
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:39:24.641] plan(): Setting new future strategy stack:
[17:39:24.641] List of future strategies:
[17:39:24.641] 1. sequential:
[17:39:24.641]    - args: function (..., envir = parent.frame())
[17:39:24.641]    - tweaked: FALSE
[17:39:24.641]    - call: future::plan("sequential")
[17:39:24.651] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[17:39:24.712] plan(): Setting new future strategy stack:
[17:39:24.712] List of future strategies:
[17:39:24.712] 1. sequential:
[17:39:24.712]    - args: function (..., envir = parent.frame())
[17:39:24.712]    - tweaked: FALSE
[17:39:24.712]    - call: plan(strategy)
[17:39:24.722] plan(): nbrOfWorkers() = 1
[17:39:24.723] future_by_internal() ...
[17:39:24.724] future_lapply() ...
[17:39:24.728] Number of chunks: 1
[17:39:24.728] getGlobalsAndPackagesXApply() ...
[17:39:24.728]  - future.globals: TRUE
[17:39:24.729] getGlobalsAndPackages() ...
[17:39:24.729] Searching for globals...
[17:39:24.731] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:24.731] Searching for globals ... DONE
[17:39:24.732] Resolving globals: FALSE
[17:39:24.733] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:24.733] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:24.733] - globals: [1] ‘FUN’
[17:39:24.733] 
[17:39:24.733] getGlobalsAndPackages() ... DONE
[17:39:24.733]  - globals found/used: [n=1] ‘FUN’
[17:39:24.734]  - needed namespaces: [n=0] 
[17:39:24.734] Finding globals ... DONE
[17:39:24.734]  - use_args: TRUE
[17:39:24.734]  - Getting '...' globals ...
[17:39:24.735] resolve() on list ...
[17:39:24.735]  recursive: 0
[17:39:24.735]  length: 1
[17:39:24.735]  elements: ‘...’
[17:39:24.735]  length: 0 (resolved future 1)
[17:39:24.735] resolve() on list ... DONE
[17:39:24.735]    - '...' content: [n=0] 
[17:39:24.736] List of 1
[17:39:24.736]  $ ...: list()
[17:39:24.736]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.736]  - attr(*, "where")=List of 1
[17:39:24.736]   ..$ ...:<environment: 0x56297095dce8> 
[17:39:24.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.736]  - attr(*, "resolved")= logi TRUE
[17:39:24.736]  - attr(*, "total_size")= num NA
[17:39:24.742]  - Getting '...' globals ... DONE
[17:39:24.742] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:24.743] List of 2
[17:39:24.743]  $ ...future.FUN:function (object, ...)  
[17:39:24.743]  $ ...          : list()
[17:39:24.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.743]  - attr(*, "where")=List of 2
[17:39:24.743]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:24.743]   ..$ ...          :<environment: 0x56297095dce8> 
[17:39:24.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.743]  - attr(*, "resolved")= logi FALSE
[17:39:24.743]  - attr(*, "total_size")= num 1240
[17:39:24.745] Packages to be attached in all futures: [n=0] 
[17:39:24.745] getGlobalsAndPackagesXApply() ... DONE
[17:39:24.746] Number of futures (= number of chunks): 1
[17:39:24.746] Launching 1 futures (chunks) ...
[17:39:24.746] Chunk #1 of 1 ...
[17:39:24.746]  - Finding globals in 'X' for chunk #1 ...
[17:39:24.746] getGlobalsAndPackages() ...
[17:39:24.746] Searching for globals...
[17:39:24.747] 
[17:39:24.747] Searching for globals ... DONE
[17:39:24.747] - globals: [0] <none>
[17:39:24.747] getGlobalsAndPackages() ... DONE
[17:39:24.747]    + additional globals found: [n=0] 
[17:39:24.747]    + additional namespaces needed: [n=0] 
[17:39:24.747]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:24.748]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:24.748]  - seeds: <none>
[17:39:24.748] getGlobalsAndPackages() ...
[17:39:24.748] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.748] Resolving globals: FALSE
[17:39:24.748] Tweak future expression to call with '...' arguments ...
[17:39:24.748] {
[17:39:24.748]     do.call(function(...) {
[17:39:24.748]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.748]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.748]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.748]             on.exit(options(oopts), add = TRUE)
[17:39:24.748]         }
[17:39:24.748]         {
[17:39:24.748]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.748]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.748]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.748]             })
[17:39:24.748]         }
[17:39:24.748]     }, args = future.call.arguments)
[17:39:24.748] }
[17:39:24.749] Tweak future expression to call with '...' arguments ... DONE
[17:39:24.749] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.749] 
[17:39:24.749] getGlobalsAndPackages() ... DONE
[17:39:24.750] run() for ‘Future’ ...
[17:39:24.750] - state: ‘created’
[17:39:24.750] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:24.751] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.751] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:24.751]   - Field: ‘label’
[17:39:24.751]   - Field: ‘local’
[17:39:24.751]   - Field: ‘owner’
[17:39:24.751]   - Field: ‘envir’
[17:39:24.751]   - Field: ‘packages’
[17:39:24.751]   - Field: ‘gc’
[17:39:24.751]   - Field: ‘conditions’
[17:39:24.752]   - Field: ‘expr’
[17:39:24.752]   - Field: ‘uuid’
[17:39:24.752]   - Field: ‘seed’
[17:39:24.752]   - Field: ‘version’
[17:39:24.752]   - Field: ‘result’
[17:39:24.752]   - Field: ‘asynchronous’
[17:39:24.752]   - Field: ‘calls’
[17:39:24.752]   - Field: ‘globals’
[17:39:24.752]   - Field: ‘stdout’
[17:39:24.752]   - Field: ‘earlySignal’
[17:39:24.753]   - Field: ‘lazy’
[17:39:24.753]   - Field: ‘state’
[17:39:24.753] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:24.753] - Launch lazy future ...
[17:39:24.754] Packages needed by the future expression (n = 0): <none>
[17:39:24.754] Packages needed by future strategies (n = 0): <none>
[17:39:24.755] {
[17:39:24.755]     {
[17:39:24.755]         {
[17:39:24.755]             ...future.startTime <- base::Sys.time()
[17:39:24.755]             {
[17:39:24.755]                 {
[17:39:24.755]                   {
[17:39:24.755]                     base::local({
[17:39:24.755]                       has_future <- base::requireNamespace("future", 
[17:39:24.755]                         quietly = TRUE)
[17:39:24.755]                       if (has_future) {
[17:39:24.755]                         ns <- base::getNamespace("future")
[17:39:24.755]                         version <- ns[[".package"]][["version"]]
[17:39:24.755]                         if (is.null(version)) 
[17:39:24.755]                           version <- utils::packageVersion("future")
[17:39:24.755]                       }
[17:39:24.755]                       else {
[17:39:24.755]                         version <- NULL
[17:39:24.755]                       }
[17:39:24.755]                       if (!has_future || version < "1.8.0") {
[17:39:24.755]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:24.755]                           "", base::R.version$version.string), 
[17:39:24.755]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:24.755]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:24.755]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:24.755]                             "release", "version")], collapse = " "), 
[17:39:24.755]                           hostname = base::Sys.info()[["nodename"]])
[17:39:24.755]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:24.755]                           info)
[17:39:24.755]                         info <- base::paste(info, collapse = "; ")
[17:39:24.755]                         if (!has_future) {
[17:39:24.755]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:24.755]                             info)
[17:39:24.755]                         }
[17:39:24.755]                         else {
[17:39:24.755]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:24.755]                             info, version)
[17:39:24.755]                         }
[17:39:24.755]                         base::stop(msg)
[17:39:24.755]                       }
[17:39:24.755]                     })
[17:39:24.755]                   }
[17:39:24.755]                   options(future.plan = NULL)
[17:39:24.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:24.755]                 }
[17:39:24.755]                 ...future.workdir <- getwd()
[17:39:24.755]             }
[17:39:24.755]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:24.755]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:24.755]         }
[17:39:24.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:24.755]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:24.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:24.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:24.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:24.755]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:24.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:24.755]             base::names(...future.oldOptions))
[17:39:24.755]     }
[17:39:24.755]     if (FALSE) {
[17:39:24.755]     }
[17:39:24.755]     else {
[17:39:24.755]         if (TRUE) {
[17:39:24.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:24.755]                 open = "w")
[17:39:24.755]         }
[17:39:24.755]         else {
[17:39:24.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:24.755]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:24.755]         }
[17:39:24.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:24.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:24.755]             base::sink(type = "output", split = FALSE)
[17:39:24.755]             base::close(...future.stdout)
[17:39:24.755]         }, add = TRUE)
[17:39:24.755]     }
[17:39:24.755]     ...future.frame <- base::sys.nframe()
[17:39:24.755]     ...future.conditions <- base::list()
[17:39:24.755]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:24.755]     if (FALSE) {
[17:39:24.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:24.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:24.755]     }
[17:39:24.755]     ...future.result <- base::tryCatch({
[17:39:24.755]         base::withCallingHandlers({
[17:39:24.755]             ...future.value <- base::withVisible(base::local({
[17:39:24.755]                 do.call(function(...) {
[17:39:24.755]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.755]                   if (!identical(...future.globals.maxSize.org, 
[17:39:24.755]                     ...future.globals.maxSize)) {
[17:39:24.755]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.755]                     on.exit(options(oopts), add = TRUE)
[17:39:24.755]                   }
[17:39:24.755]                   {
[17:39:24.755]                     lapply(seq_along(...future.elements_ii), 
[17:39:24.755]                       FUN = function(jj) {
[17:39:24.755]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.755]                         ...future.FUN(...future.X_jj, ...)
[17:39:24.755]                       })
[17:39:24.755]                   }
[17:39:24.755]                 }, args = future.call.arguments)
[17:39:24.755]             }))
[17:39:24.755]             future::FutureResult(value = ...future.value$value, 
[17:39:24.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.755]                   ...future.rng), globalenv = if (FALSE) 
[17:39:24.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:24.755]                     ...future.globalenv.names))
[17:39:24.755]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:24.755]         }, condition = base::local({
[17:39:24.755]             c <- base::c
[17:39:24.755]             inherits <- base::inherits
[17:39:24.755]             invokeRestart <- base::invokeRestart
[17:39:24.755]             length <- base::length
[17:39:24.755]             list <- base::list
[17:39:24.755]             seq.int <- base::seq.int
[17:39:24.755]             signalCondition <- base::signalCondition
[17:39:24.755]             sys.calls <- base::sys.calls
[17:39:24.755]             `[[` <- base::`[[`
[17:39:24.755]             `+` <- base::`+`
[17:39:24.755]             `<<-` <- base::`<<-`
[17:39:24.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:24.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:24.755]                   3L)]
[17:39:24.755]             }
[17:39:24.755]             function(cond) {
[17:39:24.755]                 is_error <- inherits(cond, "error")
[17:39:24.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:24.755]                   NULL)
[17:39:24.755]                 if (is_error) {
[17:39:24.755]                   sessionInformation <- function() {
[17:39:24.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:24.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:24.755]                       search = base::search(), system = base::Sys.info())
[17:39:24.755]                   }
[17:39:24.755]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:24.755]                     cond$call), session = sessionInformation(), 
[17:39:24.755]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:24.755]                   signalCondition(cond)
[17:39:24.755]                 }
[17:39:24.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:24.755]                 "immediateCondition"))) {
[17:39:24.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:24.755]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:24.755]                   if (TRUE && !signal) {
[17:39:24.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.755]                     {
[17:39:24.755]                       inherits <- base::inherits
[17:39:24.755]                       invokeRestart <- base::invokeRestart
[17:39:24.755]                       is.null <- base::is.null
[17:39:24.755]                       muffled <- FALSE
[17:39:24.755]                       if (inherits(cond, "message")) {
[17:39:24.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.755]                         if (muffled) 
[17:39:24.755]                           invokeRestart("muffleMessage")
[17:39:24.755]                       }
[17:39:24.755]                       else if (inherits(cond, "warning")) {
[17:39:24.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.755]                         if (muffled) 
[17:39:24.755]                           invokeRestart("muffleWarning")
[17:39:24.755]                       }
[17:39:24.755]                       else if (inherits(cond, "condition")) {
[17:39:24.755]                         if (!is.null(pattern)) {
[17:39:24.755]                           computeRestarts <- base::computeRestarts
[17:39:24.755]                           grepl <- base::grepl
[17:39:24.755]                           restarts <- computeRestarts(cond)
[17:39:24.755]                           for (restart in restarts) {
[17:39:24.755]                             name <- restart$name
[17:39:24.755]                             if (is.null(name)) 
[17:39:24.755]                               next
[17:39:24.755]                             if (!grepl(pattern, name)) 
[17:39:24.755]                               next
[17:39:24.755]                             invokeRestart(restart)
[17:39:24.755]                             muffled <- TRUE
[17:39:24.755]                             break
[17:39:24.755]                           }
[17:39:24.755]                         }
[17:39:24.755]                       }
[17:39:24.755]                       invisible(muffled)
[17:39:24.755]                     }
[17:39:24.755]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.755]                   }
[17:39:24.755]                 }
[17:39:24.755]                 else {
[17:39:24.755]                   if (TRUE) {
[17:39:24.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.755]                     {
[17:39:24.755]                       inherits <- base::inherits
[17:39:24.755]                       invokeRestart <- base::invokeRestart
[17:39:24.755]                       is.null <- base::is.null
[17:39:24.755]                       muffled <- FALSE
[17:39:24.755]                       if (inherits(cond, "message")) {
[17:39:24.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.755]                         if (muffled) 
[17:39:24.755]                           invokeRestart("muffleMessage")
[17:39:24.755]                       }
[17:39:24.755]                       else if (inherits(cond, "warning")) {
[17:39:24.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.755]                         if (muffled) 
[17:39:24.755]                           invokeRestart("muffleWarning")
[17:39:24.755]                       }
[17:39:24.755]                       else if (inherits(cond, "condition")) {
[17:39:24.755]                         if (!is.null(pattern)) {
[17:39:24.755]                           computeRestarts <- base::computeRestarts
[17:39:24.755]                           grepl <- base::grepl
[17:39:24.755]                           restarts <- computeRestarts(cond)
[17:39:24.755]                           for (restart in restarts) {
[17:39:24.755]                             name <- restart$name
[17:39:24.755]                             if (is.null(name)) 
[17:39:24.755]                               next
[17:39:24.755]                             if (!grepl(pattern, name)) 
[17:39:24.755]                               next
[17:39:24.755]                             invokeRestart(restart)
[17:39:24.755]                             muffled <- TRUE
[17:39:24.755]                             break
[17:39:24.755]                           }
[17:39:24.755]                         }
[17:39:24.755]                       }
[17:39:24.755]                       invisible(muffled)
[17:39:24.755]                     }
[17:39:24.755]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.755]                   }
[17:39:24.755]                 }
[17:39:24.755]             }
[17:39:24.755]         }))
[17:39:24.755]     }, error = function(ex) {
[17:39:24.755]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:24.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.755]                 ...future.rng), started = ...future.startTime, 
[17:39:24.755]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:24.755]             version = "1.8"), class = "FutureResult")
[17:39:24.755]     }, finally = {
[17:39:24.755]         if (!identical(...future.workdir, getwd())) 
[17:39:24.755]             setwd(...future.workdir)
[17:39:24.755]         {
[17:39:24.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:24.755]                 ...future.oldOptions$nwarnings <- NULL
[17:39:24.755]             }
[17:39:24.755]             base::options(...future.oldOptions)
[17:39:24.755]             if (.Platform$OS.type == "windows") {
[17:39:24.755]                 old_names <- names(...future.oldEnvVars)
[17:39:24.755]                 envs <- base::Sys.getenv()
[17:39:24.755]                 names <- names(envs)
[17:39:24.755]                 common <- intersect(names, old_names)
[17:39:24.755]                 added <- setdiff(names, old_names)
[17:39:24.755]                 removed <- setdiff(old_names, names)
[17:39:24.755]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:24.755]                   envs[common]]
[17:39:24.755]                 NAMES <- toupper(changed)
[17:39:24.755]                 args <- list()
[17:39:24.755]                 for (kk in seq_along(NAMES)) {
[17:39:24.755]                   name <- changed[[kk]]
[17:39:24.755]                   NAME <- NAMES[[kk]]
[17:39:24.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.755]                     next
[17:39:24.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.755]                 }
[17:39:24.755]                 NAMES <- toupper(added)
[17:39:24.755]                 for (kk in seq_along(NAMES)) {
[17:39:24.755]                   name <- added[[kk]]
[17:39:24.755]                   NAME <- NAMES[[kk]]
[17:39:24.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.755]                     next
[17:39:24.755]                   args[[name]] <- ""
[17:39:24.755]                 }
[17:39:24.755]                 NAMES <- toupper(removed)
[17:39:24.755]                 for (kk in seq_along(NAMES)) {
[17:39:24.755]                   name <- removed[[kk]]
[17:39:24.755]                   NAME <- NAMES[[kk]]
[17:39:24.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.755]                     next
[17:39:24.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.755]                 }
[17:39:24.755]                 if (length(args) > 0) 
[17:39:24.755]                   base::do.call(base::Sys.setenv, args = args)
[17:39:24.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:24.755]             }
[17:39:24.755]             else {
[17:39:24.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:24.755]             }
[17:39:24.755]             {
[17:39:24.755]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:24.755]                   0L) {
[17:39:24.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:24.755]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:24.755]                   base::options(opts)
[17:39:24.755]                 }
[17:39:24.755]                 {
[17:39:24.755]                   {
[17:39:24.755]                     NULL
[17:39:24.755]                     RNGkind("Mersenne-Twister")
[17:39:24.755]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:24.755]                       inherits = FALSE)
[17:39:24.755]                   }
[17:39:24.755]                   options(future.plan = NULL)
[17:39:24.755]                   if (is.na(NA_character_)) 
[17:39:24.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:24.755]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:24.755]                   {
[17:39:24.755]                     future <- SequentialFuture(..., envir = envir)
[17:39:24.755]                     if (!future$lazy) 
[17:39:24.755]                       future <- run(future)
[17:39:24.755]                     invisible(future)
[17:39:24.755]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:24.755]                 }
[17:39:24.755]             }
[17:39:24.755]         }
[17:39:24.755]     })
[17:39:24.755]     if (TRUE) {
[17:39:24.755]         base::sink(type = "output", split = FALSE)
[17:39:24.755]         if (TRUE) {
[17:39:24.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:24.755]         }
[17:39:24.755]         else {
[17:39:24.755]             ...future.result["stdout"] <- base::list(NULL)
[17:39:24.755]         }
[17:39:24.755]         base::close(...future.stdout)
[17:39:24.755]         ...future.stdout <- NULL
[17:39:24.755]     }
[17:39:24.755]     ...future.result$conditions <- ...future.conditions
[17:39:24.755]     ...future.result$finished <- base::Sys.time()
[17:39:24.755]     ...future.result
[17:39:24.755] }
[17:39:24.756] assign_globals() ...
[17:39:24.757] List of 5
[17:39:24.757]  $ ...future.FUN            :function (object, ...)  
[17:39:24.757]  $ future.call.arguments    : list()
[17:39:24.757]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.757]  $ ...future.elements_ii    :List of 3
[17:39:24.757]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:24.757]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:24.757]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.757]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:24.757]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:24.757]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.757]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:24.757]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:24.757]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.757]  $ ...future.seeds_ii       : NULL
[17:39:24.757]  $ ...future.globals.maxSize: NULL
[17:39:24.757]  - attr(*, "resolved")= logi FALSE
[17:39:24.757]  - attr(*, "total_size")= num 1240
[17:39:24.757]  - attr(*, "where")=List of 5
[17:39:24.757]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:24.757]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:24.757]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:24.757]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:24.757]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:24.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.757]  - attr(*, "already-done")= logi TRUE
[17:39:24.764] - copied ‘...future.FUN’ to environment
[17:39:24.764] - copied ‘future.call.arguments’ to environment
[17:39:24.764] - copied ‘...future.elements_ii’ to environment
[17:39:24.764] - copied ‘...future.seeds_ii’ to environment
[17:39:24.764] - copied ‘...future.globals.maxSize’ to environment
[17:39:24.764] assign_globals() ... done
[17:39:24.765] plan(): Setting new future strategy stack:
[17:39:24.765] List of future strategies:
[17:39:24.765] 1. sequential:
[17:39:24.765]    - args: function (..., envir = parent.frame())
[17:39:24.765]    - tweaked: FALSE
[17:39:24.765]    - call: NULL
[17:39:24.765] plan(): nbrOfWorkers() = 1
[17:39:24.768] plan(): Setting new future strategy stack:
[17:39:24.769] List of future strategies:
[17:39:24.769] 1. sequential:
[17:39:24.769]    - args: function (..., envir = parent.frame())
[17:39:24.769]    - tweaked: FALSE
[17:39:24.769]    - call: plan(strategy)
[17:39:24.770] plan(): nbrOfWorkers() = 1
[17:39:24.770] SequentialFuture started (and completed)
[17:39:24.770] - Launch lazy future ... done
[17:39:24.770] run() for ‘SequentialFuture’ ... done
[17:39:24.771] Created future:
[17:39:24.771] SequentialFuture:
[17:39:24.771] Label: ‘future_by-1’
[17:39:24.771] Expression:
[17:39:24.771] {
[17:39:24.771]     do.call(function(...) {
[17:39:24.771]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.771]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.771]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.771]             on.exit(options(oopts), add = TRUE)
[17:39:24.771]         }
[17:39:24.771]         {
[17:39:24.771]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.771]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.771]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.771]             })
[17:39:24.771]         }
[17:39:24.771]     }, args = future.call.arguments)
[17:39:24.771] }
[17:39:24.771] Lazy evaluation: FALSE
[17:39:24.771] Asynchronous evaluation: FALSE
[17:39:24.771] Local evaluation: TRUE
[17:39:24.771] Environment: R_GlobalEnv
[17:39:24.771] Capture standard output: TRUE
[17:39:24.771] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:24.771] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:24.771] Packages: <none>
[17:39:24.771] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:24.771] Resolved: TRUE
[17:39:24.771] Value: 4.62 KiB of class ‘list’
[17:39:24.771] Early signaling: FALSE
[17:39:24.771] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:24.771] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.772] Chunk #1 of 1 ... DONE
[17:39:24.773] Launching 1 futures (chunks) ... DONE
[17:39:24.773] Resolving 1 futures (chunks) ...
[17:39:24.773] resolve() on list ...
[17:39:24.773]  recursive: 0
[17:39:24.773]  length: 1
[17:39:24.773] 
[17:39:24.773] resolved() for ‘SequentialFuture’ ...
[17:39:24.773] - state: ‘finished’
[17:39:24.774] - run: TRUE
[17:39:24.774] - result: ‘FutureResult’
[17:39:24.774] resolved() for ‘SequentialFuture’ ... done
[17:39:24.774] Future #1
[17:39:24.774] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:24.774] - nx: 1
[17:39:24.774] - relay: TRUE
[17:39:24.774] - stdout: TRUE
[17:39:24.775] - signal: TRUE
[17:39:24.775] - resignal: FALSE
[17:39:24.775] - force: TRUE
[17:39:24.775] - relayed: [n=1] FALSE
[17:39:24.775] - queued futures: [n=1] FALSE
[17:39:24.775]  - until=1
[17:39:24.775]  - relaying element #1
[17:39:24.775] - relayed: [n=1] TRUE
[17:39:24.775] - queued futures: [n=1] TRUE
[17:39:24.776] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:24.776]  length: 0 (resolved future 1)
[17:39:24.776] Relaying remaining futures
[17:39:24.776] signalConditionsASAP(NULL, pos=0) ...
[17:39:24.776] - nx: 1
[17:39:24.776] - relay: TRUE
[17:39:24.776] - stdout: TRUE
[17:39:24.776] - signal: TRUE
[17:39:24.776] - resignal: FALSE
[17:39:24.776] - force: TRUE
[17:39:24.777] - relayed: [n=1] TRUE
[17:39:24.777] - queued futures: [n=1] TRUE
 - flush all
[17:39:24.777] - relayed: [n=1] TRUE
[17:39:24.777] - queued futures: [n=1] TRUE
[17:39:24.777] signalConditionsASAP(NULL, pos=0) ... done
[17:39:24.777] resolve() on list ... DONE
[17:39:24.777]  - Number of value chunks collected: 1
[17:39:24.777] Resolving 1 futures (chunks) ... DONE
[17:39:24.777] Reducing values from 1 chunks ...
[17:39:24.777]  - Number of values collected after concatenation: 3
[17:39:24.778]  - Number of values expected: 3
[17:39:24.778] Reducing values from 1 chunks ... DONE
[17:39:24.778] future_lapply() ... DONE
[17:39:24.778] future_by_internal() ... DONE
[17:39:24.779] future_by_internal() ...
[17:39:24.779] future_lapply() ...
[17:39:24.779] Number of chunks: 1
[17:39:24.780] getGlobalsAndPackagesXApply() ...
[17:39:24.780]  - future.globals: TRUE
[17:39:24.780] getGlobalsAndPackages() ...
[17:39:24.780] Searching for globals...
[17:39:24.781] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:24.781] Searching for globals ... DONE
[17:39:24.781] Resolving globals: FALSE
[17:39:24.781] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:24.782] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:24.782] - globals: [1] ‘FUN’
[17:39:24.782] 
[17:39:24.782] getGlobalsAndPackages() ... DONE
[17:39:24.782]  - globals found/used: [n=1] ‘FUN’
[17:39:24.782]  - needed namespaces: [n=0] 
[17:39:24.782] Finding globals ... DONE
[17:39:24.782]  - use_args: TRUE
[17:39:24.783]  - Getting '...' globals ...
[17:39:24.783] resolve() on list ...
[17:39:24.783]  recursive: 0
[17:39:24.783]  length: 1
[17:39:24.783]  elements: ‘...’
[17:39:24.783]  length: 0 (resolved future 1)
[17:39:24.783] resolve() on list ... DONE
[17:39:24.784]    - '...' content: [n=1] ‘digits’
[17:39:24.784] List of 1
[17:39:24.784]  $ ...:List of 1
[17:39:24.784]   ..$ digits: int 2
[17:39:24.784]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.784]  - attr(*, "where")=List of 1
[17:39:24.784]   ..$ ...:<environment: 0x56296ea77600> 
[17:39:24.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.784]  - attr(*, "resolved")= logi TRUE
[17:39:24.784]  - attr(*, "total_size")= num NA
[17:39:24.787]  - Getting '...' globals ... DONE
[17:39:24.787] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:24.787] List of 2
[17:39:24.787]  $ ...future.FUN:function (object, ...)  
[17:39:24.787]  $ ...          :List of 1
[17:39:24.787]   ..$ digits: int 2
[17:39:24.787]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.787]  - attr(*, "where")=List of 2
[17:39:24.787]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:24.787]   ..$ ...          :<environment: 0x56296ea77600> 
[17:39:24.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.787]  - attr(*, "resolved")= logi FALSE
[17:39:24.787]  - attr(*, "total_size")= num 1296
[17:39:24.790] Packages to be attached in all futures: [n=0] 
[17:39:24.790] getGlobalsAndPackagesXApply() ... DONE
[17:39:24.790] Number of futures (= number of chunks): 1
[17:39:24.790] Launching 1 futures (chunks) ...
[17:39:24.790] Chunk #1 of 1 ...
[17:39:24.790]  - Finding globals in 'X' for chunk #1 ...
[17:39:24.791] getGlobalsAndPackages() ...
[17:39:24.791] Searching for globals...
[17:39:24.791] 
[17:39:24.791] Searching for globals ... DONE
[17:39:24.791] - globals: [0] <none>
[17:39:24.791] getGlobalsAndPackages() ... DONE
[17:39:24.791]    + additional globals found: [n=0] 
[17:39:24.791]    + additional namespaces needed: [n=0] 
[17:39:24.791]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:24.792]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[17:39:24.792]  - seeds: <none>
[17:39:24.793] getGlobalsAndPackages() ...
[17:39:24.793] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.794] Resolving globals: FALSE
[17:39:24.794] Tweak future expression to call with '...' arguments ...
[17:39:24.794] {
[17:39:24.794]     do.call(function(...) {
[17:39:24.794]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.794]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.794]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.794]             on.exit(options(oopts), add = TRUE)
[17:39:24.794]         }
[17:39:24.794]         {
[17:39:24.794]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.794]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.794]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.794]             })
[17:39:24.794]         }
[17:39:24.794]     }, args = future.call.arguments)
[17:39:24.794] }
[17:39:24.794] Tweak future expression to call with '...' arguments ... DONE
[17:39:24.794] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.795] 
[17:39:24.795] getGlobalsAndPackages() ... DONE
[17:39:24.795] run() for ‘Future’ ...
[17:39:24.795] - state: ‘created’
[17:39:24.795] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:24.795] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:24.796]   - Field: ‘label’
[17:39:24.796]   - Field: ‘local’
[17:39:24.796]   - Field: ‘owner’
[17:39:24.796]   - Field: ‘envir’
[17:39:24.796]   - Field: ‘packages’
[17:39:24.796]   - Field: ‘gc’
[17:39:24.796]   - Field: ‘conditions’
[17:39:24.796]   - Field: ‘expr’
[17:39:24.796]   - Field: ‘uuid’
[17:39:24.797]   - Field: ‘seed’
[17:39:24.797]   - Field: ‘version’
[17:39:24.797]   - Field: ‘result’
[17:39:24.797]   - Field: ‘asynchronous’
[17:39:24.797]   - Field: ‘calls’
[17:39:24.797]   - Field: ‘globals’
[17:39:24.797]   - Field: ‘stdout’
[17:39:24.797]   - Field: ‘earlySignal’
[17:39:24.797]   - Field: ‘lazy’
[17:39:24.797]   - Field: ‘state’
[17:39:24.797] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:24.798] - Launch lazy future ...
[17:39:24.798] Packages needed by the future expression (n = 0): <none>
[17:39:24.798] Packages needed by future strategies (n = 0): <none>
[17:39:24.798] {
[17:39:24.798]     {
[17:39:24.798]         {
[17:39:24.798]             ...future.startTime <- base::Sys.time()
[17:39:24.798]             {
[17:39:24.798]                 {
[17:39:24.798]                   {
[17:39:24.798]                     base::local({
[17:39:24.798]                       has_future <- base::requireNamespace("future", 
[17:39:24.798]                         quietly = TRUE)
[17:39:24.798]                       if (has_future) {
[17:39:24.798]                         ns <- base::getNamespace("future")
[17:39:24.798]                         version <- ns[[".package"]][["version"]]
[17:39:24.798]                         if (is.null(version)) 
[17:39:24.798]                           version <- utils::packageVersion("future")
[17:39:24.798]                       }
[17:39:24.798]                       else {
[17:39:24.798]                         version <- NULL
[17:39:24.798]                       }
[17:39:24.798]                       if (!has_future || version < "1.8.0") {
[17:39:24.798]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:24.798]                           "", base::R.version$version.string), 
[17:39:24.798]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:24.798]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:24.798]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:24.798]                             "release", "version")], collapse = " "), 
[17:39:24.798]                           hostname = base::Sys.info()[["nodename"]])
[17:39:24.798]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:24.798]                           info)
[17:39:24.798]                         info <- base::paste(info, collapse = "; ")
[17:39:24.798]                         if (!has_future) {
[17:39:24.798]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:24.798]                             info)
[17:39:24.798]                         }
[17:39:24.798]                         else {
[17:39:24.798]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:24.798]                             info, version)
[17:39:24.798]                         }
[17:39:24.798]                         base::stop(msg)
[17:39:24.798]                       }
[17:39:24.798]                     })
[17:39:24.798]                   }
[17:39:24.798]                   options(future.plan = NULL)
[17:39:24.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:24.798]                 }
[17:39:24.798]                 ...future.workdir <- getwd()
[17:39:24.798]             }
[17:39:24.798]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:24.798]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:24.798]         }
[17:39:24.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:24.798]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[17:39:24.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:24.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:24.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:24.798]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:24.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:24.798]             base::names(...future.oldOptions))
[17:39:24.798]     }
[17:39:24.798]     if (FALSE) {
[17:39:24.798]     }
[17:39:24.798]     else {
[17:39:24.798]         if (TRUE) {
[17:39:24.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:24.798]                 open = "w")
[17:39:24.798]         }
[17:39:24.798]         else {
[17:39:24.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:24.798]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:24.798]         }
[17:39:24.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:24.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:24.798]             base::sink(type = "output", split = FALSE)
[17:39:24.798]             base::close(...future.stdout)
[17:39:24.798]         }, add = TRUE)
[17:39:24.798]     }
[17:39:24.798]     ...future.frame <- base::sys.nframe()
[17:39:24.798]     ...future.conditions <- base::list()
[17:39:24.798]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:24.798]     if (FALSE) {
[17:39:24.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:24.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:24.798]     }
[17:39:24.798]     ...future.result <- base::tryCatch({
[17:39:24.798]         base::withCallingHandlers({
[17:39:24.798]             ...future.value <- base::withVisible(base::local({
[17:39:24.798]                 do.call(function(...) {
[17:39:24.798]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.798]                   if (!identical(...future.globals.maxSize.org, 
[17:39:24.798]                     ...future.globals.maxSize)) {
[17:39:24.798]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.798]                     on.exit(options(oopts), add = TRUE)
[17:39:24.798]                   }
[17:39:24.798]                   {
[17:39:24.798]                     lapply(seq_along(...future.elements_ii), 
[17:39:24.798]                       FUN = function(jj) {
[17:39:24.798]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.798]                         ...future.FUN(...future.X_jj, ...)
[17:39:24.798]                       })
[17:39:24.798]                   }
[17:39:24.798]                 }, args = future.call.arguments)
[17:39:24.798]             }))
[17:39:24.798]             future::FutureResult(value = ...future.value$value, 
[17:39:24.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.798]                   ...future.rng), globalenv = if (FALSE) 
[17:39:24.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:24.798]                     ...future.globalenv.names))
[17:39:24.798]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:24.798]         }, condition = base::local({
[17:39:24.798]             c <- base::c
[17:39:24.798]             inherits <- base::inherits
[17:39:24.798]             invokeRestart <- base::invokeRestart
[17:39:24.798]             length <- base::length
[17:39:24.798]             list <- base::list
[17:39:24.798]             seq.int <- base::seq.int
[17:39:24.798]             signalCondition <- base::signalCondition
[17:39:24.798]             sys.calls <- base::sys.calls
[17:39:24.798]             `[[` <- base::`[[`
[17:39:24.798]             `+` <- base::`+`
[17:39:24.798]             `<<-` <- base::`<<-`
[17:39:24.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:24.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:24.798]                   3L)]
[17:39:24.798]             }
[17:39:24.798]             function(cond) {
[17:39:24.798]                 is_error <- inherits(cond, "error")
[17:39:24.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:24.798]                   NULL)
[17:39:24.798]                 if (is_error) {
[17:39:24.798]                   sessionInformation <- function() {
[17:39:24.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:24.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:24.798]                       search = base::search(), system = base::Sys.info())
[17:39:24.798]                   }
[17:39:24.798]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:24.798]                     cond$call), session = sessionInformation(), 
[17:39:24.798]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:24.798]                   signalCondition(cond)
[17:39:24.798]                 }
[17:39:24.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:24.798]                 "immediateCondition"))) {
[17:39:24.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:24.798]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:24.798]                   if (TRUE && !signal) {
[17:39:24.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.798]                     {
[17:39:24.798]                       inherits <- base::inherits
[17:39:24.798]                       invokeRestart <- base::invokeRestart
[17:39:24.798]                       is.null <- base::is.null
[17:39:24.798]                       muffled <- FALSE
[17:39:24.798]                       if (inherits(cond, "message")) {
[17:39:24.798]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.798]                         if (muffled) 
[17:39:24.798]                           invokeRestart("muffleMessage")
[17:39:24.798]                       }
[17:39:24.798]                       else if (inherits(cond, "warning")) {
[17:39:24.798]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.798]                         if (muffled) 
[17:39:24.798]                           invokeRestart("muffleWarning")
[17:39:24.798]                       }
[17:39:24.798]                       else if (inherits(cond, "condition")) {
[17:39:24.798]                         if (!is.null(pattern)) {
[17:39:24.798]                           computeRestarts <- base::computeRestarts
[17:39:24.798]                           grepl <- base::grepl
[17:39:24.798]                           restarts <- computeRestarts(cond)
[17:39:24.798]                           for (restart in restarts) {
[17:39:24.798]                             name <- restart$name
[17:39:24.798]                             if (is.null(name)) 
[17:39:24.798]                               next
[17:39:24.798]                             if (!grepl(pattern, name)) 
[17:39:24.798]                               next
[17:39:24.798]                             invokeRestart(restart)
[17:39:24.798]                             muffled <- TRUE
[17:39:24.798]                             break
[17:39:24.798]                           }
[17:39:24.798]                         }
[17:39:24.798]                       }
[17:39:24.798]                       invisible(muffled)
[17:39:24.798]                     }
[17:39:24.798]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.798]                   }
[17:39:24.798]                 }
[17:39:24.798]                 else {
[17:39:24.798]                   if (TRUE) {
[17:39:24.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.798]                     {
[17:39:24.798]                       inherits <- base::inherits
[17:39:24.798]                       invokeRestart <- base::invokeRestart
[17:39:24.798]                       is.null <- base::is.null
[17:39:24.798]                       muffled <- FALSE
[17:39:24.798]                       if (inherits(cond, "message")) {
[17:39:24.798]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.798]                         if (muffled) 
[17:39:24.798]                           invokeRestart("muffleMessage")
[17:39:24.798]                       }
[17:39:24.798]                       else if (inherits(cond, "warning")) {
[17:39:24.798]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.798]                         if (muffled) 
[17:39:24.798]                           invokeRestart("muffleWarning")
[17:39:24.798]                       }
[17:39:24.798]                       else if (inherits(cond, "condition")) {
[17:39:24.798]                         if (!is.null(pattern)) {
[17:39:24.798]                           computeRestarts <- base::computeRestarts
[17:39:24.798]                           grepl <- base::grepl
[17:39:24.798]                           restarts <- computeRestarts(cond)
[17:39:24.798]                           for (restart in restarts) {
[17:39:24.798]                             name <- restart$name
[17:39:24.798]                             if (is.null(name)) 
[17:39:24.798]                               next
[17:39:24.798]                             if (!grepl(pattern, name)) 
[17:39:24.798]                               next
[17:39:24.798]                             invokeRestart(restart)
[17:39:24.798]                             muffled <- TRUE
[17:39:24.798]                             break
[17:39:24.798]                           }
[17:39:24.798]                         }
[17:39:24.798]                       }
[17:39:24.798]                       invisible(muffled)
[17:39:24.798]                     }
[17:39:24.798]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.798]                   }
[17:39:24.798]                 }
[17:39:24.798]             }
[17:39:24.798]         }))
[17:39:24.798]     }, error = function(ex) {
[17:39:24.798]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:24.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.798]                 ...future.rng), started = ...future.startTime, 
[17:39:24.798]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:24.798]             version = "1.8"), class = "FutureResult")
[17:39:24.798]     }, finally = {
[17:39:24.798]         if (!identical(...future.workdir, getwd())) 
[17:39:24.798]             setwd(...future.workdir)
[17:39:24.798]         {
[17:39:24.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:24.798]                 ...future.oldOptions$nwarnings <- NULL
[17:39:24.798]             }
[17:39:24.798]             base::options(...future.oldOptions)
[17:39:24.798]             if (.Platform$OS.type == "windows") {
[17:39:24.798]                 old_names <- names(...future.oldEnvVars)
[17:39:24.798]                 envs <- base::Sys.getenv()
[17:39:24.798]                 names <- names(envs)
[17:39:24.798]                 common <- intersect(names, old_names)
[17:39:24.798]                 added <- setdiff(names, old_names)
[17:39:24.798]                 removed <- setdiff(old_names, names)
[17:39:24.798]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:24.798]                   envs[common]]
[17:39:24.798]                 NAMES <- toupper(changed)
[17:39:24.798]                 args <- list()
[17:39:24.798]                 for (kk in seq_along(NAMES)) {
[17:39:24.798]                   name <- changed[[kk]]
[17:39:24.798]                   NAME <- NAMES[[kk]]
[17:39:24.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.798]                     next
[17:39:24.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.798]                 }
[17:39:24.798]                 NAMES <- toupper(added)
[17:39:24.798]                 for (kk in seq_along(NAMES)) {
[17:39:24.798]                   name <- added[[kk]]
[17:39:24.798]                   NAME <- NAMES[[kk]]
[17:39:24.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.798]                     next
[17:39:24.798]                   args[[name]] <- ""
[17:39:24.798]                 }
[17:39:24.798]                 NAMES <- toupper(removed)
[17:39:24.798]                 for (kk in seq_along(NAMES)) {
[17:39:24.798]                   name <- removed[[kk]]
[17:39:24.798]                   NAME <- NAMES[[kk]]
[17:39:24.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.798]                     next
[17:39:24.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.798]                 }
[17:39:24.798]                 if (length(args) > 0) 
[17:39:24.798]                   base::do.call(base::Sys.setenv, args = args)
[17:39:24.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:24.798]             }
[17:39:24.798]             else {
[17:39:24.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:24.798]             }
[17:39:24.798]             {
[17:39:24.798]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:24.798]                   0L) {
[17:39:24.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:24.798]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:24.798]                   base::options(opts)
[17:39:24.798]                 }
[17:39:24.798]                 {
[17:39:24.798]                   {
[17:39:24.798]                     NULL
[17:39:24.798]                     RNGkind("Mersenne-Twister")
[17:39:24.798]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:24.798]                       inherits = FALSE)
[17:39:24.798]                   }
[17:39:24.798]                   options(future.plan = NULL)
[17:39:24.798]                   if (is.na(NA_character_)) 
[17:39:24.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:24.798]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:24.798]                   {
[17:39:24.798]                     future <- SequentialFuture(..., envir = envir)
[17:39:24.798]                     if (!future$lazy) 
[17:39:24.798]                       future <- run(future)
[17:39:24.798]                     invisible(future)
[17:39:24.798]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:24.798]                 }
[17:39:24.798]             }
[17:39:24.798]         }
[17:39:24.798]     })
[17:39:24.798]     if (TRUE) {
[17:39:24.798]         base::sink(type = "output", split = FALSE)
[17:39:24.798]         if (TRUE) {
[17:39:24.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:24.798]         }
[17:39:24.798]         else {
[17:39:24.798]             ...future.result["stdout"] <- base::list(NULL)
[17:39:24.798]         }
[17:39:24.798]         base::close(...future.stdout)
[17:39:24.798]         ...future.stdout <- NULL
[17:39:24.798]     }
[17:39:24.798]     ...future.result$conditions <- ...future.conditions
[17:39:24.798]     ...future.result$finished <- base::Sys.time()
[17:39:24.798]     ...future.result
[17:39:24.798] }
[17:39:24.800] assign_globals() ...
[17:39:24.800] List of 5
[17:39:24.800]  $ ...future.FUN            :function (object, ...)  
[17:39:24.800]  $ future.call.arguments    :List of 1
[17:39:24.800]   ..$ digits: int 2
[17:39:24.800]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.800]  $ ...future.elements_ii    :List of 6
[17:39:24.800]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:39:24.800]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:39:24.800]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:39:24.800]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:39:24.800]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:39:24.800]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:39:24.800]  $ ...future.seeds_ii       : NULL
[17:39:24.800]  $ ...future.globals.maxSize: NULL
[17:39:24.800]  - attr(*, "resolved")= logi FALSE
[17:39:24.800]  - attr(*, "total_size")= num 1296
[17:39:24.800]  - attr(*, "where")=List of 5
[17:39:24.800]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:24.800]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:24.800]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:24.800]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:24.800]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:24.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.800]  - attr(*, "already-done")= logi TRUE
[17:39:24.807] - copied ‘...future.FUN’ to environment
[17:39:24.807] - copied ‘future.call.arguments’ to environment
[17:39:24.807] - copied ‘...future.elements_ii’ to environment
[17:39:24.807] - copied ‘...future.seeds_ii’ to environment
[17:39:24.807] - copied ‘...future.globals.maxSize’ to environment
[17:39:24.807] assign_globals() ... done
[17:39:24.808] plan(): Setting new future strategy stack:
[17:39:24.808] List of future strategies:
[17:39:24.808] 1. sequential:
[17:39:24.808]    - args: function (..., envir = parent.frame())
[17:39:24.808]    - tweaked: FALSE
[17:39:24.808]    - call: NULL
[17:39:24.808] plan(): nbrOfWorkers() = 1
[17:39:24.809] plan(): Setting new future strategy stack:
[17:39:24.810] List of future strategies:
[17:39:24.810] 1. sequential:
[17:39:24.810]    - args: function (..., envir = parent.frame())
[17:39:24.810]    - tweaked: FALSE
[17:39:24.810]    - call: plan(strategy)
[17:39:24.810] plan(): nbrOfWorkers() = 1
[17:39:24.810] SequentialFuture started (and completed)
[17:39:24.810] - Launch lazy future ... done
[17:39:24.810] run() for ‘SequentialFuture’ ... done
[17:39:24.810] Created future:
[17:39:24.811] SequentialFuture:
[17:39:24.811] Label: ‘future_by-1’
[17:39:24.811] Expression:
[17:39:24.811] {
[17:39:24.811]     do.call(function(...) {
[17:39:24.811]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.811]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.811]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.811]             on.exit(options(oopts), add = TRUE)
[17:39:24.811]         }
[17:39:24.811]         {
[17:39:24.811]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.811]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.811]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.811]             })
[17:39:24.811]         }
[17:39:24.811]     }, args = future.call.arguments)
[17:39:24.811] }
[17:39:24.811] Lazy evaluation: FALSE
[17:39:24.811] Asynchronous evaluation: FALSE
[17:39:24.811] Local evaluation: TRUE
[17:39:24.811] Environment: R_GlobalEnv
[17:39:24.811] Capture standard output: TRUE
[17:39:24.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:24.811] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:24.811] Packages: <none>
[17:39:24.811] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:24.811] Resolved: TRUE
[17:39:24.811] Value: 5.48 KiB of class ‘list’
[17:39:24.811] Early signaling: FALSE
[17:39:24.811] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:24.811] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.812] Chunk #1 of 1 ... DONE
[17:39:24.812] Launching 1 futures (chunks) ... DONE
[17:39:24.812] Resolving 1 futures (chunks) ...
[17:39:24.812] resolve() on list ...
[17:39:24.812]  recursive: 0
[17:39:24.812]  length: 1
[17:39:24.812] 
[17:39:24.812] resolved() for ‘SequentialFuture’ ...
[17:39:24.812] - state: ‘finished’
[17:39:24.812] - run: TRUE
[17:39:24.813] - result: ‘FutureResult’
[17:39:24.813] resolved() for ‘SequentialFuture’ ... done
[17:39:24.813] Future #1
[17:39:24.813] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:24.813] - nx: 1
[17:39:24.813] - relay: TRUE
[17:39:24.813] - stdout: TRUE
[17:39:24.813] - signal: TRUE
[17:39:24.813] - resignal: FALSE
[17:39:24.813] - force: TRUE
[17:39:24.813] - relayed: [n=1] FALSE
[17:39:24.814] - queued futures: [n=1] FALSE
[17:39:24.814]  - until=1
[17:39:24.814]  - relaying element #1
[17:39:24.814] - relayed: [n=1] TRUE
[17:39:24.814] - queued futures: [n=1] TRUE
[17:39:24.814] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:24.814]  length: 0 (resolved future 1)
[17:39:24.814] Relaying remaining futures
[17:39:24.814] signalConditionsASAP(NULL, pos=0) ...
[17:39:24.814] - nx: 1
[17:39:24.815] - relay: TRUE
[17:39:24.815] - stdout: TRUE
[17:39:24.815] - signal: TRUE
[17:39:24.815] - resignal: FALSE
[17:39:24.815] - force: TRUE
[17:39:24.815] - relayed: [n=1] TRUE
[17:39:24.815] - queued futures: [n=1] TRUE
 - flush all
[17:39:24.815] - relayed: [n=1] TRUE
[17:39:24.817] - queued futures: [n=1] TRUE
[17:39:24.817] signalConditionsASAP(NULL, pos=0) ... done
[17:39:24.817] resolve() on list ... DONE
[17:39:24.817]  - Number of value chunks collected: 1
[17:39:24.817] Resolving 1 futures (chunks) ... DONE
[17:39:24.817] Reducing values from 1 chunks ...
[17:39:24.817]  - Number of values collected after concatenation: 6
[17:39:24.817]  - Number of values expected: 6
[17:39:24.818] Reducing values from 1 chunks ... DONE
[17:39:24.818] future_lapply() ... DONE
[17:39:24.818] future_by_internal() ... DONE
[17:39:24.821] future_by_internal() ...
[17:39:24.821] future_lapply() ...
[17:39:24.822] Number of chunks: 1
[17:39:24.822] getGlobalsAndPackagesXApply() ...
[17:39:24.823]  - future.globals: TRUE
[17:39:24.823] getGlobalsAndPackages() ...
[17:39:24.823] Searching for globals...
[17:39:24.824] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:24.824] Searching for globals ... DONE
[17:39:24.824] Resolving globals: FALSE
[17:39:24.825] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:39:24.825] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:39:24.825] - globals: [1] ‘FUN’
[17:39:24.825] - packages: [1] ‘stats’
[17:39:24.826] getGlobalsAndPackages() ... DONE
[17:39:24.826]  - globals found/used: [n=1] ‘FUN’
[17:39:24.826]  - needed namespaces: [n=1] ‘stats’
[17:39:24.826] Finding globals ... DONE
[17:39:24.826]  - use_args: TRUE
[17:39:24.826]  - Getting '...' globals ...
[17:39:24.826] resolve() on list ...
[17:39:24.826]  recursive: 0
[17:39:24.827]  length: 1
[17:39:24.827]  elements: ‘...’
[17:39:24.827]  length: 0 (resolved future 1)
[17:39:24.827] resolve() on list ... DONE
[17:39:24.827]    - '...' content: [n=1] ‘singular.ok’
[17:39:24.827] List of 1
[17:39:24.827]  $ ...:List of 1
[17:39:24.827]   ..$ singular.ok: logi FALSE
[17:39:24.827]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.827]  - attr(*, "where")=List of 1
[17:39:24.827]   ..$ ...:<environment: 0x56296e945908> 
[17:39:24.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.827]  - attr(*, "resolved")= logi TRUE
[17:39:24.827]  - attr(*, "total_size")= num NA
[17:39:24.830]  - Getting '...' globals ... DONE
[17:39:24.830] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:24.830] List of 2
[17:39:24.830]  $ ...future.FUN:function (x, ...)  
[17:39:24.830]  $ ...          :List of 1
[17:39:24.830]   ..$ singular.ok: logi FALSE
[17:39:24.830]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.830]  - attr(*, "where")=List of 2
[17:39:24.830]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:24.830]   ..$ ...          :<environment: 0x56296e945908> 
[17:39:24.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.830]  - attr(*, "resolved")= logi FALSE
[17:39:24.830]  - attr(*, "total_size")= num 5384
[17:39:24.833] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:24.833] getGlobalsAndPackagesXApply() ... DONE
[17:39:24.833] Number of futures (= number of chunks): 1
[17:39:24.834] Launching 1 futures (chunks) ...
[17:39:24.834] Chunk #1 of 1 ...
[17:39:24.834]  - Finding globals in 'X' for chunk #1 ...
[17:39:24.834] getGlobalsAndPackages() ...
[17:39:24.834] Searching for globals...
[17:39:24.834] 
[17:39:24.835] Searching for globals ... DONE
[17:39:24.835] - globals: [0] <none>
[17:39:24.835] getGlobalsAndPackages() ... DONE
[17:39:24.835]    + additional globals found: [n=0] 
[17:39:24.835]    + additional namespaces needed: [n=0] 
[17:39:24.835]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:24.835]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:24.835]  - seeds: <none>
[17:39:24.835] getGlobalsAndPackages() ...
[17:39:24.835] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.836] Resolving globals: FALSE
[17:39:24.837] Tweak future expression to call with '...' arguments ...
[17:39:24.837] {
[17:39:24.837]     do.call(function(...) {
[17:39:24.837]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.837]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.837]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.837]             on.exit(options(oopts), add = TRUE)
[17:39:24.837]         }
[17:39:24.837]         {
[17:39:24.837]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.837]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.837]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.837]             })
[17:39:24.837]         }
[17:39:24.837]     }, args = future.call.arguments)
[17:39:24.837] }
[17:39:24.837] Tweak future expression to call with '...' arguments ... DONE
[17:39:24.838] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.838] 
[17:39:24.838] getGlobalsAndPackages() ... DONE
[17:39:24.838] run() for ‘Future’ ...
[17:39:24.838] - state: ‘created’
[17:39:24.838] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:24.839] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:24.839]   - Field: ‘label’
[17:39:24.839]   - Field: ‘local’
[17:39:24.839]   - Field: ‘owner’
[17:39:24.839]   - Field: ‘envir’
[17:39:24.839]   - Field: ‘packages’
[17:39:24.839]   - Field: ‘gc’
[17:39:24.840]   - Field: ‘conditions’
[17:39:24.840]   - Field: ‘expr’
[17:39:24.840]   - Field: ‘uuid’
[17:39:24.840]   - Field: ‘seed’
[17:39:24.840]   - Field: ‘version’
[17:39:24.840]   - Field: ‘result’
[17:39:24.840]   - Field: ‘asynchronous’
[17:39:24.840]   - Field: ‘calls’
[17:39:24.840]   - Field: ‘globals’
[17:39:24.840]   - Field: ‘stdout’
[17:39:24.840]   - Field: ‘earlySignal’
[17:39:24.841]   - Field: ‘lazy’
[17:39:24.841]   - Field: ‘state’
[17:39:24.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:24.841] - Launch lazy future ...
[17:39:24.841] Packages needed by the future expression (n = 1): ‘stats’
[17:39:24.841] Packages needed by future strategies (n = 0): <none>
[17:39:24.842] {
[17:39:24.842]     {
[17:39:24.842]         {
[17:39:24.842]             ...future.startTime <- base::Sys.time()
[17:39:24.842]             {
[17:39:24.842]                 {
[17:39:24.842]                   {
[17:39:24.842]                     {
[17:39:24.842]                       base::local({
[17:39:24.842]                         has_future <- base::requireNamespace("future", 
[17:39:24.842]                           quietly = TRUE)
[17:39:24.842]                         if (has_future) {
[17:39:24.842]                           ns <- base::getNamespace("future")
[17:39:24.842]                           version <- ns[[".package"]][["version"]]
[17:39:24.842]                           if (is.null(version)) 
[17:39:24.842]                             version <- utils::packageVersion("future")
[17:39:24.842]                         }
[17:39:24.842]                         else {
[17:39:24.842]                           version <- NULL
[17:39:24.842]                         }
[17:39:24.842]                         if (!has_future || version < "1.8.0") {
[17:39:24.842]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:24.842]                             "", base::R.version$version.string), 
[17:39:24.842]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:24.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:24.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:24.842]                               "release", "version")], collapse = " "), 
[17:39:24.842]                             hostname = base::Sys.info()[["nodename"]])
[17:39:24.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:24.842]                             info)
[17:39:24.842]                           info <- base::paste(info, collapse = "; ")
[17:39:24.842]                           if (!has_future) {
[17:39:24.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:24.842]                               info)
[17:39:24.842]                           }
[17:39:24.842]                           else {
[17:39:24.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:24.842]                               info, version)
[17:39:24.842]                           }
[17:39:24.842]                           base::stop(msg)
[17:39:24.842]                         }
[17:39:24.842]                       })
[17:39:24.842]                     }
[17:39:24.842]                     base::local({
[17:39:24.842]                       for (pkg in "stats") {
[17:39:24.842]                         base::loadNamespace(pkg)
[17:39:24.842]                         base::library(pkg, character.only = TRUE)
[17:39:24.842]                       }
[17:39:24.842]                     })
[17:39:24.842]                   }
[17:39:24.842]                   options(future.plan = NULL)
[17:39:24.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:24.842]                 }
[17:39:24.842]                 ...future.workdir <- getwd()
[17:39:24.842]             }
[17:39:24.842]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:24.842]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:24.842]         }
[17:39:24.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:24.842]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:24.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:24.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:24.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:24.842]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:24.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:24.842]             base::names(...future.oldOptions))
[17:39:24.842]     }
[17:39:24.842]     if (FALSE) {
[17:39:24.842]     }
[17:39:24.842]     else {
[17:39:24.842]         if (TRUE) {
[17:39:24.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:24.842]                 open = "w")
[17:39:24.842]         }
[17:39:24.842]         else {
[17:39:24.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:24.842]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:24.842]         }
[17:39:24.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:24.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:24.842]             base::sink(type = "output", split = FALSE)
[17:39:24.842]             base::close(...future.stdout)
[17:39:24.842]         }, add = TRUE)
[17:39:24.842]     }
[17:39:24.842]     ...future.frame <- base::sys.nframe()
[17:39:24.842]     ...future.conditions <- base::list()
[17:39:24.842]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:24.842]     if (FALSE) {
[17:39:24.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:24.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:24.842]     }
[17:39:24.842]     ...future.result <- base::tryCatch({
[17:39:24.842]         base::withCallingHandlers({
[17:39:24.842]             ...future.value <- base::withVisible(base::local({
[17:39:24.842]                 do.call(function(...) {
[17:39:24.842]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.842]                   if (!identical(...future.globals.maxSize.org, 
[17:39:24.842]                     ...future.globals.maxSize)) {
[17:39:24.842]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.842]                     on.exit(options(oopts), add = TRUE)
[17:39:24.842]                   }
[17:39:24.842]                   {
[17:39:24.842]                     lapply(seq_along(...future.elements_ii), 
[17:39:24.842]                       FUN = function(jj) {
[17:39:24.842]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.842]                         ...future.FUN(...future.X_jj, ...)
[17:39:24.842]                       })
[17:39:24.842]                   }
[17:39:24.842]                 }, args = future.call.arguments)
[17:39:24.842]             }))
[17:39:24.842]             future::FutureResult(value = ...future.value$value, 
[17:39:24.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.842]                   ...future.rng), globalenv = if (FALSE) 
[17:39:24.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:24.842]                     ...future.globalenv.names))
[17:39:24.842]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:24.842]         }, condition = base::local({
[17:39:24.842]             c <- base::c
[17:39:24.842]             inherits <- base::inherits
[17:39:24.842]             invokeRestart <- base::invokeRestart
[17:39:24.842]             length <- base::length
[17:39:24.842]             list <- base::list
[17:39:24.842]             seq.int <- base::seq.int
[17:39:24.842]             signalCondition <- base::signalCondition
[17:39:24.842]             sys.calls <- base::sys.calls
[17:39:24.842]             `[[` <- base::`[[`
[17:39:24.842]             `+` <- base::`+`
[17:39:24.842]             `<<-` <- base::`<<-`
[17:39:24.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:24.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:24.842]                   3L)]
[17:39:24.842]             }
[17:39:24.842]             function(cond) {
[17:39:24.842]                 is_error <- inherits(cond, "error")
[17:39:24.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:24.842]                   NULL)
[17:39:24.842]                 if (is_error) {
[17:39:24.842]                   sessionInformation <- function() {
[17:39:24.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:24.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:24.842]                       search = base::search(), system = base::Sys.info())
[17:39:24.842]                   }
[17:39:24.842]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:24.842]                     cond$call), session = sessionInformation(), 
[17:39:24.842]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:24.842]                   signalCondition(cond)
[17:39:24.842]                 }
[17:39:24.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:24.842]                 "immediateCondition"))) {
[17:39:24.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:24.842]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:24.842]                   if (TRUE && !signal) {
[17:39:24.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.842]                     {
[17:39:24.842]                       inherits <- base::inherits
[17:39:24.842]                       invokeRestart <- base::invokeRestart
[17:39:24.842]                       is.null <- base::is.null
[17:39:24.842]                       muffled <- FALSE
[17:39:24.842]                       if (inherits(cond, "message")) {
[17:39:24.842]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.842]                         if (muffled) 
[17:39:24.842]                           invokeRestart("muffleMessage")
[17:39:24.842]                       }
[17:39:24.842]                       else if (inherits(cond, "warning")) {
[17:39:24.842]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.842]                         if (muffled) 
[17:39:24.842]                           invokeRestart("muffleWarning")
[17:39:24.842]                       }
[17:39:24.842]                       else if (inherits(cond, "condition")) {
[17:39:24.842]                         if (!is.null(pattern)) {
[17:39:24.842]                           computeRestarts <- base::computeRestarts
[17:39:24.842]                           grepl <- base::grepl
[17:39:24.842]                           restarts <- computeRestarts(cond)
[17:39:24.842]                           for (restart in restarts) {
[17:39:24.842]                             name <- restart$name
[17:39:24.842]                             if (is.null(name)) 
[17:39:24.842]                               next
[17:39:24.842]                             if (!grepl(pattern, name)) 
[17:39:24.842]                               next
[17:39:24.842]                             invokeRestart(restart)
[17:39:24.842]                             muffled <- TRUE
[17:39:24.842]                             break
[17:39:24.842]                           }
[17:39:24.842]                         }
[17:39:24.842]                       }
[17:39:24.842]                       invisible(muffled)
[17:39:24.842]                     }
[17:39:24.842]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.842]                   }
[17:39:24.842]                 }
[17:39:24.842]                 else {
[17:39:24.842]                   if (TRUE) {
[17:39:24.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.842]                     {
[17:39:24.842]                       inherits <- base::inherits
[17:39:24.842]                       invokeRestart <- base::invokeRestart
[17:39:24.842]                       is.null <- base::is.null
[17:39:24.842]                       muffled <- FALSE
[17:39:24.842]                       if (inherits(cond, "message")) {
[17:39:24.842]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.842]                         if (muffled) 
[17:39:24.842]                           invokeRestart("muffleMessage")
[17:39:24.842]                       }
[17:39:24.842]                       else if (inherits(cond, "warning")) {
[17:39:24.842]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.842]                         if (muffled) 
[17:39:24.842]                           invokeRestart("muffleWarning")
[17:39:24.842]                       }
[17:39:24.842]                       else if (inherits(cond, "condition")) {
[17:39:24.842]                         if (!is.null(pattern)) {
[17:39:24.842]                           computeRestarts <- base::computeRestarts
[17:39:24.842]                           grepl <- base::grepl
[17:39:24.842]                           restarts <- computeRestarts(cond)
[17:39:24.842]                           for (restart in restarts) {
[17:39:24.842]                             name <- restart$name
[17:39:24.842]                             if (is.null(name)) 
[17:39:24.842]                               next
[17:39:24.842]                             if (!grepl(pattern, name)) 
[17:39:24.842]                               next
[17:39:24.842]                             invokeRestart(restart)
[17:39:24.842]                             muffled <- TRUE
[17:39:24.842]                             break
[17:39:24.842]                           }
[17:39:24.842]                         }
[17:39:24.842]                       }
[17:39:24.842]                       invisible(muffled)
[17:39:24.842]                     }
[17:39:24.842]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.842]                   }
[17:39:24.842]                 }
[17:39:24.842]             }
[17:39:24.842]         }))
[17:39:24.842]     }, error = function(ex) {
[17:39:24.842]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:24.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.842]                 ...future.rng), started = ...future.startTime, 
[17:39:24.842]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:24.842]             version = "1.8"), class = "FutureResult")
[17:39:24.842]     }, finally = {
[17:39:24.842]         if (!identical(...future.workdir, getwd())) 
[17:39:24.842]             setwd(...future.workdir)
[17:39:24.842]         {
[17:39:24.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:24.842]                 ...future.oldOptions$nwarnings <- NULL
[17:39:24.842]             }
[17:39:24.842]             base::options(...future.oldOptions)
[17:39:24.842]             if (.Platform$OS.type == "windows") {
[17:39:24.842]                 old_names <- names(...future.oldEnvVars)
[17:39:24.842]                 envs <- base::Sys.getenv()
[17:39:24.842]                 names <- names(envs)
[17:39:24.842]                 common <- intersect(names, old_names)
[17:39:24.842]                 added <- setdiff(names, old_names)
[17:39:24.842]                 removed <- setdiff(old_names, names)
[17:39:24.842]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:24.842]                   envs[common]]
[17:39:24.842]                 NAMES <- toupper(changed)
[17:39:24.842]                 args <- list()
[17:39:24.842]                 for (kk in seq_along(NAMES)) {
[17:39:24.842]                   name <- changed[[kk]]
[17:39:24.842]                   NAME <- NAMES[[kk]]
[17:39:24.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.842]                     next
[17:39:24.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.842]                 }
[17:39:24.842]                 NAMES <- toupper(added)
[17:39:24.842]                 for (kk in seq_along(NAMES)) {
[17:39:24.842]                   name <- added[[kk]]
[17:39:24.842]                   NAME <- NAMES[[kk]]
[17:39:24.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.842]                     next
[17:39:24.842]                   args[[name]] <- ""
[17:39:24.842]                 }
[17:39:24.842]                 NAMES <- toupper(removed)
[17:39:24.842]                 for (kk in seq_along(NAMES)) {
[17:39:24.842]                   name <- removed[[kk]]
[17:39:24.842]                   NAME <- NAMES[[kk]]
[17:39:24.842]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.842]                     next
[17:39:24.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.842]                 }
[17:39:24.842]                 if (length(args) > 0) 
[17:39:24.842]                   base::do.call(base::Sys.setenv, args = args)
[17:39:24.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:24.842]             }
[17:39:24.842]             else {
[17:39:24.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:24.842]             }
[17:39:24.842]             {
[17:39:24.842]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:24.842]                   0L) {
[17:39:24.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:24.842]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:24.842]                   base::options(opts)
[17:39:24.842]                 }
[17:39:24.842]                 {
[17:39:24.842]                   {
[17:39:24.842]                     NULL
[17:39:24.842]                     RNGkind("Mersenne-Twister")
[17:39:24.842]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:24.842]                       inherits = FALSE)
[17:39:24.842]                   }
[17:39:24.842]                   options(future.plan = NULL)
[17:39:24.842]                   if (is.na(NA_character_)) 
[17:39:24.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:24.842]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:24.842]                   {
[17:39:24.842]                     future <- SequentialFuture(..., envir = envir)
[17:39:24.842]                     if (!future$lazy) 
[17:39:24.842]                       future <- run(future)
[17:39:24.842]                     invisible(future)
[17:39:24.842]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:24.842]                 }
[17:39:24.842]             }
[17:39:24.842]         }
[17:39:24.842]     })
[17:39:24.842]     if (TRUE) {
[17:39:24.842]         base::sink(type = "output", split = FALSE)
[17:39:24.842]         if (TRUE) {
[17:39:24.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:24.842]         }
[17:39:24.842]         else {
[17:39:24.842]             ...future.result["stdout"] <- base::list(NULL)
[17:39:24.842]         }
[17:39:24.842]         base::close(...future.stdout)
[17:39:24.842]         ...future.stdout <- NULL
[17:39:24.842]     }
[17:39:24.842]     ...future.result$conditions <- ...future.conditions
[17:39:24.842]     ...future.result$finished <- base::Sys.time()
[17:39:24.842]     ...future.result
[17:39:24.842] }
[17:39:24.843] assign_globals() ...
[17:39:24.843] List of 5
[17:39:24.843]  $ ...future.FUN            :function (x, ...)  
[17:39:24.843]  $ future.call.arguments    :List of 1
[17:39:24.843]   ..$ singular.ok: logi FALSE
[17:39:24.843]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.843]  $ ...future.elements_ii    :List of 3
[17:39:24.843]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.843]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:24.843]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.843]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:24.843]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.843]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:24.843]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.843]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:24.843]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.843]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:24.843]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.843]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:24.843]  $ ...future.seeds_ii       : NULL
[17:39:24.843]  $ ...future.globals.maxSize: NULL
[17:39:24.843]  - attr(*, "resolved")= logi FALSE
[17:39:24.843]  - attr(*, "total_size")= num 5384
[17:39:24.843]  - attr(*, "where")=List of 5
[17:39:24.843]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:24.843]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:24.843]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:24.843]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:24.843]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:24.843]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.843]  - attr(*, "already-done")= logi TRUE
[17:39:24.852] - reassign environment for ‘...future.FUN’
[17:39:24.852] - copied ‘...future.FUN’ to environment
[17:39:24.852] - copied ‘future.call.arguments’ to environment
[17:39:24.852] - copied ‘...future.elements_ii’ to environment
[17:39:24.853] - copied ‘...future.seeds_ii’ to environment
[17:39:24.853] - copied ‘...future.globals.maxSize’ to environment
[17:39:24.853] assign_globals() ... done
[17:39:24.853] plan(): Setting new future strategy stack:
[17:39:24.853] List of future strategies:
[17:39:24.853] 1. sequential:
[17:39:24.853]    - args: function (..., envir = parent.frame())
[17:39:24.853]    - tweaked: FALSE
[17:39:24.853]    - call: NULL
[17:39:24.854] plan(): nbrOfWorkers() = 1
[17:39:24.856] plan(): Setting new future strategy stack:
[17:39:24.856] List of future strategies:
[17:39:24.856] 1. sequential:
[17:39:24.856]    - args: function (..., envir = parent.frame())
[17:39:24.856]    - tweaked: FALSE
[17:39:24.856]    - call: plan(strategy)
[17:39:24.857] plan(): nbrOfWorkers() = 1
[17:39:24.857] SequentialFuture started (and completed)
[17:39:24.857] - Launch lazy future ... done
[17:39:24.857] run() for ‘SequentialFuture’ ... done
[17:39:24.857] Created future:
[17:39:24.857] SequentialFuture:
[17:39:24.857] Label: ‘future_by-1’
[17:39:24.857] Expression:
[17:39:24.857] {
[17:39:24.857]     do.call(function(...) {
[17:39:24.857]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.857]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.857]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.857]             on.exit(options(oopts), add = TRUE)
[17:39:24.857]         }
[17:39:24.857]         {
[17:39:24.857]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.857]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.857]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.857]             })
[17:39:24.857]         }
[17:39:24.857]     }, args = future.call.arguments)
[17:39:24.857] }
[17:39:24.857] Lazy evaluation: FALSE
[17:39:24.857] Asynchronous evaluation: FALSE
[17:39:24.857] Local evaluation: TRUE
[17:39:24.857] Environment: R_GlobalEnv
[17:39:24.857] Capture standard output: TRUE
[17:39:24.857] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:24.857] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:24.857] Packages: 1 packages (‘stats’)
[17:39:24.857] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:24.857] Resolved: TRUE
[17:39:24.857] Value: 26.06 KiB of class ‘list’
[17:39:24.857] Early signaling: FALSE
[17:39:24.857] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:24.857] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.860] Chunk #1 of 1 ... DONE
[17:39:24.860] Launching 1 futures (chunks) ... DONE
[17:39:24.861] Resolving 1 futures (chunks) ...
[17:39:24.861] resolve() on list ...
[17:39:24.861]  recursive: 0
[17:39:24.861]  length: 1
[17:39:24.861] 
[17:39:24.861] resolved() for ‘SequentialFuture’ ...
[17:39:24.861] - state: ‘finished’
[17:39:24.861] - run: TRUE
[17:39:24.861] - result: ‘FutureResult’
[17:39:24.861] resolved() for ‘SequentialFuture’ ... done
[17:39:24.861] Future #1
[17:39:24.862] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:24.862] - nx: 1
[17:39:24.862] - relay: TRUE
[17:39:24.862] - stdout: TRUE
[17:39:24.862] - signal: TRUE
[17:39:24.862] - resignal: FALSE
[17:39:24.862] - force: TRUE
[17:39:24.862] - relayed: [n=1] FALSE
[17:39:24.862] - queued futures: [n=1] FALSE
[17:39:24.862]  - until=1
[17:39:24.862]  - relaying element #1
[17:39:24.863] - relayed: [n=1] TRUE
[17:39:24.863] - queued futures: [n=1] TRUE
[17:39:24.863] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:24.863]  length: 0 (resolved future 1)
[17:39:24.863] Relaying remaining futures
[17:39:24.863] signalConditionsASAP(NULL, pos=0) ...
[17:39:24.863] - nx: 1
[17:39:24.863] - relay: TRUE
[17:39:24.863] - stdout: TRUE
[17:39:24.864] - signal: TRUE
[17:39:24.864] - resignal: FALSE
[17:39:24.864] - force: TRUE
[17:39:24.864] - relayed: [n=1] TRUE
[17:39:24.864] - queued futures: [n=1] TRUE
 - flush all
[17:39:24.864] - relayed: [n=1] TRUE
[17:39:24.864] - queued futures: [n=1] TRUE
[17:39:24.864] signalConditionsASAP(NULL, pos=0) ... done
[17:39:24.864] resolve() on list ... DONE
[17:39:24.864]  - Number of value chunks collected: 1
[17:39:24.865] Resolving 1 futures (chunks) ... DONE
[17:39:24.865] Reducing values from 1 chunks ...
[17:39:24.865]  - Number of values collected after concatenation: 3
[17:39:24.865]  - Number of values expected: 3
[17:39:24.865] Reducing values from 1 chunks ... DONE
[17:39:24.865] future_lapply() ... DONE
[17:39:24.865] future_by_internal() ... DONE
[17:39:24.869] future_by_internal() ...
[17:39:24.870] future_lapply() ...
[17:39:24.871] Number of chunks: 1
[17:39:24.871] getGlobalsAndPackagesXApply() ...
[17:39:24.871]  - future.globals: TRUE
[17:39:24.871] getGlobalsAndPackages() ...
[17:39:24.871] Searching for globals...
[17:39:24.873] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:24.873] Searching for globals ... DONE
[17:39:24.873] Resolving globals: FALSE
[17:39:24.873] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:39:24.874] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:39:24.874] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:24.874] - packages: [1] ‘stats’
[17:39:24.874] getGlobalsAndPackages() ... DONE
[17:39:24.874]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:24.874]  - needed namespaces: [n=1] ‘stats’
[17:39:24.875] Finding globals ... DONE
[17:39:24.875]  - use_args: TRUE
[17:39:24.875]  - Getting '...' globals ...
[17:39:24.875] resolve() on list ...
[17:39:24.875]  recursive: 0
[17:39:24.875]  length: 1
[17:39:24.875]  elements: ‘...’
[17:39:24.875]  length: 0 (resolved future 1)
[17:39:24.876] resolve() on list ... DONE
[17:39:24.876]    - '...' content: [n=0] 
[17:39:24.876] List of 1
[17:39:24.876]  $ ...: list()
[17:39:24.876]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.876]  - attr(*, "where")=List of 1
[17:39:24.876]   ..$ ...:<environment: 0x562970888be0> 
[17:39:24.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.876]  - attr(*, "resolved")= logi TRUE
[17:39:24.876]  - attr(*, "total_size")= num NA
[17:39:24.880]  - Getting '...' globals ... DONE
[17:39:24.880] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:39:24.880] List of 4
[17:39:24.880]  $ ...future.FUN:function (x)  
[17:39:24.880]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:24.880]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:24.880]  $ ...          : list()
[17:39:24.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.880]  - attr(*, "where")=List of 4
[17:39:24.880]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:24.880]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:39:24.880]   ..$ wool         :<environment: R_EmptyEnv> 
[17:39:24.880]   ..$ ...          :<environment: 0x562970888be0> 
[17:39:24.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.880]  - attr(*, "resolved")= logi FALSE
[17:39:24.880]  - attr(*, "total_size")= num 2320
[17:39:24.884] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:24.884] getGlobalsAndPackagesXApply() ... DONE
[17:39:24.884] Number of futures (= number of chunks): 1
[17:39:24.884] Launching 1 futures (chunks) ...
[17:39:24.885] Chunk #1 of 1 ...
[17:39:24.885]  - Finding globals in 'X' for chunk #1 ...
[17:39:24.885] getGlobalsAndPackages() ...
[17:39:24.885] Searching for globals...
[17:39:24.885] 
[17:39:24.885] Searching for globals ... DONE
[17:39:24.886] - globals: [0] <none>
[17:39:24.886] getGlobalsAndPackages() ... DONE
[17:39:24.886]    + additional globals found: [n=0] 
[17:39:24.886]    + additional namespaces needed: [n=0] 
[17:39:24.886]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:24.886]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:24.886]  - seeds: <none>
[17:39:24.886] getGlobalsAndPackages() ...
[17:39:24.886] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.886] Resolving globals: FALSE
[17:39:24.887] Tweak future expression to call with '...' arguments ...
[17:39:24.887] {
[17:39:24.887]     do.call(function(...) {
[17:39:24.887]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.887]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.887]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.887]             on.exit(options(oopts), add = TRUE)
[17:39:24.887]         }
[17:39:24.887]         {
[17:39:24.887]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.887]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.887]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.887]             })
[17:39:24.887]         }
[17:39:24.887]     }, args = future.call.arguments)
[17:39:24.887] }
[17:39:24.887] Tweak future expression to call with '...' arguments ... DONE
[17:39:24.887] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.887] 
[17:39:24.888] getGlobalsAndPackages() ... DONE
[17:39:24.888] run() for ‘Future’ ...
[17:39:24.888] - state: ‘created’
[17:39:24.888] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:24.888] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:24.889]   - Field: ‘label’
[17:39:24.889]   - Field: ‘local’
[17:39:24.889]   - Field: ‘owner’
[17:39:24.889]   - Field: ‘envir’
[17:39:24.889]   - Field: ‘packages’
[17:39:24.889]   - Field: ‘gc’
[17:39:24.889]   - Field: ‘conditions’
[17:39:24.889]   - Field: ‘expr’
[17:39:24.889]   - Field: ‘uuid’
[17:39:24.889]   - Field: ‘seed’
[17:39:24.890]   - Field: ‘version’
[17:39:24.890]   - Field: ‘result’
[17:39:24.890]   - Field: ‘asynchronous’
[17:39:24.890]   - Field: ‘calls’
[17:39:24.890]   - Field: ‘globals’
[17:39:24.890]   - Field: ‘stdout’
[17:39:24.890]   - Field: ‘earlySignal’
[17:39:24.890]   - Field: ‘lazy’
[17:39:24.890]   - Field: ‘state’
[17:39:24.890] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:24.890] - Launch lazy future ...
[17:39:24.891] Packages needed by the future expression (n = 1): ‘stats’
[17:39:24.891] Packages needed by future strategies (n = 0): <none>
[17:39:24.891] {
[17:39:24.891]     {
[17:39:24.891]         {
[17:39:24.891]             ...future.startTime <- base::Sys.time()
[17:39:24.891]             {
[17:39:24.891]                 {
[17:39:24.891]                   {
[17:39:24.891]                     {
[17:39:24.891]                       base::local({
[17:39:24.891]                         has_future <- base::requireNamespace("future", 
[17:39:24.891]                           quietly = TRUE)
[17:39:24.891]                         if (has_future) {
[17:39:24.891]                           ns <- base::getNamespace("future")
[17:39:24.891]                           version <- ns[[".package"]][["version"]]
[17:39:24.891]                           if (is.null(version)) 
[17:39:24.891]                             version <- utils::packageVersion("future")
[17:39:24.891]                         }
[17:39:24.891]                         else {
[17:39:24.891]                           version <- NULL
[17:39:24.891]                         }
[17:39:24.891]                         if (!has_future || version < "1.8.0") {
[17:39:24.891]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:24.891]                             "", base::R.version$version.string), 
[17:39:24.891]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:24.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:24.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:24.891]                               "release", "version")], collapse = " "), 
[17:39:24.891]                             hostname = base::Sys.info()[["nodename"]])
[17:39:24.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:24.891]                             info)
[17:39:24.891]                           info <- base::paste(info, collapse = "; ")
[17:39:24.891]                           if (!has_future) {
[17:39:24.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:24.891]                               info)
[17:39:24.891]                           }
[17:39:24.891]                           else {
[17:39:24.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:24.891]                               info, version)
[17:39:24.891]                           }
[17:39:24.891]                           base::stop(msg)
[17:39:24.891]                         }
[17:39:24.891]                       })
[17:39:24.891]                     }
[17:39:24.891]                     base::local({
[17:39:24.891]                       for (pkg in "stats") {
[17:39:24.891]                         base::loadNamespace(pkg)
[17:39:24.891]                         base::library(pkg, character.only = TRUE)
[17:39:24.891]                       }
[17:39:24.891]                     })
[17:39:24.891]                   }
[17:39:24.891]                   options(future.plan = NULL)
[17:39:24.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:24.891]                 }
[17:39:24.891]                 ...future.workdir <- getwd()
[17:39:24.891]             }
[17:39:24.891]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:24.891]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:24.891]         }
[17:39:24.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:24.891]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:24.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:24.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:24.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:24.891]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:24.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:24.891]             base::names(...future.oldOptions))
[17:39:24.891]     }
[17:39:24.891]     if (FALSE) {
[17:39:24.891]     }
[17:39:24.891]     else {
[17:39:24.891]         if (TRUE) {
[17:39:24.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:24.891]                 open = "w")
[17:39:24.891]         }
[17:39:24.891]         else {
[17:39:24.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:24.891]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:24.891]         }
[17:39:24.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:24.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:24.891]             base::sink(type = "output", split = FALSE)
[17:39:24.891]             base::close(...future.stdout)
[17:39:24.891]         }, add = TRUE)
[17:39:24.891]     }
[17:39:24.891]     ...future.frame <- base::sys.nframe()
[17:39:24.891]     ...future.conditions <- base::list()
[17:39:24.891]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:24.891]     if (FALSE) {
[17:39:24.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:24.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:24.891]     }
[17:39:24.891]     ...future.result <- base::tryCatch({
[17:39:24.891]         base::withCallingHandlers({
[17:39:24.891]             ...future.value <- base::withVisible(base::local({
[17:39:24.891]                 do.call(function(...) {
[17:39:24.891]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.891]                   if (!identical(...future.globals.maxSize.org, 
[17:39:24.891]                     ...future.globals.maxSize)) {
[17:39:24.891]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.891]                     on.exit(options(oopts), add = TRUE)
[17:39:24.891]                   }
[17:39:24.891]                   {
[17:39:24.891]                     lapply(seq_along(...future.elements_ii), 
[17:39:24.891]                       FUN = function(jj) {
[17:39:24.891]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.891]                         ...future.FUN(...future.X_jj, ...)
[17:39:24.891]                       })
[17:39:24.891]                   }
[17:39:24.891]                 }, args = future.call.arguments)
[17:39:24.891]             }))
[17:39:24.891]             future::FutureResult(value = ...future.value$value, 
[17:39:24.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.891]                   ...future.rng), globalenv = if (FALSE) 
[17:39:24.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:24.891]                     ...future.globalenv.names))
[17:39:24.891]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:24.891]         }, condition = base::local({
[17:39:24.891]             c <- base::c
[17:39:24.891]             inherits <- base::inherits
[17:39:24.891]             invokeRestart <- base::invokeRestart
[17:39:24.891]             length <- base::length
[17:39:24.891]             list <- base::list
[17:39:24.891]             seq.int <- base::seq.int
[17:39:24.891]             signalCondition <- base::signalCondition
[17:39:24.891]             sys.calls <- base::sys.calls
[17:39:24.891]             `[[` <- base::`[[`
[17:39:24.891]             `+` <- base::`+`
[17:39:24.891]             `<<-` <- base::`<<-`
[17:39:24.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:24.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:24.891]                   3L)]
[17:39:24.891]             }
[17:39:24.891]             function(cond) {
[17:39:24.891]                 is_error <- inherits(cond, "error")
[17:39:24.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:24.891]                   NULL)
[17:39:24.891]                 if (is_error) {
[17:39:24.891]                   sessionInformation <- function() {
[17:39:24.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:24.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:24.891]                       search = base::search(), system = base::Sys.info())
[17:39:24.891]                   }
[17:39:24.891]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:24.891]                     cond$call), session = sessionInformation(), 
[17:39:24.891]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:24.891]                   signalCondition(cond)
[17:39:24.891]                 }
[17:39:24.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:24.891]                 "immediateCondition"))) {
[17:39:24.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:24.891]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:24.891]                   if (TRUE && !signal) {
[17:39:24.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.891]                     {
[17:39:24.891]                       inherits <- base::inherits
[17:39:24.891]                       invokeRestart <- base::invokeRestart
[17:39:24.891]                       is.null <- base::is.null
[17:39:24.891]                       muffled <- FALSE
[17:39:24.891]                       if (inherits(cond, "message")) {
[17:39:24.891]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.891]                         if (muffled) 
[17:39:24.891]                           invokeRestart("muffleMessage")
[17:39:24.891]                       }
[17:39:24.891]                       else if (inherits(cond, "warning")) {
[17:39:24.891]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.891]                         if (muffled) 
[17:39:24.891]                           invokeRestart("muffleWarning")
[17:39:24.891]                       }
[17:39:24.891]                       else if (inherits(cond, "condition")) {
[17:39:24.891]                         if (!is.null(pattern)) {
[17:39:24.891]                           computeRestarts <- base::computeRestarts
[17:39:24.891]                           grepl <- base::grepl
[17:39:24.891]                           restarts <- computeRestarts(cond)
[17:39:24.891]                           for (restart in restarts) {
[17:39:24.891]                             name <- restart$name
[17:39:24.891]                             if (is.null(name)) 
[17:39:24.891]                               next
[17:39:24.891]                             if (!grepl(pattern, name)) 
[17:39:24.891]                               next
[17:39:24.891]                             invokeRestart(restart)
[17:39:24.891]                             muffled <- TRUE
[17:39:24.891]                             break
[17:39:24.891]                           }
[17:39:24.891]                         }
[17:39:24.891]                       }
[17:39:24.891]                       invisible(muffled)
[17:39:24.891]                     }
[17:39:24.891]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.891]                   }
[17:39:24.891]                 }
[17:39:24.891]                 else {
[17:39:24.891]                   if (TRUE) {
[17:39:24.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.891]                     {
[17:39:24.891]                       inherits <- base::inherits
[17:39:24.891]                       invokeRestart <- base::invokeRestart
[17:39:24.891]                       is.null <- base::is.null
[17:39:24.891]                       muffled <- FALSE
[17:39:24.891]                       if (inherits(cond, "message")) {
[17:39:24.891]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.891]                         if (muffled) 
[17:39:24.891]                           invokeRestart("muffleMessage")
[17:39:24.891]                       }
[17:39:24.891]                       else if (inherits(cond, "warning")) {
[17:39:24.891]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.891]                         if (muffled) 
[17:39:24.891]                           invokeRestart("muffleWarning")
[17:39:24.891]                       }
[17:39:24.891]                       else if (inherits(cond, "condition")) {
[17:39:24.891]                         if (!is.null(pattern)) {
[17:39:24.891]                           computeRestarts <- base::computeRestarts
[17:39:24.891]                           grepl <- base::grepl
[17:39:24.891]                           restarts <- computeRestarts(cond)
[17:39:24.891]                           for (restart in restarts) {
[17:39:24.891]                             name <- restart$name
[17:39:24.891]                             if (is.null(name)) 
[17:39:24.891]                               next
[17:39:24.891]                             if (!grepl(pattern, name)) 
[17:39:24.891]                               next
[17:39:24.891]                             invokeRestart(restart)
[17:39:24.891]                             muffled <- TRUE
[17:39:24.891]                             break
[17:39:24.891]                           }
[17:39:24.891]                         }
[17:39:24.891]                       }
[17:39:24.891]                       invisible(muffled)
[17:39:24.891]                     }
[17:39:24.891]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.891]                   }
[17:39:24.891]                 }
[17:39:24.891]             }
[17:39:24.891]         }))
[17:39:24.891]     }, error = function(ex) {
[17:39:24.891]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:24.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.891]                 ...future.rng), started = ...future.startTime, 
[17:39:24.891]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:24.891]             version = "1.8"), class = "FutureResult")
[17:39:24.891]     }, finally = {
[17:39:24.891]         if (!identical(...future.workdir, getwd())) 
[17:39:24.891]             setwd(...future.workdir)
[17:39:24.891]         {
[17:39:24.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:24.891]                 ...future.oldOptions$nwarnings <- NULL
[17:39:24.891]             }
[17:39:24.891]             base::options(...future.oldOptions)
[17:39:24.891]             if (.Platform$OS.type == "windows") {
[17:39:24.891]                 old_names <- names(...future.oldEnvVars)
[17:39:24.891]                 envs <- base::Sys.getenv()
[17:39:24.891]                 names <- names(envs)
[17:39:24.891]                 common <- intersect(names, old_names)
[17:39:24.891]                 added <- setdiff(names, old_names)
[17:39:24.891]                 removed <- setdiff(old_names, names)
[17:39:24.891]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:24.891]                   envs[common]]
[17:39:24.891]                 NAMES <- toupper(changed)
[17:39:24.891]                 args <- list()
[17:39:24.891]                 for (kk in seq_along(NAMES)) {
[17:39:24.891]                   name <- changed[[kk]]
[17:39:24.891]                   NAME <- NAMES[[kk]]
[17:39:24.891]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.891]                     next
[17:39:24.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.891]                 }
[17:39:24.891]                 NAMES <- toupper(added)
[17:39:24.891]                 for (kk in seq_along(NAMES)) {
[17:39:24.891]                   name <- added[[kk]]
[17:39:24.891]                   NAME <- NAMES[[kk]]
[17:39:24.891]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.891]                     next
[17:39:24.891]                   args[[name]] <- ""
[17:39:24.891]                 }
[17:39:24.891]                 NAMES <- toupper(removed)
[17:39:24.891]                 for (kk in seq_along(NAMES)) {
[17:39:24.891]                   name <- removed[[kk]]
[17:39:24.891]                   NAME <- NAMES[[kk]]
[17:39:24.891]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.891]                     next
[17:39:24.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.891]                 }
[17:39:24.891]                 if (length(args) > 0) 
[17:39:24.891]                   base::do.call(base::Sys.setenv, args = args)
[17:39:24.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:24.891]             }
[17:39:24.891]             else {
[17:39:24.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:24.891]             }
[17:39:24.891]             {
[17:39:24.891]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:24.891]                   0L) {
[17:39:24.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:24.891]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:24.891]                   base::options(opts)
[17:39:24.891]                 }
[17:39:24.891]                 {
[17:39:24.891]                   {
[17:39:24.891]                     NULL
[17:39:24.891]                     RNGkind("Mersenne-Twister")
[17:39:24.891]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:24.891]                       inherits = FALSE)
[17:39:24.891]                   }
[17:39:24.891]                   options(future.plan = NULL)
[17:39:24.891]                   if (is.na(NA_character_)) 
[17:39:24.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:24.891]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:24.891]                   {
[17:39:24.891]                     future <- SequentialFuture(..., envir = envir)
[17:39:24.891]                     if (!future$lazy) 
[17:39:24.891]                       future <- run(future)
[17:39:24.891]                     invisible(future)
[17:39:24.891]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:24.891]                 }
[17:39:24.891]             }
[17:39:24.891]         }
[17:39:24.891]     })
[17:39:24.891]     if (TRUE) {
[17:39:24.891]         base::sink(type = "output", split = FALSE)
[17:39:24.891]         if (TRUE) {
[17:39:24.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:24.891]         }
[17:39:24.891]         else {
[17:39:24.891]             ...future.result["stdout"] <- base::list(NULL)
[17:39:24.891]         }
[17:39:24.891]         base::close(...future.stdout)
[17:39:24.891]         ...future.stdout <- NULL
[17:39:24.891]     }
[17:39:24.891]     ...future.result$conditions <- ...future.conditions
[17:39:24.891]     ...future.result$finished <- base::Sys.time()
[17:39:24.891]     ...future.result
[17:39:24.891] }
[17:39:24.893] assign_globals() ...
[17:39:24.893] List of 7
[17:39:24.893]  $ ...future.FUN            :function (x)  
[17:39:24.893]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:24.893]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:24.893]  $ future.call.arguments    : list()
[17:39:24.893]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.893]  $ ...future.elements_ii    :List of 3
[17:39:24.893]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.893]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:24.893]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.893]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:24.893]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.893]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:24.893]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.893]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:24.893]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.893]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:24.893]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.893]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:24.893]  $ ...future.seeds_ii       : NULL
[17:39:24.893]  $ ...future.globals.maxSize: NULL
[17:39:24.893]  - attr(*, "resolved")= logi FALSE
[17:39:24.893]  - attr(*, "total_size")= num 2320
[17:39:24.893]  - attr(*, "where")=List of 7
[17:39:24.893]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:24.893]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:39:24.893]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:39:24.893]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:24.893]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:24.893]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:24.893]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:24.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.893]  - attr(*, "already-done")= logi TRUE
[17:39:24.905] - reassign environment for ‘...future.FUN’
[17:39:24.905] - copied ‘...future.FUN’ to environment
[17:39:24.905] - copied ‘breaks’ to environment
[17:39:24.905] - copied ‘wool’ to environment
[17:39:24.905] - copied ‘future.call.arguments’ to environment
[17:39:24.905] - copied ‘...future.elements_ii’ to environment
[17:39:24.905] - copied ‘...future.seeds_ii’ to environment
[17:39:24.905] - copied ‘...future.globals.maxSize’ to environment
[17:39:24.905] assign_globals() ... done
[17:39:24.906] plan(): Setting new future strategy stack:
[17:39:24.906] List of future strategies:
[17:39:24.906] 1. sequential:
[17:39:24.906]    - args: function (..., envir = parent.frame())
[17:39:24.906]    - tweaked: FALSE
[17:39:24.906]    - call: NULL
[17:39:24.906] plan(): nbrOfWorkers() = 1
[17:39:24.909] plan(): Setting new future strategy stack:
[17:39:24.909] List of future strategies:
[17:39:24.909] 1. sequential:
[17:39:24.909]    - args: function (..., envir = parent.frame())
[17:39:24.909]    - tweaked: FALSE
[17:39:24.909]    - call: plan(strategy)
[17:39:24.910] plan(): nbrOfWorkers() = 1
[17:39:24.910] SequentialFuture started (and completed)
[17:39:24.910] - Launch lazy future ... done
[17:39:24.910] run() for ‘SequentialFuture’ ... done
[17:39:24.910] Created future:
[17:39:24.910] SequentialFuture:
[17:39:24.910] Label: ‘future_by-1’
[17:39:24.910] Expression:
[17:39:24.910] {
[17:39:24.910]     do.call(function(...) {
[17:39:24.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.910]             on.exit(options(oopts), add = TRUE)
[17:39:24.910]         }
[17:39:24.910]         {
[17:39:24.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.910]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.910]             })
[17:39:24.910]         }
[17:39:24.910]     }, args = future.call.arguments)
[17:39:24.910] }
[17:39:24.910] Lazy evaluation: FALSE
[17:39:24.910] Asynchronous evaluation: FALSE
[17:39:24.910] Local evaluation: TRUE
[17:39:24.910] Environment: 0x562970821cc0
[17:39:24.910] Capture standard output: TRUE
[17:39:24.910] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:24.910] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:39:24.910] Packages: 1 packages (‘stats’)
[17:39:24.910] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:24.910] Resolved: TRUE
[17:39:24.910] Value: 25.57 KiB of class ‘list’
[17:39:24.910] Early signaling: FALSE
[17:39:24.910] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:24.910] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.912] Chunk #1 of 1 ... DONE
[17:39:24.912] Launching 1 futures (chunks) ... DONE
[17:39:24.912] Resolving 1 futures (chunks) ...
[17:39:24.912] resolve() on list ...
[17:39:24.912]  recursive: 0
[17:39:24.912]  length: 1
[17:39:24.912] 
[17:39:24.913] resolved() for ‘SequentialFuture’ ...
[17:39:24.913] - state: ‘finished’
[17:39:24.913] - run: TRUE
[17:39:24.913] - result: ‘FutureResult’
[17:39:24.913] resolved() for ‘SequentialFuture’ ... done
[17:39:24.913] Future #1
[17:39:24.913] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:24.913] - nx: 1
[17:39:24.913] - relay: TRUE
[17:39:24.914] - stdout: TRUE
[17:39:24.914] - signal: TRUE
[17:39:24.914] - resignal: FALSE
[17:39:24.914] - force: TRUE
[17:39:24.914] - relayed: [n=1] FALSE
[17:39:24.914] - queued futures: [n=1] FALSE
[17:39:24.914]  - until=1
[17:39:24.914]  - relaying element #1
[17:39:24.914] - relayed: [n=1] TRUE
[17:39:24.914] - queued futures: [n=1] TRUE
[17:39:24.915] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:24.915]  length: 0 (resolved future 1)
[17:39:24.915] Relaying remaining futures
[17:39:24.915] signalConditionsASAP(NULL, pos=0) ...
[17:39:24.915] - nx: 1
[17:39:24.915] - relay: TRUE
[17:39:24.915] - stdout: TRUE
[17:39:24.915] - signal: TRUE
[17:39:24.915] - resignal: FALSE
[17:39:24.915] - force: TRUE
[17:39:24.916] - relayed: [n=1] TRUE
[17:39:24.916] - queued futures: [n=1] TRUE
 - flush all
[17:39:24.916] - relayed: [n=1] TRUE
[17:39:24.916] - queued futures: [n=1] TRUE
[17:39:24.916] signalConditionsASAP(NULL, pos=0) ... done
[17:39:24.916] resolve() on list ... DONE
[17:39:24.916]  - Number of value chunks collected: 1
[17:39:24.916] Resolving 1 futures (chunks) ... DONE
[17:39:24.916] Reducing values from 1 chunks ...
[17:39:24.916]  - Number of values collected after concatenation: 3
[17:39:24.917]  - Number of values expected: 3
[17:39:24.917] Reducing values from 1 chunks ... DONE
[17:39:24.917] future_lapply() ... DONE
[17:39:24.917] future_by_internal() ... DONE
[17:39:24.917] future_by_internal() ...
[17:39:24.918] future_lapply() ...
[17:39:24.918] Number of chunks: 1
[17:39:24.918] getGlobalsAndPackagesXApply() ...
[17:39:24.918]  - future.globals: TRUE
[17:39:24.919] getGlobalsAndPackages() ...
[17:39:24.919] Searching for globals...
[17:39:24.920] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:24.920] Searching for globals ... DONE
[17:39:24.920] Resolving globals: FALSE
[17:39:24.920] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:24.921] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:24.921] - globals: [1] ‘FUN’
[17:39:24.921] 
[17:39:24.921] getGlobalsAndPackages() ... DONE
[17:39:24.921]  - globals found/used: [n=1] ‘FUN’
[17:39:24.921]  - needed namespaces: [n=0] 
[17:39:24.923] Finding globals ... DONE
[17:39:24.923]  - use_args: TRUE
[17:39:24.923]  - Getting '...' globals ...
[17:39:24.924] resolve() on list ...
[17:39:24.924]  recursive: 0
[17:39:24.924]  length: 1
[17:39:24.924]  elements: ‘...’
[17:39:24.924]  length: 0 (resolved future 1)
[17:39:24.924] resolve() on list ... DONE
[17:39:24.924]    - '...' content: [n=0] 
[17:39:24.925] List of 1
[17:39:24.925]  $ ...: list()
[17:39:24.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.925]  - attr(*, "where")=List of 1
[17:39:24.925]   ..$ ...:<environment: 0x562970e38910> 
[17:39:24.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.925]  - attr(*, "resolved")= logi TRUE
[17:39:24.925]  - attr(*, "total_size")= num NA
[17:39:24.927]  - Getting '...' globals ... DONE
[17:39:24.927] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:24.927] List of 2
[17:39:24.927]  $ ...future.FUN:function (object, ...)  
[17:39:24.927]  $ ...          : list()
[17:39:24.927]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.927]  - attr(*, "where")=List of 2
[17:39:24.927]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:24.927]   ..$ ...          :<environment: 0x562970e38910> 
[17:39:24.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.927]  - attr(*, "resolved")= logi FALSE
[17:39:24.927]  - attr(*, "total_size")= num 1240
[17:39:24.930] Packages to be attached in all futures: [n=0] 
[17:39:24.930] getGlobalsAndPackagesXApply() ... DONE
[17:39:24.930] Number of futures (= number of chunks): 1
[17:39:24.931] Launching 1 futures (chunks) ...
[17:39:24.931] Chunk #1 of 1 ...
[17:39:24.931]  - Finding globals in 'X' for chunk #1 ...
[17:39:24.931] getGlobalsAndPackages() ...
[17:39:24.931] Searching for globals...
[17:39:24.932] 
[17:39:24.932] Searching for globals ... DONE
[17:39:24.932] - globals: [0] <none>
[17:39:24.932] getGlobalsAndPackages() ... DONE
[17:39:24.932]    + additional globals found: [n=0] 
[17:39:24.932]    + additional namespaces needed: [n=0] 
[17:39:24.932]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:24.932]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:24.932]  - seeds: <none>
[17:39:24.932] getGlobalsAndPackages() ...
[17:39:24.933] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.933] Resolving globals: FALSE
[17:39:24.933] Tweak future expression to call with '...' arguments ...
[17:39:24.933] {
[17:39:24.933]     do.call(function(...) {
[17:39:24.933]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.933]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.933]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.933]             on.exit(options(oopts), add = TRUE)
[17:39:24.933]         }
[17:39:24.933]         {
[17:39:24.933]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.933]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.933]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.933]             })
[17:39:24.933]         }
[17:39:24.933]     }, args = future.call.arguments)
[17:39:24.933] }
[17:39:24.933] Tweak future expression to call with '...' arguments ... DONE
[17:39:24.933] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.934] 
[17:39:24.934] getGlobalsAndPackages() ... DONE
[17:39:24.934] run() for ‘Future’ ...
[17:39:24.934] - state: ‘created’
[17:39:24.934] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:24.935] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.935] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:24.935]   - Field: ‘label’
[17:39:24.935]   - Field: ‘local’
[17:39:24.935]   - Field: ‘owner’
[17:39:24.935]   - Field: ‘envir’
[17:39:24.935]   - Field: ‘packages’
[17:39:24.935]   - Field: ‘gc’
[17:39:24.935]   - Field: ‘conditions’
[17:39:24.936]   - Field: ‘expr’
[17:39:24.936]   - Field: ‘uuid’
[17:39:24.936]   - Field: ‘seed’
[17:39:24.936]   - Field: ‘version’
[17:39:24.936]   - Field: ‘result’
[17:39:24.936]   - Field: ‘asynchronous’
[17:39:24.936]   - Field: ‘calls’
[17:39:24.936]   - Field: ‘globals’
[17:39:24.936]   - Field: ‘stdout’
[17:39:24.936]   - Field: ‘earlySignal’
[17:39:24.936]   - Field: ‘lazy’
[17:39:24.937]   - Field: ‘state’
[17:39:24.937] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:24.937] - Launch lazy future ...
[17:39:24.937] Packages needed by the future expression (n = 0): <none>
[17:39:24.937] Packages needed by future strategies (n = 0): <none>
[17:39:24.938] {
[17:39:24.938]     {
[17:39:24.938]         {
[17:39:24.938]             ...future.startTime <- base::Sys.time()
[17:39:24.938]             {
[17:39:24.938]                 {
[17:39:24.938]                   {
[17:39:24.938]                     base::local({
[17:39:24.938]                       has_future <- base::requireNamespace("future", 
[17:39:24.938]                         quietly = TRUE)
[17:39:24.938]                       if (has_future) {
[17:39:24.938]                         ns <- base::getNamespace("future")
[17:39:24.938]                         version <- ns[[".package"]][["version"]]
[17:39:24.938]                         if (is.null(version)) 
[17:39:24.938]                           version <- utils::packageVersion("future")
[17:39:24.938]                       }
[17:39:24.938]                       else {
[17:39:24.938]                         version <- NULL
[17:39:24.938]                       }
[17:39:24.938]                       if (!has_future || version < "1.8.0") {
[17:39:24.938]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:24.938]                           "", base::R.version$version.string), 
[17:39:24.938]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:24.938]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:24.938]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:24.938]                             "release", "version")], collapse = " "), 
[17:39:24.938]                           hostname = base::Sys.info()[["nodename"]])
[17:39:24.938]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:24.938]                           info)
[17:39:24.938]                         info <- base::paste(info, collapse = "; ")
[17:39:24.938]                         if (!has_future) {
[17:39:24.938]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:24.938]                             info)
[17:39:24.938]                         }
[17:39:24.938]                         else {
[17:39:24.938]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:24.938]                             info, version)
[17:39:24.938]                         }
[17:39:24.938]                         base::stop(msg)
[17:39:24.938]                       }
[17:39:24.938]                     })
[17:39:24.938]                   }
[17:39:24.938]                   options(future.plan = NULL)
[17:39:24.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:24.938]                 }
[17:39:24.938]                 ...future.workdir <- getwd()
[17:39:24.938]             }
[17:39:24.938]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:24.938]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:24.938]         }
[17:39:24.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:24.938]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:24.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:24.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:24.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:24.938]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:24.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:24.938]             base::names(...future.oldOptions))
[17:39:24.938]     }
[17:39:24.938]     if (FALSE) {
[17:39:24.938]     }
[17:39:24.938]     else {
[17:39:24.938]         if (TRUE) {
[17:39:24.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:24.938]                 open = "w")
[17:39:24.938]         }
[17:39:24.938]         else {
[17:39:24.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:24.938]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:24.938]         }
[17:39:24.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:24.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:24.938]             base::sink(type = "output", split = FALSE)
[17:39:24.938]             base::close(...future.stdout)
[17:39:24.938]         }, add = TRUE)
[17:39:24.938]     }
[17:39:24.938]     ...future.frame <- base::sys.nframe()
[17:39:24.938]     ...future.conditions <- base::list()
[17:39:24.938]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:24.938]     if (FALSE) {
[17:39:24.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:24.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:24.938]     }
[17:39:24.938]     ...future.result <- base::tryCatch({
[17:39:24.938]         base::withCallingHandlers({
[17:39:24.938]             ...future.value <- base::withVisible(base::local({
[17:39:24.938]                 do.call(function(...) {
[17:39:24.938]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.938]                   if (!identical(...future.globals.maxSize.org, 
[17:39:24.938]                     ...future.globals.maxSize)) {
[17:39:24.938]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.938]                     on.exit(options(oopts), add = TRUE)
[17:39:24.938]                   }
[17:39:24.938]                   {
[17:39:24.938]                     lapply(seq_along(...future.elements_ii), 
[17:39:24.938]                       FUN = function(jj) {
[17:39:24.938]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.938]                         ...future.FUN(...future.X_jj, ...)
[17:39:24.938]                       })
[17:39:24.938]                   }
[17:39:24.938]                 }, args = future.call.arguments)
[17:39:24.938]             }))
[17:39:24.938]             future::FutureResult(value = ...future.value$value, 
[17:39:24.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.938]                   ...future.rng), globalenv = if (FALSE) 
[17:39:24.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:24.938]                     ...future.globalenv.names))
[17:39:24.938]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:24.938]         }, condition = base::local({
[17:39:24.938]             c <- base::c
[17:39:24.938]             inherits <- base::inherits
[17:39:24.938]             invokeRestart <- base::invokeRestart
[17:39:24.938]             length <- base::length
[17:39:24.938]             list <- base::list
[17:39:24.938]             seq.int <- base::seq.int
[17:39:24.938]             signalCondition <- base::signalCondition
[17:39:24.938]             sys.calls <- base::sys.calls
[17:39:24.938]             `[[` <- base::`[[`
[17:39:24.938]             `+` <- base::`+`
[17:39:24.938]             `<<-` <- base::`<<-`
[17:39:24.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:24.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:24.938]                   3L)]
[17:39:24.938]             }
[17:39:24.938]             function(cond) {
[17:39:24.938]                 is_error <- inherits(cond, "error")
[17:39:24.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:24.938]                   NULL)
[17:39:24.938]                 if (is_error) {
[17:39:24.938]                   sessionInformation <- function() {
[17:39:24.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:24.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:24.938]                       search = base::search(), system = base::Sys.info())
[17:39:24.938]                   }
[17:39:24.938]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:24.938]                     cond$call), session = sessionInformation(), 
[17:39:24.938]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:24.938]                   signalCondition(cond)
[17:39:24.938]                 }
[17:39:24.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:24.938]                 "immediateCondition"))) {
[17:39:24.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:24.938]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:24.938]                   if (TRUE && !signal) {
[17:39:24.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.938]                     {
[17:39:24.938]                       inherits <- base::inherits
[17:39:24.938]                       invokeRestart <- base::invokeRestart
[17:39:24.938]                       is.null <- base::is.null
[17:39:24.938]                       muffled <- FALSE
[17:39:24.938]                       if (inherits(cond, "message")) {
[17:39:24.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.938]                         if (muffled) 
[17:39:24.938]                           invokeRestart("muffleMessage")
[17:39:24.938]                       }
[17:39:24.938]                       else if (inherits(cond, "warning")) {
[17:39:24.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.938]                         if (muffled) 
[17:39:24.938]                           invokeRestart("muffleWarning")
[17:39:24.938]                       }
[17:39:24.938]                       else if (inherits(cond, "condition")) {
[17:39:24.938]                         if (!is.null(pattern)) {
[17:39:24.938]                           computeRestarts <- base::computeRestarts
[17:39:24.938]                           grepl <- base::grepl
[17:39:24.938]                           restarts <- computeRestarts(cond)
[17:39:24.938]                           for (restart in restarts) {
[17:39:24.938]                             name <- restart$name
[17:39:24.938]                             if (is.null(name)) 
[17:39:24.938]                               next
[17:39:24.938]                             if (!grepl(pattern, name)) 
[17:39:24.938]                               next
[17:39:24.938]                             invokeRestart(restart)
[17:39:24.938]                             muffled <- TRUE
[17:39:24.938]                             break
[17:39:24.938]                           }
[17:39:24.938]                         }
[17:39:24.938]                       }
[17:39:24.938]                       invisible(muffled)
[17:39:24.938]                     }
[17:39:24.938]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.938]                   }
[17:39:24.938]                 }
[17:39:24.938]                 else {
[17:39:24.938]                   if (TRUE) {
[17:39:24.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.938]                     {
[17:39:24.938]                       inherits <- base::inherits
[17:39:24.938]                       invokeRestart <- base::invokeRestart
[17:39:24.938]                       is.null <- base::is.null
[17:39:24.938]                       muffled <- FALSE
[17:39:24.938]                       if (inherits(cond, "message")) {
[17:39:24.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.938]                         if (muffled) 
[17:39:24.938]                           invokeRestart("muffleMessage")
[17:39:24.938]                       }
[17:39:24.938]                       else if (inherits(cond, "warning")) {
[17:39:24.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.938]                         if (muffled) 
[17:39:24.938]                           invokeRestart("muffleWarning")
[17:39:24.938]                       }
[17:39:24.938]                       else if (inherits(cond, "condition")) {
[17:39:24.938]                         if (!is.null(pattern)) {
[17:39:24.938]                           computeRestarts <- base::computeRestarts
[17:39:24.938]                           grepl <- base::grepl
[17:39:24.938]                           restarts <- computeRestarts(cond)
[17:39:24.938]                           for (restart in restarts) {
[17:39:24.938]                             name <- restart$name
[17:39:24.938]                             if (is.null(name)) 
[17:39:24.938]                               next
[17:39:24.938]                             if (!grepl(pattern, name)) 
[17:39:24.938]                               next
[17:39:24.938]                             invokeRestart(restart)
[17:39:24.938]                             muffled <- TRUE
[17:39:24.938]                             break
[17:39:24.938]                           }
[17:39:24.938]                         }
[17:39:24.938]                       }
[17:39:24.938]                       invisible(muffled)
[17:39:24.938]                     }
[17:39:24.938]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.938]                   }
[17:39:24.938]                 }
[17:39:24.938]             }
[17:39:24.938]         }))
[17:39:24.938]     }, error = function(ex) {
[17:39:24.938]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:24.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.938]                 ...future.rng), started = ...future.startTime, 
[17:39:24.938]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:24.938]             version = "1.8"), class = "FutureResult")
[17:39:24.938]     }, finally = {
[17:39:24.938]         if (!identical(...future.workdir, getwd())) 
[17:39:24.938]             setwd(...future.workdir)
[17:39:24.938]         {
[17:39:24.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:24.938]                 ...future.oldOptions$nwarnings <- NULL
[17:39:24.938]             }
[17:39:24.938]             base::options(...future.oldOptions)
[17:39:24.938]             if (.Platform$OS.type == "windows") {
[17:39:24.938]                 old_names <- names(...future.oldEnvVars)
[17:39:24.938]                 envs <- base::Sys.getenv()
[17:39:24.938]                 names <- names(envs)
[17:39:24.938]                 common <- intersect(names, old_names)
[17:39:24.938]                 added <- setdiff(names, old_names)
[17:39:24.938]                 removed <- setdiff(old_names, names)
[17:39:24.938]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:24.938]                   envs[common]]
[17:39:24.938]                 NAMES <- toupper(changed)
[17:39:24.938]                 args <- list()
[17:39:24.938]                 for (kk in seq_along(NAMES)) {
[17:39:24.938]                   name <- changed[[kk]]
[17:39:24.938]                   NAME <- NAMES[[kk]]
[17:39:24.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.938]                     next
[17:39:24.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.938]                 }
[17:39:24.938]                 NAMES <- toupper(added)
[17:39:24.938]                 for (kk in seq_along(NAMES)) {
[17:39:24.938]                   name <- added[[kk]]
[17:39:24.938]                   NAME <- NAMES[[kk]]
[17:39:24.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.938]                     next
[17:39:24.938]                   args[[name]] <- ""
[17:39:24.938]                 }
[17:39:24.938]                 NAMES <- toupper(removed)
[17:39:24.938]                 for (kk in seq_along(NAMES)) {
[17:39:24.938]                   name <- removed[[kk]]
[17:39:24.938]                   NAME <- NAMES[[kk]]
[17:39:24.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.938]                     next
[17:39:24.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.938]                 }
[17:39:24.938]                 if (length(args) > 0) 
[17:39:24.938]                   base::do.call(base::Sys.setenv, args = args)
[17:39:24.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:24.938]             }
[17:39:24.938]             else {
[17:39:24.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:24.938]             }
[17:39:24.938]             {
[17:39:24.938]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:24.938]                   0L) {
[17:39:24.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:24.938]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:24.938]                   base::options(opts)
[17:39:24.938]                 }
[17:39:24.938]                 {
[17:39:24.938]                   {
[17:39:24.938]                     NULL
[17:39:24.938]                     RNGkind("Mersenne-Twister")
[17:39:24.938]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:24.938]                       inherits = FALSE)
[17:39:24.938]                   }
[17:39:24.938]                   options(future.plan = NULL)
[17:39:24.938]                   if (is.na(NA_character_)) 
[17:39:24.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:24.938]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:24.938]                   {
[17:39:24.938]                     future <- SequentialFuture(..., envir = envir)
[17:39:24.938]                     if (!future$lazy) 
[17:39:24.938]                       future <- run(future)
[17:39:24.938]                     invisible(future)
[17:39:24.938]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:24.938]                 }
[17:39:24.938]             }
[17:39:24.938]         }
[17:39:24.938]     })
[17:39:24.938]     if (TRUE) {
[17:39:24.938]         base::sink(type = "output", split = FALSE)
[17:39:24.938]         if (TRUE) {
[17:39:24.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:24.938]         }
[17:39:24.938]         else {
[17:39:24.938]             ...future.result["stdout"] <- base::list(NULL)
[17:39:24.938]         }
[17:39:24.938]         base::close(...future.stdout)
[17:39:24.938]         ...future.stdout <- NULL
[17:39:24.938]     }
[17:39:24.938]     ...future.result$conditions <- ...future.conditions
[17:39:24.938]     ...future.result$finished <- base::Sys.time()
[17:39:24.938]     ...future.result
[17:39:24.938] }
[17:39:24.939] assign_globals() ...
[17:39:24.939] List of 5
[17:39:24.939]  $ ...future.FUN            :function (object, ...)  
[17:39:24.939]  $ future.call.arguments    : list()
[17:39:24.939]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.939]  $ ...future.elements_ii    :List of 3
[17:39:24.939]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.939]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:24.939]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.939]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:24.939]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.939]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:24.939]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.939]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:24.939]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.939]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:24.939]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.939]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:24.939]  $ ...future.seeds_ii       : NULL
[17:39:24.939]  $ ...future.globals.maxSize: NULL
[17:39:24.939]  - attr(*, "resolved")= logi FALSE
[17:39:24.939]  - attr(*, "total_size")= num 1240
[17:39:24.939]  - attr(*, "where")=List of 5
[17:39:24.939]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:24.939]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:24.939]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:24.939]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:24.939]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:24.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.939]  - attr(*, "already-done")= logi TRUE
[17:39:24.950] - copied ‘...future.FUN’ to environment
[17:39:24.950] - copied ‘future.call.arguments’ to environment
[17:39:24.950] - copied ‘...future.elements_ii’ to environment
[17:39:24.950] - copied ‘...future.seeds_ii’ to environment
[17:39:24.950] - copied ‘...future.globals.maxSize’ to environment
[17:39:24.951] assign_globals() ... done
[17:39:24.951] plan(): Setting new future strategy stack:
[17:39:24.951] List of future strategies:
[17:39:24.951] 1. sequential:
[17:39:24.951]    - args: function (..., envir = parent.frame())
[17:39:24.951]    - tweaked: FALSE
[17:39:24.951]    - call: NULL
[17:39:24.951] plan(): nbrOfWorkers() = 1
[17:39:24.954] plan(): Setting new future strategy stack:
[17:39:24.954] List of future strategies:
[17:39:24.954] 1. sequential:
[17:39:24.954]    - args: function (..., envir = parent.frame())
[17:39:24.954]    - tweaked: FALSE
[17:39:24.954]    - call: plan(strategy)
[17:39:24.954] plan(): nbrOfWorkers() = 1
[17:39:24.954] SequentialFuture started (and completed)
[17:39:24.954] - Launch lazy future ... done
[17:39:24.954] run() for ‘SequentialFuture’ ... done
[17:39:24.955] Created future:
[17:39:24.955] SequentialFuture:
[17:39:24.955] Label: ‘future_by-1’
[17:39:24.955] Expression:
[17:39:24.955] {
[17:39:24.955]     do.call(function(...) {
[17:39:24.955]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.955]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.955]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.955]             on.exit(options(oopts), add = TRUE)
[17:39:24.955]         }
[17:39:24.955]         {
[17:39:24.955]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.955]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.955]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.955]             })
[17:39:24.955]         }
[17:39:24.955]     }, args = future.call.arguments)
[17:39:24.955] }
[17:39:24.955] Lazy evaluation: FALSE
[17:39:24.955] Asynchronous evaluation: FALSE
[17:39:24.955] Local evaluation: TRUE
[17:39:24.955] Environment: 0x562970df5a40
[17:39:24.955] Capture standard output: TRUE
[17:39:24.955] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:24.955] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:24.955] Packages: <none>
[17:39:24.955] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:24.955] Resolved: TRUE
[17:39:24.955] Value: 5.37 KiB of class ‘list’
[17:39:24.955] Early signaling: FALSE
[17:39:24.955] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:24.955] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.956] Chunk #1 of 1 ... DONE
[17:39:24.956] Launching 1 futures (chunks) ... DONE
[17:39:24.956] Resolving 1 futures (chunks) ...
[17:39:24.956] resolve() on list ...
[17:39:24.956]  recursive: 0
[17:39:24.956]  length: 1
[17:39:24.957] 
[17:39:24.957] resolved() for ‘SequentialFuture’ ...
[17:39:24.957] - state: ‘finished’
[17:39:24.957] - run: TRUE
[17:39:24.957] - result: ‘FutureResult’
[17:39:24.957] resolved() for ‘SequentialFuture’ ... done
[17:39:24.957] Future #1
[17:39:24.957] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:24.957] - nx: 1
[17:39:24.958] - relay: TRUE
[17:39:24.958] - stdout: TRUE
[17:39:24.958] - signal: TRUE
[17:39:24.958] - resignal: FALSE
[17:39:24.958] - force: TRUE
[17:39:24.958] - relayed: [n=1] FALSE
[17:39:24.958] - queued futures: [n=1] FALSE
[17:39:24.958]  - until=1
[17:39:24.958]  - relaying element #1
[17:39:24.958] - relayed: [n=1] TRUE
[17:39:24.959] - queued futures: [n=1] TRUE
[17:39:24.959] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:24.959]  length: 0 (resolved future 1)
[17:39:24.959] Relaying remaining futures
[17:39:24.959] signalConditionsASAP(NULL, pos=0) ...
[17:39:24.959] - nx: 1
[17:39:24.959] - relay: TRUE
[17:39:24.959] - stdout: TRUE
[17:39:24.959] - signal: TRUE
[17:39:24.959] - resignal: FALSE
[17:39:24.959] - force: TRUE
[17:39:24.959] - relayed: [n=1] TRUE
[17:39:24.960] - queued futures: [n=1] TRUE
 - flush all
[17:39:24.960] - relayed: [n=1] TRUE
[17:39:24.960] - queued futures: [n=1] TRUE
[17:39:24.960] signalConditionsASAP(NULL, pos=0) ... done
[17:39:24.960] resolve() on list ... DONE
[17:39:24.960]  - Number of value chunks collected: 1
[17:39:24.960] Resolving 1 futures (chunks) ... DONE
[17:39:24.960] Reducing values from 1 chunks ...
[17:39:24.960]  - Number of values collected after concatenation: 3
[17:39:24.961]  - Number of values expected: 3
[17:39:24.961] Reducing values from 1 chunks ... DONE
[17:39:24.961] future_lapply() ... DONE
[17:39:24.961] future_by_internal() ... DONE
[17:39:24.963] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:39:24.963] future_lapply() ...
[17:39:24.964] Number of chunks: 1
[17:39:24.964] getGlobalsAndPackagesXApply() ...
[17:39:24.964]  - future.globals: TRUE
[17:39:24.964] getGlobalsAndPackages() ...
[17:39:24.964] Searching for globals...
[17:39:24.967] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:24.967] Searching for globals ... DONE
[17:39:24.967] Resolving globals: FALSE
[17:39:24.967] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:24.968] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:24.968] - globals: [1] ‘FUN’
[17:39:24.968] 
[17:39:24.968] getGlobalsAndPackages() ... DONE
[17:39:24.968]  - globals found/used: [n=1] ‘FUN’
[17:39:24.968]  - needed namespaces: [n=0] 
[17:39:24.968] Finding globals ... DONE
[17:39:24.968]  - use_args: TRUE
[17:39:24.969]  - Getting '...' globals ...
[17:39:24.969] resolve() on list ...
[17:39:24.969]  recursive: 0
[17:39:24.969]  length: 1
[17:39:24.969]  elements: ‘...’
[17:39:24.969]  length: 0 (resolved future 1)
[17:39:24.969] resolve() on list ... DONE
[17:39:24.969]    - '...' content: [n=0] 
[17:39:24.970] List of 1
[17:39:24.970]  $ ...: list()
[17:39:24.970]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.970]  - attr(*, "where")=List of 1
[17:39:24.970]   ..$ ...:<environment: 0x562970f49600> 
[17:39:24.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.970]  - attr(*, "resolved")= logi TRUE
[17:39:24.970]  - attr(*, "total_size")= num NA
[17:39:24.972]  - Getting '...' globals ... DONE
[17:39:24.972] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:24.972] List of 2
[17:39:24.972]  $ ...future.FUN:function (object, ...)  
[17:39:24.972]  $ ...          : list()
[17:39:24.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.972]  - attr(*, "where")=List of 2
[17:39:24.972]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:24.972]   ..$ ...          :<environment: 0x562970f49600> 
[17:39:24.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.972]  - attr(*, "resolved")= logi FALSE
[17:39:24.972]  - attr(*, "total_size")= num 1240
[17:39:24.975] Packages to be attached in all futures: [n=0] 
[17:39:24.975] getGlobalsAndPackagesXApply() ... DONE
[17:39:24.975] Number of futures (= number of chunks): 1
[17:39:24.975] Launching 1 futures (chunks) ...
[17:39:24.975] Chunk #1 of 1 ...
[17:39:24.976]  - Finding globals in 'X' for chunk #1 ...
[17:39:24.976] getGlobalsAndPackages() ...
[17:39:24.976] Searching for globals...
[17:39:24.976] 
[17:39:24.976] Searching for globals ... DONE
[17:39:24.976] - globals: [0] <none>
[17:39:24.976] getGlobalsAndPackages() ... DONE
[17:39:24.976]    + additional globals found: [n=0] 
[17:39:24.977]    + additional namespaces needed: [n=0] 
[17:39:24.977]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:24.977]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:24.977]  - seeds: <none>
[17:39:24.977] getGlobalsAndPackages() ...
[17:39:24.977] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.977] Resolving globals: FALSE
[17:39:24.977] Tweak future expression to call with '...' arguments ...
[17:39:24.977] {
[17:39:24.977]     do.call(function(...) {
[17:39:24.977]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.977]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.977]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.977]             on.exit(options(oopts), add = TRUE)
[17:39:24.977]         }
[17:39:24.977]         {
[17:39:24.977]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.977]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.977]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.977]             })
[17:39:24.977]         }
[17:39:24.977]     }, args = future.call.arguments)
[17:39:24.977] }
[17:39:24.978] Tweak future expression to call with '...' arguments ... DONE
[17:39:24.978] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.978] 
[17:39:24.978] getGlobalsAndPackages() ... DONE
[17:39:24.978] run() for ‘Future’ ...
[17:39:24.979] - state: ‘created’
[17:39:24.979] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:24.979] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:24.979]   - Field: ‘label’
[17:39:24.979]   - Field: ‘local’
[17:39:24.979]   - Field: ‘owner’
[17:39:24.980]   - Field: ‘envir’
[17:39:24.980]   - Field: ‘packages’
[17:39:24.980]   - Field: ‘gc’
[17:39:24.980]   - Field: ‘conditions’
[17:39:24.980]   - Field: ‘expr’
[17:39:24.980]   - Field: ‘uuid’
[17:39:24.980]   - Field: ‘seed’
[17:39:24.980]   - Field: ‘version’
[17:39:24.980]   - Field: ‘result’
[17:39:24.980]   - Field: ‘asynchronous’
[17:39:24.981]   - Field: ‘calls’
[17:39:24.981]   - Field: ‘globals’
[17:39:24.981]   - Field: ‘stdout’
[17:39:24.981]   - Field: ‘earlySignal’
[17:39:24.981]   - Field: ‘lazy’
[17:39:24.981]   - Field: ‘state’
[17:39:24.981] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:24.981] - Launch lazy future ...
[17:39:24.981] Packages needed by the future expression (n = 0): <none>
[17:39:24.981] Packages needed by future strategies (n = 0): <none>
[17:39:24.982] {
[17:39:24.982]     {
[17:39:24.982]         {
[17:39:24.982]             ...future.startTime <- base::Sys.time()
[17:39:24.982]             {
[17:39:24.982]                 {
[17:39:24.982]                   {
[17:39:24.982]                     base::local({
[17:39:24.982]                       has_future <- base::requireNamespace("future", 
[17:39:24.982]                         quietly = TRUE)
[17:39:24.982]                       if (has_future) {
[17:39:24.982]                         ns <- base::getNamespace("future")
[17:39:24.982]                         version <- ns[[".package"]][["version"]]
[17:39:24.982]                         if (is.null(version)) 
[17:39:24.982]                           version <- utils::packageVersion("future")
[17:39:24.982]                       }
[17:39:24.982]                       else {
[17:39:24.982]                         version <- NULL
[17:39:24.982]                       }
[17:39:24.982]                       if (!has_future || version < "1.8.0") {
[17:39:24.982]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:24.982]                           "", base::R.version$version.string), 
[17:39:24.982]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:24.982]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:24.982]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:24.982]                             "release", "version")], collapse = " "), 
[17:39:24.982]                           hostname = base::Sys.info()[["nodename"]])
[17:39:24.982]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:24.982]                           info)
[17:39:24.982]                         info <- base::paste(info, collapse = "; ")
[17:39:24.982]                         if (!has_future) {
[17:39:24.982]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:24.982]                             info)
[17:39:24.982]                         }
[17:39:24.982]                         else {
[17:39:24.982]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:24.982]                             info, version)
[17:39:24.982]                         }
[17:39:24.982]                         base::stop(msg)
[17:39:24.982]                       }
[17:39:24.982]                     })
[17:39:24.982]                   }
[17:39:24.982]                   options(future.plan = NULL)
[17:39:24.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:24.982]                 }
[17:39:24.982]                 ...future.workdir <- getwd()
[17:39:24.982]             }
[17:39:24.982]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:24.982]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:24.982]         }
[17:39:24.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:24.982]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:24.982]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:24.982]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:24.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:24.982]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:24.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:24.982]             base::names(...future.oldOptions))
[17:39:24.982]     }
[17:39:24.982]     if (FALSE) {
[17:39:24.982]     }
[17:39:24.982]     else {
[17:39:24.982]         if (TRUE) {
[17:39:24.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:24.982]                 open = "w")
[17:39:24.982]         }
[17:39:24.982]         else {
[17:39:24.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:24.982]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:24.982]         }
[17:39:24.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:24.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:24.982]             base::sink(type = "output", split = FALSE)
[17:39:24.982]             base::close(...future.stdout)
[17:39:24.982]         }, add = TRUE)
[17:39:24.982]     }
[17:39:24.982]     ...future.frame <- base::sys.nframe()
[17:39:24.982]     ...future.conditions <- base::list()
[17:39:24.982]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:24.982]     if (FALSE) {
[17:39:24.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:24.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:24.982]     }
[17:39:24.982]     ...future.result <- base::tryCatch({
[17:39:24.982]         base::withCallingHandlers({
[17:39:24.982]             ...future.value <- base::withVisible(base::local({
[17:39:24.982]                 do.call(function(...) {
[17:39:24.982]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.982]                   if (!identical(...future.globals.maxSize.org, 
[17:39:24.982]                     ...future.globals.maxSize)) {
[17:39:24.982]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.982]                     on.exit(options(oopts), add = TRUE)
[17:39:24.982]                   }
[17:39:24.982]                   {
[17:39:24.982]                     lapply(seq_along(...future.elements_ii), 
[17:39:24.982]                       FUN = function(jj) {
[17:39:24.982]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.982]                         ...future.FUN(...future.X_jj, ...)
[17:39:24.982]                       })
[17:39:24.982]                   }
[17:39:24.982]                 }, args = future.call.arguments)
[17:39:24.982]             }))
[17:39:24.982]             future::FutureResult(value = ...future.value$value, 
[17:39:24.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.982]                   ...future.rng), globalenv = if (FALSE) 
[17:39:24.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:24.982]                     ...future.globalenv.names))
[17:39:24.982]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:24.982]         }, condition = base::local({
[17:39:24.982]             c <- base::c
[17:39:24.982]             inherits <- base::inherits
[17:39:24.982]             invokeRestart <- base::invokeRestart
[17:39:24.982]             length <- base::length
[17:39:24.982]             list <- base::list
[17:39:24.982]             seq.int <- base::seq.int
[17:39:24.982]             signalCondition <- base::signalCondition
[17:39:24.982]             sys.calls <- base::sys.calls
[17:39:24.982]             `[[` <- base::`[[`
[17:39:24.982]             `+` <- base::`+`
[17:39:24.982]             `<<-` <- base::`<<-`
[17:39:24.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:24.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:24.982]                   3L)]
[17:39:24.982]             }
[17:39:24.982]             function(cond) {
[17:39:24.982]                 is_error <- inherits(cond, "error")
[17:39:24.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:24.982]                   NULL)
[17:39:24.982]                 if (is_error) {
[17:39:24.982]                   sessionInformation <- function() {
[17:39:24.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:24.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:24.982]                       search = base::search(), system = base::Sys.info())
[17:39:24.982]                   }
[17:39:24.982]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:24.982]                     cond$call), session = sessionInformation(), 
[17:39:24.982]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:24.982]                   signalCondition(cond)
[17:39:24.982]                 }
[17:39:24.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:24.982]                 "immediateCondition"))) {
[17:39:24.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:24.982]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:24.982]                   if (TRUE && !signal) {
[17:39:24.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.982]                     {
[17:39:24.982]                       inherits <- base::inherits
[17:39:24.982]                       invokeRestart <- base::invokeRestart
[17:39:24.982]                       is.null <- base::is.null
[17:39:24.982]                       muffled <- FALSE
[17:39:24.982]                       if (inherits(cond, "message")) {
[17:39:24.982]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.982]                         if (muffled) 
[17:39:24.982]                           invokeRestart("muffleMessage")
[17:39:24.982]                       }
[17:39:24.982]                       else if (inherits(cond, "warning")) {
[17:39:24.982]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.982]                         if (muffled) 
[17:39:24.982]                           invokeRestart("muffleWarning")
[17:39:24.982]                       }
[17:39:24.982]                       else if (inherits(cond, "condition")) {
[17:39:24.982]                         if (!is.null(pattern)) {
[17:39:24.982]                           computeRestarts <- base::computeRestarts
[17:39:24.982]                           grepl <- base::grepl
[17:39:24.982]                           restarts <- computeRestarts(cond)
[17:39:24.982]                           for (restart in restarts) {
[17:39:24.982]                             name <- restart$name
[17:39:24.982]                             if (is.null(name)) 
[17:39:24.982]                               next
[17:39:24.982]                             if (!grepl(pattern, name)) 
[17:39:24.982]                               next
[17:39:24.982]                             invokeRestart(restart)
[17:39:24.982]                             muffled <- TRUE
[17:39:24.982]                             break
[17:39:24.982]                           }
[17:39:24.982]                         }
[17:39:24.982]                       }
[17:39:24.982]                       invisible(muffled)
[17:39:24.982]                     }
[17:39:24.982]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.982]                   }
[17:39:24.982]                 }
[17:39:24.982]                 else {
[17:39:24.982]                   if (TRUE) {
[17:39:24.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.982]                     {
[17:39:24.982]                       inherits <- base::inherits
[17:39:24.982]                       invokeRestart <- base::invokeRestart
[17:39:24.982]                       is.null <- base::is.null
[17:39:24.982]                       muffled <- FALSE
[17:39:24.982]                       if (inherits(cond, "message")) {
[17:39:24.982]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.982]                         if (muffled) 
[17:39:24.982]                           invokeRestart("muffleMessage")
[17:39:24.982]                       }
[17:39:24.982]                       else if (inherits(cond, "warning")) {
[17:39:24.982]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.982]                         if (muffled) 
[17:39:24.982]                           invokeRestart("muffleWarning")
[17:39:24.982]                       }
[17:39:24.982]                       else if (inherits(cond, "condition")) {
[17:39:24.982]                         if (!is.null(pattern)) {
[17:39:24.982]                           computeRestarts <- base::computeRestarts
[17:39:24.982]                           grepl <- base::grepl
[17:39:24.982]                           restarts <- computeRestarts(cond)
[17:39:24.982]                           for (restart in restarts) {
[17:39:24.982]                             name <- restart$name
[17:39:24.982]                             if (is.null(name)) 
[17:39:24.982]                               next
[17:39:24.982]                             if (!grepl(pattern, name)) 
[17:39:24.982]                               next
[17:39:24.982]                             invokeRestart(restart)
[17:39:24.982]                             muffled <- TRUE
[17:39:24.982]                             break
[17:39:24.982]                           }
[17:39:24.982]                         }
[17:39:24.982]                       }
[17:39:24.982]                       invisible(muffled)
[17:39:24.982]                     }
[17:39:24.982]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.982]                   }
[17:39:24.982]                 }
[17:39:24.982]             }
[17:39:24.982]         }))
[17:39:24.982]     }, error = function(ex) {
[17:39:24.982]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:24.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.982]                 ...future.rng), started = ...future.startTime, 
[17:39:24.982]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:24.982]             version = "1.8"), class = "FutureResult")
[17:39:24.982]     }, finally = {
[17:39:24.982]         if (!identical(...future.workdir, getwd())) 
[17:39:24.982]             setwd(...future.workdir)
[17:39:24.982]         {
[17:39:24.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:24.982]                 ...future.oldOptions$nwarnings <- NULL
[17:39:24.982]             }
[17:39:24.982]             base::options(...future.oldOptions)
[17:39:24.982]             if (.Platform$OS.type == "windows") {
[17:39:24.982]                 old_names <- names(...future.oldEnvVars)
[17:39:24.982]                 envs <- base::Sys.getenv()
[17:39:24.982]                 names <- names(envs)
[17:39:24.982]                 common <- intersect(names, old_names)
[17:39:24.982]                 added <- setdiff(names, old_names)
[17:39:24.982]                 removed <- setdiff(old_names, names)
[17:39:24.982]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:24.982]                   envs[common]]
[17:39:24.982]                 NAMES <- toupper(changed)
[17:39:24.982]                 args <- list()
[17:39:24.982]                 for (kk in seq_along(NAMES)) {
[17:39:24.982]                   name <- changed[[kk]]
[17:39:24.982]                   NAME <- NAMES[[kk]]
[17:39:24.982]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.982]                     next
[17:39:24.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.982]                 }
[17:39:24.982]                 NAMES <- toupper(added)
[17:39:24.982]                 for (kk in seq_along(NAMES)) {
[17:39:24.982]                   name <- added[[kk]]
[17:39:24.982]                   NAME <- NAMES[[kk]]
[17:39:24.982]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.982]                     next
[17:39:24.982]                   args[[name]] <- ""
[17:39:24.982]                 }
[17:39:24.982]                 NAMES <- toupper(removed)
[17:39:24.982]                 for (kk in seq_along(NAMES)) {
[17:39:24.982]                   name <- removed[[kk]]
[17:39:24.982]                   NAME <- NAMES[[kk]]
[17:39:24.982]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.982]                     next
[17:39:24.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.982]                 }
[17:39:24.982]                 if (length(args) > 0) 
[17:39:24.982]                   base::do.call(base::Sys.setenv, args = args)
[17:39:24.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:24.982]             }
[17:39:24.982]             else {
[17:39:24.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:24.982]             }
[17:39:24.982]             {
[17:39:24.982]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:24.982]                   0L) {
[17:39:24.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:24.982]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:24.982]                   base::options(opts)
[17:39:24.982]                 }
[17:39:24.982]                 {
[17:39:24.982]                   {
[17:39:24.982]                     NULL
[17:39:24.982]                     RNGkind("Mersenne-Twister")
[17:39:24.982]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:24.982]                       inherits = FALSE)
[17:39:24.982]                   }
[17:39:24.982]                   options(future.plan = NULL)
[17:39:24.982]                   if (is.na(NA_character_)) 
[17:39:24.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:24.982]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:24.982]                   {
[17:39:24.982]                     future <- SequentialFuture(..., envir = envir)
[17:39:24.982]                     if (!future$lazy) 
[17:39:24.982]                       future <- run(future)
[17:39:24.982]                     invisible(future)
[17:39:24.982]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:24.982]                 }
[17:39:24.982]             }
[17:39:24.982]         }
[17:39:24.982]     })
[17:39:24.982]     if (TRUE) {
[17:39:24.982]         base::sink(type = "output", split = FALSE)
[17:39:24.982]         if (TRUE) {
[17:39:24.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:24.982]         }
[17:39:24.982]         else {
[17:39:24.982]             ...future.result["stdout"] <- base::list(NULL)
[17:39:24.982]         }
[17:39:24.982]         base::close(...future.stdout)
[17:39:24.982]         ...future.stdout <- NULL
[17:39:24.982]     }
[17:39:24.982]     ...future.result$conditions <- ...future.conditions
[17:39:24.982]     ...future.result$finished <- base::Sys.time()
[17:39:24.982]     ...future.result
[17:39:24.982] }
[17:39:24.984] assign_globals() ...
[17:39:24.984] List of 5
[17:39:24.984]  $ ...future.FUN            :function (object, ...)  
[17:39:24.984]  $ future.call.arguments    : list()
[17:39:24.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.984]  $ ...future.elements_ii    :List of 3
[17:39:24.984]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.984]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:24.984]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.984]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:24.984]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.984]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:24.984]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.984]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:24.984]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:24.984]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:24.984]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:24.984]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:24.984]  $ ...future.seeds_ii       : NULL
[17:39:24.984]  $ ...future.globals.maxSize: NULL
[17:39:24.984]  - attr(*, "resolved")= logi FALSE
[17:39:24.984]  - attr(*, "total_size")= num 1240
[17:39:24.984]  - attr(*, "where")=List of 5
[17:39:24.984]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:24.984]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:24.984]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:24.984]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:24.984]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:24.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.984]  - attr(*, "already-done")= logi TRUE
[17:39:24.994] - copied ‘...future.FUN’ to environment
[17:39:24.994] - copied ‘future.call.arguments’ to environment
[17:39:24.994] - copied ‘...future.elements_ii’ to environment
[17:39:24.994] - copied ‘...future.seeds_ii’ to environment
[17:39:24.994] - copied ‘...future.globals.maxSize’ to environment
[17:39:24.994] assign_globals() ... done
[17:39:24.994] plan(): Setting new future strategy stack:
[17:39:24.995] List of future strategies:
[17:39:24.995] 1. sequential:
[17:39:24.995]    - args: function (..., envir = parent.frame())
[17:39:24.995]    - tweaked: FALSE
[17:39:24.995]    - call: NULL
[17:39:24.995] plan(): nbrOfWorkers() = 1
[17:39:24.997] plan(): Setting new future strategy stack:
[17:39:24.997] List of future strategies:
[17:39:24.997] 1. sequential:
[17:39:24.997]    - args: function (..., envir = parent.frame())
[17:39:24.997]    - tweaked: FALSE
[17:39:24.997]    - call: plan(strategy)
[17:39:24.998] plan(): nbrOfWorkers() = 1
[17:39:24.998] SequentialFuture started (and completed)
[17:39:24.998] - Launch lazy future ... done
[17:39:24.998] run() for ‘SequentialFuture’ ... done
[17:39:24.998] Created future:
[17:39:24.998] SequentialFuture:
[17:39:24.998] Label: ‘future_by-1’
[17:39:24.998] Expression:
[17:39:24.998] {
[17:39:24.998]     do.call(function(...) {
[17:39:24.998]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.998]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.998]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.998]             on.exit(options(oopts), add = TRUE)
[17:39:24.998]         }
[17:39:24.998]         {
[17:39:24.998]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.998]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.998]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.998]             })
[17:39:24.998]         }
[17:39:24.998]     }, args = future.call.arguments)
[17:39:24.998] }
[17:39:24.998] Lazy evaluation: FALSE
[17:39:24.998] Asynchronous evaluation: FALSE
[17:39:24.998] Local evaluation: TRUE
[17:39:24.998] Environment: 0x562970dcfd40
[17:39:24.998] Capture standard output: TRUE
[17:39:24.998] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:24.998] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:24.998] Packages: <none>
[17:39:24.998] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:24.998] Resolved: TRUE
[17:39:24.998] Value: 5.37 KiB of class ‘list’
[17:39:24.998] Early signaling: FALSE
[17:39:24.998] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:24.998] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:24.999] Chunk #1 of 1 ... DONE
[17:39:25.000] Launching 1 futures (chunks) ... DONE
[17:39:25.000] Resolving 1 futures (chunks) ...
[17:39:25.000] resolve() on list ...
[17:39:25.000]  recursive: 0
[17:39:25.000]  length: 1
[17:39:25.000] 
[17:39:25.000] resolved() for ‘SequentialFuture’ ...
[17:39:25.000] - state: ‘finished’
[17:39:25.000] - run: TRUE
[17:39:25.000] - result: ‘FutureResult’
[17:39:25.001] resolved() for ‘SequentialFuture’ ... done
[17:39:25.001] Future #1
[17:39:25.001] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.001] - nx: 1
[17:39:25.001] - relay: TRUE
[17:39:25.001] - stdout: TRUE
[17:39:25.001] - signal: TRUE
[17:39:25.001] - resignal: FALSE
[17:39:25.001] - force: TRUE
[17:39:25.001] - relayed: [n=1] FALSE
[17:39:25.001] - queued futures: [n=1] FALSE
[17:39:25.002]  - until=1
[17:39:25.002]  - relaying element #1
[17:39:25.002] - relayed: [n=1] TRUE
[17:39:25.002] - queued futures: [n=1] TRUE
[17:39:25.002] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.002]  length: 0 (resolved future 1)
[17:39:25.002] Relaying remaining futures
[17:39:25.002] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.002] - nx: 1
[17:39:25.002] - relay: TRUE
[17:39:25.003] - stdout: TRUE
[17:39:25.003] - signal: TRUE
[17:39:25.003] - resignal: FALSE
[17:39:25.003] - force: TRUE
[17:39:25.003] - relayed: [n=1] TRUE
[17:39:25.003] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.003] - relayed: [n=1] TRUE
[17:39:25.003] - queued futures: [n=1] TRUE
[17:39:25.003] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.003] resolve() on list ... DONE
[17:39:25.004]  - Number of value chunks collected: 1
[17:39:25.004] Resolving 1 futures (chunks) ... DONE
[17:39:25.004] Reducing values from 1 chunks ...
[17:39:25.004]  - Number of values collected after concatenation: 3
[17:39:25.004]  - Number of values expected: 3
[17:39:25.004] Reducing values from 1 chunks ... DONE
[17:39:25.004] future_lapply() ... DONE
[17:39:25.004] future_by_internal() ... DONE
[17:39:25.005] future_by_internal() ...
- plan('multicore') ...
[17:39:25.006] plan(): Setting new future strategy stack:
[17:39:25.006] List of future strategies:
[17:39:25.006] 1. multicore:
[17:39:25.006]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:25.006]    - tweaked: FALSE
[17:39:25.006]    - call: plan(strategy)
[17:39:25.011] plan(): nbrOfWorkers() = 1
[17:39:25.011] future_by_internal() ...
[17:39:25.012] future_lapply() ...
[17:39:25.015] Number of chunks: 1
[17:39:25.016] getGlobalsAndPackagesXApply() ...
[17:39:25.016]  - future.globals: TRUE
[17:39:25.016] getGlobalsAndPackages() ...
[17:39:25.016] Searching for globals...
[17:39:25.017] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.017] Searching for globals ... DONE
[17:39:25.017] Resolving globals: FALSE
[17:39:25.017] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.018] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.018] - globals: [1] ‘FUN’
[17:39:25.018] 
[17:39:25.018] getGlobalsAndPackages() ... DONE
[17:39:25.018]  - globals found/used: [n=1] ‘FUN’
[17:39:25.018]  - needed namespaces: [n=0] 
[17:39:25.018] Finding globals ... DONE
[17:39:25.019]  - use_args: TRUE
[17:39:25.019]  - Getting '...' globals ...
[17:39:25.019] resolve() on list ...
[17:39:25.019]  recursive: 0
[17:39:25.019]  length: 1
[17:39:25.019]  elements: ‘...’
[17:39:25.019]  length: 0 (resolved future 1)
[17:39:25.019] resolve() on list ... DONE
[17:39:25.020]    - '...' content: [n=0] 
[17:39:25.020] List of 1
[17:39:25.020]  $ ...: list()
[17:39:25.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.020]  - attr(*, "where")=List of 1
[17:39:25.020]   ..$ ...:<environment: 0x56296f7f2d48> 
[17:39:25.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.020]  - attr(*, "resolved")= logi TRUE
[17:39:25.020]  - attr(*, "total_size")= num NA
[17:39:25.022]  - Getting '...' globals ... DONE
[17:39:25.022] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.022] List of 2
[17:39:25.022]  $ ...future.FUN:function (object, ...)  
[17:39:25.022]  $ ...          : list()
[17:39:25.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.022]  - attr(*, "where")=List of 2
[17:39:25.022]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.022]   ..$ ...          :<environment: 0x56296f7f2d48> 
[17:39:25.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.022]  - attr(*, "resolved")= logi FALSE
[17:39:25.022]  - attr(*, "total_size")= num 1240
[17:39:25.025] Packages to be attached in all futures: [n=0] 
[17:39:25.025] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.025] Number of futures (= number of chunks): 1
[17:39:25.026] Launching 1 futures (chunks) ...
[17:39:25.026] Chunk #1 of 1 ...
[17:39:25.026]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.026] getGlobalsAndPackages() ...
[17:39:25.026] Searching for globals...
[17:39:25.026] 
[17:39:25.026] Searching for globals ... DONE
[17:39:25.027] - globals: [0] <none>
[17:39:25.027] getGlobalsAndPackages() ... DONE
[17:39:25.027]    + additional globals found: [n=0] 
[17:39:25.027]    + additional namespaces needed: [n=0] 
[17:39:25.027]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.027]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.027]  - seeds: <none>
[17:39:25.027] getGlobalsAndPackages() ...
[17:39:25.027] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.028] Resolving globals: FALSE
[17:39:25.028] Tweak future expression to call with '...' arguments ...
[17:39:25.028] {
[17:39:25.028]     do.call(function(...) {
[17:39:25.028]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.028]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.028]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.028]             on.exit(options(oopts), add = TRUE)
[17:39:25.028]         }
[17:39:25.028]         {
[17:39:25.028]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.028]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.028]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.028]             })
[17:39:25.028]         }
[17:39:25.028]     }, args = future.call.arguments)
[17:39:25.028] }
[17:39:25.028] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.028] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.028] 
[17:39:25.029] getGlobalsAndPackages() ... DONE
[17:39:25.029] run() for ‘Future’ ...
[17:39:25.029] - state: ‘created’
[17:39:25.029] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.033] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.033] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.033]   - Field: ‘label’
[17:39:25.033]   - Field: ‘local’
[17:39:25.033]   - Field: ‘owner’
[17:39:25.033]   - Field: ‘envir’
[17:39:25.033]   - Field: ‘packages’
[17:39:25.033]   - Field: ‘gc’
[17:39:25.033]   - Field: ‘conditions’
[17:39:25.034]   - Field: ‘expr’
[17:39:25.034]   - Field: ‘uuid’
[17:39:25.034]   - Field: ‘seed’
[17:39:25.034]   - Field: ‘version’
[17:39:25.036]   - Field: ‘result’
[17:39:25.036]   - Field: ‘asynchronous’
[17:39:25.036]   - Field: ‘calls’
[17:39:25.036]   - Field: ‘globals’
[17:39:25.036]   - Field: ‘stdout’
[17:39:25.036]   - Field: ‘earlySignal’
[17:39:25.036]   - Field: ‘lazy’
[17:39:25.036]   - Field: ‘state’
[17:39:25.036] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.037] - Launch lazy future ...
[17:39:25.037] Packages needed by the future expression (n = 0): <none>
[17:39:25.037] Packages needed by future strategies (n = 0): <none>
[17:39:25.037] {
[17:39:25.037]     {
[17:39:25.037]         {
[17:39:25.037]             ...future.startTime <- base::Sys.time()
[17:39:25.037]             {
[17:39:25.037]                 {
[17:39:25.037]                   {
[17:39:25.037]                     base::local({
[17:39:25.037]                       has_future <- base::requireNamespace("future", 
[17:39:25.037]                         quietly = TRUE)
[17:39:25.037]                       if (has_future) {
[17:39:25.037]                         ns <- base::getNamespace("future")
[17:39:25.037]                         version <- ns[[".package"]][["version"]]
[17:39:25.037]                         if (is.null(version)) 
[17:39:25.037]                           version <- utils::packageVersion("future")
[17:39:25.037]                       }
[17:39:25.037]                       else {
[17:39:25.037]                         version <- NULL
[17:39:25.037]                       }
[17:39:25.037]                       if (!has_future || version < "1.8.0") {
[17:39:25.037]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.037]                           "", base::R.version$version.string), 
[17:39:25.037]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.037]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.037]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.037]                             "release", "version")], collapse = " "), 
[17:39:25.037]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.037]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.037]                           info)
[17:39:25.037]                         info <- base::paste(info, collapse = "; ")
[17:39:25.037]                         if (!has_future) {
[17:39:25.037]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.037]                             info)
[17:39:25.037]                         }
[17:39:25.037]                         else {
[17:39:25.037]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.037]                             info, version)
[17:39:25.037]                         }
[17:39:25.037]                         base::stop(msg)
[17:39:25.037]                       }
[17:39:25.037]                     })
[17:39:25.037]                   }
[17:39:25.037]                   options(future.plan = NULL)
[17:39:25.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.037]                 }
[17:39:25.037]                 ...future.workdir <- getwd()
[17:39:25.037]             }
[17:39:25.037]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.037]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.037]         }
[17:39:25.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.037]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.037]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.037]             base::names(...future.oldOptions))
[17:39:25.037]     }
[17:39:25.037]     if (FALSE) {
[17:39:25.037]     }
[17:39:25.037]     else {
[17:39:25.037]         if (TRUE) {
[17:39:25.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.037]                 open = "w")
[17:39:25.037]         }
[17:39:25.037]         else {
[17:39:25.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.037]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.037]         }
[17:39:25.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.037]             base::sink(type = "output", split = FALSE)
[17:39:25.037]             base::close(...future.stdout)
[17:39:25.037]         }, add = TRUE)
[17:39:25.037]     }
[17:39:25.037]     ...future.frame <- base::sys.nframe()
[17:39:25.037]     ...future.conditions <- base::list()
[17:39:25.037]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.037]     if (FALSE) {
[17:39:25.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.037]     }
[17:39:25.037]     ...future.result <- base::tryCatch({
[17:39:25.037]         base::withCallingHandlers({
[17:39:25.037]             ...future.value <- base::withVisible(base::local({
[17:39:25.037]                 do.call(function(...) {
[17:39:25.037]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.037]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.037]                     ...future.globals.maxSize)) {
[17:39:25.037]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.037]                     on.exit(options(oopts), add = TRUE)
[17:39:25.037]                   }
[17:39:25.037]                   {
[17:39:25.037]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.037]                       FUN = function(jj) {
[17:39:25.037]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.037]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.037]                       })
[17:39:25.037]                   }
[17:39:25.037]                 }, args = future.call.arguments)
[17:39:25.037]             }))
[17:39:25.037]             future::FutureResult(value = ...future.value$value, 
[17:39:25.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.037]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.037]                     ...future.globalenv.names))
[17:39:25.037]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.037]         }, condition = base::local({
[17:39:25.037]             c <- base::c
[17:39:25.037]             inherits <- base::inherits
[17:39:25.037]             invokeRestart <- base::invokeRestart
[17:39:25.037]             length <- base::length
[17:39:25.037]             list <- base::list
[17:39:25.037]             seq.int <- base::seq.int
[17:39:25.037]             signalCondition <- base::signalCondition
[17:39:25.037]             sys.calls <- base::sys.calls
[17:39:25.037]             `[[` <- base::`[[`
[17:39:25.037]             `+` <- base::`+`
[17:39:25.037]             `<<-` <- base::`<<-`
[17:39:25.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.037]                   3L)]
[17:39:25.037]             }
[17:39:25.037]             function(cond) {
[17:39:25.037]                 is_error <- inherits(cond, "error")
[17:39:25.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.037]                   NULL)
[17:39:25.037]                 if (is_error) {
[17:39:25.037]                   sessionInformation <- function() {
[17:39:25.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.037]                       search = base::search(), system = base::Sys.info())
[17:39:25.037]                   }
[17:39:25.037]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.037]                     cond$call), session = sessionInformation(), 
[17:39:25.037]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.037]                   signalCondition(cond)
[17:39:25.037]                 }
[17:39:25.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.037]                 "immediateCondition"))) {
[17:39:25.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.037]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.037]                   if (TRUE && !signal) {
[17:39:25.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.037]                     {
[17:39:25.037]                       inherits <- base::inherits
[17:39:25.037]                       invokeRestart <- base::invokeRestart
[17:39:25.037]                       is.null <- base::is.null
[17:39:25.037]                       muffled <- FALSE
[17:39:25.037]                       if (inherits(cond, "message")) {
[17:39:25.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.037]                         if (muffled) 
[17:39:25.037]                           invokeRestart("muffleMessage")
[17:39:25.037]                       }
[17:39:25.037]                       else if (inherits(cond, "warning")) {
[17:39:25.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.037]                         if (muffled) 
[17:39:25.037]                           invokeRestart("muffleWarning")
[17:39:25.037]                       }
[17:39:25.037]                       else if (inherits(cond, "condition")) {
[17:39:25.037]                         if (!is.null(pattern)) {
[17:39:25.037]                           computeRestarts <- base::computeRestarts
[17:39:25.037]                           grepl <- base::grepl
[17:39:25.037]                           restarts <- computeRestarts(cond)
[17:39:25.037]                           for (restart in restarts) {
[17:39:25.037]                             name <- restart$name
[17:39:25.037]                             if (is.null(name)) 
[17:39:25.037]                               next
[17:39:25.037]                             if (!grepl(pattern, name)) 
[17:39:25.037]                               next
[17:39:25.037]                             invokeRestart(restart)
[17:39:25.037]                             muffled <- TRUE
[17:39:25.037]                             break
[17:39:25.037]                           }
[17:39:25.037]                         }
[17:39:25.037]                       }
[17:39:25.037]                       invisible(muffled)
[17:39:25.037]                     }
[17:39:25.037]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.037]                   }
[17:39:25.037]                 }
[17:39:25.037]                 else {
[17:39:25.037]                   if (TRUE) {
[17:39:25.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.037]                     {
[17:39:25.037]                       inherits <- base::inherits
[17:39:25.037]                       invokeRestart <- base::invokeRestart
[17:39:25.037]                       is.null <- base::is.null
[17:39:25.037]                       muffled <- FALSE
[17:39:25.037]                       if (inherits(cond, "message")) {
[17:39:25.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.037]                         if (muffled) 
[17:39:25.037]                           invokeRestart("muffleMessage")
[17:39:25.037]                       }
[17:39:25.037]                       else if (inherits(cond, "warning")) {
[17:39:25.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.037]                         if (muffled) 
[17:39:25.037]                           invokeRestart("muffleWarning")
[17:39:25.037]                       }
[17:39:25.037]                       else if (inherits(cond, "condition")) {
[17:39:25.037]                         if (!is.null(pattern)) {
[17:39:25.037]                           computeRestarts <- base::computeRestarts
[17:39:25.037]                           grepl <- base::grepl
[17:39:25.037]                           restarts <- computeRestarts(cond)
[17:39:25.037]                           for (restart in restarts) {
[17:39:25.037]                             name <- restart$name
[17:39:25.037]                             if (is.null(name)) 
[17:39:25.037]                               next
[17:39:25.037]                             if (!grepl(pattern, name)) 
[17:39:25.037]                               next
[17:39:25.037]                             invokeRestart(restart)
[17:39:25.037]                             muffled <- TRUE
[17:39:25.037]                             break
[17:39:25.037]                           }
[17:39:25.037]                         }
[17:39:25.037]                       }
[17:39:25.037]                       invisible(muffled)
[17:39:25.037]                     }
[17:39:25.037]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.037]                   }
[17:39:25.037]                 }
[17:39:25.037]             }
[17:39:25.037]         }))
[17:39:25.037]     }, error = function(ex) {
[17:39:25.037]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.037]                 ...future.rng), started = ...future.startTime, 
[17:39:25.037]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.037]             version = "1.8"), class = "FutureResult")
[17:39:25.037]     }, finally = {
[17:39:25.037]         if (!identical(...future.workdir, getwd())) 
[17:39:25.037]             setwd(...future.workdir)
[17:39:25.037]         {
[17:39:25.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.037]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.037]             }
[17:39:25.037]             base::options(...future.oldOptions)
[17:39:25.037]             if (.Platform$OS.type == "windows") {
[17:39:25.037]                 old_names <- names(...future.oldEnvVars)
[17:39:25.037]                 envs <- base::Sys.getenv()
[17:39:25.037]                 names <- names(envs)
[17:39:25.037]                 common <- intersect(names, old_names)
[17:39:25.037]                 added <- setdiff(names, old_names)
[17:39:25.037]                 removed <- setdiff(old_names, names)
[17:39:25.037]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.037]                   envs[common]]
[17:39:25.037]                 NAMES <- toupper(changed)
[17:39:25.037]                 args <- list()
[17:39:25.037]                 for (kk in seq_along(NAMES)) {
[17:39:25.037]                   name <- changed[[kk]]
[17:39:25.037]                   NAME <- NAMES[[kk]]
[17:39:25.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.037]                     next
[17:39:25.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.037]                 }
[17:39:25.037]                 NAMES <- toupper(added)
[17:39:25.037]                 for (kk in seq_along(NAMES)) {
[17:39:25.037]                   name <- added[[kk]]
[17:39:25.037]                   NAME <- NAMES[[kk]]
[17:39:25.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.037]                     next
[17:39:25.037]                   args[[name]] <- ""
[17:39:25.037]                 }
[17:39:25.037]                 NAMES <- toupper(removed)
[17:39:25.037]                 for (kk in seq_along(NAMES)) {
[17:39:25.037]                   name <- removed[[kk]]
[17:39:25.037]                   NAME <- NAMES[[kk]]
[17:39:25.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.037]                     next
[17:39:25.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.037]                 }
[17:39:25.037]                 if (length(args) > 0) 
[17:39:25.037]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.037]             }
[17:39:25.037]             else {
[17:39:25.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.037]             }
[17:39:25.037]             {
[17:39:25.037]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.037]                   0L) {
[17:39:25.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.037]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.037]                   base::options(opts)
[17:39:25.037]                 }
[17:39:25.037]                 {
[17:39:25.037]                   {
[17:39:25.037]                     NULL
[17:39:25.037]                     RNGkind("Mersenne-Twister")
[17:39:25.037]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.037]                       inherits = FALSE)
[17:39:25.037]                   }
[17:39:25.037]                   options(future.plan = NULL)
[17:39:25.037]                   if (is.na(NA_character_)) 
[17:39:25.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.037]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:25.037]                     envir = parent.frame()) 
[17:39:25.037]                   {
[17:39:25.037]                     default_workers <- missing(workers)
[17:39:25.037]                     if (is.function(workers)) 
[17:39:25.037]                       workers <- workers()
[17:39:25.037]                     workers <- structure(as.integer(workers), 
[17:39:25.037]                       class = class(workers))
[17:39:25.037]                     stop_if_not(is.finite(workers), workers >= 
[17:39:25.037]                       1L)
[17:39:25.037]                     if ((workers == 1L && !inherits(workers, 
[17:39:25.037]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:25.037]                       if (default_workers) 
[17:39:25.037]                         supportsMulticore(warn = TRUE)
[17:39:25.037]                       return(sequential(..., envir = envir))
[17:39:25.037]                     }
[17:39:25.037]                     oopts <- options(mc.cores = workers)
[17:39:25.037]                     on.exit(options(oopts))
[17:39:25.037]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:25.037]                       envir = envir)
[17:39:25.037]                     if (!future$lazy) 
[17:39:25.037]                       future <- run(future)
[17:39:25.037]                     invisible(future)
[17:39:25.037]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.037]                 }
[17:39:25.037]             }
[17:39:25.037]         }
[17:39:25.037]     })
[17:39:25.037]     if (TRUE) {
[17:39:25.037]         base::sink(type = "output", split = FALSE)
[17:39:25.037]         if (TRUE) {
[17:39:25.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.037]         }
[17:39:25.037]         else {
[17:39:25.037]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.037]         }
[17:39:25.037]         base::close(...future.stdout)
[17:39:25.037]         ...future.stdout <- NULL
[17:39:25.037]     }
[17:39:25.037]     ...future.result$conditions <- ...future.conditions
[17:39:25.037]     ...future.result$finished <- base::Sys.time()
[17:39:25.037]     ...future.result
[17:39:25.037] }
[17:39:25.039] assign_globals() ...
[17:39:25.039] List of 5
[17:39:25.039]  $ ...future.FUN            :function (object, ...)  
[17:39:25.039]  $ future.call.arguments    : list()
[17:39:25.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.039]  $ ...future.elements_ii    :List of 3
[17:39:25.039]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:25.039]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.039]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.039]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:25.039]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.039]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.039]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:25.039]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.039]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.039]  $ ...future.seeds_ii       : NULL
[17:39:25.039]  $ ...future.globals.maxSize: NULL
[17:39:25.039]  - attr(*, "resolved")= logi FALSE
[17:39:25.039]  - attr(*, "total_size")= num 1240
[17:39:25.039]  - attr(*, "where")=List of 5
[17:39:25.039]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.039]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.039]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.039]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.039]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.039]  - attr(*, "already-done")= logi TRUE
[17:39:25.047] - copied ‘...future.FUN’ to environment
[17:39:25.047] - copied ‘future.call.arguments’ to environment
[17:39:25.047] - copied ‘...future.elements_ii’ to environment
[17:39:25.047] - copied ‘...future.seeds_ii’ to environment
[17:39:25.047] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.047] assign_globals() ... done
[17:39:25.048] plan(): Setting new future strategy stack:
[17:39:25.048] List of future strategies:
[17:39:25.048] 1. sequential:
[17:39:25.048]    - args: function (..., envir = parent.frame())
[17:39:25.048]    - tweaked: FALSE
[17:39:25.048]    - call: NULL
[17:39:25.048] plan(): nbrOfWorkers() = 1
[17:39:25.050] plan(): Setting new future strategy stack:
[17:39:25.050] List of future strategies:
[17:39:25.050] 1. multicore:
[17:39:25.050]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:25.050]    - tweaked: FALSE
[17:39:25.050]    - call: plan(strategy)
[17:39:25.054] plan(): nbrOfWorkers() = 1
[17:39:25.054] SequentialFuture started (and completed)
[17:39:25.054] - Launch lazy future ... done
[17:39:25.054] run() for ‘SequentialFuture’ ... done
[17:39:25.055] Created future:
[17:39:25.055] SequentialFuture:
[17:39:25.055] Label: ‘future_by-1’
[17:39:25.055] Expression:
[17:39:25.055] {
[17:39:25.055]     do.call(function(...) {
[17:39:25.055]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.055]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.055]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.055]             on.exit(options(oopts), add = TRUE)
[17:39:25.055]         }
[17:39:25.055]         {
[17:39:25.055]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.055]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.055]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.055]             })
[17:39:25.055]         }
[17:39:25.055]     }, args = future.call.arguments)
[17:39:25.055] }
[17:39:25.055] Lazy evaluation: FALSE
[17:39:25.055] Asynchronous evaluation: FALSE
[17:39:25.055] Local evaluation: TRUE
[17:39:25.055] Environment: R_GlobalEnv
[17:39:25.055] Capture standard output: TRUE
[17:39:25.055] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.055] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.055] Packages: <none>
[17:39:25.055] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.055] Resolved: TRUE
[17:39:25.055] Value: 4.62 KiB of class ‘list’
[17:39:25.055] Early signaling: FALSE
[17:39:25.055] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.055] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.056] Chunk #1 of 1 ... DONE
[17:39:25.056] Launching 1 futures (chunks) ... DONE
[17:39:25.056] Resolving 1 futures (chunks) ...
[17:39:25.056] resolve() on list ...
[17:39:25.056]  recursive: 0
[17:39:25.056]  length: 1
[17:39:25.057] 
[17:39:25.057] resolved() for ‘SequentialFuture’ ...
[17:39:25.057] - state: ‘finished’
[17:39:25.057] - run: TRUE
[17:39:25.057] - result: ‘FutureResult’
[17:39:25.057] resolved() for ‘SequentialFuture’ ... done
[17:39:25.057] Future #1
[17:39:25.057] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.057] - nx: 1
[17:39:25.057] - relay: TRUE
[17:39:25.058] - stdout: TRUE
[17:39:25.058] - signal: TRUE
[17:39:25.058] - resignal: FALSE
[17:39:25.058] - force: TRUE
[17:39:25.058] - relayed: [n=1] FALSE
[17:39:25.058] - queued futures: [n=1] FALSE
[17:39:25.058]  - until=1
[17:39:25.058]  - relaying element #1
[17:39:25.058] - relayed: [n=1] TRUE
[17:39:25.058] - queued futures: [n=1] TRUE
[17:39:25.060] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.061]  length: 0 (resolved future 1)
[17:39:25.061] Relaying remaining futures
[17:39:25.061] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.061] - nx: 1
[17:39:25.061] - relay: TRUE
[17:39:25.061] - stdout: TRUE
[17:39:25.061] - signal: TRUE
[17:39:25.061] - resignal: FALSE
[17:39:25.061] - force: TRUE
[17:39:25.061] - relayed: [n=1] TRUE
[17:39:25.061] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.062] - relayed: [n=1] TRUE
[17:39:25.062] - queued futures: [n=1] TRUE
[17:39:25.062] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.062] resolve() on list ... DONE
[17:39:25.062]  - Number of value chunks collected: 1
[17:39:25.062] Resolving 1 futures (chunks) ... DONE
[17:39:25.062] Reducing values from 1 chunks ...
[17:39:25.062]  - Number of values collected after concatenation: 3
[17:39:25.062]  - Number of values expected: 3
[17:39:25.063] Reducing values from 1 chunks ... DONE
[17:39:25.063] future_lapply() ... DONE
[17:39:25.063] future_by_internal() ... DONE
[17:39:25.063] future_by_internal() ...
[17:39:25.063] future_lapply() ...
[17:39:25.067] Number of chunks: 1
[17:39:25.067] getGlobalsAndPackagesXApply() ...
[17:39:25.067]  - future.globals: TRUE
[17:39:25.067] getGlobalsAndPackages() ...
[17:39:25.067] Searching for globals...
[17:39:25.068] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.069] Searching for globals ... DONE
[17:39:25.069] Resolving globals: FALSE
[17:39:25.069] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.069] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.069] - globals: [1] ‘FUN’
[17:39:25.070] 
[17:39:25.070] getGlobalsAndPackages() ... DONE
[17:39:25.070]  - globals found/used: [n=1] ‘FUN’
[17:39:25.070]  - needed namespaces: [n=0] 
[17:39:25.070] Finding globals ... DONE
[17:39:25.070]  - use_args: TRUE
[17:39:25.070]  - Getting '...' globals ...
[17:39:25.070] resolve() on list ...
[17:39:25.071]  recursive: 0
[17:39:25.071]  length: 1
[17:39:25.071]  elements: ‘...’
[17:39:25.071]  length: 0 (resolved future 1)
[17:39:25.071] resolve() on list ... DONE
[17:39:25.071]    - '...' content: [n=1] ‘digits’
[17:39:25.071] List of 1
[17:39:25.071]  $ ...:List of 1
[17:39:25.071]   ..$ digits: int 2
[17:39:25.071]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.071]  - attr(*, "where")=List of 1
[17:39:25.071]   ..$ ...:<environment: 0x56296f3756b0> 
[17:39:25.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.071]  - attr(*, "resolved")= logi TRUE
[17:39:25.071]  - attr(*, "total_size")= num NA
[17:39:25.074]  - Getting '...' globals ... DONE
[17:39:25.074] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.074] List of 2
[17:39:25.074]  $ ...future.FUN:function (object, ...)  
[17:39:25.074]  $ ...          :List of 1
[17:39:25.074]   ..$ digits: int 2
[17:39:25.074]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.074]  - attr(*, "where")=List of 2
[17:39:25.074]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.074]   ..$ ...          :<environment: 0x56296f3756b0> 
[17:39:25.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.074]  - attr(*, "resolved")= logi FALSE
[17:39:25.074]  - attr(*, "total_size")= num 1296
[17:39:25.077] Packages to be attached in all futures: [n=0] 
[17:39:25.078] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.078] Number of futures (= number of chunks): 1
[17:39:25.078] Launching 1 futures (chunks) ...
[17:39:25.078] Chunk #1 of 1 ...
[17:39:25.078]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.078] getGlobalsAndPackages() ...
[17:39:25.078] Searching for globals...
[17:39:25.079] 
[17:39:25.079] Searching for globals ... DONE
[17:39:25.079] - globals: [0] <none>
[17:39:25.079] getGlobalsAndPackages() ... DONE
[17:39:25.079]    + additional globals found: [n=0] 
[17:39:25.079]    + additional namespaces needed: [n=0] 
[17:39:25.079]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.079]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[17:39:25.079]  - seeds: <none>
[17:39:25.079] getGlobalsAndPackages() ...
[17:39:25.080] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.080] Resolving globals: FALSE
[17:39:25.080] Tweak future expression to call with '...' arguments ...
[17:39:25.080] {
[17:39:25.080]     do.call(function(...) {
[17:39:25.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.080]             on.exit(options(oopts), add = TRUE)
[17:39:25.080]         }
[17:39:25.080]         {
[17:39:25.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.080]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.080]             })
[17:39:25.080]         }
[17:39:25.080]     }, args = future.call.arguments)
[17:39:25.080] }
[17:39:25.080] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.080] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.081] 
[17:39:25.081] getGlobalsAndPackages() ... DONE
[17:39:25.081] run() for ‘Future’ ...
[17:39:25.081] - state: ‘created’
[17:39:25.083] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.086] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.086] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.087]   - Field: ‘label’
[17:39:25.087]   - Field: ‘local’
[17:39:25.087]   - Field: ‘owner’
[17:39:25.087]   - Field: ‘envir’
[17:39:25.087]   - Field: ‘packages’
[17:39:25.087]   - Field: ‘gc’
[17:39:25.087]   - Field: ‘conditions’
[17:39:25.087]   - Field: ‘expr’
[17:39:25.087]   - Field: ‘uuid’
[17:39:25.087]   - Field: ‘seed’
[17:39:25.088]   - Field: ‘version’
[17:39:25.088]   - Field: ‘result’
[17:39:25.088]   - Field: ‘asynchronous’
[17:39:25.088]   - Field: ‘calls’
[17:39:25.088]   - Field: ‘globals’
[17:39:25.088]   - Field: ‘stdout’
[17:39:25.088]   - Field: ‘earlySignal’
[17:39:25.088]   - Field: ‘lazy’
[17:39:25.088]   - Field: ‘state’
[17:39:25.088] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.088] - Launch lazy future ...
[17:39:25.089] Packages needed by the future expression (n = 0): <none>
[17:39:25.089] Packages needed by future strategies (n = 0): <none>
[17:39:25.089] {
[17:39:25.089]     {
[17:39:25.089]         {
[17:39:25.089]             ...future.startTime <- base::Sys.time()
[17:39:25.089]             {
[17:39:25.089]                 {
[17:39:25.089]                   {
[17:39:25.089]                     base::local({
[17:39:25.089]                       has_future <- base::requireNamespace("future", 
[17:39:25.089]                         quietly = TRUE)
[17:39:25.089]                       if (has_future) {
[17:39:25.089]                         ns <- base::getNamespace("future")
[17:39:25.089]                         version <- ns[[".package"]][["version"]]
[17:39:25.089]                         if (is.null(version)) 
[17:39:25.089]                           version <- utils::packageVersion("future")
[17:39:25.089]                       }
[17:39:25.089]                       else {
[17:39:25.089]                         version <- NULL
[17:39:25.089]                       }
[17:39:25.089]                       if (!has_future || version < "1.8.0") {
[17:39:25.089]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.089]                           "", base::R.version$version.string), 
[17:39:25.089]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.089]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.089]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.089]                             "release", "version")], collapse = " "), 
[17:39:25.089]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.089]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.089]                           info)
[17:39:25.089]                         info <- base::paste(info, collapse = "; ")
[17:39:25.089]                         if (!has_future) {
[17:39:25.089]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.089]                             info)
[17:39:25.089]                         }
[17:39:25.089]                         else {
[17:39:25.089]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.089]                             info, version)
[17:39:25.089]                         }
[17:39:25.089]                         base::stop(msg)
[17:39:25.089]                       }
[17:39:25.089]                     })
[17:39:25.089]                   }
[17:39:25.089]                   options(future.plan = NULL)
[17:39:25.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.089]                 }
[17:39:25.089]                 ...future.workdir <- getwd()
[17:39:25.089]             }
[17:39:25.089]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.089]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.089]         }
[17:39:25.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.089]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[17:39:25.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.089]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.089]             base::names(...future.oldOptions))
[17:39:25.089]     }
[17:39:25.089]     if (FALSE) {
[17:39:25.089]     }
[17:39:25.089]     else {
[17:39:25.089]         if (TRUE) {
[17:39:25.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.089]                 open = "w")
[17:39:25.089]         }
[17:39:25.089]         else {
[17:39:25.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.089]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.089]         }
[17:39:25.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.089]             base::sink(type = "output", split = FALSE)
[17:39:25.089]             base::close(...future.stdout)
[17:39:25.089]         }, add = TRUE)
[17:39:25.089]     }
[17:39:25.089]     ...future.frame <- base::sys.nframe()
[17:39:25.089]     ...future.conditions <- base::list()
[17:39:25.089]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.089]     if (FALSE) {
[17:39:25.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.089]     }
[17:39:25.089]     ...future.result <- base::tryCatch({
[17:39:25.089]         base::withCallingHandlers({
[17:39:25.089]             ...future.value <- base::withVisible(base::local({
[17:39:25.089]                 do.call(function(...) {
[17:39:25.089]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.089]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.089]                     ...future.globals.maxSize)) {
[17:39:25.089]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.089]                     on.exit(options(oopts), add = TRUE)
[17:39:25.089]                   }
[17:39:25.089]                   {
[17:39:25.089]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.089]                       FUN = function(jj) {
[17:39:25.089]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.089]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.089]                       })
[17:39:25.089]                   }
[17:39:25.089]                 }, args = future.call.arguments)
[17:39:25.089]             }))
[17:39:25.089]             future::FutureResult(value = ...future.value$value, 
[17:39:25.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.089]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.089]                     ...future.globalenv.names))
[17:39:25.089]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.089]         }, condition = base::local({
[17:39:25.089]             c <- base::c
[17:39:25.089]             inherits <- base::inherits
[17:39:25.089]             invokeRestart <- base::invokeRestart
[17:39:25.089]             length <- base::length
[17:39:25.089]             list <- base::list
[17:39:25.089]             seq.int <- base::seq.int
[17:39:25.089]             signalCondition <- base::signalCondition
[17:39:25.089]             sys.calls <- base::sys.calls
[17:39:25.089]             `[[` <- base::`[[`
[17:39:25.089]             `+` <- base::`+`
[17:39:25.089]             `<<-` <- base::`<<-`
[17:39:25.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.089]                   3L)]
[17:39:25.089]             }
[17:39:25.089]             function(cond) {
[17:39:25.089]                 is_error <- inherits(cond, "error")
[17:39:25.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.089]                   NULL)
[17:39:25.089]                 if (is_error) {
[17:39:25.089]                   sessionInformation <- function() {
[17:39:25.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.089]                       search = base::search(), system = base::Sys.info())
[17:39:25.089]                   }
[17:39:25.089]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.089]                     cond$call), session = sessionInformation(), 
[17:39:25.089]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.089]                   signalCondition(cond)
[17:39:25.089]                 }
[17:39:25.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.089]                 "immediateCondition"))) {
[17:39:25.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.089]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.089]                   if (TRUE && !signal) {
[17:39:25.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.089]                     {
[17:39:25.089]                       inherits <- base::inherits
[17:39:25.089]                       invokeRestart <- base::invokeRestart
[17:39:25.089]                       is.null <- base::is.null
[17:39:25.089]                       muffled <- FALSE
[17:39:25.089]                       if (inherits(cond, "message")) {
[17:39:25.089]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.089]                         if (muffled) 
[17:39:25.089]                           invokeRestart("muffleMessage")
[17:39:25.089]                       }
[17:39:25.089]                       else if (inherits(cond, "warning")) {
[17:39:25.089]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.089]                         if (muffled) 
[17:39:25.089]                           invokeRestart("muffleWarning")
[17:39:25.089]                       }
[17:39:25.089]                       else if (inherits(cond, "condition")) {
[17:39:25.089]                         if (!is.null(pattern)) {
[17:39:25.089]                           computeRestarts <- base::computeRestarts
[17:39:25.089]                           grepl <- base::grepl
[17:39:25.089]                           restarts <- computeRestarts(cond)
[17:39:25.089]                           for (restart in restarts) {
[17:39:25.089]                             name <- restart$name
[17:39:25.089]                             if (is.null(name)) 
[17:39:25.089]                               next
[17:39:25.089]                             if (!grepl(pattern, name)) 
[17:39:25.089]                               next
[17:39:25.089]                             invokeRestart(restart)
[17:39:25.089]                             muffled <- TRUE
[17:39:25.089]                             break
[17:39:25.089]                           }
[17:39:25.089]                         }
[17:39:25.089]                       }
[17:39:25.089]                       invisible(muffled)
[17:39:25.089]                     }
[17:39:25.089]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.089]                   }
[17:39:25.089]                 }
[17:39:25.089]                 else {
[17:39:25.089]                   if (TRUE) {
[17:39:25.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.089]                     {
[17:39:25.089]                       inherits <- base::inherits
[17:39:25.089]                       invokeRestart <- base::invokeRestart
[17:39:25.089]                       is.null <- base::is.null
[17:39:25.089]                       muffled <- FALSE
[17:39:25.089]                       if (inherits(cond, "message")) {
[17:39:25.089]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.089]                         if (muffled) 
[17:39:25.089]                           invokeRestart("muffleMessage")
[17:39:25.089]                       }
[17:39:25.089]                       else if (inherits(cond, "warning")) {
[17:39:25.089]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.089]                         if (muffled) 
[17:39:25.089]                           invokeRestart("muffleWarning")
[17:39:25.089]                       }
[17:39:25.089]                       else if (inherits(cond, "condition")) {
[17:39:25.089]                         if (!is.null(pattern)) {
[17:39:25.089]                           computeRestarts <- base::computeRestarts
[17:39:25.089]                           grepl <- base::grepl
[17:39:25.089]                           restarts <- computeRestarts(cond)
[17:39:25.089]                           for (restart in restarts) {
[17:39:25.089]                             name <- restart$name
[17:39:25.089]                             if (is.null(name)) 
[17:39:25.089]                               next
[17:39:25.089]                             if (!grepl(pattern, name)) 
[17:39:25.089]                               next
[17:39:25.089]                             invokeRestart(restart)
[17:39:25.089]                             muffled <- TRUE
[17:39:25.089]                             break
[17:39:25.089]                           }
[17:39:25.089]                         }
[17:39:25.089]                       }
[17:39:25.089]                       invisible(muffled)
[17:39:25.089]                     }
[17:39:25.089]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.089]                   }
[17:39:25.089]                 }
[17:39:25.089]             }
[17:39:25.089]         }))
[17:39:25.089]     }, error = function(ex) {
[17:39:25.089]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.089]                 ...future.rng), started = ...future.startTime, 
[17:39:25.089]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.089]             version = "1.8"), class = "FutureResult")
[17:39:25.089]     }, finally = {
[17:39:25.089]         if (!identical(...future.workdir, getwd())) 
[17:39:25.089]             setwd(...future.workdir)
[17:39:25.089]         {
[17:39:25.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.089]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.089]             }
[17:39:25.089]             base::options(...future.oldOptions)
[17:39:25.089]             if (.Platform$OS.type == "windows") {
[17:39:25.089]                 old_names <- names(...future.oldEnvVars)
[17:39:25.089]                 envs <- base::Sys.getenv()
[17:39:25.089]                 names <- names(envs)
[17:39:25.089]                 common <- intersect(names, old_names)
[17:39:25.089]                 added <- setdiff(names, old_names)
[17:39:25.089]                 removed <- setdiff(old_names, names)
[17:39:25.089]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.089]                   envs[common]]
[17:39:25.089]                 NAMES <- toupper(changed)
[17:39:25.089]                 args <- list()
[17:39:25.089]                 for (kk in seq_along(NAMES)) {
[17:39:25.089]                   name <- changed[[kk]]
[17:39:25.089]                   NAME <- NAMES[[kk]]
[17:39:25.089]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.089]                     next
[17:39:25.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.089]                 }
[17:39:25.089]                 NAMES <- toupper(added)
[17:39:25.089]                 for (kk in seq_along(NAMES)) {
[17:39:25.089]                   name <- added[[kk]]
[17:39:25.089]                   NAME <- NAMES[[kk]]
[17:39:25.089]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.089]                     next
[17:39:25.089]                   args[[name]] <- ""
[17:39:25.089]                 }
[17:39:25.089]                 NAMES <- toupper(removed)
[17:39:25.089]                 for (kk in seq_along(NAMES)) {
[17:39:25.089]                   name <- removed[[kk]]
[17:39:25.089]                   NAME <- NAMES[[kk]]
[17:39:25.089]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.089]                     next
[17:39:25.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.089]                 }
[17:39:25.089]                 if (length(args) > 0) 
[17:39:25.089]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.089]             }
[17:39:25.089]             else {
[17:39:25.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.089]             }
[17:39:25.089]             {
[17:39:25.089]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.089]                   0L) {
[17:39:25.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.089]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.089]                   base::options(opts)
[17:39:25.089]                 }
[17:39:25.089]                 {
[17:39:25.089]                   {
[17:39:25.089]                     NULL
[17:39:25.089]                     RNGkind("Mersenne-Twister")
[17:39:25.089]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.089]                       inherits = FALSE)
[17:39:25.089]                   }
[17:39:25.089]                   options(future.plan = NULL)
[17:39:25.089]                   if (is.na(NA_character_)) 
[17:39:25.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.089]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:25.089]                     envir = parent.frame()) 
[17:39:25.089]                   {
[17:39:25.089]                     default_workers <- missing(workers)
[17:39:25.089]                     if (is.function(workers)) 
[17:39:25.089]                       workers <- workers()
[17:39:25.089]                     workers <- structure(as.integer(workers), 
[17:39:25.089]                       class = class(workers))
[17:39:25.089]                     stop_if_not(is.finite(workers), workers >= 
[17:39:25.089]                       1L)
[17:39:25.089]                     if ((workers == 1L && !inherits(workers, 
[17:39:25.089]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:25.089]                       if (default_workers) 
[17:39:25.089]                         supportsMulticore(warn = TRUE)
[17:39:25.089]                       return(sequential(..., envir = envir))
[17:39:25.089]                     }
[17:39:25.089]                     oopts <- options(mc.cores = workers)
[17:39:25.089]                     on.exit(options(oopts))
[17:39:25.089]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:25.089]                       envir = envir)
[17:39:25.089]                     if (!future$lazy) 
[17:39:25.089]                       future <- run(future)
[17:39:25.089]                     invisible(future)
[17:39:25.089]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.089]                 }
[17:39:25.089]             }
[17:39:25.089]         }
[17:39:25.089]     })
[17:39:25.089]     if (TRUE) {
[17:39:25.089]         base::sink(type = "output", split = FALSE)
[17:39:25.089]         if (TRUE) {
[17:39:25.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.089]         }
[17:39:25.089]         else {
[17:39:25.089]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.089]         }
[17:39:25.089]         base::close(...future.stdout)
[17:39:25.089]         ...future.stdout <- NULL
[17:39:25.089]     }
[17:39:25.089]     ...future.result$conditions <- ...future.conditions
[17:39:25.089]     ...future.result$finished <- base::Sys.time()
[17:39:25.089]     ...future.result
[17:39:25.089] }
[17:39:25.091] assign_globals() ...
[17:39:25.091] List of 5
[17:39:25.091]  $ ...future.FUN            :function (object, ...)  
[17:39:25.091]  $ future.call.arguments    :List of 1
[17:39:25.091]   ..$ digits: int 2
[17:39:25.091]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.091]  $ ...future.elements_ii    :List of 6
[17:39:25.091]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:39:25.091]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:39:25.091]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:39:25.091]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:39:25.091]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:39:25.091]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:39:25.091]  $ ...future.seeds_ii       : NULL
[17:39:25.091]  $ ...future.globals.maxSize: NULL
[17:39:25.091]  - attr(*, "resolved")= logi FALSE
[17:39:25.091]  - attr(*, "total_size")= num 1296
[17:39:25.091]  - attr(*, "where")=List of 5
[17:39:25.091]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.091]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.091]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.091]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.091]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.091]  - attr(*, "already-done")= logi TRUE
[17:39:25.098] - copied ‘...future.FUN’ to environment
[17:39:25.098] - copied ‘future.call.arguments’ to environment
[17:39:25.098] - copied ‘...future.elements_ii’ to environment
[17:39:25.098] - copied ‘...future.seeds_ii’ to environment
[17:39:25.098] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.098] assign_globals() ... done
[17:39:25.098] plan(): Setting new future strategy stack:
[17:39:25.098] List of future strategies:
[17:39:25.098] 1. sequential:
[17:39:25.098]    - args: function (..., envir = parent.frame())
[17:39:25.098]    - tweaked: FALSE
[17:39:25.098]    - call: NULL
[17:39:25.099] plan(): nbrOfWorkers() = 1
[17:39:25.100] plan(): Setting new future strategy stack:
[17:39:25.100] List of future strategies:
[17:39:25.100] 1. multicore:
[17:39:25.100]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:25.100]    - tweaked: FALSE
[17:39:25.100]    - call: plan(strategy)
[17:39:25.104] plan(): nbrOfWorkers() = 1
[17:39:25.104] SequentialFuture started (and completed)
[17:39:25.104] - Launch lazy future ... done
[17:39:25.105] run() for ‘SequentialFuture’ ... done
[17:39:25.105] Created future:
[17:39:25.105] SequentialFuture:
[17:39:25.105] Label: ‘future_by-1’
[17:39:25.105] Expression:
[17:39:25.105] {
[17:39:25.105]     do.call(function(...) {
[17:39:25.105]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.105]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.105]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.105]             on.exit(options(oopts), add = TRUE)
[17:39:25.105]         }
[17:39:25.105]         {
[17:39:25.105]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.105]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.105]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.105]             })
[17:39:25.105]         }
[17:39:25.105]     }, args = future.call.arguments)
[17:39:25.105] }
[17:39:25.105] Lazy evaluation: FALSE
[17:39:25.105] Asynchronous evaluation: FALSE
[17:39:25.105] Local evaluation: TRUE
[17:39:25.105] Environment: R_GlobalEnv
[17:39:25.105] Capture standard output: TRUE
[17:39:25.105] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.105] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.105] Packages: <none>
[17:39:25.105] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.105] Resolved: TRUE
[17:39:25.105] Value: 5.48 KiB of class ‘list’
[17:39:25.105] Early signaling: FALSE
[17:39:25.105] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.105] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.106] Chunk #1 of 1 ... DONE
[17:39:25.106] Launching 1 futures (chunks) ... DONE
[17:39:25.106] Resolving 1 futures (chunks) ...
[17:39:25.106] resolve() on list ...
[17:39:25.106]  recursive: 0
[17:39:25.107]  length: 1
[17:39:25.107] 
[17:39:25.107] resolved() for ‘SequentialFuture’ ...
[17:39:25.107] - state: ‘finished’
[17:39:25.107] - run: TRUE
[17:39:25.107] - result: ‘FutureResult’
[17:39:25.107] resolved() for ‘SequentialFuture’ ... done
[17:39:25.133] Future #1
[17:39:25.134] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.134] - nx: 1
[17:39:25.134] - relay: TRUE
[17:39:25.134] - stdout: TRUE
[17:39:25.134] - signal: TRUE
[17:39:25.134] - resignal: FALSE
[17:39:25.134] - force: TRUE
[17:39:25.134] - relayed: [n=1] FALSE
[17:39:25.134] - queued futures: [n=1] FALSE
[17:39:25.135]  - until=1
[17:39:25.135]  - relaying element #1
[17:39:25.135] - relayed: [n=1] TRUE
[17:39:25.135] - queued futures: [n=1] TRUE
[17:39:25.135] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.135]  length: 0 (resolved future 1)
[17:39:25.135] Relaying remaining futures
[17:39:25.135] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.136] - nx: 1
[17:39:25.136] - relay: TRUE
[17:39:25.136] - stdout: TRUE
[17:39:25.136] - signal: TRUE
[17:39:25.136] - resignal: FALSE
[17:39:25.136] - force: TRUE
[17:39:25.136] - relayed: [n=1] TRUE
[17:39:25.136] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.136] - relayed: [n=1] TRUE
[17:39:25.136] - queued futures: [n=1] TRUE
[17:39:25.136] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.137] resolve() on list ... DONE
[17:39:25.137]  - Number of value chunks collected: 1
[17:39:25.137] Resolving 1 futures (chunks) ... DONE
[17:39:25.137] Reducing values from 1 chunks ...
[17:39:25.137]  - Number of values collected after concatenation: 6
[17:39:25.137]  - Number of values expected: 6
[17:39:25.137] Reducing values from 1 chunks ... DONE
[17:39:25.137] future_lapply() ... DONE
[17:39:25.137] future_by_internal() ... DONE
[17:39:25.138] future_by_internal() ...
[17:39:25.139] future_lapply() ...
[17:39:25.143] Number of chunks: 1
[17:39:25.143] getGlobalsAndPackagesXApply() ...
[17:39:25.144]  - future.globals: TRUE
[17:39:25.144] getGlobalsAndPackages() ...
[17:39:25.144] Searching for globals...
[17:39:25.146] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:25.146] Searching for globals ... DONE
[17:39:25.146] Resolving globals: FALSE
[17:39:25.146] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:39:25.147] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:39:25.147] - globals: [1] ‘FUN’
[17:39:25.147] - packages: [1] ‘stats’
[17:39:25.147] getGlobalsAndPackages() ... DONE
[17:39:25.147]  - globals found/used: [n=1] ‘FUN’
[17:39:25.147]  - needed namespaces: [n=1] ‘stats’
[17:39:25.147] Finding globals ... DONE
[17:39:25.147]  - use_args: TRUE
[17:39:25.148]  - Getting '...' globals ...
[17:39:25.148] resolve() on list ...
[17:39:25.148]  recursive: 0
[17:39:25.148]  length: 1
[17:39:25.148]  elements: ‘...’
[17:39:25.148]  length: 0 (resolved future 1)
[17:39:25.148] resolve() on list ... DONE
[17:39:25.148]    - '...' content: [n=1] ‘singular.ok’
[17:39:25.149] List of 1
[17:39:25.149]  $ ...:List of 1
[17:39:25.149]   ..$ singular.ok: logi FALSE
[17:39:25.149]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.149]  - attr(*, "where")=List of 1
[17:39:25.149]   ..$ ...:<environment: 0x56296ef4a828> 
[17:39:25.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.149]  - attr(*, "resolved")= logi TRUE
[17:39:25.149]  - attr(*, "total_size")= num NA
[17:39:25.151]  - Getting '...' globals ... DONE
[17:39:25.152] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.152] List of 2
[17:39:25.152]  $ ...future.FUN:function (x, ...)  
[17:39:25.152]  $ ...          :List of 1
[17:39:25.152]   ..$ singular.ok: logi FALSE
[17:39:25.152]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.152]  - attr(*, "where")=List of 2
[17:39:25.152]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.152]   ..$ ...          :<environment: 0x56296ef4a828> 
[17:39:25.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.152]  - attr(*, "resolved")= logi FALSE
[17:39:25.152]  - attr(*, "total_size")= num 5384
[17:39:25.155] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:25.155] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.155] Number of futures (= number of chunks): 1
[17:39:25.155] Launching 1 futures (chunks) ...
[17:39:25.155] Chunk #1 of 1 ...
[17:39:25.156]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.156] getGlobalsAndPackages() ...
[17:39:25.156] Searching for globals...
[17:39:25.156] 
[17:39:25.156] Searching for globals ... DONE
[17:39:25.156] - globals: [0] <none>
[17:39:25.156] getGlobalsAndPackages() ... DONE
[17:39:25.157]    + additional globals found: [n=0] 
[17:39:25.157]    + additional namespaces needed: [n=0] 
[17:39:25.157]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.158]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.158]  - seeds: <none>
[17:39:25.158] getGlobalsAndPackages() ...
[17:39:25.158] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.159] Resolving globals: FALSE
[17:39:25.159] Tweak future expression to call with '...' arguments ...
[17:39:25.159] {
[17:39:25.159]     do.call(function(...) {
[17:39:25.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.159]             on.exit(options(oopts), add = TRUE)
[17:39:25.159]         }
[17:39:25.159]         {
[17:39:25.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.159]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.159]             })
[17:39:25.159]         }
[17:39:25.159]     }, args = future.call.arguments)
[17:39:25.159] }
[17:39:25.159] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.159] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.160] 
[17:39:25.160] getGlobalsAndPackages() ... DONE
[17:39:25.160] run() for ‘Future’ ...
[17:39:25.160] - state: ‘created’
[17:39:25.160] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.164] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.164] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.164]   - Field: ‘label’
[17:39:25.165]   - Field: ‘local’
[17:39:25.165]   - Field: ‘owner’
[17:39:25.165]   - Field: ‘envir’
[17:39:25.165]   - Field: ‘packages’
[17:39:25.165]   - Field: ‘gc’
[17:39:25.165]   - Field: ‘conditions’
[17:39:25.165]   - Field: ‘expr’
[17:39:25.165]   - Field: ‘uuid’
[17:39:25.166]   - Field: ‘seed’
[17:39:25.166]   - Field: ‘version’
[17:39:25.166]   - Field: ‘result’
[17:39:25.166]   - Field: ‘asynchronous’
[17:39:25.166]   - Field: ‘calls’
[17:39:25.166]   - Field: ‘globals’
[17:39:25.166]   - Field: ‘stdout’
[17:39:25.166]   - Field: ‘earlySignal’
[17:39:25.166]   - Field: ‘lazy’
[17:39:25.166]   - Field: ‘state’
[17:39:25.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.167] - Launch lazy future ...
[17:39:25.167] Packages needed by the future expression (n = 1): ‘stats’
[17:39:25.167] Packages needed by future strategies (n = 0): <none>
[17:39:25.167] {
[17:39:25.167]     {
[17:39:25.167]         {
[17:39:25.167]             ...future.startTime <- base::Sys.time()
[17:39:25.167]             {
[17:39:25.167]                 {
[17:39:25.167]                   {
[17:39:25.167]                     {
[17:39:25.167]                       base::local({
[17:39:25.167]                         has_future <- base::requireNamespace("future", 
[17:39:25.167]                           quietly = TRUE)
[17:39:25.167]                         if (has_future) {
[17:39:25.167]                           ns <- base::getNamespace("future")
[17:39:25.167]                           version <- ns[[".package"]][["version"]]
[17:39:25.167]                           if (is.null(version)) 
[17:39:25.167]                             version <- utils::packageVersion("future")
[17:39:25.167]                         }
[17:39:25.167]                         else {
[17:39:25.167]                           version <- NULL
[17:39:25.167]                         }
[17:39:25.167]                         if (!has_future || version < "1.8.0") {
[17:39:25.167]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.167]                             "", base::R.version$version.string), 
[17:39:25.167]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:25.167]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.167]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.167]                               "release", "version")], collapse = " "), 
[17:39:25.167]                             hostname = base::Sys.info()[["nodename"]])
[17:39:25.167]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.167]                             info)
[17:39:25.167]                           info <- base::paste(info, collapse = "; ")
[17:39:25.167]                           if (!has_future) {
[17:39:25.167]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.167]                               info)
[17:39:25.167]                           }
[17:39:25.167]                           else {
[17:39:25.167]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.167]                               info, version)
[17:39:25.167]                           }
[17:39:25.167]                           base::stop(msg)
[17:39:25.167]                         }
[17:39:25.167]                       })
[17:39:25.167]                     }
[17:39:25.167]                     base::local({
[17:39:25.167]                       for (pkg in "stats") {
[17:39:25.167]                         base::loadNamespace(pkg)
[17:39:25.167]                         base::library(pkg, character.only = TRUE)
[17:39:25.167]                       }
[17:39:25.167]                     })
[17:39:25.167]                   }
[17:39:25.167]                   options(future.plan = NULL)
[17:39:25.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.167]                 }
[17:39:25.167]                 ...future.workdir <- getwd()
[17:39:25.167]             }
[17:39:25.167]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.167]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.167]         }
[17:39:25.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.167]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.167]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.167]             base::names(...future.oldOptions))
[17:39:25.167]     }
[17:39:25.167]     if (FALSE) {
[17:39:25.167]     }
[17:39:25.167]     else {
[17:39:25.167]         if (TRUE) {
[17:39:25.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.167]                 open = "w")
[17:39:25.167]         }
[17:39:25.167]         else {
[17:39:25.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.167]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.167]         }
[17:39:25.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.167]             base::sink(type = "output", split = FALSE)
[17:39:25.167]             base::close(...future.stdout)
[17:39:25.167]         }, add = TRUE)
[17:39:25.167]     }
[17:39:25.167]     ...future.frame <- base::sys.nframe()
[17:39:25.167]     ...future.conditions <- base::list()
[17:39:25.167]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.167]     if (FALSE) {
[17:39:25.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.167]     }
[17:39:25.167]     ...future.result <- base::tryCatch({
[17:39:25.167]         base::withCallingHandlers({
[17:39:25.167]             ...future.value <- base::withVisible(base::local({
[17:39:25.167]                 do.call(function(...) {
[17:39:25.167]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.167]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.167]                     ...future.globals.maxSize)) {
[17:39:25.167]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.167]                     on.exit(options(oopts), add = TRUE)
[17:39:25.167]                   }
[17:39:25.167]                   {
[17:39:25.167]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.167]                       FUN = function(jj) {
[17:39:25.167]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.167]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.167]                       })
[17:39:25.167]                   }
[17:39:25.167]                 }, args = future.call.arguments)
[17:39:25.167]             }))
[17:39:25.167]             future::FutureResult(value = ...future.value$value, 
[17:39:25.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.167]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.167]                     ...future.globalenv.names))
[17:39:25.167]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.167]         }, condition = base::local({
[17:39:25.167]             c <- base::c
[17:39:25.167]             inherits <- base::inherits
[17:39:25.167]             invokeRestart <- base::invokeRestart
[17:39:25.167]             length <- base::length
[17:39:25.167]             list <- base::list
[17:39:25.167]             seq.int <- base::seq.int
[17:39:25.167]             signalCondition <- base::signalCondition
[17:39:25.167]             sys.calls <- base::sys.calls
[17:39:25.167]             `[[` <- base::`[[`
[17:39:25.167]             `+` <- base::`+`
[17:39:25.167]             `<<-` <- base::`<<-`
[17:39:25.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.167]                   3L)]
[17:39:25.167]             }
[17:39:25.167]             function(cond) {
[17:39:25.167]                 is_error <- inherits(cond, "error")
[17:39:25.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.167]                   NULL)
[17:39:25.167]                 if (is_error) {
[17:39:25.167]                   sessionInformation <- function() {
[17:39:25.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.167]                       search = base::search(), system = base::Sys.info())
[17:39:25.167]                   }
[17:39:25.167]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.167]                     cond$call), session = sessionInformation(), 
[17:39:25.167]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.167]                   signalCondition(cond)
[17:39:25.167]                 }
[17:39:25.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.167]                 "immediateCondition"))) {
[17:39:25.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.167]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.167]                   if (TRUE && !signal) {
[17:39:25.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.167]                     {
[17:39:25.167]                       inherits <- base::inherits
[17:39:25.167]                       invokeRestart <- base::invokeRestart
[17:39:25.167]                       is.null <- base::is.null
[17:39:25.167]                       muffled <- FALSE
[17:39:25.167]                       if (inherits(cond, "message")) {
[17:39:25.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.167]                         if (muffled) 
[17:39:25.167]                           invokeRestart("muffleMessage")
[17:39:25.167]                       }
[17:39:25.167]                       else if (inherits(cond, "warning")) {
[17:39:25.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.167]                         if (muffled) 
[17:39:25.167]                           invokeRestart("muffleWarning")
[17:39:25.167]                       }
[17:39:25.167]                       else if (inherits(cond, "condition")) {
[17:39:25.167]                         if (!is.null(pattern)) {
[17:39:25.167]                           computeRestarts <- base::computeRestarts
[17:39:25.167]                           grepl <- base::grepl
[17:39:25.167]                           restarts <- computeRestarts(cond)
[17:39:25.167]                           for (restart in restarts) {
[17:39:25.167]                             name <- restart$name
[17:39:25.167]                             if (is.null(name)) 
[17:39:25.167]                               next
[17:39:25.167]                             if (!grepl(pattern, name)) 
[17:39:25.167]                               next
[17:39:25.167]                             invokeRestart(restart)
[17:39:25.167]                             muffled <- TRUE
[17:39:25.167]                             break
[17:39:25.167]                           }
[17:39:25.167]                         }
[17:39:25.167]                       }
[17:39:25.167]                       invisible(muffled)
[17:39:25.167]                     }
[17:39:25.167]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.167]                   }
[17:39:25.167]                 }
[17:39:25.167]                 else {
[17:39:25.167]                   if (TRUE) {
[17:39:25.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.167]                     {
[17:39:25.167]                       inherits <- base::inherits
[17:39:25.167]                       invokeRestart <- base::invokeRestart
[17:39:25.167]                       is.null <- base::is.null
[17:39:25.167]                       muffled <- FALSE
[17:39:25.167]                       if (inherits(cond, "message")) {
[17:39:25.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.167]                         if (muffled) 
[17:39:25.167]                           invokeRestart("muffleMessage")
[17:39:25.167]                       }
[17:39:25.167]                       else if (inherits(cond, "warning")) {
[17:39:25.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.167]                         if (muffled) 
[17:39:25.167]                           invokeRestart("muffleWarning")
[17:39:25.167]                       }
[17:39:25.167]                       else if (inherits(cond, "condition")) {
[17:39:25.167]                         if (!is.null(pattern)) {
[17:39:25.167]                           computeRestarts <- base::computeRestarts
[17:39:25.167]                           grepl <- base::grepl
[17:39:25.167]                           restarts <- computeRestarts(cond)
[17:39:25.167]                           for (restart in restarts) {
[17:39:25.167]                             name <- restart$name
[17:39:25.167]                             if (is.null(name)) 
[17:39:25.167]                               next
[17:39:25.167]                             if (!grepl(pattern, name)) 
[17:39:25.167]                               next
[17:39:25.167]                             invokeRestart(restart)
[17:39:25.167]                             muffled <- TRUE
[17:39:25.167]                             break
[17:39:25.167]                           }
[17:39:25.167]                         }
[17:39:25.167]                       }
[17:39:25.167]                       invisible(muffled)
[17:39:25.167]                     }
[17:39:25.167]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.167]                   }
[17:39:25.167]                 }
[17:39:25.167]             }
[17:39:25.167]         }))
[17:39:25.167]     }, error = function(ex) {
[17:39:25.167]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.167]                 ...future.rng), started = ...future.startTime, 
[17:39:25.167]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.167]             version = "1.8"), class = "FutureResult")
[17:39:25.167]     }, finally = {
[17:39:25.167]         if (!identical(...future.workdir, getwd())) 
[17:39:25.167]             setwd(...future.workdir)
[17:39:25.167]         {
[17:39:25.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.167]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.167]             }
[17:39:25.167]             base::options(...future.oldOptions)
[17:39:25.167]             if (.Platform$OS.type == "windows") {
[17:39:25.167]                 old_names <- names(...future.oldEnvVars)
[17:39:25.167]                 envs <- base::Sys.getenv()
[17:39:25.167]                 names <- names(envs)
[17:39:25.167]                 common <- intersect(names, old_names)
[17:39:25.167]                 added <- setdiff(names, old_names)
[17:39:25.167]                 removed <- setdiff(old_names, names)
[17:39:25.167]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.167]                   envs[common]]
[17:39:25.167]                 NAMES <- toupper(changed)
[17:39:25.167]                 args <- list()
[17:39:25.167]                 for (kk in seq_along(NAMES)) {
[17:39:25.167]                   name <- changed[[kk]]
[17:39:25.167]                   NAME <- NAMES[[kk]]
[17:39:25.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.167]                     next
[17:39:25.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.167]                 }
[17:39:25.167]                 NAMES <- toupper(added)
[17:39:25.167]                 for (kk in seq_along(NAMES)) {
[17:39:25.167]                   name <- added[[kk]]
[17:39:25.167]                   NAME <- NAMES[[kk]]
[17:39:25.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.167]                     next
[17:39:25.167]                   args[[name]] <- ""
[17:39:25.167]                 }
[17:39:25.167]                 NAMES <- toupper(removed)
[17:39:25.167]                 for (kk in seq_along(NAMES)) {
[17:39:25.167]                   name <- removed[[kk]]
[17:39:25.167]                   NAME <- NAMES[[kk]]
[17:39:25.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.167]                     next
[17:39:25.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.167]                 }
[17:39:25.167]                 if (length(args) > 0) 
[17:39:25.167]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.167]             }
[17:39:25.167]             else {
[17:39:25.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.167]             }
[17:39:25.167]             {
[17:39:25.167]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.167]                   0L) {
[17:39:25.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.167]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.167]                   base::options(opts)
[17:39:25.167]                 }
[17:39:25.167]                 {
[17:39:25.167]                   {
[17:39:25.167]                     NULL
[17:39:25.167]                     RNGkind("Mersenne-Twister")
[17:39:25.167]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.167]                       inherits = FALSE)
[17:39:25.167]                   }
[17:39:25.167]                   options(future.plan = NULL)
[17:39:25.167]                   if (is.na(NA_character_)) 
[17:39:25.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.167]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:25.167]                     envir = parent.frame()) 
[17:39:25.167]                   {
[17:39:25.167]                     default_workers <- missing(workers)
[17:39:25.167]                     if (is.function(workers)) 
[17:39:25.167]                       workers <- workers()
[17:39:25.167]                     workers <- structure(as.integer(workers), 
[17:39:25.167]                       class = class(workers))
[17:39:25.167]                     stop_if_not(is.finite(workers), workers >= 
[17:39:25.167]                       1L)
[17:39:25.167]                     if ((workers == 1L && !inherits(workers, 
[17:39:25.167]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:25.167]                       if (default_workers) 
[17:39:25.167]                         supportsMulticore(warn = TRUE)
[17:39:25.167]                       return(sequential(..., envir = envir))
[17:39:25.167]                     }
[17:39:25.167]                     oopts <- options(mc.cores = workers)
[17:39:25.167]                     on.exit(options(oopts))
[17:39:25.167]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:25.167]                       envir = envir)
[17:39:25.167]                     if (!future$lazy) 
[17:39:25.167]                       future <- run(future)
[17:39:25.167]                     invisible(future)
[17:39:25.167]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.167]                 }
[17:39:25.167]             }
[17:39:25.167]         }
[17:39:25.167]     })
[17:39:25.167]     if (TRUE) {
[17:39:25.167]         base::sink(type = "output", split = FALSE)
[17:39:25.167]         if (TRUE) {
[17:39:25.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.167]         }
[17:39:25.167]         else {
[17:39:25.167]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.167]         }
[17:39:25.167]         base::close(...future.stdout)
[17:39:25.167]         ...future.stdout <- NULL
[17:39:25.167]     }
[17:39:25.167]     ...future.result$conditions <- ...future.conditions
[17:39:25.167]     ...future.result$finished <- base::Sys.time()
[17:39:25.167]     ...future.result
[17:39:25.167] }
[17:39:25.169] assign_globals() ...
[17:39:25.169] List of 5
[17:39:25.169]  $ ...future.FUN            :function (x, ...)  
[17:39:25.169]  $ future.call.arguments    :List of 1
[17:39:25.169]   ..$ singular.ok: logi FALSE
[17:39:25.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.169]  $ ...future.elements_ii    :List of 3
[17:39:25.169]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.169]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.169]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.169]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.169]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.169]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.169]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.169]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.169]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.169]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.169]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.169]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.169]  $ ...future.seeds_ii       : NULL
[17:39:25.169]  $ ...future.globals.maxSize: NULL
[17:39:25.169]  - attr(*, "resolved")= logi FALSE
[17:39:25.169]  - attr(*, "total_size")= num 5384
[17:39:25.169]  - attr(*, "where")=List of 5
[17:39:25.169]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.169]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.169]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.169]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.169]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.169]  - attr(*, "already-done")= logi TRUE
[17:39:25.178] - reassign environment for ‘...future.FUN’
[17:39:25.178] - copied ‘...future.FUN’ to environment
[17:39:25.178] - copied ‘future.call.arguments’ to environment
[17:39:25.179] - copied ‘...future.elements_ii’ to environment
[17:39:25.179] - copied ‘...future.seeds_ii’ to environment
[17:39:25.179] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.179] assign_globals() ... done
[17:39:25.179] plan(): Setting new future strategy stack:
[17:39:25.179] List of future strategies:
[17:39:25.179] 1. sequential:
[17:39:25.179]    - args: function (..., envir = parent.frame())
[17:39:25.179]    - tweaked: FALSE
[17:39:25.179]    - call: NULL
[17:39:25.180] plan(): nbrOfWorkers() = 1
[17:39:25.182] plan(): Setting new future strategy stack:
[17:39:25.183] List of future strategies:
[17:39:25.183] 1. multicore:
[17:39:25.183]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:25.183]    - tweaked: FALSE
[17:39:25.183]    - call: plan(strategy)
[17:39:25.187] plan(): nbrOfWorkers() = 1
[17:39:25.187] SequentialFuture started (and completed)
[17:39:25.187] - Launch lazy future ... done
[17:39:25.188] run() for ‘SequentialFuture’ ... done
[17:39:25.188] Created future:
[17:39:25.188] SequentialFuture:
[17:39:25.188] Label: ‘future_by-1’
[17:39:25.188] Expression:
[17:39:25.188] {
[17:39:25.188]     do.call(function(...) {
[17:39:25.188]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.188]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.188]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.188]             on.exit(options(oopts), add = TRUE)
[17:39:25.188]         }
[17:39:25.188]         {
[17:39:25.188]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.188]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.188]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.188]             })
[17:39:25.188]         }
[17:39:25.188]     }, args = future.call.arguments)
[17:39:25.188] }
[17:39:25.188] Lazy evaluation: FALSE
[17:39:25.188] Asynchronous evaluation: FALSE
[17:39:25.188] Local evaluation: TRUE
[17:39:25.188] Environment: R_GlobalEnv
[17:39:25.188] Capture standard output: TRUE
[17:39:25.188] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.188] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.188] Packages: 1 packages (‘stats’)
[17:39:25.188] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.188] Resolved: TRUE
[17:39:25.188] Value: 26.06 KiB of class ‘list’
[17:39:25.188] Early signaling: FALSE
[17:39:25.188] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.188] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.189] Chunk #1 of 1 ... DONE
[17:39:25.189] Launching 1 futures (chunks) ... DONE
[17:39:25.189] Resolving 1 futures (chunks) ...
[17:39:25.190] resolve() on list ...
[17:39:25.190]  recursive: 0
[17:39:25.190]  length: 1
[17:39:25.190] 
[17:39:25.190] resolved() for ‘SequentialFuture’ ...
[17:39:25.190] - state: ‘finished’
[17:39:25.190] - run: TRUE
[17:39:25.190] - result: ‘FutureResult’
[17:39:25.190] resolved() for ‘SequentialFuture’ ... done
[17:39:25.190] Future #1
[17:39:25.191] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.191] - nx: 1
[17:39:25.191] - relay: TRUE
[17:39:25.191] - stdout: TRUE
[17:39:25.191] - signal: TRUE
[17:39:25.191] - resignal: FALSE
[17:39:25.191] - force: TRUE
[17:39:25.191] - relayed: [n=1] FALSE
[17:39:25.191] - queued futures: [n=1] FALSE
[17:39:25.191]  - until=1
[17:39:25.191]  - relaying element #1
[17:39:25.192] - relayed: [n=1] TRUE
[17:39:25.192] - queued futures: [n=1] TRUE
[17:39:25.192] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.192]  length: 0 (resolved future 1)
[17:39:25.192] Relaying remaining futures
[17:39:25.192] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.192] - nx: 1
[17:39:25.192] - relay: TRUE
[17:39:25.192] - stdout: TRUE
[17:39:25.192] - signal: TRUE
[17:39:25.193] - resignal: FALSE
[17:39:25.193] - force: TRUE
[17:39:25.193] - relayed: [n=1] TRUE
[17:39:25.193] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.193] - relayed: [n=1] TRUE
[17:39:25.193] - queued futures: [n=1] TRUE
[17:39:25.193] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.193] resolve() on list ... DONE
[17:39:25.193]  - Number of value chunks collected: 1
[17:39:25.193] Resolving 1 futures (chunks) ... DONE
[17:39:25.194] Reducing values from 1 chunks ...
[17:39:25.194]  - Number of values collected after concatenation: 3
[17:39:25.194]  - Number of values expected: 3
[17:39:25.194] Reducing values from 1 chunks ... DONE
[17:39:25.194] future_lapply() ... DONE
[17:39:25.194] future_by_internal() ... DONE
[17:39:25.198] future_by_internal() ...
[17:39:25.198] future_lapply() ...
[17:39:25.202] Number of chunks: 1
[17:39:25.202] getGlobalsAndPackagesXApply() ...
[17:39:25.202]  - future.globals: TRUE
[17:39:25.202] getGlobalsAndPackages() ...
[17:39:25.202] Searching for globals...
[17:39:25.204] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:25.204] Searching for globals ... DONE
[17:39:25.204] Resolving globals: FALSE
[17:39:25.205] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:39:25.205] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:39:25.205] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:25.205] - packages: [1] ‘stats’
[17:39:25.205] getGlobalsAndPackages() ... DONE
[17:39:25.205]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:25.206]  - needed namespaces: [n=1] ‘stats’
[17:39:25.206] Finding globals ... DONE
[17:39:25.206]  - use_args: TRUE
[17:39:25.206]  - Getting '...' globals ...
[17:39:25.206] resolve() on list ...
[17:39:25.206]  recursive: 0
[17:39:25.206]  length: 1
[17:39:25.206]  elements: ‘...’
[17:39:25.207]  length: 0 (resolved future 1)
[17:39:25.207] resolve() on list ... DONE
[17:39:25.207]    - '...' content: [n=0] 
[17:39:25.207] List of 1
[17:39:25.207]  $ ...: list()
[17:39:25.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.207]  - attr(*, "where")=List of 1
[17:39:25.207]   ..$ ...:<environment: 0x5629708829f8> 
[17:39:25.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.207]  - attr(*, "resolved")= logi TRUE
[17:39:25.207]  - attr(*, "total_size")= num NA
[17:39:25.210]  - Getting '...' globals ... DONE
[17:39:25.210] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:39:25.211] List of 4
[17:39:25.211]  $ ...future.FUN:function (x)  
[17:39:25.211]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:25.211]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.211]  $ ...          : list()
[17:39:25.211]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.211]  - attr(*, "where")=List of 4
[17:39:25.211]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.211]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:39:25.211]   ..$ wool         :<environment: R_EmptyEnv> 
[17:39:25.211]   ..$ ...          :<environment: 0x5629708829f8> 
[17:39:25.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.211]  - attr(*, "resolved")= logi FALSE
[17:39:25.211]  - attr(*, "total_size")= num 2320
[17:39:25.214] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:25.214] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.214] Number of futures (= number of chunks): 1
[17:39:25.215] Launching 1 futures (chunks) ...
[17:39:25.215] Chunk #1 of 1 ...
[17:39:25.215]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.215] getGlobalsAndPackages() ...
[17:39:25.215] Searching for globals...
[17:39:25.215] 
[17:39:25.216] Searching for globals ... DONE
[17:39:25.216] - globals: [0] <none>
[17:39:25.216] getGlobalsAndPackages() ... DONE
[17:39:25.216]    + additional globals found: [n=0] 
[17:39:25.216]    + additional namespaces needed: [n=0] 
[17:39:25.216]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.216]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.216]  - seeds: <none>
[17:39:25.216] getGlobalsAndPackages() ...
[17:39:25.216] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.217] Resolving globals: FALSE
[17:39:25.217] Tweak future expression to call with '...' arguments ...
[17:39:25.217] {
[17:39:25.217]     do.call(function(...) {
[17:39:25.217]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.217]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.217]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.217]             on.exit(options(oopts), add = TRUE)
[17:39:25.217]         }
[17:39:25.217]         {
[17:39:25.217]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.217]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.217]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.217]             })
[17:39:25.217]         }
[17:39:25.217]     }, args = future.call.arguments)
[17:39:25.217] }
[17:39:25.217] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.217] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.218] 
[17:39:25.218] getGlobalsAndPackages() ... DONE
[17:39:25.218] run() for ‘Future’ ...
[17:39:25.218] - state: ‘created’
[17:39:25.218] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.222] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.222] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.222]   - Field: ‘label’
[17:39:25.222]   - Field: ‘local’
[17:39:25.222]   - Field: ‘owner’
[17:39:25.222]   - Field: ‘envir’
[17:39:25.222]   - Field: ‘packages’
[17:39:25.222]   - Field: ‘gc’
[17:39:25.222]   - Field: ‘conditions’
[17:39:25.222]   - Field: ‘expr’
[17:39:25.223]   - Field: ‘uuid’
[17:39:25.223]   - Field: ‘seed’
[17:39:25.223]   - Field: ‘version’
[17:39:25.223]   - Field: ‘result’
[17:39:25.223]   - Field: ‘asynchronous’
[17:39:25.223]   - Field: ‘calls’
[17:39:25.223]   - Field: ‘globals’
[17:39:25.223]   - Field: ‘stdout’
[17:39:25.223]   - Field: ‘earlySignal’
[17:39:25.223]   - Field: ‘lazy’
[17:39:25.223]   - Field: ‘state’
[17:39:25.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.224] - Launch lazy future ...
[17:39:25.224] Packages needed by the future expression (n = 1): ‘stats’
[17:39:25.224] Packages needed by future strategies (n = 0): <none>
[17:39:25.224] {
[17:39:25.224]     {
[17:39:25.224]         {
[17:39:25.224]             ...future.startTime <- base::Sys.time()
[17:39:25.224]             {
[17:39:25.224]                 {
[17:39:25.224]                   {
[17:39:25.224]                     {
[17:39:25.224]                       base::local({
[17:39:25.224]                         has_future <- base::requireNamespace("future", 
[17:39:25.224]                           quietly = TRUE)
[17:39:25.224]                         if (has_future) {
[17:39:25.224]                           ns <- base::getNamespace("future")
[17:39:25.224]                           version <- ns[[".package"]][["version"]]
[17:39:25.224]                           if (is.null(version)) 
[17:39:25.224]                             version <- utils::packageVersion("future")
[17:39:25.224]                         }
[17:39:25.224]                         else {
[17:39:25.224]                           version <- NULL
[17:39:25.224]                         }
[17:39:25.224]                         if (!has_future || version < "1.8.0") {
[17:39:25.224]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.224]                             "", base::R.version$version.string), 
[17:39:25.224]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:25.224]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.224]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.224]                               "release", "version")], collapse = " "), 
[17:39:25.224]                             hostname = base::Sys.info()[["nodename"]])
[17:39:25.224]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.224]                             info)
[17:39:25.224]                           info <- base::paste(info, collapse = "; ")
[17:39:25.224]                           if (!has_future) {
[17:39:25.224]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.224]                               info)
[17:39:25.224]                           }
[17:39:25.224]                           else {
[17:39:25.224]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.224]                               info, version)
[17:39:25.224]                           }
[17:39:25.224]                           base::stop(msg)
[17:39:25.224]                         }
[17:39:25.224]                       })
[17:39:25.224]                     }
[17:39:25.224]                     base::local({
[17:39:25.224]                       for (pkg in "stats") {
[17:39:25.224]                         base::loadNamespace(pkg)
[17:39:25.224]                         base::library(pkg, character.only = TRUE)
[17:39:25.224]                       }
[17:39:25.224]                     })
[17:39:25.224]                   }
[17:39:25.224]                   options(future.plan = NULL)
[17:39:25.224]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.224]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.224]                 }
[17:39:25.224]                 ...future.workdir <- getwd()
[17:39:25.224]             }
[17:39:25.224]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.224]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.224]         }
[17:39:25.224]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.224]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.224]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.224]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.224]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.224]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.224]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.224]             base::names(...future.oldOptions))
[17:39:25.224]     }
[17:39:25.224]     if (FALSE) {
[17:39:25.224]     }
[17:39:25.224]     else {
[17:39:25.224]         if (TRUE) {
[17:39:25.224]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.224]                 open = "w")
[17:39:25.224]         }
[17:39:25.224]         else {
[17:39:25.224]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.224]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.224]         }
[17:39:25.224]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.224]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.224]             base::sink(type = "output", split = FALSE)
[17:39:25.224]             base::close(...future.stdout)
[17:39:25.224]         }, add = TRUE)
[17:39:25.224]     }
[17:39:25.224]     ...future.frame <- base::sys.nframe()
[17:39:25.224]     ...future.conditions <- base::list()
[17:39:25.224]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.224]     if (FALSE) {
[17:39:25.224]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.224]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.224]     }
[17:39:25.224]     ...future.result <- base::tryCatch({
[17:39:25.224]         base::withCallingHandlers({
[17:39:25.224]             ...future.value <- base::withVisible(base::local({
[17:39:25.224]                 do.call(function(...) {
[17:39:25.224]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.224]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.224]                     ...future.globals.maxSize)) {
[17:39:25.224]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.224]                     on.exit(options(oopts), add = TRUE)
[17:39:25.224]                   }
[17:39:25.224]                   {
[17:39:25.224]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.224]                       FUN = function(jj) {
[17:39:25.224]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.224]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.224]                       })
[17:39:25.224]                   }
[17:39:25.224]                 }, args = future.call.arguments)
[17:39:25.224]             }))
[17:39:25.224]             future::FutureResult(value = ...future.value$value, 
[17:39:25.224]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.224]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.224]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.224]                     ...future.globalenv.names))
[17:39:25.224]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.224]         }, condition = base::local({
[17:39:25.224]             c <- base::c
[17:39:25.224]             inherits <- base::inherits
[17:39:25.224]             invokeRestart <- base::invokeRestart
[17:39:25.224]             length <- base::length
[17:39:25.224]             list <- base::list
[17:39:25.224]             seq.int <- base::seq.int
[17:39:25.224]             signalCondition <- base::signalCondition
[17:39:25.224]             sys.calls <- base::sys.calls
[17:39:25.224]             `[[` <- base::`[[`
[17:39:25.224]             `+` <- base::`+`
[17:39:25.224]             `<<-` <- base::`<<-`
[17:39:25.224]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.224]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.224]                   3L)]
[17:39:25.224]             }
[17:39:25.224]             function(cond) {
[17:39:25.224]                 is_error <- inherits(cond, "error")
[17:39:25.224]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.224]                   NULL)
[17:39:25.224]                 if (is_error) {
[17:39:25.224]                   sessionInformation <- function() {
[17:39:25.224]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.224]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.224]                       search = base::search(), system = base::Sys.info())
[17:39:25.224]                   }
[17:39:25.224]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.224]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.224]                     cond$call), session = sessionInformation(), 
[17:39:25.224]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.224]                   signalCondition(cond)
[17:39:25.224]                 }
[17:39:25.224]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.224]                 "immediateCondition"))) {
[17:39:25.224]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.224]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.224]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.224]                   if (TRUE && !signal) {
[17:39:25.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.224]                     {
[17:39:25.224]                       inherits <- base::inherits
[17:39:25.224]                       invokeRestart <- base::invokeRestart
[17:39:25.224]                       is.null <- base::is.null
[17:39:25.224]                       muffled <- FALSE
[17:39:25.224]                       if (inherits(cond, "message")) {
[17:39:25.224]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.224]                         if (muffled) 
[17:39:25.224]                           invokeRestart("muffleMessage")
[17:39:25.224]                       }
[17:39:25.224]                       else if (inherits(cond, "warning")) {
[17:39:25.224]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.224]                         if (muffled) 
[17:39:25.224]                           invokeRestart("muffleWarning")
[17:39:25.224]                       }
[17:39:25.224]                       else if (inherits(cond, "condition")) {
[17:39:25.224]                         if (!is.null(pattern)) {
[17:39:25.224]                           computeRestarts <- base::computeRestarts
[17:39:25.224]                           grepl <- base::grepl
[17:39:25.224]                           restarts <- computeRestarts(cond)
[17:39:25.224]                           for (restart in restarts) {
[17:39:25.224]                             name <- restart$name
[17:39:25.224]                             if (is.null(name)) 
[17:39:25.224]                               next
[17:39:25.224]                             if (!grepl(pattern, name)) 
[17:39:25.224]                               next
[17:39:25.224]                             invokeRestart(restart)
[17:39:25.224]                             muffled <- TRUE
[17:39:25.224]                             break
[17:39:25.224]                           }
[17:39:25.224]                         }
[17:39:25.224]                       }
[17:39:25.224]                       invisible(muffled)
[17:39:25.224]                     }
[17:39:25.224]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.224]                   }
[17:39:25.224]                 }
[17:39:25.224]                 else {
[17:39:25.224]                   if (TRUE) {
[17:39:25.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.224]                     {
[17:39:25.224]                       inherits <- base::inherits
[17:39:25.224]                       invokeRestart <- base::invokeRestart
[17:39:25.224]                       is.null <- base::is.null
[17:39:25.224]                       muffled <- FALSE
[17:39:25.224]                       if (inherits(cond, "message")) {
[17:39:25.224]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.224]                         if (muffled) 
[17:39:25.224]                           invokeRestart("muffleMessage")
[17:39:25.224]                       }
[17:39:25.224]                       else if (inherits(cond, "warning")) {
[17:39:25.224]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.224]                         if (muffled) 
[17:39:25.224]                           invokeRestart("muffleWarning")
[17:39:25.224]                       }
[17:39:25.224]                       else if (inherits(cond, "condition")) {
[17:39:25.224]                         if (!is.null(pattern)) {
[17:39:25.224]                           computeRestarts <- base::computeRestarts
[17:39:25.224]                           grepl <- base::grepl
[17:39:25.224]                           restarts <- computeRestarts(cond)
[17:39:25.224]                           for (restart in restarts) {
[17:39:25.224]                             name <- restart$name
[17:39:25.224]                             if (is.null(name)) 
[17:39:25.224]                               next
[17:39:25.224]                             if (!grepl(pattern, name)) 
[17:39:25.224]                               next
[17:39:25.224]                             invokeRestart(restart)
[17:39:25.224]                             muffled <- TRUE
[17:39:25.224]                             break
[17:39:25.224]                           }
[17:39:25.224]                         }
[17:39:25.224]                       }
[17:39:25.224]                       invisible(muffled)
[17:39:25.224]                     }
[17:39:25.224]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.224]                   }
[17:39:25.224]                 }
[17:39:25.224]             }
[17:39:25.224]         }))
[17:39:25.224]     }, error = function(ex) {
[17:39:25.224]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.224]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.224]                 ...future.rng), started = ...future.startTime, 
[17:39:25.224]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.224]             version = "1.8"), class = "FutureResult")
[17:39:25.224]     }, finally = {
[17:39:25.224]         if (!identical(...future.workdir, getwd())) 
[17:39:25.224]             setwd(...future.workdir)
[17:39:25.224]         {
[17:39:25.224]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.224]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.224]             }
[17:39:25.224]             base::options(...future.oldOptions)
[17:39:25.224]             if (.Platform$OS.type == "windows") {
[17:39:25.224]                 old_names <- names(...future.oldEnvVars)
[17:39:25.224]                 envs <- base::Sys.getenv()
[17:39:25.224]                 names <- names(envs)
[17:39:25.224]                 common <- intersect(names, old_names)
[17:39:25.224]                 added <- setdiff(names, old_names)
[17:39:25.224]                 removed <- setdiff(old_names, names)
[17:39:25.224]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.224]                   envs[common]]
[17:39:25.224]                 NAMES <- toupper(changed)
[17:39:25.224]                 args <- list()
[17:39:25.224]                 for (kk in seq_along(NAMES)) {
[17:39:25.224]                   name <- changed[[kk]]
[17:39:25.224]                   NAME <- NAMES[[kk]]
[17:39:25.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.224]                     next
[17:39:25.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.224]                 }
[17:39:25.224]                 NAMES <- toupper(added)
[17:39:25.224]                 for (kk in seq_along(NAMES)) {
[17:39:25.224]                   name <- added[[kk]]
[17:39:25.224]                   NAME <- NAMES[[kk]]
[17:39:25.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.224]                     next
[17:39:25.224]                   args[[name]] <- ""
[17:39:25.224]                 }
[17:39:25.224]                 NAMES <- toupper(removed)
[17:39:25.224]                 for (kk in seq_along(NAMES)) {
[17:39:25.224]                   name <- removed[[kk]]
[17:39:25.224]                   NAME <- NAMES[[kk]]
[17:39:25.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.224]                     next
[17:39:25.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.224]                 }
[17:39:25.224]                 if (length(args) > 0) 
[17:39:25.224]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.224]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.224]             }
[17:39:25.224]             else {
[17:39:25.224]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.224]             }
[17:39:25.224]             {
[17:39:25.224]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.224]                   0L) {
[17:39:25.224]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.224]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.224]                   base::options(opts)
[17:39:25.224]                 }
[17:39:25.224]                 {
[17:39:25.224]                   {
[17:39:25.224]                     NULL
[17:39:25.224]                     RNGkind("Mersenne-Twister")
[17:39:25.224]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.224]                       inherits = FALSE)
[17:39:25.224]                   }
[17:39:25.224]                   options(future.plan = NULL)
[17:39:25.224]                   if (is.na(NA_character_)) 
[17:39:25.224]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.224]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.224]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:25.224]                     envir = parent.frame()) 
[17:39:25.224]                   {
[17:39:25.224]                     default_workers <- missing(workers)
[17:39:25.224]                     if (is.function(workers)) 
[17:39:25.224]                       workers <- workers()
[17:39:25.224]                     workers <- structure(as.integer(workers), 
[17:39:25.224]                       class = class(workers))
[17:39:25.224]                     stop_if_not(is.finite(workers), workers >= 
[17:39:25.224]                       1L)
[17:39:25.224]                     if ((workers == 1L && !inherits(workers, 
[17:39:25.224]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:25.224]                       if (default_workers) 
[17:39:25.224]                         supportsMulticore(warn = TRUE)
[17:39:25.224]                       return(sequential(..., envir = envir))
[17:39:25.224]                     }
[17:39:25.224]                     oopts <- options(mc.cores = workers)
[17:39:25.224]                     on.exit(options(oopts))
[17:39:25.224]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:25.224]                       envir = envir)
[17:39:25.224]                     if (!future$lazy) 
[17:39:25.224]                       future <- run(future)
[17:39:25.224]                     invisible(future)
[17:39:25.224]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.224]                 }
[17:39:25.224]             }
[17:39:25.224]         }
[17:39:25.224]     })
[17:39:25.224]     if (TRUE) {
[17:39:25.224]         base::sink(type = "output", split = FALSE)
[17:39:25.224]         if (TRUE) {
[17:39:25.224]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.224]         }
[17:39:25.224]         else {
[17:39:25.224]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.224]         }
[17:39:25.224]         base::close(...future.stdout)
[17:39:25.224]         ...future.stdout <- NULL
[17:39:25.224]     }
[17:39:25.224]     ...future.result$conditions <- ...future.conditions
[17:39:25.224]     ...future.result$finished <- base::Sys.time()
[17:39:25.224]     ...future.result
[17:39:25.224] }
[17:39:25.226] assign_globals() ...
[17:39:25.226] List of 7
[17:39:25.226]  $ ...future.FUN            :function (x)  
[17:39:25.226]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:25.226]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.226]  $ future.call.arguments    : list()
[17:39:25.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.226]  $ ...future.elements_ii    :List of 3
[17:39:25.226]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.226]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.226]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.226]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.226]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.226]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.226]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.226]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.226]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.226]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.226]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.226]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.226]  $ ...future.seeds_ii       : NULL
[17:39:25.226]  $ ...future.globals.maxSize: NULL
[17:39:25.226]  - attr(*, "resolved")= logi FALSE
[17:39:25.226]  - attr(*, "total_size")= num 2320
[17:39:25.226]  - attr(*, "where")=List of 7
[17:39:25.226]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.226]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:39:25.226]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:39:25.226]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.226]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.226]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.226]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.226]  - attr(*, "already-done")= logi TRUE
[17:39:25.237] - reassign environment for ‘...future.FUN’
[17:39:25.237] - copied ‘...future.FUN’ to environment
[17:39:25.237] - copied ‘breaks’ to environment
[17:39:25.237] - copied ‘wool’ to environment
[17:39:25.237] - copied ‘future.call.arguments’ to environment
[17:39:25.237] - copied ‘...future.elements_ii’ to environment
[17:39:25.238] - copied ‘...future.seeds_ii’ to environment
[17:39:25.238] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.238] assign_globals() ... done
[17:39:25.238] plan(): Setting new future strategy stack:
[17:39:25.238] List of future strategies:
[17:39:25.238] 1. sequential:
[17:39:25.238]    - args: function (..., envir = parent.frame())
[17:39:25.238]    - tweaked: FALSE
[17:39:25.238]    - call: NULL
[17:39:25.239] plan(): nbrOfWorkers() = 1
[17:39:25.241] plan(): Setting new future strategy stack:
[17:39:25.241] List of future strategies:
[17:39:25.241] 1. multicore:
[17:39:25.241]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:25.241]    - tweaked: FALSE
[17:39:25.241]    - call: plan(strategy)
[17:39:25.245] plan(): nbrOfWorkers() = 1
[17:39:25.245] SequentialFuture started (and completed)
[17:39:25.245] - Launch lazy future ... done
[17:39:25.245] run() for ‘SequentialFuture’ ... done
[17:39:25.245] Created future:
[17:39:25.245] SequentialFuture:
[17:39:25.245] Label: ‘future_by-1’
[17:39:25.245] Expression:
[17:39:25.245] {
[17:39:25.245]     do.call(function(...) {
[17:39:25.245]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.245]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.245]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.245]             on.exit(options(oopts), add = TRUE)
[17:39:25.245]         }
[17:39:25.245]         {
[17:39:25.245]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.245]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.245]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.245]             })
[17:39:25.245]         }
[17:39:25.245]     }, args = future.call.arguments)
[17:39:25.245] }
[17:39:25.245] Lazy evaluation: FALSE
[17:39:25.245] Asynchronous evaluation: FALSE
[17:39:25.245] Local evaluation: TRUE
[17:39:25.245] Environment: 0x56297080e4d0
[17:39:25.245] Capture standard output: TRUE
[17:39:25.245] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.245] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:39:25.245] Packages: 1 packages (‘stats’)
[17:39:25.245] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.245] Resolved: TRUE
[17:39:25.245] Value: 25.57 KiB of class ‘list’
[17:39:25.245] Early signaling: FALSE
[17:39:25.245] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.245] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.247] Chunk #1 of 1 ... DONE
[17:39:25.247] Launching 1 futures (chunks) ... DONE
[17:39:25.247] Resolving 1 futures (chunks) ...
[17:39:25.247] resolve() on list ...
[17:39:25.247]  recursive: 0
[17:39:25.248]  length: 1
[17:39:25.248] 
[17:39:25.248] resolved() for ‘SequentialFuture’ ...
[17:39:25.248] - state: ‘finished’
[17:39:25.248] - run: TRUE
[17:39:25.248] - result: ‘FutureResult’
[17:39:25.248] resolved() for ‘SequentialFuture’ ... done
[17:39:25.248] Future #1
[17:39:25.248] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.248] - nx: 1
[17:39:25.248] - relay: TRUE
[17:39:25.249] - stdout: TRUE
[17:39:25.249] - signal: TRUE
[17:39:25.249] - resignal: FALSE
[17:39:25.249] - force: TRUE
[17:39:25.249] - relayed: [n=1] FALSE
[17:39:25.249] - queued futures: [n=1] FALSE
[17:39:25.249]  - until=1
[17:39:25.249]  - relaying element #1
[17:39:25.249] - relayed: [n=1] TRUE
[17:39:25.249] - queued futures: [n=1] TRUE
[17:39:25.250] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.250]  length: 0 (resolved future 1)
[17:39:25.250] Relaying remaining futures
[17:39:25.250] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.250] - nx: 1
[17:39:25.250] - relay: TRUE
[17:39:25.250] - stdout: TRUE
[17:39:25.250] - signal: TRUE
[17:39:25.250] - resignal: FALSE
[17:39:25.250] - force: TRUE
[17:39:25.250] - relayed: [n=1] TRUE
[17:39:25.250] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.251] - relayed: [n=1] TRUE
[17:39:25.251] - queued futures: [n=1] TRUE
[17:39:25.251] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.251] resolve() on list ... DONE
[17:39:25.251]  - Number of value chunks collected: 1
[17:39:25.251] Resolving 1 futures (chunks) ... DONE
[17:39:25.251] Reducing values from 1 chunks ...
[17:39:25.251]  - Number of values collected after concatenation: 3
[17:39:25.251]  - Number of values expected: 3
[17:39:25.251] Reducing values from 1 chunks ... DONE
[17:39:25.252] future_lapply() ... DONE
[17:39:25.252] future_by_internal() ... DONE
[17:39:25.252] future_by_internal() ...
[17:39:25.252] future_lapply() ...
[17:39:25.256] Number of chunks: 1
[17:39:25.257] getGlobalsAndPackagesXApply() ...
[17:39:25.257]  - future.globals: TRUE
[17:39:25.257] getGlobalsAndPackages() ...
[17:39:25.257] Searching for globals...
[17:39:25.258] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.259] Searching for globals ... DONE
[17:39:25.259] Resolving globals: FALSE
[17:39:25.259] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.259] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.259] - globals: [1] ‘FUN’
[17:39:25.260] 
[17:39:25.260] getGlobalsAndPackages() ... DONE
[17:39:25.260]  - globals found/used: [n=1] ‘FUN’
[17:39:25.260]  - needed namespaces: [n=0] 
[17:39:25.260] Finding globals ... DONE
[17:39:25.260]  - use_args: TRUE
[17:39:25.260]  - Getting '...' globals ...
[17:39:25.260] resolve() on list ...
[17:39:25.260]  recursive: 0
[17:39:25.261]  length: 1
[17:39:25.261]  elements: ‘...’
[17:39:25.261]  length: 0 (resolved future 1)
[17:39:25.261] resolve() on list ... DONE
[17:39:25.261]    - '...' content: [n=0] 
[17:39:25.261] List of 1
[17:39:25.261]  $ ...: list()
[17:39:25.261]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.261]  - attr(*, "where")=List of 1
[17:39:25.261]   ..$ ...:<environment: 0x562971082558> 
[17:39:25.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.261]  - attr(*, "resolved")= logi TRUE
[17:39:25.261]  - attr(*, "total_size")= num NA
[17:39:25.263]  - Getting '...' globals ... DONE
[17:39:25.264] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.264] List of 2
[17:39:25.264]  $ ...future.FUN:function (object, ...)  
[17:39:25.264]  $ ...          : list()
[17:39:25.264]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.264]  - attr(*, "where")=List of 2
[17:39:25.264]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.264]   ..$ ...          :<environment: 0x562971082558> 
[17:39:25.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.264]  - attr(*, "resolved")= logi FALSE
[17:39:25.264]  - attr(*, "total_size")= num 1240
[17:39:25.266] Packages to be attached in all futures: [n=0] 
[17:39:25.266] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.267] Number of futures (= number of chunks): 1
[17:39:25.267] Launching 1 futures (chunks) ...
[17:39:25.267] Chunk #1 of 1 ...
[17:39:25.267]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.267] getGlobalsAndPackages() ...
[17:39:25.267] Searching for globals...
[17:39:25.268] 
[17:39:25.268] Searching for globals ... DONE
[17:39:25.268] - globals: [0] <none>
[17:39:25.268] getGlobalsAndPackages() ... DONE
[17:39:25.268]    + additional globals found: [n=0] 
[17:39:25.268]    + additional namespaces needed: [n=0] 
[17:39:25.268]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.268]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.268]  - seeds: <none>
[17:39:25.268] getGlobalsAndPackages() ...
[17:39:25.269] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.269] Resolving globals: FALSE
[17:39:25.269] Tweak future expression to call with '...' arguments ...
[17:39:25.269] {
[17:39:25.269]     do.call(function(...) {
[17:39:25.269]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.269]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.269]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.269]             on.exit(options(oopts), add = TRUE)
[17:39:25.269]         }
[17:39:25.269]         {
[17:39:25.269]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.269]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.269]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.269]             })
[17:39:25.269]         }
[17:39:25.269]     }, args = future.call.arguments)
[17:39:25.269] }
[17:39:25.269] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.269] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.270] 
[17:39:25.270] getGlobalsAndPackages() ... DONE
[17:39:25.270] run() for ‘Future’ ...
[17:39:25.270] - state: ‘created’
[17:39:25.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.274] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.274]   - Field: ‘label’
[17:39:25.274]   - Field: ‘local’
[17:39:25.274]   - Field: ‘owner’
[17:39:25.274]   - Field: ‘envir’
[17:39:25.274]   - Field: ‘packages’
[17:39:25.274]   - Field: ‘gc’
[17:39:25.275]   - Field: ‘conditions’
[17:39:25.275]   - Field: ‘expr’
[17:39:25.275]   - Field: ‘uuid’
[17:39:25.275]   - Field: ‘seed’
[17:39:25.275]   - Field: ‘version’
[17:39:25.275]   - Field: ‘result’
[17:39:25.275]   - Field: ‘asynchronous’
[17:39:25.275]   - Field: ‘calls’
[17:39:25.275]   - Field: ‘globals’
[17:39:25.276]   - Field: ‘stdout’
[17:39:25.276]   - Field: ‘earlySignal’
[17:39:25.276]   - Field: ‘lazy’
[17:39:25.276]   - Field: ‘state’
[17:39:25.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.276] - Launch lazy future ...
[17:39:25.276] Packages needed by the future expression (n = 0): <none>
[17:39:25.276] Packages needed by future strategies (n = 0): <none>
[17:39:25.277] {
[17:39:25.277]     {
[17:39:25.277]         {
[17:39:25.277]             ...future.startTime <- base::Sys.time()
[17:39:25.277]             {
[17:39:25.277]                 {
[17:39:25.277]                   {
[17:39:25.277]                     base::local({
[17:39:25.277]                       has_future <- base::requireNamespace("future", 
[17:39:25.277]                         quietly = TRUE)
[17:39:25.277]                       if (has_future) {
[17:39:25.277]                         ns <- base::getNamespace("future")
[17:39:25.277]                         version <- ns[[".package"]][["version"]]
[17:39:25.277]                         if (is.null(version)) 
[17:39:25.277]                           version <- utils::packageVersion("future")
[17:39:25.277]                       }
[17:39:25.277]                       else {
[17:39:25.277]                         version <- NULL
[17:39:25.277]                       }
[17:39:25.277]                       if (!has_future || version < "1.8.0") {
[17:39:25.277]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.277]                           "", base::R.version$version.string), 
[17:39:25.277]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.277]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.277]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.277]                             "release", "version")], collapse = " "), 
[17:39:25.277]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.277]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.277]                           info)
[17:39:25.277]                         info <- base::paste(info, collapse = "; ")
[17:39:25.277]                         if (!has_future) {
[17:39:25.277]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.277]                             info)
[17:39:25.277]                         }
[17:39:25.277]                         else {
[17:39:25.277]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.277]                             info, version)
[17:39:25.277]                         }
[17:39:25.277]                         base::stop(msg)
[17:39:25.277]                       }
[17:39:25.277]                     })
[17:39:25.277]                   }
[17:39:25.277]                   options(future.plan = NULL)
[17:39:25.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.277]                 }
[17:39:25.277]                 ...future.workdir <- getwd()
[17:39:25.277]             }
[17:39:25.277]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.277]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.277]         }
[17:39:25.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.277]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.277]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.277]             base::names(...future.oldOptions))
[17:39:25.277]     }
[17:39:25.277]     if (FALSE) {
[17:39:25.277]     }
[17:39:25.277]     else {
[17:39:25.277]         if (TRUE) {
[17:39:25.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.277]                 open = "w")
[17:39:25.277]         }
[17:39:25.277]         else {
[17:39:25.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.277]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.277]         }
[17:39:25.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.277]             base::sink(type = "output", split = FALSE)
[17:39:25.277]             base::close(...future.stdout)
[17:39:25.277]         }, add = TRUE)
[17:39:25.277]     }
[17:39:25.277]     ...future.frame <- base::sys.nframe()
[17:39:25.277]     ...future.conditions <- base::list()
[17:39:25.277]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.277]     if (FALSE) {
[17:39:25.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.277]     }
[17:39:25.277]     ...future.result <- base::tryCatch({
[17:39:25.277]         base::withCallingHandlers({
[17:39:25.277]             ...future.value <- base::withVisible(base::local({
[17:39:25.277]                 do.call(function(...) {
[17:39:25.277]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.277]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.277]                     ...future.globals.maxSize)) {
[17:39:25.277]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.277]                     on.exit(options(oopts), add = TRUE)
[17:39:25.277]                   }
[17:39:25.277]                   {
[17:39:25.277]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.277]                       FUN = function(jj) {
[17:39:25.277]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.277]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.277]                       })
[17:39:25.277]                   }
[17:39:25.277]                 }, args = future.call.arguments)
[17:39:25.277]             }))
[17:39:25.277]             future::FutureResult(value = ...future.value$value, 
[17:39:25.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.277]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.277]                     ...future.globalenv.names))
[17:39:25.277]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.277]         }, condition = base::local({
[17:39:25.277]             c <- base::c
[17:39:25.277]             inherits <- base::inherits
[17:39:25.277]             invokeRestart <- base::invokeRestart
[17:39:25.277]             length <- base::length
[17:39:25.277]             list <- base::list
[17:39:25.277]             seq.int <- base::seq.int
[17:39:25.277]             signalCondition <- base::signalCondition
[17:39:25.277]             sys.calls <- base::sys.calls
[17:39:25.277]             `[[` <- base::`[[`
[17:39:25.277]             `+` <- base::`+`
[17:39:25.277]             `<<-` <- base::`<<-`
[17:39:25.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.277]                   3L)]
[17:39:25.277]             }
[17:39:25.277]             function(cond) {
[17:39:25.277]                 is_error <- inherits(cond, "error")
[17:39:25.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.277]                   NULL)
[17:39:25.277]                 if (is_error) {
[17:39:25.277]                   sessionInformation <- function() {
[17:39:25.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.277]                       search = base::search(), system = base::Sys.info())
[17:39:25.277]                   }
[17:39:25.277]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.277]                     cond$call), session = sessionInformation(), 
[17:39:25.277]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.277]                   signalCondition(cond)
[17:39:25.277]                 }
[17:39:25.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.277]                 "immediateCondition"))) {
[17:39:25.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.277]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.277]                   if (TRUE && !signal) {
[17:39:25.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.277]                     {
[17:39:25.277]                       inherits <- base::inherits
[17:39:25.277]                       invokeRestart <- base::invokeRestart
[17:39:25.277]                       is.null <- base::is.null
[17:39:25.277]                       muffled <- FALSE
[17:39:25.277]                       if (inherits(cond, "message")) {
[17:39:25.277]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.277]                         if (muffled) 
[17:39:25.277]                           invokeRestart("muffleMessage")
[17:39:25.277]                       }
[17:39:25.277]                       else if (inherits(cond, "warning")) {
[17:39:25.277]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.277]                         if (muffled) 
[17:39:25.277]                           invokeRestart("muffleWarning")
[17:39:25.277]                       }
[17:39:25.277]                       else if (inherits(cond, "condition")) {
[17:39:25.277]                         if (!is.null(pattern)) {
[17:39:25.277]                           computeRestarts <- base::computeRestarts
[17:39:25.277]                           grepl <- base::grepl
[17:39:25.277]                           restarts <- computeRestarts(cond)
[17:39:25.277]                           for (restart in restarts) {
[17:39:25.277]                             name <- restart$name
[17:39:25.277]                             if (is.null(name)) 
[17:39:25.277]                               next
[17:39:25.277]                             if (!grepl(pattern, name)) 
[17:39:25.277]                               next
[17:39:25.277]                             invokeRestart(restart)
[17:39:25.277]                             muffled <- TRUE
[17:39:25.277]                             break
[17:39:25.277]                           }
[17:39:25.277]                         }
[17:39:25.277]                       }
[17:39:25.277]                       invisible(muffled)
[17:39:25.277]                     }
[17:39:25.277]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.277]                   }
[17:39:25.277]                 }
[17:39:25.277]                 else {
[17:39:25.277]                   if (TRUE) {
[17:39:25.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.277]                     {
[17:39:25.277]                       inherits <- base::inherits
[17:39:25.277]                       invokeRestart <- base::invokeRestart
[17:39:25.277]                       is.null <- base::is.null
[17:39:25.277]                       muffled <- FALSE
[17:39:25.277]                       if (inherits(cond, "message")) {
[17:39:25.277]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.277]                         if (muffled) 
[17:39:25.277]                           invokeRestart("muffleMessage")
[17:39:25.277]                       }
[17:39:25.277]                       else if (inherits(cond, "warning")) {
[17:39:25.277]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.277]                         if (muffled) 
[17:39:25.277]                           invokeRestart("muffleWarning")
[17:39:25.277]                       }
[17:39:25.277]                       else if (inherits(cond, "condition")) {
[17:39:25.277]                         if (!is.null(pattern)) {
[17:39:25.277]                           computeRestarts <- base::computeRestarts
[17:39:25.277]                           grepl <- base::grepl
[17:39:25.277]                           restarts <- computeRestarts(cond)
[17:39:25.277]                           for (restart in restarts) {
[17:39:25.277]                             name <- restart$name
[17:39:25.277]                             if (is.null(name)) 
[17:39:25.277]                               next
[17:39:25.277]                             if (!grepl(pattern, name)) 
[17:39:25.277]                               next
[17:39:25.277]                             invokeRestart(restart)
[17:39:25.277]                             muffled <- TRUE
[17:39:25.277]                             break
[17:39:25.277]                           }
[17:39:25.277]                         }
[17:39:25.277]                       }
[17:39:25.277]                       invisible(muffled)
[17:39:25.277]                     }
[17:39:25.277]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.277]                   }
[17:39:25.277]                 }
[17:39:25.277]             }
[17:39:25.277]         }))
[17:39:25.277]     }, error = function(ex) {
[17:39:25.277]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.277]                 ...future.rng), started = ...future.startTime, 
[17:39:25.277]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.277]             version = "1.8"), class = "FutureResult")
[17:39:25.277]     }, finally = {
[17:39:25.277]         if (!identical(...future.workdir, getwd())) 
[17:39:25.277]             setwd(...future.workdir)
[17:39:25.277]         {
[17:39:25.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.277]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.277]             }
[17:39:25.277]             base::options(...future.oldOptions)
[17:39:25.277]             if (.Platform$OS.type == "windows") {
[17:39:25.277]                 old_names <- names(...future.oldEnvVars)
[17:39:25.277]                 envs <- base::Sys.getenv()
[17:39:25.277]                 names <- names(envs)
[17:39:25.277]                 common <- intersect(names, old_names)
[17:39:25.277]                 added <- setdiff(names, old_names)
[17:39:25.277]                 removed <- setdiff(old_names, names)
[17:39:25.277]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.277]                   envs[common]]
[17:39:25.277]                 NAMES <- toupper(changed)
[17:39:25.277]                 args <- list()
[17:39:25.277]                 for (kk in seq_along(NAMES)) {
[17:39:25.277]                   name <- changed[[kk]]
[17:39:25.277]                   NAME <- NAMES[[kk]]
[17:39:25.277]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.277]                     next
[17:39:25.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.277]                 }
[17:39:25.277]                 NAMES <- toupper(added)
[17:39:25.277]                 for (kk in seq_along(NAMES)) {
[17:39:25.277]                   name <- added[[kk]]
[17:39:25.277]                   NAME <- NAMES[[kk]]
[17:39:25.277]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.277]                     next
[17:39:25.277]                   args[[name]] <- ""
[17:39:25.277]                 }
[17:39:25.277]                 NAMES <- toupper(removed)
[17:39:25.277]                 for (kk in seq_along(NAMES)) {
[17:39:25.277]                   name <- removed[[kk]]
[17:39:25.277]                   NAME <- NAMES[[kk]]
[17:39:25.277]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.277]                     next
[17:39:25.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.277]                 }
[17:39:25.277]                 if (length(args) > 0) 
[17:39:25.277]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.277]             }
[17:39:25.277]             else {
[17:39:25.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.277]             }
[17:39:25.277]             {
[17:39:25.277]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.277]                   0L) {
[17:39:25.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.277]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.277]                   base::options(opts)
[17:39:25.277]                 }
[17:39:25.277]                 {
[17:39:25.277]                   {
[17:39:25.277]                     NULL
[17:39:25.277]                     RNGkind("Mersenne-Twister")
[17:39:25.277]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.277]                       inherits = FALSE)
[17:39:25.277]                   }
[17:39:25.277]                   options(future.plan = NULL)
[17:39:25.277]                   if (is.na(NA_character_)) 
[17:39:25.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.277]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:25.277]                     envir = parent.frame()) 
[17:39:25.277]                   {
[17:39:25.277]                     default_workers <- missing(workers)
[17:39:25.277]                     if (is.function(workers)) 
[17:39:25.277]                       workers <- workers()
[17:39:25.277]                     workers <- structure(as.integer(workers), 
[17:39:25.277]                       class = class(workers))
[17:39:25.277]                     stop_if_not(is.finite(workers), workers >= 
[17:39:25.277]                       1L)
[17:39:25.277]                     if ((workers == 1L && !inherits(workers, 
[17:39:25.277]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:25.277]                       if (default_workers) 
[17:39:25.277]                         supportsMulticore(warn = TRUE)
[17:39:25.277]                       return(sequential(..., envir = envir))
[17:39:25.277]                     }
[17:39:25.277]                     oopts <- options(mc.cores = workers)
[17:39:25.277]                     on.exit(options(oopts))
[17:39:25.277]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:25.277]                       envir = envir)
[17:39:25.277]                     if (!future$lazy) 
[17:39:25.277]                       future <- run(future)
[17:39:25.277]                     invisible(future)
[17:39:25.277]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.277]                 }
[17:39:25.277]             }
[17:39:25.277]         }
[17:39:25.277]     })
[17:39:25.277]     if (TRUE) {
[17:39:25.277]         base::sink(type = "output", split = FALSE)
[17:39:25.277]         if (TRUE) {
[17:39:25.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.277]         }
[17:39:25.277]         else {
[17:39:25.277]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.277]         }
[17:39:25.277]         base::close(...future.stdout)
[17:39:25.277]         ...future.stdout <- NULL
[17:39:25.277]     }
[17:39:25.277]     ...future.result$conditions <- ...future.conditions
[17:39:25.277]     ...future.result$finished <- base::Sys.time()
[17:39:25.277]     ...future.result
[17:39:25.277] }
[17:39:25.279] assign_globals() ...
[17:39:25.279] List of 5
[17:39:25.279]  $ ...future.FUN            :function (object, ...)  
[17:39:25.279]  $ future.call.arguments    : list()
[17:39:25.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.279]  $ ...future.elements_ii    :List of 3
[17:39:25.279]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.279]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.279]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.279]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.279]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.279]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.279]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.279]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.279]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.279]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.279]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.279]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.279]  $ ...future.seeds_ii       : NULL
[17:39:25.279]  $ ...future.globals.maxSize: NULL
[17:39:25.279]  - attr(*, "resolved")= logi FALSE
[17:39:25.279]  - attr(*, "total_size")= num 1240
[17:39:25.279]  - attr(*, "where")=List of 5
[17:39:25.279]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.279]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.279]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.279]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.279]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.279]  - attr(*, "already-done")= logi TRUE
[17:39:25.289] - copied ‘...future.FUN’ to environment
[17:39:25.289] - copied ‘future.call.arguments’ to environment
[17:39:25.289] - copied ‘...future.elements_ii’ to environment
[17:39:25.289] - copied ‘...future.seeds_ii’ to environment
[17:39:25.289] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.289] assign_globals() ... done
[17:39:25.289] plan(): Setting new future strategy stack:
[17:39:25.290] List of future strategies:
[17:39:25.290] 1. sequential:
[17:39:25.290]    - args: function (..., envir = parent.frame())
[17:39:25.290]    - tweaked: FALSE
[17:39:25.290]    - call: NULL
[17:39:25.290] plan(): nbrOfWorkers() = 1
[17:39:25.292] plan(): Setting new future strategy stack:
[17:39:25.292] List of future strategies:
[17:39:25.292] 1. multicore:
[17:39:25.292]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:25.292]    - tweaked: FALSE
[17:39:25.292]    - call: plan(strategy)
[17:39:25.296] plan(): nbrOfWorkers() = 1
[17:39:25.296] SequentialFuture started (and completed)
[17:39:25.296] - Launch lazy future ... done
[17:39:25.296] run() for ‘SequentialFuture’ ... done
[17:39:25.296] Created future:
[17:39:25.296] SequentialFuture:
[17:39:25.296] Label: ‘future_by-1’
[17:39:25.296] Expression:
[17:39:25.296] {
[17:39:25.296]     do.call(function(...) {
[17:39:25.296]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.296]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.296]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.296]             on.exit(options(oopts), add = TRUE)
[17:39:25.296]         }
[17:39:25.296]         {
[17:39:25.296]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.296]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.296]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.296]             })
[17:39:25.296]         }
[17:39:25.296]     }, args = future.call.arguments)
[17:39:25.296] }
[17:39:25.296] Lazy evaluation: FALSE
[17:39:25.296] Asynchronous evaluation: FALSE
[17:39:25.296] Local evaluation: TRUE
[17:39:25.296] Environment: 0x562970f4cc98
[17:39:25.296] Capture standard output: TRUE
[17:39:25.296] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.296] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.296] Packages: <none>
[17:39:25.296] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.296] Resolved: TRUE
[17:39:25.296] Value: 5.37 KiB of class ‘list’
[17:39:25.296] Early signaling: FALSE
[17:39:25.296] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.296] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.298] Chunk #1 of 1 ... DONE
[17:39:25.298] Launching 1 futures (chunks) ... DONE
[17:39:25.298] Resolving 1 futures (chunks) ...
[17:39:25.298] resolve() on list ...
[17:39:25.298]  recursive: 0
[17:39:25.298]  length: 1
[17:39:25.298] 
[17:39:25.298] resolved() for ‘SequentialFuture’ ...
[17:39:25.299] - state: ‘finished’
[17:39:25.299] - run: TRUE
[17:39:25.299] - result: ‘FutureResult’
[17:39:25.299] resolved() for ‘SequentialFuture’ ... done
[17:39:25.299] Future #1
[17:39:25.299] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.299] - nx: 1
[17:39:25.299] - relay: TRUE
[17:39:25.299] - stdout: TRUE
[17:39:25.299] - signal: TRUE
[17:39:25.300] - resignal: FALSE
[17:39:25.300] - force: TRUE
[17:39:25.300] - relayed: [n=1] FALSE
[17:39:25.300] - queued futures: [n=1] FALSE
[17:39:25.300]  - until=1
[17:39:25.300]  - relaying element #1
[17:39:25.300] - relayed: [n=1] TRUE
[17:39:25.300] - queued futures: [n=1] TRUE
[17:39:25.300] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.300]  length: 0 (resolved future 1)
[17:39:25.301] Relaying remaining futures
[17:39:25.301] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.301] - nx: 1
[17:39:25.301] - relay: TRUE
[17:39:25.301] - stdout: TRUE
[17:39:25.301] - signal: TRUE
[17:39:25.301] - resignal: FALSE
[17:39:25.301] - force: TRUE
[17:39:25.301] - relayed: [n=1] TRUE
[17:39:25.301] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.301] - relayed: [n=1] TRUE
[17:39:25.302] - queued futures: [n=1] TRUE
[17:39:25.302] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.302] resolve() on list ... DONE
[17:39:25.302]  - Number of value chunks collected: 1
[17:39:25.302] Resolving 1 futures (chunks) ... DONE
[17:39:25.302] Reducing values from 1 chunks ...
[17:39:25.302]  - Number of values collected after concatenation: 3
[17:39:25.302]  - Number of values expected: 3
[17:39:25.302] Reducing values from 1 chunks ... DONE
[17:39:25.302] future_lapply() ... DONE
[17:39:25.303] future_by_internal() ... DONE
[17:39:25.303] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:39:25.304] future_lapply() ...
[17:39:25.309] Number of chunks: 1
[17:39:25.309] getGlobalsAndPackagesXApply() ...
[17:39:25.309]  - future.globals: TRUE
[17:39:25.309] getGlobalsAndPackages() ...
[17:39:25.310] Searching for globals...
[17:39:25.311] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.311] Searching for globals ... DONE
[17:39:25.311] Resolving globals: FALSE
[17:39:25.311] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.312] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.312] - globals: [1] ‘FUN’
[17:39:25.312] 
[17:39:25.312] getGlobalsAndPackages() ... DONE
[17:39:25.312]  - globals found/used: [n=1] ‘FUN’
[17:39:25.312]  - needed namespaces: [n=0] 
[17:39:25.312] Finding globals ... DONE
[17:39:25.312]  - use_args: TRUE
[17:39:25.312]  - Getting '...' globals ...
[17:39:25.313] resolve() on list ...
[17:39:25.313]  recursive: 0
[17:39:25.313]  length: 1
[17:39:25.313]  elements: ‘...’
[17:39:25.313]  length: 0 (resolved future 1)
[17:39:25.313] resolve() on list ... DONE
[17:39:25.313]    - '...' content: [n=0] 
[17:39:25.313] List of 1
[17:39:25.313]  $ ...: list()
[17:39:25.313]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.313]  - attr(*, "where")=List of 1
[17:39:25.313]   ..$ ...:<environment: 0x562971152ba8> 
[17:39:25.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.313]  - attr(*, "resolved")= logi TRUE
[17:39:25.313]  - attr(*, "total_size")= num NA
[17:39:25.316]  - Getting '...' globals ... DONE
[17:39:25.316] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.316] List of 2
[17:39:25.316]  $ ...future.FUN:function (object, ...)  
[17:39:25.316]  $ ...          : list()
[17:39:25.316]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.316]  - attr(*, "where")=List of 2
[17:39:25.316]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.316]   ..$ ...          :<environment: 0x562971152ba8> 
[17:39:25.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.316]  - attr(*, "resolved")= logi FALSE
[17:39:25.316]  - attr(*, "total_size")= num 1240
[17:39:25.319] Packages to be attached in all futures: [n=0] 
[17:39:25.319] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.319] Number of futures (= number of chunks): 1
[17:39:25.320] Launching 1 futures (chunks) ...
[17:39:25.320] Chunk #1 of 1 ...
[17:39:25.320]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.320] getGlobalsAndPackages() ...
[17:39:25.320] Searching for globals...
[17:39:25.320] 
[17:39:25.320] Searching for globals ... DONE
[17:39:25.321] - globals: [0] <none>
[17:39:25.321] getGlobalsAndPackages() ... DONE
[17:39:25.321]    + additional globals found: [n=0] 
[17:39:25.321]    + additional namespaces needed: [n=0] 
[17:39:25.321]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.321]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.321]  - seeds: <none>
[17:39:25.321] getGlobalsAndPackages() ...
[17:39:25.321] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.322] Resolving globals: FALSE
[17:39:25.322] Tweak future expression to call with '...' arguments ...
[17:39:25.322] {
[17:39:25.322]     do.call(function(...) {
[17:39:25.322]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.322]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.322]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.322]             on.exit(options(oopts), add = TRUE)
[17:39:25.322]         }
[17:39:25.322]         {
[17:39:25.322]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.322]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.322]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.322]             })
[17:39:25.322]         }
[17:39:25.322]     }, args = future.call.arguments)
[17:39:25.322] }
[17:39:25.322] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.322] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.322] 
[17:39:25.323] getGlobalsAndPackages() ... DONE
[17:39:25.323] run() for ‘Future’ ...
[17:39:25.323] - state: ‘created’
[17:39:25.323] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.327] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.327] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.327]   - Field: ‘label’
[17:39:25.327]   - Field: ‘local’
[17:39:25.327]   - Field: ‘owner’
[17:39:25.327]   - Field: ‘envir’
[17:39:25.328]   - Field: ‘packages’
[17:39:25.328]   - Field: ‘gc’
[17:39:25.328]   - Field: ‘conditions’
[17:39:25.328]   - Field: ‘expr’
[17:39:25.328]   - Field: ‘uuid’
[17:39:25.328]   - Field: ‘seed’
[17:39:25.328]   - Field: ‘version’
[17:39:25.328]   - Field: ‘result’
[17:39:25.328]   - Field: ‘asynchronous’
[17:39:25.328]   - Field: ‘calls’
[17:39:25.329]   - Field: ‘globals’
[17:39:25.329]   - Field: ‘stdout’
[17:39:25.329]   - Field: ‘earlySignal’
[17:39:25.329]   - Field: ‘lazy’
[17:39:25.329]   - Field: ‘state’
[17:39:25.329] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.329] - Launch lazy future ...
[17:39:25.329] Packages needed by the future expression (n = 0): <none>
[17:39:25.329] Packages needed by future strategies (n = 0): <none>
[17:39:25.330] {
[17:39:25.330]     {
[17:39:25.330]         {
[17:39:25.330]             ...future.startTime <- base::Sys.time()
[17:39:25.330]             {
[17:39:25.330]                 {
[17:39:25.330]                   {
[17:39:25.330]                     base::local({
[17:39:25.330]                       has_future <- base::requireNamespace("future", 
[17:39:25.330]                         quietly = TRUE)
[17:39:25.330]                       if (has_future) {
[17:39:25.330]                         ns <- base::getNamespace("future")
[17:39:25.330]                         version <- ns[[".package"]][["version"]]
[17:39:25.330]                         if (is.null(version)) 
[17:39:25.330]                           version <- utils::packageVersion("future")
[17:39:25.330]                       }
[17:39:25.330]                       else {
[17:39:25.330]                         version <- NULL
[17:39:25.330]                       }
[17:39:25.330]                       if (!has_future || version < "1.8.0") {
[17:39:25.330]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.330]                           "", base::R.version$version.string), 
[17:39:25.330]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.330]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.330]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.330]                             "release", "version")], collapse = " "), 
[17:39:25.330]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.330]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.330]                           info)
[17:39:25.330]                         info <- base::paste(info, collapse = "; ")
[17:39:25.330]                         if (!has_future) {
[17:39:25.330]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.330]                             info)
[17:39:25.330]                         }
[17:39:25.330]                         else {
[17:39:25.330]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.330]                             info, version)
[17:39:25.330]                         }
[17:39:25.330]                         base::stop(msg)
[17:39:25.330]                       }
[17:39:25.330]                     })
[17:39:25.330]                   }
[17:39:25.330]                   options(future.plan = NULL)
[17:39:25.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.330]                 }
[17:39:25.330]                 ...future.workdir <- getwd()
[17:39:25.330]             }
[17:39:25.330]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.330]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.330]         }
[17:39:25.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.330]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.330]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.330]             base::names(...future.oldOptions))
[17:39:25.330]     }
[17:39:25.330]     if (FALSE) {
[17:39:25.330]     }
[17:39:25.330]     else {
[17:39:25.330]         if (TRUE) {
[17:39:25.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.330]                 open = "w")
[17:39:25.330]         }
[17:39:25.330]         else {
[17:39:25.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.330]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.330]         }
[17:39:25.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.330]             base::sink(type = "output", split = FALSE)
[17:39:25.330]             base::close(...future.stdout)
[17:39:25.330]         }, add = TRUE)
[17:39:25.330]     }
[17:39:25.330]     ...future.frame <- base::sys.nframe()
[17:39:25.330]     ...future.conditions <- base::list()
[17:39:25.330]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.330]     if (FALSE) {
[17:39:25.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.330]     }
[17:39:25.330]     ...future.result <- base::tryCatch({
[17:39:25.330]         base::withCallingHandlers({
[17:39:25.330]             ...future.value <- base::withVisible(base::local({
[17:39:25.330]                 do.call(function(...) {
[17:39:25.330]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.330]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.330]                     ...future.globals.maxSize)) {
[17:39:25.330]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.330]                     on.exit(options(oopts), add = TRUE)
[17:39:25.330]                   }
[17:39:25.330]                   {
[17:39:25.330]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.330]                       FUN = function(jj) {
[17:39:25.330]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.330]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.330]                       })
[17:39:25.330]                   }
[17:39:25.330]                 }, args = future.call.arguments)
[17:39:25.330]             }))
[17:39:25.330]             future::FutureResult(value = ...future.value$value, 
[17:39:25.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.330]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.330]                     ...future.globalenv.names))
[17:39:25.330]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.330]         }, condition = base::local({
[17:39:25.330]             c <- base::c
[17:39:25.330]             inherits <- base::inherits
[17:39:25.330]             invokeRestart <- base::invokeRestart
[17:39:25.330]             length <- base::length
[17:39:25.330]             list <- base::list
[17:39:25.330]             seq.int <- base::seq.int
[17:39:25.330]             signalCondition <- base::signalCondition
[17:39:25.330]             sys.calls <- base::sys.calls
[17:39:25.330]             `[[` <- base::`[[`
[17:39:25.330]             `+` <- base::`+`
[17:39:25.330]             `<<-` <- base::`<<-`
[17:39:25.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.330]                   3L)]
[17:39:25.330]             }
[17:39:25.330]             function(cond) {
[17:39:25.330]                 is_error <- inherits(cond, "error")
[17:39:25.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.330]                   NULL)
[17:39:25.330]                 if (is_error) {
[17:39:25.330]                   sessionInformation <- function() {
[17:39:25.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.330]                       search = base::search(), system = base::Sys.info())
[17:39:25.330]                   }
[17:39:25.330]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.330]                     cond$call), session = sessionInformation(), 
[17:39:25.330]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.330]                   signalCondition(cond)
[17:39:25.330]                 }
[17:39:25.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.330]                 "immediateCondition"))) {
[17:39:25.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.330]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.330]                   if (TRUE && !signal) {
[17:39:25.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.330]                     {
[17:39:25.330]                       inherits <- base::inherits
[17:39:25.330]                       invokeRestart <- base::invokeRestart
[17:39:25.330]                       is.null <- base::is.null
[17:39:25.330]                       muffled <- FALSE
[17:39:25.330]                       if (inherits(cond, "message")) {
[17:39:25.330]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.330]                         if (muffled) 
[17:39:25.330]                           invokeRestart("muffleMessage")
[17:39:25.330]                       }
[17:39:25.330]                       else if (inherits(cond, "warning")) {
[17:39:25.330]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.330]                         if (muffled) 
[17:39:25.330]                           invokeRestart("muffleWarning")
[17:39:25.330]                       }
[17:39:25.330]                       else if (inherits(cond, "condition")) {
[17:39:25.330]                         if (!is.null(pattern)) {
[17:39:25.330]                           computeRestarts <- base::computeRestarts
[17:39:25.330]                           grepl <- base::grepl
[17:39:25.330]                           restarts <- computeRestarts(cond)
[17:39:25.330]                           for (restart in restarts) {
[17:39:25.330]                             name <- restart$name
[17:39:25.330]                             if (is.null(name)) 
[17:39:25.330]                               next
[17:39:25.330]                             if (!grepl(pattern, name)) 
[17:39:25.330]                               next
[17:39:25.330]                             invokeRestart(restart)
[17:39:25.330]                             muffled <- TRUE
[17:39:25.330]                             break
[17:39:25.330]                           }
[17:39:25.330]                         }
[17:39:25.330]                       }
[17:39:25.330]                       invisible(muffled)
[17:39:25.330]                     }
[17:39:25.330]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.330]                   }
[17:39:25.330]                 }
[17:39:25.330]                 else {
[17:39:25.330]                   if (TRUE) {
[17:39:25.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.330]                     {
[17:39:25.330]                       inherits <- base::inherits
[17:39:25.330]                       invokeRestart <- base::invokeRestart
[17:39:25.330]                       is.null <- base::is.null
[17:39:25.330]                       muffled <- FALSE
[17:39:25.330]                       if (inherits(cond, "message")) {
[17:39:25.330]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.330]                         if (muffled) 
[17:39:25.330]                           invokeRestart("muffleMessage")
[17:39:25.330]                       }
[17:39:25.330]                       else if (inherits(cond, "warning")) {
[17:39:25.330]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.330]                         if (muffled) 
[17:39:25.330]                           invokeRestart("muffleWarning")
[17:39:25.330]                       }
[17:39:25.330]                       else if (inherits(cond, "condition")) {
[17:39:25.330]                         if (!is.null(pattern)) {
[17:39:25.330]                           computeRestarts <- base::computeRestarts
[17:39:25.330]                           grepl <- base::grepl
[17:39:25.330]                           restarts <- computeRestarts(cond)
[17:39:25.330]                           for (restart in restarts) {
[17:39:25.330]                             name <- restart$name
[17:39:25.330]                             if (is.null(name)) 
[17:39:25.330]                               next
[17:39:25.330]                             if (!grepl(pattern, name)) 
[17:39:25.330]                               next
[17:39:25.330]                             invokeRestart(restart)
[17:39:25.330]                             muffled <- TRUE
[17:39:25.330]                             break
[17:39:25.330]                           }
[17:39:25.330]                         }
[17:39:25.330]                       }
[17:39:25.330]                       invisible(muffled)
[17:39:25.330]                     }
[17:39:25.330]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.330]                   }
[17:39:25.330]                 }
[17:39:25.330]             }
[17:39:25.330]         }))
[17:39:25.330]     }, error = function(ex) {
[17:39:25.330]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.330]                 ...future.rng), started = ...future.startTime, 
[17:39:25.330]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.330]             version = "1.8"), class = "FutureResult")
[17:39:25.330]     }, finally = {
[17:39:25.330]         if (!identical(...future.workdir, getwd())) 
[17:39:25.330]             setwd(...future.workdir)
[17:39:25.330]         {
[17:39:25.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.330]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.330]             }
[17:39:25.330]             base::options(...future.oldOptions)
[17:39:25.330]             if (.Platform$OS.type == "windows") {
[17:39:25.330]                 old_names <- names(...future.oldEnvVars)
[17:39:25.330]                 envs <- base::Sys.getenv()
[17:39:25.330]                 names <- names(envs)
[17:39:25.330]                 common <- intersect(names, old_names)
[17:39:25.330]                 added <- setdiff(names, old_names)
[17:39:25.330]                 removed <- setdiff(old_names, names)
[17:39:25.330]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.330]                   envs[common]]
[17:39:25.330]                 NAMES <- toupper(changed)
[17:39:25.330]                 args <- list()
[17:39:25.330]                 for (kk in seq_along(NAMES)) {
[17:39:25.330]                   name <- changed[[kk]]
[17:39:25.330]                   NAME <- NAMES[[kk]]
[17:39:25.330]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.330]                     next
[17:39:25.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.330]                 }
[17:39:25.330]                 NAMES <- toupper(added)
[17:39:25.330]                 for (kk in seq_along(NAMES)) {
[17:39:25.330]                   name <- added[[kk]]
[17:39:25.330]                   NAME <- NAMES[[kk]]
[17:39:25.330]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.330]                     next
[17:39:25.330]                   args[[name]] <- ""
[17:39:25.330]                 }
[17:39:25.330]                 NAMES <- toupper(removed)
[17:39:25.330]                 for (kk in seq_along(NAMES)) {
[17:39:25.330]                   name <- removed[[kk]]
[17:39:25.330]                   NAME <- NAMES[[kk]]
[17:39:25.330]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.330]                     next
[17:39:25.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.330]                 }
[17:39:25.330]                 if (length(args) > 0) 
[17:39:25.330]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.330]             }
[17:39:25.330]             else {
[17:39:25.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.330]             }
[17:39:25.330]             {
[17:39:25.330]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.330]                   0L) {
[17:39:25.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.330]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.330]                   base::options(opts)
[17:39:25.330]                 }
[17:39:25.330]                 {
[17:39:25.330]                   {
[17:39:25.330]                     NULL
[17:39:25.330]                     RNGkind("Mersenne-Twister")
[17:39:25.330]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.330]                       inherits = FALSE)
[17:39:25.330]                   }
[17:39:25.330]                   options(future.plan = NULL)
[17:39:25.330]                   if (is.na(NA_character_)) 
[17:39:25.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.330]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:25.330]                     envir = parent.frame()) 
[17:39:25.330]                   {
[17:39:25.330]                     default_workers <- missing(workers)
[17:39:25.330]                     if (is.function(workers)) 
[17:39:25.330]                       workers <- workers()
[17:39:25.330]                     workers <- structure(as.integer(workers), 
[17:39:25.330]                       class = class(workers))
[17:39:25.330]                     stop_if_not(is.finite(workers), workers >= 
[17:39:25.330]                       1L)
[17:39:25.330]                     if ((workers == 1L && !inherits(workers, 
[17:39:25.330]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:25.330]                       if (default_workers) 
[17:39:25.330]                         supportsMulticore(warn = TRUE)
[17:39:25.330]                       return(sequential(..., envir = envir))
[17:39:25.330]                     }
[17:39:25.330]                     oopts <- options(mc.cores = workers)
[17:39:25.330]                     on.exit(options(oopts))
[17:39:25.330]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:25.330]                       envir = envir)
[17:39:25.330]                     if (!future$lazy) 
[17:39:25.330]                       future <- run(future)
[17:39:25.330]                     invisible(future)
[17:39:25.330]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.330]                 }
[17:39:25.330]             }
[17:39:25.330]         }
[17:39:25.330]     })
[17:39:25.330]     if (TRUE) {
[17:39:25.330]         base::sink(type = "output", split = FALSE)
[17:39:25.330]         if (TRUE) {
[17:39:25.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.330]         }
[17:39:25.330]         else {
[17:39:25.330]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.330]         }
[17:39:25.330]         base::close(...future.stdout)
[17:39:25.330]         ...future.stdout <- NULL
[17:39:25.330]     }
[17:39:25.330]     ...future.result$conditions <- ...future.conditions
[17:39:25.330]     ...future.result$finished <- base::Sys.time()
[17:39:25.330]     ...future.result
[17:39:25.330] }
[17:39:25.332] assign_globals() ...
[17:39:25.332] List of 5
[17:39:25.332]  $ ...future.FUN            :function (object, ...)  
[17:39:25.332]  $ future.call.arguments    : list()
[17:39:25.332]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.332]  $ ...future.elements_ii    :List of 3
[17:39:25.332]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.332]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.332]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.332]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.332]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.332]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.332]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.332]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.332]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.332]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.332]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.332]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.332]  $ ...future.seeds_ii       : NULL
[17:39:25.332]  $ ...future.globals.maxSize: NULL
[17:39:25.332]  - attr(*, "resolved")= logi FALSE
[17:39:25.332]  - attr(*, "total_size")= num 1240
[17:39:25.332]  - attr(*, "where")=List of 5
[17:39:25.332]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.332]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.332]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.332]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.332]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.332]  - attr(*, "already-done")= logi TRUE
[17:39:25.343] - copied ‘...future.FUN’ to environment
[17:39:25.343] - copied ‘future.call.arguments’ to environment
[17:39:25.343] - copied ‘...future.elements_ii’ to environment
[17:39:25.343] - copied ‘...future.seeds_ii’ to environment
[17:39:25.343] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.343] assign_globals() ... done
[17:39:25.344] plan(): Setting new future strategy stack:
[17:39:25.344] List of future strategies:
[17:39:25.344] 1. sequential:
[17:39:25.344]    - args: function (..., envir = parent.frame())
[17:39:25.344]    - tweaked: FALSE
[17:39:25.344]    - call: NULL
[17:39:25.344] plan(): nbrOfWorkers() = 1
[17:39:25.346] plan(): Setting new future strategy stack:
[17:39:25.346] List of future strategies:
[17:39:25.346] 1. multicore:
[17:39:25.346]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:25.346]    - tweaked: FALSE
[17:39:25.346]    - call: plan(strategy)
[17:39:25.350] plan(): nbrOfWorkers() = 1
[17:39:25.350] SequentialFuture started (and completed)
[17:39:25.350] - Launch lazy future ... done
[17:39:25.350] run() for ‘SequentialFuture’ ... done
[17:39:25.350] Created future:
[17:39:25.351] SequentialFuture:
[17:39:25.351] Label: ‘future_by-1’
[17:39:25.351] Expression:
[17:39:25.351] {
[17:39:25.351]     do.call(function(...) {
[17:39:25.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.351]             on.exit(options(oopts), add = TRUE)
[17:39:25.351]         }
[17:39:25.351]         {
[17:39:25.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.351]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.351]             })
[17:39:25.351]         }
[17:39:25.351]     }, args = future.call.arguments)
[17:39:25.351] }
[17:39:25.351] Lazy evaluation: FALSE
[17:39:25.351] Asynchronous evaluation: FALSE
[17:39:25.351] Local evaluation: TRUE
[17:39:25.351] Environment: 0x5629710ec498
[17:39:25.351] Capture standard output: TRUE
[17:39:25.351] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.351] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.351] Packages: <none>
[17:39:25.351] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.351] Resolved: TRUE
[17:39:25.351] Value: 5.37 KiB of class ‘list’
[17:39:25.351] Early signaling: FALSE
[17:39:25.351] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.351] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.352] Chunk #1 of 1 ... DONE
[17:39:25.352] Launching 1 futures (chunks) ... DONE
[17:39:25.352] Resolving 1 futures (chunks) ...
[17:39:25.352] resolve() on list ...
[17:39:25.352]  recursive: 0
[17:39:25.352]  length: 1
[17:39:25.353] 
[17:39:25.353] resolved() for ‘SequentialFuture’ ...
[17:39:25.353] - state: ‘finished’
[17:39:25.353] - run: TRUE
[17:39:25.353] - result: ‘FutureResult’
[17:39:25.353] resolved() for ‘SequentialFuture’ ... done
[17:39:25.353] Future #1
[17:39:25.353] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.353] - nx: 1
[17:39:25.354] - relay: TRUE
[17:39:25.354] - stdout: TRUE
[17:39:25.354] - signal: TRUE
[17:39:25.354] - resignal: FALSE
[17:39:25.354] - force: TRUE
[17:39:25.354] - relayed: [n=1] FALSE
[17:39:25.354] - queued futures: [n=1] FALSE
[17:39:25.354]  - until=1
[17:39:25.354]  - relaying element #1
[17:39:25.354] - relayed: [n=1] TRUE
[17:39:25.355] - queued futures: [n=1] TRUE
[17:39:25.355] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.355]  length: 0 (resolved future 1)
[17:39:25.355] Relaying remaining futures
[17:39:25.355] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.355] - nx: 1
[17:39:25.355] - relay: TRUE
[17:39:25.355] - stdout: TRUE
[17:39:25.355] - signal: TRUE
[17:39:25.355] - resignal: FALSE
[17:39:25.355] - force: TRUE
[17:39:25.356] - relayed: [n=1] TRUE
[17:39:25.356] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.356] - relayed: [n=1] TRUE
[17:39:25.356] - queued futures: [n=1] TRUE
[17:39:25.356] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.356] resolve() on list ... DONE
[17:39:25.356]  - Number of value chunks collected: 1
[17:39:25.356] Resolving 1 futures (chunks) ... DONE
[17:39:25.356] Reducing values from 1 chunks ...
[17:39:25.356]  - Number of values collected after concatenation: 3
[17:39:25.357]  - Number of values expected: 3
[17:39:25.358] Reducing values from 1 chunks ... DONE
[17:39:25.358] future_lapply() ... DONE
[17:39:25.358] future_by_internal() ... DONE
[17:39:25.359] future_by_internal() ...
- plan('multisession') ...
[17:39:25.360] plan(): Setting new future strategy stack:
[17:39:25.360] List of future strategies:
[17:39:25.360] 1. multisession:
[17:39:25.360]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:25.360]    - tweaked: FALSE
[17:39:25.360]    - call: plan(strategy)
[17:39:25.361] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:25.361] multisession:
[17:39:25.361] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:25.361] - tweaked: FALSE
[17:39:25.361] - call: plan(strategy)
[17:39:25.364] getGlobalsAndPackages() ...
[17:39:25.364] Not searching for globals
[17:39:25.365] - globals: [0] <none>
[17:39:25.365] getGlobalsAndPackages() ... DONE
[17:39:25.365] Packages needed by the future expression (n = 0): <none>
[17:39:25.365] Packages needed by future strategies (n = 0): <none>
[17:39:25.365] {
[17:39:25.365]     {
[17:39:25.365]         {
[17:39:25.365]             ...future.startTime <- base::Sys.time()
[17:39:25.365]             {
[17:39:25.365]                 {
[17:39:25.365]                   {
[17:39:25.365]                     base::local({
[17:39:25.365]                       has_future <- base::requireNamespace("future", 
[17:39:25.365]                         quietly = TRUE)
[17:39:25.365]                       if (has_future) {
[17:39:25.365]                         ns <- base::getNamespace("future")
[17:39:25.365]                         version <- ns[[".package"]][["version"]]
[17:39:25.365]                         if (is.null(version)) 
[17:39:25.365]                           version <- utils::packageVersion("future")
[17:39:25.365]                       }
[17:39:25.365]                       else {
[17:39:25.365]                         version <- NULL
[17:39:25.365]                       }
[17:39:25.365]                       if (!has_future || version < "1.8.0") {
[17:39:25.365]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.365]                           "", base::R.version$version.string), 
[17:39:25.365]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.365]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.365]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.365]                             "release", "version")], collapse = " "), 
[17:39:25.365]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.365]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.365]                           info)
[17:39:25.365]                         info <- base::paste(info, collapse = "; ")
[17:39:25.365]                         if (!has_future) {
[17:39:25.365]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.365]                             info)
[17:39:25.365]                         }
[17:39:25.365]                         else {
[17:39:25.365]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.365]                             info, version)
[17:39:25.365]                         }
[17:39:25.365]                         base::stop(msg)
[17:39:25.365]                       }
[17:39:25.365]                     })
[17:39:25.365]                   }
[17:39:25.365]                   options(future.plan = NULL)
[17:39:25.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.365]                 }
[17:39:25.365]                 ...future.workdir <- getwd()
[17:39:25.365]             }
[17:39:25.365]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.365]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.365]         }
[17:39:25.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:25.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.365]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.365]             base::names(...future.oldOptions))
[17:39:25.365]     }
[17:39:25.365]     if (FALSE) {
[17:39:25.365]     }
[17:39:25.365]     else {
[17:39:25.365]         if (TRUE) {
[17:39:25.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.365]                 open = "w")
[17:39:25.365]         }
[17:39:25.365]         else {
[17:39:25.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.365]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.365]         }
[17:39:25.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.365]             base::sink(type = "output", split = FALSE)
[17:39:25.365]             base::close(...future.stdout)
[17:39:25.365]         }, add = TRUE)
[17:39:25.365]     }
[17:39:25.365]     ...future.frame <- base::sys.nframe()
[17:39:25.365]     ...future.conditions <- base::list()
[17:39:25.365]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.365]     if (FALSE) {
[17:39:25.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.365]     }
[17:39:25.365]     ...future.result <- base::tryCatch({
[17:39:25.365]         base::withCallingHandlers({
[17:39:25.365]             ...future.value <- base::withVisible(base::local(NA))
[17:39:25.365]             future::FutureResult(value = ...future.value$value, 
[17:39:25.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.365]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.365]                     ...future.globalenv.names))
[17:39:25.365]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.365]         }, condition = base::local({
[17:39:25.365]             c <- base::c
[17:39:25.365]             inherits <- base::inherits
[17:39:25.365]             invokeRestart <- base::invokeRestart
[17:39:25.365]             length <- base::length
[17:39:25.365]             list <- base::list
[17:39:25.365]             seq.int <- base::seq.int
[17:39:25.365]             signalCondition <- base::signalCondition
[17:39:25.365]             sys.calls <- base::sys.calls
[17:39:25.365]             `[[` <- base::`[[`
[17:39:25.365]             `+` <- base::`+`
[17:39:25.365]             `<<-` <- base::`<<-`
[17:39:25.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.365]                   3L)]
[17:39:25.365]             }
[17:39:25.365]             function(cond) {
[17:39:25.365]                 is_error <- inherits(cond, "error")
[17:39:25.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.365]                   NULL)
[17:39:25.365]                 if (is_error) {
[17:39:25.365]                   sessionInformation <- function() {
[17:39:25.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.365]                       search = base::search(), system = base::Sys.info())
[17:39:25.365]                   }
[17:39:25.365]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.365]                     cond$call), session = sessionInformation(), 
[17:39:25.365]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.365]                   signalCondition(cond)
[17:39:25.365]                 }
[17:39:25.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.365]                 "immediateCondition"))) {
[17:39:25.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.365]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.365]                   if (TRUE && !signal) {
[17:39:25.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.365]                     {
[17:39:25.365]                       inherits <- base::inherits
[17:39:25.365]                       invokeRestart <- base::invokeRestart
[17:39:25.365]                       is.null <- base::is.null
[17:39:25.365]                       muffled <- FALSE
[17:39:25.365]                       if (inherits(cond, "message")) {
[17:39:25.365]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.365]                         if (muffled) 
[17:39:25.365]                           invokeRestart("muffleMessage")
[17:39:25.365]                       }
[17:39:25.365]                       else if (inherits(cond, "warning")) {
[17:39:25.365]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.365]                         if (muffled) 
[17:39:25.365]                           invokeRestart("muffleWarning")
[17:39:25.365]                       }
[17:39:25.365]                       else if (inherits(cond, "condition")) {
[17:39:25.365]                         if (!is.null(pattern)) {
[17:39:25.365]                           computeRestarts <- base::computeRestarts
[17:39:25.365]                           grepl <- base::grepl
[17:39:25.365]                           restarts <- computeRestarts(cond)
[17:39:25.365]                           for (restart in restarts) {
[17:39:25.365]                             name <- restart$name
[17:39:25.365]                             if (is.null(name)) 
[17:39:25.365]                               next
[17:39:25.365]                             if (!grepl(pattern, name)) 
[17:39:25.365]                               next
[17:39:25.365]                             invokeRestart(restart)
[17:39:25.365]                             muffled <- TRUE
[17:39:25.365]                             break
[17:39:25.365]                           }
[17:39:25.365]                         }
[17:39:25.365]                       }
[17:39:25.365]                       invisible(muffled)
[17:39:25.365]                     }
[17:39:25.365]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.365]                   }
[17:39:25.365]                 }
[17:39:25.365]                 else {
[17:39:25.365]                   if (TRUE) {
[17:39:25.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.365]                     {
[17:39:25.365]                       inherits <- base::inherits
[17:39:25.365]                       invokeRestart <- base::invokeRestart
[17:39:25.365]                       is.null <- base::is.null
[17:39:25.365]                       muffled <- FALSE
[17:39:25.365]                       if (inherits(cond, "message")) {
[17:39:25.365]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.365]                         if (muffled) 
[17:39:25.365]                           invokeRestart("muffleMessage")
[17:39:25.365]                       }
[17:39:25.365]                       else if (inherits(cond, "warning")) {
[17:39:25.365]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.365]                         if (muffled) 
[17:39:25.365]                           invokeRestart("muffleWarning")
[17:39:25.365]                       }
[17:39:25.365]                       else if (inherits(cond, "condition")) {
[17:39:25.365]                         if (!is.null(pattern)) {
[17:39:25.365]                           computeRestarts <- base::computeRestarts
[17:39:25.365]                           grepl <- base::grepl
[17:39:25.365]                           restarts <- computeRestarts(cond)
[17:39:25.365]                           for (restart in restarts) {
[17:39:25.365]                             name <- restart$name
[17:39:25.365]                             if (is.null(name)) 
[17:39:25.365]                               next
[17:39:25.365]                             if (!grepl(pattern, name)) 
[17:39:25.365]                               next
[17:39:25.365]                             invokeRestart(restart)
[17:39:25.365]                             muffled <- TRUE
[17:39:25.365]                             break
[17:39:25.365]                           }
[17:39:25.365]                         }
[17:39:25.365]                       }
[17:39:25.365]                       invisible(muffled)
[17:39:25.365]                     }
[17:39:25.365]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.365]                   }
[17:39:25.365]                 }
[17:39:25.365]             }
[17:39:25.365]         }))
[17:39:25.365]     }, error = function(ex) {
[17:39:25.365]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.365]                 ...future.rng), started = ...future.startTime, 
[17:39:25.365]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.365]             version = "1.8"), class = "FutureResult")
[17:39:25.365]     }, finally = {
[17:39:25.365]         if (!identical(...future.workdir, getwd())) 
[17:39:25.365]             setwd(...future.workdir)
[17:39:25.365]         {
[17:39:25.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.365]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.365]             }
[17:39:25.365]             base::options(...future.oldOptions)
[17:39:25.365]             if (.Platform$OS.type == "windows") {
[17:39:25.365]                 old_names <- names(...future.oldEnvVars)
[17:39:25.365]                 envs <- base::Sys.getenv()
[17:39:25.365]                 names <- names(envs)
[17:39:25.365]                 common <- intersect(names, old_names)
[17:39:25.365]                 added <- setdiff(names, old_names)
[17:39:25.365]                 removed <- setdiff(old_names, names)
[17:39:25.365]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.365]                   envs[common]]
[17:39:25.365]                 NAMES <- toupper(changed)
[17:39:25.365]                 args <- list()
[17:39:25.365]                 for (kk in seq_along(NAMES)) {
[17:39:25.365]                   name <- changed[[kk]]
[17:39:25.365]                   NAME <- NAMES[[kk]]
[17:39:25.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.365]                     next
[17:39:25.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.365]                 }
[17:39:25.365]                 NAMES <- toupper(added)
[17:39:25.365]                 for (kk in seq_along(NAMES)) {
[17:39:25.365]                   name <- added[[kk]]
[17:39:25.365]                   NAME <- NAMES[[kk]]
[17:39:25.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.365]                     next
[17:39:25.365]                   args[[name]] <- ""
[17:39:25.365]                 }
[17:39:25.365]                 NAMES <- toupper(removed)
[17:39:25.365]                 for (kk in seq_along(NAMES)) {
[17:39:25.365]                   name <- removed[[kk]]
[17:39:25.365]                   NAME <- NAMES[[kk]]
[17:39:25.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.365]                     next
[17:39:25.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.365]                 }
[17:39:25.365]                 if (length(args) > 0) 
[17:39:25.365]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.365]             }
[17:39:25.365]             else {
[17:39:25.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.365]             }
[17:39:25.365]             {
[17:39:25.365]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.365]                   0L) {
[17:39:25.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.365]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.365]                   base::options(opts)
[17:39:25.365]                 }
[17:39:25.365]                 {
[17:39:25.365]                   {
[17:39:25.365]                     NULL
[17:39:25.365]                     RNGkind("Mersenne-Twister")
[17:39:25.365]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.365]                       inherits = FALSE)
[17:39:25.365]                   }
[17:39:25.365]                   options(future.plan = NULL)
[17:39:25.365]                   if (is.na(NA_character_)) 
[17:39:25.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.365]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:25.365]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:25.365]                     envir = parent.frame()) 
[17:39:25.365]                   {
[17:39:25.365]                     if (is.function(workers)) 
[17:39:25.365]                       workers <- workers()
[17:39:25.365]                     workers <- structure(as.integer(workers), 
[17:39:25.365]                       class = class(workers))
[17:39:25.365]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:25.365]                       workers >= 1)
[17:39:25.365]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:25.365]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:25.365]                     }
[17:39:25.365]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:25.365]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:25.365]                       envir = envir)
[17:39:25.365]                     if (!future$lazy) 
[17:39:25.365]                       future <- run(future)
[17:39:25.365]                     invisible(future)
[17:39:25.365]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.365]                 }
[17:39:25.365]             }
[17:39:25.365]         }
[17:39:25.365]     })
[17:39:25.365]     if (TRUE) {
[17:39:25.365]         base::sink(type = "output", split = FALSE)
[17:39:25.365]         if (TRUE) {
[17:39:25.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.365]         }
[17:39:25.365]         else {
[17:39:25.365]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.365]         }
[17:39:25.365]         base::close(...future.stdout)
[17:39:25.365]         ...future.stdout <- NULL
[17:39:25.365]     }
[17:39:25.365]     ...future.result$conditions <- ...future.conditions
[17:39:25.365]     ...future.result$finished <- base::Sys.time()
[17:39:25.365]     ...future.result
[17:39:25.365] }
[17:39:25.367] plan(): Setting new future strategy stack:
[17:39:25.367] List of future strategies:
[17:39:25.367] 1. sequential:
[17:39:25.367]    - args: function (..., envir = parent.frame())
[17:39:25.367]    - tweaked: FALSE
[17:39:25.367]    - call: NULL
[17:39:25.368] plan(): nbrOfWorkers() = 1
[17:39:25.369] plan(): Setting new future strategy stack:
[17:39:25.369] List of future strategies:
[17:39:25.369] 1. multisession:
[17:39:25.369]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:25.369]    - tweaked: FALSE
[17:39:25.369]    - call: plan(strategy)
[17:39:25.372] plan(): nbrOfWorkers() = 1
[17:39:25.372] SequentialFuture started (and completed)
[17:39:25.373] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:25.375] plan(): nbrOfWorkers() = 1
[17:39:25.376] future_by_internal() ...
[17:39:25.376] future_lapply() ...
[17:39:25.379] Number of chunks: 1
[17:39:25.380] getGlobalsAndPackagesXApply() ...
[17:39:25.380]  - future.globals: TRUE
[17:39:25.380] getGlobalsAndPackages() ...
[17:39:25.380] Searching for globals...
[17:39:25.381] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.381] Searching for globals ... DONE
[17:39:25.381] Resolving globals: FALSE
[17:39:25.381] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.382] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.382] - globals: [1] ‘FUN’
[17:39:25.382] 
[17:39:25.382] getGlobalsAndPackages() ... DONE
[17:39:25.382]  - globals found/used: [n=1] ‘FUN’
[17:39:25.382]  - needed namespaces: [n=0] 
[17:39:25.382] Finding globals ... DONE
[17:39:25.382]  - use_args: TRUE
[17:39:25.383]  - Getting '...' globals ...
[17:39:25.383] resolve() on list ...
[17:39:25.383]  recursive: 0
[17:39:25.383]  length: 1
[17:39:25.383]  elements: ‘...’
[17:39:25.383]  length: 0 (resolved future 1)
[17:39:25.383] resolve() on list ... DONE
[17:39:25.383]    - '...' content: [n=0] 
[17:39:25.384] List of 1
[17:39:25.384]  $ ...: list()
[17:39:25.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.384]  - attr(*, "where")=List of 1
[17:39:25.384]   ..$ ...:<environment: 0x56296ea76048> 
[17:39:25.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.384]  - attr(*, "resolved")= logi TRUE
[17:39:25.384]  - attr(*, "total_size")= num NA
[17:39:25.386]  - Getting '...' globals ... DONE
[17:39:25.386] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.386] List of 2
[17:39:25.386]  $ ...future.FUN:function (object, ...)  
[17:39:25.386]  $ ...          : list()
[17:39:25.386]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.386]  - attr(*, "where")=List of 2
[17:39:25.386]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.386]   ..$ ...          :<environment: 0x56296ea76048> 
[17:39:25.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.386]  - attr(*, "resolved")= logi FALSE
[17:39:25.386]  - attr(*, "total_size")= num 1240
[17:39:25.391] Packages to be attached in all futures: [n=0] 
[17:39:25.391] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.391] Number of futures (= number of chunks): 1
[17:39:25.391] Launching 1 futures (chunks) ...
[17:39:25.391] Chunk #1 of 1 ...
[17:39:25.391]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.392] getGlobalsAndPackages() ...
[17:39:25.392] Searching for globals...
[17:39:25.392] 
[17:39:25.392] Searching for globals ... DONE
[17:39:25.392] - globals: [0] <none>
[17:39:25.392] getGlobalsAndPackages() ... DONE
[17:39:25.393]    + additional globals found: [n=0] 
[17:39:25.393]    + additional namespaces needed: [n=0] 
[17:39:25.393]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.393]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.393]  - seeds: <none>
[17:39:25.393] getGlobalsAndPackages() ...
[17:39:25.393] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.393] Resolving globals: FALSE
[17:39:25.393] Tweak future expression to call with '...' arguments ...
[17:39:25.393] {
[17:39:25.393]     do.call(function(...) {
[17:39:25.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.393]             on.exit(options(oopts), add = TRUE)
[17:39:25.393]         }
[17:39:25.393]         {
[17:39:25.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.393]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.393]             })
[17:39:25.393]         }
[17:39:25.393]     }, args = future.call.arguments)
[17:39:25.393] }
[17:39:25.394] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.394] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.394] 
[17:39:25.394] getGlobalsAndPackages() ... DONE
[17:39:25.395] run() for ‘Future’ ...
[17:39:25.395] - state: ‘created’
[17:39:25.395] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.398] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.398]   - Field: ‘label’
[17:39:25.398]   - Field: ‘local’
[17:39:25.399]   - Field: ‘owner’
[17:39:25.399]   - Field: ‘envir’
[17:39:25.399]   - Field: ‘packages’
[17:39:25.399]   - Field: ‘gc’
[17:39:25.399]   - Field: ‘conditions’
[17:39:25.399]   - Field: ‘expr’
[17:39:25.399]   - Field: ‘uuid’
[17:39:25.399]   - Field: ‘seed’
[17:39:25.399]   - Field: ‘version’
[17:39:25.399]   - Field: ‘result’
[17:39:25.400]   - Field: ‘asynchronous’
[17:39:25.400]   - Field: ‘calls’
[17:39:25.400]   - Field: ‘globals’
[17:39:25.400]   - Field: ‘stdout’
[17:39:25.400]   - Field: ‘earlySignal’
[17:39:25.400]   - Field: ‘lazy’
[17:39:25.400]   - Field: ‘state’
[17:39:25.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.400] - Launch lazy future ...
[17:39:25.401] Packages needed by the future expression (n = 0): <none>
[17:39:25.401] Packages needed by future strategies (n = 0): <none>
[17:39:25.401] {
[17:39:25.401]     {
[17:39:25.401]         {
[17:39:25.401]             ...future.startTime <- base::Sys.time()
[17:39:25.401]             {
[17:39:25.401]                 {
[17:39:25.401]                   {
[17:39:25.401]                     base::local({
[17:39:25.401]                       has_future <- base::requireNamespace("future", 
[17:39:25.401]                         quietly = TRUE)
[17:39:25.401]                       if (has_future) {
[17:39:25.401]                         ns <- base::getNamespace("future")
[17:39:25.401]                         version <- ns[[".package"]][["version"]]
[17:39:25.401]                         if (is.null(version)) 
[17:39:25.401]                           version <- utils::packageVersion("future")
[17:39:25.401]                       }
[17:39:25.401]                       else {
[17:39:25.401]                         version <- NULL
[17:39:25.401]                       }
[17:39:25.401]                       if (!has_future || version < "1.8.0") {
[17:39:25.401]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.401]                           "", base::R.version$version.string), 
[17:39:25.401]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.401]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.401]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.401]                             "release", "version")], collapse = " "), 
[17:39:25.401]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.401]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.401]                           info)
[17:39:25.401]                         info <- base::paste(info, collapse = "; ")
[17:39:25.401]                         if (!has_future) {
[17:39:25.401]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.401]                             info)
[17:39:25.401]                         }
[17:39:25.401]                         else {
[17:39:25.401]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.401]                             info, version)
[17:39:25.401]                         }
[17:39:25.401]                         base::stop(msg)
[17:39:25.401]                       }
[17:39:25.401]                     })
[17:39:25.401]                   }
[17:39:25.401]                   options(future.plan = NULL)
[17:39:25.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.401]                 }
[17:39:25.401]                 ...future.workdir <- getwd()
[17:39:25.401]             }
[17:39:25.401]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.401]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.401]         }
[17:39:25.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.401]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.401]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.401]             base::names(...future.oldOptions))
[17:39:25.401]     }
[17:39:25.401]     if (FALSE) {
[17:39:25.401]     }
[17:39:25.401]     else {
[17:39:25.401]         if (TRUE) {
[17:39:25.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.401]                 open = "w")
[17:39:25.401]         }
[17:39:25.401]         else {
[17:39:25.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.401]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.401]         }
[17:39:25.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.401]             base::sink(type = "output", split = FALSE)
[17:39:25.401]             base::close(...future.stdout)
[17:39:25.401]         }, add = TRUE)
[17:39:25.401]     }
[17:39:25.401]     ...future.frame <- base::sys.nframe()
[17:39:25.401]     ...future.conditions <- base::list()
[17:39:25.401]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.401]     if (FALSE) {
[17:39:25.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.401]     }
[17:39:25.401]     ...future.result <- base::tryCatch({
[17:39:25.401]         base::withCallingHandlers({
[17:39:25.401]             ...future.value <- base::withVisible(base::local({
[17:39:25.401]                 do.call(function(...) {
[17:39:25.401]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.401]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.401]                     ...future.globals.maxSize)) {
[17:39:25.401]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.401]                     on.exit(options(oopts), add = TRUE)
[17:39:25.401]                   }
[17:39:25.401]                   {
[17:39:25.401]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.401]                       FUN = function(jj) {
[17:39:25.401]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.401]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.401]                       })
[17:39:25.401]                   }
[17:39:25.401]                 }, args = future.call.arguments)
[17:39:25.401]             }))
[17:39:25.401]             future::FutureResult(value = ...future.value$value, 
[17:39:25.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.401]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.401]                     ...future.globalenv.names))
[17:39:25.401]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.401]         }, condition = base::local({
[17:39:25.401]             c <- base::c
[17:39:25.401]             inherits <- base::inherits
[17:39:25.401]             invokeRestart <- base::invokeRestart
[17:39:25.401]             length <- base::length
[17:39:25.401]             list <- base::list
[17:39:25.401]             seq.int <- base::seq.int
[17:39:25.401]             signalCondition <- base::signalCondition
[17:39:25.401]             sys.calls <- base::sys.calls
[17:39:25.401]             `[[` <- base::`[[`
[17:39:25.401]             `+` <- base::`+`
[17:39:25.401]             `<<-` <- base::`<<-`
[17:39:25.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.401]                   3L)]
[17:39:25.401]             }
[17:39:25.401]             function(cond) {
[17:39:25.401]                 is_error <- inherits(cond, "error")
[17:39:25.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.401]                   NULL)
[17:39:25.401]                 if (is_error) {
[17:39:25.401]                   sessionInformation <- function() {
[17:39:25.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.401]                       search = base::search(), system = base::Sys.info())
[17:39:25.401]                   }
[17:39:25.401]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.401]                     cond$call), session = sessionInformation(), 
[17:39:25.401]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.401]                   signalCondition(cond)
[17:39:25.401]                 }
[17:39:25.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.401]                 "immediateCondition"))) {
[17:39:25.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.401]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.401]                   if (TRUE && !signal) {
[17:39:25.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.401]                     {
[17:39:25.401]                       inherits <- base::inherits
[17:39:25.401]                       invokeRestart <- base::invokeRestart
[17:39:25.401]                       is.null <- base::is.null
[17:39:25.401]                       muffled <- FALSE
[17:39:25.401]                       if (inherits(cond, "message")) {
[17:39:25.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.401]                         if (muffled) 
[17:39:25.401]                           invokeRestart("muffleMessage")
[17:39:25.401]                       }
[17:39:25.401]                       else if (inherits(cond, "warning")) {
[17:39:25.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.401]                         if (muffled) 
[17:39:25.401]                           invokeRestart("muffleWarning")
[17:39:25.401]                       }
[17:39:25.401]                       else if (inherits(cond, "condition")) {
[17:39:25.401]                         if (!is.null(pattern)) {
[17:39:25.401]                           computeRestarts <- base::computeRestarts
[17:39:25.401]                           grepl <- base::grepl
[17:39:25.401]                           restarts <- computeRestarts(cond)
[17:39:25.401]                           for (restart in restarts) {
[17:39:25.401]                             name <- restart$name
[17:39:25.401]                             if (is.null(name)) 
[17:39:25.401]                               next
[17:39:25.401]                             if (!grepl(pattern, name)) 
[17:39:25.401]                               next
[17:39:25.401]                             invokeRestart(restart)
[17:39:25.401]                             muffled <- TRUE
[17:39:25.401]                             break
[17:39:25.401]                           }
[17:39:25.401]                         }
[17:39:25.401]                       }
[17:39:25.401]                       invisible(muffled)
[17:39:25.401]                     }
[17:39:25.401]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.401]                   }
[17:39:25.401]                 }
[17:39:25.401]                 else {
[17:39:25.401]                   if (TRUE) {
[17:39:25.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.401]                     {
[17:39:25.401]                       inherits <- base::inherits
[17:39:25.401]                       invokeRestart <- base::invokeRestart
[17:39:25.401]                       is.null <- base::is.null
[17:39:25.401]                       muffled <- FALSE
[17:39:25.401]                       if (inherits(cond, "message")) {
[17:39:25.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.401]                         if (muffled) 
[17:39:25.401]                           invokeRestart("muffleMessage")
[17:39:25.401]                       }
[17:39:25.401]                       else if (inherits(cond, "warning")) {
[17:39:25.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.401]                         if (muffled) 
[17:39:25.401]                           invokeRestart("muffleWarning")
[17:39:25.401]                       }
[17:39:25.401]                       else if (inherits(cond, "condition")) {
[17:39:25.401]                         if (!is.null(pattern)) {
[17:39:25.401]                           computeRestarts <- base::computeRestarts
[17:39:25.401]                           grepl <- base::grepl
[17:39:25.401]                           restarts <- computeRestarts(cond)
[17:39:25.401]                           for (restart in restarts) {
[17:39:25.401]                             name <- restart$name
[17:39:25.401]                             if (is.null(name)) 
[17:39:25.401]                               next
[17:39:25.401]                             if (!grepl(pattern, name)) 
[17:39:25.401]                               next
[17:39:25.401]                             invokeRestart(restart)
[17:39:25.401]                             muffled <- TRUE
[17:39:25.401]                             break
[17:39:25.401]                           }
[17:39:25.401]                         }
[17:39:25.401]                       }
[17:39:25.401]                       invisible(muffled)
[17:39:25.401]                     }
[17:39:25.401]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.401]                   }
[17:39:25.401]                 }
[17:39:25.401]             }
[17:39:25.401]         }))
[17:39:25.401]     }, error = function(ex) {
[17:39:25.401]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.401]                 ...future.rng), started = ...future.startTime, 
[17:39:25.401]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.401]             version = "1.8"), class = "FutureResult")
[17:39:25.401]     }, finally = {
[17:39:25.401]         if (!identical(...future.workdir, getwd())) 
[17:39:25.401]             setwd(...future.workdir)
[17:39:25.401]         {
[17:39:25.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.401]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.401]             }
[17:39:25.401]             base::options(...future.oldOptions)
[17:39:25.401]             if (.Platform$OS.type == "windows") {
[17:39:25.401]                 old_names <- names(...future.oldEnvVars)
[17:39:25.401]                 envs <- base::Sys.getenv()
[17:39:25.401]                 names <- names(envs)
[17:39:25.401]                 common <- intersect(names, old_names)
[17:39:25.401]                 added <- setdiff(names, old_names)
[17:39:25.401]                 removed <- setdiff(old_names, names)
[17:39:25.401]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.401]                   envs[common]]
[17:39:25.401]                 NAMES <- toupper(changed)
[17:39:25.401]                 args <- list()
[17:39:25.401]                 for (kk in seq_along(NAMES)) {
[17:39:25.401]                   name <- changed[[kk]]
[17:39:25.401]                   NAME <- NAMES[[kk]]
[17:39:25.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.401]                     next
[17:39:25.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.401]                 }
[17:39:25.401]                 NAMES <- toupper(added)
[17:39:25.401]                 for (kk in seq_along(NAMES)) {
[17:39:25.401]                   name <- added[[kk]]
[17:39:25.401]                   NAME <- NAMES[[kk]]
[17:39:25.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.401]                     next
[17:39:25.401]                   args[[name]] <- ""
[17:39:25.401]                 }
[17:39:25.401]                 NAMES <- toupper(removed)
[17:39:25.401]                 for (kk in seq_along(NAMES)) {
[17:39:25.401]                   name <- removed[[kk]]
[17:39:25.401]                   NAME <- NAMES[[kk]]
[17:39:25.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.401]                     next
[17:39:25.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.401]                 }
[17:39:25.401]                 if (length(args) > 0) 
[17:39:25.401]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.401]             }
[17:39:25.401]             else {
[17:39:25.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.401]             }
[17:39:25.401]             {
[17:39:25.401]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.401]                   0L) {
[17:39:25.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.401]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.401]                   base::options(opts)
[17:39:25.401]                 }
[17:39:25.401]                 {
[17:39:25.401]                   {
[17:39:25.401]                     NULL
[17:39:25.401]                     RNGkind("Mersenne-Twister")
[17:39:25.401]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.401]                       inherits = FALSE)
[17:39:25.401]                   }
[17:39:25.401]                   options(future.plan = NULL)
[17:39:25.401]                   if (is.na(NA_character_)) 
[17:39:25.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.401]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:25.401]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:25.401]                     envir = parent.frame()) 
[17:39:25.401]                   {
[17:39:25.401]                     if (is.function(workers)) 
[17:39:25.401]                       workers <- workers()
[17:39:25.401]                     workers <- structure(as.integer(workers), 
[17:39:25.401]                       class = class(workers))
[17:39:25.401]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:25.401]                       workers >= 1)
[17:39:25.401]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:25.401]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:25.401]                     }
[17:39:25.401]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:25.401]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:25.401]                       envir = envir)
[17:39:25.401]                     if (!future$lazy) 
[17:39:25.401]                       future <- run(future)
[17:39:25.401]                     invisible(future)
[17:39:25.401]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.401]                 }
[17:39:25.401]             }
[17:39:25.401]         }
[17:39:25.401]     })
[17:39:25.401]     if (TRUE) {
[17:39:25.401]         base::sink(type = "output", split = FALSE)
[17:39:25.401]         if (TRUE) {
[17:39:25.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.401]         }
[17:39:25.401]         else {
[17:39:25.401]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.401]         }
[17:39:25.401]         base::close(...future.stdout)
[17:39:25.401]         ...future.stdout <- NULL
[17:39:25.401]     }
[17:39:25.401]     ...future.result$conditions <- ...future.conditions
[17:39:25.401]     ...future.result$finished <- base::Sys.time()
[17:39:25.401]     ...future.result
[17:39:25.401] }
[17:39:25.403] assign_globals() ...
[17:39:25.403] List of 5
[17:39:25.403]  $ ...future.FUN            :function (object, ...)  
[17:39:25.403]  $ future.call.arguments    : list()
[17:39:25.403]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.403]  $ ...future.elements_ii    :List of 3
[17:39:25.403]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:25.403]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.403]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.403]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:25.403]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.403]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.403]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:25.403]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.403]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.403]  $ ...future.seeds_ii       : NULL
[17:39:25.403]  $ ...future.globals.maxSize: NULL
[17:39:25.403]  - attr(*, "resolved")= logi FALSE
[17:39:25.403]  - attr(*, "total_size")= num 1240
[17:39:25.403]  - attr(*, "where")=List of 5
[17:39:25.403]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.403]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.403]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.403]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.403]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.403]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.403]  - attr(*, "already-done")= logi TRUE
[17:39:25.410] - copied ‘...future.FUN’ to environment
[17:39:25.410] - copied ‘future.call.arguments’ to environment
[17:39:25.410] - copied ‘...future.elements_ii’ to environment
[17:39:25.411] - copied ‘...future.seeds_ii’ to environment
[17:39:25.411] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.411] assign_globals() ... done
[17:39:25.411] plan(): Setting new future strategy stack:
[17:39:25.411] List of future strategies:
[17:39:25.411] 1. sequential:
[17:39:25.411]    - args: function (..., envir = parent.frame())
[17:39:25.411]    - tweaked: FALSE
[17:39:25.411]    - call: NULL
[17:39:25.411] plan(): nbrOfWorkers() = 1
[17:39:25.415] plan(): Setting new future strategy stack:
[17:39:25.415] List of future strategies:
[17:39:25.415] 1. multisession:
[17:39:25.415]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:25.415]    - tweaked: FALSE
[17:39:25.415]    - call: plan(strategy)
[17:39:25.418] plan(): nbrOfWorkers() = 1
[17:39:25.418] SequentialFuture started (and completed)
[17:39:25.419] - Launch lazy future ... done
[17:39:25.419] run() for ‘SequentialFuture’ ... done
[17:39:25.419] Created future:
[17:39:25.419] SequentialFuture:
[17:39:25.419] Label: ‘future_by-1’
[17:39:25.419] Expression:
[17:39:25.419] {
[17:39:25.419]     do.call(function(...) {
[17:39:25.419]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.419]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.419]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.419]             on.exit(options(oopts), add = TRUE)
[17:39:25.419]         }
[17:39:25.419]         {
[17:39:25.419]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.419]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.419]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.419]             })
[17:39:25.419]         }
[17:39:25.419]     }, args = future.call.arguments)
[17:39:25.419] }
[17:39:25.419] Lazy evaluation: FALSE
[17:39:25.419] Asynchronous evaluation: FALSE
[17:39:25.419] Local evaluation: TRUE
[17:39:25.419] Environment: R_GlobalEnv
[17:39:25.419] Capture standard output: TRUE
[17:39:25.419] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.419] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.419] Packages: <none>
[17:39:25.419] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.419] Resolved: TRUE
[17:39:25.419] Value: 4.62 KiB of class ‘list’
[17:39:25.419] Early signaling: FALSE
[17:39:25.419] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.419] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.420] Chunk #1 of 1 ... DONE
[17:39:25.420] Launching 1 futures (chunks) ... DONE
[17:39:25.420] Resolving 1 futures (chunks) ...
[17:39:25.420] resolve() on list ...
[17:39:25.421]  recursive: 0
[17:39:25.421]  length: 1
[17:39:25.421] 
[17:39:25.421] resolved() for ‘SequentialFuture’ ...
[17:39:25.421] - state: ‘finished’
[17:39:25.421] - run: TRUE
[17:39:25.421] - result: ‘FutureResult’
[17:39:25.421] resolved() for ‘SequentialFuture’ ... done
[17:39:25.421] Future #1
[17:39:25.421] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.422] - nx: 1
[17:39:25.422] - relay: TRUE
[17:39:25.422] - stdout: TRUE
[17:39:25.422] - signal: TRUE
[17:39:25.422] - resignal: FALSE
[17:39:25.422] - force: TRUE
[17:39:25.422] - relayed: [n=1] FALSE
[17:39:25.422] - queued futures: [n=1] FALSE
[17:39:25.422]  - until=1
[17:39:25.422]  - relaying element #1
[17:39:25.422] - relayed: [n=1] TRUE
[17:39:25.423] - queued futures: [n=1] TRUE
[17:39:25.423] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.423]  length: 0 (resolved future 1)
[17:39:25.423] Relaying remaining futures
[17:39:25.423] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.423] - nx: 1
[17:39:25.423] - relay: TRUE
[17:39:25.423] - stdout: TRUE
[17:39:25.423] - signal: TRUE
[17:39:25.423] - resignal: FALSE
[17:39:25.423] - force: TRUE
[17:39:25.424] - relayed: [n=1] TRUE
[17:39:25.424] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.424] - relayed: [n=1] TRUE
[17:39:25.424] - queued futures: [n=1] TRUE
[17:39:25.424] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.424] resolve() on list ... DONE
[17:39:25.424]  - Number of value chunks collected: 1
[17:39:25.424] Resolving 1 futures (chunks) ... DONE
[17:39:25.424] Reducing values from 1 chunks ...
[17:39:25.424]  - Number of values collected after concatenation: 3
[17:39:25.425]  - Number of values expected: 3
[17:39:25.425] Reducing values from 1 chunks ... DONE
[17:39:25.425] future_lapply() ... DONE
[17:39:25.425] future_by_internal() ... DONE
[17:39:25.425] future_by_internal() ...
[17:39:25.425] future_lapply() ...
[17:39:25.429] Number of chunks: 1
[17:39:25.429] getGlobalsAndPackagesXApply() ...
[17:39:25.429]  - future.globals: TRUE
[17:39:25.429] getGlobalsAndPackages() ...
[17:39:25.429] Searching for globals...
[17:39:25.430] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.430] Searching for globals ... DONE
[17:39:25.430] Resolving globals: FALSE
[17:39:25.431] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.431] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.431] - globals: [1] ‘FUN’
[17:39:25.431] 
[17:39:25.431] getGlobalsAndPackages() ... DONE
[17:39:25.432]  - globals found/used: [n=1] ‘FUN’
[17:39:25.432]  - needed namespaces: [n=0] 
[17:39:25.432] Finding globals ... DONE
[17:39:25.432]  - use_args: TRUE
[17:39:25.432]  - Getting '...' globals ...
[17:39:25.432] resolve() on list ...
[17:39:25.432]  recursive: 0
[17:39:25.432]  length: 1
[17:39:25.433]  elements: ‘...’
[17:39:25.433]  length: 0 (resolved future 1)
[17:39:25.433] resolve() on list ... DONE
[17:39:25.433]    - '...' content: [n=1] ‘digits’
[17:39:25.433] List of 1
[17:39:25.433]  $ ...:List of 1
[17:39:25.433]   ..$ digits: int 2
[17:39:25.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.433]  - attr(*, "where")=List of 1
[17:39:25.433]   ..$ ...:<environment: 0x56296ec46ac8> 
[17:39:25.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.433]  - attr(*, "resolved")= logi TRUE
[17:39:25.433]  - attr(*, "total_size")= num NA
[17:39:25.436]  - Getting '...' globals ... DONE
[17:39:25.436] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.436] List of 2
[17:39:25.436]  $ ...future.FUN:function (object, ...)  
[17:39:25.436]  $ ...          :List of 1
[17:39:25.436]   ..$ digits: int 2
[17:39:25.436]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.436]  - attr(*, "where")=List of 2
[17:39:25.436]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.436]   ..$ ...          :<environment: 0x56296ec46ac8> 
[17:39:25.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.436]  - attr(*, "resolved")= logi FALSE
[17:39:25.436]  - attr(*, "total_size")= num 1296
[17:39:25.441] Packages to be attached in all futures: [n=0] 
[17:39:25.441] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.441] Number of futures (= number of chunks): 1
[17:39:25.442] Launching 1 futures (chunks) ...
[17:39:25.442] Chunk #1 of 1 ...
[17:39:25.442]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.442] getGlobalsAndPackages() ...
[17:39:25.442] Searching for globals...
[17:39:25.442] 
[17:39:25.442] Searching for globals ... DONE
[17:39:25.442] - globals: [0] <none>
[17:39:25.443] getGlobalsAndPackages() ... DONE
[17:39:25.443]    + additional globals found: [n=0] 
[17:39:25.443]    + additional namespaces needed: [n=0] 
[17:39:25.443]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.443]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[17:39:25.443]  - seeds: <none>
[17:39:25.443] getGlobalsAndPackages() ...
[17:39:25.443] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.443] Resolving globals: FALSE
[17:39:25.444] Tweak future expression to call with '...' arguments ...
[17:39:25.444] {
[17:39:25.444]     do.call(function(...) {
[17:39:25.444]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.444]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.444]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.444]             on.exit(options(oopts), add = TRUE)
[17:39:25.444]         }
[17:39:25.444]         {
[17:39:25.444]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.444]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.444]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.444]             })
[17:39:25.444]         }
[17:39:25.444]     }, args = future.call.arguments)
[17:39:25.444] }
[17:39:25.444] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.444] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.444] 
[17:39:25.444] getGlobalsAndPackages() ... DONE
[17:39:25.445] run() for ‘Future’ ...
[17:39:25.445] - state: ‘created’
[17:39:25.445] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.448] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.449]   - Field: ‘label’
[17:39:25.449]   - Field: ‘local’
[17:39:25.449]   - Field: ‘owner’
[17:39:25.449]   - Field: ‘envir’
[17:39:25.449]   - Field: ‘packages’
[17:39:25.449]   - Field: ‘gc’
[17:39:25.449]   - Field: ‘conditions’
[17:39:25.449]   - Field: ‘expr’
[17:39:25.449]   - Field: ‘uuid’
[17:39:25.449]   - Field: ‘seed’
[17:39:25.450]   - Field: ‘version’
[17:39:25.450]   - Field: ‘result’
[17:39:25.450]   - Field: ‘asynchronous’
[17:39:25.450]   - Field: ‘calls’
[17:39:25.450]   - Field: ‘globals’
[17:39:25.450]   - Field: ‘stdout’
[17:39:25.450]   - Field: ‘earlySignal’
[17:39:25.450]   - Field: ‘lazy’
[17:39:25.450]   - Field: ‘state’
[17:39:25.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.450] - Launch lazy future ...
[17:39:25.451] Packages needed by the future expression (n = 0): <none>
[17:39:25.451] Packages needed by future strategies (n = 0): <none>
[17:39:25.451] {
[17:39:25.451]     {
[17:39:25.451]         {
[17:39:25.451]             ...future.startTime <- base::Sys.time()
[17:39:25.451]             {
[17:39:25.451]                 {
[17:39:25.451]                   {
[17:39:25.451]                     base::local({
[17:39:25.451]                       has_future <- base::requireNamespace("future", 
[17:39:25.451]                         quietly = TRUE)
[17:39:25.451]                       if (has_future) {
[17:39:25.451]                         ns <- base::getNamespace("future")
[17:39:25.451]                         version <- ns[[".package"]][["version"]]
[17:39:25.451]                         if (is.null(version)) 
[17:39:25.451]                           version <- utils::packageVersion("future")
[17:39:25.451]                       }
[17:39:25.451]                       else {
[17:39:25.451]                         version <- NULL
[17:39:25.451]                       }
[17:39:25.451]                       if (!has_future || version < "1.8.0") {
[17:39:25.451]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.451]                           "", base::R.version$version.string), 
[17:39:25.451]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.451]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.451]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.451]                             "release", "version")], collapse = " "), 
[17:39:25.451]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.451]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.451]                           info)
[17:39:25.451]                         info <- base::paste(info, collapse = "; ")
[17:39:25.451]                         if (!has_future) {
[17:39:25.451]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.451]                             info)
[17:39:25.451]                         }
[17:39:25.451]                         else {
[17:39:25.451]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.451]                             info, version)
[17:39:25.451]                         }
[17:39:25.451]                         base::stop(msg)
[17:39:25.451]                       }
[17:39:25.451]                     })
[17:39:25.451]                   }
[17:39:25.451]                   options(future.plan = NULL)
[17:39:25.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.451]                 }
[17:39:25.451]                 ...future.workdir <- getwd()
[17:39:25.451]             }
[17:39:25.451]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.451]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.451]         }
[17:39:25.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.451]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[17:39:25.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.451]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.451]             base::names(...future.oldOptions))
[17:39:25.451]     }
[17:39:25.451]     if (FALSE) {
[17:39:25.451]     }
[17:39:25.451]     else {
[17:39:25.451]         if (TRUE) {
[17:39:25.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.451]                 open = "w")
[17:39:25.451]         }
[17:39:25.451]         else {
[17:39:25.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.451]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.451]         }
[17:39:25.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.451]             base::sink(type = "output", split = FALSE)
[17:39:25.451]             base::close(...future.stdout)
[17:39:25.451]         }, add = TRUE)
[17:39:25.451]     }
[17:39:25.451]     ...future.frame <- base::sys.nframe()
[17:39:25.451]     ...future.conditions <- base::list()
[17:39:25.451]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.451]     if (FALSE) {
[17:39:25.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.451]     }
[17:39:25.451]     ...future.result <- base::tryCatch({
[17:39:25.451]         base::withCallingHandlers({
[17:39:25.451]             ...future.value <- base::withVisible(base::local({
[17:39:25.451]                 do.call(function(...) {
[17:39:25.451]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.451]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.451]                     ...future.globals.maxSize)) {
[17:39:25.451]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.451]                     on.exit(options(oopts), add = TRUE)
[17:39:25.451]                   }
[17:39:25.451]                   {
[17:39:25.451]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.451]                       FUN = function(jj) {
[17:39:25.451]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.451]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.451]                       })
[17:39:25.451]                   }
[17:39:25.451]                 }, args = future.call.arguments)
[17:39:25.451]             }))
[17:39:25.451]             future::FutureResult(value = ...future.value$value, 
[17:39:25.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.451]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.451]                     ...future.globalenv.names))
[17:39:25.451]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.451]         }, condition = base::local({
[17:39:25.451]             c <- base::c
[17:39:25.451]             inherits <- base::inherits
[17:39:25.451]             invokeRestart <- base::invokeRestart
[17:39:25.451]             length <- base::length
[17:39:25.451]             list <- base::list
[17:39:25.451]             seq.int <- base::seq.int
[17:39:25.451]             signalCondition <- base::signalCondition
[17:39:25.451]             sys.calls <- base::sys.calls
[17:39:25.451]             `[[` <- base::`[[`
[17:39:25.451]             `+` <- base::`+`
[17:39:25.451]             `<<-` <- base::`<<-`
[17:39:25.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.451]                   3L)]
[17:39:25.451]             }
[17:39:25.451]             function(cond) {
[17:39:25.451]                 is_error <- inherits(cond, "error")
[17:39:25.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.451]                   NULL)
[17:39:25.451]                 if (is_error) {
[17:39:25.451]                   sessionInformation <- function() {
[17:39:25.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.451]                       search = base::search(), system = base::Sys.info())
[17:39:25.451]                   }
[17:39:25.451]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.451]                     cond$call), session = sessionInformation(), 
[17:39:25.451]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.451]                   signalCondition(cond)
[17:39:25.451]                 }
[17:39:25.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.451]                 "immediateCondition"))) {
[17:39:25.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.451]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.451]                   if (TRUE && !signal) {
[17:39:25.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.451]                     {
[17:39:25.451]                       inherits <- base::inherits
[17:39:25.451]                       invokeRestart <- base::invokeRestart
[17:39:25.451]                       is.null <- base::is.null
[17:39:25.451]                       muffled <- FALSE
[17:39:25.451]                       if (inherits(cond, "message")) {
[17:39:25.451]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.451]                         if (muffled) 
[17:39:25.451]                           invokeRestart("muffleMessage")
[17:39:25.451]                       }
[17:39:25.451]                       else if (inherits(cond, "warning")) {
[17:39:25.451]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.451]                         if (muffled) 
[17:39:25.451]                           invokeRestart("muffleWarning")
[17:39:25.451]                       }
[17:39:25.451]                       else if (inherits(cond, "condition")) {
[17:39:25.451]                         if (!is.null(pattern)) {
[17:39:25.451]                           computeRestarts <- base::computeRestarts
[17:39:25.451]                           grepl <- base::grepl
[17:39:25.451]                           restarts <- computeRestarts(cond)
[17:39:25.451]                           for (restart in restarts) {
[17:39:25.451]                             name <- restart$name
[17:39:25.451]                             if (is.null(name)) 
[17:39:25.451]                               next
[17:39:25.451]                             if (!grepl(pattern, name)) 
[17:39:25.451]                               next
[17:39:25.451]                             invokeRestart(restart)
[17:39:25.451]                             muffled <- TRUE
[17:39:25.451]                             break
[17:39:25.451]                           }
[17:39:25.451]                         }
[17:39:25.451]                       }
[17:39:25.451]                       invisible(muffled)
[17:39:25.451]                     }
[17:39:25.451]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.451]                   }
[17:39:25.451]                 }
[17:39:25.451]                 else {
[17:39:25.451]                   if (TRUE) {
[17:39:25.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.451]                     {
[17:39:25.451]                       inherits <- base::inherits
[17:39:25.451]                       invokeRestart <- base::invokeRestart
[17:39:25.451]                       is.null <- base::is.null
[17:39:25.451]                       muffled <- FALSE
[17:39:25.451]                       if (inherits(cond, "message")) {
[17:39:25.451]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.451]                         if (muffled) 
[17:39:25.451]                           invokeRestart("muffleMessage")
[17:39:25.451]                       }
[17:39:25.451]                       else if (inherits(cond, "warning")) {
[17:39:25.451]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.451]                         if (muffled) 
[17:39:25.451]                           invokeRestart("muffleWarning")
[17:39:25.451]                       }
[17:39:25.451]                       else if (inherits(cond, "condition")) {
[17:39:25.451]                         if (!is.null(pattern)) {
[17:39:25.451]                           computeRestarts <- base::computeRestarts
[17:39:25.451]                           grepl <- base::grepl
[17:39:25.451]                           restarts <- computeRestarts(cond)
[17:39:25.451]                           for (restart in restarts) {
[17:39:25.451]                             name <- restart$name
[17:39:25.451]                             if (is.null(name)) 
[17:39:25.451]                               next
[17:39:25.451]                             if (!grepl(pattern, name)) 
[17:39:25.451]                               next
[17:39:25.451]                             invokeRestart(restart)
[17:39:25.451]                             muffled <- TRUE
[17:39:25.451]                             break
[17:39:25.451]                           }
[17:39:25.451]                         }
[17:39:25.451]                       }
[17:39:25.451]                       invisible(muffled)
[17:39:25.451]                     }
[17:39:25.451]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.451]                   }
[17:39:25.451]                 }
[17:39:25.451]             }
[17:39:25.451]         }))
[17:39:25.451]     }, error = function(ex) {
[17:39:25.451]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.451]                 ...future.rng), started = ...future.startTime, 
[17:39:25.451]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.451]             version = "1.8"), class = "FutureResult")
[17:39:25.451]     }, finally = {
[17:39:25.451]         if (!identical(...future.workdir, getwd())) 
[17:39:25.451]             setwd(...future.workdir)
[17:39:25.451]         {
[17:39:25.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.451]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.451]             }
[17:39:25.451]             base::options(...future.oldOptions)
[17:39:25.451]             if (.Platform$OS.type == "windows") {
[17:39:25.451]                 old_names <- names(...future.oldEnvVars)
[17:39:25.451]                 envs <- base::Sys.getenv()
[17:39:25.451]                 names <- names(envs)
[17:39:25.451]                 common <- intersect(names, old_names)
[17:39:25.451]                 added <- setdiff(names, old_names)
[17:39:25.451]                 removed <- setdiff(old_names, names)
[17:39:25.451]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.451]                   envs[common]]
[17:39:25.451]                 NAMES <- toupper(changed)
[17:39:25.451]                 args <- list()
[17:39:25.451]                 for (kk in seq_along(NAMES)) {
[17:39:25.451]                   name <- changed[[kk]]
[17:39:25.451]                   NAME <- NAMES[[kk]]
[17:39:25.451]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.451]                     next
[17:39:25.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.451]                 }
[17:39:25.451]                 NAMES <- toupper(added)
[17:39:25.451]                 for (kk in seq_along(NAMES)) {
[17:39:25.451]                   name <- added[[kk]]
[17:39:25.451]                   NAME <- NAMES[[kk]]
[17:39:25.451]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.451]                     next
[17:39:25.451]                   args[[name]] <- ""
[17:39:25.451]                 }
[17:39:25.451]                 NAMES <- toupper(removed)
[17:39:25.451]                 for (kk in seq_along(NAMES)) {
[17:39:25.451]                   name <- removed[[kk]]
[17:39:25.451]                   NAME <- NAMES[[kk]]
[17:39:25.451]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.451]                     next
[17:39:25.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.451]                 }
[17:39:25.451]                 if (length(args) > 0) 
[17:39:25.451]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.451]             }
[17:39:25.451]             else {
[17:39:25.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.451]             }
[17:39:25.451]             {
[17:39:25.451]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.451]                   0L) {
[17:39:25.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.451]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.451]                   base::options(opts)
[17:39:25.451]                 }
[17:39:25.451]                 {
[17:39:25.451]                   {
[17:39:25.451]                     NULL
[17:39:25.451]                     RNGkind("Mersenne-Twister")
[17:39:25.451]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.451]                       inherits = FALSE)
[17:39:25.451]                   }
[17:39:25.451]                   options(future.plan = NULL)
[17:39:25.451]                   if (is.na(NA_character_)) 
[17:39:25.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.451]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:25.451]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:25.451]                     envir = parent.frame()) 
[17:39:25.451]                   {
[17:39:25.451]                     if (is.function(workers)) 
[17:39:25.451]                       workers <- workers()
[17:39:25.451]                     workers <- structure(as.integer(workers), 
[17:39:25.451]                       class = class(workers))
[17:39:25.451]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:25.451]                       workers >= 1)
[17:39:25.451]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:25.451]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:25.451]                     }
[17:39:25.451]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:25.451]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:25.451]                       envir = envir)
[17:39:25.451]                     if (!future$lazy) 
[17:39:25.451]                       future <- run(future)
[17:39:25.451]                     invisible(future)
[17:39:25.451]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.451]                 }
[17:39:25.451]             }
[17:39:25.451]         }
[17:39:25.451]     })
[17:39:25.451]     if (TRUE) {
[17:39:25.451]         base::sink(type = "output", split = FALSE)
[17:39:25.451]         if (TRUE) {
[17:39:25.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.451]         }
[17:39:25.451]         else {
[17:39:25.451]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.451]         }
[17:39:25.451]         base::close(...future.stdout)
[17:39:25.451]         ...future.stdout <- NULL
[17:39:25.451]     }
[17:39:25.451]     ...future.result$conditions <- ...future.conditions
[17:39:25.451]     ...future.result$finished <- base::Sys.time()
[17:39:25.451]     ...future.result
[17:39:25.451] }
[17:39:25.453] assign_globals() ...
[17:39:25.453] List of 5
[17:39:25.453]  $ ...future.FUN            :function (object, ...)  
[17:39:25.453]  $ future.call.arguments    :List of 1
[17:39:25.453]   ..$ digits: int 2
[17:39:25.453]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.453]  $ ...future.elements_ii    :List of 6
[17:39:25.453]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:39:25.453]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:39:25.453]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:39:25.453]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:39:25.453]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:39:25.453]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:39:25.453]  $ ...future.seeds_ii       : NULL
[17:39:25.453]  $ ...future.globals.maxSize: NULL
[17:39:25.453]  - attr(*, "resolved")= logi FALSE
[17:39:25.453]  - attr(*, "total_size")= num 1296
[17:39:25.453]  - attr(*, "where")=List of 5
[17:39:25.453]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.453]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.453]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.453]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.453]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.453]  - attr(*, "already-done")= logi TRUE
[17:39:25.460] - copied ‘...future.FUN’ to environment
[17:39:25.460] - copied ‘future.call.arguments’ to environment
[17:39:25.460] - copied ‘...future.elements_ii’ to environment
[17:39:25.460] - copied ‘...future.seeds_ii’ to environment
[17:39:25.460] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.460] assign_globals() ... done
[17:39:25.460] plan(): Setting new future strategy stack:
[17:39:25.460] List of future strategies:
[17:39:25.460] 1. sequential:
[17:39:25.460]    - args: function (..., envir = parent.frame())
[17:39:25.460]    - tweaked: FALSE
[17:39:25.460]    - call: NULL
[17:39:25.461] plan(): nbrOfWorkers() = 1
[17:39:25.464] plan(): Setting new future strategy stack:
[17:39:25.464] List of future strategies:
[17:39:25.464] 1. multisession:
[17:39:25.464]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:25.464]    - tweaked: FALSE
[17:39:25.464]    - call: plan(strategy)
[17:39:25.467] plan(): nbrOfWorkers() = 1
[17:39:25.467] SequentialFuture started (and completed)
[17:39:25.468] - Launch lazy future ... done
[17:39:25.468] run() for ‘SequentialFuture’ ... done
[17:39:25.468] Created future:
[17:39:25.468] SequentialFuture:
[17:39:25.468] Label: ‘future_by-1’
[17:39:25.468] Expression:
[17:39:25.468] {
[17:39:25.468]     do.call(function(...) {
[17:39:25.468]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.468]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.468]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.468]             on.exit(options(oopts), add = TRUE)
[17:39:25.468]         }
[17:39:25.468]         {
[17:39:25.468]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.468]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.468]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.468]             })
[17:39:25.468]         }
[17:39:25.468]     }, args = future.call.arguments)
[17:39:25.468] }
[17:39:25.468] Lazy evaluation: FALSE
[17:39:25.468] Asynchronous evaluation: FALSE
[17:39:25.468] Local evaluation: TRUE
[17:39:25.468] Environment: R_GlobalEnv
[17:39:25.468] Capture standard output: TRUE
[17:39:25.468] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.468] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.468] Packages: <none>
[17:39:25.468] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.468] Resolved: TRUE
[17:39:25.468] Value: 5.48 KiB of class ‘list’
[17:39:25.468] Early signaling: FALSE
[17:39:25.468] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.468] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.469] Chunk #1 of 1 ... DONE
[17:39:25.469] Launching 1 futures (chunks) ... DONE
[17:39:25.469] Resolving 1 futures (chunks) ...
[17:39:25.469] resolve() on list ...
[17:39:25.469]  recursive: 0
[17:39:25.469]  length: 1
[17:39:25.470] 
[17:39:25.470] resolved() for ‘SequentialFuture’ ...
[17:39:25.470] - state: ‘finished’
[17:39:25.470] - run: TRUE
[17:39:25.470] - result: ‘FutureResult’
[17:39:25.470] resolved() for ‘SequentialFuture’ ... done
[17:39:25.470] Future #1
[17:39:25.470] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.470] - nx: 1
[17:39:25.470] - relay: TRUE
[17:39:25.471] - stdout: TRUE
[17:39:25.471] - signal: TRUE
[17:39:25.471] - resignal: FALSE
[17:39:25.471] - force: TRUE
[17:39:25.471] - relayed: [n=1] FALSE
[17:39:25.471] - queued futures: [n=1] FALSE
[17:39:25.471]  - until=1
[17:39:25.471]  - relaying element #1
[17:39:25.471] - relayed: [n=1] TRUE
[17:39:25.471] - queued futures: [n=1] TRUE
[17:39:25.472] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.472]  length: 0 (resolved future 1)
[17:39:25.472] Relaying remaining futures
[17:39:25.472] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.472] - nx: 1
[17:39:25.472] - relay: TRUE
[17:39:25.472] - stdout: TRUE
[17:39:25.472] - signal: TRUE
[17:39:25.472] - resignal: FALSE
[17:39:25.472] - force: TRUE
[17:39:25.472] - relayed: [n=1] TRUE
[17:39:25.473] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.473] - relayed: [n=1] TRUE
[17:39:25.473] - queued futures: [n=1] TRUE
[17:39:25.473] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.473] resolve() on list ... DONE
[17:39:25.473]  - Number of value chunks collected: 1
[17:39:25.473] Resolving 1 futures (chunks) ... DONE
[17:39:25.473] Reducing values from 1 chunks ...
[17:39:25.473]  - Number of values collected after concatenation: 6
[17:39:25.473]  - Number of values expected: 6
[17:39:25.474] Reducing values from 1 chunks ... DONE
[17:39:25.474] future_lapply() ... DONE
[17:39:25.474] future_by_internal() ... DONE
[17:39:25.475] future_by_internal() ...
[17:39:25.475] future_lapply() ...
[17:39:25.479] Number of chunks: 1
[17:39:25.479] getGlobalsAndPackagesXApply() ...
[17:39:25.479]  - future.globals: TRUE
[17:39:25.479] getGlobalsAndPackages() ...
[17:39:25.479] Searching for globals...
[17:39:25.481] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:25.481] Searching for globals ... DONE
[17:39:25.481] Resolving globals: FALSE
[17:39:25.481] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:39:25.482] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:39:25.482] - globals: [1] ‘FUN’
[17:39:25.482] - packages: [1] ‘stats’
[17:39:25.482] getGlobalsAndPackages() ... DONE
[17:39:25.482]  - globals found/used: [n=1] ‘FUN’
[17:39:25.482]  - needed namespaces: [n=1] ‘stats’
[17:39:25.482] Finding globals ... DONE
[17:39:25.482]  - use_args: TRUE
[17:39:25.482]  - Getting '...' globals ...
[17:39:25.483] resolve() on list ...
[17:39:25.483]  recursive: 0
[17:39:25.483]  length: 1
[17:39:25.483]  elements: ‘...’
[17:39:25.483]  length: 0 (resolved future 1)
[17:39:25.483] resolve() on list ... DONE
[17:39:25.483]    - '...' content: [n=1] ‘singular.ok’
[17:39:25.483] List of 1
[17:39:25.483]  $ ...:List of 1
[17:39:25.483]   ..$ singular.ok: logi FALSE
[17:39:25.483]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.483]  - attr(*, "where")=List of 1
[17:39:25.483]   ..$ ...:<environment: 0x562970455d08> 
[17:39:25.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.483]  - attr(*, "resolved")= logi TRUE
[17:39:25.483]  - attr(*, "total_size")= num NA
[17:39:25.488]  - Getting '...' globals ... DONE
[17:39:25.488] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.488] List of 2
[17:39:25.488]  $ ...future.FUN:function (x, ...)  
[17:39:25.488]  $ ...          :List of 1
[17:39:25.488]   ..$ singular.ok: logi FALSE
[17:39:25.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.488]  - attr(*, "where")=List of 2
[17:39:25.488]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.488]   ..$ ...          :<environment: 0x562970455d08> 
[17:39:25.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.488]  - attr(*, "resolved")= logi FALSE
[17:39:25.488]  - attr(*, "total_size")= num 5384
[17:39:25.491] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:25.491] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.491] Number of futures (= number of chunks): 1
[17:39:25.491] Launching 1 futures (chunks) ...
[17:39:25.491] Chunk #1 of 1 ...
[17:39:25.492]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.492] getGlobalsAndPackages() ...
[17:39:25.492] Searching for globals...
[17:39:25.492] 
[17:39:25.492] Searching for globals ... DONE
[17:39:25.492] - globals: [0] <none>
[17:39:25.492] getGlobalsAndPackages() ... DONE
[17:39:25.493]    + additional globals found: [n=0] 
[17:39:25.493]    + additional namespaces needed: [n=0] 
[17:39:25.493]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.493]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.493]  - seeds: <none>
[17:39:25.493] getGlobalsAndPackages() ...
[17:39:25.493] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.493] Resolving globals: FALSE
[17:39:25.493] Tweak future expression to call with '...' arguments ...
[17:39:25.493] {
[17:39:25.493]     do.call(function(...) {
[17:39:25.493]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.493]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.493]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.493]             on.exit(options(oopts), add = TRUE)
[17:39:25.493]         }
[17:39:25.493]         {
[17:39:25.493]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.493]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.493]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.493]             })
[17:39:25.493]         }
[17:39:25.493]     }, args = future.call.arguments)
[17:39:25.493] }
[17:39:25.494] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.494] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.494] 
[17:39:25.494] getGlobalsAndPackages() ... DONE
[17:39:25.495] run() for ‘Future’ ...
[17:39:25.495] - state: ‘created’
[17:39:25.495] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.498] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.498] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.498]   - Field: ‘label’
[17:39:25.499]   - Field: ‘local’
[17:39:25.499]   - Field: ‘owner’
[17:39:25.499]   - Field: ‘envir’
[17:39:25.499]   - Field: ‘packages’
[17:39:25.499]   - Field: ‘gc’
[17:39:25.499]   - Field: ‘conditions’
[17:39:25.499]   - Field: ‘expr’
[17:39:25.499]   - Field: ‘uuid’
[17:39:25.499]   - Field: ‘seed’
[17:39:25.499]   - Field: ‘version’
[17:39:25.500]   - Field: ‘result’
[17:39:25.500]   - Field: ‘asynchronous’
[17:39:25.500]   - Field: ‘calls’
[17:39:25.500]   - Field: ‘globals’
[17:39:25.500]   - Field: ‘stdout’
[17:39:25.500]   - Field: ‘earlySignal’
[17:39:25.500]   - Field: ‘lazy’
[17:39:25.500]   - Field: ‘state’
[17:39:25.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.500] - Launch lazy future ...
[17:39:25.501] Packages needed by the future expression (n = 1): ‘stats’
[17:39:25.501] Packages needed by future strategies (n = 0): <none>
[17:39:25.501] {
[17:39:25.501]     {
[17:39:25.501]         {
[17:39:25.501]             ...future.startTime <- base::Sys.time()
[17:39:25.501]             {
[17:39:25.501]                 {
[17:39:25.501]                   {
[17:39:25.501]                     {
[17:39:25.501]                       base::local({
[17:39:25.501]                         has_future <- base::requireNamespace("future", 
[17:39:25.501]                           quietly = TRUE)
[17:39:25.501]                         if (has_future) {
[17:39:25.501]                           ns <- base::getNamespace("future")
[17:39:25.501]                           version <- ns[[".package"]][["version"]]
[17:39:25.501]                           if (is.null(version)) 
[17:39:25.501]                             version <- utils::packageVersion("future")
[17:39:25.501]                         }
[17:39:25.501]                         else {
[17:39:25.501]                           version <- NULL
[17:39:25.501]                         }
[17:39:25.501]                         if (!has_future || version < "1.8.0") {
[17:39:25.501]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.501]                             "", base::R.version$version.string), 
[17:39:25.501]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:25.501]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.501]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.501]                               "release", "version")], collapse = " "), 
[17:39:25.501]                             hostname = base::Sys.info()[["nodename"]])
[17:39:25.501]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.501]                             info)
[17:39:25.501]                           info <- base::paste(info, collapse = "; ")
[17:39:25.501]                           if (!has_future) {
[17:39:25.501]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.501]                               info)
[17:39:25.501]                           }
[17:39:25.501]                           else {
[17:39:25.501]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.501]                               info, version)
[17:39:25.501]                           }
[17:39:25.501]                           base::stop(msg)
[17:39:25.501]                         }
[17:39:25.501]                       })
[17:39:25.501]                     }
[17:39:25.501]                     base::local({
[17:39:25.501]                       for (pkg in "stats") {
[17:39:25.501]                         base::loadNamespace(pkg)
[17:39:25.501]                         base::library(pkg, character.only = TRUE)
[17:39:25.501]                       }
[17:39:25.501]                     })
[17:39:25.501]                   }
[17:39:25.501]                   options(future.plan = NULL)
[17:39:25.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.501]                 }
[17:39:25.501]                 ...future.workdir <- getwd()
[17:39:25.501]             }
[17:39:25.501]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.501]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.501]         }
[17:39:25.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.501]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.501]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.501]             base::names(...future.oldOptions))
[17:39:25.501]     }
[17:39:25.501]     if (FALSE) {
[17:39:25.501]     }
[17:39:25.501]     else {
[17:39:25.501]         if (TRUE) {
[17:39:25.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.501]                 open = "w")
[17:39:25.501]         }
[17:39:25.501]         else {
[17:39:25.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.501]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.501]         }
[17:39:25.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.501]             base::sink(type = "output", split = FALSE)
[17:39:25.501]             base::close(...future.stdout)
[17:39:25.501]         }, add = TRUE)
[17:39:25.501]     }
[17:39:25.501]     ...future.frame <- base::sys.nframe()
[17:39:25.501]     ...future.conditions <- base::list()
[17:39:25.501]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.501]     if (FALSE) {
[17:39:25.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.501]     }
[17:39:25.501]     ...future.result <- base::tryCatch({
[17:39:25.501]         base::withCallingHandlers({
[17:39:25.501]             ...future.value <- base::withVisible(base::local({
[17:39:25.501]                 do.call(function(...) {
[17:39:25.501]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.501]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.501]                     ...future.globals.maxSize)) {
[17:39:25.501]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.501]                     on.exit(options(oopts), add = TRUE)
[17:39:25.501]                   }
[17:39:25.501]                   {
[17:39:25.501]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.501]                       FUN = function(jj) {
[17:39:25.501]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.501]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.501]                       })
[17:39:25.501]                   }
[17:39:25.501]                 }, args = future.call.arguments)
[17:39:25.501]             }))
[17:39:25.501]             future::FutureResult(value = ...future.value$value, 
[17:39:25.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.501]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.501]                     ...future.globalenv.names))
[17:39:25.501]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.501]         }, condition = base::local({
[17:39:25.501]             c <- base::c
[17:39:25.501]             inherits <- base::inherits
[17:39:25.501]             invokeRestart <- base::invokeRestart
[17:39:25.501]             length <- base::length
[17:39:25.501]             list <- base::list
[17:39:25.501]             seq.int <- base::seq.int
[17:39:25.501]             signalCondition <- base::signalCondition
[17:39:25.501]             sys.calls <- base::sys.calls
[17:39:25.501]             `[[` <- base::`[[`
[17:39:25.501]             `+` <- base::`+`
[17:39:25.501]             `<<-` <- base::`<<-`
[17:39:25.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.501]                   3L)]
[17:39:25.501]             }
[17:39:25.501]             function(cond) {
[17:39:25.501]                 is_error <- inherits(cond, "error")
[17:39:25.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.501]                   NULL)
[17:39:25.501]                 if (is_error) {
[17:39:25.501]                   sessionInformation <- function() {
[17:39:25.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.501]                       search = base::search(), system = base::Sys.info())
[17:39:25.501]                   }
[17:39:25.501]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.501]                     cond$call), session = sessionInformation(), 
[17:39:25.501]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.501]                   signalCondition(cond)
[17:39:25.501]                 }
[17:39:25.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.501]                 "immediateCondition"))) {
[17:39:25.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.501]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.501]                   if (TRUE && !signal) {
[17:39:25.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.501]                     {
[17:39:25.501]                       inherits <- base::inherits
[17:39:25.501]                       invokeRestart <- base::invokeRestart
[17:39:25.501]                       is.null <- base::is.null
[17:39:25.501]                       muffled <- FALSE
[17:39:25.501]                       if (inherits(cond, "message")) {
[17:39:25.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.501]                         if (muffled) 
[17:39:25.501]                           invokeRestart("muffleMessage")
[17:39:25.501]                       }
[17:39:25.501]                       else if (inherits(cond, "warning")) {
[17:39:25.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.501]                         if (muffled) 
[17:39:25.501]                           invokeRestart("muffleWarning")
[17:39:25.501]                       }
[17:39:25.501]                       else if (inherits(cond, "condition")) {
[17:39:25.501]                         if (!is.null(pattern)) {
[17:39:25.501]                           computeRestarts <- base::computeRestarts
[17:39:25.501]                           grepl <- base::grepl
[17:39:25.501]                           restarts <- computeRestarts(cond)
[17:39:25.501]                           for (restart in restarts) {
[17:39:25.501]                             name <- restart$name
[17:39:25.501]                             if (is.null(name)) 
[17:39:25.501]                               next
[17:39:25.501]                             if (!grepl(pattern, name)) 
[17:39:25.501]                               next
[17:39:25.501]                             invokeRestart(restart)
[17:39:25.501]                             muffled <- TRUE
[17:39:25.501]                             break
[17:39:25.501]                           }
[17:39:25.501]                         }
[17:39:25.501]                       }
[17:39:25.501]                       invisible(muffled)
[17:39:25.501]                     }
[17:39:25.501]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.501]                   }
[17:39:25.501]                 }
[17:39:25.501]                 else {
[17:39:25.501]                   if (TRUE) {
[17:39:25.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.501]                     {
[17:39:25.501]                       inherits <- base::inherits
[17:39:25.501]                       invokeRestart <- base::invokeRestart
[17:39:25.501]                       is.null <- base::is.null
[17:39:25.501]                       muffled <- FALSE
[17:39:25.501]                       if (inherits(cond, "message")) {
[17:39:25.501]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.501]                         if (muffled) 
[17:39:25.501]                           invokeRestart("muffleMessage")
[17:39:25.501]                       }
[17:39:25.501]                       else if (inherits(cond, "warning")) {
[17:39:25.501]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.501]                         if (muffled) 
[17:39:25.501]                           invokeRestart("muffleWarning")
[17:39:25.501]                       }
[17:39:25.501]                       else if (inherits(cond, "condition")) {
[17:39:25.501]                         if (!is.null(pattern)) {
[17:39:25.501]                           computeRestarts <- base::computeRestarts
[17:39:25.501]                           grepl <- base::grepl
[17:39:25.501]                           restarts <- computeRestarts(cond)
[17:39:25.501]                           for (restart in restarts) {
[17:39:25.501]                             name <- restart$name
[17:39:25.501]                             if (is.null(name)) 
[17:39:25.501]                               next
[17:39:25.501]                             if (!grepl(pattern, name)) 
[17:39:25.501]                               next
[17:39:25.501]                             invokeRestart(restart)
[17:39:25.501]                             muffled <- TRUE
[17:39:25.501]                             break
[17:39:25.501]                           }
[17:39:25.501]                         }
[17:39:25.501]                       }
[17:39:25.501]                       invisible(muffled)
[17:39:25.501]                     }
[17:39:25.501]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.501]                   }
[17:39:25.501]                 }
[17:39:25.501]             }
[17:39:25.501]         }))
[17:39:25.501]     }, error = function(ex) {
[17:39:25.501]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.501]                 ...future.rng), started = ...future.startTime, 
[17:39:25.501]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.501]             version = "1.8"), class = "FutureResult")
[17:39:25.501]     }, finally = {
[17:39:25.501]         if (!identical(...future.workdir, getwd())) 
[17:39:25.501]             setwd(...future.workdir)
[17:39:25.501]         {
[17:39:25.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.501]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.501]             }
[17:39:25.501]             base::options(...future.oldOptions)
[17:39:25.501]             if (.Platform$OS.type == "windows") {
[17:39:25.501]                 old_names <- names(...future.oldEnvVars)
[17:39:25.501]                 envs <- base::Sys.getenv()
[17:39:25.501]                 names <- names(envs)
[17:39:25.501]                 common <- intersect(names, old_names)
[17:39:25.501]                 added <- setdiff(names, old_names)
[17:39:25.501]                 removed <- setdiff(old_names, names)
[17:39:25.501]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.501]                   envs[common]]
[17:39:25.501]                 NAMES <- toupper(changed)
[17:39:25.501]                 args <- list()
[17:39:25.501]                 for (kk in seq_along(NAMES)) {
[17:39:25.501]                   name <- changed[[kk]]
[17:39:25.501]                   NAME <- NAMES[[kk]]
[17:39:25.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.501]                     next
[17:39:25.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.501]                 }
[17:39:25.501]                 NAMES <- toupper(added)
[17:39:25.501]                 for (kk in seq_along(NAMES)) {
[17:39:25.501]                   name <- added[[kk]]
[17:39:25.501]                   NAME <- NAMES[[kk]]
[17:39:25.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.501]                     next
[17:39:25.501]                   args[[name]] <- ""
[17:39:25.501]                 }
[17:39:25.501]                 NAMES <- toupper(removed)
[17:39:25.501]                 for (kk in seq_along(NAMES)) {
[17:39:25.501]                   name <- removed[[kk]]
[17:39:25.501]                   NAME <- NAMES[[kk]]
[17:39:25.501]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.501]                     next
[17:39:25.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.501]                 }
[17:39:25.501]                 if (length(args) > 0) 
[17:39:25.501]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.501]             }
[17:39:25.501]             else {
[17:39:25.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.501]             }
[17:39:25.501]             {
[17:39:25.501]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.501]                   0L) {
[17:39:25.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.501]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.501]                   base::options(opts)
[17:39:25.501]                 }
[17:39:25.501]                 {
[17:39:25.501]                   {
[17:39:25.501]                     NULL
[17:39:25.501]                     RNGkind("Mersenne-Twister")
[17:39:25.501]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.501]                       inherits = FALSE)
[17:39:25.501]                   }
[17:39:25.501]                   options(future.plan = NULL)
[17:39:25.501]                   if (is.na(NA_character_)) 
[17:39:25.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.501]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:25.501]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:25.501]                     envir = parent.frame()) 
[17:39:25.501]                   {
[17:39:25.501]                     if (is.function(workers)) 
[17:39:25.501]                       workers <- workers()
[17:39:25.501]                     workers <- structure(as.integer(workers), 
[17:39:25.501]                       class = class(workers))
[17:39:25.501]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:25.501]                       workers >= 1)
[17:39:25.501]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:25.501]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:25.501]                     }
[17:39:25.501]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:25.501]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:25.501]                       envir = envir)
[17:39:25.501]                     if (!future$lazy) 
[17:39:25.501]                       future <- run(future)
[17:39:25.501]                     invisible(future)
[17:39:25.501]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.501]                 }
[17:39:25.501]             }
[17:39:25.501]         }
[17:39:25.501]     })
[17:39:25.501]     if (TRUE) {
[17:39:25.501]         base::sink(type = "output", split = FALSE)
[17:39:25.501]         if (TRUE) {
[17:39:25.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.501]         }
[17:39:25.501]         else {
[17:39:25.501]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.501]         }
[17:39:25.501]         base::close(...future.stdout)
[17:39:25.501]         ...future.stdout <- NULL
[17:39:25.501]     }
[17:39:25.501]     ...future.result$conditions <- ...future.conditions
[17:39:25.501]     ...future.result$finished <- base::Sys.time()
[17:39:25.501]     ...future.result
[17:39:25.501] }
[17:39:25.503] assign_globals() ...
[17:39:25.503] List of 5
[17:39:25.503]  $ ...future.FUN            :function (x, ...)  
[17:39:25.503]  $ future.call.arguments    :List of 1
[17:39:25.503]   ..$ singular.ok: logi FALSE
[17:39:25.503]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.503]  $ ...future.elements_ii    :List of 3
[17:39:25.503]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.503]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.503]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.503]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.503]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.503]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.503]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.503]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.503]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.503]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.503]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.503]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.503]  $ ...future.seeds_ii       : NULL
[17:39:25.503]  $ ...future.globals.maxSize: NULL
[17:39:25.503]  - attr(*, "resolved")= logi FALSE
[17:39:25.503]  - attr(*, "total_size")= num 5384
[17:39:25.503]  - attr(*, "where")=List of 5
[17:39:25.503]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.503]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.503]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.503]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.503]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.503]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.503]  - attr(*, "already-done")= logi TRUE
[17:39:25.514] - reassign environment for ‘...future.FUN’
[17:39:25.514] - copied ‘...future.FUN’ to environment
[17:39:25.514] - copied ‘future.call.arguments’ to environment
[17:39:25.514] - copied ‘...future.elements_ii’ to environment
[17:39:25.514] - copied ‘...future.seeds_ii’ to environment
[17:39:25.515] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.515] assign_globals() ... done
[17:39:25.515] plan(): Setting new future strategy stack:
[17:39:25.515] List of future strategies:
[17:39:25.515] 1. sequential:
[17:39:25.515]    - args: function (..., envir = parent.frame())
[17:39:25.515]    - tweaked: FALSE
[17:39:25.515]    - call: NULL
[17:39:25.516] plan(): nbrOfWorkers() = 1
[17:39:25.518] plan(): Setting new future strategy stack:
[17:39:25.518] List of future strategies:
[17:39:25.518] 1. multisession:
[17:39:25.518]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:25.518]    - tweaked: FALSE
[17:39:25.518]    - call: plan(strategy)
[17:39:25.522] plan(): nbrOfWorkers() = 1
[17:39:25.522] SequentialFuture started (and completed)
[17:39:25.522] - Launch lazy future ... done
[17:39:25.522] run() for ‘SequentialFuture’ ... done
[17:39:25.522] Created future:
[17:39:25.522] SequentialFuture:
[17:39:25.522] Label: ‘future_by-1’
[17:39:25.522] Expression:
[17:39:25.522] {
[17:39:25.522]     do.call(function(...) {
[17:39:25.522]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.522]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.522]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.522]             on.exit(options(oopts), add = TRUE)
[17:39:25.522]         }
[17:39:25.522]         {
[17:39:25.522]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.522]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.522]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.522]             })
[17:39:25.522]         }
[17:39:25.522]     }, args = future.call.arguments)
[17:39:25.522] }
[17:39:25.522] Lazy evaluation: FALSE
[17:39:25.522] Asynchronous evaluation: FALSE
[17:39:25.522] Local evaluation: TRUE
[17:39:25.522] Environment: R_GlobalEnv
[17:39:25.522] Capture standard output: TRUE
[17:39:25.522] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.522] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.522] Packages: 1 packages (‘stats’)
[17:39:25.522] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.522] Resolved: TRUE
[17:39:25.522] Value: 26.06 KiB of class ‘list’
[17:39:25.522] Early signaling: FALSE
[17:39:25.522] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.522] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.524] Chunk #1 of 1 ... DONE
[17:39:25.524] Launching 1 futures (chunks) ... DONE
[17:39:25.524] Resolving 1 futures (chunks) ...
[17:39:25.524] resolve() on list ...
[17:39:25.524]  recursive: 0
[17:39:25.524]  length: 1
[17:39:25.525] 
[17:39:25.525] resolved() for ‘SequentialFuture’ ...
[17:39:25.525] - state: ‘finished’
[17:39:25.525] - run: TRUE
[17:39:25.525] - result: ‘FutureResult’
[17:39:25.525] resolved() for ‘SequentialFuture’ ... done
[17:39:25.525] Future #1
[17:39:25.525] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.525] - nx: 1
[17:39:25.526] - relay: TRUE
[17:39:25.526] - stdout: TRUE
[17:39:25.526] - signal: TRUE
[17:39:25.526] - resignal: FALSE
[17:39:25.526] - force: TRUE
[17:39:25.526] - relayed: [n=1] FALSE
[17:39:25.526] - queued futures: [n=1] FALSE
[17:39:25.526]  - until=1
[17:39:25.526]  - relaying element #1
[17:39:25.526] - relayed: [n=1] TRUE
[17:39:25.526] - queued futures: [n=1] TRUE
[17:39:25.527] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.527]  length: 0 (resolved future 1)
[17:39:25.527] Relaying remaining futures
[17:39:25.527] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.527] - nx: 1
[17:39:25.527] - relay: TRUE
[17:39:25.527] - stdout: TRUE
[17:39:25.527] - signal: TRUE
[17:39:25.527] - resignal: FALSE
[17:39:25.527] - force: TRUE
[17:39:25.527] - relayed: [n=1] TRUE
[17:39:25.528] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.528] - relayed: [n=1] TRUE
[17:39:25.528] - queued futures: [n=1] TRUE
[17:39:25.528] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.528] resolve() on list ... DONE
[17:39:25.528]  - Number of value chunks collected: 1
[17:39:25.528] Resolving 1 futures (chunks) ... DONE
[17:39:25.528] Reducing values from 1 chunks ...
[17:39:25.528]  - Number of values collected after concatenation: 3
[17:39:25.528]  - Number of values expected: 3
[17:39:25.529] Reducing values from 1 chunks ... DONE
[17:39:25.529] future_lapply() ... DONE
[17:39:25.529] future_by_internal() ... DONE
[17:39:25.534] future_by_internal() ...
[17:39:25.534] future_lapply() ...
[17:39:25.538] Number of chunks: 1
[17:39:25.538] getGlobalsAndPackagesXApply() ...
[17:39:25.538]  - future.globals: TRUE
[17:39:25.539] getGlobalsAndPackages() ...
[17:39:25.539] Searching for globals...
[17:39:25.540] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:25.540] Searching for globals ... DONE
[17:39:25.541] Resolving globals: FALSE
[17:39:25.541] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:39:25.541] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:39:25.542] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:25.542] - packages: [1] ‘stats’
[17:39:25.542] getGlobalsAndPackages() ... DONE
[17:39:25.542]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:25.542]  - needed namespaces: [n=1] ‘stats’
[17:39:25.542] Finding globals ... DONE
[17:39:25.542]  - use_args: TRUE
[17:39:25.542]  - Getting '...' globals ...
[17:39:25.543] resolve() on list ...
[17:39:25.543]  recursive: 0
[17:39:25.543]  length: 1
[17:39:25.543]  elements: ‘...’
[17:39:25.543]  length: 0 (resolved future 1)
[17:39:25.543] resolve() on list ... DONE
[17:39:25.543]    - '...' content: [n=0] 
[17:39:25.543] List of 1
[17:39:25.543]  $ ...: list()
[17:39:25.543]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.543]  - attr(*, "where")=List of 1
[17:39:25.543]   ..$ ...:<environment: 0x56296f4036b0> 
[17:39:25.543]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.543]  - attr(*, "resolved")= logi TRUE
[17:39:25.543]  - attr(*, "total_size")= num NA
[17:39:25.546]  - Getting '...' globals ... DONE
[17:39:25.546] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:39:25.546] List of 4
[17:39:25.546]  $ ...future.FUN:function (x)  
[17:39:25.546]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:25.546]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.546]  $ ...          : list()
[17:39:25.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.546]  - attr(*, "where")=List of 4
[17:39:25.546]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.546]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:39:25.546]   ..$ wool         :<environment: R_EmptyEnv> 
[17:39:25.546]   ..$ ...          :<environment: 0x56296f4036b0> 
[17:39:25.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.546]  - attr(*, "resolved")= logi FALSE
[17:39:25.546]  - attr(*, "total_size")= num 2320
[17:39:25.551] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:25.551] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.551] Number of futures (= number of chunks): 1
[17:39:25.551] Launching 1 futures (chunks) ...
[17:39:25.552] Chunk #1 of 1 ...
[17:39:25.552]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.552] getGlobalsAndPackages() ...
[17:39:25.552] Searching for globals...
[17:39:25.552] 
[17:39:25.552] Searching for globals ... DONE
[17:39:25.553] - globals: [0] <none>
[17:39:25.553] getGlobalsAndPackages() ... DONE
[17:39:25.553]    + additional globals found: [n=0] 
[17:39:25.553]    + additional namespaces needed: [n=0] 
[17:39:25.553]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.553]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.553]  - seeds: <none>
[17:39:25.553] getGlobalsAndPackages() ...
[17:39:25.553] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.553] Resolving globals: FALSE
[17:39:25.554] Tweak future expression to call with '...' arguments ...
[17:39:25.554] {
[17:39:25.554]     do.call(function(...) {
[17:39:25.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.554]             on.exit(options(oopts), add = TRUE)
[17:39:25.554]         }
[17:39:25.554]         {
[17:39:25.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.554]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.554]             })
[17:39:25.554]         }
[17:39:25.554]     }, args = future.call.arguments)
[17:39:25.554] }
[17:39:25.554] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.554] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.554] 
[17:39:25.555] getGlobalsAndPackages() ... DONE
[17:39:25.555] run() for ‘Future’ ...
[17:39:25.555] - state: ‘created’
[17:39:25.555] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.559] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.559]   - Field: ‘label’
[17:39:25.559]   - Field: ‘local’
[17:39:25.559]   - Field: ‘owner’
[17:39:25.559]   - Field: ‘envir’
[17:39:25.559]   - Field: ‘packages’
[17:39:25.559]   - Field: ‘gc’
[17:39:25.559]   - Field: ‘conditions’
[17:39:25.560]   - Field: ‘expr’
[17:39:25.560]   - Field: ‘uuid’
[17:39:25.560]   - Field: ‘seed’
[17:39:25.560]   - Field: ‘version’
[17:39:25.560]   - Field: ‘result’
[17:39:25.560]   - Field: ‘asynchronous’
[17:39:25.560]   - Field: ‘calls’
[17:39:25.560]   - Field: ‘globals’
[17:39:25.560]   - Field: ‘stdout’
[17:39:25.560]   - Field: ‘earlySignal’
[17:39:25.561]   - Field: ‘lazy’
[17:39:25.561]   - Field: ‘state’
[17:39:25.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.561] - Launch lazy future ...
[17:39:25.561] Packages needed by the future expression (n = 1): ‘stats’
[17:39:25.561] Packages needed by future strategies (n = 0): <none>
[17:39:25.562] {
[17:39:25.562]     {
[17:39:25.562]         {
[17:39:25.562]             ...future.startTime <- base::Sys.time()
[17:39:25.562]             {
[17:39:25.562]                 {
[17:39:25.562]                   {
[17:39:25.562]                     {
[17:39:25.562]                       base::local({
[17:39:25.562]                         has_future <- base::requireNamespace("future", 
[17:39:25.562]                           quietly = TRUE)
[17:39:25.562]                         if (has_future) {
[17:39:25.562]                           ns <- base::getNamespace("future")
[17:39:25.562]                           version <- ns[[".package"]][["version"]]
[17:39:25.562]                           if (is.null(version)) 
[17:39:25.562]                             version <- utils::packageVersion("future")
[17:39:25.562]                         }
[17:39:25.562]                         else {
[17:39:25.562]                           version <- NULL
[17:39:25.562]                         }
[17:39:25.562]                         if (!has_future || version < "1.8.0") {
[17:39:25.562]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.562]                             "", base::R.version$version.string), 
[17:39:25.562]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:25.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.562]                               "release", "version")], collapse = " "), 
[17:39:25.562]                             hostname = base::Sys.info()[["nodename"]])
[17:39:25.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.562]                             info)
[17:39:25.562]                           info <- base::paste(info, collapse = "; ")
[17:39:25.562]                           if (!has_future) {
[17:39:25.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.562]                               info)
[17:39:25.562]                           }
[17:39:25.562]                           else {
[17:39:25.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.562]                               info, version)
[17:39:25.562]                           }
[17:39:25.562]                           base::stop(msg)
[17:39:25.562]                         }
[17:39:25.562]                       })
[17:39:25.562]                     }
[17:39:25.562]                     base::local({
[17:39:25.562]                       for (pkg in "stats") {
[17:39:25.562]                         base::loadNamespace(pkg)
[17:39:25.562]                         base::library(pkg, character.only = TRUE)
[17:39:25.562]                       }
[17:39:25.562]                     })
[17:39:25.562]                   }
[17:39:25.562]                   options(future.plan = NULL)
[17:39:25.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.562]                 }
[17:39:25.562]                 ...future.workdir <- getwd()
[17:39:25.562]             }
[17:39:25.562]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.562]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.562]         }
[17:39:25.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.562]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.562]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.562]             base::names(...future.oldOptions))
[17:39:25.562]     }
[17:39:25.562]     if (FALSE) {
[17:39:25.562]     }
[17:39:25.562]     else {
[17:39:25.562]         if (TRUE) {
[17:39:25.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.562]                 open = "w")
[17:39:25.562]         }
[17:39:25.562]         else {
[17:39:25.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.562]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.562]         }
[17:39:25.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.562]             base::sink(type = "output", split = FALSE)
[17:39:25.562]             base::close(...future.stdout)
[17:39:25.562]         }, add = TRUE)
[17:39:25.562]     }
[17:39:25.562]     ...future.frame <- base::sys.nframe()
[17:39:25.562]     ...future.conditions <- base::list()
[17:39:25.562]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.562]     if (FALSE) {
[17:39:25.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.562]     }
[17:39:25.562]     ...future.result <- base::tryCatch({
[17:39:25.562]         base::withCallingHandlers({
[17:39:25.562]             ...future.value <- base::withVisible(base::local({
[17:39:25.562]                 do.call(function(...) {
[17:39:25.562]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.562]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.562]                     ...future.globals.maxSize)) {
[17:39:25.562]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.562]                     on.exit(options(oopts), add = TRUE)
[17:39:25.562]                   }
[17:39:25.562]                   {
[17:39:25.562]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.562]                       FUN = function(jj) {
[17:39:25.562]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.562]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.562]                       })
[17:39:25.562]                   }
[17:39:25.562]                 }, args = future.call.arguments)
[17:39:25.562]             }))
[17:39:25.562]             future::FutureResult(value = ...future.value$value, 
[17:39:25.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.562]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.562]                     ...future.globalenv.names))
[17:39:25.562]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.562]         }, condition = base::local({
[17:39:25.562]             c <- base::c
[17:39:25.562]             inherits <- base::inherits
[17:39:25.562]             invokeRestart <- base::invokeRestart
[17:39:25.562]             length <- base::length
[17:39:25.562]             list <- base::list
[17:39:25.562]             seq.int <- base::seq.int
[17:39:25.562]             signalCondition <- base::signalCondition
[17:39:25.562]             sys.calls <- base::sys.calls
[17:39:25.562]             `[[` <- base::`[[`
[17:39:25.562]             `+` <- base::`+`
[17:39:25.562]             `<<-` <- base::`<<-`
[17:39:25.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.562]                   3L)]
[17:39:25.562]             }
[17:39:25.562]             function(cond) {
[17:39:25.562]                 is_error <- inherits(cond, "error")
[17:39:25.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.562]                   NULL)
[17:39:25.562]                 if (is_error) {
[17:39:25.562]                   sessionInformation <- function() {
[17:39:25.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.562]                       search = base::search(), system = base::Sys.info())
[17:39:25.562]                   }
[17:39:25.562]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.562]                     cond$call), session = sessionInformation(), 
[17:39:25.562]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.562]                   signalCondition(cond)
[17:39:25.562]                 }
[17:39:25.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.562]                 "immediateCondition"))) {
[17:39:25.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.562]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.562]                   if (TRUE && !signal) {
[17:39:25.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.562]                     {
[17:39:25.562]                       inherits <- base::inherits
[17:39:25.562]                       invokeRestart <- base::invokeRestart
[17:39:25.562]                       is.null <- base::is.null
[17:39:25.562]                       muffled <- FALSE
[17:39:25.562]                       if (inherits(cond, "message")) {
[17:39:25.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.562]                         if (muffled) 
[17:39:25.562]                           invokeRestart("muffleMessage")
[17:39:25.562]                       }
[17:39:25.562]                       else if (inherits(cond, "warning")) {
[17:39:25.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.562]                         if (muffled) 
[17:39:25.562]                           invokeRestart("muffleWarning")
[17:39:25.562]                       }
[17:39:25.562]                       else if (inherits(cond, "condition")) {
[17:39:25.562]                         if (!is.null(pattern)) {
[17:39:25.562]                           computeRestarts <- base::computeRestarts
[17:39:25.562]                           grepl <- base::grepl
[17:39:25.562]                           restarts <- computeRestarts(cond)
[17:39:25.562]                           for (restart in restarts) {
[17:39:25.562]                             name <- restart$name
[17:39:25.562]                             if (is.null(name)) 
[17:39:25.562]                               next
[17:39:25.562]                             if (!grepl(pattern, name)) 
[17:39:25.562]                               next
[17:39:25.562]                             invokeRestart(restart)
[17:39:25.562]                             muffled <- TRUE
[17:39:25.562]                             break
[17:39:25.562]                           }
[17:39:25.562]                         }
[17:39:25.562]                       }
[17:39:25.562]                       invisible(muffled)
[17:39:25.562]                     }
[17:39:25.562]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.562]                   }
[17:39:25.562]                 }
[17:39:25.562]                 else {
[17:39:25.562]                   if (TRUE) {
[17:39:25.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.562]                     {
[17:39:25.562]                       inherits <- base::inherits
[17:39:25.562]                       invokeRestart <- base::invokeRestart
[17:39:25.562]                       is.null <- base::is.null
[17:39:25.562]                       muffled <- FALSE
[17:39:25.562]                       if (inherits(cond, "message")) {
[17:39:25.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.562]                         if (muffled) 
[17:39:25.562]                           invokeRestart("muffleMessage")
[17:39:25.562]                       }
[17:39:25.562]                       else if (inherits(cond, "warning")) {
[17:39:25.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.562]                         if (muffled) 
[17:39:25.562]                           invokeRestart("muffleWarning")
[17:39:25.562]                       }
[17:39:25.562]                       else if (inherits(cond, "condition")) {
[17:39:25.562]                         if (!is.null(pattern)) {
[17:39:25.562]                           computeRestarts <- base::computeRestarts
[17:39:25.562]                           grepl <- base::grepl
[17:39:25.562]                           restarts <- computeRestarts(cond)
[17:39:25.562]                           for (restart in restarts) {
[17:39:25.562]                             name <- restart$name
[17:39:25.562]                             if (is.null(name)) 
[17:39:25.562]                               next
[17:39:25.562]                             if (!grepl(pattern, name)) 
[17:39:25.562]                               next
[17:39:25.562]                             invokeRestart(restart)
[17:39:25.562]                             muffled <- TRUE
[17:39:25.562]                             break
[17:39:25.562]                           }
[17:39:25.562]                         }
[17:39:25.562]                       }
[17:39:25.562]                       invisible(muffled)
[17:39:25.562]                     }
[17:39:25.562]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.562]                   }
[17:39:25.562]                 }
[17:39:25.562]             }
[17:39:25.562]         }))
[17:39:25.562]     }, error = function(ex) {
[17:39:25.562]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.562]                 ...future.rng), started = ...future.startTime, 
[17:39:25.562]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.562]             version = "1.8"), class = "FutureResult")
[17:39:25.562]     }, finally = {
[17:39:25.562]         if (!identical(...future.workdir, getwd())) 
[17:39:25.562]             setwd(...future.workdir)
[17:39:25.562]         {
[17:39:25.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.562]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.562]             }
[17:39:25.562]             base::options(...future.oldOptions)
[17:39:25.562]             if (.Platform$OS.type == "windows") {
[17:39:25.562]                 old_names <- names(...future.oldEnvVars)
[17:39:25.562]                 envs <- base::Sys.getenv()
[17:39:25.562]                 names <- names(envs)
[17:39:25.562]                 common <- intersect(names, old_names)
[17:39:25.562]                 added <- setdiff(names, old_names)
[17:39:25.562]                 removed <- setdiff(old_names, names)
[17:39:25.562]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.562]                   envs[common]]
[17:39:25.562]                 NAMES <- toupper(changed)
[17:39:25.562]                 args <- list()
[17:39:25.562]                 for (kk in seq_along(NAMES)) {
[17:39:25.562]                   name <- changed[[kk]]
[17:39:25.562]                   NAME <- NAMES[[kk]]
[17:39:25.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.562]                     next
[17:39:25.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.562]                 }
[17:39:25.562]                 NAMES <- toupper(added)
[17:39:25.562]                 for (kk in seq_along(NAMES)) {
[17:39:25.562]                   name <- added[[kk]]
[17:39:25.562]                   NAME <- NAMES[[kk]]
[17:39:25.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.562]                     next
[17:39:25.562]                   args[[name]] <- ""
[17:39:25.562]                 }
[17:39:25.562]                 NAMES <- toupper(removed)
[17:39:25.562]                 for (kk in seq_along(NAMES)) {
[17:39:25.562]                   name <- removed[[kk]]
[17:39:25.562]                   NAME <- NAMES[[kk]]
[17:39:25.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.562]                     next
[17:39:25.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.562]                 }
[17:39:25.562]                 if (length(args) > 0) 
[17:39:25.562]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.562]             }
[17:39:25.562]             else {
[17:39:25.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.562]             }
[17:39:25.562]             {
[17:39:25.562]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.562]                   0L) {
[17:39:25.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.562]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.562]                   base::options(opts)
[17:39:25.562]                 }
[17:39:25.562]                 {
[17:39:25.562]                   {
[17:39:25.562]                     NULL
[17:39:25.562]                     RNGkind("Mersenne-Twister")
[17:39:25.562]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.562]                       inherits = FALSE)
[17:39:25.562]                   }
[17:39:25.562]                   options(future.plan = NULL)
[17:39:25.562]                   if (is.na(NA_character_)) 
[17:39:25.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.562]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:25.562]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:25.562]                     envir = parent.frame()) 
[17:39:25.562]                   {
[17:39:25.562]                     if (is.function(workers)) 
[17:39:25.562]                       workers <- workers()
[17:39:25.562]                     workers <- structure(as.integer(workers), 
[17:39:25.562]                       class = class(workers))
[17:39:25.562]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:25.562]                       workers >= 1)
[17:39:25.562]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:25.562]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:25.562]                     }
[17:39:25.562]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:25.562]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:25.562]                       envir = envir)
[17:39:25.562]                     if (!future$lazy) 
[17:39:25.562]                       future <- run(future)
[17:39:25.562]                     invisible(future)
[17:39:25.562]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.562]                 }
[17:39:25.562]             }
[17:39:25.562]         }
[17:39:25.562]     })
[17:39:25.562]     if (TRUE) {
[17:39:25.562]         base::sink(type = "output", split = FALSE)
[17:39:25.562]         if (TRUE) {
[17:39:25.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.562]         }
[17:39:25.562]         else {
[17:39:25.562]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.562]         }
[17:39:25.562]         base::close(...future.stdout)
[17:39:25.562]         ...future.stdout <- NULL
[17:39:25.562]     }
[17:39:25.562]     ...future.result$conditions <- ...future.conditions
[17:39:25.562]     ...future.result$finished <- base::Sys.time()
[17:39:25.562]     ...future.result
[17:39:25.562] }
[17:39:25.564] assign_globals() ...
[17:39:25.564] List of 7
[17:39:25.564]  $ ...future.FUN            :function (x)  
[17:39:25.564]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:25.564]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.564]  $ future.call.arguments    : list()
[17:39:25.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.564]  $ ...future.elements_ii    :List of 3
[17:39:25.564]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.564]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.564]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.564]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.564]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.564]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.564]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.564]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.564]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.564]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.564]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.564]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.564]  $ ...future.seeds_ii       : NULL
[17:39:25.564]  $ ...future.globals.maxSize: NULL
[17:39:25.564]  - attr(*, "resolved")= logi FALSE
[17:39:25.564]  - attr(*, "total_size")= num 2320
[17:39:25.564]  - attr(*, "where")=List of 7
[17:39:25.564]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.564]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:39:25.564]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:39:25.564]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.564]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.564]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.564]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.564]  - attr(*, "already-done")= logi TRUE
[17:39:25.576] - reassign environment for ‘...future.FUN’
[17:39:25.576] - copied ‘...future.FUN’ to environment
[17:39:25.576] - copied ‘breaks’ to environment
[17:39:25.576] - copied ‘wool’ to environment
[17:39:25.576] - copied ‘future.call.arguments’ to environment
[17:39:25.576] - copied ‘...future.elements_ii’ to environment
[17:39:25.577] - copied ‘...future.seeds_ii’ to environment
[17:39:25.577] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.577] assign_globals() ... done
[17:39:25.577] plan(): Setting new future strategy stack:
[17:39:25.577] List of future strategies:
[17:39:25.577] 1. sequential:
[17:39:25.577]    - args: function (..., envir = parent.frame())
[17:39:25.577]    - tweaked: FALSE
[17:39:25.577]    - call: NULL
[17:39:25.578] plan(): nbrOfWorkers() = 1
[17:39:25.581] plan(): Setting new future strategy stack:
[17:39:25.581] List of future strategies:
[17:39:25.581] 1. multisession:
[17:39:25.581]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:25.581]    - tweaked: FALSE
[17:39:25.581]    - call: plan(strategy)
[17:39:25.585] plan(): nbrOfWorkers() = 1
[17:39:25.585] SequentialFuture started (and completed)
[17:39:25.585] - Launch lazy future ... done
[17:39:25.585] run() for ‘SequentialFuture’ ... done
[17:39:25.585] Created future:
[17:39:25.585] SequentialFuture:
[17:39:25.585] Label: ‘future_by-1’
[17:39:25.585] Expression:
[17:39:25.585] {
[17:39:25.585]     do.call(function(...) {
[17:39:25.585]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.585]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.585]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.585]             on.exit(options(oopts), add = TRUE)
[17:39:25.585]         }
[17:39:25.585]         {
[17:39:25.585]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.585]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.585]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.585]             })
[17:39:25.585]         }
[17:39:25.585]     }, args = future.call.arguments)
[17:39:25.585] }
[17:39:25.585] Lazy evaluation: FALSE
[17:39:25.585] Asynchronous evaluation: FALSE
[17:39:25.585] Local evaluation: TRUE
[17:39:25.585] Environment: 0x56296f5a00e0
[17:39:25.585] Capture standard output: TRUE
[17:39:25.585] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.585] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:39:25.585] Packages: 1 packages (‘stats’)
[17:39:25.585] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.585] Resolved: TRUE
[17:39:25.585] Value: 25.57 KiB of class ‘list’
[17:39:25.585] Early signaling: FALSE
[17:39:25.585] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.585] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.587] Chunk #1 of 1 ... DONE
[17:39:25.587] Launching 1 futures (chunks) ... DONE
[17:39:25.587] Resolving 1 futures (chunks) ...
[17:39:25.587] resolve() on list ...
[17:39:25.587]  recursive: 0
[17:39:25.588]  length: 1
[17:39:25.588] 
[17:39:25.588] resolved() for ‘SequentialFuture’ ...
[17:39:25.588] - state: ‘finished’
[17:39:25.588] - run: TRUE
[17:39:25.588] - result: ‘FutureResult’
[17:39:25.588] resolved() for ‘SequentialFuture’ ... done
[17:39:25.588] Future #1
[17:39:25.588] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.588] - nx: 1
[17:39:25.589] - relay: TRUE
[17:39:25.589] - stdout: TRUE
[17:39:25.589] - signal: TRUE
[17:39:25.589] - resignal: FALSE
[17:39:25.589] - force: TRUE
[17:39:25.589] - relayed: [n=1] FALSE
[17:39:25.589] - queued futures: [n=1] FALSE
[17:39:25.589]  - until=1
[17:39:25.589]  - relaying element #1
[17:39:25.589] - relayed: [n=1] TRUE
[17:39:25.590] - queued futures: [n=1] TRUE
[17:39:25.590] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.590]  length: 0 (resolved future 1)
[17:39:25.590] Relaying remaining futures
[17:39:25.590] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.590] - nx: 1
[17:39:25.590] - relay: TRUE
[17:39:25.590] - stdout: TRUE
[17:39:25.590] - signal: TRUE
[17:39:25.590] - resignal: FALSE
[17:39:25.590] - force: TRUE
[17:39:25.591] - relayed: [n=1] TRUE
[17:39:25.591] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.591] - relayed: [n=1] TRUE
[17:39:25.591] - queued futures: [n=1] TRUE
[17:39:25.591] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.591] resolve() on list ... DONE
[17:39:25.591]  - Number of value chunks collected: 1
[17:39:25.591] Resolving 1 futures (chunks) ... DONE
[17:39:25.591] Reducing values from 1 chunks ...
[17:39:25.592]  - Number of values collected after concatenation: 3
[17:39:25.592]  - Number of values expected: 3
[17:39:25.592] Reducing values from 1 chunks ... DONE
[17:39:25.592] future_lapply() ... DONE
[17:39:25.592] future_by_internal() ... DONE
[17:39:25.592] future_by_internal() ...
[17:39:25.593] future_lapply() ...
[17:39:25.596] Number of chunks: 1
[17:39:25.597] getGlobalsAndPackagesXApply() ...
[17:39:25.597]  - future.globals: TRUE
[17:39:25.597] getGlobalsAndPackages() ...
[17:39:25.597] Searching for globals...
[17:39:25.598] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.598] Searching for globals ... DONE
[17:39:25.598] Resolving globals: FALSE
[17:39:25.598] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.599] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.601] - globals: [1] ‘FUN’
[17:39:25.601] 
[17:39:25.601] getGlobalsAndPackages() ... DONE
[17:39:25.601]  - globals found/used: [n=1] ‘FUN’
[17:39:25.601]  - needed namespaces: [n=0] 
[17:39:25.602] Finding globals ... DONE
[17:39:25.602]  - use_args: TRUE
[17:39:25.602]  - Getting '...' globals ...
[17:39:25.602] resolve() on list ...
[17:39:25.602]  recursive: 0
[17:39:25.602]  length: 1
[17:39:25.602]  elements: ‘...’
[17:39:25.603]  length: 0 (resolved future 1)
[17:39:25.603] resolve() on list ... DONE
[17:39:25.603]    - '...' content: [n=0] 
[17:39:25.603] List of 1
[17:39:25.603]  $ ...: list()
[17:39:25.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.603]  - attr(*, "where")=List of 1
[17:39:25.603]   ..$ ...:<environment: 0x562970b78a30> 
[17:39:25.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.603]  - attr(*, "resolved")= logi TRUE
[17:39:25.603]  - attr(*, "total_size")= num NA
[17:39:25.606]  - Getting '...' globals ... DONE
[17:39:25.606] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.606] List of 2
[17:39:25.606]  $ ...future.FUN:function (object, ...)  
[17:39:25.606]  $ ...          : list()
[17:39:25.606]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.606]  - attr(*, "where")=List of 2
[17:39:25.606]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.606]   ..$ ...          :<environment: 0x562970b78a30> 
[17:39:25.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.606]  - attr(*, "resolved")= logi FALSE
[17:39:25.606]  - attr(*, "total_size")= num 1240
[17:39:25.609] Packages to be attached in all futures: [n=0] 
[17:39:25.609] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.609] Number of futures (= number of chunks): 1
[17:39:25.609] Launching 1 futures (chunks) ...
[17:39:25.609] Chunk #1 of 1 ...
[17:39:25.609]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.610] getGlobalsAndPackages() ...
[17:39:25.610] Searching for globals...
[17:39:25.610] 
[17:39:25.610] Searching for globals ... DONE
[17:39:25.610] - globals: [0] <none>
[17:39:25.610] getGlobalsAndPackages() ... DONE
[17:39:25.611]    + additional globals found: [n=0] 
[17:39:25.611]    + additional namespaces needed: [n=0] 
[17:39:25.611]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.611]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.611]  - seeds: <none>
[17:39:25.611] getGlobalsAndPackages() ...
[17:39:25.611] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.611] Resolving globals: FALSE
[17:39:25.612] Tweak future expression to call with '...' arguments ...
[17:39:25.612] {
[17:39:25.612]     do.call(function(...) {
[17:39:25.612]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.612]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.612]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.612]             on.exit(options(oopts), add = TRUE)
[17:39:25.612]         }
[17:39:25.612]         {
[17:39:25.612]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.612]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.612]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.612]             })
[17:39:25.612]         }
[17:39:25.612]     }, args = future.call.arguments)
[17:39:25.612] }
[17:39:25.612] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.612] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.612] 
[17:39:25.613] getGlobalsAndPackages() ... DONE
[17:39:25.613] run() for ‘Future’ ...
[17:39:25.613] - state: ‘created’
[17:39:25.613] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.617] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.617]   - Field: ‘label’
[17:39:25.617]   - Field: ‘local’
[17:39:25.617]   - Field: ‘owner’
[17:39:25.618]   - Field: ‘envir’
[17:39:25.618]   - Field: ‘packages’
[17:39:25.618]   - Field: ‘gc’
[17:39:25.618]   - Field: ‘conditions’
[17:39:25.618]   - Field: ‘expr’
[17:39:25.618]   - Field: ‘uuid’
[17:39:25.618]   - Field: ‘seed’
[17:39:25.618]   - Field: ‘version’
[17:39:25.618]   - Field: ‘result’
[17:39:25.619]   - Field: ‘asynchronous’
[17:39:25.619]   - Field: ‘calls’
[17:39:25.619]   - Field: ‘globals’
[17:39:25.619]   - Field: ‘stdout’
[17:39:25.619]   - Field: ‘earlySignal’
[17:39:25.619]   - Field: ‘lazy’
[17:39:25.619]   - Field: ‘state’
[17:39:25.619] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.619] - Launch lazy future ...
[17:39:25.620] Packages needed by the future expression (n = 0): <none>
[17:39:25.620] Packages needed by future strategies (n = 0): <none>
[17:39:25.620] {
[17:39:25.620]     {
[17:39:25.620]         {
[17:39:25.620]             ...future.startTime <- base::Sys.time()
[17:39:25.620]             {
[17:39:25.620]                 {
[17:39:25.620]                   {
[17:39:25.620]                     base::local({
[17:39:25.620]                       has_future <- base::requireNamespace("future", 
[17:39:25.620]                         quietly = TRUE)
[17:39:25.620]                       if (has_future) {
[17:39:25.620]                         ns <- base::getNamespace("future")
[17:39:25.620]                         version <- ns[[".package"]][["version"]]
[17:39:25.620]                         if (is.null(version)) 
[17:39:25.620]                           version <- utils::packageVersion("future")
[17:39:25.620]                       }
[17:39:25.620]                       else {
[17:39:25.620]                         version <- NULL
[17:39:25.620]                       }
[17:39:25.620]                       if (!has_future || version < "1.8.0") {
[17:39:25.620]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.620]                           "", base::R.version$version.string), 
[17:39:25.620]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.620]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.620]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.620]                             "release", "version")], collapse = " "), 
[17:39:25.620]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.620]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.620]                           info)
[17:39:25.620]                         info <- base::paste(info, collapse = "; ")
[17:39:25.620]                         if (!has_future) {
[17:39:25.620]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.620]                             info)
[17:39:25.620]                         }
[17:39:25.620]                         else {
[17:39:25.620]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.620]                             info, version)
[17:39:25.620]                         }
[17:39:25.620]                         base::stop(msg)
[17:39:25.620]                       }
[17:39:25.620]                     })
[17:39:25.620]                   }
[17:39:25.620]                   options(future.plan = NULL)
[17:39:25.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.620]                 }
[17:39:25.620]                 ...future.workdir <- getwd()
[17:39:25.620]             }
[17:39:25.620]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.620]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.620]         }
[17:39:25.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.620]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.620]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.620]             base::names(...future.oldOptions))
[17:39:25.620]     }
[17:39:25.620]     if (FALSE) {
[17:39:25.620]     }
[17:39:25.620]     else {
[17:39:25.620]         if (TRUE) {
[17:39:25.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.620]                 open = "w")
[17:39:25.620]         }
[17:39:25.620]         else {
[17:39:25.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.620]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.620]         }
[17:39:25.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.620]             base::sink(type = "output", split = FALSE)
[17:39:25.620]             base::close(...future.stdout)
[17:39:25.620]         }, add = TRUE)
[17:39:25.620]     }
[17:39:25.620]     ...future.frame <- base::sys.nframe()
[17:39:25.620]     ...future.conditions <- base::list()
[17:39:25.620]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.620]     if (FALSE) {
[17:39:25.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.620]     }
[17:39:25.620]     ...future.result <- base::tryCatch({
[17:39:25.620]         base::withCallingHandlers({
[17:39:25.620]             ...future.value <- base::withVisible(base::local({
[17:39:25.620]                 do.call(function(...) {
[17:39:25.620]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.620]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.620]                     ...future.globals.maxSize)) {
[17:39:25.620]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.620]                     on.exit(options(oopts), add = TRUE)
[17:39:25.620]                   }
[17:39:25.620]                   {
[17:39:25.620]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.620]                       FUN = function(jj) {
[17:39:25.620]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.620]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.620]                       })
[17:39:25.620]                   }
[17:39:25.620]                 }, args = future.call.arguments)
[17:39:25.620]             }))
[17:39:25.620]             future::FutureResult(value = ...future.value$value, 
[17:39:25.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.620]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.620]                     ...future.globalenv.names))
[17:39:25.620]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.620]         }, condition = base::local({
[17:39:25.620]             c <- base::c
[17:39:25.620]             inherits <- base::inherits
[17:39:25.620]             invokeRestart <- base::invokeRestart
[17:39:25.620]             length <- base::length
[17:39:25.620]             list <- base::list
[17:39:25.620]             seq.int <- base::seq.int
[17:39:25.620]             signalCondition <- base::signalCondition
[17:39:25.620]             sys.calls <- base::sys.calls
[17:39:25.620]             `[[` <- base::`[[`
[17:39:25.620]             `+` <- base::`+`
[17:39:25.620]             `<<-` <- base::`<<-`
[17:39:25.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.620]                   3L)]
[17:39:25.620]             }
[17:39:25.620]             function(cond) {
[17:39:25.620]                 is_error <- inherits(cond, "error")
[17:39:25.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.620]                   NULL)
[17:39:25.620]                 if (is_error) {
[17:39:25.620]                   sessionInformation <- function() {
[17:39:25.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.620]                       search = base::search(), system = base::Sys.info())
[17:39:25.620]                   }
[17:39:25.620]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.620]                     cond$call), session = sessionInformation(), 
[17:39:25.620]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.620]                   signalCondition(cond)
[17:39:25.620]                 }
[17:39:25.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.620]                 "immediateCondition"))) {
[17:39:25.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.620]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.620]                   if (TRUE && !signal) {
[17:39:25.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.620]                     {
[17:39:25.620]                       inherits <- base::inherits
[17:39:25.620]                       invokeRestart <- base::invokeRestart
[17:39:25.620]                       is.null <- base::is.null
[17:39:25.620]                       muffled <- FALSE
[17:39:25.620]                       if (inherits(cond, "message")) {
[17:39:25.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.620]                         if (muffled) 
[17:39:25.620]                           invokeRestart("muffleMessage")
[17:39:25.620]                       }
[17:39:25.620]                       else if (inherits(cond, "warning")) {
[17:39:25.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.620]                         if (muffled) 
[17:39:25.620]                           invokeRestart("muffleWarning")
[17:39:25.620]                       }
[17:39:25.620]                       else if (inherits(cond, "condition")) {
[17:39:25.620]                         if (!is.null(pattern)) {
[17:39:25.620]                           computeRestarts <- base::computeRestarts
[17:39:25.620]                           grepl <- base::grepl
[17:39:25.620]                           restarts <- computeRestarts(cond)
[17:39:25.620]                           for (restart in restarts) {
[17:39:25.620]                             name <- restart$name
[17:39:25.620]                             if (is.null(name)) 
[17:39:25.620]                               next
[17:39:25.620]                             if (!grepl(pattern, name)) 
[17:39:25.620]                               next
[17:39:25.620]                             invokeRestart(restart)
[17:39:25.620]                             muffled <- TRUE
[17:39:25.620]                             break
[17:39:25.620]                           }
[17:39:25.620]                         }
[17:39:25.620]                       }
[17:39:25.620]                       invisible(muffled)
[17:39:25.620]                     }
[17:39:25.620]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.620]                   }
[17:39:25.620]                 }
[17:39:25.620]                 else {
[17:39:25.620]                   if (TRUE) {
[17:39:25.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.620]                     {
[17:39:25.620]                       inherits <- base::inherits
[17:39:25.620]                       invokeRestart <- base::invokeRestart
[17:39:25.620]                       is.null <- base::is.null
[17:39:25.620]                       muffled <- FALSE
[17:39:25.620]                       if (inherits(cond, "message")) {
[17:39:25.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.620]                         if (muffled) 
[17:39:25.620]                           invokeRestart("muffleMessage")
[17:39:25.620]                       }
[17:39:25.620]                       else if (inherits(cond, "warning")) {
[17:39:25.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.620]                         if (muffled) 
[17:39:25.620]                           invokeRestart("muffleWarning")
[17:39:25.620]                       }
[17:39:25.620]                       else if (inherits(cond, "condition")) {
[17:39:25.620]                         if (!is.null(pattern)) {
[17:39:25.620]                           computeRestarts <- base::computeRestarts
[17:39:25.620]                           grepl <- base::grepl
[17:39:25.620]                           restarts <- computeRestarts(cond)
[17:39:25.620]                           for (restart in restarts) {
[17:39:25.620]                             name <- restart$name
[17:39:25.620]                             if (is.null(name)) 
[17:39:25.620]                               next
[17:39:25.620]                             if (!grepl(pattern, name)) 
[17:39:25.620]                               next
[17:39:25.620]                             invokeRestart(restart)
[17:39:25.620]                             muffled <- TRUE
[17:39:25.620]                             break
[17:39:25.620]                           }
[17:39:25.620]                         }
[17:39:25.620]                       }
[17:39:25.620]                       invisible(muffled)
[17:39:25.620]                     }
[17:39:25.620]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.620]                   }
[17:39:25.620]                 }
[17:39:25.620]             }
[17:39:25.620]         }))
[17:39:25.620]     }, error = function(ex) {
[17:39:25.620]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.620]                 ...future.rng), started = ...future.startTime, 
[17:39:25.620]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.620]             version = "1.8"), class = "FutureResult")
[17:39:25.620]     }, finally = {
[17:39:25.620]         if (!identical(...future.workdir, getwd())) 
[17:39:25.620]             setwd(...future.workdir)
[17:39:25.620]         {
[17:39:25.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.620]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.620]             }
[17:39:25.620]             base::options(...future.oldOptions)
[17:39:25.620]             if (.Platform$OS.type == "windows") {
[17:39:25.620]                 old_names <- names(...future.oldEnvVars)
[17:39:25.620]                 envs <- base::Sys.getenv()
[17:39:25.620]                 names <- names(envs)
[17:39:25.620]                 common <- intersect(names, old_names)
[17:39:25.620]                 added <- setdiff(names, old_names)
[17:39:25.620]                 removed <- setdiff(old_names, names)
[17:39:25.620]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.620]                   envs[common]]
[17:39:25.620]                 NAMES <- toupper(changed)
[17:39:25.620]                 args <- list()
[17:39:25.620]                 for (kk in seq_along(NAMES)) {
[17:39:25.620]                   name <- changed[[kk]]
[17:39:25.620]                   NAME <- NAMES[[kk]]
[17:39:25.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.620]                     next
[17:39:25.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.620]                 }
[17:39:25.620]                 NAMES <- toupper(added)
[17:39:25.620]                 for (kk in seq_along(NAMES)) {
[17:39:25.620]                   name <- added[[kk]]
[17:39:25.620]                   NAME <- NAMES[[kk]]
[17:39:25.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.620]                     next
[17:39:25.620]                   args[[name]] <- ""
[17:39:25.620]                 }
[17:39:25.620]                 NAMES <- toupper(removed)
[17:39:25.620]                 for (kk in seq_along(NAMES)) {
[17:39:25.620]                   name <- removed[[kk]]
[17:39:25.620]                   NAME <- NAMES[[kk]]
[17:39:25.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.620]                     next
[17:39:25.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.620]                 }
[17:39:25.620]                 if (length(args) > 0) 
[17:39:25.620]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.620]             }
[17:39:25.620]             else {
[17:39:25.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.620]             }
[17:39:25.620]             {
[17:39:25.620]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.620]                   0L) {
[17:39:25.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.620]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.620]                   base::options(opts)
[17:39:25.620]                 }
[17:39:25.620]                 {
[17:39:25.620]                   {
[17:39:25.620]                     NULL
[17:39:25.620]                     RNGkind("Mersenne-Twister")
[17:39:25.620]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.620]                       inherits = FALSE)
[17:39:25.620]                   }
[17:39:25.620]                   options(future.plan = NULL)
[17:39:25.620]                   if (is.na(NA_character_)) 
[17:39:25.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.620]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:25.620]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:25.620]                     envir = parent.frame()) 
[17:39:25.620]                   {
[17:39:25.620]                     if (is.function(workers)) 
[17:39:25.620]                       workers <- workers()
[17:39:25.620]                     workers <- structure(as.integer(workers), 
[17:39:25.620]                       class = class(workers))
[17:39:25.620]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:25.620]                       workers >= 1)
[17:39:25.620]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:25.620]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:25.620]                     }
[17:39:25.620]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:25.620]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:25.620]                       envir = envir)
[17:39:25.620]                     if (!future$lazy) 
[17:39:25.620]                       future <- run(future)
[17:39:25.620]                     invisible(future)
[17:39:25.620]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.620]                 }
[17:39:25.620]             }
[17:39:25.620]         }
[17:39:25.620]     })
[17:39:25.620]     if (TRUE) {
[17:39:25.620]         base::sink(type = "output", split = FALSE)
[17:39:25.620]         if (TRUE) {
[17:39:25.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.620]         }
[17:39:25.620]         else {
[17:39:25.620]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.620]         }
[17:39:25.620]         base::close(...future.stdout)
[17:39:25.620]         ...future.stdout <- NULL
[17:39:25.620]     }
[17:39:25.620]     ...future.result$conditions <- ...future.conditions
[17:39:25.620]     ...future.result$finished <- base::Sys.time()
[17:39:25.620]     ...future.result
[17:39:25.620] }
[17:39:25.622] assign_globals() ...
[17:39:25.622] List of 5
[17:39:25.622]  $ ...future.FUN            :function (object, ...)  
[17:39:25.622]  $ future.call.arguments    : list()
[17:39:25.622]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.622]  $ ...future.elements_ii    :List of 3
[17:39:25.622]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.622]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.622]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.622]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.622]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.622]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.622]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.622]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.622]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.622]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.622]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.622]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.622]  $ ...future.seeds_ii       : NULL
[17:39:25.622]  $ ...future.globals.maxSize: NULL
[17:39:25.622]  - attr(*, "resolved")= logi FALSE
[17:39:25.622]  - attr(*, "total_size")= num 1240
[17:39:25.622]  - attr(*, "where")=List of 5
[17:39:25.622]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.622]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.622]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.622]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.622]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.622]  - attr(*, "already-done")= logi TRUE
[17:39:25.634] - copied ‘...future.FUN’ to environment
[17:39:25.634] - copied ‘future.call.arguments’ to environment
[17:39:25.634] - copied ‘...future.elements_ii’ to environment
[17:39:25.634] - copied ‘...future.seeds_ii’ to environment
[17:39:25.635] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.635] assign_globals() ... done
[17:39:25.635] plan(): Setting new future strategy stack:
[17:39:25.635] List of future strategies:
[17:39:25.635] 1. sequential:
[17:39:25.635]    - args: function (..., envir = parent.frame())
[17:39:25.635]    - tweaked: FALSE
[17:39:25.635]    - call: NULL
[17:39:25.635] plan(): nbrOfWorkers() = 1
[17:39:25.638] plan(): Setting new future strategy stack:
[17:39:25.638] List of future strategies:
[17:39:25.638] 1. multisession:
[17:39:25.638]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:25.638]    - tweaked: FALSE
[17:39:25.638]    - call: plan(strategy)
[17:39:25.642] plan(): nbrOfWorkers() = 1
[17:39:25.642] SequentialFuture started (and completed)
[17:39:25.642] - Launch lazy future ... done
[17:39:25.642] run() for ‘SequentialFuture’ ... done
[17:39:25.642] Created future:
[17:39:25.642] SequentialFuture:
[17:39:25.642] Label: ‘future_by-1’
[17:39:25.642] Expression:
[17:39:25.642] {
[17:39:25.642]     do.call(function(...) {
[17:39:25.642]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.642]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.642]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.642]             on.exit(options(oopts), add = TRUE)
[17:39:25.642]         }
[17:39:25.642]         {
[17:39:25.642]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.642]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.642]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.642]             })
[17:39:25.642]         }
[17:39:25.642]     }, args = future.call.arguments)
[17:39:25.642] }
[17:39:25.642] Lazy evaluation: FALSE
[17:39:25.642] Asynchronous evaluation: FALSE
[17:39:25.642] Local evaluation: TRUE
[17:39:25.642] Environment: 0x562970a94080
[17:39:25.642] Capture standard output: TRUE
[17:39:25.642] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.642] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.642] Packages: <none>
[17:39:25.642] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.642] Resolved: TRUE
[17:39:25.642] Value: 5.37 KiB of class ‘list’
[17:39:25.642] Early signaling: FALSE
[17:39:25.642] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.642] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.644] Chunk #1 of 1 ... DONE
[17:39:25.644] Launching 1 futures (chunks) ... DONE
[17:39:25.644] Resolving 1 futures (chunks) ...
[17:39:25.644] resolve() on list ...
[17:39:25.644]  recursive: 0
[17:39:25.644]  length: 1
[17:39:25.644] 
[17:39:25.644] resolved() for ‘SequentialFuture’ ...
[17:39:25.645] - state: ‘finished’
[17:39:25.645] - run: TRUE
[17:39:25.645] - result: ‘FutureResult’
[17:39:25.645] resolved() for ‘SequentialFuture’ ... done
[17:39:25.645] Future #1
[17:39:25.645] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.645] - nx: 1
[17:39:25.645] - relay: TRUE
[17:39:25.645] - stdout: TRUE
[17:39:25.645] - signal: TRUE
[17:39:25.646] - resignal: FALSE
[17:39:25.646] - force: TRUE
[17:39:25.646] - relayed: [n=1] FALSE
[17:39:25.646] - queued futures: [n=1] FALSE
[17:39:25.646]  - until=1
[17:39:25.646]  - relaying element #1
[17:39:25.646] - relayed: [n=1] TRUE
[17:39:25.646] - queued futures: [n=1] TRUE
[17:39:25.646] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.647]  length: 0 (resolved future 1)
[17:39:25.647] Relaying remaining futures
[17:39:25.647] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.647] - nx: 1
[17:39:25.647] - relay: TRUE
[17:39:25.647] - stdout: TRUE
[17:39:25.647] - signal: TRUE
[17:39:25.647] - resignal: FALSE
[17:39:25.647] - force: TRUE
[17:39:25.647] - relayed: [n=1] TRUE
[17:39:25.647] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.648] - relayed: [n=1] TRUE
[17:39:25.648] - queued futures: [n=1] TRUE
[17:39:25.651] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.651] resolve() on list ... DONE
[17:39:25.651]  - Number of value chunks collected: 1
[17:39:25.651] Resolving 1 futures (chunks) ... DONE
[17:39:25.652] Reducing values from 1 chunks ...
[17:39:25.652]  - Number of values collected after concatenation: 3
[17:39:25.652]  - Number of values expected: 3
[17:39:25.652] Reducing values from 1 chunks ... DONE
[17:39:25.652] future_lapply() ... DONE
[17:39:25.652] future_by_internal() ... DONE
[17:39:25.653] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:39:25.654] future_lapply() ...
[17:39:25.658] Number of chunks: 1
[17:39:25.658] getGlobalsAndPackagesXApply() ...
[17:39:25.658]  - future.globals: TRUE
[17:39:25.658] getGlobalsAndPackages() ...
[17:39:25.658] Searching for globals...
[17:39:25.659] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.659] Searching for globals ... DONE
[17:39:25.659] Resolving globals: FALSE
[17:39:25.660] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.660] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.660] - globals: [1] ‘FUN’
[17:39:25.660] 
[17:39:25.660] getGlobalsAndPackages() ... DONE
[17:39:25.661]  - globals found/used: [n=1] ‘FUN’
[17:39:25.661]  - needed namespaces: [n=0] 
[17:39:25.661] Finding globals ... DONE
[17:39:25.661]  - use_args: TRUE
[17:39:25.661]  - Getting '...' globals ...
[17:39:25.661] resolve() on list ...
[17:39:25.661]  recursive: 0
[17:39:25.661]  length: 1
[17:39:25.662]  elements: ‘...’
[17:39:25.662]  length: 0 (resolved future 1)
[17:39:25.662] resolve() on list ... DONE
[17:39:25.662]    - '...' content: [n=0] 
[17:39:25.662] List of 1
[17:39:25.662]  $ ...: list()
[17:39:25.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.662]  - attr(*, "where")=List of 1
[17:39:25.662]   ..$ ...:<environment: 0x56296f75cbd0> 
[17:39:25.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.662]  - attr(*, "resolved")= logi TRUE
[17:39:25.662]  - attr(*, "total_size")= num NA
[17:39:25.665]  - Getting '...' globals ... DONE
[17:39:25.665] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.665] List of 2
[17:39:25.665]  $ ...future.FUN:function (object, ...)  
[17:39:25.665]  $ ...          : list()
[17:39:25.665]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.665]  - attr(*, "where")=List of 2
[17:39:25.665]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.665]   ..$ ...          :<environment: 0x56296f75cbd0> 
[17:39:25.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.665]  - attr(*, "resolved")= logi FALSE
[17:39:25.665]  - attr(*, "total_size")= num 1240
[17:39:25.668] Packages to be attached in all futures: [n=0] 
[17:39:25.668] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.668] Number of futures (= number of chunks): 1
[17:39:25.668] Launching 1 futures (chunks) ...
[17:39:25.668] Chunk #1 of 1 ...
[17:39:25.668]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.668] getGlobalsAndPackages() ...
[17:39:25.668] Searching for globals...
[17:39:25.669] 
[17:39:25.669] Searching for globals ... DONE
[17:39:25.669] - globals: [0] <none>
[17:39:25.669] getGlobalsAndPackages() ... DONE
[17:39:25.669]    + additional globals found: [n=0] 
[17:39:25.669]    + additional namespaces needed: [n=0] 
[17:39:25.669]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.670]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.670]  - seeds: <none>
[17:39:25.670] getGlobalsAndPackages() ...
[17:39:25.670] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.670] Resolving globals: FALSE
[17:39:25.670] Tweak future expression to call with '...' arguments ...
[17:39:25.670] {
[17:39:25.670]     do.call(function(...) {
[17:39:25.670]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.670]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.670]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.670]             on.exit(options(oopts), add = TRUE)
[17:39:25.670]         }
[17:39:25.670]         {
[17:39:25.670]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.670]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.670]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.670]             })
[17:39:25.670]         }
[17:39:25.670]     }, args = future.call.arguments)
[17:39:25.670] }
[17:39:25.671] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.671] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.671] 
[17:39:25.671] getGlobalsAndPackages() ... DONE
[17:39:25.671] run() for ‘Future’ ...
[17:39:25.672] - state: ‘created’
[17:39:25.672] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:25.676] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.676]   - Field: ‘label’
[17:39:25.676]   - Field: ‘local’
[17:39:25.676]   - Field: ‘owner’
[17:39:25.677]   - Field: ‘envir’
[17:39:25.677]   - Field: ‘packages’
[17:39:25.677]   - Field: ‘gc’
[17:39:25.677]   - Field: ‘conditions’
[17:39:25.677]   - Field: ‘expr’
[17:39:25.677]   - Field: ‘uuid’
[17:39:25.677]   - Field: ‘seed’
[17:39:25.678]   - Field: ‘version’
[17:39:25.678]   - Field: ‘result’
[17:39:25.680]   - Field: ‘asynchronous’
[17:39:25.680]   - Field: ‘calls’
[17:39:25.680]   - Field: ‘globals’
[17:39:25.680]   - Field: ‘stdout’
[17:39:25.681]   - Field: ‘earlySignal’
[17:39:25.681]   - Field: ‘lazy’
[17:39:25.681]   - Field: ‘state’
[17:39:25.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.681] - Launch lazy future ...
[17:39:25.681] Packages needed by the future expression (n = 0): <none>
[17:39:25.682] Packages needed by future strategies (n = 0): <none>
[17:39:25.682] {
[17:39:25.682]     {
[17:39:25.682]         {
[17:39:25.682]             ...future.startTime <- base::Sys.time()
[17:39:25.682]             {
[17:39:25.682]                 {
[17:39:25.682]                   {
[17:39:25.682]                     base::local({
[17:39:25.682]                       has_future <- base::requireNamespace("future", 
[17:39:25.682]                         quietly = TRUE)
[17:39:25.682]                       if (has_future) {
[17:39:25.682]                         ns <- base::getNamespace("future")
[17:39:25.682]                         version <- ns[[".package"]][["version"]]
[17:39:25.682]                         if (is.null(version)) 
[17:39:25.682]                           version <- utils::packageVersion("future")
[17:39:25.682]                       }
[17:39:25.682]                       else {
[17:39:25.682]                         version <- NULL
[17:39:25.682]                       }
[17:39:25.682]                       if (!has_future || version < "1.8.0") {
[17:39:25.682]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.682]                           "", base::R.version$version.string), 
[17:39:25.682]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.682]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.682]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.682]                             "release", "version")], collapse = " "), 
[17:39:25.682]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.682]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.682]                           info)
[17:39:25.682]                         info <- base::paste(info, collapse = "; ")
[17:39:25.682]                         if (!has_future) {
[17:39:25.682]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.682]                             info)
[17:39:25.682]                         }
[17:39:25.682]                         else {
[17:39:25.682]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.682]                             info, version)
[17:39:25.682]                         }
[17:39:25.682]                         base::stop(msg)
[17:39:25.682]                       }
[17:39:25.682]                     })
[17:39:25.682]                   }
[17:39:25.682]                   options(future.plan = NULL)
[17:39:25.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.682]                 }
[17:39:25.682]                 ...future.workdir <- getwd()
[17:39:25.682]             }
[17:39:25.682]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.682]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.682]         }
[17:39:25.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.682]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.682]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.682]             base::names(...future.oldOptions))
[17:39:25.682]     }
[17:39:25.682]     if (FALSE) {
[17:39:25.682]     }
[17:39:25.682]     else {
[17:39:25.682]         if (TRUE) {
[17:39:25.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.682]                 open = "w")
[17:39:25.682]         }
[17:39:25.682]         else {
[17:39:25.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.682]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.682]         }
[17:39:25.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.682]             base::sink(type = "output", split = FALSE)
[17:39:25.682]             base::close(...future.stdout)
[17:39:25.682]         }, add = TRUE)
[17:39:25.682]     }
[17:39:25.682]     ...future.frame <- base::sys.nframe()
[17:39:25.682]     ...future.conditions <- base::list()
[17:39:25.682]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.682]     if (FALSE) {
[17:39:25.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.682]     }
[17:39:25.682]     ...future.result <- base::tryCatch({
[17:39:25.682]         base::withCallingHandlers({
[17:39:25.682]             ...future.value <- base::withVisible(base::local({
[17:39:25.682]                 do.call(function(...) {
[17:39:25.682]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.682]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.682]                     ...future.globals.maxSize)) {
[17:39:25.682]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.682]                     on.exit(options(oopts), add = TRUE)
[17:39:25.682]                   }
[17:39:25.682]                   {
[17:39:25.682]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.682]                       FUN = function(jj) {
[17:39:25.682]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.682]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.682]                       })
[17:39:25.682]                   }
[17:39:25.682]                 }, args = future.call.arguments)
[17:39:25.682]             }))
[17:39:25.682]             future::FutureResult(value = ...future.value$value, 
[17:39:25.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.682]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.682]                     ...future.globalenv.names))
[17:39:25.682]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.682]         }, condition = base::local({
[17:39:25.682]             c <- base::c
[17:39:25.682]             inherits <- base::inherits
[17:39:25.682]             invokeRestart <- base::invokeRestart
[17:39:25.682]             length <- base::length
[17:39:25.682]             list <- base::list
[17:39:25.682]             seq.int <- base::seq.int
[17:39:25.682]             signalCondition <- base::signalCondition
[17:39:25.682]             sys.calls <- base::sys.calls
[17:39:25.682]             `[[` <- base::`[[`
[17:39:25.682]             `+` <- base::`+`
[17:39:25.682]             `<<-` <- base::`<<-`
[17:39:25.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.682]                   3L)]
[17:39:25.682]             }
[17:39:25.682]             function(cond) {
[17:39:25.682]                 is_error <- inherits(cond, "error")
[17:39:25.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.682]                   NULL)
[17:39:25.682]                 if (is_error) {
[17:39:25.682]                   sessionInformation <- function() {
[17:39:25.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.682]                       search = base::search(), system = base::Sys.info())
[17:39:25.682]                   }
[17:39:25.682]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.682]                     cond$call), session = sessionInformation(), 
[17:39:25.682]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.682]                   signalCondition(cond)
[17:39:25.682]                 }
[17:39:25.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.682]                 "immediateCondition"))) {
[17:39:25.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.682]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.682]                   if (TRUE && !signal) {
[17:39:25.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.682]                     {
[17:39:25.682]                       inherits <- base::inherits
[17:39:25.682]                       invokeRestart <- base::invokeRestart
[17:39:25.682]                       is.null <- base::is.null
[17:39:25.682]                       muffled <- FALSE
[17:39:25.682]                       if (inherits(cond, "message")) {
[17:39:25.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.682]                         if (muffled) 
[17:39:25.682]                           invokeRestart("muffleMessage")
[17:39:25.682]                       }
[17:39:25.682]                       else if (inherits(cond, "warning")) {
[17:39:25.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.682]                         if (muffled) 
[17:39:25.682]                           invokeRestart("muffleWarning")
[17:39:25.682]                       }
[17:39:25.682]                       else if (inherits(cond, "condition")) {
[17:39:25.682]                         if (!is.null(pattern)) {
[17:39:25.682]                           computeRestarts <- base::computeRestarts
[17:39:25.682]                           grepl <- base::grepl
[17:39:25.682]                           restarts <- computeRestarts(cond)
[17:39:25.682]                           for (restart in restarts) {
[17:39:25.682]                             name <- restart$name
[17:39:25.682]                             if (is.null(name)) 
[17:39:25.682]                               next
[17:39:25.682]                             if (!grepl(pattern, name)) 
[17:39:25.682]                               next
[17:39:25.682]                             invokeRestart(restart)
[17:39:25.682]                             muffled <- TRUE
[17:39:25.682]                             break
[17:39:25.682]                           }
[17:39:25.682]                         }
[17:39:25.682]                       }
[17:39:25.682]                       invisible(muffled)
[17:39:25.682]                     }
[17:39:25.682]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.682]                   }
[17:39:25.682]                 }
[17:39:25.682]                 else {
[17:39:25.682]                   if (TRUE) {
[17:39:25.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.682]                     {
[17:39:25.682]                       inherits <- base::inherits
[17:39:25.682]                       invokeRestart <- base::invokeRestart
[17:39:25.682]                       is.null <- base::is.null
[17:39:25.682]                       muffled <- FALSE
[17:39:25.682]                       if (inherits(cond, "message")) {
[17:39:25.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.682]                         if (muffled) 
[17:39:25.682]                           invokeRestart("muffleMessage")
[17:39:25.682]                       }
[17:39:25.682]                       else if (inherits(cond, "warning")) {
[17:39:25.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.682]                         if (muffled) 
[17:39:25.682]                           invokeRestart("muffleWarning")
[17:39:25.682]                       }
[17:39:25.682]                       else if (inherits(cond, "condition")) {
[17:39:25.682]                         if (!is.null(pattern)) {
[17:39:25.682]                           computeRestarts <- base::computeRestarts
[17:39:25.682]                           grepl <- base::grepl
[17:39:25.682]                           restarts <- computeRestarts(cond)
[17:39:25.682]                           for (restart in restarts) {
[17:39:25.682]                             name <- restart$name
[17:39:25.682]                             if (is.null(name)) 
[17:39:25.682]                               next
[17:39:25.682]                             if (!grepl(pattern, name)) 
[17:39:25.682]                               next
[17:39:25.682]                             invokeRestart(restart)
[17:39:25.682]                             muffled <- TRUE
[17:39:25.682]                             break
[17:39:25.682]                           }
[17:39:25.682]                         }
[17:39:25.682]                       }
[17:39:25.682]                       invisible(muffled)
[17:39:25.682]                     }
[17:39:25.682]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.682]                   }
[17:39:25.682]                 }
[17:39:25.682]             }
[17:39:25.682]         }))
[17:39:25.682]     }, error = function(ex) {
[17:39:25.682]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.682]                 ...future.rng), started = ...future.startTime, 
[17:39:25.682]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.682]             version = "1.8"), class = "FutureResult")
[17:39:25.682]     }, finally = {
[17:39:25.682]         if (!identical(...future.workdir, getwd())) 
[17:39:25.682]             setwd(...future.workdir)
[17:39:25.682]         {
[17:39:25.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.682]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.682]             }
[17:39:25.682]             base::options(...future.oldOptions)
[17:39:25.682]             if (.Platform$OS.type == "windows") {
[17:39:25.682]                 old_names <- names(...future.oldEnvVars)
[17:39:25.682]                 envs <- base::Sys.getenv()
[17:39:25.682]                 names <- names(envs)
[17:39:25.682]                 common <- intersect(names, old_names)
[17:39:25.682]                 added <- setdiff(names, old_names)
[17:39:25.682]                 removed <- setdiff(old_names, names)
[17:39:25.682]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.682]                   envs[common]]
[17:39:25.682]                 NAMES <- toupper(changed)
[17:39:25.682]                 args <- list()
[17:39:25.682]                 for (kk in seq_along(NAMES)) {
[17:39:25.682]                   name <- changed[[kk]]
[17:39:25.682]                   NAME <- NAMES[[kk]]
[17:39:25.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.682]                     next
[17:39:25.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.682]                 }
[17:39:25.682]                 NAMES <- toupper(added)
[17:39:25.682]                 for (kk in seq_along(NAMES)) {
[17:39:25.682]                   name <- added[[kk]]
[17:39:25.682]                   NAME <- NAMES[[kk]]
[17:39:25.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.682]                     next
[17:39:25.682]                   args[[name]] <- ""
[17:39:25.682]                 }
[17:39:25.682]                 NAMES <- toupper(removed)
[17:39:25.682]                 for (kk in seq_along(NAMES)) {
[17:39:25.682]                   name <- removed[[kk]]
[17:39:25.682]                   NAME <- NAMES[[kk]]
[17:39:25.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.682]                     next
[17:39:25.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.682]                 }
[17:39:25.682]                 if (length(args) > 0) 
[17:39:25.682]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.682]             }
[17:39:25.682]             else {
[17:39:25.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.682]             }
[17:39:25.682]             {
[17:39:25.682]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.682]                   0L) {
[17:39:25.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.682]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.682]                   base::options(opts)
[17:39:25.682]                 }
[17:39:25.682]                 {
[17:39:25.682]                   {
[17:39:25.682]                     NULL
[17:39:25.682]                     RNGkind("Mersenne-Twister")
[17:39:25.682]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.682]                       inherits = FALSE)
[17:39:25.682]                   }
[17:39:25.682]                   options(future.plan = NULL)
[17:39:25.682]                   if (is.na(NA_character_)) 
[17:39:25.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.682]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:25.682]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:25.682]                     envir = parent.frame()) 
[17:39:25.682]                   {
[17:39:25.682]                     if (is.function(workers)) 
[17:39:25.682]                       workers <- workers()
[17:39:25.682]                     workers <- structure(as.integer(workers), 
[17:39:25.682]                       class = class(workers))
[17:39:25.682]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:25.682]                       workers >= 1)
[17:39:25.682]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:25.682]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:25.682]                     }
[17:39:25.682]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:25.682]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:25.682]                       envir = envir)
[17:39:25.682]                     if (!future$lazy) 
[17:39:25.682]                       future <- run(future)
[17:39:25.682]                     invisible(future)
[17:39:25.682]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.682]                 }
[17:39:25.682]             }
[17:39:25.682]         }
[17:39:25.682]     })
[17:39:25.682]     if (TRUE) {
[17:39:25.682]         base::sink(type = "output", split = FALSE)
[17:39:25.682]         if (TRUE) {
[17:39:25.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.682]         }
[17:39:25.682]         else {
[17:39:25.682]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.682]         }
[17:39:25.682]         base::close(...future.stdout)
[17:39:25.682]         ...future.stdout <- NULL
[17:39:25.682]     }
[17:39:25.682]     ...future.result$conditions <- ...future.conditions
[17:39:25.682]     ...future.result$finished <- base::Sys.time()
[17:39:25.682]     ...future.result
[17:39:25.682] }
[17:39:25.685] assign_globals() ...
[17:39:25.685] List of 5
[17:39:25.685]  $ ...future.FUN            :function (object, ...)  
[17:39:25.685]  $ future.call.arguments    : list()
[17:39:25.685]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.685]  $ ...future.elements_ii    :List of 3
[17:39:25.685]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.685]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.685]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.685]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.685]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.685]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.685]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.685]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.685]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.685]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.685]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.685]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.685]  $ ...future.seeds_ii       : NULL
[17:39:25.685]  $ ...future.globals.maxSize: NULL
[17:39:25.685]  - attr(*, "resolved")= logi FALSE
[17:39:25.685]  - attr(*, "total_size")= num 1240
[17:39:25.685]  - attr(*, "where")=List of 5
[17:39:25.685]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.685]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.685]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.685]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.685]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.685]  - attr(*, "already-done")= logi TRUE
[17:39:25.697] - copied ‘...future.FUN’ to environment
[17:39:25.697] - copied ‘future.call.arguments’ to environment
[17:39:25.697] - copied ‘...future.elements_ii’ to environment
[17:39:25.697] - copied ‘...future.seeds_ii’ to environment
[17:39:25.697] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.698] assign_globals() ... done
[17:39:25.698] plan(): Setting new future strategy stack:
[17:39:25.698] List of future strategies:
[17:39:25.698] 1. sequential:
[17:39:25.698]    - args: function (..., envir = parent.frame())
[17:39:25.698]    - tweaked: FALSE
[17:39:25.698]    - call: NULL
[17:39:25.699] plan(): nbrOfWorkers() = 1
[17:39:25.701] plan(): Setting new future strategy stack:
[17:39:25.701] List of future strategies:
[17:39:25.701] 1. multisession:
[17:39:25.701]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:25.701]    - tweaked: FALSE
[17:39:25.701]    - call: plan(strategy)
[17:39:25.705] plan(): nbrOfWorkers() = 1
[17:39:25.705] SequentialFuture started (and completed)
[17:39:25.706] - Launch lazy future ... done
[17:39:25.706] run() for ‘SequentialFuture’ ... done
[17:39:25.706] Created future:
[17:39:25.706] SequentialFuture:
[17:39:25.706] Label: ‘future_by-1’
[17:39:25.706] Expression:
[17:39:25.706] {
[17:39:25.706]     do.call(function(...) {
[17:39:25.706]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.706]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.706]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.706]             on.exit(options(oopts), add = TRUE)
[17:39:25.706]         }
[17:39:25.706]         {
[17:39:25.706]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.706]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.706]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.706]             })
[17:39:25.706]         }
[17:39:25.706]     }, args = future.call.arguments)
[17:39:25.706] }
[17:39:25.706] Lazy evaluation: FALSE
[17:39:25.706] Asynchronous evaluation: FALSE
[17:39:25.706] Local evaluation: TRUE
[17:39:25.706] Environment: 0x56296f59e888
[17:39:25.706] Capture standard output: TRUE
[17:39:25.706] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.706] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.706] Packages: <none>
[17:39:25.706] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.706] Resolved: TRUE
[17:39:25.706] Value: 5.37 KiB of class ‘list’
[17:39:25.706] Early signaling: FALSE
[17:39:25.706] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.706] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.707] Chunk #1 of 1 ... DONE
[17:39:25.707] Launching 1 futures (chunks) ... DONE
[17:39:25.708] Resolving 1 futures (chunks) ...
[17:39:25.708] resolve() on list ...
[17:39:25.708]  recursive: 0
[17:39:25.708]  length: 1
[17:39:25.708] 
[17:39:25.708] resolved() for ‘SequentialFuture’ ...
[17:39:25.708] - state: ‘finished’
[17:39:25.708] - run: TRUE
[17:39:25.708] - result: ‘FutureResult’
[17:39:25.708] resolved() for ‘SequentialFuture’ ... done
[17:39:25.709] Future #1
[17:39:25.709] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.709] - nx: 1
[17:39:25.709] - relay: TRUE
[17:39:25.709] - stdout: TRUE
[17:39:25.709] - signal: TRUE
[17:39:25.709] - resignal: FALSE
[17:39:25.709] - force: TRUE
[17:39:25.709] - relayed: [n=1] FALSE
[17:39:25.709] - queued futures: [n=1] FALSE
[17:39:25.710]  - until=1
[17:39:25.710]  - relaying element #1
[17:39:25.712] - relayed: [n=1] TRUE
[17:39:25.712] - queued futures: [n=1] TRUE
[17:39:25.712] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.712]  length: 0 (resolved future 1)
[17:39:25.712] Relaying remaining futures
[17:39:25.712] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.712] - nx: 1
[17:39:25.712] - relay: TRUE
[17:39:25.713] - stdout: TRUE
[17:39:25.713] - signal: TRUE
[17:39:25.713] - resignal: FALSE
[17:39:25.713] - force: TRUE
[17:39:25.713] - relayed: [n=1] TRUE
[17:39:25.713] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.714] - relayed: [n=1] TRUE
[17:39:25.714] - queued futures: [n=1] TRUE
[17:39:25.714] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.714] resolve() on list ... DONE
[17:39:25.714]  - Number of value chunks collected: 1
[17:39:25.714] Resolving 1 futures (chunks) ... DONE
[17:39:25.714] Reducing values from 1 chunks ...
[17:39:25.714]  - Number of values collected after concatenation: 3
[17:39:25.715]  - Number of values expected: 3
[17:39:25.715] Reducing values from 1 chunks ... DONE
[17:39:25.715] future_lapply() ... DONE
[17:39:25.715] future_by_internal() ... DONE
[17:39:25.716] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[17:39:25.717] plan(): Setting new future strategy stack:
[17:39:25.717] List of future strategies:
[17:39:25.717] 1. sequential:
[17:39:25.717]    - args: function (..., envir = parent.frame())
[17:39:25.717]    - tweaked: FALSE
[17:39:25.717]    - call: plan(strategy)
[17:39:25.717] plan(): nbrOfWorkers() = 1
[17:39:25.718] future_by_internal() ...
[17:39:25.718] future_lapply() ...
[17:39:25.718] Number of chunks: 1
[17:39:25.719] getGlobalsAndPackagesXApply() ...
[17:39:25.719]  - future.globals: TRUE
[17:39:25.719] getGlobalsAndPackages() ...
[17:39:25.719] Searching for globals...
[17:39:25.720] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.720] Searching for globals ... DONE
[17:39:25.720] Resolving globals: FALSE
[17:39:25.720] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.721] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.721] - globals: [1] ‘FUN’
[17:39:25.721] 
[17:39:25.721] getGlobalsAndPackages() ... DONE
[17:39:25.721]  - globals found/used: [n=1] ‘FUN’
[17:39:25.721]  - needed namespaces: [n=0] 
[17:39:25.721] Finding globals ... DONE
[17:39:25.721]  - use_args: TRUE
[17:39:25.722]  - Getting '...' globals ...
[17:39:25.722] resolve() on list ...
[17:39:25.722]  recursive: 0
[17:39:25.722]  length: 1
[17:39:25.722]  elements: ‘...’
[17:39:25.722]  length: 0 (resolved future 1)
[17:39:25.722] resolve() on list ... DONE
[17:39:25.722]    - '...' content: [n=0] 
[17:39:25.723] List of 1
[17:39:25.723]  $ ...: list()
[17:39:25.723]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.723]  - attr(*, "where")=List of 1
[17:39:25.723]   ..$ ...:<environment: 0x56296fc53be8> 
[17:39:25.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.723]  - attr(*, "resolved")= logi TRUE
[17:39:25.723]  - attr(*, "total_size")= num NA
[17:39:25.725]  - Getting '...' globals ... DONE
[17:39:25.725] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.725] List of 2
[17:39:25.725]  $ ...future.FUN:function (object, ...)  
[17:39:25.725]  $ ...          : list()
[17:39:25.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.725]  - attr(*, "where")=List of 2
[17:39:25.725]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.725]   ..$ ...          :<environment: 0x56296fc53be8> 
[17:39:25.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.725]  - attr(*, "resolved")= logi FALSE
[17:39:25.725]  - attr(*, "total_size")= num 1240
[17:39:25.728] Packages to be attached in all futures: [n=0] 
[17:39:25.728] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.728] Number of futures (= number of chunks): 1
[17:39:25.728] Launching 1 futures (chunks) ...
[17:39:25.729] Chunk #1 of 1 ...
[17:39:25.729]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.729] getGlobalsAndPackages() ...
[17:39:25.729] Searching for globals...
[17:39:25.729] 
[17:39:25.729] Searching for globals ... DONE
[17:39:25.730] - globals: [0] <none>
[17:39:25.730] getGlobalsAndPackages() ... DONE
[17:39:25.730]    + additional globals found: [n=0] 
[17:39:25.730]    + additional namespaces needed: [n=0] 
[17:39:25.730]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.730]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.730]  - seeds: <none>
[17:39:25.730] getGlobalsAndPackages() ...
[17:39:25.730] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.730] Resolving globals: FALSE
[17:39:25.731] Tweak future expression to call with '...' arguments ...
[17:39:25.731] {
[17:39:25.731]     do.call(function(...) {
[17:39:25.731]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.731]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.731]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.731]             on.exit(options(oopts), add = TRUE)
[17:39:25.731]         }
[17:39:25.731]         {
[17:39:25.731]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.731]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.731]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.731]             })
[17:39:25.731]         }
[17:39:25.731]     }, args = future.call.arguments)
[17:39:25.731] }
[17:39:25.731] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.731] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.731] 
[17:39:25.732] getGlobalsAndPackages() ... DONE
[17:39:25.732] run() for ‘Future’ ...
[17:39:25.732] - state: ‘created’
[17:39:25.732] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:25.732] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.734]   - Field: ‘label’
[17:39:25.734]   - Field: ‘local’
[17:39:25.734]   - Field: ‘owner’
[17:39:25.734]   - Field: ‘envir’
[17:39:25.735]   - Field: ‘packages’
[17:39:25.735]   - Field: ‘gc’
[17:39:25.735]   - Field: ‘conditions’
[17:39:25.735]   - Field: ‘expr’
[17:39:25.735]   - Field: ‘uuid’
[17:39:25.735]   - Field: ‘seed’
[17:39:25.735]   - Field: ‘version’
[17:39:25.735]   - Field: ‘result’
[17:39:25.735]   - Field: ‘asynchronous’
[17:39:25.736]   - Field: ‘calls’
[17:39:25.736]   - Field: ‘globals’
[17:39:25.736]   - Field: ‘stdout’
[17:39:25.736]   - Field: ‘earlySignal’
[17:39:25.736]   - Field: ‘lazy’
[17:39:25.736]   - Field: ‘state’
[17:39:25.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.736] - Launch lazy future ...
[17:39:25.736] Packages needed by the future expression (n = 0): <none>
[17:39:25.737] Packages needed by future strategies (n = 0): <none>
[17:39:25.737] {
[17:39:25.737]     {
[17:39:25.737]         {
[17:39:25.737]             ...future.startTime <- base::Sys.time()
[17:39:25.737]             {
[17:39:25.737]                 {
[17:39:25.737]                   {
[17:39:25.737]                     base::local({
[17:39:25.737]                       has_future <- base::requireNamespace("future", 
[17:39:25.737]                         quietly = TRUE)
[17:39:25.737]                       if (has_future) {
[17:39:25.737]                         ns <- base::getNamespace("future")
[17:39:25.737]                         version <- ns[[".package"]][["version"]]
[17:39:25.737]                         if (is.null(version)) 
[17:39:25.737]                           version <- utils::packageVersion("future")
[17:39:25.737]                       }
[17:39:25.737]                       else {
[17:39:25.737]                         version <- NULL
[17:39:25.737]                       }
[17:39:25.737]                       if (!has_future || version < "1.8.0") {
[17:39:25.737]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.737]                           "", base::R.version$version.string), 
[17:39:25.737]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.737]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.737]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.737]                             "release", "version")], collapse = " "), 
[17:39:25.737]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.737]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.737]                           info)
[17:39:25.737]                         info <- base::paste(info, collapse = "; ")
[17:39:25.737]                         if (!has_future) {
[17:39:25.737]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.737]                             info)
[17:39:25.737]                         }
[17:39:25.737]                         else {
[17:39:25.737]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.737]                             info, version)
[17:39:25.737]                         }
[17:39:25.737]                         base::stop(msg)
[17:39:25.737]                       }
[17:39:25.737]                     })
[17:39:25.737]                   }
[17:39:25.737]                   options(future.plan = NULL)
[17:39:25.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.737]                 }
[17:39:25.737]                 ...future.workdir <- getwd()
[17:39:25.737]             }
[17:39:25.737]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.737]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.737]         }
[17:39:25.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.737]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.737]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.737]             base::names(...future.oldOptions))
[17:39:25.737]     }
[17:39:25.737]     if (FALSE) {
[17:39:25.737]     }
[17:39:25.737]     else {
[17:39:25.737]         if (TRUE) {
[17:39:25.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.737]                 open = "w")
[17:39:25.737]         }
[17:39:25.737]         else {
[17:39:25.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.737]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.737]         }
[17:39:25.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.737]             base::sink(type = "output", split = FALSE)
[17:39:25.737]             base::close(...future.stdout)
[17:39:25.737]         }, add = TRUE)
[17:39:25.737]     }
[17:39:25.737]     ...future.frame <- base::sys.nframe()
[17:39:25.737]     ...future.conditions <- base::list()
[17:39:25.737]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.737]     if (FALSE) {
[17:39:25.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.737]     }
[17:39:25.737]     ...future.result <- base::tryCatch({
[17:39:25.737]         base::withCallingHandlers({
[17:39:25.737]             ...future.value <- base::withVisible(base::local({
[17:39:25.737]                 do.call(function(...) {
[17:39:25.737]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.737]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.737]                     ...future.globals.maxSize)) {
[17:39:25.737]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.737]                     on.exit(options(oopts), add = TRUE)
[17:39:25.737]                   }
[17:39:25.737]                   {
[17:39:25.737]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.737]                       FUN = function(jj) {
[17:39:25.737]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.737]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.737]                       })
[17:39:25.737]                   }
[17:39:25.737]                 }, args = future.call.arguments)
[17:39:25.737]             }))
[17:39:25.737]             future::FutureResult(value = ...future.value$value, 
[17:39:25.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.737]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.737]                     ...future.globalenv.names))
[17:39:25.737]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.737]         }, condition = base::local({
[17:39:25.737]             c <- base::c
[17:39:25.737]             inherits <- base::inherits
[17:39:25.737]             invokeRestart <- base::invokeRestart
[17:39:25.737]             length <- base::length
[17:39:25.737]             list <- base::list
[17:39:25.737]             seq.int <- base::seq.int
[17:39:25.737]             signalCondition <- base::signalCondition
[17:39:25.737]             sys.calls <- base::sys.calls
[17:39:25.737]             `[[` <- base::`[[`
[17:39:25.737]             `+` <- base::`+`
[17:39:25.737]             `<<-` <- base::`<<-`
[17:39:25.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.737]                   3L)]
[17:39:25.737]             }
[17:39:25.737]             function(cond) {
[17:39:25.737]                 is_error <- inherits(cond, "error")
[17:39:25.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.737]                   NULL)
[17:39:25.737]                 if (is_error) {
[17:39:25.737]                   sessionInformation <- function() {
[17:39:25.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.737]                       search = base::search(), system = base::Sys.info())
[17:39:25.737]                   }
[17:39:25.737]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.737]                     cond$call), session = sessionInformation(), 
[17:39:25.737]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.737]                   signalCondition(cond)
[17:39:25.737]                 }
[17:39:25.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.737]                 "immediateCondition"))) {
[17:39:25.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.737]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.737]                   if (TRUE && !signal) {
[17:39:25.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.737]                     {
[17:39:25.737]                       inherits <- base::inherits
[17:39:25.737]                       invokeRestart <- base::invokeRestart
[17:39:25.737]                       is.null <- base::is.null
[17:39:25.737]                       muffled <- FALSE
[17:39:25.737]                       if (inherits(cond, "message")) {
[17:39:25.737]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.737]                         if (muffled) 
[17:39:25.737]                           invokeRestart("muffleMessage")
[17:39:25.737]                       }
[17:39:25.737]                       else if (inherits(cond, "warning")) {
[17:39:25.737]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.737]                         if (muffled) 
[17:39:25.737]                           invokeRestart("muffleWarning")
[17:39:25.737]                       }
[17:39:25.737]                       else if (inherits(cond, "condition")) {
[17:39:25.737]                         if (!is.null(pattern)) {
[17:39:25.737]                           computeRestarts <- base::computeRestarts
[17:39:25.737]                           grepl <- base::grepl
[17:39:25.737]                           restarts <- computeRestarts(cond)
[17:39:25.737]                           for (restart in restarts) {
[17:39:25.737]                             name <- restart$name
[17:39:25.737]                             if (is.null(name)) 
[17:39:25.737]                               next
[17:39:25.737]                             if (!grepl(pattern, name)) 
[17:39:25.737]                               next
[17:39:25.737]                             invokeRestart(restart)
[17:39:25.737]                             muffled <- TRUE
[17:39:25.737]                             break
[17:39:25.737]                           }
[17:39:25.737]                         }
[17:39:25.737]                       }
[17:39:25.737]                       invisible(muffled)
[17:39:25.737]                     }
[17:39:25.737]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.737]                   }
[17:39:25.737]                 }
[17:39:25.737]                 else {
[17:39:25.737]                   if (TRUE) {
[17:39:25.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.737]                     {
[17:39:25.737]                       inherits <- base::inherits
[17:39:25.737]                       invokeRestart <- base::invokeRestart
[17:39:25.737]                       is.null <- base::is.null
[17:39:25.737]                       muffled <- FALSE
[17:39:25.737]                       if (inherits(cond, "message")) {
[17:39:25.737]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.737]                         if (muffled) 
[17:39:25.737]                           invokeRestart("muffleMessage")
[17:39:25.737]                       }
[17:39:25.737]                       else if (inherits(cond, "warning")) {
[17:39:25.737]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.737]                         if (muffled) 
[17:39:25.737]                           invokeRestart("muffleWarning")
[17:39:25.737]                       }
[17:39:25.737]                       else if (inherits(cond, "condition")) {
[17:39:25.737]                         if (!is.null(pattern)) {
[17:39:25.737]                           computeRestarts <- base::computeRestarts
[17:39:25.737]                           grepl <- base::grepl
[17:39:25.737]                           restarts <- computeRestarts(cond)
[17:39:25.737]                           for (restart in restarts) {
[17:39:25.737]                             name <- restart$name
[17:39:25.737]                             if (is.null(name)) 
[17:39:25.737]                               next
[17:39:25.737]                             if (!grepl(pattern, name)) 
[17:39:25.737]                               next
[17:39:25.737]                             invokeRestart(restart)
[17:39:25.737]                             muffled <- TRUE
[17:39:25.737]                             break
[17:39:25.737]                           }
[17:39:25.737]                         }
[17:39:25.737]                       }
[17:39:25.737]                       invisible(muffled)
[17:39:25.737]                     }
[17:39:25.737]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.737]                   }
[17:39:25.737]                 }
[17:39:25.737]             }
[17:39:25.737]         }))
[17:39:25.737]     }, error = function(ex) {
[17:39:25.737]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.737]                 ...future.rng), started = ...future.startTime, 
[17:39:25.737]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.737]             version = "1.8"), class = "FutureResult")
[17:39:25.737]     }, finally = {
[17:39:25.737]         if (!identical(...future.workdir, getwd())) 
[17:39:25.737]             setwd(...future.workdir)
[17:39:25.737]         {
[17:39:25.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.737]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.737]             }
[17:39:25.737]             base::options(...future.oldOptions)
[17:39:25.737]             if (.Platform$OS.type == "windows") {
[17:39:25.737]                 old_names <- names(...future.oldEnvVars)
[17:39:25.737]                 envs <- base::Sys.getenv()
[17:39:25.737]                 names <- names(envs)
[17:39:25.737]                 common <- intersect(names, old_names)
[17:39:25.737]                 added <- setdiff(names, old_names)
[17:39:25.737]                 removed <- setdiff(old_names, names)
[17:39:25.737]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.737]                   envs[common]]
[17:39:25.737]                 NAMES <- toupper(changed)
[17:39:25.737]                 args <- list()
[17:39:25.737]                 for (kk in seq_along(NAMES)) {
[17:39:25.737]                   name <- changed[[kk]]
[17:39:25.737]                   NAME <- NAMES[[kk]]
[17:39:25.737]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.737]                     next
[17:39:25.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.737]                 }
[17:39:25.737]                 NAMES <- toupper(added)
[17:39:25.737]                 for (kk in seq_along(NAMES)) {
[17:39:25.737]                   name <- added[[kk]]
[17:39:25.737]                   NAME <- NAMES[[kk]]
[17:39:25.737]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.737]                     next
[17:39:25.737]                   args[[name]] <- ""
[17:39:25.737]                 }
[17:39:25.737]                 NAMES <- toupper(removed)
[17:39:25.737]                 for (kk in seq_along(NAMES)) {
[17:39:25.737]                   name <- removed[[kk]]
[17:39:25.737]                   NAME <- NAMES[[kk]]
[17:39:25.737]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.737]                     next
[17:39:25.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.737]                 }
[17:39:25.737]                 if (length(args) > 0) 
[17:39:25.737]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.737]             }
[17:39:25.737]             else {
[17:39:25.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.737]             }
[17:39:25.737]             {
[17:39:25.737]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.737]                   0L) {
[17:39:25.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.737]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.737]                   base::options(opts)
[17:39:25.737]                 }
[17:39:25.737]                 {
[17:39:25.737]                   {
[17:39:25.737]                     NULL
[17:39:25.737]                     RNGkind("Mersenne-Twister")
[17:39:25.737]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.737]                       inherits = FALSE)
[17:39:25.737]                   }
[17:39:25.737]                   options(future.plan = NULL)
[17:39:25.737]                   if (is.na(NA_character_)) 
[17:39:25.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.737]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:25.737]                   {
[17:39:25.737]                     future <- SequentialFuture(..., envir = envir)
[17:39:25.737]                     if (!future$lazy) 
[17:39:25.737]                       future <- run(future)
[17:39:25.737]                     invisible(future)
[17:39:25.737]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.737]                 }
[17:39:25.737]             }
[17:39:25.737]         }
[17:39:25.737]     })
[17:39:25.737]     if (TRUE) {
[17:39:25.737]         base::sink(type = "output", split = FALSE)
[17:39:25.737]         if (TRUE) {
[17:39:25.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.737]         }
[17:39:25.737]         else {
[17:39:25.737]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.737]         }
[17:39:25.737]         base::close(...future.stdout)
[17:39:25.737]         ...future.stdout <- NULL
[17:39:25.737]     }
[17:39:25.737]     ...future.result$conditions <- ...future.conditions
[17:39:25.737]     ...future.result$finished <- base::Sys.time()
[17:39:25.737]     ...future.result
[17:39:25.737] }
[17:39:25.739] assign_globals() ...
[17:39:25.739] List of 5
[17:39:25.739]  $ ...future.FUN            :function (object, ...)  
[17:39:25.739]  $ future.call.arguments    : list()
[17:39:25.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.739]  $ ...future.elements_ii    :List of 3
[17:39:25.739]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:25.739]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.739]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.739]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:25.739]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.739]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.739]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:25.739]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.739]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.739]  $ ...future.seeds_ii       : NULL
[17:39:25.739]  $ ...future.globals.maxSize: NULL
[17:39:25.739]  - attr(*, "resolved")= logi FALSE
[17:39:25.739]  - attr(*, "total_size")= num 1240
[17:39:25.739]  - attr(*, "where")=List of 5
[17:39:25.739]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.739]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.739]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.739]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.739]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.739]  - attr(*, "already-done")= logi TRUE
[17:39:25.747] - copied ‘...future.FUN’ to environment
[17:39:25.747] - copied ‘future.call.arguments’ to environment
[17:39:25.747] - copied ‘...future.elements_ii’ to environment
[17:39:25.747] - copied ‘...future.seeds_ii’ to environment
[17:39:25.747] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.747] assign_globals() ... done
[17:39:25.748] plan(): Setting new future strategy stack:
[17:39:25.748] List of future strategies:
[17:39:25.748] 1. sequential:
[17:39:25.748]    - args: function (..., envir = parent.frame())
[17:39:25.748]    - tweaked: FALSE
[17:39:25.748]    - call: NULL
[17:39:25.748] plan(): nbrOfWorkers() = 1
[17:39:25.750] plan(): Setting new future strategy stack:
[17:39:25.750] List of future strategies:
[17:39:25.750] 1. sequential:
[17:39:25.750]    - args: function (..., envir = parent.frame())
[17:39:25.750]    - tweaked: FALSE
[17:39:25.750]    - call: plan(strategy)
[17:39:25.750] plan(): nbrOfWorkers() = 1
[17:39:25.751] SequentialFuture started (and completed)
[17:39:25.751] - Launch lazy future ... done
[17:39:25.751] run() for ‘SequentialFuture’ ... done
[17:39:25.751] Created future:
[17:39:25.751] SequentialFuture:
[17:39:25.751] Label: ‘future_by-1’
[17:39:25.751] Expression:
[17:39:25.751] {
[17:39:25.751]     do.call(function(...) {
[17:39:25.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.751]             on.exit(options(oopts), add = TRUE)
[17:39:25.751]         }
[17:39:25.751]         {
[17:39:25.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.751]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.751]             })
[17:39:25.751]         }
[17:39:25.751]     }, args = future.call.arguments)
[17:39:25.751] }
[17:39:25.751] Lazy evaluation: FALSE
[17:39:25.751] Asynchronous evaluation: FALSE
[17:39:25.751] Local evaluation: TRUE
[17:39:25.751] Environment: R_GlobalEnv
[17:39:25.751] Capture standard output: TRUE
[17:39:25.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.751] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.751] Packages: <none>
[17:39:25.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.751] Resolved: TRUE
[17:39:25.751] Value: 4.62 KiB of class ‘list’
[17:39:25.751] Early signaling: FALSE
[17:39:25.751] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.751] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.752] Chunk #1 of 1 ... DONE
[17:39:25.752] Launching 1 futures (chunks) ... DONE
[17:39:25.752] Resolving 1 futures (chunks) ...
[17:39:25.752] resolve() on list ...
[17:39:25.753]  recursive: 0
[17:39:25.753]  length: 1
[17:39:25.753] 
[17:39:25.753] resolved() for ‘SequentialFuture’ ...
[17:39:25.753] - state: ‘finished’
[17:39:25.753] - run: TRUE
[17:39:25.753] - result: ‘FutureResult’
[17:39:25.753] resolved() for ‘SequentialFuture’ ... done
[17:39:25.753] Future #1
[17:39:25.754] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.754] - nx: 1
[17:39:25.754] - relay: TRUE
[17:39:25.754] - stdout: TRUE
[17:39:25.754] - signal: TRUE
[17:39:25.754] - resignal: FALSE
[17:39:25.754] - force: TRUE
[17:39:25.754] - relayed: [n=1] FALSE
[17:39:25.754] - queued futures: [n=1] FALSE
[17:39:25.754]  - until=1
[17:39:25.754]  - relaying element #1
[17:39:25.755] - relayed: [n=1] TRUE
[17:39:25.755] - queued futures: [n=1] TRUE
[17:39:25.755] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.755]  length: 0 (resolved future 1)
[17:39:25.755] Relaying remaining futures
[17:39:25.755] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.755] - nx: 1
[17:39:25.755] - relay: TRUE
[17:39:25.755] - stdout: TRUE
[17:39:25.755] - signal: TRUE
[17:39:25.756] - resignal: FALSE
[17:39:25.756] - force: TRUE
[17:39:25.757] - relayed: [n=1] TRUE
[17:39:25.757] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.757] - relayed: [n=1] TRUE
[17:39:25.758] - queued futures: [n=1] TRUE
[17:39:25.758] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.758] resolve() on list ... DONE
[17:39:25.758]  - Number of value chunks collected: 1
[17:39:25.758] Resolving 1 futures (chunks) ... DONE
[17:39:25.758] Reducing values from 1 chunks ...
[17:39:25.758]  - Number of values collected after concatenation: 3
[17:39:25.758]  - Number of values expected: 3
[17:39:25.758] Reducing values from 1 chunks ... DONE
[17:39:25.758] future_lapply() ... DONE
[17:39:25.759] future_by_internal() ... DONE
[17:39:25.759] future_by_internal() ...
[17:39:25.759] future_lapply() ...
[17:39:25.760] Number of chunks: 1
[17:39:25.760] getGlobalsAndPackagesXApply() ...
[17:39:25.760]  - future.globals: TRUE
[17:39:25.760] getGlobalsAndPackages() ...
[17:39:25.760] Searching for globals...
[17:39:25.761] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.761] Searching for globals ... DONE
[17:39:25.761] Resolving globals: FALSE
[17:39:25.762] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.762] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.762] - globals: [1] ‘FUN’
[17:39:25.762] 
[17:39:25.762] getGlobalsAndPackages() ... DONE
[17:39:25.763]  - globals found/used: [n=1] ‘FUN’
[17:39:25.763]  - needed namespaces: [n=0] 
[17:39:25.763] Finding globals ... DONE
[17:39:25.763]  - use_args: TRUE
[17:39:25.763]  - Getting '...' globals ...
[17:39:25.763] resolve() on list ...
[17:39:25.763]  recursive: 0
[17:39:25.763]  length: 1
[17:39:25.764]  elements: ‘...’
[17:39:25.764]  length: 0 (resolved future 1)
[17:39:25.764] resolve() on list ... DONE
[17:39:25.764]    - '...' content: [n=1] ‘digits’
[17:39:25.764] List of 1
[17:39:25.764]  $ ...:List of 1
[17:39:25.764]   ..$ digits: int 2
[17:39:25.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.764]  - attr(*, "where")=List of 1
[17:39:25.764]   ..$ ...:<environment: 0x562970a9eef0> 
[17:39:25.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.764]  - attr(*, "resolved")= logi TRUE
[17:39:25.764]  - attr(*, "total_size")= num NA
[17:39:25.767]  - Getting '...' globals ... DONE
[17:39:25.767] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.767] List of 2
[17:39:25.767]  $ ...future.FUN:function (object, ...)  
[17:39:25.767]  $ ...          :List of 1
[17:39:25.767]   ..$ digits: int 2
[17:39:25.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.767]  - attr(*, "where")=List of 2
[17:39:25.767]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.767]   ..$ ...          :<environment: 0x562970a9eef0> 
[17:39:25.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.767]  - attr(*, "resolved")= logi FALSE
[17:39:25.767]  - attr(*, "total_size")= num 1296
[17:39:25.770] Packages to be attached in all futures: [n=0] 
[17:39:25.770] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.770] Number of futures (= number of chunks): 1
[17:39:25.770] Launching 1 futures (chunks) ...
[17:39:25.770] Chunk #1 of 1 ...
[17:39:25.771]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.771] getGlobalsAndPackages() ...
[17:39:25.771] Searching for globals...
[17:39:25.771] 
[17:39:25.771] Searching for globals ... DONE
[17:39:25.771] - globals: [0] <none>
[17:39:25.771] getGlobalsAndPackages() ... DONE
[17:39:25.771]    + additional globals found: [n=0] 
[17:39:25.771]    + additional namespaces needed: [n=0] 
[17:39:25.772]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.772]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[17:39:25.772]  - seeds: <none>
[17:39:25.772] getGlobalsAndPackages() ...
[17:39:25.772] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.772] Resolving globals: FALSE
[17:39:25.772] Tweak future expression to call with '...' arguments ...
[17:39:25.772] {
[17:39:25.772]     do.call(function(...) {
[17:39:25.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.772]             on.exit(options(oopts), add = TRUE)
[17:39:25.772]         }
[17:39:25.772]         {
[17:39:25.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.772]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.772]             })
[17:39:25.772]         }
[17:39:25.772]     }, args = future.call.arguments)
[17:39:25.772] }
[17:39:25.773] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.773] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.773] 
[17:39:25.773] getGlobalsAndPackages() ... DONE
[17:39:25.773] run() for ‘Future’ ...
[17:39:25.773] - state: ‘created’
[17:39:25.774] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:25.774] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.774] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.774]   - Field: ‘label’
[17:39:25.774]   - Field: ‘local’
[17:39:25.774]   - Field: ‘owner’
[17:39:25.774]   - Field: ‘envir’
[17:39:25.774]   - Field: ‘packages’
[17:39:25.775]   - Field: ‘gc’
[17:39:25.775]   - Field: ‘conditions’
[17:39:25.775]   - Field: ‘expr’
[17:39:25.775]   - Field: ‘uuid’
[17:39:25.775]   - Field: ‘seed’
[17:39:25.775]   - Field: ‘version’
[17:39:25.775]   - Field: ‘result’
[17:39:25.775]   - Field: ‘asynchronous’
[17:39:25.775]   - Field: ‘calls’
[17:39:25.775]   - Field: ‘globals’
[17:39:25.775]   - Field: ‘stdout’
[17:39:25.776]   - Field: ‘earlySignal’
[17:39:25.776]   - Field: ‘lazy’
[17:39:25.776]   - Field: ‘state’
[17:39:25.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.776] - Launch lazy future ...
[17:39:25.776] Packages needed by the future expression (n = 0): <none>
[17:39:25.776] Packages needed by future strategies (n = 0): <none>
[17:39:25.778] {
[17:39:25.778]     {
[17:39:25.778]         {
[17:39:25.778]             ...future.startTime <- base::Sys.time()
[17:39:25.778]             {
[17:39:25.778]                 {
[17:39:25.778]                   {
[17:39:25.778]                     base::local({
[17:39:25.778]                       has_future <- base::requireNamespace("future", 
[17:39:25.778]                         quietly = TRUE)
[17:39:25.778]                       if (has_future) {
[17:39:25.778]                         ns <- base::getNamespace("future")
[17:39:25.778]                         version <- ns[[".package"]][["version"]]
[17:39:25.778]                         if (is.null(version)) 
[17:39:25.778]                           version <- utils::packageVersion("future")
[17:39:25.778]                       }
[17:39:25.778]                       else {
[17:39:25.778]                         version <- NULL
[17:39:25.778]                       }
[17:39:25.778]                       if (!has_future || version < "1.8.0") {
[17:39:25.778]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.778]                           "", base::R.version$version.string), 
[17:39:25.778]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.778]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.778]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.778]                             "release", "version")], collapse = " "), 
[17:39:25.778]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.778]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.778]                           info)
[17:39:25.778]                         info <- base::paste(info, collapse = "; ")
[17:39:25.778]                         if (!has_future) {
[17:39:25.778]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.778]                             info)
[17:39:25.778]                         }
[17:39:25.778]                         else {
[17:39:25.778]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.778]                             info, version)
[17:39:25.778]                         }
[17:39:25.778]                         base::stop(msg)
[17:39:25.778]                       }
[17:39:25.778]                     })
[17:39:25.778]                   }
[17:39:25.778]                   options(future.plan = NULL)
[17:39:25.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.778]                 }
[17:39:25.778]                 ...future.workdir <- getwd()
[17:39:25.778]             }
[17:39:25.778]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.778]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.778]         }
[17:39:25.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.778]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[17:39:25.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.778]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.778]             base::names(...future.oldOptions))
[17:39:25.778]     }
[17:39:25.778]     if (FALSE) {
[17:39:25.778]     }
[17:39:25.778]     else {
[17:39:25.778]         if (TRUE) {
[17:39:25.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.778]                 open = "w")
[17:39:25.778]         }
[17:39:25.778]         else {
[17:39:25.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.778]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.778]         }
[17:39:25.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.778]             base::sink(type = "output", split = FALSE)
[17:39:25.778]             base::close(...future.stdout)
[17:39:25.778]         }, add = TRUE)
[17:39:25.778]     }
[17:39:25.778]     ...future.frame <- base::sys.nframe()
[17:39:25.778]     ...future.conditions <- base::list()
[17:39:25.778]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.778]     if (FALSE) {
[17:39:25.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.778]     }
[17:39:25.778]     ...future.result <- base::tryCatch({
[17:39:25.778]         base::withCallingHandlers({
[17:39:25.778]             ...future.value <- base::withVisible(base::local({
[17:39:25.778]                 do.call(function(...) {
[17:39:25.778]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.778]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.778]                     ...future.globals.maxSize)) {
[17:39:25.778]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.778]                     on.exit(options(oopts), add = TRUE)
[17:39:25.778]                   }
[17:39:25.778]                   {
[17:39:25.778]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.778]                       FUN = function(jj) {
[17:39:25.778]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.778]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.778]                       })
[17:39:25.778]                   }
[17:39:25.778]                 }, args = future.call.arguments)
[17:39:25.778]             }))
[17:39:25.778]             future::FutureResult(value = ...future.value$value, 
[17:39:25.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.778]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.778]                     ...future.globalenv.names))
[17:39:25.778]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.778]         }, condition = base::local({
[17:39:25.778]             c <- base::c
[17:39:25.778]             inherits <- base::inherits
[17:39:25.778]             invokeRestart <- base::invokeRestart
[17:39:25.778]             length <- base::length
[17:39:25.778]             list <- base::list
[17:39:25.778]             seq.int <- base::seq.int
[17:39:25.778]             signalCondition <- base::signalCondition
[17:39:25.778]             sys.calls <- base::sys.calls
[17:39:25.778]             `[[` <- base::`[[`
[17:39:25.778]             `+` <- base::`+`
[17:39:25.778]             `<<-` <- base::`<<-`
[17:39:25.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.778]                   3L)]
[17:39:25.778]             }
[17:39:25.778]             function(cond) {
[17:39:25.778]                 is_error <- inherits(cond, "error")
[17:39:25.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.778]                   NULL)
[17:39:25.778]                 if (is_error) {
[17:39:25.778]                   sessionInformation <- function() {
[17:39:25.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.778]                       search = base::search(), system = base::Sys.info())
[17:39:25.778]                   }
[17:39:25.778]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.778]                     cond$call), session = sessionInformation(), 
[17:39:25.778]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.778]                   signalCondition(cond)
[17:39:25.778]                 }
[17:39:25.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.778]                 "immediateCondition"))) {
[17:39:25.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.778]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.778]                   if (TRUE && !signal) {
[17:39:25.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.778]                     {
[17:39:25.778]                       inherits <- base::inherits
[17:39:25.778]                       invokeRestart <- base::invokeRestart
[17:39:25.778]                       is.null <- base::is.null
[17:39:25.778]                       muffled <- FALSE
[17:39:25.778]                       if (inherits(cond, "message")) {
[17:39:25.778]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.778]                         if (muffled) 
[17:39:25.778]                           invokeRestart("muffleMessage")
[17:39:25.778]                       }
[17:39:25.778]                       else if (inherits(cond, "warning")) {
[17:39:25.778]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.778]                         if (muffled) 
[17:39:25.778]                           invokeRestart("muffleWarning")
[17:39:25.778]                       }
[17:39:25.778]                       else if (inherits(cond, "condition")) {
[17:39:25.778]                         if (!is.null(pattern)) {
[17:39:25.778]                           computeRestarts <- base::computeRestarts
[17:39:25.778]                           grepl <- base::grepl
[17:39:25.778]                           restarts <- computeRestarts(cond)
[17:39:25.778]                           for (restart in restarts) {
[17:39:25.778]                             name <- restart$name
[17:39:25.778]                             if (is.null(name)) 
[17:39:25.778]                               next
[17:39:25.778]                             if (!grepl(pattern, name)) 
[17:39:25.778]                               next
[17:39:25.778]                             invokeRestart(restart)
[17:39:25.778]                             muffled <- TRUE
[17:39:25.778]                             break
[17:39:25.778]                           }
[17:39:25.778]                         }
[17:39:25.778]                       }
[17:39:25.778]                       invisible(muffled)
[17:39:25.778]                     }
[17:39:25.778]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.778]                   }
[17:39:25.778]                 }
[17:39:25.778]                 else {
[17:39:25.778]                   if (TRUE) {
[17:39:25.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.778]                     {
[17:39:25.778]                       inherits <- base::inherits
[17:39:25.778]                       invokeRestart <- base::invokeRestart
[17:39:25.778]                       is.null <- base::is.null
[17:39:25.778]                       muffled <- FALSE
[17:39:25.778]                       if (inherits(cond, "message")) {
[17:39:25.778]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.778]                         if (muffled) 
[17:39:25.778]                           invokeRestart("muffleMessage")
[17:39:25.778]                       }
[17:39:25.778]                       else if (inherits(cond, "warning")) {
[17:39:25.778]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.778]                         if (muffled) 
[17:39:25.778]                           invokeRestart("muffleWarning")
[17:39:25.778]                       }
[17:39:25.778]                       else if (inherits(cond, "condition")) {
[17:39:25.778]                         if (!is.null(pattern)) {
[17:39:25.778]                           computeRestarts <- base::computeRestarts
[17:39:25.778]                           grepl <- base::grepl
[17:39:25.778]                           restarts <- computeRestarts(cond)
[17:39:25.778]                           for (restart in restarts) {
[17:39:25.778]                             name <- restart$name
[17:39:25.778]                             if (is.null(name)) 
[17:39:25.778]                               next
[17:39:25.778]                             if (!grepl(pattern, name)) 
[17:39:25.778]                               next
[17:39:25.778]                             invokeRestart(restart)
[17:39:25.778]                             muffled <- TRUE
[17:39:25.778]                             break
[17:39:25.778]                           }
[17:39:25.778]                         }
[17:39:25.778]                       }
[17:39:25.778]                       invisible(muffled)
[17:39:25.778]                     }
[17:39:25.778]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.778]                   }
[17:39:25.778]                 }
[17:39:25.778]             }
[17:39:25.778]         }))
[17:39:25.778]     }, error = function(ex) {
[17:39:25.778]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.778]                 ...future.rng), started = ...future.startTime, 
[17:39:25.778]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.778]             version = "1.8"), class = "FutureResult")
[17:39:25.778]     }, finally = {
[17:39:25.778]         if (!identical(...future.workdir, getwd())) 
[17:39:25.778]             setwd(...future.workdir)
[17:39:25.778]         {
[17:39:25.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.778]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.778]             }
[17:39:25.778]             base::options(...future.oldOptions)
[17:39:25.778]             if (.Platform$OS.type == "windows") {
[17:39:25.778]                 old_names <- names(...future.oldEnvVars)
[17:39:25.778]                 envs <- base::Sys.getenv()
[17:39:25.778]                 names <- names(envs)
[17:39:25.778]                 common <- intersect(names, old_names)
[17:39:25.778]                 added <- setdiff(names, old_names)
[17:39:25.778]                 removed <- setdiff(old_names, names)
[17:39:25.778]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.778]                   envs[common]]
[17:39:25.778]                 NAMES <- toupper(changed)
[17:39:25.778]                 args <- list()
[17:39:25.778]                 for (kk in seq_along(NAMES)) {
[17:39:25.778]                   name <- changed[[kk]]
[17:39:25.778]                   NAME <- NAMES[[kk]]
[17:39:25.778]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.778]                     next
[17:39:25.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.778]                 }
[17:39:25.778]                 NAMES <- toupper(added)
[17:39:25.778]                 for (kk in seq_along(NAMES)) {
[17:39:25.778]                   name <- added[[kk]]
[17:39:25.778]                   NAME <- NAMES[[kk]]
[17:39:25.778]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.778]                     next
[17:39:25.778]                   args[[name]] <- ""
[17:39:25.778]                 }
[17:39:25.778]                 NAMES <- toupper(removed)
[17:39:25.778]                 for (kk in seq_along(NAMES)) {
[17:39:25.778]                   name <- removed[[kk]]
[17:39:25.778]                   NAME <- NAMES[[kk]]
[17:39:25.778]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.778]                     next
[17:39:25.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.778]                 }
[17:39:25.778]                 if (length(args) > 0) 
[17:39:25.778]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.778]             }
[17:39:25.778]             else {
[17:39:25.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.778]             }
[17:39:25.778]             {
[17:39:25.778]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.778]                   0L) {
[17:39:25.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.778]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.778]                   base::options(opts)
[17:39:25.778]                 }
[17:39:25.778]                 {
[17:39:25.778]                   {
[17:39:25.778]                     NULL
[17:39:25.778]                     RNGkind("Mersenne-Twister")
[17:39:25.778]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.778]                       inherits = FALSE)
[17:39:25.778]                   }
[17:39:25.778]                   options(future.plan = NULL)
[17:39:25.778]                   if (is.na(NA_character_)) 
[17:39:25.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.778]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:25.778]                   {
[17:39:25.778]                     future <- SequentialFuture(..., envir = envir)
[17:39:25.778]                     if (!future$lazy) 
[17:39:25.778]                       future <- run(future)
[17:39:25.778]                     invisible(future)
[17:39:25.778]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.778]                 }
[17:39:25.778]             }
[17:39:25.778]         }
[17:39:25.778]     })
[17:39:25.778]     if (TRUE) {
[17:39:25.778]         base::sink(type = "output", split = FALSE)
[17:39:25.778]         if (TRUE) {
[17:39:25.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.778]         }
[17:39:25.778]         else {
[17:39:25.778]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.778]         }
[17:39:25.778]         base::close(...future.stdout)
[17:39:25.778]         ...future.stdout <- NULL
[17:39:25.778]     }
[17:39:25.778]     ...future.result$conditions <- ...future.conditions
[17:39:25.778]     ...future.result$finished <- base::Sys.time()
[17:39:25.778]     ...future.result
[17:39:25.778] }
[17:39:25.779] assign_globals() ...
[17:39:25.780] List of 5
[17:39:25.780]  $ ...future.FUN            :function (object, ...)  
[17:39:25.780]  $ future.call.arguments    :List of 1
[17:39:25.780]   ..$ digits: int 2
[17:39:25.780]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.780]  $ ...future.elements_ii    :List of 6
[17:39:25.780]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:39:25.780]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:39:25.780]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:39:25.780]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:39:25.780]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:39:25.780]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:39:25.780]  $ ...future.seeds_ii       : NULL
[17:39:25.780]  $ ...future.globals.maxSize: NULL
[17:39:25.780]  - attr(*, "resolved")= logi FALSE
[17:39:25.780]  - attr(*, "total_size")= num 1296
[17:39:25.780]  - attr(*, "where")=List of 5
[17:39:25.780]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.780]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.780]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.780]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.780]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.780]  - attr(*, "already-done")= logi TRUE
[17:39:25.786] - copied ‘...future.FUN’ to environment
[17:39:25.786] - copied ‘future.call.arguments’ to environment
[17:39:25.787] - copied ‘...future.elements_ii’ to environment
[17:39:25.787] - copied ‘...future.seeds_ii’ to environment
[17:39:25.787] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.787] assign_globals() ... done
[17:39:25.787] plan(): Setting new future strategy stack:
[17:39:25.787] List of future strategies:
[17:39:25.787] 1. sequential:
[17:39:25.787]    - args: function (..., envir = parent.frame())
[17:39:25.787]    - tweaked: FALSE
[17:39:25.787]    - call: NULL
[17:39:25.787] plan(): nbrOfWorkers() = 1
[17:39:25.789] plan(): Setting new future strategy stack:
[17:39:25.789] List of future strategies:
[17:39:25.789] 1. sequential:
[17:39:25.789]    - args: function (..., envir = parent.frame())
[17:39:25.789]    - tweaked: FALSE
[17:39:25.789]    - call: plan(strategy)
[17:39:25.789] plan(): nbrOfWorkers() = 1
[17:39:25.789] SequentialFuture started (and completed)
[17:39:25.790] - Launch lazy future ... done
[17:39:25.790] run() for ‘SequentialFuture’ ... done
[17:39:25.790] Created future:
[17:39:25.790] SequentialFuture:
[17:39:25.790] Label: ‘future_by-1’
[17:39:25.790] Expression:
[17:39:25.790] {
[17:39:25.790]     do.call(function(...) {
[17:39:25.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.790]             on.exit(options(oopts), add = TRUE)
[17:39:25.790]         }
[17:39:25.790]         {
[17:39:25.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.790]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.790]             })
[17:39:25.790]         }
[17:39:25.790]     }, args = future.call.arguments)
[17:39:25.790] }
[17:39:25.790] Lazy evaluation: FALSE
[17:39:25.790] Asynchronous evaluation: FALSE
[17:39:25.790] Local evaluation: TRUE
[17:39:25.790] Environment: R_GlobalEnv
[17:39:25.790] Capture standard output: TRUE
[17:39:25.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.790] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.790] Packages: <none>
[17:39:25.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.790] Resolved: TRUE
[17:39:25.790] Value: 5.48 KiB of class ‘list’
[17:39:25.790] Early signaling: FALSE
[17:39:25.790] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.790] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.791] Chunk #1 of 1 ... DONE
[17:39:25.791] Launching 1 futures (chunks) ... DONE
[17:39:25.791] Resolving 1 futures (chunks) ...
[17:39:25.791] resolve() on list ...
[17:39:25.791]  recursive: 0
[17:39:25.791]  length: 1
[17:39:25.791] 
[17:39:25.791] resolved() for ‘SequentialFuture’ ...
[17:39:25.792] - state: ‘finished’
[17:39:25.792] - run: TRUE
[17:39:25.792] - result: ‘FutureResult’
[17:39:25.792] resolved() for ‘SequentialFuture’ ... done
[17:39:25.792] Future #1
[17:39:25.792] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.792] - nx: 1
[17:39:25.792] - relay: TRUE
[17:39:25.792] - stdout: TRUE
[17:39:25.792] - signal: TRUE
[17:39:25.792] - resignal: FALSE
[17:39:25.793] - force: TRUE
[17:39:25.793] - relayed: [n=1] FALSE
[17:39:25.793] - queued futures: [n=1] FALSE
[17:39:25.793]  - until=1
[17:39:25.793]  - relaying element #1
[17:39:25.793] - relayed: [n=1] TRUE
[17:39:25.793] - queued futures: [n=1] TRUE
[17:39:25.793] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.793]  length: 0 (resolved future 1)
[17:39:25.793] Relaying remaining futures
[17:39:25.794] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.794] - nx: 1
[17:39:25.794] - relay: TRUE
[17:39:25.794] - stdout: TRUE
[17:39:25.794] - signal: TRUE
[17:39:25.794] - resignal: FALSE
[17:39:25.794] - force: TRUE
[17:39:25.794] - relayed: [n=1] TRUE
[17:39:25.794] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.794] - relayed: [n=1] TRUE
[17:39:25.794] - queued futures: [n=1] TRUE
[17:39:25.794] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.795] resolve() on list ... DONE
[17:39:25.795]  - Number of value chunks collected: 1
[17:39:25.795] Resolving 1 futures (chunks) ... DONE
[17:39:25.795] Reducing values from 1 chunks ...
[17:39:25.795]  - Number of values collected after concatenation: 6
[17:39:25.795]  - Number of values expected: 6
[17:39:25.795] Reducing values from 1 chunks ... DONE
[17:39:25.795] future_lapply() ... DONE
[17:39:25.795] future_by_internal() ... DONE
[17:39:25.796] future_by_internal() ...
[17:39:25.797] future_lapply() ...
[17:39:25.799] Number of chunks: 1
[17:39:25.799] getGlobalsAndPackagesXApply() ...
[17:39:25.799]  - future.globals: TRUE
[17:39:25.799] getGlobalsAndPackages() ...
[17:39:25.799] Searching for globals...
[17:39:25.801] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:25.801] Searching for globals ... DONE
[17:39:25.801] Resolving globals: FALSE
[17:39:25.801] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:39:25.802] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:39:25.802] - globals: [1] ‘FUN’
[17:39:25.802] - packages: [1] ‘stats’
[17:39:25.802] getGlobalsAndPackages() ... DONE
[17:39:25.802]  - globals found/used: [n=1] ‘FUN’
[17:39:25.802]  - needed namespaces: [n=1] ‘stats’
[17:39:25.803] Finding globals ... DONE
[17:39:25.803]  - use_args: TRUE
[17:39:25.803]  - Getting '...' globals ...
[17:39:25.803] resolve() on list ...
[17:39:25.803]  recursive: 0
[17:39:25.803]  length: 1
[17:39:25.803]  elements: ‘...’
[17:39:25.803]  length: 0 (resolved future 1)
[17:39:25.804] resolve() on list ... DONE
[17:39:25.804]    - '...' content: [n=1] ‘singular.ok’
[17:39:25.804] List of 1
[17:39:25.804]  $ ...:List of 1
[17:39:25.804]   ..$ singular.ok: logi FALSE
[17:39:25.804]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.804]  - attr(*, "where")=List of 1
[17:39:25.804]   ..$ ...:<environment: 0x562970ef6008> 
[17:39:25.804]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.804]  - attr(*, "resolved")= logi TRUE
[17:39:25.804]  - attr(*, "total_size")= num NA
[17:39:25.807]  - Getting '...' globals ... DONE
[17:39:25.807] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.807] List of 2
[17:39:25.807]  $ ...future.FUN:function (x, ...)  
[17:39:25.807]  $ ...          :List of 1
[17:39:25.807]   ..$ singular.ok: logi FALSE
[17:39:25.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.807]  - attr(*, "where")=List of 2
[17:39:25.807]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.807]   ..$ ...          :<environment: 0x562970ef6008> 
[17:39:25.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.807]  - attr(*, "resolved")= logi FALSE
[17:39:25.807]  - attr(*, "total_size")= num 5384
[17:39:25.810] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:25.810] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.810] Number of futures (= number of chunks): 1
[17:39:25.810] Launching 1 futures (chunks) ...
[17:39:25.811] Chunk #1 of 1 ...
[17:39:25.811]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.811] getGlobalsAndPackages() ...
[17:39:25.811] Searching for globals...
[17:39:25.811] 
[17:39:25.811] Searching for globals ... DONE
[17:39:25.812] - globals: [0] <none>
[17:39:25.812] getGlobalsAndPackages() ... DONE
[17:39:25.812]    + additional globals found: [n=0] 
[17:39:25.812]    + additional namespaces needed: [n=0] 
[17:39:25.812]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.812]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.812]  - seeds: <none>
[17:39:25.812] getGlobalsAndPackages() ...
[17:39:25.812] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.813] Resolving globals: FALSE
[17:39:25.813] Tweak future expression to call with '...' arguments ...
[17:39:25.813] {
[17:39:25.813]     do.call(function(...) {
[17:39:25.813]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.813]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.813]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.813]             on.exit(options(oopts), add = TRUE)
[17:39:25.813]         }
[17:39:25.813]         {
[17:39:25.813]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.813]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.813]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.813]             })
[17:39:25.813]         }
[17:39:25.813]     }, args = future.call.arguments)
[17:39:25.813] }
[17:39:25.813] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.813] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.814] 
[17:39:25.814] getGlobalsAndPackages() ... DONE
[17:39:25.814] run() for ‘Future’ ...
[17:39:25.814] - state: ‘created’
[17:39:25.814] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:25.815] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.815] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.815]   - Field: ‘label’
[17:39:25.815]   - Field: ‘local’
[17:39:25.815]   - Field: ‘owner’
[17:39:25.815]   - Field: ‘envir’
[17:39:25.815]   - Field: ‘packages’
[17:39:25.815]   - Field: ‘gc’
[17:39:25.815]   - Field: ‘conditions’
[17:39:25.816]   - Field: ‘expr’
[17:39:25.816]   - Field: ‘uuid’
[17:39:25.816]   - Field: ‘seed’
[17:39:25.816]   - Field: ‘version’
[17:39:25.816]   - Field: ‘result’
[17:39:25.816]   - Field: ‘asynchronous’
[17:39:25.816]   - Field: ‘calls’
[17:39:25.816]   - Field: ‘globals’
[17:39:25.816]   - Field: ‘stdout’
[17:39:25.816]   - Field: ‘earlySignal’
[17:39:25.817]   - Field: ‘lazy’
[17:39:25.817]   - Field: ‘state’
[17:39:25.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.817] - Launch lazy future ...
[17:39:25.817] Packages needed by the future expression (n = 1): ‘stats’
[17:39:25.817] Packages needed by future strategies (n = 0): <none>
[17:39:25.820] {
[17:39:25.820]     {
[17:39:25.820]         {
[17:39:25.820]             ...future.startTime <- base::Sys.time()
[17:39:25.820]             {
[17:39:25.820]                 {
[17:39:25.820]                   {
[17:39:25.820]                     {
[17:39:25.820]                       base::local({
[17:39:25.820]                         has_future <- base::requireNamespace("future", 
[17:39:25.820]                           quietly = TRUE)
[17:39:25.820]                         if (has_future) {
[17:39:25.820]                           ns <- base::getNamespace("future")
[17:39:25.820]                           version <- ns[[".package"]][["version"]]
[17:39:25.820]                           if (is.null(version)) 
[17:39:25.820]                             version <- utils::packageVersion("future")
[17:39:25.820]                         }
[17:39:25.820]                         else {
[17:39:25.820]                           version <- NULL
[17:39:25.820]                         }
[17:39:25.820]                         if (!has_future || version < "1.8.0") {
[17:39:25.820]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.820]                             "", base::R.version$version.string), 
[17:39:25.820]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:25.820]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.820]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.820]                               "release", "version")], collapse = " "), 
[17:39:25.820]                             hostname = base::Sys.info()[["nodename"]])
[17:39:25.820]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.820]                             info)
[17:39:25.820]                           info <- base::paste(info, collapse = "; ")
[17:39:25.820]                           if (!has_future) {
[17:39:25.820]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.820]                               info)
[17:39:25.820]                           }
[17:39:25.820]                           else {
[17:39:25.820]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.820]                               info, version)
[17:39:25.820]                           }
[17:39:25.820]                           base::stop(msg)
[17:39:25.820]                         }
[17:39:25.820]                       })
[17:39:25.820]                     }
[17:39:25.820]                     base::local({
[17:39:25.820]                       for (pkg in "stats") {
[17:39:25.820]                         base::loadNamespace(pkg)
[17:39:25.820]                         base::library(pkg, character.only = TRUE)
[17:39:25.820]                       }
[17:39:25.820]                     })
[17:39:25.820]                   }
[17:39:25.820]                   options(future.plan = NULL)
[17:39:25.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.820]                 }
[17:39:25.820]                 ...future.workdir <- getwd()
[17:39:25.820]             }
[17:39:25.820]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.820]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.820]         }
[17:39:25.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.820]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.820]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.820]             base::names(...future.oldOptions))
[17:39:25.820]     }
[17:39:25.820]     if (FALSE) {
[17:39:25.820]     }
[17:39:25.820]     else {
[17:39:25.820]         if (TRUE) {
[17:39:25.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.820]                 open = "w")
[17:39:25.820]         }
[17:39:25.820]         else {
[17:39:25.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.820]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.820]         }
[17:39:25.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.820]             base::sink(type = "output", split = FALSE)
[17:39:25.820]             base::close(...future.stdout)
[17:39:25.820]         }, add = TRUE)
[17:39:25.820]     }
[17:39:25.820]     ...future.frame <- base::sys.nframe()
[17:39:25.820]     ...future.conditions <- base::list()
[17:39:25.820]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.820]     if (FALSE) {
[17:39:25.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.820]     }
[17:39:25.820]     ...future.result <- base::tryCatch({
[17:39:25.820]         base::withCallingHandlers({
[17:39:25.820]             ...future.value <- base::withVisible(base::local({
[17:39:25.820]                 do.call(function(...) {
[17:39:25.820]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.820]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.820]                     ...future.globals.maxSize)) {
[17:39:25.820]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.820]                     on.exit(options(oopts), add = TRUE)
[17:39:25.820]                   }
[17:39:25.820]                   {
[17:39:25.820]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.820]                       FUN = function(jj) {
[17:39:25.820]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.820]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.820]                       })
[17:39:25.820]                   }
[17:39:25.820]                 }, args = future.call.arguments)
[17:39:25.820]             }))
[17:39:25.820]             future::FutureResult(value = ...future.value$value, 
[17:39:25.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.820]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.820]                     ...future.globalenv.names))
[17:39:25.820]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.820]         }, condition = base::local({
[17:39:25.820]             c <- base::c
[17:39:25.820]             inherits <- base::inherits
[17:39:25.820]             invokeRestart <- base::invokeRestart
[17:39:25.820]             length <- base::length
[17:39:25.820]             list <- base::list
[17:39:25.820]             seq.int <- base::seq.int
[17:39:25.820]             signalCondition <- base::signalCondition
[17:39:25.820]             sys.calls <- base::sys.calls
[17:39:25.820]             `[[` <- base::`[[`
[17:39:25.820]             `+` <- base::`+`
[17:39:25.820]             `<<-` <- base::`<<-`
[17:39:25.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.820]                   3L)]
[17:39:25.820]             }
[17:39:25.820]             function(cond) {
[17:39:25.820]                 is_error <- inherits(cond, "error")
[17:39:25.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.820]                   NULL)
[17:39:25.820]                 if (is_error) {
[17:39:25.820]                   sessionInformation <- function() {
[17:39:25.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.820]                       search = base::search(), system = base::Sys.info())
[17:39:25.820]                   }
[17:39:25.820]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.820]                     cond$call), session = sessionInformation(), 
[17:39:25.820]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.820]                   signalCondition(cond)
[17:39:25.820]                 }
[17:39:25.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.820]                 "immediateCondition"))) {
[17:39:25.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.820]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.820]                   if (TRUE && !signal) {
[17:39:25.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.820]                     {
[17:39:25.820]                       inherits <- base::inherits
[17:39:25.820]                       invokeRestart <- base::invokeRestart
[17:39:25.820]                       is.null <- base::is.null
[17:39:25.820]                       muffled <- FALSE
[17:39:25.820]                       if (inherits(cond, "message")) {
[17:39:25.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.820]                         if (muffled) 
[17:39:25.820]                           invokeRestart("muffleMessage")
[17:39:25.820]                       }
[17:39:25.820]                       else if (inherits(cond, "warning")) {
[17:39:25.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.820]                         if (muffled) 
[17:39:25.820]                           invokeRestart("muffleWarning")
[17:39:25.820]                       }
[17:39:25.820]                       else if (inherits(cond, "condition")) {
[17:39:25.820]                         if (!is.null(pattern)) {
[17:39:25.820]                           computeRestarts <- base::computeRestarts
[17:39:25.820]                           grepl <- base::grepl
[17:39:25.820]                           restarts <- computeRestarts(cond)
[17:39:25.820]                           for (restart in restarts) {
[17:39:25.820]                             name <- restart$name
[17:39:25.820]                             if (is.null(name)) 
[17:39:25.820]                               next
[17:39:25.820]                             if (!grepl(pattern, name)) 
[17:39:25.820]                               next
[17:39:25.820]                             invokeRestart(restart)
[17:39:25.820]                             muffled <- TRUE
[17:39:25.820]                             break
[17:39:25.820]                           }
[17:39:25.820]                         }
[17:39:25.820]                       }
[17:39:25.820]                       invisible(muffled)
[17:39:25.820]                     }
[17:39:25.820]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.820]                   }
[17:39:25.820]                 }
[17:39:25.820]                 else {
[17:39:25.820]                   if (TRUE) {
[17:39:25.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.820]                     {
[17:39:25.820]                       inherits <- base::inherits
[17:39:25.820]                       invokeRestart <- base::invokeRestart
[17:39:25.820]                       is.null <- base::is.null
[17:39:25.820]                       muffled <- FALSE
[17:39:25.820]                       if (inherits(cond, "message")) {
[17:39:25.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.820]                         if (muffled) 
[17:39:25.820]                           invokeRestart("muffleMessage")
[17:39:25.820]                       }
[17:39:25.820]                       else if (inherits(cond, "warning")) {
[17:39:25.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.820]                         if (muffled) 
[17:39:25.820]                           invokeRestart("muffleWarning")
[17:39:25.820]                       }
[17:39:25.820]                       else if (inherits(cond, "condition")) {
[17:39:25.820]                         if (!is.null(pattern)) {
[17:39:25.820]                           computeRestarts <- base::computeRestarts
[17:39:25.820]                           grepl <- base::grepl
[17:39:25.820]                           restarts <- computeRestarts(cond)
[17:39:25.820]                           for (restart in restarts) {
[17:39:25.820]                             name <- restart$name
[17:39:25.820]                             if (is.null(name)) 
[17:39:25.820]                               next
[17:39:25.820]                             if (!grepl(pattern, name)) 
[17:39:25.820]                               next
[17:39:25.820]                             invokeRestart(restart)
[17:39:25.820]                             muffled <- TRUE
[17:39:25.820]                             break
[17:39:25.820]                           }
[17:39:25.820]                         }
[17:39:25.820]                       }
[17:39:25.820]                       invisible(muffled)
[17:39:25.820]                     }
[17:39:25.820]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.820]                   }
[17:39:25.820]                 }
[17:39:25.820]             }
[17:39:25.820]         }))
[17:39:25.820]     }, error = function(ex) {
[17:39:25.820]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.820]                 ...future.rng), started = ...future.startTime, 
[17:39:25.820]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.820]             version = "1.8"), class = "FutureResult")
[17:39:25.820]     }, finally = {
[17:39:25.820]         if (!identical(...future.workdir, getwd())) 
[17:39:25.820]             setwd(...future.workdir)
[17:39:25.820]         {
[17:39:25.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.820]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.820]             }
[17:39:25.820]             base::options(...future.oldOptions)
[17:39:25.820]             if (.Platform$OS.type == "windows") {
[17:39:25.820]                 old_names <- names(...future.oldEnvVars)
[17:39:25.820]                 envs <- base::Sys.getenv()
[17:39:25.820]                 names <- names(envs)
[17:39:25.820]                 common <- intersect(names, old_names)
[17:39:25.820]                 added <- setdiff(names, old_names)
[17:39:25.820]                 removed <- setdiff(old_names, names)
[17:39:25.820]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.820]                   envs[common]]
[17:39:25.820]                 NAMES <- toupper(changed)
[17:39:25.820]                 args <- list()
[17:39:25.820]                 for (kk in seq_along(NAMES)) {
[17:39:25.820]                   name <- changed[[kk]]
[17:39:25.820]                   NAME <- NAMES[[kk]]
[17:39:25.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.820]                     next
[17:39:25.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.820]                 }
[17:39:25.820]                 NAMES <- toupper(added)
[17:39:25.820]                 for (kk in seq_along(NAMES)) {
[17:39:25.820]                   name <- added[[kk]]
[17:39:25.820]                   NAME <- NAMES[[kk]]
[17:39:25.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.820]                     next
[17:39:25.820]                   args[[name]] <- ""
[17:39:25.820]                 }
[17:39:25.820]                 NAMES <- toupper(removed)
[17:39:25.820]                 for (kk in seq_along(NAMES)) {
[17:39:25.820]                   name <- removed[[kk]]
[17:39:25.820]                   NAME <- NAMES[[kk]]
[17:39:25.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.820]                     next
[17:39:25.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.820]                 }
[17:39:25.820]                 if (length(args) > 0) 
[17:39:25.820]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.820]             }
[17:39:25.820]             else {
[17:39:25.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.820]             }
[17:39:25.820]             {
[17:39:25.820]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.820]                   0L) {
[17:39:25.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.820]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.820]                   base::options(opts)
[17:39:25.820]                 }
[17:39:25.820]                 {
[17:39:25.820]                   {
[17:39:25.820]                     NULL
[17:39:25.820]                     RNGkind("Mersenne-Twister")
[17:39:25.820]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.820]                       inherits = FALSE)
[17:39:25.820]                   }
[17:39:25.820]                   options(future.plan = NULL)
[17:39:25.820]                   if (is.na(NA_character_)) 
[17:39:25.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.820]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:25.820]                   {
[17:39:25.820]                     future <- SequentialFuture(..., envir = envir)
[17:39:25.820]                     if (!future$lazy) 
[17:39:25.820]                       future <- run(future)
[17:39:25.820]                     invisible(future)
[17:39:25.820]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.820]                 }
[17:39:25.820]             }
[17:39:25.820]         }
[17:39:25.820]     })
[17:39:25.820]     if (TRUE) {
[17:39:25.820]         base::sink(type = "output", split = FALSE)
[17:39:25.820]         if (TRUE) {
[17:39:25.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.820]         }
[17:39:25.820]         else {
[17:39:25.820]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.820]         }
[17:39:25.820]         base::close(...future.stdout)
[17:39:25.820]         ...future.stdout <- NULL
[17:39:25.820]     }
[17:39:25.820]     ...future.result$conditions <- ...future.conditions
[17:39:25.820]     ...future.result$finished <- base::Sys.time()
[17:39:25.820]     ...future.result
[17:39:25.820] }
[17:39:25.822] assign_globals() ...
[17:39:25.822] List of 5
[17:39:25.822]  $ ...future.FUN            :function (x, ...)  
[17:39:25.822]  $ future.call.arguments    :List of 1
[17:39:25.822]   ..$ singular.ok: logi FALSE
[17:39:25.822]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.822]  $ ...future.elements_ii    :List of 3
[17:39:25.822]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.822]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.822]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.822]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.822]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.822]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.822]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.822]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.822]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.822]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.822]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.822]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.822]  $ ...future.seeds_ii       : NULL
[17:39:25.822]  $ ...future.globals.maxSize: NULL
[17:39:25.822]  - attr(*, "resolved")= logi FALSE
[17:39:25.822]  - attr(*, "total_size")= num 5384
[17:39:25.822]  - attr(*, "where")=List of 5
[17:39:25.822]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.822]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.822]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.822]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.822]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.822]  - attr(*, "already-done")= logi TRUE
[17:39:25.832] - reassign environment for ‘...future.FUN’
[17:39:25.832] - copied ‘...future.FUN’ to environment
[17:39:25.832] - copied ‘future.call.arguments’ to environment
[17:39:25.832] - copied ‘...future.elements_ii’ to environment
[17:39:25.832] - copied ‘...future.seeds_ii’ to environment
[17:39:25.832] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.833] assign_globals() ... done
[17:39:25.833] plan(): Setting new future strategy stack:
[17:39:25.833] List of future strategies:
[17:39:25.833] 1. sequential:
[17:39:25.833]    - args: function (..., envir = parent.frame())
[17:39:25.833]    - tweaked: FALSE
[17:39:25.833]    - call: NULL
[17:39:25.833] plan(): nbrOfWorkers() = 1
[17:39:25.836] plan(): Setting new future strategy stack:
[17:39:25.836] List of future strategies:
[17:39:25.836] 1. sequential:
[17:39:25.836]    - args: function (..., envir = parent.frame())
[17:39:25.836]    - tweaked: FALSE
[17:39:25.836]    - call: plan(strategy)
[17:39:25.837] plan(): nbrOfWorkers() = 1
[17:39:25.837] SequentialFuture started (and completed)
[17:39:25.837] - Launch lazy future ... done
[17:39:25.837] run() for ‘SequentialFuture’ ... done
[17:39:25.837] Created future:
[17:39:25.837] SequentialFuture:
[17:39:25.837] Label: ‘future_by-1’
[17:39:25.837] Expression:
[17:39:25.837] {
[17:39:25.837]     do.call(function(...) {
[17:39:25.837]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.837]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.837]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.837]             on.exit(options(oopts), add = TRUE)
[17:39:25.837]         }
[17:39:25.837]         {
[17:39:25.837]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.837]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.837]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.837]             })
[17:39:25.837]         }
[17:39:25.837]     }, args = future.call.arguments)
[17:39:25.837] }
[17:39:25.837] Lazy evaluation: FALSE
[17:39:25.837] Asynchronous evaluation: FALSE
[17:39:25.837] Local evaluation: TRUE
[17:39:25.837] Environment: R_GlobalEnv
[17:39:25.837] Capture standard output: TRUE
[17:39:25.837] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.837] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.837] Packages: 1 packages (‘stats’)
[17:39:25.837] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.837] Resolved: TRUE
[17:39:25.837] Value: 26.06 KiB of class ‘list’
[17:39:25.837] Early signaling: FALSE
[17:39:25.837] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.837] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.839] Chunk #1 of 1 ... DONE
[17:39:25.839] Launching 1 futures (chunks) ... DONE
[17:39:25.839] Resolving 1 futures (chunks) ...
[17:39:25.839] resolve() on list ...
[17:39:25.839]  recursive: 0
[17:39:25.840]  length: 1
[17:39:25.840] 
[17:39:25.840] resolved() for ‘SequentialFuture’ ...
[17:39:25.840] - state: ‘finished’
[17:39:25.840] - run: TRUE
[17:39:25.840] - result: ‘FutureResult’
[17:39:25.840] resolved() for ‘SequentialFuture’ ... done
[17:39:25.840] Future #1
[17:39:25.840] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.840] - nx: 1
[17:39:25.841] - relay: TRUE
[17:39:25.841] - stdout: TRUE
[17:39:25.841] - signal: TRUE
[17:39:25.841] - resignal: FALSE
[17:39:25.841] - force: TRUE
[17:39:25.841] - relayed: [n=1] FALSE
[17:39:25.841] - queued futures: [n=1] FALSE
[17:39:25.841]  - until=1
[17:39:25.841]  - relaying element #1
[17:39:25.843] - relayed: [n=1] TRUE
[17:39:25.843] - queued futures: [n=1] TRUE
[17:39:25.843] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.844]  length: 0 (resolved future 1)
[17:39:25.844] Relaying remaining futures
[17:39:25.844] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.844] - nx: 1
[17:39:25.844] - relay: TRUE
[17:39:25.844] - stdout: TRUE
[17:39:25.844] - signal: TRUE
[17:39:25.844] - resignal: FALSE
[17:39:25.844] - force: TRUE
[17:39:25.844] - relayed: [n=1] TRUE
[17:39:25.844] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.845] - relayed: [n=1] TRUE
[17:39:25.845] - queued futures: [n=1] TRUE
[17:39:25.845] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.845] resolve() on list ... DONE
[17:39:25.845]  - Number of value chunks collected: 1
[17:39:25.845] Resolving 1 futures (chunks) ... DONE
[17:39:25.845] Reducing values from 1 chunks ...
[17:39:25.845]  - Number of values collected after concatenation: 3
[17:39:25.846]  - Number of values expected: 3
[17:39:25.846] Reducing values from 1 chunks ... DONE
[17:39:25.846] future_lapply() ... DONE
[17:39:25.846] future_by_internal() ... DONE
[17:39:25.850] future_by_internal() ...
[17:39:25.850] future_lapply() ...
[17:39:25.851] Number of chunks: 1
[17:39:25.851] getGlobalsAndPackagesXApply() ...
[17:39:25.851]  - future.globals: TRUE
[17:39:25.852] getGlobalsAndPackages() ...
[17:39:25.852] Searching for globals...
[17:39:25.853] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:25.853] Searching for globals ... DONE
[17:39:25.854] Resolving globals: FALSE
[17:39:25.854] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:39:25.854] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:39:25.855] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:25.855] - packages: [1] ‘stats’
[17:39:25.855] getGlobalsAndPackages() ... DONE
[17:39:25.855]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:25.855]  - needed namespaces: [n=1] ‘stats’
[17:39:25.855] Finding globals ... DONE
[17:39:25.855]  - use_args: TRUE
[17:39:25.855]  - Getting '...' globals ...
[17:39:25.856] resolve() on list ...
[17:39:25.856]  recursive: 0
[17:39:25.856]  length: 1
[17:39:25.856]  elements: ‘...’
[17:39:25.856]  length: 0 (resolved future 1)
[17:39:25.856] resolve() on list ... DONE
[17:39:25.856]    - '...' content: [n=0] 
[17:39:25.856] List of 1
[17:39:25.856]  $ ...: list()
[17:39:25.856]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.856]  - attr(*, "where")=List of 1
[17:39:25.856]   ..$ ...:<environment: 0x56296e9319e8> 
[17:39:25.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.856]  - attr(*, "resolved")= logi TRUE
[17:39:25.856]  - attr(*, "total_size")= num NA
[17:39:25.859]  - Getting '...' globals ... DONE
[17:39:25.859] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:39:25.859] List of 4
[17:39:25.859]  $ ...future.FUN:function (x)  
[17:39:25.859]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:25.859]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.859]  $ ...          : list()
[17:39:25.859]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.859]  - attr(*, "where")=List of 4
[17:39:25.859]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.859]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:39:25.859]   ..$ wool         :<environment: R_EmptyEnv> 
[17:39:25.859]   ..$ ...          :<environment: 0x56296e9319e8> 
[17:39:25.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.859]  - attr(*, "resolved")= logi FALSE
[17:39:25.859]  - attr(*, "total_size")= num 2320
[17:39:25.865] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:25.865] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.865] Number of futures (= number of chunks): 1
[17:39:25.865] Launching 1 futures (chunks) ...
[17:39:25.865] Chunk #1 of 1 ...
[17:39:25.865]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.866] getGlobalsAndPackages() ...
[17:39:25.866] Searching for globals...
[17:39:25.866] 
[17:39:25.866] Searching for globals ... DONE
[17:39:25.866] - globals: [0] <none>
[17:39:25.866] getGlobalsAndPackages() ... DONE
[17:39:25.866]    + additional globals found: [n=0] 
[17:39:25.867]    + additional namespaces needed: [n=0] 
[17:39:25.867]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.867]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.867]  - seeds: <none>
[17:39:25.867] getGlobalsAndPackages() ...
[17:39:25.867] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.867] Resolving globals: FALSE
[17:39:25.867] Tweak future expression to call with '...' arguments ...
[17:39:25.867] {
[17:39:25.867]     do.call(function(...) {
[17:39:25.867]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.867]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.867]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.867]             on.exit(options(oopts), add = TRUE)
[17:39:25.867]         }
[17:39:25.867]         {
[17:39:25.867]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.867]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.867]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.867]             })
[17:39:25.867]         }
[17:39:25.867]     }, args = future.call.arguments)
[17:39:25.867] }
[17:39:25.868] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.868] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.868] 
[17:39:25.868] getGlobalsAndPackages() ... DONE
[17:39:25.869] run() for ‘Future’ ...
[17:39:25.869] - state: ‘created’
[17:39:25.869] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:25.869] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.869] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.869]   - Field: ‘label’
[17:39:25.870]   - Field: ‘local’
[17:39:25.870]   - Field: ‘owner’
[17:39:25.870]   - Field: ‘envir’
[17:39:25.870]   - Field: ‘packages’
[17:39:25.870]   - Field: ‘gc’
[17:39:25.870]   - Field: ‘conditions’
[17:39:25.870]   - Field: ‘expr’
[17:39:25.870]   - Field: ‘uuid’
[17:39:25.870]   - Field: ‘seed’
[17:39:25.870]   - Field: ‘version’
[17:39:25.871]   - Field: ‘result’
[17:39:25.871]   - Field: ‘asynchronous’
[17:39:25.871]   - Field: ‘calls’
[17:39:25.871]   - Field: ‘globals’
[17:39:25.871]   - Field: ‘stdout’
[17:39:25.871]   - Field: ‘earlySignal’
[17:39:25.871]   - Field: ‘lazy’
[17:39:25.871]   - Field: ‘state’
[17:39:25.871] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.871] - Launch lazy future ...
[17:39:25.872] Packages needed by the future expression (n = 1): ‘stats’
[17:39:25.872] Packages needed by future strategies (n = 0): <none>
[17:39:25.872] {
[17:39:25.872]     {
[17:39:25.872]         {
[17:39:25.872]             ...future.startTime <- base::Sys.time()
[17:39:25.872]             {
[17:39:25.872]                 {
[17:39:25.872]                   {
[17:39:25.872]                     {
[17:39:25.872]                       base::local({
[17:39:25.872]                         has_future <- base::requireNamespace("future", 
[17:39:25.872]                           quietly = TRUE)
[17:39:25.872]                         if (has_future) {
[17:39:25.872]                           ns <- base::getNamespace("future")
[17:39:25.872]                           version <- ns[[".package"]][["version"]]
[17:39:25.872]                           if (is.null(version)) 
[17:39:25.872]                             version <- utils::packageVersion("future")
[17:39:25.872]                         }
[17:39:25.872]                         else {
[17:39:25.872]                           version <- NULL
[17:39:25.872]                         }
[17:39:25.872]                         if (!has_future || version < "1.8.0") {
[17:39:25.872]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.872]                             "", base::R.version$version.string), 
[17:39:25.872]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:25.872]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.872]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.872]                               "release", "version")], collapse = " "), 
[17:39:25.872]                             hostname = base::Sys.info()[["nodename"]])
[17:39:25.872]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.872]                             info)
[17:39:25.872]                           info <- base::paste(info, collapse = "; ")
[17:39:25.872]                           if (!has_future) {
[17:39:25.872]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.872]                               info)
[17:39:25.872]                           }
[17:39:25.872]                           else {
[17:39:25.872]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.872]                               info, version)
[17:39:25.872]                           }
[17:39:25.872]                           base::stop(msg)
[17:39:25.872]                         }
[17:39:25.872]                       })
[17:39:25.872]                     }
[17:39:25.872]                     base::local({
[17:39:25.872]                       for (pkg in "stats") {
[17:39:25.872]                         base::loadNamespace(pkg)
[17:39:25.872]                         base::library(pkg, character.only = TRUE)
[17:39:25.872]                       }
[17:39:25.872]                     })
[17:39:25.872]                   }
[17:39:25.872]                   options(future.plan = NULL)
[17:39:25.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.872]                 }
[17:39:25.872]                 ...future.workdir <- getwd()
[17:39:25.872]             }
[17:39:25.872]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.872]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.872]         }
[17:39:25.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.872]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.872]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.872]             base::names(...future.oldOptions))
[17:39:25.872]     }
[17:39:25.872]     if (FALSE) {
[17:39:25.872]     }
[17:39:25.872]     else {
[17:39:25.872]         if (TRUE) {
[17:39:25.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.872]                 open = "w")
[17:39:25.872]         }
[17:39:25.872]         else {
[17:39:25.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.872]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.872]         }
[17:39:25.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.872]             base::sink(type = "output", split = FALSE)
[17:39:25.872]             base::close(...future.stdout)
[17:39:25.872]         }, add = TRUE)
[17:39:25.872]     }
[17:39:25.872]     ...future.frame <- base::sys.nframe()
[17:39:25.872]     ...future.conditions <- base::list()
[17:39:25.872]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.872]     if (FALSE) {
[17:39:25.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.872]     }
[17:39:25.872]     ...future.result <- base::tryCatch({
[17:39:25.872]         base::withCallingHandlers({
[17:39:25.872]             ...future.value <- base::withVisible(base::local({
[17:39:25.872]                 do.call(function(...) {
[17:39:25.872]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.872]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.872]                     ...future.globals.maxSize)) {
[17:39:25.872]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.872]                     on.exit(options(oopts), add = TRUE)
[17:39:25.872]                   }
[17:39:25.872]                   {
[17:39:25.872]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.872]                       FUN = function(jj) {
[17:39:25.872]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.872]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.872]                       })
[17:39:25.872]                   }
[17:39:25.872]                 }, args = future.call.arguments)
[17:39:25.872]             }))
[17:39:25.872]             future::FutureResult(value = ...future.value$value, 
[17:39:25.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.872]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.872]                     ...future.globalenv.names))
[17:39:25.872]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.872]         }, condition = base::local({
[17:39:25.872]             c <- base::c
[17:39:25.872]             inherits <- base::inherits
[17:39:25.872]             invokeRestart <- base::invokeRestart
[17:39:25.872]             length <- base::length
[17:39:25.872]             list <- base::list
[17:39:25.872]             seq.int <- base::seq.int
[17:39:25.872]             signalCondition <- base::signalCondition
[17:39:25.872]             sys.calls <- base::sys.calls
[17:39:25.872]             `[[` <- base::`[[`
[17:39:25.872]             `+` <- base::`+`
[17:39:25.872]             `<<-` <- base::`<<-`
[17:39:25.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.872]                   3L)]
[17:39:25.872]             }
[17:39:25.872]             function(cond) {
[17:39:25.872]                 is_error <- inherits(cond, "error")
[17:39:25.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.872]                   NULL)
[17:39:25.872]                 if (is_error) {
[17:39:25.872]                   sessionInformation <- function() {
[17:39:25.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.872]                       search = base::search(), system = base::Sys.info())
[17:39:25.872]                   }
[17:39:25.872]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.872]                     cond$call), session = sessionInformation(), 
[17:39:25.872]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.872]                   signalCondition(cond)
[17:39:25.872]                 }
[17:39:25.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.872]                 "immediateCondition"))) {
[17:39:25.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.872]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.872]                   if (TRUE && !signal) {
[17:39:25.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.872]                     {
[17:39:25.872]                       inherits <- base::inherits
[17:39:25.872]                       invokeRestart <- base::invokeRestart
[17:39:25.872]                       is.null <- base::is.null
[17:39:25.872]                       muffled <- FALSE
[17:39:25.872]                       if (inherits(cond, "message")) {
[17:39:25.872]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.872]                         if (muffled) 
[17:39:25.872]                           invokeRestart("muffleMessage")
[17:39:25.872]                       }
[17:39:25.872]                       else if (inherits(cond, "warning")) {
[17:39:25.872]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.872]                         if (muffled) 
[17:39:25.872]                           invokeRestart("muffleWarning")
[17:39:25.872]                       }
[17:39:25.872]                       else if (inherits(cond, "condition")) {
[17:39:25.872]                         if (!is.null(pattern)) {
[17:39:25.872]                           computeRestarts <- base::computeRestarts
[17:39:25.872]                           grepl <- base::grepl
[17:39:25.872]                           restarts <- computeRestarts(cond)
[17:39:25.872]                           for (restart in restarts) {
[17:39:25.872]                             name <- restart$name
[17:39:25.872]                             if (is.null(name)) 
[17:39:25.872]                               next
[17:39:25.872]                             if (!grepl(pattern, name)) 
[17:39:25.872]                               next
[17:39:25.872]                             invokeRestart(restart)
[17:39:25.872]                             muffled <- TRUE
[17:39:25.872]                             break
[17:39:25.872]                           }
[17:39:25.872]                         }
[17:39:25.872]                       }
[17:39:25.872]                       invisible(muffled)
[17:39:25.872]                     }
[17:39:25.872]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.872]                   }
[17:39:25.872]                 }
[17:39:25.872]                 else {
[17:39:25.872]                   if (TRUE) {
[17:39:25.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.872]                     {
[17:39:25.872]                       inherits <- base::inherits
[17:39:25.872]                       invokeRestart <- base::invokeRestart
[17:39:25.872]                       is.null <- base::is.null
[17:39:25.872]                       muffled <- FALSE
[17:39:25.872]                       if (inherits(cond, "message")) {
[17:39:25.872]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.872]                         if (muffled) 
[17:39:25.872]                           invokeRestart("muffleMessage")
[17:39:25.872]                       }
[17:39:25.872]                       else if (inherits(cond, "warning")) {
[17:39:25.872]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.872]                         if (muffled) 
[17:39:25.872]                           invokeRestart("muffleWarning")
[17:39:25.872]                       }
[17:39:25.872]                       else if (inherits(cond, "condition")) {
[17:39:25.872]                         if (!is.null(pattern)) {
[17:39:25.872]                           computeRestarts <- base::computeRestarts
[17:39:25.872]                           grepl <- base::grepl
[17:39:25.872]                           restarts <- computeRestarts(cond)
[17:39:25.872]                           for (restart in restarts) {
[17:39:25.872]                             name <- restart$name
[17:39:25.872]                             if (is.null(name)) 
[17:39:25.872]                               next
[17:39:25.872]                             if (!grepl(pattern, name)) 
[17:39:25.872]                               next
[17:39:25.872]                             invokeRestart(restart)
[17:39:25.872]                             muffled <- TRUE
[17:39:25.872]                             break
[17:39:25.872]                           }
[17:39:25.872]                         }
[17:39:25.872]                       }
[17:39:25.872]                       invisible(muffled)
[17:39:25.872]                     }
[17:39:25.872]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.872]                   }
[17:39:25.872]                 }
[17:39:25.872]             }
[17:39:25.872]         }))
[17:39:25.872]     }, error = function(ex) {
[17:39:25.872]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.872]                 ...future.rng), started = ...future.startTime, 
[17:39:25.872]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.872]             version = "1.8"), class = "FutureResult")
[17:39:25.872]     }, finally = {
[17:39:25.872]         if (!identical(...future.workdir, getwd())) 
[17:39:25.872]             setwd(...future.workdir)
[17:39:25.872]         {
[17:39:25.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.872]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.872]             }
[17:39:25.872]             base::options(...future.oldOptions)
[17:39:25.872]             if (.Platform$OS.type == "windows") {
[17:39:25.872]                 old_names <- names(...future.oldEnvVars)
[17:39:25.872]                 envs <- base::Sys.getenv()
[17:39:25.872]                 names <- names(envs)
[17:39:25.872]                 common <- intersect(names, old_names)
[17:39:25.872]                 added <- setdiff(names, old_names)
[17:39:25.872]                 removed <- setdiff(old_names, names)
[17:39:25.872]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.872]                   envs[common]]
[17:39:25.872]                 NAMES <- toupper(changed)
[17:39:25.872]                 args <- list()
[17:39:25.872]                 for (kk in seq_along(NAMES)) {
[17:39:25.872]                   name <- changed[[kk]]
[17:39:25.872]                   NAME <- NAMES[[kk]]
[17:39:25.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.872]                     next
[17:39:25.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.872]                 }
[17:39:25.872]                 NAMES <- toupper(added)
[17:39:25.872]                 for (kk in seq_along(NAMES)) {
[17:39:25.872]                   name <- added[[kk]]
[17:39:25.872]                   NAME <- NAMES[[kk]]
[17:39:25.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.872]                     next
[17:39:25.872]                   args[[name]] <- ""
[17:39:25.872]                 }
[17:39:25.872]                 NAMES <- toupper(removed)
[17:39:25.872]                 for (kk in seq_along(NAMES)) {
[17:39:25.872]                   name <- removed[[kk]]
[17:39:25.872]                   NAME <- NAMES[[kk]]
[17:39:25.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.872]                     next
[17:39:25.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.872]                 }
[17:39:25.872]                 if (length(args) > 0) 
[17:39:25.872]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.872]             }
[17:39:25.872]             else {
[17:39:25.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.872]             }
[17:39:25.872]             {
[17:39:25.872]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.872]                   0L) {
[17:39:25.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.872]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.872]                   base::options(opts)
[17:39:25.872]                 }
[17:39:25.872]                 {
[17:39:25.872]                   {
[17:39:25.872]                     NULL
[17:39:25.872]                     RNGkind("Mersenne-Twister")
[17:39:25.872]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.872]                       inherits = FALSE)
[17:39:25.872]                   }
[17:39:25.872]                   options(future.plan = NULL)
[17:39:25.872]                   if (is.na(NA_character_)) 
[17:39:25.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.872]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:25.872]                   {
[17:39:25.872]                     future <- SequentialFuture(..., envir = envir)
[17:39:25.872]                     if (!future$lazy) 
[17:39:25.872]                       future <- run(future)
[17:39:25.872]                     invisible(future)
[17:39:25.872]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.872]                 }
[17:39:25.872]             }
[17:39:25.872]         }
[17:39:25.872]     })
[17:39:25.872]     if (TRUE) {
[17:39:25.872]         base::sink(type = "output", split = FALSE)
[17:39:25.872]         if (TRUE) {
[17:39:25.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.872]         }
[17:39:25.872]         else {
[17:39:25.872]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.872]         }
[17:39:25.872]         base::close(...future.stdout)
[17:39:25.872]         ...future.stdout <- NULL
[17:39:25.872]     }
[17:39:25.872]     ...future.result$conditions <- ...future.conditions
[17:39:25.872]     ...future.result$finished <- base::Sys.time()
[17:39:25.872]     ...future.result
[17:39:25.872] }
[17:39:25.874] assign_globals() ...
[17:39:25.874] List of 7
[17:39:25.874]  $ ...future.FUN            :function (x)  
[17:39:25.874]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:25.874]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.874]  $ future.call.arguments    : list()
[17:39:25.874]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.874]  $ ...future.elements_ii    :List of 3
[17:39:25.874]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.874]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.874]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.874]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.874]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.874]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.874]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.874]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.874]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.874]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.874]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.874]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.874]  $ ...future.seeds_ii       : NULL
[17:39:25.874]  $ ...future.globals.maxSize: NULL
[17:39:25.874]  - attr(*, "resolved")= logi FALSE
[17:39:25.874]  - attr(*, "total_size")= num 2320
[17:39:25.874]  - attr(*, "where")=List of 7
[17:39:25.874]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.874]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:39:25.874]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:39:25.874]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.874]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.874]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.874]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.874]  - attr(*, "already-done")= logi TRUE
[17:39:25.886] - reassign environment for ‘...future.FUN’
[17:39:25.887] - copied ‘...future.FUN’ to environment
[17:39:25.887] - copied ‘breaks’ to environment
[17:39:25.887] - copied ‘wool’ to environment
[17:39:25.887] - copied ‘future.call.arguments’ to environment
[17:39:25.887] - copied ‘...future.elements_ii’ to environment
[17:39:25.887] - copied ‘...future.seeds_ii’ to environment
[17:39:25.887] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.887] assign_globals() ... done
[17:39:25.888] plan(): Setting new future strategy stack:
[17:39:25.888] List of future strategies:
[17:39:25.888] 1. sequential:
[17:39:25.888]    - args: function (..., envir = parent.frame())
[17:39:25.888]    - tweaked: FALSE
[17:39:25.888]    - call: NULL
[17:39:25.888] plan(): nbrOfWorkers() = 1
[17:39:25.891] plan(): Setting new future strategy stack:
[17:39:25.891] List of future strategies:
[17:39:25.891] 1. sequential:
[17:39:25.891]    - args: function (..., envir = parent.frame())
[17:39:25.891]    - tweaked: FALSE
[17:39:25.891]    - call: plan(strategy)
[17:39:25.892] plan(): nbrOfWorkers() = 1
[17:39:25.892] SequentialFuture started (and completed)
[17:39:25.892] - Launch lazy future ... done
[17:39:25.892] run() for ‘SequentialFuture’ ... done
[17:39:25.892] Created future:
[17:39:25.892] SequentialFuture:
[17:39:25.892] Label: ‘future_by-1’
[17:39:25.892] Expression:
[17:39:25.892] {
[17:39:25.892]     do.call(function(...) {
[17:39:25.892]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.892]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.892]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.892]             on.exit(options(oopts), add = TRUE)
[17:39:25.892]         }
[17:39:25.892]         {
[17:39:25.892]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.892]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.892]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.892]             })
[17:39:25.892]         }
[17:39:25.892]     }, args = future.call.arguments)
[17:39:25.892] }
[17:39:25.892] Lazy evaluation: FALSE
[17:39:25.892] Asynchronous evaluation: FALSE
[17:39:25.892] Local evaluation: TRUE
[17:39:25.892] Environment: 0x56296e9ef4e8
[17:39:25.892] Capture standard output: TRUE
[17:39:25.892] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.892] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:39:25.892] Packages: 1 packages (‘stats’)
[17:39:25.892] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.892] Resolved: TRUE
[17:39:25.892] Value: 25.57 KiB of class ‘list’
[17:39:25.892] Early signaling: FALSE
[17:39:25.892] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.892] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.894] Chunk #1 of 1 ... DONE
[17:39:25.894] Launching 1 futures (chunks) ... DONE
[17:39:25.894] Resolving 1 futures (chunks) ...
[17:39:25.894] resolve() on list ...
[17:39:25.894]  recursive: 0
[17:39:25.894]  length: 1
[17:39:25.894] 
[17:39:25.895] resolved() for ‘SequentialFuture’ ...
[17:39:25.895] - state: ‘finished’
[17:39:25.895] - run: TRUE
[17:39:25.895] - result: ‘FutureResult’
[17:39:25.895] resolved() for ‘SequentialFuture’ ... done
[17:39:25.895] Future #1
[17:39:25.895] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.895] - nx: 1
[17:39:25.895] - relay: TRUE
[17:39:25.895] - stdout: TRUE
[17:39:25.896] - signal: TRUE
[17:39:25.896] - resignal: FALSE
[17:39:25.896] - force: TRUE
[17:39:25.896] - relayed: [n=1] FALSE
[17:39:25.896] - queued futures: [n=1] FALSE
[17:39:25.896]  - until=1
[17:39:25.896]  - relaying element #1
[17:39:25.896] - relayed: [n=1] TRUE
[17:39:25.896] - queued futures: [n=1] TRUE
[17:39:25.896] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.897]  length: 0 (resolved future 1)
[17:39:25.897] Relaying remaining futures
[17:39:25.897] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.897] - nx: 1
[17:39:25.897] - relay: TRUE
[17:39:25.897] - stdout: TRUE
[17:39:25.897] - signal: TRUE
[17:39:25.897] - resignal: FALSE
[17:39:25.897] - force: TRUE
[17:39:25.897] - relayed: [n=1] TRUE
[17:39:25.897] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.898] - relayed: [n=1] TRUE
[17:39:25.898] - queued futures: [n=1] TRUE
[17:39:25.898] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.898] resolve() on list ... DONE
[17:39:25.898]  - Number of value chunks collected: 1
[17:39:25.898] Resolving 1 futures (chunks) ... DONE
[17:39:25.898] Reducing values from 1 chunks ...
[17:39:25.898]  - Number of values collected after concatenation: 3
[17:39:25.898]  - Number of values expected: 3
[17:39:25.898] Reducing values from 1 chunks ... DONE
[17:39:25.899] future_lapply() ... DONE
[17:39:25.899] future_by_internal() ... DONE
[17:39:25.899] future_by_internal() ...
[17:39:25.899] future_lapply() ...
[17:39:25.900] Number of chunks: 1
[17:39:25.900] getGlobalsAndPackagesXApply() ...
[17:39:25.900]  - future.globals: TRUE
[17:39:25.900] getGlobalsAndPackages() ...
[17:39:25.900] Searching for globals...
[17:39:25.901] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.901] Searching for globals ... DONE
[17:39:25.902] Resolving globals: FALSE
[17:39:25.902] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.902] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.902] - globals: [1] ‘FUN’
[17:39:25.902] 
[17:39:25.903] getGlobalsAndPackages() ... DONE
[17:39:25.903]  - globals found/used: [n=1] ‘FUN’
[17:39:25.903]  - needed namespaces: [n=0] 
[17:39:25.903] Finding globals ... DONE
[17:39:25.903]  - use_args: TRUE
[17:39:25.905]  - Getting '...' globals ...
[17:39:25.905] resolve() on list ...
[17:39:25.905]  recursive: 0
[17:39:25.905]  length: 1
[17:39:25.905]  elements: ‘...’
[17:39:25.905]  length: 0 (resolved future 1)
[17:39:25.905] resolve() on list ... DONE
[17:39:25.905]    - '...' content: [n=0] 
[17:39:25.906] List of 1
[17:39:25.906]  $ ...: list()
[17:39:25.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.906]  - attr(*, "where")=List of 1
[17:39:25.906]   ..$ ...:<environment: 0x5629708d63b8> 
[17:39:25.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.906]  - attr(*, "resolved")= logi TRUE
[17:39:25.906]  - attr(*, "total_size")= num NA
[17:39:25.908]  - Getting '...' globals ... DONE
[17:39:25.909] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.909] List of 2
[17:39:25.909]  $ ...future.FUN:function (object, ...)  
[17:39:25.909]  $ ...          : list()
[17:39:25.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.909]  - attr(*, "where")=List of 2
[17:39:25.909]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.909]   ..$ ...          :<environment: 0x5629708d63b8> 
[17:39:25.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.909]  - attr(*, "resolved")= logi FALSE
[17:39:25.909]  - attr(*, "total_size")= num 1240
[17:39:25.911] Packages to be attached in all futures: [n=0] 
[17:39:25.911] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.912] Number of futures (= number of chunks): 1
[17:39:25.912] Launching 1 futures (chunks) ...
[17:39:25.912] Chunk #1 of 1 ...
[17:39:25.912]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.912] getGlobalsAndPackages() ...
[17:39:25.912] Searching for globals...
[17:39:25.913] 
[17:39:25.913] Searching for globals ... DONE
[17:39:25.913] - globals: [0] <none>
[17:39:25.913] getGlobalsAndPackages() ... DONE
[17:39:25.913]    + additional globals found: [n=0] 
[17:39:25.913]    + additional namespaces needed: [n=0] 
[17:39:25.913]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.913]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.913]  - seeds: <none>
[17:39:25.914] getGlobalsAndPackages() ...
[17:39:25.914] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.914] Resolving globals: FALSE
[17:39:25.914] Tweak future expression to call with '...' arguments ...
[17:39:25.914] {
[17:39:25.914]     do.call(function(...) {
[17:39:25.914]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.914]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.914]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.914]             on.exit(options(oopts), add = TRUE)
[17:39:25.914]         }
[17:39:25.914]         {
[17:39:25.914]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.914]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.914]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.914]             })
[17:39:25.914]         }
[17:39:25.914]     }, args = future.call.arguments)
[17:39:25.914] }
[17:39:25.914] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.915] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.915] 
[17:39:25.915] getGlobalsAndPackages() ... DONE
[17:39:25.915] run() for ‘Future’ ...
[17:39:25.915] - state: ‘created’
[17:39:25.915] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:25.916] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.916] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.916]   - Field: ‘label’
[17:39:25.916]   - Field: ‘local’
[17:39:25.916]   - Field: ‘owner’
[17:39:25.916]   - Field: ‘envir’
[17:39:25.916]   - Field: ‘packages’
[17:39:25.916]   - Field: ‘gc’
[17:39:25.916]   - Field: ‘conditions’
[17:39:25.916]   - Field: ‘expr’
[17:39:25.917]   - Field: ‘uuid’
[17:39:25.917]   - Field: ‘seed’
[17:39:25.917]   - Field: ‘version’
[17:39:25.917]   - Field: ‘result’
[17:39:25.917]   - Field: ‘asynchronous’
[17:39:25.917]   - Field: ‘calls’
[17:39:25.917]   - Field: ‘globals’
[17:39:25.917]   - Field: ‘stdout’
[17:39:25.917]   - Field: ‘earlySignal’
[17:39:25.917]   - Field: ‘lazy’
[17:39:25.917]   - Field: ‘state’
[17:39:25.918] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.918] - Launch lazy future ...
[17:39:25.918] Packages needed by the future expression (n = 0): <none>
[17:39:25.918] Packages needed by future strategies (n = 0): <none>
[17:39:25.918] {
[17:39:25.918]     {
[17:39:25.918]         {
[17:39:25.918]             ...future.startTime <- base::Sys.time()
[17:39:25.918]             {
[17:39:25.918]                 {
[17:39:25.918]                   {
[17:39:25.918]                     base::local({
[17:39:25.918]                       has_future <- base::requireNamespace("future", 
[17:39:25.918]                         quietly = TRUE)
[17:39:25.918]                       if (has_future) {
[17:39:25.918]                         ns <- base::getNamespace("future")
[17:39:25.918]                         version <- ns[[".package"]][["version"]]
[17:39:25.918]                         if (is.null(version)) 
[17:39:25.918]                           version <- utils::packageVersion("future")
[17:39:25.918]                       }
[17:39:25.918]                       else {
[17:39:25.918]                         version <- NULL
[17:39:25.918]                       }
[17:39:25.918]                       if (!has_future || version < "1.8.0") {
[17:39:25.918]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.918]                           "", base::R.version$version.string), 
[17:39:25.918]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.918]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.918]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.918]                             "release", "version")], collapse = " "), 
[17:39:25.918]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.918]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.918]                           info)
[17:39:25.918]                         info <- base::paste(info, collapse = "; ")
[17:39:25.918]                         if (!has_future) {
[17:39:25.918]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.918]                             info)
[17:39:25.918]                         }
[17:39:25.918]                         else {
[17:39:25.918]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.918]                             info, version)
[17:39:25.918]                         }
[17:39:25.918]                         base::stop(msg)
[17:39:25.918]                       }
[17:39:25.918]                     })
[17:39:25.918]                   }
[17:39:25.918]                   options(future.plan = NULL)
[17:39:25.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.918]                 }
[17:39:25.918]                 ...future.workdir <- getwd()
[17:39:25.918]             }
[17:39:25.918]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.918]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.918]         }
[17:39:25.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.918]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.918]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.918]             base::names(...future.oldOptions))
[17:39:25.918]     }
[17:39:25.918]     if (FALSE) {
[17:39:25.918]     }
[17:39:25.918]     else {
[17:39:25.918]         if (TRUE) {
[17:39:25.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.918]                 open = "w")
[17:39:25.918]         }
[17:39:25.918]         else {
[17:39:25.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.918]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.918]         }
[17:39:25.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.918]             base::sink(type = "output", split = FALSE)
[17:39:25.918]             base::close(...future.stdout)
[17:39:25.918]         }, add = TRUE)
[17:39:25.918]     }
[17:39:25.918]     ...future.frame <- base::sys.nframe()
[17:39:25.918]     ...future.conditions <- base::list()
[17:39:25.918]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.918]     if (FALSE) {
[17:39:25.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.918]     }
[17:39:25.918]     ...future.result <- base::tryCatch({
[17:39:25.918]         base::withCallingHandlers({
[17:39:25.918]             ...future.value <- base::withVisible(base::local({
[17:39:25.918]                 do.call(function(...) {
[17:39:25.918]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.918]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.918]                     ...future.globals.maxSize)) {
[17:39:25.918]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.918]                     on.exit(options(oopts), add = TRUE)
[17:39:25.918]                   }
[17:39:25.918]                   {
[17:39:25.918]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.918]                       FUN = function(jj) {
[17:39:25.918]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.918]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.918]                       })
[17:39:25.918]                   }
[17:39:25.918]                 }, args = future.call.arguments)
[17:39:25.918]             }))
[17:39:25.918]             future::FutureResult(value = ...future.value$value, 
[17:39:25.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.918]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.918]                     ...future.globalenv.names))
[17:39:25.918]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.918]         }, condition = base::local({
[17:39:25.918]             c <- base::c
[17:39:25.918]             inherits <- base::inherits
[17:39:25.918]             invokeRestart <- base::invokeRestart
[17:39:25.918]             length <- base::length
[17:39:25.918]             list <- base::list
[17:39:25.918]             seq.int <- base::seq.int
[17:39:25.918]             signalCondition <- base::signalCondition
[17:39:25.918]             sys.calls <- base::sys.calls
[17:39:25.918]             `[[` <- base::`[[`
[17:39:25.918]             `+` <- base::`+`
[17:39:25.918]             `<<-` <- base::`<<-`
[17:39:25.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.918]                   3L)]
[17:39:25.918]             }
[17:39:25.918]             function(cond) {
[17:39:25.918]                 is_error <- inherits(cond, "error")
[17:39:25.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.918]                   NULL)
[17:39:25.918]                 if (is_error) {
[17:39:25.918]                   sessionInformation <- function() {
[17:39:25.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.918]                       search = base::search(), system = base::Sys.info())
[17:39:25.918]                   }
[17:39:25.918]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.918]                     cond$call), session = sessionInformation(), 
[17:39:25.918]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.918]                   signalCondition(cond)
[17:39:25.918]                 }
[17:39:25.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.918]                 "immediateCondition"))) {
[17:39:25.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.918]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.918]                   if (TRUE && !signal) {
[17:39:25.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.918]                     {
[17:39:25.918]                       inherits <- base::inherits
[17:39:25.918]                       invokeRestart <- base::invokeRestart
[17:39:25.918]                       is.null <- base::is.null
[17:39:25.918]                       muffled <- FALSE
[17:39:25.918]                       if (inherits(cond, "message")) {
[17:39:25.918]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.918]                         if (muffled) 
[17:39:25.918]                           invokeRestart("muffleMessage")
[17:39:25.918]                       }
[17:39:25.918]                       else if (inherits(cond, "warning")) {
[17:39:25.918]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.918]                         if (muffled) 
[17:39:25.918]                           invokeRestart("muffleWarning")
[17:39:25.918]                       }
[17:39:25.918]                       else if (inherits(cond, "condition")) {
[17:39:25.918]                         if (!is.null(pattern)) {
[17:39:25.918]                           computeRestarts <- base::computeRestarts
[17:39:25.918]                           grepl <- base::grepl
[17:39:25.918]                           restarts <- computeRestarts(cond)
[17:39:25.918]                           for (restart in restarts) {
[17:39:25.918]                             name <- restart$name
[17:39:25.918]                             if (is.null(name)) 
[17:39:25.918]                               next
[17:39:25.918]                             if (!grepl(pattern, name)) 
[17:39:25.918]                               next
[17:39:25.918]                             invokeRestart(restart)
[17:39:25.918]                             muffled <- TRUE
[17:39:25.918]                             break
[17:39:25.918]                           }
[17:39:25.918]                         }
[17:39:25.918]                       }
[17:39:25.918]                       invisible(muffled)
[17:39:25.918]                     }
[17:39:25.918]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.918]                   }
[17:39:25.918]                 }
[17:39:25.918]                 else {
[17:39:25.918]                   if (TRUE) {
[17:39:25.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.918]                     {
[17:39:25.918]                       inherits <- base::inherits
[17:39:25.918]                       invokeRestart <- base::invokeRestart
[17:39:25.918]                       is.null <- base::is.null
[17:39:25.918]                       muffled <- FALSE
[17:39:25.918]                       if (inherits(cond, "message")) {
[17:39:25.918]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.918]                         if (muffled) 
[17:39:25.918]                           invokeRestart("muffleMessage")
[17:39:25.918]                       }
[17:39:25.918]                       else if (inherits(cond, "warning")) {
[17:39:25.918]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.918]                         if (muffled) 
[17:39:25.918]                           invokeRestart("muffleWarning")
[17:39:25.918]                       }
[17:39:25.918]                       else if (inherits(cond, "condition")) {
[17:39:25.918]                         if (!is.null(pattern)) {
[17:39:25.918]                           computeRestarts <- base::computeRestarts
[17:39:25.918]                           grepl <- base::grepl
[17:39:25.918]                           restarts <- computeRestarts(cond)
[17:39:25.918]                           for (restart in restarts) {
[17:39:25.918]                             name <- restart$name
[17:39:25.918]                             if (is.null(name)) 
[17:39:25.918]                               next
[17:39:25.918]                             if (!grepl(pattern, name)) 
[17:39:25.918]                               next
[17:39:25.918]                             invokeRestart(restart)
[17:39:25.918]                             muffled <- TRUE
[17:39:25.918]                             break
[17:39:25.918]                           }
[17:39:25.918]                         }
[17:39:25.918]                       }
[17:39:25.918]                       invisible(muffled)
[17:39:25.918]                     }
[17:39:25.918]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.918]                   }
[17:39:25.918]                 }
[17:39:25.918]             }
[17:39:25.918]         }))
[17:39:25.918]     }, error = function(ex) {
[17:39:25.918]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.918]                 ...future.rng), started = ...future.startTime, 
[17:39:25.918]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.918]             version = "1.8"), class = "FutureResult")
[17:39:25.918]     }, finally = {
[17:39:25.918]         if (!identical(...future.workdir, getwd())) 
[17:39:25.918]             setwd(...future.workdir)
[17:39:25.918]         {
[17:39:25.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.918]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.918]             }
[17:39:25.918]             base::options(...future.oldOptions)
[17:39:25.918]             if (.Platform$OS.type == "windows") {
[17:39:25.918]                 old_names <- names(...future.oldEnvVars)
[17:39:25.918]                 envs <- base::Sys.getenv()
[17:39:25.918]                 names <- names(envs)
[17:39:25.918]                 common <- intersect(names, old_names)
[17:39:25.918]                 added <- setdiff(names, old_names)
[17:39:25.918]                 removed <- setdiff(old_names, names)
[17:39:25.918]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.918]                   envs[common]]
[17:39:25.918]                 NAMES <- toupper(changed)
[17:39:25.918]                 args <- list()
[17:39:25.918]                 for (kk in seq_along(NAMES)) {
[17:39:25.918]                   name <- changed[[kk]]
[17:39:25.918]                   NAME <- NAMES[[kk]]
[17:39:25.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.918]                     next
[17:39:25.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.918]                 }
[17:39:25.918]                 NAMES <- toupper(added)
[17:39:25.918]                 for (kk in seq_along(NAMES)) {
[17:39:25.918]                   name <- added[[kk]]
[17:39:25.918]                   NAME <- NAMES[[kk]]
[17:39:25.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.918]                     next
[17:39:25.918]                   args[[name]] <- ""
[17:39:25.918]                 }
[17:39:25.918]                 NAMES <- toupper(removed)
[17:39:25.918]                 for (kk in seq_along(NAMES)) {
[17:39:25.918]                   name <- removed[[kk]]
[17:39:25.918]                   NAME <- NAMES[[kk]]
[17:39:25.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.918]                     next
[17:39:25.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.918]                 }
[17:39:25.918]                 if (length(args) > 0) 
[17:39:25.918]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.918]             }
[17:39:25.918]             else {
[17:39:25.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.918]             }
[17:39:25.918]             {
[17:39:25.918]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.918]                   0L) {
[17:39:25.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.918]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.918]                   base::options(opts)
[17:39:25.918]                 }
[17:39:25.918]                 {
[17:39:25.918]                   {
[17:39:25.918]                     NULL
[17:39:25.918]                     RNGkind("Mersenne-Twister")
[17:39:25.918]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.918]                       inherits = FALSE)
[17:39:25.918]                   }
[17:39:25.918]                   options(future.plan = NULL)
[17:39:25.918]                   if (is.na(NA_character_)) 
[17:39:25.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.918]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:25.918]                   {
[17:39:25.918]                     future <- SequentialFuture(..., envir = envir)
[17:39:25.918]                     if (!future$lazy) 
[17:39:25.918]                       future <- run(future)
[17:39:25.918]                     invisible(future)
[17:39:25.918]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.918]                 }
[17:39:25.918]             }
[17:39:25.918]         }
[17:39:25.918]     })
[17:39:25.918]     if (TRUE) {
[17:39:25.918]         base::sink(type = "output", split = FALSE)
[17:39:25.918]         if (TRUE) {
[17:39:25.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.918]         }
[17:39:25.918]         else {
[17:39:25.918]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.918]         }
[17:39:25.918]         base::close(...future.stdout)
[17:39:25.918]         ...future.stdout <- NULL
[17:39:25.918]     }
[17:39:25.918]     ...future.result$conditions <- ...future.conditions
[17:39:25.918]     ...future.result$finished <- base::Sys.time()
[17:39:25.918]     ...future.result
[17:39:25.918] }
[17:39:25.920] assign_globals() ...
[17:39:25.920] List of 5
[17:39:25.920]  $ ...future.FUN            :function (object, ...)  
[17:39:25.920]  $ future.call.arguments    : list()
[17:39:25.920]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.920]  $ ...future.elements_ii    :List of 3
[17:39:25.920]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.920]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.920]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.920]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.920]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.920]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.920]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.920]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.920]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.920]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.920]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.920]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.920]  $ ...future.seeds_ii       : NULL
[17:39:25.920]  $ ...future.globals.maxSize: NULL
[17:39:25.920]  - attr(*, "resolved")= logi FALSE
[17:39:25.920]  - attr(*, "total_size")= num 1240
[17:39:25.920]  - attr(*, "where")=List of 5
[17:39:25.920]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.920]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.920]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.920]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.920]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.920]  - attr(*, "already-done")= logi TRUE
[17:39:25.931] - copied ‘...future.FUN’ to environment
[17:39:25.931] - copied ‘future.call.arguments’ to environment
[17:39:25.931] - copied ‘...future.elements_ii’ to environment
[17:39:25.931] - copied ‘...future.seeds_ii’ to environment
[17:39:25.931] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.931] assign_globals() ... done
[17:39:25.931] plan(): Setting new future strategy stack:
[17:39:25.932] List of future strategies:
[17:39:25.932] 1. sequential:
[17:39:25.932]    - args: function (..., envir = parent.frame())
[17:39:25.932]    - tweaked: FALSE
[17:39:25.932]    - call: NULL
[17:39:25.932] plan(): nbrOfWorkers() = 1
[17:39:25.934] plan(): Setting new future strategy stack:
[17:39:25.934] List of future strategies:
[17:39:25.934] 1. sequential:
[17:39:25.934]    - args: function (..., envir = parent.frame())
[17:39:25.934]    - tweaked: FALSE
[17:39:25.934]    - call: plan(strategy)
[17:39:25.935] plan(): nbrOfWorkers() = 1
[17:39:25.935] SequentialFuture started (and completed)
[17:39:25.935] - Launch lazy future ... done
[17:39:25.935] run() for ‘SequentialFuture’ ... done
[17:39:25.935] Created future:
[17:39:25.935] SequentialFuture:
[17:39:25.935] Label: ‘future_by-1’
[17:39:25.935] Expression:
[17:39:25.935] {
[17:39:25.935]     do.call(function(...) {
[17:39:25.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.935]             on.exit(options(oopts), add = TRUE)
[17:39:25.935]         }
[17:39:25.935]         {
[17:39:25.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.935]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.935]             })
[17:39:25.935]         }
[17:39:25.935]     }, args = future.call.arguments)
[17:39:25.935] }
[17:39:25.935] Lazy evaluation: FALSE
[17:39:25.935] Asynchronous evaluation: FALSE
[17:39:25.935] Local evaluation: TRUE
[17:39:25.935] Environment: 0x56297089d0d0
[17:39:25.935] Capture standard output: TRUE
[17:39:25.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.935] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.935] Packages: <none>
[17:39:25.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.935] Resolved: TRUE
[17:39:25.935] Value: 5.37 KiB of class ‘list’
[17:39:25.935] Early signaling: FALSE
[17:39:25.935] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.935] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.936] Chunk #1 of 1 ... DONE
[17:39:25.937] Launching 1 futures (chunks) ... DONE
[17:39:25.937] Resolving 1 futures (chunks) ...
[17:39:25.937] resolve() on list ...
[17:39:25.937]  recursive: 0
[17:39:25.937]  length: 1
[17:39:25.937] 
[17:39:25.937] resolved() for ‘SequentialFuture’ ...
[17:39:25.937] - state: ‘finished’
[17:39:25.937] - run: TRUE
[17:39:25.937] - result: ‘FutureResult’
[17:39:25.937] resolved() for ‘SequentialFuture’ ... done
[17:39:25.938] Future #1
[17:39:25.938] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.938] - nx: 1
[17:39:25.938] - relay: TRUE
[17:39:25.938] - stdout: TRUE
[17:39:25.938] - signal: TRUE
[17:39:25.938] - resignal: FALSE
[17:39:25.938] - force: TRUE
[17:39:25.938] - relayed: [n=1] FALSE
[17:39:25.938] - queued futures: [n=1] FALSE
[17:39:25.938]  - until=1
[17:39:25.939]  - relaying element #1
[17:39:25.939] - relayed: [n=1] TRUE
[17:39:25.939] - queued futures: [n=1] TRUE
[17:39:25.939] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.939]  length: 0 (resolved future 1)
[17:39:25.939] Relaying remaining futures
[17:39:25.939] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.939] - nx: 1
[17:39:25.939] - relay: TRUE
[17:39:25.939] - stdout: TRUE
[17:39:25.940] - signal: TRUE
[17:39:25.940] - resignal: FALSE
[17:39:25.940] - force: TRUE
[17:39:25.940] - relayed: [n=1] TRUE
[17:39:25.940] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.940] - relayed: [n=1] TRUE
[17:39:25.940] - queued futures: [n=1] TRUE
[17:39:25.940] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.940] resolve() on list ... DONE
[17:39:25.940]  - Number of value chunks collected: 1
[17:39:25.941] Resolving 1 futures (chunks) ... DONE
[17:39:25.941] Reducing values from 1 chunks ...
[17:39:25.941]  - Number of values collected after concatenation: 3
[17:39:25.941]  - Number of values expected: 3
[17:39:25.941] Reducing values from 1 chunks ... DONE
[17:39:25.941] future_lapply() ... DONE
[17:39:25.941] future_by_internal() ... DONE
[17:39:25.942] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:39:25.942] future_lapply() ...
[17:39:25.943] Number of chunks: 1
[17:39:25.943] getGlobalsAndPackagesXApply() ...
[17:39:25.943]  - future.globals: TRUE
[17:39:25.943] getGlobalsAndPackages() ...
[17:39:25.943] Searching for globals...
[17:39:25.946] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.946] Searching for globals ... DONE
[17:39:25.946] Resolving globals: FALSE
[17:39:25.946] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.946] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.947] - globals: [1] ‘FUN’
[17:39:25.947] 
[17:39:25.947] getGlobalsAndPackages() ... DONE
[17:39:25.947]  - globals found/used: [n=1] ‘FUN’
[17:39:25.947]  - needed namespaces: [n=0] 
[17:39:25.947] Finding globals ... DONE
[17:39:25.947]  - use_args: TRUE
[17:39:25.947]  - Getting '...' globals ...
[17:39:25.948] resolve() on list ...
[17:39:25.948]  recursive: 0
[17:39:25.948]  length: 1
[17:39:25.948]  elements: ‘...’
[17:39:25.948]  length: 0 (resolved future 1)
[17:39:25.948] resolve() on list ... DONE
[17:39:25.948]    - '...' content: [n=0] 
[17:39:25.948] List of 1
[17:39:25.948]  $ ...: list()
[17:39:25.948]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.948]  - attr(*, "where")=List of 1
[17:39:25.948]   ..$ ...:<environment: 0x562970d3e2b8> 
[17:39:25.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.948]  - attr(*, "resolved")= logi TRUE
[17:39:25.948]  - attr(*, "total_size")= num NA
[17:39:25.951]  - Getting '...' globals ... DONE
[17:39:25.951] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:25.951] List of 2
[17:39:25.951]  $ ...future.FUN:function (object, ...)  
[17:39:25.951]  $ ...          : list()
[17:39:25.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.951]  - attr(*, "where")=List of 2
[17:39:25.951]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:25.951]   ..$ ...          :<environment: 0x562970d3e2b8> 
[17:39:25.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.951]  - attr(*, "resolved")= logi FALSE
[17:39:25.951]  - attr(*, "total_size")= num 1240
[17:39:25.954] Packages to be attached in all futures: [n=0] 
[17:39:25.954] getGlobalsAndPackagesXApply() ... DONE
[17:39:25.954] Number of futures (= number of chunks): 1
[17:39:25.954] Launching 1 futures (chunks) ...
[17:39:25.954] Chunk #1 of 1 ...
[17:39:25.954]  - Finding globals in 'X' for chunk #1 ...
[17:39:25.954] getGlobalsAndPackages() ...
[17:39:25.954] Searching for globals...
[17:39:25.955] 
[17:39:25.955] Searching for globals ... DONE
[17:39:25.955] - globals: [0] <none>
[17:39:25.955] getGlobalsAndPackages() ... DONE
[17:39:25.955]    + additional globals found: [n=0] 
[17:39:25.955]    + additional namespaces needed: [n=0] 
[17:39:25.955]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:25.956]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:25.956]  - seeds: <none>
[17:39:25.956] getGlobalsAndPackages() ...
[17:39:25.956] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.956] Resolving globals: FALSE
[17:39:25.956] Tweak future expression to call with '...' arguments ...
[17:39:25.956] {
[17:39:25.956]     do.call(function(...) {
[17:39:25.956]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.956]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.956]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.956]             on.exit(options(oopts), add = TRUE)
[17:39:25.956]         }
[17:39:25.956]         {
[17:39:25.956]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.956]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.956]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.956]             })
[17:39:25.956]         }
[17:39:25.956]     }, args = future.call.arguments)
[17:39:25.956] }
[17:39:25.956] Tweak future expression to call with '...' arguments ... DONE
[17:39:25.957] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:25.957] 
[17:39:25.957] getGlobalsAndPackages() ... DONE
[17:39:25.957] run() for ‘Future’ ...
[17:39:25.957] - state: ‘created’
[17:39:25.957] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:25.958] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.958] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:25.958]   - Field: ‘label’
[17:39:25.958]   - Field: ‘local’
[17:39:25.958]   - Field: ‘owner’
[17:39:25.958]   - Field: ‘envir’
[17:39:25.958]   - Field: ‘packages’
[17:39:25.958]   - Field: ‘gc’
[17:39:25.959]   - Field: ‘conditions’
[17:39:25.959]   - Field: ‘expr’
[17:39:25.959]   - Field: ‘uuid’
[17:39:25.959]   - Field: ‘seed’
[17:39:25.959]   - Field: ‘version’
[17:39:25.959]   - Field: ‘result’
[17:39:25.959]   - Field: ‘asynchronous’
[17:39:25.959]   - Field: ‘calls’
[17:39:25.959]   - Field: ‘globals’
[17:39:25.959]   - Field: ‘stdout’
[17:39:25.959]   - Field: ‘earlySignal’
[17:39:25.960]   - Field: ‘lazy’
[17:39:25.960]   - Field: ‘state’
[17:39:25.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:25.960] - Launch lazy future ...
[17:39:25.960] Packages needed by the future expression (n = 0): <none>
[17:39:25.960] Packages needed by future strategies (n = 0): <none>
[17:39:25.961] {
[17:39:25.961]     {
[17:39:25.961]         {
[17:39:25.961]             ...future.startTime <- base::Sys.time()
[17:39:25.961]             {
[17:39:25.961]                 {
[17:39:25.961]                   {
[17:39:25.961]                     base::local({
[17:39:25.961]                       has_future <- base::requireNamespace("future", 
[17:39:25.961]                         quietly = TRUE)
[17:39:25.961]                       if (has_future) {
[17:39:25.961]                         ns <- base::getNamespace("future")
[17:39:25.961]                         version <- ns[[".package"]][["version"]]
[17:39:25.961]                         if (is.null(version)) 
[17:39:25.961]                           version <- utils::packageVersion("future")
[17:39:25.961]                       }
[17:39:25.961]                       else {
[17:39:25.961]                         version <- NULL
[17:39:25.961]                       }
[17:39:25.961]                       if (!has_future || version < "1.8.0") {
[17:39:25.961]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:25.961]                           "", base::R.version$version.string), 
[17:39:25.961]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:25.961]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:25.961]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:25.961]                             "release", "version")], collapse = " "), 
[17:39:25.961]                           hostname = base::Sys.info()[["nodename"]])
[17:39:25.961]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:25.961]                           info)
[17:39:25.961]                         info <- base::paste(info, collapse = "; ")
[17:39:25.961]                         if (!has_future) {
[17:39:25.961]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:25.961]                             info)
[17:39:25.961]                         }
[17:39:25.961]                         else {
[17:39:25.961]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:25.961]                             info, version)
[17:39:25.961]                         }
[17:39:25.961]                         base::stop(msg)
[17:39:25.961]                       }
[17:39:25.961]                     })
[17:39:25.961]                   }
[17:39:25.961]                   options(future.plan = NULL)
[17:39:25.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:25.961]                 }
[17:39:25.961]                 ...future.workdir <- getwd()
[17:39:25.961]             }
[17:39:25.961]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:25.961]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:25.961]         }
[17:39:25.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:25.961]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:25.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:25.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:25.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:25.961]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:25.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:25.961]             base::names(...future.oldOptions))
[17:39:25.961]     }
[17:39:25.961]     if (FALSE) {
[17:39:25.961]     }
[17:39:25.961]     else {
[17:39:25.961]         if (TRUE) {
[17:39:25.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:25.961]                 open = "w")
[17:39:25.961]         }
[17:39:25.961]         else {
[17:39:25.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:25.961]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:25.961]         }
[17:39:25.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:25.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:25.961]             base::sink(type = "output", split = FALSE)
[17:39:25.961]             base::close(...future.stdout)
[17:39:25.961]         }, add = TRUE)
[17:39:25.961]     }
[17:39:25.961]     ...future.frame <- base::sys.nframe()
[17:39:25.961]     ...future.conditions <- base::list()
[17:39:25.961]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:25.961]     if (FALSE) {
[17:39:25.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:25.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:25.961]     }
[17:39:25.961]     ...future.result <- base::tryCatch({
[17:39:25.961]         base::withCallingHandlers({
[17:39:25.961]             ...future.value <- base::withVisible(base::local({
[17:39:25.961]                 do.call(function(...) {
[17:39:25.961]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.961]                   if (!identical(...future.globals.maxSize.org, 
[17:39:25.961]                     ...future.globals.maxSize)) {
[17:39:25.961]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.961]                     on.exit(options(oopts), add = TRUE)
[17:39:25.961]                   }
[17:39:25.961]                   {
[17:39:25.961]                     lapply(seq_along(...future.elements_ii), 
[17:39:25.961]                       FUN = function(jj) {
[17:39:25.961]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.961]                         ...future.FUN(...future.X_jj, ...)
[17:39:25.961]                       })
[17:39:25.961]                   }
[17:39:25.961]                 }, args = future.call.arguments)
[17:39:25.961]             }))
[17:39:25.961]             future::FutureResult(value = ...future.value$value, 
[17:39:25.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.961]                   ...future.rng), globalenv = if (FALSE) 
[17:39:25.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:25.961]                     ...future.globalenv.names))
[17:39:25.961]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:25.961]         }, condition = base::local({
[17:39:25.961]             c <- base::c
[17:39:25.961]             inherits <- base::inherits
[17:39:25.961]             invokeRestart <- base::invokeRestart
[17:39:25.961]             length <- base::length
[17:39:25.961]             list <- base::list
[17:39:25.961]             seq.int <- base::seq.int
[17:39:25.961]             signalCondition <- base::signalCondition
[17:39:25.961]             sys.calls <- base::sys.calls
[17:39:25.961]             `[[` <- base::`[[`
[17:39:25.961]             `+` <- base::`+`
[17:39:25.961]             `<<-` <- base::`<<-`
[17:39:25.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:25.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:25.961]                   3L)]
[17:39:25.961]             }
[17:39:25.961]             function(cond) {
[17:39:25.961]                 is_error <- inherits(cond, "error")
[17:39:25.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:25.961]                   NULL)
[17:39:25.961]                 if (is_error) {
[17:39:25.961]                   sessionInformation <- function() {
[17:39:25.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:25.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:25.961]                       search = base::search(), system = base::Sys.info())
[17:39:25.961]                   }
[17:39:25.961]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:25.961]                     cond$call), session = sessionInformation(), 
[17:39:25.961]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:25.961]                   signalCondition(cond)
[17:39:25.961]                 }
[17:39:25.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:25.961]                 "immediateCondition"))) {
[17:39:25.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:25.961]                   ...future.conditions[[length(...future.conditions) + 
[17:39:25.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:25.961]                   if (TRUE && !signal) {
[17:39:25.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.961]                     {
[17:39:25.961]                       inherits <- base::inherits
[17:39:25.961]                       invokeRestart <- base::invokeRestart
[17:39:25.961]                       is.null <- base::is.null
[17:39:25.961]                       muffled <- FALSE
[17:39:25.961]                       if (inherits(cond, "message")) {
[17:39:25.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.961]                         if (muffled) 
[17:39:25.961]                           invokeRestart("muffleMessage")
[17:39:25.961]                       }
[17:39:25.961]                       else if (inherits(cond, "warning")) {
[17:39:25.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.961]                         if (muffled) 
[17:39:25.961]                           invokeRestart("muffleWarning")
[17:39:25.961]                       }
[17:39:25.961]                       else if (inherits(cond, "condition")) {
[17:39:25.961]                         if (!is.null(pattern)) {
[17:39:25.961]                           computeRestarts <- base::computeRestarts
[17:39:25.961]                           grepl <- base::grepl
[17:39:25.961]                           restarts <- computeRestarts(cond)
[17:39:25.961]                           for (restart in restarts) {
[17:39:25.961]                             name <- restart$name
[17:39:25.961]                             if (is.null(name)) 
[17:39:25.961]                               next
[17:39:25.961]                             if (!grepl(pattern, name)) 
[17:39:25.961]                               next
[17:39:25.961]                             invokeRestart(restart)
[17:39:25.961]                             muffled <- TRUE
[17:39:25.961]                             break
[17:39:25.961]                           }
[17:39:25.961]                         }
[17:39:25.961]                       }
[17:39:25.961]                       invisible(muffled)
[17:39:25.961]                     }
[17:39:25.961]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.961]                   }
[17:39:25.961]                 }
[17:39:25.961]                 else {
[17:39:25.961]                   if (TRUE) {
[17:39:25.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:25.961]                     {
[17:39:25.961]                       inherits <- base::inherits
[17:39:25.961]                       invokeRestart <- base::invokeRestart
[17:39:25.961]                       is.null <- base::is.null
[17:39:25.961]                       muffled <- FALSE
[17:39:25.961]                       if (inherits(cond, "message")) {
[17:39:25.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:25.961]                         if (muffled) 
[17:39:25.961]                           invokeRestart("muffleMessage")
[17:39:25.961]                       }
[17:39:25.961]                       else if (inherits(cond, "warning")) {
[17:39:25.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:25.961]                         if (muffled) 
[17:39:25.961]                           invokeRestart("muffleWarning")
[17:39:25.961]                       }
[17:39:25.961]                       else if (inherits(cond, "condition")) {
[17:39:25.961]                         if (!is.null(pattern)) {
[17:39:25.961]                           computeRestarts <- base::computeRestarts
[17:39:25.961]                           grepl <- base::grepl
[17:39:25.961]                           restarts <- computeRestarts(cond)
[17:39:25.961]                           for (restart in restarts) {
[17:39:25.961]                             name <- restart$name
[17:39:25.961]                             if (is.null(name)) 
[17:39:25.961]                               next
[17:39:25.961]                             if (!grepl(pattern, name)) 
[17:39:25.961]                               next
[17:39:25.961]                             invokeRestart(restart)
[17:39:25.961]                             muffled <- TRUE
[17:39:25.961]                             break
[17:39:25.961]                           }
[17:39:25.961]                         }
[17:39:25.961]                       }
[17:39:25.961]                       invisible(muffled)
[17:39:25.961]                     }
[17:39:25.961]                     muffleCondition(cond, pattern = "^muffle")
[17:39:25.961]                   }
[17:39:25.961]                 }
[17:39:25.961]             }
[17:39:25.961]         }))
[17:39:25.961]     }, error = function(ex) {
[17:39:25.961]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:25.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:25.961]                 ...future.rng), started = ...future.startTime, 
[17:39:25.961]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:25.961]             version = "1.8"), class = "FutureResult")
[17:39:25.961]     }, finally = {
[17:39:25.961]         if (!identical(...future.workdir, getwd())) 
[17:39:25.961]             setwd(...future.workdir)
[17:39:25.961]         {
[17:39:25.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:25.961]                 ...future.oldOptions$nwarnings <- NULL
[17:39:25.961]             }
[17:39:25.961]             base::options(...future.oldOptions)
[17:39:25.961]             if (.Platform$OS.type == "windows") {
[17:39:25.961]                 old_names <- names(...future.oldEnvVars)
[17:39:25.961]                 envs <- base::Sys.getenv()
[17:39:25.961]                 names <- names(envs)
[17:39:25.961]                 common <- intersect(names, old_names)
[17:39:25.961]                 added <- setdiff(names, old_names)
[17:39:25.961]                 removed <- setdiff(old_names, names)
[17:39:25.961]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:25.961]                   envs[common]]
[17:39:25.961]                 NAMES <- toupper(changed)
[17:39:25.961]                 args <- list()
[17:39:25.961]                 for (kk in seq_along(NAMES)) {
[17:39:25.961]                   name <- changed[[kk]]
[17:39:25.961]                   NAME <- NAMES[[kk]]
[17:39:25.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.961]                     next
[17:39:25.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.961]                 }
[17:39:25.961]                 NAMES <- toupper(added)
[17:39:25.961]                 for (kk in seq_along(NAMES)) {
[17:39:25.961]                   name <- added[[kk]]
[17:39:25.961]                   NAME <- NAMES[[kk]]
[17:39:25.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.961]                     next
[17:39:25.961]                   args[[name]] <- ""
[17:39:25.961]                 }
[17:39:25.961]                 NAMES <- toupper(removed)
[17:39:25.961]                 for (kk in seq_along(NAMES)) {
[17:39:25.961]                   name <- removed[[kk]]
[17:39:25.961]                   NAME <- NAMES[[kk]]
[17:39:25.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:25.961]                     next
[17:39:25.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:25.961]                 }
[17:39:25.961]                 if (length(args) > 0) 
[17:39:25.961]                   base::do.call(base::Sys.setenv, args = args)
[17:39:25.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:25.961]             }
[17:39:25.961]             else {
[17:39:25.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:25.961]             }
[17:39:25.961]             {
[17:39:25.961]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:25.961]                   0L) {
[17:39:25.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:25.961]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:25.961]                   base::options(opts)
[17:39:25.961]                 }
[17:39:25.961]                 {
[17:39:25.961]                   {
[17:39:25.961]                     NULL
[17:39:25.961]                     RNGkind("Mersenne-Twister")
[17:39:25.961]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:25.961]                       inherits = FALSE)
[17:39:25.961]                   }
[17:39:25.961]                   options(future.plan = NULL)
[17:39:25.961]                   if (is.na(NA_character_)) 
[17:39:25.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:25.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:25.961]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:25.961]                   {
[17:39:25.961]                     future <- SequentialFuture(..., envir = envir)
[17:39:25.961]                     if (!future$lazy) 
[17:39:25.961]                       future <- run(future)
[17:39:25.961]                     invisible(future)
[17:39:25.961]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:25.961]                 }
[17:39:25.961]             }
[17:39:25.961]         }
[17:39:25.961]     })
[17:39:25.961]     if (TRUE) {
[17:39:25.961]         base::sink(type = "output", split = FALSE)
[17:39:25.961]         if (TRUE) {
[17:39:25.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:25.961]         }
[17:39:25.961]         else {
[17:39:25.961]             ...future.result["stdout"] <- base::list(NULL)
[17:39:25.961]         }
[17:39:25.961]         base::close(...future.stdout)
[17:39:25.961]         ...future.stdout <- NULL
[17:39:25.961]     }
[17:39:25.961]     ...future.result$conditions <- ...future.conditions
[17:39:25.961]     ...future.result$finished <- base::Sys.time()
[17:39:25.961]     ...future.result
[17:39:25.961] }
[17:39:25.962] assign_globals() ...
[17:39:25.962] List of 5
[17:39:25.962]  $ ...future.FUN            :function (object, ...)  
[17:39:25.962]  $ future.call.arguments    : list()
[17:39:25.962]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.962]  $ ...future.elements_ii    :List of 3
[17:39:25.962]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.962]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:25.962]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.962]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:25.962]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.962]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:25.962]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.962]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:25.962]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:25.962]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:25.962]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:25.962]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:25.962]  $ ...future.seeds_ii       : NULL
[17:39:25.962]  $ ...future.globals.maxSize: NULL
[17:39:25.962]  - attr(*, "resolved")= logi FALSE
[17:39:25.962]  - attr(*, "total_size")= num 1240
[17:39:25.962]  - attr(*, "where")=List of 5
[17:39:25.962]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:25.962]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:25.962]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:25.962]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:25.962]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:25.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.962]  - attr(*, "already-done")= logi TRUE
[17:39:25.972] - copied ‘...future.FUN’ to environment
[17:39:25.972] - copied ‘future.call.arguments’ to environment
[17:39:25.972] - copied ‘...future.elements_ii’ to environment
[17:39:25.972] - copied ‘...future.seeds_ii’ to environment
[17:39:25.973] - copied ‘...future.globals.maxSize’ to environment
[17:39:25.973] assign_globals() ... done
[17:39:25.973] plan(): Setting new future strategy stack:
[17:39:25.973] List of future strategies:
[17:39:25.973] 1. sequential:
[17:39:25.973]    - args: function (..., envir = parent.frame())
[17:39:25.973]    - tweaked: FALSE
[17:39:25.973]    - call: NULL
[17:39:25.973] plan(): nbrOfWorkers() = 1
[17:39:25.975] plan(): Setting new future strategy stack:
[17:39:25.976] List of future strategies:
[17:39:25.976] 1. sequential:
[17:39:25.976]    - args: function (..., envir = parent.frame())
[17:39:25.976]    - tweaked: FALSE
[17:39:25.976]    - call: plan(strategy)
[17:39:25.976] plan(): nbrOfWorkers() = 1
[17:39:25.976] SequentialFuture started (and completed)
[17:39:25.976] - Launch lazy future ... done
[17:39:25.976] run() for ‘SequentialFuture’ ... done
[17:39:25.976] Created future:
[17:39:25.976] SequentialFuture:
[17:39:25.976] Label: ‘future_by-1’
[17:39:25.976] Expression:
[17:39:25.976] {
[17:39:25.976]     do.call(function(...) {
[17:39:25.976]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:25.976]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:25.976]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:25.976]             on.exit(options(oopts), add = TRUE)
[17:39:25.976]         }
[17:39:25.976]         {
[17:39:25.976]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:25.976]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:25.976]                 ...future.FUN(...future.X_jj, ...)
[17:39:25.976]             })
[17:39:25.976]         }
[17:39:25.976]     }, args = future.call.arguments)
[17:39:25.976] }
[17:39:25.976] Lazy evaluation: FALSE
[17:39:25.976] Asynchronous evaluation: FALSE
[17:39:25.976] Local evaluation: TRUE
[17:39:25.976] Environment: 0x562970cc6458
[17:39:25.976] Capture standard output: TRUE
[17:39:25.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:25.976] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:25.976] Packages: <none>
[17:39:25.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:25.976] Resolved: TRUE
[17:39:25.976] Value: 5.37 KiB of class ‘list’
[17:39:25.976] Early signaling: FALSE
[17:39:25.976] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:25.976] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:25.978] Chunk #1 of 1 ... DONE
[17:39:25.978] Launching 1 futures (chunks) ... DONE
[17:39:25.978] Resolving 1 futures (chunks) ...
[17:39:25.978] resolve() on list ...
[17:39:25.978]  recursive: 0
[17:39:25.978]  length: 1
[17:39:25.978] 
[17:39:25.978] resolved() for ‘SequentialFuture’ ...
[17:39:25.978] - state: ‘finished’
[17:39:25.978] - run: TRUE
[17:39:25.979] - result: ‘FutureResult’
[17:39:25.979] resolved() for ‘SequentialFuture’ ... done
[17:39:25.979] Future #1
[17:39:25.979] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:25.979] - nx: 1
[17:39:25.979] - relay: TRUE
[17:39:25.979] - stdout: TRUE
[17:39:25.979] - signal: TRUE
[17:39:25.979] - resignal: FALSE
[17:39:25.979] - force: TRUE
[17:39:25.979] - relayed: [n=1] FALSE
[17:39:25.980] - queued futures: [n=1] FALSE
[17:39:25.980]  - until=1
[17:39:25.980]  - relaying element #1
[17:39:25.980] - relayed: [n=1] TRUE
[17:39:25.980] - queued futures: [n=1] TRUE
[17:39:25.980] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:25.980]  length: 0 (resolved future 1)
[17:39:25.980] Relaying remaining futures
[17:39:25.980] signalConditionsASAP(NULL, pos=0) ...
[17:39:25.981] - nx: 1
[17:39:25.981] - relay: TRUE
[17:39:25.981] - stdout: TRUE
[17:39:25.981] - signal: TRUE
[17:39:25.981] - resignal: FALSE
[17:39:25.981] - force: TRUE
[17:39:25.981] - relayed: [n=1] TRUE
[17:39:25.981] - queued futures: [n=1] TRUE
 - flush all
[17:39:25.981] - relayed: [n=1] TRUE
[17:39:25.981] - queued futures: [n=1] TRUE
[17:39:25.981] signalConditionsASAP(NULL, pos=0) ... done
[17:39:25.981] resolve() on list ... DONE
[17:39:25.982]  - Number of value chunks collected: 1
[17:39:25.982] Resolving 1 futures (chunks) ... DONE
[17:39:25.982] Reducing values from 1 chunks ...
[17:39:25.982]  - Number of values collected after concatenation: 3
[17:39:25.982]  - Number of values expected: 3
[17:39:25.982] Reducing values from 1 chunks ... DONE
[17:39:25.982] future_lapply() ... DONE
[17:39:25.982] future_by_internal() ... DONE
[17:39:25.984] future_by_internal() ...
- plan('multicore') ...
[17:39:25.985] plan(): Setting new future strategy stack:
[17:39:25.985] List of future strategies:
[17:39:25.985] 1. multicore:
[17:39:25.985]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:25.985]    - tweaked: FALSE
[17:39:25.985]    - call: plan(strategy)
[17:39:25.989] plan(): nbrOfWorkers() = 2
[17:39:25.989] future_by_internal() ...
[17:39:25.990] future_lapply() ...
[17:39:25.994] Number of chunks: 2
[17:39:25.994] getGlobalsAndPackagesXApply() ...
[17:39:25.994]  - future.globals: TRUE
[17:39:25.994] getGlobalsAndPackages() ...
[17:39:25.994] Searching for globals...
[17:39:25.995] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:25.996] Searching for globals ... DONE
[17:39:25.996] Resolving globals: FALSE
[17:39:25.996] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:25.996] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:25.996] - globals: [1] ‘FUN’
[17:39:25.997] 
[17:39:25.997] getGlobalsAndPackages() ... DONE
[17:39:25.997]  - globals found/used: [n=1] ‘FUN’
[17:39:25.997]  - needed namespaces: [n=0] 
[17:39:25.997] Finding globals ... DONE
[17:39:25.997]  - use_args: TRUE
[17:39:25.997]  - Getting '...' globals ...
[17:39:25.997] resolve() on list ...
[17:39:25.997]  recursive: 0
[17:39:25.998]  length: 1
[17:39:25.998]  elements: ‘...’
[17:39:25.998]  length: 0 (resolved future 1)
[17:39:25.998] resolve() on list ... DONE
[17:39:25.998]    - '...' content: [n=0] 
[17:39:25.998] List of 1
[17:39:25.998]  $ ...: list()
[17:39:25.998]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:25.998]  - attr(*, "where")=List of 1
[17:39:25.998]   ..$ ...:<environment: 0x562971175520> 
[17:39:25.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:25.998]  - attr(*, "resolved")= logi TRUE
[17:39:25.998]  - attr(*, "total_size")= num NA
[17:39:26.001]  - Getting '...' globals ... DONE
[17:39:26.001] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:26.001] List of 2
[17:39:26.001]  $ ...future.FUN:function (object, ...)  
[17:39:26.001]  $ ...          : list()
[17:39:26.001]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.001]  - attr(*, "where")=List of 2
[17:39:26.001]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:26.001]   ..$ ...          :<environment: 0x562971175520> 
[17:39:26.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.001]  - attr(*, "resolved")= logi FALSE
[17:39:26.001]  - attr(*, "total_size")= num 1240
[17:39:26.004] Packages to be attached in all futures: [n=0] 
[17:39:26.004] getGlobalsAndPackagesXApply() ... DONE
[17:39:26.004] Number of futures (= number of chunks): 2
[17:39:26.004] Launching 2 futures (chunks) ...
[17:39:26.004] Chunk #1 of 2 ...
[17:39:26.004]  - Finding globals in 'X' for chunk #1 ...
[17:39:26.004] getGlobalsAndPackages() ...
[17:39:26.004] Searching for globals...
[17:39:26.005] 
[17:39:26.005] Searching for globals ... DONE
[17:39:26.005] - globals: [0] <none>
[17:39:26.005] getGlobalsAndPackages() ... DONE
[17:39:26.005]    + additional globals found: [n=0] 
[17:39:26.005]    + additional namespaces needed: [n=0] 
[17:39:26.005]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:26.005]  - seeds: <none>
[17:39:26.005] getGlobalsAndPackages() ...
[17:39:26.006] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.006] Resolving globals: FALSE
[17:39:26.006] Tweak future expression to call with '...' arguments ...
[17:39:26.006] {
[17:39:26.006]     do.call(function(...) {
[17:39:26.006]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.006]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.006]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.006]             on.exit(options(oopts), add = TRUE)
[17:39:26.006]         }
[17:39:26.006]         {
[17:39:26.006]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.006]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.006]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.006]             })
[17:39:26.006]         }
[17:39:26.006]     }, args = future.call.arguments)
[17:39:26.006] }
[17:39:26.006] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.008] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.008] 
[17:39:26.009] getGlobalsAndPackages() ... DONE
[17:39:26.009] run() for ‘Future’ ...
[17:39:26.009] - state: ‘created’
[17:39:26.009] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.013] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.014]   - Field: ‘label’
[17:39:26.014]   - Field: ‘local’
[17:39:26.014]   - Field: ‘owner’
[17:39:26.014]   - Field: ‘envir’
[17:39:26.014]   - Field: ‘workers’
[17:39:26.014]   - Field: ‘packages’
[17:39:26.015]   - Field: ‘gc’
[17:39:26.015]   - Field: ‘job’
[17:39:26.015]   - Field: ‘conditions’
[17:39:26.015]   - Field: ‘expr’
[17:39:26.015]   - Field: ‘uuid’
[17:39:26.015]   - Field: ‘seed’
[17:39:26.015]   - Field: ‘version’
[17:39:26.015]   - Field: ‘result’
[17:39:26.016]   - Field: ‘asynchronous’
[17:39:26.016]   - Field: ‘calls’
[17:39:26.016]   - Field: ‘globals’
[17:39:26.016]   - Field: ‘stdout’
[17:39:26.016]   - Field: ‘earlySignal’
[17:39:26.016]   - Field: ‘lazy’
[17:39:26.016]   - Field: ‘state’
[17:39:26.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.016] - Launch lazy future ...
[17:39:26.017] Packages needed by the future expression (n = 0): <none>
[17:39:26.018] Packages needed by future strategies (n = 0): <none>
[17:39:26.018] {
[17:39:26.018]     {
[17:39:26.018]         {
[17:39:26.018]             ...future.startTime <- base::Sys.time()
[17:39:26.018]             {
[17:39:26.018]                 {
[17:39:26.018]                   {
[17:39:26.018]                     {
[17:39:26.018]                       base::local({
[17:39:26.018]                         has_future <- base::requireNamespace("future", 
[17:39:26.018]                           quietly = TRUE)
[17:39:26.018]                         if (has_future) {
[17:39:26.018]                           ns <- base::getNamespace("future")
[17:39:26.018]                           version <- ns[[".package"]][["version"]]
[17:39:26.018]                           if (is.null(version)) 
[17:39:26.018]                             version <- utils::packageVersion("future")
[17:39:26.018]                         }
[17:39:26.018]                         else {
[17:39:26.018]                           version <- NULL
[17:39:26.018]                         }
[17:39:26.018]                         if (!has_future || version < "1.8.0") {
[17:39:26.018]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.018]                             "", base::R.version$version.string), 
[17:39:26.018]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:26.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:26.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.018]                               "release", "version")], collapse = " "), 
[17:39:26.018]                             hostname = base::Sys.info()[["nodename"]])
[17:39:26.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.018]                             info)
[17:39:26.018]                           info <- base::paste(info, collapse = "; ")
[17:39:26.018]                           if (!has_future) {
[17:39:26.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.018]                               info)
[17:39:26.018]                           }
[17:39:26.018]                           else {
[17:39:26.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.018]                               info, version)
[17:39:26.018]                           }
[17:39:26.018]                           base::stop(msg)
[17:39:26.018]                         }
[17:39:26.018]                       })
[17:39:26.018]                     }
[17:39:26.018]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.018]                     base::options(mc.cores = 1L)
[17:39:26.018]                   }
[17:39:26.018]                   options(future.plan = NULL)
[17:39:26.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.018]                 }
[17:39:26.018]                 ...future.workdir <- getwd()
[17:39:26.018]             }
[17:39:26.018]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.018]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.018]         }
[17:39:26.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:26.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.018]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.018]             base::names(...future.oldOptions))
[17:39:26.018]     }
[17:39:26.018]     if (FALSE) {
[17:39:26.018]     }
[17:39:26.018]     else {
[17:39:26.018]         if (TRUE) {
[17:39:26.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.018]                 open = "w")
[17:39:26.018]         }
[17:39:26.018]         else {
[17:39:26.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.018]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.018]         }
[17:39:26.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.018]             base::sink(type = "output", split = FALSE)
[17:39:26.018]             base::close(...future.stdout)
[17:39:26.018]         }, add = TRUE)
[17:39:26.018]     }
[17:39:26.018]     ...future.frame <- base::sys.nframe()
[17:39:26.018]     ...future.conditions <- base::list()
[17:39:26.018]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.018]     if (FALSE) {
[17:39:26.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.018]     }
[17:39:26.018]     ...future.result <- base::tryCatch({
[17:39:26.018]         base::withCallingHandlers({
[17:39:26.018]             ...future.value <- base::withVisible(base::local({
[17:39:26.018]                 withCallingHandlers({
[17:39:26.018]                   {
[17:39:26.018]                     do.call(function(...) {
[17:39:26.018]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.018]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.018]                         ...future.globals.maxSize)) {
[17:39:26.018]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.018]                         on.exit(options(oopts), add = TRUE)
[17:39:26.018]                       }
[17:39:26.018]                       {
[17:39:26.018]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.018]                           FUN = function(jj) {
[17:39:26.018]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.018]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.018]                           })
[17:39:26.018]                       }
[17:39:26.018]                     }, args = future.call.arguments)
[17:39:26.018]                   }
[17:39:26.018]                 }, immediateCondition = function(cond) {
[17:39:26.018]                   save_rds <- function (object, pathname, ...) 
[17:39:26.018]                   {
[17:39:26.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.018]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.018]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.018]                         fi_tmp[["mtime"]])
[17:39:26.018]                     }
[17:39:26.018]                     tryCatch({
[17:39:26.018]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.018]                     }, error = function(ex) {
[17:39:26.018]                       msg <- conditionMessage(ex)
[17:39:26.018]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.018]                         fi_tmp[["mtime"]], msg)
[17:39:26.018]                       ex$message <- msg
[17:39:26.018]                       stop(ex)
[17:39:26.018]                     })
[17:39:26.018]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.018]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.018]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.018]                       fi <- file.info(pathname)
[17:39:26.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.018]                         fi[["size"]], fi[["mtime"]])
[17:39:26.018]                       stop(msg)
[17:39:26.018]                     }
[17:39:26.018]                     invisible(pathname)
[17:39:26.018]                   }
[17:39:26.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.018]                     rootPath = tempdir()) 
[17:39:26.018]                   {
[17:39:26.018]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.018]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.018]                       tmpdir = path, fileext = ".rds")
[17:39:26.018]                     save_rds(obj, file)
[17:39:26.018]                   }
[17:39:26.018]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.018]                   {
[17:39:26.018]                     inherits <- base::inherits
[17:39:26.018]                     invokeRestart <- base::invokeRestart
[17:39:26.018]                     is.null <- base::is.null
[17:39:26.018]                     muffled <- FALSE
[17:39:26.018]                     if (inherits(cond, "message")) {
[17:39:26.018]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.018]                       if (muffled) 
[17:39:26.018]                         invokeRestart("muffleMessage")
[17:39:26.018]                     }
[17:39:26.018]                     else if (inherits(cond, "warning")) {
[17:39:26.018]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.018]                       if (muffled) 
[17:39:26.018]                         invokeRestart("muffleWarning")
[17:39:26.018]                     }
[17:39:26.018]                     else if (inherits(cond, "condition")) {
[17:39:26.018]                       if (!is.null(pattern)) {
[17:39:26.018]                         computeRestarts <- base::computeRestarts
[17:39:26.018]                         grepl <- base::grepl
[17:39:26.018]                         restarts <- computeRestarts(cond)
[17:39:26.018]                         for (restart in restarts) {
[17:39:26.018]                           name <- restart$name
[17:39:26.018]                           if (is.null(name)) 
[17:39:26.018]                             next
[17:39:26.018]                           if (!grepl(pattern, name)) 
[17:39:26.018]                             next
[17:39:26.018]                           invokeRestart(restart)
[17:39:26.018]                           muffled <- TRUE
[17:39:26.018]                           break
[17:39:26.018]                         }
[17:39:26.018]                       }
[17:39:26.018]                     }
[17:39:26.018]                     invisible(muffled)
[17:39:26.018]                   }
[17:39:26.018]                   muffleCondition(cond)
[17:39:26.018]                 })
[17:39:26.018]             }))
[17:39:26.018]             future::FutureResult(value = ...future.value$value, 
[17:39:26.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.018]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.018]                     ...future.globalenv.names))
[17:39:26.018]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.018]         }, condition = base::local({
[17:39:26.018]             c <- base::c
[17:39:26.018]             inherits <- base::inherits
[17:39:26.018]             invokeRestart <- base::invokeRestart
[17:39:26.018]             length <- base::length
[17:39:26.018]             list <- base::list
[17:39:26.018]             seq.int <- base::seq.int
[17:39:26.018]             signalCondition <- base::signalCondition
[17:39:26.018]             sys.calls <- base::sys.calls
[17:39:26.018]             `[[` <- base::`[[`
[17:39:26.018]             `+` <- base::`+`
[17:39:26.018]             `<<-` <- base::`<<-`
[17:39:26.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.018]                   3L)]
[17:39:26.018]             }
[17:39:26.018]             function(cond) {
[17:39:26.018]                 is_error <- inherits(cond, "error")
[17:39:26.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.018]                   NULL)
[17:39:26.018]                 if (is_error) {
[17:39:26.018]                   sessionInformation <- function() {
[17:39:26.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.018]                       search = base::search(), system = base::Sys.info())
[17:39:26.018]                   }
[17:39:26.018]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.018]                     cond$call), session = sessionInformation(), 
[17:39:26.018]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.018]                   signalCondition(cond)
[17:39:26.018]                 }
[17:39:26.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.018]                 "immediateCondition"))) {
[17:39:26.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.018]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.018]                   if (TRUE && !signal) {
[17:39:26.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.018]                     {
[17:39:26.018]                       inherits <- base::inherits
[17:39:26.018]                       invokeRestart <- base::invokeRestart
[17:39:26.018]                       is.null <- base::is.null
[17:39:26.018]                       muffled <- FALSE
[17:39:26.018]                       if (inherits(cond, "message")) {
[17:39:26.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.018]                         if (muffled) 
[17:39:26.018]                           invokeRestart("muffleMessage")
[17:39:26.018]                       }
[17:39:26.018]                       else if (inherits(cond, "warning")) {
[17:39:26.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.018]                         if (muffled) 
[17:39:26.018]                           invokeRestart("muffleWarning")
[17:39:26.018]                       }
[17:39:26.018]                       else if (inherits(cond, "condition")) {
[17:39:26.018]                         if (!is.null(pattern)) {
[17:39:26.018]                           computeRestarts <- base::computeRestarts
[17:39:26.018]                           grepl <- base::grepl
[17:39:26.018]                           restarts <- computeRestarts(cond)
[17:39:26.018]                           for (restart in restarts) {
[17:39:26.018]                             name <- restart$name
[17:39:26.018]                             if (is.null(name)) 
[17:39:26.018]                               next
[17:39:26.018]                             if (!grepl(pattern, name)) 
[17:39:26.018]                               next
[17:39:26.018]                             invokeRestart(restart)
[17:39:26.018]                             muffled <- TRUE
[17:39:26.018]                             break
[17:39:26.018]                           }
[17:39:26.018]                         }
[17:39:26.018]                       }
[17:39:26.018]                       invisible(muffled)
[17:39:26.018]                     }
[17:39:26.018]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.018]                   }
[17:39:26.018]                 }
[17:39:26.018]                 else {
[17:39:26.018]                   if (TRUE) {
[17:39:26.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.018]                     {
[17:39:26.018]                       inherits <- base::inherits
[17:39:26.018]                       invokeRestart <- base::invokeRestart
[17:39:26.018]                       is.null <- base::is.null
[17:39:26.018]                       muffled <- FALSE
[17:39:26.018]                       if (inherits(cond, "message")) {
[17:39:26.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.018]                         if (muffled) 
[17:39:26.018]                           invokeRestart("muffleMessage")
[17:39:26.018]                       }
[17:39:26.018]                       else if (inherits(cond, "warning")) {
[17:39:26.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.018]                         if (muffled) 
[17:39:26.018]                           invokeRestart("muffleWarning")
[17:39:26.018]                       }
[17:39:26.018]                       else if (inherits(cond, "condition")) {
[17:39:26.018]                         if (!is.null(pattern)) {
[17:39:26.018]                           computeRestarts <- base::computeRestarts
[17:39:26.018]                           grepl <- base::grepl
[17:39:26.018]                           restarts <- computeRestarts(cond)
[17:39:26.018]                           for (restart in restarts) {
[17:39:26.018]                             name <- restart$name
[17:39:26.018]                             if (is.null(name)) 
[17:39:26.018]                               next
[17:39:26.018]                             if (!grepl(pattern, name)) 
[17:39:26.018]                               next
[17:39:26.018]                             invokeRestart(restart)
[17:39:26.018]                             muffled <- TRUE
[17:39:26.018]                             break
[17:39:26.018]                           }
[17:39:26.018]                         }
[17:39:26.018]                       }
[17:39:26.018]                       invisible(muffled)
[17:39:26.018]                     }
[17:39:26.018]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.018]                   }
[17:39:26.018]                 }
[17:39:26.018]             }
[17:39:26.018]         }))
[17:39:26.018]     }, error = function(ex) {
[17:39:26.018]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.018]                 ...future.rng), started = ...future.startTime, 
[17:39:26.018]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.018]             version = "1.8"), class = "FutureResult")
[17:39:26.018]     }, finally = {
[17:39:26.018]         if (!identical(...future.workdir, getwd())) 
[17:39:26.018]             setwd(...future.workdir)
[17:39:26.018]         {
[17:39:26.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.018]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.018]             }
[17:39:26.018]             base::options(...future.oldOptions)
[17:39:26.018]             if (.Platform$OS.type == "windows") {
[17:39:26.018]                 old_names <- names(...future.oldEnvVars)
[17:39:26.018]                 envs <- base::Sys.getenv()
[17:39:26.018]                 names <- names(envs)
[17:39:26.018]                 common <- intersect(names, old_names)
[17:39:26.018]                 added <- setdiff(names, old_names)
[17:39:26.018]                 removed <- setdiff(old_names, names)
[17:39:26.018]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.018]                   envs[common]]
[17:39:26.018]                 NAMES <- toupper(changed)
[17:39:26.018]                 args <- list()
[17:39:26.018]                 for (kk in seq_along(NAMES)) {
[17:39:26.018]                   name <- changed[[kk]]
[17:39:26.018]                   NAME <- NAMES[[kk]]
[17:39:26.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.018]                     next
[17:39:26.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.018]                 }
[17:39:26.018]                 NAMES <- toupper(added)
[17:39:26.018]                 for (kk in seq_along(NAMES)) {
[17:39:26.018]                   name <- added[[kk]]
[17:39:26.018]                   NAME <- NAMES[[kk]]
[17:39:26.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.018]                     next
[17:39:26.018]                   args[[name]] <- ""
[17:39:26.018]                 }
[17:39:26.018]                 NAMES <- toupper(removed)
[17:39:26.018]                 for (kk in seq_along(NAMES)) {
[17:39:26.018]                   name <- removed[[kk]]
[17:39:26.018]                   NAME <- NAMES[[kk]]
[17:39:26.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.018]                     next
[17:39:26.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.018]                 }
[17:39:26.018]                 if (length(args) > 0) 
[17:39:26.018]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.018]             }
[17:39:26.018]             else {
[17:39:26.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.018]             }
[17:39:26.018]             {
[17:39:26.018]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.018]                   0L) {
[17:39:26.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.018]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.018]                   base::options(opts)
[17:39:26.018]                 }
[17:39:26.018]                 {
[17:39:26.018]                   {
[17:39:26.018]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.018]                     NULL
[17:39:26.018]                   }
[17:39:26.018]                   options(future.plan = NULL)
[17:39:26.018]                   if (is.na(NA_character_)) 
[17:39:26.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.018]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.018]                     envir = parent.frame()) 
[17:39:26.018]                   {
[17:39:26.018]                     default_workers <- missing(workers)
[17:39:26.018]                     if (is.function(workers)) 
[17:39:26.018]                       workers <- workers()
[17:39:26.018]                     workers <- structure(as.integer(workers), 
[17:39:26.018]                       class = class(workers))
[17:39:26.018]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.018]                       1L)
[17:39:26.018]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.018]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.018]                       if (default_workers) 
[17:39:26.018]                         supportsMulticore(warn = TRUE)
[17:39:26.018]                       return(sequential(..., envir = envir))
[17:39:26.018]                     }
[17:39:26.018]                     oopts <- options(mc.cores = workers)
[17:39:26.018]                     on.exit(options(oopts))
[17:39:26.018]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.018]                       envir = envir)
[17:39:26.018]                     if (!future$lazy) 
[17:39:26.018]                       future <- run(future)
[17:39:26.018]                     invisible(future)
[17:39:26.018]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.018]                 }
[17:39:26.018]             }
[17:39:26.018]         }
[17:39:26.018]     })
[17:39:26.018]     if (TRUE) {
[17:39:26.018]         base::sink(type = "output", split = FALSE)
[17:39:26.018]         if (TRUE) {
[17:39:26.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.018]         }
[17:39:26.018]         else {
[17:39:26.018]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.018]         }
[17:39:26.018]         base::close(...future.stdout)
[17:39:26.018]         ...future.stdout <- NULL
[17:39:26.018]     }
[17:39:26.018]     ...future.result$conditions <- ...future.conditions
[17:39:26.018]     ...future.result$finished <- base::Sys.time()
[17:39:26.018]     ...future.result
[17:39:26.018] }
[17:39:26.021] assign_globals() ...
[17:39:26.021] List of 5
[17:39:26.021]  $ ...future.FUN            :function (object, ...)  
[17:39:26.021]  $ future.call.arguments    : list()
[17:39:26.021]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.021]  $ ...future.elements_ii    :List of 1
[17:39:26.021]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:26.021]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:26.021]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.021]  $ ...future.seeds_ii       : NULL
[17:39:26.021]  $ ...future.globals.maxSize: NULL
[17:39:26.021]  - attr(*, "where")=List of 5
[17:39:26.021]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.021]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.021]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.021]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.021]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.021]  - attr(*, "resolved")= logi FALSE
[17:39:26.021]  - attr(*, "total_size")= num 1240
[17:39:26.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.021]  - attr(*, "already-done")= logi TRUE
[17:39:26.026] - copied ‘...future.FUN’ to environment
[17:39:26.026] - copied ‘future.call.arguments’ to environment
[17:39:26.026] - copied ‘...future.elements_ii’ to environment
[17:39:26.027] - copied ‘...future.seeds_ii’ to environment
[17:39:26.027] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.027] assign_globals() ... done
[17:39:26.027] requestCore(): workers = 2
[17:39:26.030] MulticoreFuture started
[17:39:26.030] - Launch lazy future ... done
[17:39:26.030] plan(): Setting new future strategy stack:
[17:39:26.031] run() for ‘MulticoreFuture’ ... done
[17:39:26.031] Created future:
[17:39:26.031] List of future strategies:
[17:39:26.031] 1. sequential:
[17:39:26.031]    - args: function (..., envir = parent.frame())
[17:39:26.031]    - tweaked: FALSE
[17:39:26.031]    - call: NULL
[17:39:26.032] plan(): nbrOfWorkers() = 1
[17:39:26.035] plan(): Setting new future strategy stack:
[17:39:26.035] List of future strategies:
[17:39:26.035] 1. multicore:
[17:39:26.035]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.035]    - tweaked: FALSE
[17:39:26.035]    - call: plan(strategy)
[17:39:26.040] plan(): nbrOfWorkers() = 2
[17:39:26.031] MulticoreFuture:
[17:39:26.031] Label: ‘future_by-1’
[17:39:26.031] Expression:
[17:39:26.031] {
[17:39:26.031]     do.call(function(...) {
[17:39:26.031]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.031]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.031]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.031]             on.exit(options(oopts), add = TRUE)
[17:39:26.031]         }
[17:39:26.031]         {
[17:39:26.031]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.031]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.031]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.031]             })
[17:39:26.031]         }
[17:39:26.031]     }, args = future.call.arguments)
[17:39:26.031] }
[17:39:26.031] Lazy evaluation: FALSE
[17:39:26.031] Asynchronous evaluation: TRUE
[17:39:26.031] Local evaluation: TRUE
[17:39:26.031] Environment: R_GlobalEnv
[17:39:26.031] Capture standard output: TRUE
[17:39:26.031] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.031] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.031] Packages: <none>
[17:39:26.031] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.031] Resolved: TRUE
[17:39:26.031] Value: <not collected>
[17:39:26.031] Conditions captured: <none>
[17:39:26.031] Early signaling: FALSE
[17:39:26.031] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.031] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.041] Chunk #1 of 2 ... DONE
[17:39:26.042] Chunk #2 of 2 ...
[17:39:26.042]  - Finding globals in 'X' for chunk #2 ...
[17:39:26.042] getGlobalsAndPackages() ...
[17:39:26.042] Searching for globals...
[17:39:26.043] 
[17:39:26.043] Searching for globals ... DONE
[17:39:26.043] - globals: [0] <none>
[17:39:26.043] getGlobalsAndPackages() ... DONE
[17:39:26.043]    + additional globals found: [n=0] 
[17:39:26.044]    + additional namespaces needed: [n=0] 
[17:39:26.044]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:26.044]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:26.044]  - seeds: <none>
[17:39:26.044] getGlobalsAndPackages() ...
[17:39:26.044] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.045] Resolving globals: FALSE
[17:39:26.045] Tweak future expression to call with '...' arguments ...
[17:39:26.045] {
[17:39:26.045]     do.call(function(...) {
[17:39:26.045]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.045]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.045]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.045]             on.exit(options(oopts), add = TRUE)
[17:39:26.045]         }
[17:39:26.045]         {
[17:39:26.045]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.045]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.045]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.045]             })
[17:39:26.045]         }
[17:39:26.045]     }, args = future.call.arguments)
[17:39:26.045] }
[17:39:26.045] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.046] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.050] 
[17:39:26.051] getGlobalsAndPackages() ... DONE
[17:39:26.052] run() for ‘Future’ ...
[17:39:26.052] - state: ‘created’
[17:39:26.052] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.058] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.058]   - Field: ‘label’
[17:39:26.059]   - Field: ‘local’
[17:39:26.059]   - Field: ‘owner’
[17:39:26.059]   - Field: ‘envir’
[17:39:26.059]   - Field: ‘workers’
[17:39:26.060]   - Field: ‘packages’
[17:39:26.060]   - Field: ‘gc’
[17:39:26.060]   - Field: ‘job’
[17:39:26.060]   - Field: ‘conditions’
[17:39:26.060]   - Field: ‘expr’
[17:39:26.061]   - Field: ‘uuid’
[17:39:26.061]   - Field: ‘seed’
[17:39:26.061]   - Field: ‘version’
[17:39:26.061]   - Field: ‘result’
[17:39:26.061]   - Field: ‘asynchronous’
[17:39:26.061]   - Field: ‘calls’
[17:39:26.062]   - Field: ‘globals’
[17:39:26.062]   - Field: ‘stdout’
[17:39:26.062]   - Field: ‘earlySignal’
[17:39:26.062]   - Field: ‘lazy’
[17:39:26.062]   - Field: ‘state’
[17:39:26.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.062] - Launch lazy future ...
[17:39:26.063] Packages needed by the future expression (n = 0): <none>
[17:39:26.063] Packages needed by future strategies (n = 0): <none>
[17:39:26.064] {
[17:39:26.064]     {
[17:39:26.064]         {
[17:39:26.064]             ...future.startTime <- base::Sys.time()
[17:39:26.064]             {
[17:39:26.064]                 {
[17:39:26.064]                   {
[17:39:26.064]                     {
[17:39:26.064]                       base::local({
[17:39:26.064]                         has_future <- base::requireNamespace("future", 
[17:39:26.064]                           quietly = TRUE)
[17:39:26.064]                         if (has_future) {
[17:39:26.064]                           ns <- base::getNamespace("future")
[17:39:26.064]                           version <- ns[[".package"]][["version"]]
[17:39:26.064]                           if (is.null(version)) 
[17:39:26.064]                             version <- utils::packageVersion("future")
[17:39:26.064]                         }
[17:39:26.064]                         else {
[17:39:26.064]                           version <- NULL
[17:39:26.064]                         }
[17:39:26.064]                         if (!has_future || version < "1.8.0") {
[17:39:26.064]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.064]                             "", base::R.version$version.string), 
[17:39:26.064]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:26.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:26.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.064]                               "release", "version")], collapse = " "), 
[17:39:26.064]                             hostname = base::Sys.info()[["nodename"]])
[17:39:26.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.064]                             info)
[17:39:26.064]                           info <- base::paste(info, collapse = "; ")
[17:39:26.064]                           if (!has_future) {
[17:39:26.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.064]                               info)
[17:39:26.064]                           }
[17:39:26.064]                           else {
[17:39:26.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.064]                               info, version)
[17:39:26.064]                           }
[17:39:26.064]                           base::stop(msg)
[17:39:26.064]                         }
[17:39:26.064]                       })
[17:39:26.064]                     }
[17:39:26.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.064]                     base::options(mc.cores = 1L)
[17:39:26.064]                   }
[17:39:26.064]                   options(future.plan = NULL)
[17:39:26.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.064]                 }
[17:39:26.064]                 ...future.workdir <- getwd()
[17:39:26.064]             }
[17:39:26.064]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.064]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.064]         }
[17:39:26.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.064]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:26.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.064]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.064]             base::names(...future.oldOptions))
[17:39:26.064]     }
[17:39:26.064]     if (FALSE) {
[17:39:26.064]     }
[17:39:26.064]     else {
[17:39:26.064]         if (TRUE) {
[17:39:26.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.064]                 open = "w")
[17:39:26.064]         }
[17:39:26.064]         else {
[17:39:26.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.064]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.064]         }
[17:39:26.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.064]             base::sink(type = "output", split = FALSE)
[17:39:26.064]             base::close(...future.stdout)
[17:39:26.064]         }, add = TRUE)
[17:39:26.064]     }
[17:39:26.064]     ...future.frame <- base::sys.nframe()
[17:39:26.064]     ...future.conditions <- base::list()
[17:39:26.064]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.064]     if (FALSE) {
[17:39:26.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.064]     }
[17:39:26.064]     ...future.result <- base::tryCatch({
[17:39:26.064]         base::withCallingHandlers({
[17:39:26.064]             ...future.value <- base::withVisible(base::local({
[17:39:26.064]                 withCallingHandlers({
[17:39:26.064]                   {
[17:39:26.064]                     do.call(function(...) {
[17:39:26.064]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.064]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.064]                         ...future.globals.maxSize)) {
[17:39:26.064]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.064]                         on.exit(options(oopts), add = TRUE)
[17:39:26.064]                       }
[17:39:26.064]                       {
[17:39:26.064]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.064]                           FUN = function(jj) {
[17:39:26.064]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.064]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.064]                           })
[17:39:26.064]                       }
[17:39:26.064]                     }, args = future.call.arguments)
[17:39:26.064]                   }
[17:39:26.064]                 }, immediateCondition = function(cond) {
[17:39:26.064]                   save_rds <- function (object, pathname, ...) 
[17:39:26.064]                   {
[17:39:26.064]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.064]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.064]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.064]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.064]                         fi_tmp[["mtime"]])
[17:39:26.064]                     }
[17:39:26.064]                     tryCatch({
[17:39:26.064]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.064]                     }, error = function(ex) {
[17:39:26.064]                       msg <- conditionMessage(ex)
[17:39:26.064]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.064]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.064]                         fi_tmp[["mtime"]], msg)
[17:39:26.064]                       ex$message <- msg
[17:39:26.064]                       stop(ex)
[17:39:26.064]                     })
[17:39:26.064]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.064]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.064]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.064]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.064]                       fi <- file.info(pathname)
[17:39:26.064]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.064]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.064]                         fi[["size"]], fi[["mtime"]])
[17:39:26.064]                       stop(msg)
[17:39:26.064]                     }
[17:39:26.064]                     invisible(pathname)
[17:39:26.064]                   }
[17:39:26.064]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.064]                     rootPath = tempdir()) 
[17:39:26.064]                   {
[17:39:26.064]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.064]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.064]                       tmpdir = path, fileext = ".rds")
[17:39:26.064]                     save_rds(obj, file)
[17:39:26.064]                   }
[17:39:26.064]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.064]                   {
[17:39:26.064]                     inherits <- base::inherits
[17:39:26.064]                     invokeRestart <- base::invokeRestart
[17:39:26.064]                     is.null <- base::is.null
[17:39:26.064]                     muffled <- FALSE
[17:39:26.064]                     if (inherits(cond, "message")) {
[17:39:26.064]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.064]                       if (muffled) 
[17:39:26.064]                         invokeRestart("muffleMessage")
[17:39:26.064]                     }
[17:39:26.064]                     else if (inherits(cond, "warning")) {
[17:39:26.064]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.064]                       if (muffled) 
[17:39:26.064]                         invokeRestart("muffleWarning")
[17:39:26.064]                     }
[17:39:26.064]                     else if (inherits(cond, "condition")) {
[17:39:26.064]                       if (!is.null(pattern)) {
[17:39:26.064]                         computeRestarts <- base::computeRestarts
[17:39:26.064]                         grepl <- base::grepl
[17:39:26.064]                         restarts <- computeRestarts(cond)
[17:39:26.064]                         for (restart in restarts) {
[17:39:26.064]                           name <- restart$name
[17:39:26.064]                           if (is.null(name)) 
[17:39:26.064]                             next
[17:39:26.064]                           if (!grepl(pattern, name)) 
[17:39:26.064]                             next
[17:39:26.064]                           invokeRestart(restart)
[17:39:26.064]                           muffled <- TRUE
[17:39:26.064]                           break
[17:39:26.064]                         }
[17:39:26.064]                       }
[17:39:26.064]                     }
[17:39:26.064]                     invisible(muffled)
[17:39:26.064]                   }
[17:39:26.064]                   muffleCondition(cond)
[17:39:26.064]                 })
[17:39:26.064]             }))
[17:39:26.064]             future::FutureResult(value = ...future.value$value, 
[17:39:26.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.064]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.064]                     ...future.globalenv.names))
[17:39:26.064]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.064]         }, condition = base::local({
[17:39:26.064]             c <- base::c
[17:39:26.064]             inherits <- base::inherits
[17:39:26.064]             invokeRestart <- base::invokeRestart
[17:39:26.064]             length <- base::length
[17:39:26.064]             list <- base::list
[17:39:26.064]             seq.int <- base::seq.int
[17:39:26.064]             signalCondition <- base::signalCondition
[17:39:26.064]             sys.calls <- base::sys.calls
[17:39:26.064]             `[[` <- base::`[[`
[17:39:26.064]             `+` <- base::`+`
[17:39:26.064]             `<<-` <- base::`<<-`
[17:39:26.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.064]                   3L)]
[17:39:26.064]             }
[17:39:26.064]             function(cond) {
[17:39:26.064]                 is_error <- inherits(cond, "error")
[17:39:26.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.064]                   NULL)
[17:39:26.064]                 if (is_error) {
[17:39:26.064]                   sessionInformation <- function() {
[17:39:26.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.064]                       search = base::search(), system = base::Sys.info())
[17:39:26.064]                   }
[17:39:26.064]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.064]                     cond$call), session = sessionInformation(), 
[17:39:26.064]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.064]                   signalCondition(cond)
[17:39:26.064]                 }
[17:39:26.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.064]                 "immediateCondition"))) {
[17:39:26.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.064]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.064]                   if (TRUE && !signal) {
[17:39:26.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.064]                     {
[17:39:26.064]                       inherits <- base::inherits
[17:39:26.064]                       invokeRestart <- base::invokeRestart
[17:39:26.064]                       is.null <- base::is.null
[17:39:26.064]                       muffled <- FALSE
[17:39:26.064]                       if (inherits(cond, "message")) {
[17:39:26.064]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.064]                         if (muffled) 
[17:39:26.064]                           invokeRestart("muffleMessage")
[17:39:26.064]                       }
[17:39:26.064]                       else if (inherits(cond, "warning")) {
[17:39:26.064]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.064]                         if (muffled) 
[17:39:26.064]                           invokeRestart("muffleWarning")
[17:39:26.064]                       }
[17:39:26.064]                       else if (inherits(cond, "condition")) {
[17:39:26.064]                         if (!is.null(pattern)) {
[17:39:26.064]                           computeRestarts <- base::computeRestarts
[17:39:26.064]                           grepl <- base::grepl
[17:39:26.064]                           restarts <- computeRestarts(cond)
[17:39:26.064]                           for (restart in restarts) {
[17:39:26.064]                             name <- restart$name
[17:39:26.064]                             if (is.null(name)) 
[17:39:26.064]                               next
[17:39:26.064]                             if (!grepl(pattern, name)) 
[17:39:26.064]                               next
[17:39:26.064]                             invokeRestart(restart)
[17:39:26.064]                             muffled <- TRUE
[17:39:26.064]                             break
[17:39:26.064]                           }
[17:39:26.064]                         }
[17:39:26.064]                       }
[17:39:26.064]                       invisible(muffled)
[17:39:26.064]                     }
[17:39:26.064]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.064]                   }
[17:39:26.064]                 }
[17:39:26.064]                 else {
[17:39:26.064]                   if (TRUE) {
[17:39:26.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.064]                     {
[17:39:26.064]                       inherits <- base::inherits
[17:39:26.064]                       invokeRestart <- base::invokeRestart
[17:39:26.064]                       is.null <- base::is.null
[17:39:26.064]                       muffled <- FALSE
[17:39:26.064]                       if (inherits(cond, "message")) {
[17:39:26.064]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.064]                         if (muffled) 
[17:39:26.064]                           invokeRestart("muffleMessage")
[17:39:26.064]                       }
[17:39:26.064]                       else if (inherits(cond, "warning")) {
[17:39:26.064]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.064]                         if (muffled) 
[17:39:26.064]                           invokeRestart("muffleWarning")
[17:39:26.064]                       }
[17:39:26.064]                       else if (inherits(cond, "condition")) {
[17:39:26.064]                         if (!is.null(pattern)) {
[17:39:26.064]                           computeRestarts <- base::computeRestarts
[17:39:26.064]                           grepl <- base::grepl
[17:39:26.064]                           restarts <- computeRestarts(cond)
[17:39:26.064]                           for (restart in restarts) {
[17:39:26.064]                             name <- restart$name
[17:39:26.064]                             if (is.null(name)) 
[17:39:26.064]                               next
[17:39:26.064]                             if (!grepl(pattern, name)) 
[17:39:26.064]                               next
[17:39:26.064]                             invokeRestart(restart)
[17:39:26.064]                             muffled <- TRUE
[17:39:26.064]                             break
[17:39:26.064]                           }
[17:39:26.064]                         }
[17:39:26.064]                       }
[17:39:26.064]                       invisible(muffled)
[17:39:26.064]                     }
[17:39:26.064]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.064]                   }
[17:39:26.064]                 }
[17:39:26.064]             }
[17:39:26.064]         }))
[17:39:26.064]     }, error = function(ex) {
[17:39:26.064]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.064]                 ...future.rng), started = ...future.startTime, 
[17:39:26.064]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.064]             version = "1.8"), class = "FutureResult")
[17:39:26.064]     }, finally = {
[17:39:26.064]         if (!identical(...future.workdir, getwd())) 
[17:39:26.064]             setwd(...future.workdir)
[17:39:26.064]         {
[17:39:26.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.064]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.064]             }
[17:39:26.064]             base::options(...future.oldOptions)
[17:39:26.064]             if (.Platform$OS.type == "windows") {
[17:39:26.064]                 old_names <- names(...future.oldEnvVars)
[17:39:26.064]                 envs <- base::Sys.getenv()
[17:39:26.064]                 names <- names(envs)
[17:39:26.064]                 common <- intersect(names, old_names)
[17:39:26.064]                 added <- setdiff(names, old_names)
[17:39:26.064]                 removed <- setdiff(old_names, names)
[17:39:26.064]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.064]                   envs[common]]
[17:39:26.064]                 NAMES <- toupper(changed)
[17:39:26.064]                 args <- list()
[17:39:26.064]                 for (kk in seq_along(NAMES)) {
[17:39:26.064]                   name <- changed[[kk]]
[17:39:26.064]                   NAME <- NAMES[[kk]]
[17:39:26.064]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.064]                     next
[17:39:26.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.064]                 }
[17:39:26.064]                 NAMES <- toupper(added)
[17:39:26.064]                 for (kk in seq_along(NAMES)) {
[17:39:26.064]                   name <- added[[kk]]
[17:39:26.064]                   NAME <- NAMES[[kk]]
[17:39:26.064]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.064]                     next
[17:39:26.064]                   args[[name]] <- ""
[17:39:26.064]                 }
[17:39:26.064]                 NAMES <- toupper(removed)
[17:39:26.064]                 for (kk in seq_along(NAMES)) {
[17:39:26.064]                   name <- removed[[kk]]
[17:39:26.064]                   NAME <- NAMES[[kk]]
[17:39:26.064]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.064]                     next
[17:39:26.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.064]                 }
[17:39:26.064]                 if (length(args) > 0) 
[17:39:26.064]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.064]             }
[17:39:26.064]             else {
[17:39:26.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.064]             }
[17:39:26.064]             {
[17:39:26.064]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.064]                   0L) {
[17:39:26.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.064]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.064]                   base::options(opts)
[17:39:26.064]                 }
[17:39:26.064]                 {
[17:39:26.064]                   {
[17:39:26.064]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.064]                     NULL
[17:39:26.064]                   }
[17:39:26.064]                   options(future.plan = NULL)
[17:39:26.064]                   if (is.na(NA_character_)) 
[17:39:26.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.064]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.064]                     envir = parent.frame()) 
[17:39:26.064]                   {
[17:39:26.064]                     default_workers <- missing(workers)
[17:39:26.064]                     if (is.function(workers)) 
[17:39:26.064]                       workers <- workers()
[17:39:26.064]                     workers <- structure(as.integer(workers), 
[17:39:26.064]                       class = class(workers))
[17:39:26.064]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.064]                       1L)
[17:39:26.064]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.064]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.064]                       if (default_workers) 
[17:39:26.064]                         supportsMulticore(warn = TRUE)
[17:39:26.064]                       return(sequential(..., envir = envir))
[17:39:26.064]                     }
[17:39:26.064]                     oopts <- options(mc.cores = workers)
[17:39:26.064]                     on.exit(options(oopts))
[17:39:26.064]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.064]                       envir = envir)
[17:39:26.064]                     if (!future$lazy) 
[17:39:26.064]                       future <- run(future)
[17:39:26.064]                     invisible(future)
[17:39:26.064]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.064]                 }
[17:39:26.064]             }
[17:39:26.064]         }
[17:39:26.064]     })
[17:39:26.064]     if (TRUE) {
[17:39:26.064]         base::sink(type = "output", split = FALSE)
[17:39:26.064]         if (TRUE) {
[17:39:26.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.064]         }
[17:39:26.064]         else {
[17:39:26.064]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.064]         }
[17:39:26.064]         base::close(...future.stdout)
[17:39:26.064]         ...future.stdout <- NULL
[17:39:26.064]     }
[17:39:26.064]     ...future.result$conditions <- ...future.conditions
[17:39:26.064]     ...future.result$finished <- base::Sys.time()
[17:39:26.064]     ...future.result
[17:39:26.064] }
[17:39:26.067] assign_globals() ...
[17:39:26.067] List of 5
[17:39:26.067]  $ ...future.FUN            :function (object, ...)  
[17:39:26.067]  $ future.call.arguments    : list()
[17:39:26.067]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.067]  $ ...future.elements_ii    :List of 2
[17:39:26.067]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:26.067]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:26.067]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.067]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:39:26.067]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:26.067]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.067]  $ ...future.seeds_ii       : NULL
[17:39:26.067]  $ ...future.globals.maxSize: NULL
[17:39:26.067]  - attr(*, "resolved")= logi FALSE
[17:39:26.067]  - attr(*, "total_size")= num 1240
[17:39:26.067]  - attr(*, "where")=List of 5
[17:39:26.067]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.067]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.067]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.067]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.067]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.067]  - attr(*, "already-done")= logi TRUE
[17:39:26.075] - copied ‘...future.FUN’ to environment
[17:39:26.075] - copied ‘future.call.arguments’ to environment
[17:39:26.076] - copied ‘...future.elements_ii’ to environment
[17:39:26.076] - copied ‘...future.seeds_ii’ to environment
[17:39:26.076] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.076] assign_globals() ... done
[17:39:26.076] requestCore(): workers = 2
[17:39:26.081] MulticoreFuture started
[17:39:26.081] - Launch lazy future ... done
[17:39:26.081] run() for ‘MulticoreFuture’ ... done
[17:39:26.082] Created future:
[17:39:26.082] plan(): Setting new future strategy stack:
[17:39:26.082] List of future strategies:
[17:39:26.082] 1. sequential:
[17:39:26.082]    - args: function (..., envir = parent.frame())
[17:39:26.082]    - tweaked: FALSE
[17:39:26.082]    - call: NULL
[17:39:26.083] plan(): nbrOfWorkers() = 1
[17:39:26.096] plan(): Setting new future strategy stack:
[17:39:26.096] List of future strategies:
[17:39:26.096] 1. multicore:
[17:39:26.096]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.096]    - tweaked: FALSE
[17:39:26.096]    - call: plan(strategy)
[17:39:26.101] plan(): nbrOfWorkers() = 2
[17:39:26.082] MulticoreFuture:
[17:39:26.082] Label: ‘future_by-2’
[17:39:26.082] Expression:
[17:39:26.082] {
[17:39:26.082]     do.call(function(...) {
[17:39:26.082]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.082]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.082]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.082]             on.exit(options(oopts), add = TRUE)
[17:39:26.082]         }
[17:39:26.082]         {
[17:39:26.082]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.082]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.082]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.082]             })
[17:39:26.082]         }
[17:39:26.082]     }, args = future.call.arguments)
[17:39:26.082] }
[17:39:26.082] Lazy evaluation: FALSE
[17:39:26.082] Asynchronous evaluation: TRUE
[17:39:26.082] Local evaluation: TRUE
[17:39:26.082] Environment: R_GlobalEnv
[17:39:26.082] Capture standard output: TRUE
[17:39:26.082] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.082] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.082] Packages: <none>
[17:39:26.082] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.082] Resolved: TRUE
[17:39:26.082] Value: <not collected>
[17:39:26.082] Conditions captured: <none>
[17:39:26.082] Early signaling: FALSE
[17:39:26.082] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.082] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.103] Chunk #2 of 2 ... DONE
[17:39:26.103] Launching 2 futures (chunks) ... DONE
[17:39:26.103] Resolving 2 futures (chunks) ...
[17:39:26.103] resolve() on list ...
[17:39:26.103]  recursive: 0
[17:39:26.103]  length: 2
[17:39:26.103] 
[17:39:26.104] Future #1
[17:39:26.106] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:26.106] - nx: 2
[17:39:26.106] - relay: TRUE
[17:39:26.106] - stdout: TRUE
[17:39:26.107] - signal: TRUE
[17:39:26.107] - resignal: FALSE
[17:39:26.107] - force: TRUE
[17:39:26.107] - relayed: [n=2] FALSE, FALSE
[17:39:26.107] - queued futures: [n=2] FALSE, FALSE
[17:39:26.108]  - until=1
[17:39:26.108]  - relaying element #1
[17:39:26.108] - relayed: [n=2] TRUE, FALSE
[17:39:26.108] - queued futures: [n=2] TRUE, FALSE
[17:39:26.108] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:26.109]  length: 1 (resolved future 1)
[17:39:26.109] Future #2
[17:39:26.110] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:26.110] - nx: 2
[17:39:26.110] - relay: TRUE
[17:39:26.111] - stdout: TRUE
[17:39:26.111] - signal: TRUE
[17:39:26.111] - resignal: FALSE
[17:39:26.111] - force: TRUE
[17:39:26.111] - relayed: [n=2] TRUE, FALSE
[17:39:26.111] - queued futures: [n=2] TRUE, FALSE
[17:39:26.111]  - until=2
[17:39:26.112]  - relaying element #2
[17:39:26.112] - relayed: [n=2] TRUE, TRUE
[17:39:26.112] - queued futures: [n=2] TRUE, TRUE
[17:39:26.112] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:26.112]  length: 0 (resolved future 2)
[17:39:26.112] Relaying remaining futures
[17:39:26.112] signalConditionsASAP(NULL, pos=0) ...
[17:39:26.113] - nx: 2
[17:39:26.113] - relay: TRUE
[17:39:26.113] - stdout: TRUE
[17:39:26.113] - signal: TRUE
[17:39:26.113] - resignal: FALSE
[17:39:26.113] - force: TRUE
[17:39:26.113] - relayed: [n=2] TRUE, TRUE
[17:39:26.113] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:26.113] - relayed: [n=2] TRUE, TRUE
[17:39:26.113] - queued futures: [n=2] TRUE, TRUE
[17:39:26.114] signalConditionsASAP(NULL, pos=0) ... done
[17:39:26.114] resolve() on list ... DONE
[17:39:26.114]  - Number of value chunks collected: 2
[17:39:26.114] Resolving 2 futures (chunks) ... DONE
[17:39:26.114] Reducing values from 2 chunks ...
[17:39:26.114]  - Number of values collected after concatenation: 3
[17:39:26.114]  - Number of values expected: 3
[17:39:26.115] Reducing values from 2 chunks ... DONE
[17:39:26.115] future_lapply() ... DONE
[17:39:26.115] future_by_internal() ... DONE
[17:39:26.115] future_by_internal() ...
[17:39:26.116] future_lapply() ...
[17:39:26.120] Number of chunks: 2
[17:39:26.120] getGlobalsAndPackagesXApply() ...
[17:39:26.120]  - future.globals: TRUE
[17:39:26.120] getGlobalsAndPackages() ...
[17:39:26.120] Searching for globals...
[17:39:26.121] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:26.122] Searching for globals ... DONE
[17:39:26.122] Resolving globals: FALSE
[17:39:26.122] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:26.122] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:26.123] - globals: [1] ‘FUN’
[17:39:26.123] 
[17:39:26.123] getGlobalsAndPackages() ... DONE
[17:39:26.123]  - globals found/used: [n=1] ‘FUN’
[17:39:26.123]  - needed namespaces: [n=0] 
[17:39:26.123] Finding globals ... DONE
[17:39:26.123]  - use_args: TRUE
[17:39:26.123]  - Getting '...' globals ...
[17:39:26.124] resolve() on list ...
[17:39:26.124]  recursive: 0
[17:39:26.124]  length: 1
[17:39:26.124]  elements: ‘...’
[17:39:26.124]  length: 0 (resolved future 1)
[17:39:26.124] resolve() on list ... DONE
[17:39:26.124]    - '...' content: [n=1] ‘digits’
[17:39:26.124] List of 1
[17:39:26.124]  $ ...:List of 1
[17:39:26.124]   ..$ digits: int 2
[17:39:26.124]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.124]  - attr(*, "where")=List of 1
[17:39:26.124]   ..$ ...:<environment: 0x56296ee28fd0> 
[17:39:26.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.124]  - attr(*, "resolved")= logi TRUE
[17:39:26.124]  - attr(*, "total_size")= num NA
[17:39:26.128]  - Getting '...' globals ... DONE
[17:39:26.128] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:26.128] List of 2
[17:39:26.128]  $ ...future.FUN:function (object, ...)  
[17:39:26.128]  $ ...          :List of 1
[17:39:26.128]   ..$ digits: int 2
[17:39:26.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.128]  - attr(*, "where")=List of 2
[17:39:26.128]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:26.128]   ..$ ...          :<environment: 0x56296ee28fd0> 
[17:39:26.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.128]  - attr(*, "resolved")= logi FALSE
[17:39:26.128]  - attr(*, "total_size")= num 1296
[17:39:26.133] Packages to be attached in all futures: [n=0] 
[17:39:26.133] getGlobalsAndPackagesXApply() ... DONE
[17:39:26.134] Number of futures (= number of chunks): 2
[17:39:26.134] Launching 2 futures (chunks) ...
[17:39:26.134] Chunk #1 of 2 ...
[17:39:26.134]  - Finding globals in 'X' for chunk #1 ...
[17:39:26.134] getGlobalsAndPackages() ...
[17:39:26.134] Searching for globals...
[17:39:26.134] 
[17:39:26.134] Searching for globals ... DONE
[17:39:26.135] - globals: [0] <none>
[17:39:26.135] getGlobalsAndPackages() ... DONE
[17:39:26.135]    + additional globals found: [n=0] 
[17:39:26.135]    + additional namespaces needed: [n=0] 
[17:39:26.135]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:26.135]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:26.135]  - seeds: <none>
[17:39:26.135] getGlobalsAndPackages() ...
[17:39:26.135] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.136] Resolving globals: FALSE
[17:39:26.136] Tweak future expression to call with '...' arguments ...
[17:39:26.136] {
[17:39:26.136]     do.call(function(...) {
[17:39:26.136]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.136]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.136]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.136]             on.exit(options(oopts), add = TRUE)
[17:39:26.136]         }
[17:39:26.136]         {
[17:39:26.136]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.136]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.136]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.136]             })
[17:39:26.136]         }
[17:39:26.136]     }, args = future.call.arguments)
[17:39:26.136] }
[17:39:26.136] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.136] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.137] 
[17:39:26.137] getGlobalsAndPackages() ... DONE
[17:39:26.137] run() for ‘Future’ ...
[17:39:26.137] - state: ‘created’
[17:39:26.137] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.141] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.141] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.141]   - Field: ‘label’
[17:39:26.141]   - Field: ‘local’
[17:39:26.141]   - Field: ‘owner’
[17:39:26.142]   - Field: ‘envir’
[17:39:26.142]   - Field: ‘workers’
[17:39:26.142]   - Field: ‘packages’
[17:39:26.142]   - Field: ‘gc’
[17:39:26.142]   - Field: ‘job’
[17:39:26.142]   - Field: ‘conditions’
[17:39:26.142]   - Field: ‘expr’
[17:39:26.142]   - Field: ‘uuid’
[17:39:26.142]   - Field: ‘seed’
[17:39:26.142]   - Field: ‘version’
[17:39:26.142]   - Field: ‘result’
[17:39:26.143]   - Field: ‘asynchronous’
[17:39:26.143]   - Field: ‘calls’
[17:39:26.143]   - Field: ‘globals’
[17:39:26.143]   - Field: ‘stdout’
[17:39:26.143]   - Field: ‘earlySignal’
[17:39:26.143]   - Field: ‘lazy’
[17:39:26.143]   - Field: ‘state’
[17:39:26.143] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.143] - Launch lazy future ...
[17:39:26.144] Packages needed by the future expression (n = 0): <none>
[17:39:26.144] Packages needed by future strategies (n = 0): <none>
[17:39:26.144] {
[17:39:26.144]     {
[17:39:26.144]         {
[17:39:26.144]             ...future.startTime <- base::Sys.time()
[17:39:26.144]             {
[17:39:26.144]                 {
[17:39:26.144]                   {
[17:39:26.144]                     {
[17:39:26.144]                       base::local({
[17:39:26.144]                         has_future <- base::requireNamespace("future", 
[17:39:26.144]                           quietly = TRUE)
[17:39:26.144]                         if (has_future) {
[17:39:26.144]                           ns <- base::getNamespace("future")
[17:39:26.144]                           version <- ns[[".package"]][["version"]]
[17:39:26.144]                           if (is.null(version)) 
[17:39:26.144]                             version <- utils::packageVersion("future")
[17:39:26.144]                         }
[17:39:26.144]                         else {
[17:39:26.144]                           version <- NULL
[17:39:26.144]                         }
[17:39:26.144]                         if (!has_future || version < "1.8.0") {
[17:39:26.144]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.144]                             "", base::R.version$version.string), 
[17:39:26.144]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:26.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:26.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.144]                               "release", "version")], collapse = " "), 
[17:39:26.144]                             hostname = base::Sys.info()[["nodename"]])
[17:39:26.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.144]                             info)
[17:39:26.144]                           info <- base::paste(info, collapse = "; ")
[17:39:26.144]                           if (!has_future) {
[17:39:26.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.144]                               info)
[17:39:26.144]                           }
[17:39:26.144]                           else {
[17:39:26.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.144]                               info, version)
[17:39:26.144]                           }
[17:39:26.144]                           base::stop(msg)
[17:39:26.144]                         }
[17:39:26.144]                       })
[17:39:26.144]                     }
[17:39:26.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.144]                     base::options(mc.cores = 1L)
[17:39:26.144]                   }
[17:39:26.144]                   options(future.plan = NULL)
[17:39:26.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.144]                 }
[17:39:26.144]                 ...future.workdir <- getwd()
[17:39:26.144]             }
[17:39:26.144]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.144]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.144]         }
[17:39:26.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.144]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:26.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.144]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.144]             base::names(...future.oldOptions))
[17:39:26.144]     }
[17:39:26.144]     if (FALSE) {
[17:39:26.144]     }
[17:39:26.144]     else {
[17:39:26.144]         if (TRUE) {
[17:39:26.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.144]                 open = "w")
[17:39:26.144]         }
[17:39:26.144]         else {
[17:39:26.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.144]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.144]         }
[17:39:26.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.144]             base::sink(type = "output", split = FALSE)
[17:39:26.144]             base::close(...future.stdout)
[17:39:26.144]         }, add = TRUE)
[17:39:26.144]     }
[17:39:26.144]     ...future.frame <- base::sys.nframe()
[17:39:26.144]     ...future.conditions <- base::list()
[17:39:26.144]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.144]     if (FALSE) {
[17:39:26.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.144]     }
[17:39:26.144]     ...future.result <- base::tryCatch({
[17:39:26.144]         base::withCallingHandlers({
[17:39:26.144]             ...future.value <- base::withVisible(base::local({
[17:39:26.144]                 withCallingHandlers({
[17:39:26.144]                   {
[17:39:26.144]                     do.call(function(...) {
[17:39:26.144]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.144]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.144]                         ...future.globals.maxSize)) {
[17:39:26.144]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.144]                         on.exit(options(oopts), add = TRUE)
[17:39:26.144]                       }
[17:39:26.144]                       {
[17:39:26.144]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.144]                           FUN = function(jj) {
[17:39:26.144]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.144]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.144]                           })
[17:39:26.144]                       }
[17:39:26.144]                     }, args = future.call.arguments)
[17:39:26.144]                   }
[17:39:26.144]                 }, immediateCondition = function(cond) {
[17:39:26.144]                   save_rds <- function (object, pathname, ...) 
[17:39:26.144]                   {
[17:39:26.144]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.144]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.144]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.144]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.144]                         fi_tmp[["mtime"]])
[17:39:26.144]                     }
[17:39:26.144]                     tryCatch({
[17:39:26.144]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.144]                     }, error = function(ex) {
[17:39:26.144]                       msg <- conditionMessage(ex)
[17:39:26.144]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.144]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.144]                         fi_tmp[["mtime"]], msg)
[17:39:26.144]                       ex$message <- msg
[17:39:26.144]                       stop(ex)
[17:39:26.144]                     })
[17:39:26.144]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.144]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.144]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.144]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.144]                       fi <- file.info(pathname)
[17:39:26.144]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.144]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.144]                         fi[["size"]], fi[["mtime"]])
[17:39:26.144]                       stop(msg)
[17:39:26.144]                     }
[17:39:26.144]                     invisible(pathname)
[17:39:26.144]                   }
[17:39:26.144]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.144]                     rootPath = tempdir()) 
[17:39:26.144]                   {
[17:39:26.144]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.144]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.144]                       tmpdir = path, fileext = ".rds")
[17:39:26.144]                     save_rds(obj, file)
[17:39:26.144]                   }
[17:39:26.144]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.144]                   {
[17:39:26.144]                     inherits <- base::inherits
[17:39:26.144]                     invokeRestart <- base::invokeRestart
[17:39:26.144]                     is.null <- base::is.null
[17:39:26.144]                     muffled <- FALSE
[17:39:26.144]                     if (inherits(cond, "message")) {
[17:39:26.144]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.144]                       if (muffled) 
[17:39:26.144]                         invokeRestart("muffleMessage")
[17:39:26.144]                     }
[17:39:26.144]                     else if (inherits(cond, "warning")) {
[17:39:26.144]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.144]                       if (muffled) 
[17:39:26.144]                         invokeRestart("muffleWarning")
[17:39:26.144]                     }
[17:39:26.144]                     else if (inherits(cond, "condition")) {
[17:39:26.144]                       if (!is.null(pattern)) {
[17:39:26.144]                         computeRestarts <- base::computeRestarts
[17:39:26.144]                         grepl <- base::grepl
[17:39:26.144]                         restarts <- computeRestarts(cond)
[17:39:26.144]                         for (restart in restarts) {
[17:39:26.144]                           name <- restart$name
[17:39:26.144]                           if (is.null(name)) 
[17:39:26.144]                             next
[17:39:26.144]                           if (!grepl(pattern, name)) 
[17:39:26.144]                             next
[17:39:26.144]                           invokeRestart(restart)
[17:39:26.144]                           muffled <- TRUE
[17:39:26.144]                           break
[17:39:26.144]                         }
[17:39:26.144]                       }
[17:39:26.144]                     }
[17:39:26.144]                     invisible(muffled)
[17:39:26.144]                   }
[17:39:26.144]                   muffleCondition(cond)
[17:39:26.144]                 })
[17:39:26.144]             }))
[17:39:26.144]             future::FutureResult(value = ...future.value$value, 
[17:39:26.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.144]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.144]                     ...future.globalenv.names))
[17:39:26.144]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.144]         }, condition = base::local({
[17:39:26.144]             c <- base::c
[17:39:26.144]             inherits <- base::inherits
[17:39:26.144]             invokeRestart <- base::invokeRestart
[17:39:26.144]             length <- base::length
[17:39:26.144]             list <- base::list
[17:39:26.144]             seq.int <- base::seq.int
[17:39:26.144]             signalCondition <- base::signalCondition
[17:39:26.144]             sys.calls <- base::sys.calls
[17:39:26.144]             `[[` <- base::`[[`
[17:39:26.144]             `+` <- base::`+`
[17:39:26.144]             `<<-` <- base::`<<-`
[17:39:26.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.144]                   3L)]
[17:39:26.144]             }
[17:39:26.144]             function(cond) {
[17:39:26.144]                 is_error <- inherits(cond, "error")
[17:39:26.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.144]                   NULL)
[17:39:26.144]                 if (is_error) {
[17:39:26.144]                   sessionInformation <- function() {
[17:39:26.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.144]                       search = base::search(), system = base::Sys.info())
[17:39:26.144]                   }
[17:39:26.144]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.144]                     cond$call), session = sessionInformation(), 
[17:39:26.144]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.144]                   signalCondition(cond)
[17:39:26.144]                 }
[17:39:26.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.144]                 "immediateCondition"))) {
[17:39:26.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.144]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.144]                   if (TRUE && !signal) {
[17:39:26.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.144]                     {
[17:39:26.144]                       inherits <- base::inherits
[17:39:26.144]                       invokeRestart <- base::invokeRestart
[17:39:26.144]                       is.null <- base::is.null
[17:39:26.144]                       muffled <- FALSE
[17:39:26.144]                       if (inherits(cond, "message")) {
[17:39:26.144]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.144]                         if (muffled) 
[17:39:26.144]                           invokeRestart("muffleMessage")
[17:39:26.144]                       }
[17:39:26.144]                       else if (inherits(cond, "warning")) {
[17:39:26.144]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.144]                         if (muffled) 
[17:39:26.144]                           invokeRestart("muffleWarning")
[17:39:26.144]                       }
[17:39:26.144]                       else if (inherits(cond, "condition")) {
[17:39:26.144]                         if (!is.null(pattern)) {
[17:39:26.144]                           computeRestarts <- base::computeRestarts
[17:39:26.144]                           grepl <- base::grepl
[17:39:26.144]                           restarts <- computeRestarts(cond)
[17:39:26.144]                           for (restart in restarts) {
[17:39:26.144]                             name <- restart$name
[17:39:26.144]                             if (is.null(name)) 
[17:39:26.144]                               next
[17:39:26.144]                             if (!grepl(pattern, name)) 
[17:39:26.144]                               next
[17:39:26.144]                             invokeRestart(restart)
[17:39:26.144]                             muffled <- TRUE
[17:39:26.144]                             break
[17:39:26.144]                           }
[17:39:26.144]                         }
[17:39:26.144]                       }
[17:39:26.144]                       invisible(muffled)
[17:39:26.144]                     }
[17:39:26.144]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.144]                   }
[17:39:26.144]                 }
[17:39:26.144]                 else {
[17:39:26.144]                   if (TRUE) {
[17:39:26.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.144]                     {
[17:39:26.144]                       inherits <- base::inherits
[17:39:26.144]                       invokeRestart <- base::invokeRestart
[17:39:26.144]                       is.null <- base::is.null
[17:39:26.144]                       muffled <- FALSE
[17:39:26.144]                       if (inherits(cond, "message")) {
[17:39:26.144]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.144]                         if (muffled) 
[17:39:26.144]                           invokeRestart("muffleMessage")
[17:39:26.144]                       }
[17:39:26.144]                       else if (inherits(cond, "warning")) {
[17:39:26.144]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.144]                         if (muffled) 
[17:39:26.144]                           invokeRestart("muffleWarning")
[17:39:26.144]                       }
[17:39:26.144]                       else if (inherits(cond, "condition")) {
[17:39:26.144]                         if (!is.null(pattern)) {
[17:39:26.144]                           computeRestarts <- base::computeRestarts
[17:39:26.144]                           grepl <- base::grepl
[17:39:26.144]                           restarts <- computeRestarts(cond)
[17:39:26.144]                           for (restart in restarts) {
[17:39:26.144]                             name <- restart$name
[17:39:26.144]                             if (is.null(name)) 
[17:39:26.144]                               next
[17:39:26.144]                             if (!grepl(pattern, name)) 
[17:39:26.144]                               next
[17:39:26.144]                             invokeRestart(restart)
[17:39:26.144]                             muffled <- TRUE
[17:39:26.144]                             break
[17:39:26.144]                           }
[17:39:26.144]                         }
[17:39:26.144]                       }
[17:39:26.144]                       invisible(muffled)
[17:39:26.144]                     }
[17:39:26.144]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.144]                   }
[17:39:26.144]                 }
[17:39:26.144]             }
[17:39:26.144]         }))
[17:39:26.144]     }, error = function(ex) {
[17:39:26.144]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.144]                 ...future.rng), started = ...future.startTime, 
[17:39:26.144]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.144]             version = "1.8"), class = "FutureResult")
[17:39:26.144]     }, finally = {
[17:39:26.144]         if (!identical(...future.workdir, getwd())) 
[17:39:26.144]             setwd(...future.workdir)
[17:39:26.144]         {
[17:39:26.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.144]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.144]             }
[17:39:26.144]             base::options(...future.oldOptions)
[17:39:26.144]             if (.Platform$OS.type == "windows") {
[17:39:26.144]                 old_names <- names(...future.oldEnvVars)
[17:39:26.144]                 envs <- base::Sys.getenv()
[17:39:26.144]                 names <- names(envs)
[17:39:26.144]                 common <- intersect(names, old_names)
[17:39:26.144]                 added <- setdiff(names, old_names)
[17:39:26.144]                 removed <- setdiff(old_names, names)
[17:39:26.144]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.144]                   envs[common]]
[17:39:26.144]                 NAMES <- toupper(changed)
[17:39:26.144]                 args <- list()
[17:39:26.144]                 for (kk in seq_along(NAMES)) {
[17:39:26.144]                   name <- changed[[kk]]
[17:39:26.144]                   NAME <- NAMES[[kk]]
[17:39:26.144]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.144]                     next
[17:39:26.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.144]                 }
[17:39:26.144]                 NAMES <- toupper(added)
[17:39:26.144]                 for (kk in seq_along(NAMES)) {
[17:39:26.144]                   name <- added[[kk]]
[17:39:26.144]                   NAME <- NAMES[[kk]]
[17:39:26.144]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.144]                     next
[17:39:26.144]                   args[[name]] <- ""
[17:39:26.144]                 }
[17:39:26.144]                 NAMES <- toupper(removed)
[17:39:26.144]                 for (kk in seq_along(NAMES)) {
[17:39:26.144]                   name <- removed[[kk]]
[17:39:26.144]                   NAME <- NAMES[[kk]]
[17:39:26.144]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.144]                     next
[17:39:26.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.144]                 }
[17:39:26.144]                 if (length(args) > 0) 
[17:39:26.144]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.144]             }
[17:39:26.144]             else {
[17:39:26.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.144]             }
[17:39:26.144]             {
[17:39:26.144]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.144]                   0L) {
[17:39:26.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.144]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.144]                   base::options(opts)
[17:39:26.144]                 }
[17:39:26.144]                 {
[17:39:26.144]                   {
[17:39:26.144]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.144]                     NULL
[17:39:26.144]                   }
[17:39:26.144]                   options(future.plan = NULL)
[17:39:26.144]                   if (is.na(NA_character_)) 
[17:39:26.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.144]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.144]                     envir = parent.frame()) 
[17:39:26.144]                   {
[17:39:26.144]                     default_workers <- missing(workers)
[17:39:26.144]                     if (is.function(workers)) 
[17:39:26.144]                       workers <- workers()
[17:39:26.144]                     workers <- structure(as.integer(workers), 
[17:39:26.144]                       class = class(workers))
[17:39:26.144]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.144]                       1L)
[17:39:26.144]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.144]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.144]                       if (default_workers) 
[17:39:26.144]                         supportsMulticore(warn = TRUE)
[17:39:26.144]                       return(sequential(..., envir = envir))
[17:39:26.144]                     }
[17:39:26.144]                     oopts <- options(mc.cores = workers)
[17:39:26.144]                     on.exit(options(oopts))
[17:39:26.144]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.144]                       envir = envir)
[17:39:26.144]                     if (!future$lazy) 
[17:39:26.144]                       future <- run(future)
[17:39:26.144]                     invisible(future)
[17:39:26.144]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.144]                 }
[17:39:26.144]             }
[17:39:26.144]         }
[17:39:26.144]     })
[17:39:26.144]     if (TRUE) {
[17:39:26.144]         base::sink(type = "output", split = FALSE)
[17:39:26.144]         if (TRUE) {
[17:39:26.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.144]         }
[17:39:26.144]         else {
[17:39:26.144]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.144]         }
[17:39:26.144]         base::close(...future.stdout)
[17:39:26.144]         ...future.stdout <- NULL
[17:39:26.144]     }
[17:39:26.144]     ...future.result$conditions <- ...future.conditions
[17:39:26.144]     ...future.result$finished <- base::Sys.time()
[17:39:26.144]     ...future.result
[17:39:26.144] }
[17:39:26.147] assign_globals() ...
[17:39:26.147] List of 5
[17:39:26.147]  $ ...future.FUN            :function (object, ...)  
[17:39:26.147]  $ future.call.arguments    :List of 1
[17:39:26.147]   ..$ digits: int 2
[17:39:26.147]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.147]  $ ...future.elements_ii    :List of 3
[17:39:26.147]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:39:26.147]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:39:26.147]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:39:26.147]  $ ...future.seeds_ii       : NULL
[17:39:26.147]  $ ...future.globals.maxSize: NULL
[17:39:26.147]  - attr(*, "resolved")= logi FALSE
[17:39:26.147]  - attr(*, "total_size")= num 1296
[17:39:26.147]  - attr(*, "where")=List of 5
[17:39:26.147]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.147]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.147]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.147]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.147]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.147]  - attr(*, "already-done")= logi TRUE
[17:39:26.153] - copied ‘...future.FUN’ to environment
[17:39:26.153] - copied ‘future.call.arguments’ to environment
[17:39:26.153] - copied ‘...future.elements_ii’ to environment
[17:39:26.155] - copied ‘...future.seeds_ii’ to environment
[17:39:26.155] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.155] assign_globals() ... done
[17:39:26.155] requestCore(): workers = 2
[17:39:26.157] MulticoreFuture started
[17:39:26.158] - Launch lazy future ... done
[17:39:26.159] plan(): Setting new future strategy stack:
[17:39:26.159] run() for ‘MulticoreFuture’ ... done
[17:39:26.159] Created future:
[17:39:26.159] List of future strategies:
[17:39:26.159] 1. sequential:
[17:39:26.159]    - args: function (..., envir = parent.frame())
[17:39:26.159]    - tweaked: FALSE
[17:39:26.159]    - call: NULL
[17:39:26.160] plan(): nbrOfWorkers() = 1
[17:39:26.164] plan(): Setting new future strategy stack:
[17:39:26.165] List of future strategies:
[17:39:26.165] 1. multicore:
[17:39:26.165]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.165]    - tweaked: FALSE
[17:39:26.165]    - call: plan(strategy)
[17:39:26.171] plan(): nbrOfWorkers() = 2
[17:39:26.160] MulticoreFuture:
[17:39:26.160] Label: ‘future_by-1’
[17:39:26.160] Expression:
[17:39:26.160] {
[17:39:26.160]     do.call(function(...) {
[17:39:26.160]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.160]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.160]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.160]             on.exit(options(oopts), add = TRUE)
[17:39:26.160]         }
[17:39:26.160]         {
[17:39:26.160]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.160]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.160]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.160]             })
[17:39:26.160]         }
[17:39:26.160]     }, args = future.call.arguments)
[17:39:26.160] }
[17:39:26.160] Lazy evaluation: FALSE
[17:39:26.160] Asynchronous evaluation: TRUE
[17:39:26.160] Local evaluation: TRUE
[17:39:26.160] Environment: R_GlobalEnv
[17:39:26.160] Capture standard output: TRUE
[17:39:26.160] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.160] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.160] Packages: <none>
[17:39:26.160] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.160] Resolved: TRUE
[17:39:26.160] Value: <not collected>
[17:39:26.160] Conditions captured: <none>
[17:39:26.160] Early signaling: FALSE
[17:39:26.160] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.160] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.172] Chunk #1 of 2 ... DONE
[17:39:26.172] Chunk #2 of 2 ...
[17:39:26.173]  - Finding globals in 'X' for chunk #2 ...
[17:39:26.173] getGlobalsAndPackages() ...
[17:39:26.173] Searching for globals...
[17:39:26.174] 
[17:39:26.174] Searching for globals ... DONE
[17:39:26.174] - globals: [0] <none>
[17:39:26.174] getGlobalsAndPackages() ... DONE
[17:39:26.174]    + additional globals found: [n=0] 
[17:39:26.174]    + additional namespaces needed: [n=0] 
[17:39:26.175]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:26.175]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:26.175]  - seeds: <none>
[17:39:26.175] getGlobalsAndPackages() ...
[17:39:26.175] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.176] Resolving globals: FALSE
[17:39:26.176] Tweak future expression to call with '...' arguments ...
[17:39:26.176] {
[17:39:26.176]     do.call(function(...) {
[17:39:26.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.176]             on.exit(options(oopts), add = TRUE)
[17:39:26.176]         }
[17:39:26.176]         {
[17:39:26.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.176]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.176]             })
[17:39:26.176]         }
[17:39:26.176]     }, args = future.call.arguments)
[17:39:26.176] }
[17:39:26.177] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.178] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.178] 
[17:39:26.178] getGlobalsAndPackages() ... DONE
[17:39:26.179] run() for ‘Future’ ...
[17:39:26.179] - state: ‘created’
[17:39:26.179] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.184] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.184]   - Field: ‘label’
[17:39:26.185]   - Field: ‘local’
[17:39:26.185]   - Field: ‘owner’
[17:39:26.185]   - Field: ‘envir’
[17:39:26.185]   - Field: ‘workers’
[17:39:26.185]   - Field: ‘packages’
[17:39:26.185]   - Field: ‘gc’
[17:39:26.185]   - Field: ‘job’
[17:39:26.186]   - Field: ‘conditions’
[17:39:26.186]   - Field: ‘expr’
[17:39:26.186]   - Field: ‘uuid’
[17:39:26.186]   - Field: ‘seed’
[17:39:26.186]   - Field: ‘version’
[17:39:26.186]   - Field: ‘result’
[17:39:26.186]   - Field: ‘asynchronous’
[17:39:26.187]   - Field: ‘calls’
[17:39:26.187]   - Field: ‘globals’
[17:39:26.187]   - Field: ‘stdout’
[17:39:26.187]   - Field: ‘earlySignal’
[17:39:26.187]   - Field: ‘lazy’
[17:39:26.187]   - Field: ‘state’
[17:39:26.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.188] - Launch lazy future ...
[17:39:26.188] Packages needed by the future expression (n = 0): <none>
[17:39:26.188] Packages needed by future strategies (n = 0): <none>
[17:39:26.189] {
[17:39:26.189]     {
[17:39:26.189]         {
[17:39:26.189]             ...future.startTime <- base::Sys.time()
[17:39:26.189]             {
[17:39:26.189]                 {
[17:39:26.189]                   {
[17:39:26.189]                     {
[17:39:26.189]                       base::local({
[17:39:26.189]                         has_future <- base::requireNamespace("future", 
[17:39:26.189]                           quietly = TRUE)
[17:39:26.189]                         if (has_future) {
[17:39:26.189]                           ns <- base::getNamespace("future")
[17:39:26.189]                           version <- ns[[".package"]][["version"]]
[17:39:26.189]                           if (is.null(version)) 
[17:39:26.189]                             version <- utils::packageVersion("future")
[17:39:26.189]                         }
[17:39:26.189]                         else {
[17:39:26.189]                           version <- NULL
[17:39:26.189]                         }
[17:39:26.189]                         if (!has_future || version < "1.8.0") {
[17:39:26.189]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.189]                             "", base::R.version$version.string), 
[17:39:26.189]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:26.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:26.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.189]                               "release", "version")], collapse = " "), 
[17:39:26.189]                             hostname = base::Sys.info()[["nodename"]])
[17:39:26.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.189]                             info)
[17:39:26.189]                           info <- base::paste(info, collapse = "; ")
[17:39:26.189]                           if (!has_future) {
[17:39:26.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.189]                               info)
[17:39:26.189]                           }
[17:39:26.189]                           else {
[17:39:26.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.189]                               info, version)
[17:39:26.189]                           }
[17:39:26.189]                           base::stop(msg)
[17:39:26.189]                         }
[17:39:26.189]                       })
[17:39:26.189]                     }
[17:39:26.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.189]                     base::options(mc.cores = 1L)
[17:39:26.189]                   }
[17:39:26.189]                   options(future.plan = NULL)
[17:39:26.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.189]                 }
[17:39:26.189]                 ...future.workdir <- getwd()
[17:39:26.189]             }
[17:39:26.189]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.189]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.189]         }
[17:39:26.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.189]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:26.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.189]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.189]             base::names(...future.oldOptions))
[17:39:26.189]     }
[17:39:26.189]     if (FALSE) {
[17:39:26.189]     }
[17:39:26.189]     else {
[17:39:26.189]         if (TRUE) {
[17:39:26.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.189]                 open = "w")
[17:39:26.189]         }
[17:39:26.189]         else {
[17:39:26.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.189]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.189]         }
[17:39:26.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.189]             base::sink(type = "output", split = FALSE)
[17:39:26.189]             base::close(...future.stdout)
[17:39:26.189]         }, add = TRUE)
[17:39:26.189]     }
[17:39:26.189]     ...future.frame <- base::sys.nframe()
[17:39:26.189]     ...future.conditions <- base::list()
[17:39:26.189]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.189]     if (FALSE) {
[17:39:26.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.189]     }
[17:39:26.189]     ...future.result <- base::tryCatch({
[17:39:26.189]         base::withCallingHandlers({
[17:39:26.189]             ...future.value <- base::withVisible(base::local({
[17:39:26.189]                 withCallingHandlers({
[17:39:26.189]                   {
[17:39:26.189]                     do.call(function(...) {
[17:39:26.189]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.189]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.189]                         ...future.globals.maxSize)) {
[17:39:26.189]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.189]                         on.exit(options(oopts), add = TRUE)
[17:39:26.189]                       }
[17:39:26.189]                       {
[17:39:26.189]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.189]                           FUN = function(jj) {
[17:39:26.189]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.189]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.189]                           })
[17:39:26.189]                       }
[17:39:26.189]                     }, args = future.call.arguments)
[17:39:26.189]                   }
[17:39:26.189]                 }, immediateCondition = function(cond) {
[17:39:26.189]                   save_rds <- function (object, pathname, ...) 
[17:39:26.189]                   {
[17:39:26.189]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.189]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.189]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.189]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.189]                         fi_tmp[["mtime"]])
[17:39:26.189]                     }
[17:39:26.189]                     tryCatch({
[17:39:26.189]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.189]                     }, error = function(ex) {
[17:39:26.189]                       msg <- conditionMessage(ex)
[17:39:26.189]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.189]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.189]                         fi_tmp[["mtime"]], msg)
[17:39:26.189]                       ex$message <- msg
[17:39:26.189]                       stop(ex)
[17:39:26.189]                     })
[17:39:26.189]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.189]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.189]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.189]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.189]                       fi <- file.info(pathname)
[17:39:26.189]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.189]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.189]                         fi[["size"]], fi[["mtime"]])
[17:39:26.189]                       stop(msg)
[17:39:26.189]                     }
[17:39:26.189]                     invisible(pathname)
[17:39:26.189]                   }
[17:39:26.189]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.189]                     rootPath = tempdir()) 
[17:39:26.189]                   {
[17:39:26.189]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.189]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.189]                       tmpdir = path, fileext = ".rds")
[17:39:26.189]                     save_rds(obj, file)
[17:39:26.189]                   }
[17:39:26.189]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.189]                   {
[17:39:26.189]                     inherits <- base::inherits
[17:39:26.189]                     invokeRestart <- base::invokeRestart
[17:39:26.189]                     is.null <- base::is.null
[17:39:26.189]                     muffled <- FALSE
[17:39:26.189]                     if (inherits(cond, "message")) {
[17:39:26.189]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.189]                       if (muffled) 
[17:39:26.189]                         invokeRestart("muffleMessage")
[17:39:26.189]                     }
[17:39:26.189]                     else if (inherits(cond, "warning")) {
[17:39:26.189]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.189]                       if (muffled) 
[17:39:26.189]                         invokeRestart("muffleWarning")
[17:39:26.189]                     }
[17:39:26.189]                     else if (inherits(cond, "condition")) {
[17:39:26.189]                       if (!is.null(pattern)) {
[17:39:26.189]                         computeRestarts <- base::computeRestarts
[17:39:26.189]                         grepl <- base::grepl
[17:39:26.189]                         restarts <- computeRestarts(cond)
[17:39:26.189]                         for (restart in restarts) {
[17:39:26.189]                           name <- restart$name
[17:39:26.189]                           if (is.null(name)) 
[17:39:26.189]                             next
[17:39:26.189]                           if (!grepl(pattern, name)) 
[17:39:26.189]                             next
[17:39:26.189]                           invokeRestart(restart)
[17:39:26.189]                           muffled <- TRUE
[17:39:26.189]                           break
[17:39:26.189]                         }
[17:39:26.189]                       }
[17:39:26.189]                     }
[17:39:26.189]                     invisible(muffled)
[17:39:26.189]                   }
[17:39:26.189]                   muffleCondition(cond)
[17:39:26.189]                 })
[17:39:26.189]             }))
[17:39:26.189]             future::FutureResult(value = ...future.value$value, 
[17:39:26.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.189]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.189]                     ...future.globalenv.names))
[17:39:26.189]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.189]         }, condition = base::local({
[17:39:26.189]             c <- base::c
[17:39:26.189]             inherits <- base::inherits
[17:39:26.189]             invokeRestart <- base::invokeRestart
[17:39:26.189]             length <- base::length
[17:39:26.189]             list <- base::list
[17:39:26.189]             seq.int <- base::seq.int
[17:39:26.189]             signalCondition <- base::signalCondition
[17:39:26.189]             sys.calls <- base::sys.calls
[17:39:26.189]             `[[` <- base::`[[`
[17:39:26.189]             `+` <- base::`+`
[17:39:26.189]             `<<-` <- base::`<<-`
[17:39:26.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.189]                   3L)]
[17:39:26.189]             }
[17:39:26.189]             function(cond) {
[17:39:26.189]                 is_error <- inherits(cond, "error")
[17:39:26.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.189]                   NULL)
[17:39:26.189]                 if (is_error) {
[17:39:26.189]                   sessionInformation <- function() {
[17:39:26.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.189]                       search = base::search(), system = base::Sys.info())
[17:39:26.189]                   }
[17:39:26.189]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.189]                     cond$call), session = sessionInformation(), 
[17:39:26.189]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.189]                   signalCondition(cond)
[17:39:26.189]                 }
[17:39:26.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.189]                 "immediateCondition"))) {
[17:39:26.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.189]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.189]                   if (TRUE && !signal) {
[17:39:26.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.189]                     {
[17:39:26.189]                       inherits <- base::inherits
[17:39:26.189]                       invokeRestart <- base::invokeRestart
[17:39:26.189]                       is.null <- base::is.null
[17:39:26.189]                       muffled <- FALSE
[17:39:26.189]                       if (inherits(cond, "message")) {
[17:39:26.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.189]                         if (muffled) 
[17:39:26.189]                           invokeRestart("muffleMessage")
[17:39:26.189]                       }
[17:39:26.189]                       else if (inherits(cond, "warning")) {
[17:39:26.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.189]                         if (muffled) 
[17:39:26.189]                           invokeRestart("muffleWarning")
[17:39:26.189]                       }
[17:39:26.189]                       else if (inherits(cond, "condition")) {
[17:39:26.189]                         if (!is.null(pattern)) {
[17:39:26.189]                           computeRestarts <- base::computeRestarts
[17:39:26.189]                           grepl <- base::grepl
[17:39:26.189]                           restarts <- computeRestarts(cond)
[17:39:26.189]                           for (restart in restarts) {
[17:39:26.189]                             name <- restart$name
[17:39:26.189]                             if (is.null(name)) 
[17:39:26.189]                               next
[17:39:26.189]                             if (!grepl(pattern, name)) 
[17:39:26.189]                               next
[17:39:26.189]                             invokeRestart(restart)
[17:39:26.189]                             muffled <- TRUE
[17:39:26.189]                             break
[17:39:26.189]                           }
[17:39:26.189]                         }
[17:39:26.189]                       }
[17:39:26.189]                       invisible(muffled)
[17:39:26.189]                     }
[17:39:26.189]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.189]                   }
[17:39:26.189]                 }
[17:39:26.189]                 else {
[17:39:26.189]                   if (TRUE) {
[17:39:26.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.189]                     {
[17:39:26.189]                       inherits <- base::inherits
[17:39:26.189]                       invokeRestart <- base::invokeRestart
[17:39:26.189]                       is.null <- base::is.null
[17:39:26.189]                       muffled <- FALSE
[17:39:26.189]                       if (inherits(cond, "message")) {
[17:39:26.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.189]                         if (muffled) 
[17:39:26.189]                           invokeRestart("muffleMessage")
[17:39:26.189]                       }
[17:39:26.189]                       else if (inherits(cond, "warning")) {
[17:39:26.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.189]                         if (muffled) 
[17:39:26.189]                           invokeRestart("muffleWarning")
[17:39:26.189]                       }
[17:39:26.189]                       else if (inherits(cond, "condition")) {
[17:39:26.189]                         if (!is.null(pattern)) {
[17:39:26.189]                           computeRestarts <- base::computeRestarts
[17:39:26.189]                           grepl <- base::grepl
[17:39:26.189]                           restarts <- computeRestarts(cond)
[17:39:26.189]                           for (restart in restarts) {
[17:39:26.189]                             name <- restart$name
[17:39:26.189]                             if (is.null(name)) 
[17:39:26.189]                               next
[17:39:26.189]                             if (!grepl(pattern, name)) 
[17:39:26.189]                               next
[17:39:26.189]                             invokeRestart(restart)
[17:39:26.189]                             muffled <- TRUE
[17:39:26.189]                             break
[17:39:26.189]                           }
[17:39:26.189]                         }
[17:39:26.189]                       }
[17:39:26.189]                       invisible(muffled)
[17:39:26.189]                     }
[17:39:26.189]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.189]                   }
[17:39:26.189]                 }
[17:39:26.189]             }
[17:39:26.189]         }))
[17:39:26.189]     }, error = function(ex) {
[17:39:26.189]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.189]                 ...future.rng), started = ...future.startTime, 
[17:39:26.189]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.189]             version = "1.8"), class = "FutureResult")
[17:39:26.189]     }, finally = {
[17:39:26.189]         if (!identical(...future.workdir, getwd())) 
[17:39:26.189]             setwd(...future.workdir)
[17:39:26.189]         {
[17:39:26.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.189]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.189]             }
[17:39:26.189]             base::options(...future.oldOptions)
[17:39:26.189]             if (.Platform$OS.type == "windows") {
[17:39:26.189]                 old_names <- names(...future.oldEnvVars)
[17:39:26.189]                 envs <- base::Sys.getenv()
[17:39:26.189]                 names <- names(envs)
[17:39:26.189]                 common <- intersect(names, old_names)
[17:39:26.189]                 added <- setdiff(names, old_names)
[17:39:26.189]                 removed <- setdiff(old_names, names)
[17:39:26.189]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.189]                   envs[common]]
[17:39:26.189]                 NAMES <- toupper(changed)
[17:39:26.189]                 args <- list()
[17:39:26.189]                 for (kk in seq_along(NAMES)) {
[17:39:26.189]                   name <- changed[[kk]]
[17:39:26.189]                   NAME <- NAMES[[kk]]
[17:39:26.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.189]                     next
[17:39:26.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.189]                 }
[17:39:26.189]                 NAMES <- toupper(added)
[17:39:26.189]                 for (kk in seq_along(NAMES)) {
[17:39:26.189]                   name <- added[[kk]]
[17:39:26.189]                   NAME <- NAMES[[kk]]
[17:39:26.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.189]                     next
[17:39:26.189]                   args[[name]] <- ""
[17:39:26.189]                 }
[17:39:26.189]                 NAMES <- toupper(removed)
[17:39:26.189]                 for (kk in seq_along(NAMES)) {
[17:39:26.189]                   name <- removed[[kk]]
[17:39:26.189]                   NAME <- NAMES[[kk]]
[17:39:26.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.189]                     next
[17:39:26.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.189]                 }
[17:39:26.189]                 if (length(args) > 0) 
[17:39:26.189]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.189]             }
[17:39:26.189]             else {
[17:39:26.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.189]             }
[17:39:26.189]             {
[17:39:26.189]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.189]                   0L) {
[17:39:26.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.189]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.189]                   base::options(opts)
[17:39:26.189]                 }
[17:39:26.189]                 {
[17:39:26.189]                   {
[17:39:26.189]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.189]                     NULL
[17:39:26.189]                   }
[17:39:26.189]                   options(future.plan = NULL)
[17:39:26.189]                   if (is.na(NA_character_)) 
[17:39:26.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.189]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.189]                     envir = parent.frame()) 
[17:39:26.189]                   {
[17:39:26.189]                     default_workers <- missing(workers)
[17:39:26.189]                     if (is.function(workers)) 
[17:39:26.189]                       workers <- workers()
[17:39:26.189]                     workers <- structure(as.integer(workers), 
[17:39:26.189]                       class = class(workers))
[17:39:26.189]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.189]                       1L)
[17:39:26.189]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.189]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.189]                       if (default_workers) 
[17:39:26.189]                         supportsMulticore(warn = TRUE)
[17:39:26.189]                       return(sequential(..., envir = envir))
[17:39:26.189]                     }
[17:39:26.189]                     oopts <- options(mc.cores = workers)
[17:39:26.189]                     on.exit(options(oopts))
[17:39:26.189]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.189]                       envir = envir)
[17:39:26.189]                     if (!future$lazy) 
[17:39:26.189]                       future <- run(future)
[17:39:26.189]                     invisible(future)
[17:39:26.189]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.189]                 }
[17:39:26.189]             }
[17:39:26.189]         }
[17:39:26.189]     })
[17:39:26.189]     if (TRUE) {
[17:39:26.189]         base::sink(type = "output", split = FALSE)
[17:39:26.189]         if (TRUE) {
[17:39:26.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.189]         }
[17:39:26.189]         else {
[17:39:26.189]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.189]         }
[17:39:26.189]         base::close(...future.stdout)
[17:39:26.189]         ...future.stdout <- NULL
[17:39:26.189]     }
[17:39:26.189]     ...future.result$conditions <- ...future.conditions
[17:39:26.189]     ...future.result$finished <- base::Sys.time()
[17:39:26.189]     ...future.result
[17:39:26.189] }
[17:39:26.192] assign_globals() ...
[17:39:26.192] List of 5
[17:39:26.192]  $ ...future.FUN            :function (object, ...)  
[17:39:26.192]  $ future.call.arguments    :List of 1
[17:39:26.192]   ..$ digits: int 2
[17:39:26.192]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.192]  $ ...future.elements_ii    :List of 3
[17:39:26.192]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:39:26.192]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:39:26.192]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:39:26.192]  $ ...future.seeds_ii       : NULL
[17:39:26.192]  $ ...future.globals.maxSize: NULL
[17:39:26.192]  - attr(*, "resolved")= logi FALSE
[17:39:26.192]  - attr(*, "total_size")= num 1296
[17:39:26.192]  - attr(*, "where")=List of 5
[17:39:26.192]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.192]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.192]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.192]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.192]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.192]  - attr(*, "already-done")= logi TRUE
[17:39:26.200] - copied ‘...future.FUN’ to environment
[17:39:26.200] - copied ‘future.call.arguments’ to environment
[17:39:26.200] - copied ‘...future.elements_ii’ to environment
[17:39:26.200] - copied ‘...future.seeds_ii’ to environment
[17:39:26.200] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.200] assign_globals() ... done
[17:39:26.200] requestCore(): workers = 2
[17:39:26.203] MulticoreFuture started
[17:39:26.203] - Launch lazy future ... done
[17:39:26.203] run() for ‘MulticoreFuture’ ... done
[17:39:26.204] Created future:
[17:39:26.204] plan(): Setting new future strategy stack:
[17:39:26.204] List of future strategies:
[17:39:26.204] 1. sequential:
[17:39:26.204]    - args: function (..., envir = parent.frame())
[17:39:26.204]    - tweaked: FALSE
[17:39:26.204]    - call: NULL
[17:39:26.205] plan(): nbrOfWorkers() = 1
[17:39:26.212] plan(): Setting new future strategy stack:
[17:39:26.213] List of future strategies:
[17:39:26.213] 1. multicore:
[17:39:26.213]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.213]    - tweaked: FALSE
[17:39:26.213]    - call: plan(strategy)
[17:39:26.219] plan(): nbrOfWorkers() = 2
[17:39:26.204] MulticoreFuture:
[17:39:26.204] Label: ‘future_by-2’
[17:39:26.204] Expression:
[17:39:26.204] {
[17:39:26.204]     do.call(function(...) {
[17:39:26.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.204]             on.exit(options(oopts), add = TRUE)
[17:39:26.204]         }
[17:39:26.204]         {
[17:39:26.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.204]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.204]             })
[17:39:26.204]         }
[17:39:26.204]     }, args = future.call.arguments)
[17:39:26.204] }
[17:39:26.204] Lazy evaluation: FALSE
[17:39:26.204] Asynchronous evaluation: TRUE
[17:39:26.204] Local evaluation: TRUE
[17:39:26.204] Environment: R_GlobalEnv
[17:39:26.204] Capture standard output: TRUE
[17:39:26.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.204] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.204] Packages: <none>
[17:39:26.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.204] Resolved: TRUE
[17:39:26.204] Value: <not collected>
[17:39:26.204] Conditions captured: <none>
[17:39:26.204] Early signaling: FALSE
[17:39:26.204] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.204] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.220] Chunk #2 of 2 ... DONE
[17:39:26.220] Launching 2 futures (chunks) ... DONE
[17:39:26.221] Resolving 2 futures (chunks) ...
[17:39:26.221] resolve() on list ...
[17:39:26.221]  recursive: 0
[17:39:26.221]  length: 2
[17:39:26.222] 
[17:39:26.222] Future #1
[17:39:26.223] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:26.223] - nx: 2
[17:39:26.223] - relay: TRUE
[17:39:26.224] - stdout: TRUE
[17:39:26.224] - signal: TRUE
[17:39:26.224] - resignal: FALSE
[17:39:26.224] - force: TRUE
[17:39:26.224] - relayed: [n=2] FALSE, FALSE
[17:39:26.225] - queued futures: [n=2] FALSE, FALSE
[17:39:26.225]  - until=1
[17:39:26.225]  - relaying element #1
[17:39:26.225] - relayed: [n=2] TRUE, FALSE
[17:39:26.226] - queued futures: [n=2] TRUE, FALSE
[17:39:26.226] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:26.226]  length: 1 (resolved future 1)
[17:39:26.227] Future #2
[17:39:26.228] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:26.228] - nx: 2
[17:39:26.228] - relay: TRUE
[17:39:26.228] - stdout: TRUE
[17:39:26.229] - signal: TRUE
[17:39:26.229] - resignal: FALSE
[17:39:26.229] - force: TRUE
[17:39:26.229] - relayed: [n=2] TRUE, FALSE
[17:39:26.229] - queued futures: [n=2] TRUE, FALSE
[17:39:26.229]  - until=2
[17:39:26.229]  - relaying element #2
[17:39:26.230] - relayed: [n=2] TRUE, TRUE
[17:39:26.230] - queued futures: [n=2] TRUE, TRUE
[17:39:26.230] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:26.230]  length: 0 (resolved future 2)
[17:39:26.230] Relaying remaining futures
[17:39:26.231] signalConditionsASAP(NULL, pos=0) ...
[17:39:26.231] - nx: 2
[17:39:26.231] - relay: TRUE
[17:39:26.231] - stdout: TRUE
[17:39:26.231] - signal: TRUE
[17:39:26.231] - resignal: FALSE
[17:39:26.231] - force: TRUE
[17:39:26.231] - relayed: [n=2] TRUE, TRUE
[17:39:26.231] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:26.232] - relayed: [n=2] TRUE, TRUE
[17:39:26.232] - queued futures: [n=2] TRUE, TRUE
[17:39:26.232] signalConditionsASAP(NULL, pos=0) ... done
[17:39:26.232] resolve() on list ... DONE
[17:39:26.232]  - Number of value chunks collected: 2
[17:39:26.232] Resolving 2 futures (chunks) ... DONE
[17:39:26.232] Reducing values from 2 chunks ...
[17:39:26.233]  - Number of values collected after concatenation: 6
[17:39:26.233]  - Number of values expected: 6
[17:39:26.233] Reducing values from 2 chunks ... DONE
[17:39:26.233] future_lapply() ... DONE
[17:39:26.233] future_by_internal() ... DONE
[17:39:26.234] future_by_internal() ...
[17:39:26.235] future_lapply() ...
[17:39:26.240] Number of chunks: 2
[17:39:26.240] getGlobalsAndPackagesXApply() ...
[17:39:26.241]  - future.globals: TRUE
[17:39:26.241] getGlobalsAndPackages() ...
[17:39:26.241] Searching for globals...
[17:39:26.243] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:26.243] Searching for globals ... DONE
[17:39:26.243] Resolving globals: FALSE
[17:39:26.244] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:39:26.244] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:39:26.244] - globals: [1] ‘FUN’
[17:39:26.244] - packages: [1] ‘stats’
[17:39:26.244] getGlobalsAndPackages() ... DONE
[17:39:26.244]  - globals found/used: [n=1] ‘FUN’
[17:39:26.245]  - needed namespaces: [n=1] ‘stats’
[17:39:26.245] Finding globals ... DONE
[17:39:26.245]  - use_args: TRUE
[17:39:26.245]  - Getting '...' globals ...
[17:39:26.245] resolve() on list ...
[17:39:26.245]  recursive: 0
[17:39:26.245]  length: 1
[17:39:26.246]  elements: ‘...’
[17:39:26.246]  length: 0 (resolved future 1)
[17:39:26.246] resolve() on list ... DONE
[17:39:26.246]    - '...' content: [n=1] ‘singular.ok’
[17:39:26.246] List of 1
[17:39:26.246]  $ ...:List of 1
[17:39:26.246]   ..$ singular.ok: logi FALSE
[17:39:26.246]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.246]  - attr(*, "where")=List of 1
[17:39:26.246]   ..$ ...:<environment: 0x56296e9593c8> 
[17:39:26.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.246]  - attr(*, "resolved")= logi TRUE
[17:39:26.246]  - attr(*, "total_size")= num NA
[17:39:26.253]  - Getting '...' globals ... DONE
[17:39:26.253] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:26.253] List of 2
[17:39:26.253]  $ ...future.FUN:function (x, ...)  
[17:39:26.253]  $ ...          :List of 1
[17:39:26.253]   ..$ singular.ok: logi FALSE
[17:39:26.253]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.253]  - attr(*, "where")=List of 2
[17:39:26.253]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:26.253]   ..$ ...          :<environment: 0x56296e9593c8> 
[17:39:26.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.253]  - attr(*, "resolved")= logi FALSE
[17:39:26.253]  - attr(*, "total_size")= num 5384
[17:39:26.257] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:26.257] getGlobalsAndPackagesXApply() ... DONE
[17:39:26.257] Number of futures (= number of chunks): 2
[17:39:26.257] Launching 2 futures (chunks) ...
[17:39:26.257] Chunk #1 of 2 ...
[17:39:26.258]  - Finding globals in 'X' for chunk #1 ...
[17:39:26.258] getGlobalsAndPackages() ...
[17:39:26.258] Searching for globals...
[17:39:26.258] 
[17:39:26.258] Searching for globals ... DONE
[17:39:26.258] - globals: [0] <none>
[17:39:26.258] getGlobalsAndPackages() ... DONE
[17:39:26.259]    + additional globals found: [n=0] 
[17:39:26.259]    + additional namespaces needed: [n=0] 
[17:39:26.259]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:26.259]  - seeds: <none>
[17:39:26.259] getGlobalsAndPackages() ...
[17:39:26.259] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.259] Resolving globals: FALSE
[17:39:26.259] Tweak future expression to call with '...' arguments ...
[17:39:26.259] {
[17:39:26.259]     do.call(function(...) {
[17:39:26.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.259]             on.exit(options(oopts), add = TRUE)
[17:39:26.259]         }
[17:39:26.259]         {
[17:39:26.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.259]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.259]             })
[17:39:26.259]         }
[17:39:26.259]     }, args = future.call.arguments)
[17:39:26.259] }
[17:39:26.260] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.260] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.260] 
[17:39:26.260] getGlobalsAndPackages() ... DONE
[17:39:26.261] run() for ‘Future’ ...
[17:39:26.261] - state: ‘created’
[17:39:26.261] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.265] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.265] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.265]   - Field: ‘label’
[17:39:26.265]   - Field: ‘local’
[17:39:26.265]   - Field: ‘owner’
[17:39:26.265]   - Field: ‘envir’
[17:39:26.265]   - Field: ‘workers’
[17:39:26.266]   - Field: ‘packages’
[17:39:26.266]   - Field: ‘gc’
[17:39:26.266]   - Field: ‘job’
[17:39:26.266]   - Field: ‘conditions’
[17:39:26.266]   - Field: ‘expr’
[17:39:26.266]   - Field: ‘uuid’
[17:39:26.266]   - Field: ‘seed’
[17:39:26.266]   - Field: ‘version’
[17:39:26.266]   - Field: ‘result’
[17:39:26.266]   - Field: ‘asynchronous’
[17:39:26.267]   - Field: ‘calls’
[17:39:26.267]   - Field: ‘globals’
[17:39:26.267]   - Field: ‘stdout’
[17:39:26.267]   - Field: ‘earlySignal’
[17:39:26.267]   - Field: ‘lazy’
[17:39:26.267]   - Field: ‘state’
[17:39:26.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.267] - Launch lazy future ...
[17:39:26.268] Packages needed by the future expression (n = 1): ‘stats’
[17:39:26.268] Packages needed by future strategies (n = 0): <none>
[17:39:26.268] {
[17:39:26.268]     {
[17:39:26.268]         {
[17:39:26.268]             ...future.startTime <- base::Sys.time()
[17:39:26.268]             {
[17:39:26.268]                 {
[17:39:26.268]                   {
[17:39:26.268]                     {
[17:39:26.268]                       {
[17:39:26.268]                         base::local({
[17:39:26.268]                           has_future <- base::requireNamespace("future", 
[17:39:26.268]                             quietly = TRUE)
[17:39:26.268]                           if (has_future) {
[17:39:26.268]                             ns <- base::getNamespace("future")
[17:39:26.268]                             version <- ns[[".package"]][["version"]]
[17:39:26.268]                             if (is.null(version)) 
[17:39:26.268]                               version <- utils::packageVersion("future")
[17:39:26.268]                           }
[17:39:26.268]                           else {
[17:39:26.268]                             version <- NULL
[17:39:26.268]                           }
[17:39:26.268]                           if (!has_future || version < "1.8.0") {
[17:39:26.268]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.268]                               "", base::R.version$version.string), 
[17:39:26.268]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:26.268]                                 base::R.version$platform, 8 * 
[17:39:26.268]                                   base::.Machine$sizeof.pointer), 
[17:39:26.268]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.268]                                 "release", "version")], collapse = " "), 
[17:39:26.268]                               hostname = base::Sys.info()[["nodename"]])
[17:39:26.268]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.268]                               info)
[17:39:26.268]                             info <- base::paste(info, collapse = "; ")
[17:39:26.268]                             if (!has_future) {
[17:39:26.268]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.268]                                 info)
[17:39:26.268]                             }
[17:39:26.268]                             else {
[17:39:26.268]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.268]                                 info, version)
[17:39:26.268]                             }
[17:39:26.268]                             base::stop(msg)
[17:39:26.268]                           }
[17:39:26.268]                         })
[17:39:26.268]                       }
[17:39:26.268]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.268]                       base::options(mc.cores = 1L)
[17:39:26.268]                     }
[17:39:26.268]                     base::local({
[17:39:26.268]                       for (pkg in "stats") {
[17:39:26.268]                         base::loadNamespace(pkg)
[17:39:26.268]                         base::library(pkg, character.only = TRUE)
[17:39:26.268]                       }
[17:39:26.268]                     })
[17:39:26.268]                   }
[17:39:26.268]                   options(future.plan = NULL)
[17:39:26.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.268]                 }
[17:39:26.268]                 ...future.workdir <- getwd()
[17:39:26.268]             }
[17:39:26.268]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.268]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.268]         }
[17:39:26.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.268]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:26.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.268]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.268]             base::names(...future.oldOptions))
[17:39:26.268]     }
[17:39:26.268]     if (FALSE) {
[17:39:26.268]     }
[17:39:26.268]     else {
[17:39:26.268]         if (TRUE) {
[17:39:26.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.268]                 open = "w")
[17:39:26.268]         }
[17:39:26.268]         else {
[17:39:26.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.268]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.268]         }
[17:39:26.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.268]             base::sink(type = "output", split = FALSE)
[17:39:26.268]             base::close(...future.stdout)
[17:39:26.268]         }, add = TRUE)
[17:39:26.268]     }
[17:39:26.268]     ...future.frame <- base::sys.nframe()
[17:39:26.268]     ...future.conditions <- base::list()
[17:39:26.268]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.268]     if (FALSE) {
[17:39:26.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.268]     }
[17:39:26.268]     ...future.result <- base::tryCatch({
[17:39:26.268]         base::withCallingHandlers({
[17:39:26.268]             ...future.value <- base::withVisible(base::local({
[17:39:26.268]                 withCallingHandlers({
[17:39:26.268]                   {
[17:39:26.268]                     do.call(function(...) {
[17:39:26.268]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.268]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.268]                         ...future.globals.maxSize)) {
[17:39:26.268]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.268]                         on.exit(options(oopts), add = TRUE)
[17:39:26.268]                       }
[17:39:26.268]                       {
[17:39:26.268]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.268]                           FUN = function(jj) {
[17:39:26.268]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.268]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.268]                           })
[17:39:26.268]                       }
[17:39:26.268]                     }, args = future.call.arguments)
[17:39:26.268]                   }
[17:39:26.268]                 }, immediateCondition = function(cond) {
[17:39:26.268]                   save_rds <- function (object, pathname, ...) 
[17:39:26.268]                   {
[17:39:26.268]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.268]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.268]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.268]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.268]                         fi_tmp[["mtime"]])
[17:39:26.268]                     }
[17:39:26.268]                     tryCatch({
[17:39:26.268]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.268]                     }, error = function(ex) {
[17:39:26.268]                       msg <- conditionMessage(ex)
[17:39:26.268]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.268]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.268]                         fi_tmp[["mtime"]], msg)
[17:39:26.268]                       ex$message <- msg
[17:39:26.268]                       stop(ex)
[17:39:26.268]                     })
[17:39:26.268]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.268]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.268]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.268]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.268]                       fi <- file.info(pathname)
[17:39:26.268]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.268]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.268]                         fi[["size"]], fi[["mtime"]])
[17:39:26.268]                       stop(msg)
[17:39:26.268]                     }
[17:39:26.268]                     invisible(pathname)
[17:39:26.268]                   }
[17:39:26.268]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.268]                     rootPath = tempdir()) 
[17:39:26.268]                   {
[17:39:26.268]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.268]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.268]                       tmpdir = path, fileext = ".rds")
[17:39:26.268]                     save_rds(obj, file)
[17:39:26.268]                   }
[17:39:26.268]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.268]                   {
[17:39:26.268]                     inherits <- base::inherits
[17:39:26.268]                     invokeRestart <- base::invokeRestart
[17:39:26.268]                     is.null <- base::is.null
[17:39:26.268]                     muffled <- FALSE
[17:39:26.268]                     if (inherits(cond, "message")) {
[17:39:26.268]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.268]                       if (muffled) 
[17:39:26.268]                         invokeRestart("muffleMessage")
[17:39:26.268]                     }
[17:39:26.268]                     else if (inherits(cond, "warning")) {
[17:39:26.268]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.268]                       if (muffled) 
[17:39:26.268]                         invokeRestart("muffleWarning")
[17:39:26.268]                     }
[17:39:26.268]                     else if (inherits(cond, "condition")) {
[17:39:26.268]                       if (!is.null(pattern)) {
[17:39:26.268]                         computeRestarts <- base::computeRestarts
[17:39:26.268]                         grepl <- base::grepl
[17:39:26.268]                         restarts <- computeRestarts(cond)
[17:39:26.268]                         for (restart in restarts) {
[17:39:26.268]                           name <- restart$name
[17:39:26.268]                           if (is.null(name)) 
[17:39:26.268]                             next
[17:39:26.268]                           if (!grepl(pattern, name)) 
[17:39:26.268]                             next
[17:39:26.268]                           invokeRestart(restart)
[17:39:26.268]                           muffled <- TRUE
[17:39:26.268]                           break
[17:39:26.268]                         }
[17:39:26.268]                       }
[17:39:26.268]                     }
[17:39:26.268]                     invisible(muffled)
[17:39:26.268]                   }
[17:39:26.268]                   muffleCondition(cond)
[17:39:26.268]                 })
[17:39:26.268]             }))
[17:39:26.268]             future::FutureResult(value = ...future.value$value, 
[17:39:26.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.268]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.268]                     ...future.globalenv.names))
[17:39:26.268]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.268]         }, condition = base::local({
[17:39:26.268]             c <- base::c
[17:39:26.268]             inherits <- base::inherits
[17:39:26.268]             invokeRestart <- base::invokeRestart
[17:39:26.268]             length <- base::length
[17:39:26.268]             list <- base::list
[17:39:26.268]             seq.int <- base::seq.int
[17:39:26.268]             signalCondition <- base::signalCondition
[17:39:26.268]             sys.calls <- base::sys.calls
[17:39:26.268]             `[[` <- base::`[[`
[17:39:26.268]             `+` <- base::`+`
[17:39:26.268]             `<<-` <- base::`<<-`
[17:39:26.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.268]                   3L)]
[17:39:26.268]             }
[17:39:26.268]             function(cond) {
[17:39:26.268]                 is_error <- inherits(cond, "error")
[17:39:26.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.268]                   NULL)
[17:39:26.268]                 if (is_error) {
[17:39:26.268]                   sessionInformation <- function() {
[17:39:26.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.268]                       search = base::search(), system = base::Sys.info())
[17:39:26.268]                   }
[17:39:26.268]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.268]                     cond$call), session = sessionInformation(), 
[17:39:26.268]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.268]                   signalCondition(cond)
[17:39:26.268]                 }
[17:39:26.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.268]                 "immediateCondition"))) {
[17:39:26.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.268]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.268]                   if (TRUE && !signal) {
[17:39:26.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.268]                     {
[17:39:26.268]                       inherits <- base::inherits
[17:39:26.268]                       invokeRestart <- base::invokeRestart
[17:39:26.268]                       is.null <- base::is.null
[17:39:26.268]                       muffled <- FALSE
[17:39:26.268]                       if (inherits(cond, "message")) {
[17:39:26.268]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.268]                         if (muffled) 
[17:39:26.268]                           invokeRestart("muffleMessage")
[17:39:26.268]                       }
[17:39:26.268]                       else if (inherits(cond, "warning")) {
[17:39:26.268]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.268]                         if (muffled) 
[17:39:26.268]                           invokeRestart("muffleWarning")
[17:39:26.268]                       }
[17:39:26.268]                       else if (inherits(cond, "condition")) {
[17:39:26.268]                         if (!is.null(pattern)) {
[17:39:26.268]                           computeRestarts <- base::computeRestarts
[17:39:26.268]                           grepl <- base::grepl
[17:39:26.268]                           restarts <- computeRestarts(cond)
[17:39:26.268]                           for (restart in restarts) {
[17:39:26.268]                             name <- restart$name
[17:39:26.268]                             if (is.null(name)) 
[17:39:26.268]                               next
[17:39:26.268]                             if (!grepl(pattern, name)) 
[17:39:26.268]                               next
[17:39:26.268]                             invokeRestart(restart)
[17:39:26.268]                             muffled <- TRUE
[17:39:26.268]                             break
[17:39:26.268]                           }
[17:39:26.268]                         }
[17:39:26.268]                       }
[17:39:26.268]                       invisible(muffled)
[17:39:26.268]                     }
[17:39:26.268]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.268]                   }
[17:39:26.268]                 }
[17:39:26.268]                 else {
[17:39:26.268]                   if (TRUE) {
[17:39:26.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.268]                     {
[17:39:26.268]                       inherits <- base::inherits
[17:39:26.268]                       invokeRestart <- base::invokeRestart
[17:39:26.268]                       is.null <- base::is.null
[17:39:26.268]                       muffled <- FALSE
[17:39:26.268]                       if (inherits(cond, "message")) {
[17:39:26.268]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.268]                         if (muffled) 
[17:39:26.268]                           invokeRestart("muffleMessage")
[17:39:26.268]                       }
[17:39:26.268]                       else if (inherits(cond, "warning")) {
[17:39:26.268]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.268]                         if (muffled) 
[17:39:26.268]                           invokeRestart("muffleWarning")
[17:39:26.268]                       }
[17:39:26.268]                       else if (inherits(cond, "condition")) {
[17:39:26.268]                         if (!is.null(pattern)) {
[17:39:26.268]                           computeRestarts <- base::computeRestarts
[17:39:26.268]                           grepl <- base::grepl
[17:39:26.268]                           restarts <- computeRestarts(cond)
[17:39:26.268]                           for (restart in restarts) {
[17:39:26.268]                             name <- restart$name
[17:39:26.268]                             if (is.null(name)) 
[17:39:26.268]                               next
[17:39:26.268]                             if (!grepl(pattern, name)) 
[17:39:26.268]                               next
[17:39:26.268]                             invokeRestart(restart)
[17:39:26.268]                             muffled <- TRUE
[17:39:26.268]                             break
[17:39:26.268]                           }
[17:39:26.268]                         }
[17:39:26.268]                       }
[17:39:26.268]                       invisible(muffled)
[17:39:26.268]                     }
[17:39:26.268]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.268]                   }
[17:39:26.268]                 }
[17:39:26.268]             }
[17:39:26.268]         }))
[17:39:26.268]     }, error = function(ex) {
[17:39:26.268]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.268]                 ...future.rng), started = ...future.startTime, 
[17:39:26.268]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.268]             version = "1.8"), class = "FutureResult")
[17:39:26.268]     }, finally = {
[17:39:26.268]         if (!identical(...future.workdir, getwd())) 
[17:39:26.268]             setwd(...future.workdir)
[17:39:26.268]         {
[17:39:26.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.268]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.268]             }
[17:39:26.268]             base::options(...future.oldOptions)
[17:39:26.268]             if (.Platform$OS.type == "windows") {
[17:39:26.268]                 old_names <- names(...future.oldEnvVars)
[17:39:26.268]                 envs <- base::Sys.getenv()
[17:39:26.268]                 names <- names(envs)
[17:39:26.268]                 common <- intersect(names, old_names)
[17:39:26.268]                 added <- setdiff(names, old_names)
[17:39:26.268]                 removed <- setdiff(old_names, names)
[17:39:26.268]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.268]                   envs[common]]
[17:39:26.268]                 NAMES <- toupper(changed)
[17:39:26.268]                 args <- list()
[17:39:26.268]                 for (kk in seq_along(NAMES)) {
[17:39:26.268]                   name <- changed[[kk]]
[17:39:26.268]                   NAME <- NAMES[[kk]]
[17:39:26.268]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.268]                     next
[17:39:26.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.268]                 }
[17:39:26.268]                 NAMES <- toupper(added)
[17:39:26.268]                 for (kk in seq_along(NAMES)) {
[17:39:26.268]                   name <- added[[kk]]
[17:39:26.268]                   NAME <- NAMES[[kk]]
[17:39:26.268]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.268]                     next
[17:39:26.268]                   args[[name]] <- ""
[17:39:26.268]                 }
[17:39:26.268]                 NAMES <- toupper(removed)
[17:39:26.268]                 for (kk in seq_along(NAMES)) {
[17:39:26.268]                   name <- removed[[kk]]
[17:39:26.268]                   NAME <- NAMES[[kk]]
[17:39:26.268]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.268]                     next
[17:39:26.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.268]                 }
[17:39:26.268]                 if (length(args) > 0) 
[17:39:26.268]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.268]             }
[17:39:26.268]             else {
[17:39:26.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.268]             }
[17:39:26.268]             {
[17:39:26.268]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.268]                   0L) {
[17:39:26.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.268]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.268]                   base::options(opts)
[17:39:26.268]                 }
[17:39:26.268]                 {
[17:39:26.268]                   {
[17:39:26.268]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.268]                     NULL
[17:39:26.268]                   }
[17:39:26.268]                   options(future.plan = NULL)
[17:39:26.268]                   if (is.na(NA_character_)) 
[17:39:26.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.268]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.268]                     envir = parent.frame()) 
[17:39:26.268]                   {
[17:39:26.268]                     default_workers <- missing(workers)
[17:39:26.268]                     if (is.function(workers)) 
[17:39:26.268]                       workers <- workers()
[17:39:26.268]                     workers <- structure(as.integer(workers), 
[17:39:26.268]                       class = class(workers))
[17:39:26.268]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.268]                       1L)
[17:39:26.268]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.268]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.268]                       if (default_workers) 
[17:39:26.268]                         supportsMulticore(warn = TRUE)
[17:39:26.268]                       return(sequential(..., envir = envir))
[17:39:26.268]                     }
[17:39:26.268]                     oopts <- options(mc.cores = workers)
[17:39:26.268]                     on.exit(options(oopts))
[17:39:26.268]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.268]                       envir = envir)
[17:39:26.268]                     if (!future$lazy) 
[17:39:26.268]                       future <- run(future)
[17:39:26.268]                     invisible(future)
[17:39:26.268]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.268]                 }
[17:39:26.268]             }
[17:39:26.268]         }
[17:39:26.268]     })
[17:39:26.268]     if (TRUE) {
[17:39:26.268]         base::sink(type = "output", split = FALSE)
[17:39:26.268]         if (TRUE) {
[17:39:26.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.268]         }
[17:39:26.268]         else {
[17:39:26.268]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.268]         }
[17:39:26.268]         base::close(...future.stdout)
[17:39:26.268]         ...future.stdout <- NULL
[17:39:26.268]     }
[17:39:26.268]     ...future.result$conditions <- ...future.conditions
[17:39:26.268]     ...future.result$finished <- base::Sys.time()
[17:39:26.268]     ...future.result
[17:39:26.268] }
[17:39:26.271] assign_globals() ...
[17:39:26.271] List of 5
[17:39:26.271]  $ ...future.FUN            :function (x, ...)  
[17:39:26.271]  $ future.call.arguments    :List of 1
[17:39:26.271]   ..$ singular.ok: logi FALSE
[17:39:26.271]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.271]  $ ...future.elements_ii    :List of 1
[17:39:26.271]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.271]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:26.271]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.271]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:26.271]  $ ...future.seeds_ii       : NULL
[17:39:26.271]  $ ...future.globals.maxSize: NULL
[17:39:26.271]  - attr(*, "where")=List of 5
[17:39:26.271]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.271]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.271]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.271]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.271]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.271]  - attr(*, "resolved")= logi FALSE
[17:39:26.271]  - attr(*, "total_size")= num 5384
[17:39:26.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.271]  - attr(*, "already-done")= logi TRUE
[17:39:26.280] - reassign environment for ‘...future.FUN’
[17:39:26.280] - copied ‘...future.FUN’ to environment
[17:39:26.280] - copied ‘future.call.arguments’ to environment
[17:39:26.281] - copied ‘...future.elements_ii’ to environment
[17:39:26.281] - copied ‘...future.seeds_ii’ to environment
[17:39:26.281] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.281] assign_globals() ... done
[17:39:26.281] requestCore(): workers = 2
[17:39:26.284] MulticoreFuture started
[17:39:26.284] - Launch lazy future ... done
[17:39:26.285] run() for ‘MulticoreFuture’ ... done
[17:39:26.285] Created future:
[17:39:26.285] plan(): Setting new future strategy stack:
[17:39:26.286] List of future strategies:
[17:39:26.286] 1. sequential:
[17:39:26.286]    - args: function (..., envir = parent.frame())
[17:39:26.286]    - tweaked: FALSE
[17:39:26.286]    - call: NULL
[17:39:26.287] plan(): nbrOfWorkers() = 1
[17:39:26.292] plan(): Setting new future strategy stack:
[17:39:26.292] List of future strategies:
[17:39:26.292] 1. multicore:
[17:39:26.292]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.292]    - tweaked: FALSE
[17:39:26.292]    - call: plan(strategy)
[17:39:26.298] plan(): nbrOfWorkers() = 2
[17:39:26.286] MulticoreFuture:
[17:39:26.286] Label: ‘future_by-1’
[17:39:26.286] Expression:
[17:39:26.286] {
[17:39:26.286]     do.call(function(...) {
[17:39:26.286]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.286]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.286]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.286]             on.exit(options(oopts), add = TRUE)
[17:39:26.286]         }
[17:39:26.286]         {
[17:39:26.286]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.286]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.286]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.286]             })
[17:39:26.286]         }
[17:39:26.286]     }, args = future.call.arguments)
[17:39:26.286] }
[17:39:26.286] Lazy evaluation: FALSE
[17:39:26.286] Asynchronous evaluation: TRUE
[17:39:26.286] Local evaluation: TRUE
[17:39:26.286] Environment: R_GlobalEnv
[17:39:26.286] Capture standard output: TRUE
[17:39:26.286] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.286] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.286] Packages: 1 packages (‘stats’)
[17:39:26.286] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.286] Resolved: TRUE
[17:39:26.286] Value: <not collected>
[17:39:26.286] Conditions captured: <none>
[17:39:26.286] Early signaling: FALSE
[17:39:26.286] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.286] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.300] Chunk #1 of 2 ... DONE
[17:39:26.300] Chunk #2 of 2 ...
[17:39:26.300]  - Finding globals in 'X' for chunk #2 ...
[17:39:26.300] getGlobalsAndPackages() ...
[17:39:26.301] Searching for globals...
[17:39:26.301] 
[17:39:26.301] Searching for globals ... DONE
[17:39:26.302] - globals: [0] <none>
[17:39:26.302] getGlobalsAndPackages() ... DONE
[17:39:26.302]    + additional globals found: [n=0] 
[17:39:26.302]    + additional namespaces needed: [n=0] 
[17:39:26.302]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:26.302]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:26.302]  - seeds: <none>
[17:39:26.303] getGlobalsAndPackages() ...
[17:39:26.303] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.303] Resolving globals: FALSE
[17:39:26.303] Tweak future expression to call with '...' arguments ...
[17:39:26.303] {
[17:39:26.303]     do.call(function(...) {
[17:39:26.303]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.303]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.303]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.303]             on.exit(options(oopts), add = TRUE)
[17:39:26.303]         }
[17:39:26.303]         {
[17:39:26.303]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.303]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.303]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.303]             })
[17:39:26.303]         }
[17:39:26.303]     }, args = future.call.arguments)
[17:39:26.303] }
[17:39:26.304] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.304] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.305] 
[17:39:26.305] getGlobalsAndPackages() ... DONE
[17:39:26.305] run() for ‘Future’ ...
[17:39:26.306] - state: ‘created’
[17:39:26.306] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.310] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.311]   - Field: ‘label’
[17:39:26.311]   - Field: ‘local’
[17:39:26.311]   - Field: ‘owner’
[17:39:26.311]   - Field: ‘envir’
[17:39:26.311]   - Field: ‘workers’
[17:39:26.311]   - Field: ‘packages’
[17:39:26.312]   - Field: ‘gc’
[17:39:26.312]   - Field: ‘job’
[17:39:26.312]   - Field: ‘conditions’
[17:39:26.312]   - Field: ‘expr’
[17:39:26.312]   - Field: ‘uuid’
[17:39:26.312]   - Field: ‘seed’
[17:39:26.312]   - Field: ‘version’
[17:39:26.313]   - Field: ‘result’
[17:39:26.313]   - Field: ‘asynchronous’
[17:39:26.313]   - Field: ‘calls’
[17:39:26.313]   - Field: ‘globals’
[17:39:26.313]   - Field: ‘stdout’
[17:39:26.313]   - Field: ‘earlySignal’
[17:39:26.313]   - Field: ‘lazy’
[17:39:26.314]   - Field: ‘state’
[17:39:26.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.314] - Launch lazy future ...
[17:39:26.314] Packages needed by the future expression (n = 1): ‘stats’
[17:39:26.314] Packages needed by future strategies (n = 0): <none>
[17:39:26.315] {
[17:39:26.315]     {
[17:39:26.315]         {
[17:39:26.315]             ...future.startTime <- base::Sys.time()
[17:39:26.315]             {
[17:39:26.315]                 {
[17:39:26.315]                   {
[17:39:26.315]                     {
[17:39:26.315]                       {
[17:39:26.315]                         base::local({
[17:39:26.315]                           has_future <- base::requireNamespace("future", 
[17:39:26.315]                             quietly = TRUE)
[17:39:26.315]                           if (has_future) {
[17:39:26.315]                             ns <- base::getNamespace("future")
[17:39:26.315]                             version <- ns[[".package"]][["version"]]
[17:39:26.315]                             if (is.null(version)) 
[17:39:26.315]                               version <- utils::packageVersion("future")
[17:39:26.315]                           }
[17:39:26.315]                           else {
[17:39:26.315]                             version <- NULL
[17:39:26.315]                           }
[17:39:26.315]                           if (!has_future || version < "1.8.0") {
[17:39:26.315]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.315]                               "", base::R.version$version.string), 
[17:39:26.315]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:26.315]                                 base::R.version$platform, 8 * 
[17:39:26.315]                                   base::.Machine$sizeof.pointer), 
[17:39:26.315]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.315]                                 "release", "version")], collapse = " "), 
[17:39:26.315]                               hostname = base::Sys.info()[["nodename"]])
[17:39:26.315]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.315]                               info)
[17:39:26.315]                             info <- base::paste(info, collapse = "; ")
[17:39:26.315]                             if (!has_future) {
[17:39:26.315]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.315]                                 info)
[17:39:26.315]                             }
[17:39:26.315]                             else {
[17:39:26.315]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.315]                                 info, version)
[17:39:26.315]                             }
[17:39:26.315]                             base::stop(msg)
[17:39:26.315]                           }
[17:39:26.315]                         })
[17:39:26.315]                       }
[17:39:26.315]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.315]                       base::options(mc.cores = 1L)
[17:39:26.315]                     }
[17:39:26.315]                     base::local({
[17:39:26.315]                       for (pkg in "stats") {
[17:39:26.315]                         base::loadNamespace(pkg)
[17:39:26.315]                         base::library(pkg, character.only = TRUE)
[17:39:26.315]                       }
[17:39:26.315]                     })
[17:39:26.315]                   }
[17:39:26.315]                   options(future.plan = NULL)
[17:39:26.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.315]                 }
[17:39:26.315]                 ...future.workdir <- getwd()
[17:39:26.315]             }
[17:39:26.315]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.315]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.315]         }
[17:39:26.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.315]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:26.315]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.315]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.315]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.315]             base::names(...future.oldOptions))
[17:39:26.315]     }
[17:39:26.315]     if (FALSE) {
[17:39:26.315]     }
[17:39:26.315]     else {
[17:39:26.315]         if (TRUE) {
[17:39:26.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.315]                 open = "w")
[17:39:26.315]         }
[17:39:26.315]         else {
[17:39:26.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.315]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.315]         }
[17:39:26.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.315]             base::sink(type = "output", split = FALSE)
[17:39:26.315]             base::close(...future.stdout)
[17:39:26.315]         }, add = TRUE)
[17:39:26.315]     }
[17:39:26.315]     ...future.frame <- base::sys.nframe()
[17:39:26.315]     ...future.conditions <- base::list()
[17:39:26.315]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.315]     if (FALSE) {
[17:39:26.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.315]     }
[17:39:26.315]     ...future.result <- base::tryCatch({
[17:39:26.315]         base::withCallingHandlers({
[17:39:26.315]             ...future.value <- base::withVisible(base::local({
[17:39:26.315]                 withCallingHandlers({
[17:39:26.315]                   {
[17:39:26.315]                     do.call(function(...) {
[17:39:26.315]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.315]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.315]                         ...future.globals.maxSize)) {
[17:39:26.315]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.315]                         on.exit(options(oopts), add = TRUE)
[17:39:26.315]                       }
[17:39:26.315]                       {
[17:39:26.315]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.315]                           FUN = function(jj) {
[17:39:26.315]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.315]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.315]                           })
[17:39:26.315]                       }
[17:39:26.315]                     }, args = future.call.arguments)
[17:39:26.315]                   }
[17:39:26.315]                 }, immediateCondition = function(cond) {
[17:39:26.315]                   save_rds <- function (object, pathname, ...) 
[17:39:26.315]                   {
[17:39:26.315]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.315]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.315]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.315]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.315]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.315]                         fi_tmp[["mtime"]])
[17:39:26.315]                     }
[17:39:26.315]                     tryCatch({
[17:39:26.315]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.315]                     }, error = function(ex) {
[17:39:26.315]                       msg <- conditionMessage(ex)
[17:39:26.315]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.315]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.315]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.315]                         fi_tmp[["mtime"]], msg)
[17:39:26.315]                       ex$message <- msg
[17:39:26.315]                       stop(ex)
[17:39:26.315]                     })
[17:39:26.315]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.315]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.315]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.315]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.315]                       fi <- file.info(pathname)
[17:39:26.315]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.315]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.315]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.315]                         fi[["size"]], fi[["mtime"]])
[17:39:26.315]                       stop(msg)
[17:39:26.315]                     }
[17:39:26.315]                     invisible(pathname)
[17:39:26.315]                   }
[17:39:26.315]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.315]                     rootPath = tempdir()) 
[17:39:26.315]                   {
[17:39:26.315]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.315]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.315]                       tmpdir = path, fileext = ".rds")
[17:39:26.315]                     save_rds(obj, file)
[17:39:26.315]                   }
[17:39:26.315]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.315]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.315]                   {
[17:39:26.315]                     inherits <- base::inherits
[17:39:26.315]                     invokeRestart <- base::invokeRestart
[17:39:26.315]                     is.null <- base::is.null
[17:39:26.315]                     muffled <- FALSE
[17:39:26.315]                     if (inherits(cond, "message")) {
[17:39:26.315]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.315]                       if (muffled) 
[17:39:26.315]                         invokeRestart("muffleMessage")
[17:39:26.315]                     }
[17:39:26.315]                     else if (inherits(cond, "warning")) {
[17:39:26.315]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.315]                       if (muffled) 
[17:39:26.315]                         invokeRestart("muffleWarning")
[17:39:26.315]                     }
[17:39:26.315]                     else if (inherits(cond, "condition")) {
[17:39:26.315]                       if (!is.null(pattern)) {
[17:39:26.315]                         computeRestarts <- base::computeRestarts
[17:39:26.315]                         grepl <- base::grepl
[17:39:26.315]                         restarts <- computeRestarts(cond)
[17:39:26.315]                         for (restart in restarts) {
[17:39:26.315]                           name <- restart$name
[17:39:26.315]                           if (is.null(name)) 
[17:39:26.315]                             next
[17:39:26.315]                           if (!grepl(pattern, name)) 
[17:39:26.315]                             next
[17:39:26.315]                           invokeRestart(restart)
[17:39:26.315]                           muffled <- TRUE
[17:39:26.315]                           break
[17:39:26.315]                         }
[17:39:26.315]                       }
[17:39:26.315]                     }
[17:39:26.315]                     invisible(muffled)
[17:39:26.315]                   }
[17:39:26.315]                   muffleCondition(cond)
[17:39:26.315]                 })
[17:39:26.315]             }))
[17:39:26.315]             future::FutureResult(value = ...future.value$value, 
[17:39:26.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.315]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.315]                     ...future.globalenv.names))
[17:39:26.315]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.315]         }, condition = base::local({
[17:39:26.315]             c <- base::c
[17:39:26.315]             inherits <- base::inherits
[17:39:26.315]             invokeRestart <- base::invokeRestart
[17:39:26.315]             length <- base::length
[17:39:26.315]             list <- base::list
[17:39:26.315]             seq.int <- base::seq.int
[17:39:26.315]             signalCondition <- base::signalCondition
[17:39:26.315]             sys.calls <- base::sys.calls
[17:39:26.315]             `[[` <- base::`[[`
[17:39:26.315]             `+` <- base::`+`
[17:39:26.315]             `<<-` <- base::`<<-`
[17:39:26.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.315]                   3L)]
[17:39:26.315]             }
[17:39:26.315]             function(cond) {
[17:39:26.315]                 is_error <- inherits(cond, "error")
[17:39:26.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.315]                   NULL)
[17:39:26.315]                 if (is_error) {
[17:39:26.315]                   sessionInformation <- function() {
[17:39:26.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.315]                       search = base::search(), system = base::Sys.info())
[17:39:26.315]                   }
[17:39:26.315]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.315]                     cond$call), session = sessionInformation(), 
[17:39:26.315]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.315]                   signalCondition(cond)
[17:39:26.315]                 }
[17:39:26.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.315]                 "immediateCondition"))) {
[17:39:26.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.315]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.315]                   if (TRUE && !signal) {
[17:39:26.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.315]                     {
[17:39:26.315]                       inherits <- base::inherits
[17:39:26.315]                       invokeRestart <- base::invokeRestart
[17:39:26.315]                       is.null <- base::is.null
[17:39:26.315]                       muffled <- FALSE
[17:39:26.315]                       if (inherits(cond, "message")) {
[17:39:26.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.315]                         if (muffled) 
[17:39:26.315]                           invokeRestart("muffleMessage")
[17:39:26.315]                       }
[17:39:26.315]                       else if (inherits(cond, "warning")) {
[17:39:26.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.315]                         if (muffled) 
[17:39:26.315]                           invokeRestart("muffleWarning")
[17:39:26.315]                       }
[17:39:26.315]                       else if (inherits(cond, "condition")) {
[17:39:26.315]                         if (!is.null(pattern)) {
[17:39:26.315]                           computeRestarts <- base::computeRestarts
[17:39:26.315]                           grepl <- base::grepl
[17:39:26.315]                           restarts <- computeRestarts(cond)
[17:39:26.315]                           for (restart in restarts) {
[17:39:26.315]                             name <- restart$name
[17:39:26.315]                             if (is.null(name)) 
[17:39:26.315]                               next
[17:39:26.315]                             if (!grepl(pattern, name)) 
[17:39:26.315]                               next
[17:39:26.315]                             invokeRestart(restart)
[17:39:26.315]                             muffled <- TRUE
[17:39:26.315]                             break
[17:39:26.315]                           }
[17:39:26.315]                         }
[17:39:26.315]                       }
[17:39:26.315]                       invisible(muffled)
[17:39:26.315]                     }
[17:39:26.315]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.315]                   }
[17:39:26.315]                 }
[17:39:26.315]                 else {
[17:39:26.315]                   if (TRUE) {
[17:39:26.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.315]                     {
[17:39:26.315]                       inherits <- base::inherits
[17:39:26.315]                       invokeRestart <- base::invokeRestart
[17:39:26.315]                       is.null <- base::is.null
[17:39:26.315]                       muffled <- FALSE
[17:39:26.315]                       if (inherits(cond, "message")) {
[17:39:26.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.315]                         if (muffled) 
[17:39:26.315]                           invokeRestart("muffleMessage")
[17:39:26.315]                       }
[17:39:26.315]                       else if (inherits(cond, "warning")) {
[17:39:26.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.315]                         if (muffled) 
[17:39:26.315]                           invokeRestart("muffleWarning")
[17:39:26.315]                       }
[17:39:26.315]                       else if (inherits(cond, "condition")) {
[17:39:26.315]                         if (!is.null(pattern)) {
[17:39:26.315]                           computeRestarts <- base::computeRestarts
[17:39:26.315]                           grepl <- base::grepl
[17:39:26.315]                           restarts <- computeRestarts(cond)
[17:39:26.315]                           for (restart in restarts) {
[17:39:26.315]                             name <- restart$name
[17:39:26.315]                             if (is.null(name)) 
[17:39:26.315]                               next
[17:39:26.315]                             if (!grepl(pattern, name)) 
[17:39:26.315]                               next
[17:39:26.315]                             invokeRestart(restart)
[17:39:26.315]                             muffled <- TRUE
[17:39:26.315]                             break
[17:39:26.315]                           }
[17:39:26.315]                         }
[17:39:26.315]                       }
[17:39:26.315]                       invisible(muffled)
[17:39:26.315]                     }
[17:39:26.315]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.315]                   }
[17:39:26.315]                 }
[17:39:26.315]             }
[17:39:26.315]         }))
[17:39:26.315]     }, error = function(ex) {
[17:39:26.315]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.315]                 ...future.rng), started = ...future.startTime, 
[17:39:26.315]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.315]             version = "1.8"), class = "FutureResult")
[17:39:26.315]     }, finally = {
[17:39:26.315]         if (!identical(...future.workdir, getwd())) 
[17:39:26.315]             setwd(...future.workdir)
[17:39:26.315]         {
[17:39:26.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.315]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.315]             }
[17:39:26.315]             base::options(...future.oldOptions)
[17:39:26.315]             if (.Platform$OS.type == "windows") {
[17:39:26.315]                 old_names <- names(...future.oldEnvVars)
[17:39:26.315]                 envs <- base::Sys.getenv()
[17:39:26.315]                 names <- names(envs)
[17:39:26.315]                 common <- intersect(names, old_names)
[17:39:26.315]                 added <- setdiff(names, old_names)
[17:39:26.315]                 removed <- setdiff(old_names, names)
[17:39:26.315]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.315]                   envs[common]]
[17:39:26.315]                 NAMES <- toupper(changed)
[17:39:26.315]                 args <- list()
[17:39:26.315]                 for (kk in seq_along(NAMES)) {
[17:39:26.315]                   name <- changed[[kk]]
[17:39:26.315]                   NAME <- NAMES[[kk]]
[17:39:26.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.315]                     next
[17:39:26.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.315]                 }
[17:39:26.315]                 NAMES <- toupper(added)
[17:39:26.315]                 for (kk in seq_along(NAMES)) {
[17:39:26.315]                   name <- added[[kk]]
[17:39:26.315]                   NAME <- NAMES[[kk]]
[17:39:26.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.315]                     next
[17:39:26.315]                   args[[name]] <- ""
[17:39:26.315]                 }
[17:39:26.315]                 NAMES <- toupper(removed)
[17:39:26.315]                 for (kk in seq_along(NAMES)) {
[17:39:26.315]                   name <- removed[[kk]]
[17:39:26.315]                   NAME <- NAMES[[kk]]
[17:39:26.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.315]                     next
[17:39:26.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.315]                 }
[17:39:26.315]                 if (length(args) > 0) 
[17:39:26.315]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.315]             }
[17:39:26.315]             else {
[17:39:26.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.315]             }
[17:39:26.315]             {
[17:39:26.315]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.315]                   0L) {
[17:39:26.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.315]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.315]                   base::options(opts)
[17:39:26.315]                 }
[17:39:26.315]                 {
[17:39:26.315]                   {
[17:39:26.315]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.315]                     NULL
[17:39:26.315]                   }
[17:39:26.315]                   options(future.plan = NULL)
[17:39:26.315]                   if (is.na(NA_character_)) 
[17:39:26.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.315]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.315]                     envir = parent.frame()) 
[17:39:26.315]                   {
[17:39:26.315]                     default_workers <- missing(workers)
[17:39:26.315]                     if (is.function(workers)) 
[17:39:26.315]                       workers <- workers()
[17:39:26.315]                     workers <- structure(as.integer(workers), 
[17:39:26.315]                       class = class(workers))
[17:39:26.315]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.315]                       1L)
[17:39:26.315]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.315]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.315]                       if (default_workers) 
[17:39:26.315]                         supportsMulticore(warn = TRUE)
[17:39:26.315]                       return(sequential(..., envir = envir))
[17:39:26.315]                     }
[17:39:26.315]                     oopts <- options(mc.cores = workers)
[17:39:26.315]                     on.exit(options(oopts))
[17:39:26.315]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.315]                       envir = envir)
[17:39:26.315]                     if (!future$lazy) 
[17:39:26.315]                       future <- run(future)
[17:39:26.315]                     invisible(future)
[17:39:26.315]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.315]                 }
[17:39:26.315]             }
[17:39:26.315]         }
[17:39:26.315]     })
[17:39:26.315]     if (TRUE) {
[17:39:26.315]         base::sink(type = "output", split = FALSE)
[17:39:26.315]         if (TRUE) {
[17:39:26.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.315]         }
[17:39:26.315]         else {
[17:39:26.315]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.315]         }
[17:39:26.315]         base::close(...future.stdout)
[17:39:26.315]         ...future.stdout <- NULL
[17:39:26.315]     }
[17:39:26.315]     ...future.result$conditions <- ...future.conditions
[17:39:26.315]     ...future.result$finished <- base::Sys.time()
[17:39:26.315]     ...future.result
[17:39:26.315] }
[17:39:26.319] assign_globals() ...
[17:39:26.319] List of 5
[17:39:26.319]  $ ...future.FUN            :function (x, ...)  
[17:39:26.319]  $ future.call.arguments    :List of 1
[17:39:26.319]   ..$ singular.ok: logi FALSE
[17:39:26.319]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.319]  $ ...future.elements_ii    :List of 2
[17:39:26.319]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.319]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:26.319]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.319]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:26.319]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.319]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:26.319]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.319]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:26.319]  $ ...future.seeds_ii       : NULL
[17:39:26.319]  $ ...future.globals.maxSize: NULL
[17:39:26.319]  - attr(*, "resolved")= logi FALSE
[17:39:26.319]  - attr(*, "total_size")= num 5384
[17:39:26.319]  - attr(*, "where")=List of 5
[17:39:26.319]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.319]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.319]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.319]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.319]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.319]  - attr(*, "already-done")= logi TRUE
[17:39:26.333] - reassign environment for ‘...future.FUN’
[17:39:26.333] - copied ‘...future.FUN’ to environment
[17:39:26.333] - copied ‘future.call.arguments’ to environment
[17:39:26.334] - copied ‘...future.elements_ii’ to environment
[17:39:26.334] - copied ‘...future.seeds_ii’ to environment
[17:39:26.334] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.334] assign_globals() ... done
[17:39:26.334] requestCore(): workers = 2
[17:39:26.336] MulticoreFuture started
[17:39:26.337] - Launch lazy future ... done
[17:39:26.337] run() for ‘MulticoreFuture’ ... done
[17:39:26.338] Created future:
[17:39:26.338] plan(): Setting new future strategy stack:
[17:39:26.338] List of future strategies:
[17:39:26.338] 1. sequential:
[17:39:26.338]    - args: function (..., envir = parent.frame())
[17:39:26.338]    - tweaked: FALSE
[17:39:26.338]    - call: NULL
[17:39:26.339] plan(): nbrOfWorkers() = 1
[17:39:26.345] plan(): Setting new future strategy stack:
[17:39:26.345] List of future strategies:
[17:39:26.345] 1. multicore:
[17:39:26.345]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.345]    - tweaked: FALSE
[17:39:26.345]    - call: plan(strategy)
[17:39:26.350] plan(): nbrOfWorkers() = 2
[17:39:26.338] MulticoreFuture:
[17:39:26.338] Label: ‘future_by-2’
[17:39:26.338] Expression:
[17:39:26.338] {
[17:39:26.338]     do.call(function(...) {
[17:39:26.338]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.338]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.338]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.338]             on.exit(options(oopts), add = TRUE)
[17:39:26.338]         }
[17:39:26.338]         {
[17:39:26.338]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.338]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.338]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.338]             })
[17:39:26.338]         }
[17:39:26.338]     }, args = future.call.arguments)
[17:39:26.338] }
[17:39:26.338] Lazy evaluation: FALSE
[17:39:26.338] Asynchronous evaluation: TRUE
[17:39:26.338] Local evaluation: TRUE
[17:39:26.338] Environment: R_GlobalEnv
[17:39:26.338] Capture standard output: TRUE
[17:39:26.338] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.338] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.338] Packages: 1 packages (‘stats’)
[17:39:26.338] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.338] Resolved: FALSE
[17:39:26.338] Value: <not collected>
[17:39:26.338] Conditions captured: <none>
[17:39:26.338] Early signaling: FALSE
[17:39:26.338] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.338] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.352] Chunk #2 of 2 ... DONE
[17:39:26.352] Launching 2 futures (chunks) ... DONE
[17:39:26.352] Resolving 2 futures (chunks) ...
[17:39:26.352] resolve() on list ...
[17:39:26.352]  recursive: 0
[17:39:26.353]  length: 2
[17:39:26.353] 
[17:39:26.353] Future #1
[17:39:26.355] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:26.355] - nx: 2
[17:39:26.355] - relay: TRUE
[17:39:26.355] - stdout: TRUE
[17:39:26.355] - signal: TRUE
[17:39:26.356] - resignal: FALSE
[17:39:26.356] - force: TRUE
[17:39:26.356] - relayed: [n=2] FALSE, FALSE
[17:39:26.356] - queued futures: [n=2] FALSE, FALSE
[17:39:26.356]  - until=1
[17:39:26.356]  - relaying element #1
[17:39:26.356] - relayed: [n=2] TRUE, FALSE
[17:39:26.357] - queued futures: [n=2] TRUE, FALSE
[17:39:26.357] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:26.357]  length: 1 (resolved future 1)
[17:39:26.357] Future #2
[17:39:26.359] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:26.359] - nx: 2
[17:39:26.359] - relay: TRUE
[17:39:26.359] - stdout: TRUE
[17:39:26.359] - signal: TRUE
[17:39:26.359] - resignal: FALSE
[17:39:26.359] - force: TRUE
[17:39:26.360] - relayed: [n=2] TRUE, FALSE
[17:39:26.360] - queued futures: [n=2] TRUE, FALSE
[17:39:26.360]  - until=2
[17:39:26.360]  - relaying element #2
[17:39:26.360] - relayed: [n=2] TRUE, TRUE
[17:39:26.360] - queued futures: [n=2] TRUE, TRUE
[17:39:26.361] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:26.361]  length: 0 (resolved future 2)
[17:39:26.361] Relaying remaining futures
[17:39:26.361] signalConditionsASAP(NULL, pos=0) ...
[17:39:26.361] - nx: 2
[17:39:26.361] - relay: TRUE
[17:39:26.361] - stdout: TRUE
[17:39:26.361] - signal: TRUE
[17:39:26.361] - resignal: FALSE
[17:39:26.362] - force: TRUE
[17:39:26.362] - relayed: [n=2] TRUE, TRUE
[17:39:26.362] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:26.362] - relayed: [n=2] TRUE, TRUE
[17:39:26.362] - queued futures: [n=2] TRUE, TRUE
[17:39:26.362] signalConditionsASAP(NULL, pos=0) ... done
[17:39:26.362] resolve() on list ... DONE
[17:39:26.363]  - Number of value chunks collected: 2
[17:39:26.363] Resolving 2 futures (chunks) ... DONE
[17:39:26.363] Reducing values from 2 chunks ...
[17:39:26.363]  - Number of values collected after concatenation: 3
[17:39:26.363]  - Number of values expected: 3
[17:39:26.363] Reducing values from 2 chunks ... DONE
[17:39:26.363] future_lapply() ... DONE
[17:39:26.363] future_by_internal() ... DONE
[17:39:26.372] future_by_internal() ...
[17:39:26.373] future_lapply() ...
[17:39:26.378] Number of chunks: 2
[17:39:26.378] getGlobalsAndPackagesXApply() ...
[17:39:26.378]  - future.globals: TRUE
[17:39:26.379] getGlobalsAndPackages() ...
[17:39:26.379] Searching for globals...
[17:39:26.381] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:26.381] Searching for globals ... DONE
[17:39:26.381] Resolving globals: FALSE
[17:39:26.381] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:39:26.382] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:39:26.382] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:26.382] - packages: [1] ‘stats’
[17:39:26.382] getGlobalsAndPackages() ... DONE
[17:39:26.382]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:26.382]  - needed namespaces: [n=1] ‘stats’
[17:39:26.382] Finding globals ... DONE
[17:39:26.383]  - use_args: TRUE
[17:39:26.383]  - Getting '...' globals ...
[17:39:26.383] resolve() on list ...
[17:39:26.383]  recursive: 0
[17:39:26.383]  length: 1
[17:39:26.383]  elements: ‘...’
[17:39:26.383]  length: 0 (resolved future 1)
[17:39:26.384] resolve() on list ... DONE
[17:39:26.384]    - '...' content: [n=0] 
[17:39:26.384] List of 1
[17:39:26.384]  $ ...: list()
[17:39:26.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.384]  - attr(*, "where")=List of 1
[17:39:26.384]   ..$ ...:<environment: 0x56296ed1b108> 
[17:39:26.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.384]  - attr(*, "resolved")= logi TRUE
[17:39:26.384]  - attr(*, "total_size")= num NA
[17:39:26.387]  - Getting '...' globals ... DONE
[17:39:26.387] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:39:26.387] List of 4
[17:39:26.387]  $ ...future.FUN:function (x)  
[17:39:26.387]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:26.387]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:26.387]  $ ...          : list()
[17:39:26.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.387]  - attr(*, "where")=List of 4
[17:39:26.387]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:26.387]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:39:26.387]   ..$ wool         :<environment: R_EmptyEnv> 
[17:39:26.387]   ..$ ...          :<environment: 0x56296ed1b108> 
[17:39:26.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.387]  - attr(*, "resolved")= logi FALSE
[17:39:26.387]  - attr(*, "total_size")= num 2320
[17:39:26.394] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:26.394] getGlobalsAndPackagesXApply() ... DONE
[17:39:26.394] Number of futures (= number of chunks): 2
[17:39:26.394] Launching 2 futures (chunks) ...
[17:39:26.394] Chunk #1 of 2 ...
[17:39:26.394]  - Finding globals in 'X' for chunk #1 ...
[17:39:26.394] getGlobalsAndPackages() ...
[17:39:26.395] Searching for globals...
[17:39:26.395] 
[17:39:26.395] Searching for globals ... DONE
[17:39:26.395] - globals: [0] <none>
[17:39:26.395] getGlobalsAndPackages() ... DONE
[17:39:26.395]    + additional globals found: [n=0] 
[17:39:26.396]    + additional namespaces needed: [n=0] 
[17:39:26.396]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:26.396]  - seeds: <none>
[17:39:26.396] getGlobalsAndPackages() ...
[17:39:26.396] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.396] Resolving globals: FALSE
[17:39:26.396] Tweak future expression to call with '...' arguments ...
[17:39:26.396] {
[17:39:26.396]     do.call(function(...) {
[17:39:26.396]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.396]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.396]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.396]             on.exit(options(oopts), add = TRUE)
[17:39:26.396]         }
[17:39:26.396]         {
[17:39:26.396]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.396]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.396]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.396]             })
[17:39:26.396]         }
[17:39:26.396]     }, args = future.call.arguments)
[17:39:26.396] }
[17:39:26.397] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.397] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.397] 
[17:39:26.397] getGlobalsAndPackages() ... DONE
[17:39:26.398] run() for ‘Future’ ...
[17:39:26.398] - state: ‘created’
[17:39:26.398] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.402] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.402] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.402]   - Field: ‘label’
[17:39:26.402]   - Field: ‘local’
[17:39:26.403]   - Field: ‘owner’
[17:39:26.403]   - Field: ‘envir’
[17:39:26.403]   - Field: ‘workers’
[17:39:26.403]   - Field: ‘packages’
[17:39:26.403]   - Field: ‘gc’
[17:39:26.403]   - Field: ‘job’
[17:39:26.403]   - Field: ‘conditions’
[17:39:26.403]   - Field: ‘expr’
[17:39:26.403]   - Field: ‘uuid’
[17:39:26.403]   - Field: ‘seed’
[17:39:26.404]   - Field: ‘version’
[17:39:26.404]   - Field: ‘result’
[17:39:26.404]   - Field: ‘asynchronous’
[17:39:26.404]   - Field: ‘calls’
[17:39:26.404]   - Field: ‘globals’
[17:39:26.404]   - Field: ‘stdout’
[17:39:26.404]   - Field: ‘earlySignal’
[17:39:26.404]   - Field: ‘lazy’
[17:39:26.404]   - Field: ‘state’
[17:39:26.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.404] - Launch lazy future ...
[17:39:26.405] Packages needed by the future expression (n = 1): ‘stats’
[17:39:26.405] Packages needed by future strategies (n = 0): <none>
[17:39:26.405] {
[17:39:26.405]     {
[17:39:26.405]         {
[17:39:26.405]             ...future.startTime <- base::Sys.time()
[17:39:26.405]             {
[17:39:26.405]                 {
[17:39:26.405]                   {
[17:39:26.405]                     {
[17:39:26.405]                       {
[17:39:26.405]                         base::local({
[17:39:26.405]                           has_future <- base::requireNamespace("future", 
[17:39:26.405]                             quietly = TRUE)
[17:39:26.405]                           if (has_future) {
[17:39:26.405]                             ns <- base::getNamespace("future")
[17:39:26.405]                             version <- ns[[".package"]][["version"]]
[17:39:26.405]                             if (is.null(version)) 
[17:39:26.405]                               version <- utils::packageVersion("future")
[17:39:26.405]                           }
[17:39:26.405]                           else {
[17:39:26.405]                             version <- NULL
[17:39:26.405]                           }
[17:39:26.405]                           if (!has_future || version < "1.8.0") {
[17:39:26.405]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.405]                               "", base::R.version$version.string), 
[17:39:26.405]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:26.405]                                 base::R.version$platform, 8 * 
[17:39:26.405]                                   base::.Machine$sizeof.pointer), 
[17:39:26.405]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.405]                                 "release", "version")], collapse = " "), 
[17:39:26.405]                               hostname = base::Sys.info()[["nodename"]])
[17:39:26.405]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.405]                               info)
[17:39:26.405]                             info <- base::paste(info, collapse = "; ")
[17:39:26.405]                             if (!has_future) {
[17:39:26.405]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.405]                                 info)
[17:39:26.405]                             }
[17:39:26.405]                             else {
[17:39:26.405]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.405]                                 info, version)
[17:39:26.405]                             }
[17:39:26.405]                             base::stop(msg)
[17:39:26.405]                           }
[17:39:26.405]                         })
[17:39:26.405]                       }
[17:39:26.405]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.405]                       base::options(mc.cores = 1L)
[17:39:26.405]                     }
[17:39:26.405]                     base::local({
[17:39:26.405]                       for (pkg in "stats") {
[17:39:26.405]                         base::loadNamespace(pkg)
[17:39:26.405]                         base::library(pkg, character.only = TRUE)
[17:39:26.405]                       }
[17:39:26.405]                     })
[17:39:26.405]                   }
[17:39:26.405]                   options(future.plan = NULL)
[17:39:26.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.405]                 }
[17:39:26.405]                 ...future.workdir <- getwd()
[17:39:26.405]             }
[17:39:26.405]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.405]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.405]         }
[17:39:26.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:26.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.405]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.405]             base::names(...future.oldOptions))
[17:39:26.405]     }
[17:39:26.405]     if (FALSE) {
[17:39:26.405]     }
[17:39:26.405]     else {
[17:39:26.405]         if (TRUE) {
[17:39:26.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.405]                 open = "w")
[17:39:26.405]         }
[17:39:26.405]         else {
[17:39:26.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.405]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.405]         }
[17:39:26.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.405]             base::sink(type = "output", split = FALSE)
[17:39:26.405]             base::close(...future.stdout)
[17:39:26.405]         }, add = TRUE)
[17:39:26.405]     }
[17:39:26.405]     ...future.frame <- base::sys.nframe()
[17:39:26.405]     ...future.conditions <- base::list()
[17:39:26.405]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.405]     if (FALSE) {
[17:39:26.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.405]     }
[17:39:26.405]     ...future.result <- base::tryCatch({
[17:39:26.405]         base::withCallingHandlers({
[17:39:26.405]             ...future.value <- base::withVisible(base::local({
[17:39:26.405]                 withCallingHandlers({
[17:39:26.405]                   {
[17:39:26.405]                     do.call(function(...) {
[17:39:26.405]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.405]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.405]                         ...future.globals.maxSize)) {
[17:39:26.405]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.405]                         on.exit(options(oopts), add = TRUE)
[17:39:26.405]                       }
[17:39:26.405]                       {
[17:39:26.405]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.405]                           FUN = function(jj) {
[17:39:26.405]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.405]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.405]                           })
[17:39:26.405]                       }
[17:39:26.405]                     }, args = future.call.arguments)
[17:39:26.405]                   }
[17:39:26.405]                 }, immediateCondition = function(cond) {
[17:39:26.405]                   save_rds <- function (object, pathname, ...) 
[17:39:26.405]                   {
[17:39:26.405]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.405]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.405]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.405]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.405]                         fi_tmp[["mtime"]])
[17:39:26.405]                     }
[17:39:26.405]                     tryCatch({
[17:39:26.405]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.405]                     }, error = function(ex) {
[17:39:26.405]                       msg <- conditionMessage(ex)
[17:39:26.405]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.405]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.405]                         fi_tmp[["mtime"]], msg)
[17:39:26.405]                       ex$message <- msg
[17:39:26.405]                       stop(ex)
[17:39:26.405]                     })
[17:39:26.405]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.405]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.405]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.405]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.405]                       fi <- file.info(pathname)
[17:39:26.405]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.405]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.405]                         fi[["size"]], fi[["mtime"]])
[17:39:26.405]                       stop(msg)
[17:39:26.405]                     }
[17:39:26.405]                     invisible(pathname)
[17:39:26.405]                   }
[17:39:26.405]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.405]                     rootPath = tempdir()) 
[17:39:26.405]                   {
[17:39:26.405]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.405]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.405]                       tmpdir = path, fileext = ".rds")
[17:39:26.405]                     save_rds(obj, file)
[17:39:26.405]                   }
[17:39:26.405]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.405]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.405]                   {
[17:39:26.405]                     inherits <- base::inherits
[17:39:26.405]                     invokeRestart <- base::invokeRestart
[17:39:26.405]                     is.null <- base::is.null
[17:39:26.405]                     muffled <- FALSE
[17:39:26.405]                     if (inherits(cond, "message")) {
[17:39:26.405]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.405]                       if (muffled) 
[17:39:26.405]                         invokeRestart("muffleMessage")
[17:39:26.405]                     }
[17:39:26.405]                     else if (inherits(cond, "warning")) {
[17:39:26.405]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.405]                       if (muffled) 
[17:39:26.405]                         invokeRestart("muffleWarning")
[17:39:26.405]                     }
[17:39:26.405]                     else if (inherits(cond, "condition")) {
[17:39:26.405]                       if (!is.null(pattern)) {
[17:39:26.405]                         computeRestarts <- base::computeRestarts
[17:39:26.405]                         grepl <- base::grepl
[17:39:26.405]                         restarts <- computeRestarts(cond)
[17:39:26.405]                         for (restart in restarts) {
[17:39:26.405]                           name <- restart$name
[17:39:26.405]                           if (is.null(name)) 
[17:39:26.405]                             next
[17:39:26.405]                           if (!grepl(pattern, name)) 
[17:39:26.405]                             next
[17:39:26.405]                           invokeRestart(restart)
[17:39:26.405]                           muffled <- TRUE
[17:39:26.405]                           break
[17:39:26.405]                         }
[17:39:26.405]                       }
[17:39:26.405]                     }
[17:39:26.405]                     invisible(muffled)
[17:39:26.405]                   }
[17:39:26.405]                   muffleCondition(cond)
[17:39:26.405]                 })
[17:39:26.405]             }))
[17:39:26.405]             future::FutureResult(value = ...future.value$value, 
[17:39:26.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.405]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.405]                     ...future.globalenv.names))
[17:39:26.405]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.405]         }, condition = base::local({
[17:39:26.405]             c <- base::c
[17:39:26.405]             inherits <- base::inherits
[17:39:26.405]             invokeRestart <- base::invokeRestart
[17:39:26.405]             length <- base::length
[17:39:26.405]             list <- base::list
[17:39:26.405]             seq.int <- base::seq.int
[17:39:26.405]             signalCondition <- base::signalCondition
[17:39:26.405]             sys.calls <- base::sys.calls
[17:39:26.405]             `[[` <- base::`[[`
[17:39:26.405]             `+` <- base::`+`
[17:39:26.405]             `<<-` <- base::`<<-`
[17:39:26.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.405]                   3L)]
[17:39:26.405]             }
[17:39:26.405]             function(cond) {
[17:39:26.405]                 is_error <- inherits(cond, "error")
[17:39:26.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.405]                   NULL)
[17:39:26.405]                 if (is_error) {
[17:39:26.405]                   sessionInformation <- function() {
[17:39:26.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.405]                       search = base::search(), system = base::Sys.info())
[17:39:26.405]                   }
[17:39:26.405]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.405]                     cond$call), session = sessionInformation(), 
[17:39:26.405]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.405]                   signalCondition(cond)
[17:39:26.405]                 }
[17:39:26.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.405]                 "immediateCondition"))) {
[17:39:26.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.405]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.405]                   if (TRUE && !signal) {
[17:39:26.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.405]                     {
[17:39:26.405]                       inherits <- base::inherits
[17:39:26.405]                       invokeRestart <- base::invokeRestart
[17:39:26.405]                       is.null <- base::is.null
[17:39:26.405]                       muffled <- FALSE
[17:39:26.405]                       if (inherits(cond, "message")) {
[17:39:26.405]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.405]                         if (muffled) 
[17:39:26.405]                           invokeRestart("muffleMessage")
[17:39:26.405]                       }
[17:39:26.405]                       else if (inherits(cond, "warning")) {
[17:39:26.405]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.405]                         if (muffled) 
[17:39:26.405]                           invokeRestart("muffleWarning")
[17:39:26.405]                       }
[17:39:26.405]                       else if (inherits(cond, "condition")) {
[17:39:26.405]                         if (!is.null(pattern)) {
[17:39:26.405]                           computeRestarts <- base::computeRestarts
[17:39:26.405]                           grepl <- base::grepl
[17:39:26.405]                           restarts <- computeRestarts(cond)
[17:39:26.405]                           for (restart in restarts) {
[17:39:26.405]                             name <- restart$name
[17:39:26.405]                             if (is.null(name)) 
[17:39:26.405]                               next
[17:39:26.405]                             if (!grepl(pattern, name)) 
[17:39:26.405]                               next
[17:39:26.405]                             invokeRestart(restart)
[17:39:26.405]                             muffled <- TRUE
[17:39:26.405]                             break
[17:39:26.405]                           }
[17:39:26.405]                         }
[17:39:26.405]                       }
[17:39:26.405]                       invisible(muffled)
[17:39:26.405]                     }
[17:39:26.405]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.405]                   }
[17:39:26.405]                 }
[17:39:26.405]                 else {
[17:39:26.405]                   if (TRUE) {
[17:39:26.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.405]                     {
[17:39:26.405]                       inherits <- base::inherits
[17:39:26.405]                       invokeRestart <- base::invokeRestart
[17:39:26.405]                       is.null <- base::is.null
[17:39:26.405]                       muffled <- FALSE
[17:39:26.405]                       if (inherits(cond, "message")) {
[17:39:26.405]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.405]                         if (muffled) 
[17:39:26.405]                           invokeRestart("muffleMessage")
[17:39:26.405]                       }
[17:39:26.405]                       else if (inherits(cond, "warning")) {
[17:39:26.405]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.405]                         if (muffled) 
[17:39:26.405]                           invokeRestart("muffleWarning")
[17:39:26.405]                       }
[17:39:26.405]                       else if (inherits(cond, "condition")) {
[17:39:26.405]                         if (!is.null(pattern)) {
[17:39:26.405]                           computeRestarts <- base::computeRestarts
[17:39:26.405]                           grepl <- base::grepl
[17:39:26.405]                           restarts <- computeRestarts(cond)
[17:39:26.405]                           for (restart in restarts) {
[17:39:26.405]                             name <- restart$name
[17:39:26.405]                             if (is.null(name)) 
[17:39:26.405]                               next
[17:39:26.405]                             if (!grepl(pattern, name)) 
[17:39:26.405]                               next
[17:39:26.405]                             invokeRestart(restart)
[17:39:26.405]                             muffled <- TRUE
[17:39:26.405]                             break
[17:39:26.405]                           }
[17:39:26.405]                         }
[17:39:26.405]                       }
[17:39:26.405]                       invisible(muffled)
[17:39:26.405]                     }
[17:39:26.405]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.405]                   }
[17:39:26.405]                 }
[17:39:26.405]             }
[17:39:26.405]         }))
[17:39:26.405]     }, error = function(ex) {
[17:39:26.405]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.405]                 ...future.rng), started = ...future.startTime, 
[17:39:26.405]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.405]             version = "1.8"), class = "FutureResult")
[17:39:26.405]     }, finally = {
[17:39:26.405]         if (!identical(...future.workdir, getwd())) 
[17:39:26.405]             setwd(...future.workdir)
[17:39:26.405]         {
[17:39:26.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.405]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.405]             }
[17:39:26.405]             base::options(...future.oldOptions)
[17:39:26.405]             if (.Platform$OS.type == "windows") {
[17:39:26.405]                 old_names <- names(...future.oldEnvVars)
[17:39:26.405]                 envs <- base::Sys.getenv()
[17:39:26.405]                 names <- names(envs)
[17:39:26.405]                 common <- intersect(names, old_names)
[17:39:26.405]                 added <- setdiff(names, old_names)
[17:39:26.405]                 removed <- setdiff(old_names, names)
[17:39:26.405]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.405]                   envs[common]]
[17:39:26.405]                 NAMES <- toupper(changed)
[17:39:26.405]                 args <- list()
[17:39:26.405]                 for (kk in seq_along(NAMES)) {
[17:39:26.405]                   name <- changed[[kk]]
[17:39:26.405]                   NAME <- NAMES[[kk]]
[17:39:26.405]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.405]                     next
[17:39:26.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.405]                 }
[17:39:26.405]                 NAMES <- toupper(added)
[17:39:26.405]                 for (kk in seq_along(NAMES)) {
[17:39:26.405]                   name <- added[[kk]]
[17:39:26.405]                   NAME <- NAMES[[kk]]
[17:39:26.405]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.405]                     next
[17:39:26.405]                   args[[name]] <- ""
[17:39:26.405]                 }
[17:39:26.405]                 NAMES <- toupper(removed)
[17:39:26.405]                 for (kk in seq_along(NAMES)) {
[17:39:26.405]                   name <- removed[[kk]]
[17:39:26.405]                   NAME <- NAMES[[kk]]
[17:39:26.405]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.405]                     next
[17:39:26.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.405]                 }
[17:39:26.405]                 if (length(args) > 0) 
[17:39:26.405]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.405]             }
[17:39:26.405]             else {
[17:39:26.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.405]             }
[17:39:26.405]             {
[17:39:26.405]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.405]                   0L) {
[17:39:26.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.405]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.405]                   base::options(opts)
[17:39:26.405]                 }
[17:39:26.405]                 {
[17:39:26.405]                   {
[17:39:26.405]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.405]                     NULL
[17:39:26.405]                   }
[17:39:26.405]                   options(future.plan = NULL)
[17:39:26.405]                   if (is.na(NA_character_)) 
[17:39:26.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.405]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.405]                     envir = parent.frame()) 
[17:39:26.405]                   {
[17:39:26.405]                     default_workers <- missing(workers)
[17:39:26.405]                     if (is.function(workers)) 
[17:39:26.405]                       workers <- workers()
[17:39:26.405]                     workers <- structure(as.integer(workers), 
[17:39:26.405]                       class = class(workers))
[17:39:26.405]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.405]                       1L)
[17:39:26.405]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.405]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.405]                       if (default_workers) 
[17:39:26.405]                         supportsMulticore(warn = TRUE)
[17:39:26.405]                       return(sequential(..., envir = envir))
[17:39:26.405]                     }
[17:39:26.405]                     oopts <- options(mc.cores = workers)
[17:39:26.405]                     on.exit(options(oopts))
[17:39:26.405]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.405]                       envir = envir)
[17:39:26.405]                     if (!future$lazy) 
[17:39:26.405]                       future <- run(future)
[17:39:26.405]                     invisible(future)
[17:39:26.405]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.405]                 }
[17:39:26.405]             }
[17:39:26.405]         }
[17:39:26.405]     })
[17:39:26.405]     if (TRUE) {
[17:39:26.405]         base::sink(type = "output", split = FALSE)
[17:39:26.405]         if (TRUE) {
[17:39:26.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.405]         }
[17:39:26.405]         else {
[17:39:26.405]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.405]         }
[17:39:26.405]         base::close(...future.stdout)
[17:39:26.405]         ...future.stdout <- NULL
[17:39:26.405]     }
[17:39:26.405]     ...future.result$conditions <- ...future.conditions
[17:39:26.405]     ...future.result$finished <- base::Sys.time()
[17:39:26.405]     ...future.result
[17:39:26.405] }
[17:39:26.408] assign_globals() ...
[17:39:26.408] List of 7
[17:39:26.408]  $ ...future.FUN            :function (x)  
[17:39:26.408]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:26.408]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:26.408]  $ future.call.arguments    : list()
[17:39:26.408]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.408]  $ ...future.elements_ii    :List of 1
[17:39:26.408]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.408]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:26.408]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.408]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:26.408]  $ ...future.seeds_ii       : NULL
[17:39:26.408]  $ ...future.globals.maxSize: NULL
[17:39:26.408]  - attr(*, "where")=List of 7
[17:39:26.408]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.408]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:39:26.408]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:39:26.408]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.408]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.408]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.408]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.408]  - attr(*, "resolved")= logi FALSE
[17:39:26.408]  - attr(*, "total_size")= num 2320
[17:39:26.408]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.408]  - attr(*, "already-done")= logi TRUE
[17:39:26.417] - reassign environment for ‘...future.FUN’
[17:39:26.417] - copied ‘...future.FUN’ to environment
[17:39:26.418] - copied ‘breaks’ to environment
[17:39:26.418] - copied ‘wool’ to environment
[17:39:26.418] - copied ‘future.call.arguments’ to environment
[17:39:26.418] - copied ‘...future.elements_ii’ to environment
[17:39:26.418] - copied ‘...future.seeds_ii’ to environment
[17:39:26.418] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.418] assign_globals() ... done
[17:39:26.418] requestCore(): workers = 2
[17:39:26.421] MulticoreFuture started
[17:39:26.422] - Launch lazy future ... done
[17:39:26.422] run() for ‘MulticoreFuture’ ... done
[17:39:26.423] Created future:
[17:39:26.423] plan(): Setting new future strategy stack:
[17:39:26.423] List of future strategies:
[17:39:26.423] 1. sequential:
[17:39:26.423]    - args: function (..., envir = parent.frame())
[17:39:26.423]    - tweaked: FALSE
[17:39:26.423]    - call: NULL
[17:39:26.425] plan(): nbrOfWorkers() = 1
[17:39:26.430] plan(): Setting new future strategy stack:
[17:39:26.430] List of future strategies:
[17:39:26.430] 1. multicore:
[17:39:26.430]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.430]    - tweaked: FALSE
[17:39:26.430]    - call: plan(strategy)
[17:39:26.437] plan(): nbrOfWorkers() = 2
[17:39:26.423] MulticoreFuture:
[17:39:26.423] Label: ‘future_by-1’
[17:39:26.423] Expression:
[17:39:26.423] {
[17:39:26.423]     do.call(function(...) {
[17:39:26.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.423]             on.exit(options(oopts), add = TRUE)
[17:39:26.423]         }
[17:39:26.423]         {
[17:39:26.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.423]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.423]             })
[17:39:26.423]         }
[17:39:26.423]     }, args = future.call.arguments)
[17:39:26.423] }
[17:39:26.423] Lazy evaluation: FALSE
[17:39:26.423] Asynchronous evaluation: TRUE
[17:39:26.423] Local evaluation: TRUE
[17:39:26.423] Environment: 0x5629710dba40
[17:39:26.423] Capture standard output: TRUE
[17:39:26.423] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.423] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[17:39:26.423] Packages: 1 packages (‘stats’)
[17:39:26.423] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.423] Resolved: FALSE
[17:39:26.423] Value: <not collected>
[17:39:26.423] Conditions captured: <none>
[17:39:26.423] Early signaling: FALSE
[17:39:26.423] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.423] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.438] Chunk #1 of 2 ... DONE
[17:39:26.438] Chunk #2 of 2 ...
[17:39:26.438]  - Finding globals in 'X' for chunk #2 ...
[17:39:26.439] getGlobalsAndPackages() ...
[17:39:26.439] Searching for globals...
[17:39:26.440] 
[17:39:26.440] Searching for globals ... DONE
[17:39:26.440] - globals: [0] <none>
[17:39:26.440] getGlobalsAndPackages() ... DONE
[17:39:26.441]    + additional globals found: [n=0] 
[17:39:26.441]    + additional namespaces needed: [n=0] 
[17:39:26.441]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:26.441]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:26.441]  - seeds: <none>
[17:39:26.442] getGlobalsAndPackages() ...
[17:39:26.442] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.442] Resolving globals: FALSE
[17:39:26.442] Tweak future expression to call with '...' arguments ...
[17:39:26.442] {
[17:39:26.442]     do.call(function(...) {
[17:39:26.442]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.442]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.442]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.442]             on.exit(options(oopts), add = TRUE)
[17:39:26.442]         }
[17:39:26.442]         {
[17:39:26.442]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.442]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.442]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.442]             })
[17:39:26.442]         }
[17:39:26.442]     }, args = future.call.arguments)
[17:39:26.442] }
[17:39:26.443] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.444] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.444] 
[17:39:26.444] getGlobalsAndPackages() ... DONE
[17:39:26.445] run() for ‘Future’ ...
[17:39:26.445] - state: ‘created’
[17:39:26.445] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.450] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.450]   - Field: ‘label’
[17:39:26.450]   - Field: ‘local’
[17:39:26.450]   - Field: ‘owner’
[17:39:26.451]   - Field: ‘envir’
[17:39:26.451]   - Field: ‘workers’
[17:39:26.451]   - Field: ‘packages’
[17:39:26.451]   - Field: ‘gc’
[17:39:26.451]   - Field: ‘job’
[17:39:26.451]   - Field: ‘conditions’
[17:39:26.451]   - Field: ‘expr’
[17:39:26.452]   - Field: ‘uuid’
[17:39:26.452]   - Field: ‘seed’
[17:39:26.452]   - Field: ‘version’
[17:39:26.452]   - Field: ‘result’
[17:39:26.452]   - Field: ‘asynchronous’
[17:39:26.452]   - Field: ‘calls’
[17:39:26.452]   - Field: ‘globals’
[17:39:26.452]   - Field: ‘stdout’
[17:39:26.453]   - Field: ‘earlySignal’
[17:39:26.453]   - Field: ‘lazy’
[17:39:26.453]   - Field: ‘state’
[17:39:26.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.453] - Launch lazy future ...
[17:39:26.453] Packages needed by the future expression (n = 1): ‘stats’
[17:39:26.454] Packages needed by future strategies (n = 0): <none>
[17:39:26.454] {
[17:39:26.454]     {
[17:39:26.454]         {
[17:39:26.454]             ...future.startTime <- base::Sys.time()
[17:39:26.454]             {
[17:39:26.454]                 {
[17:39:26.454]                   {
[17:39:26.454]                     {
[17:39:26.454]                       {
[17:39:26.454]                         base::local({
[17:39:26.454]                           has_future <- base::requireNamespace("future", 
[17:39:26.454]                             quietly = TRUE)
[17:39:26.454]                           if (has_future) {
[17:39:26.454]                             ns <- base::getNamespace("future")
[17:39:26.454]                             version <- ns[[".package"]][["version"]]
[17:39:26.454]                             if (is.null(version)) 
[17:39:26.454]                               version <- utils::packageVersion("future")
[17:39:26.454]                           }
[17:39:26.454]                           else {
[17:39:26.454]                             version <- NULL
[17:39:26.454]                           }
[17:39:26.454]                           if (!has_future || version < "1.8.0") {
[17:39:26.454]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.454]                               "", base::R.version$version.string), 
[17:39:26.454]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:26.454]                                 base::R.version$platform, 8 * 
[17:39:26.454]                                   base::.Machine$sizeof.pointer), 
[17:39:26.454]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.454]                                 "release", "version")], collapse = " "), 
[17:39:26.454]                               hostname = base::Sys.info()[["nodename"]])
[17:39:26.454]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.454]                               info)
[17:39:26.454]                             info <- base::paste(info, collapse = "; ")
[17:39:26.454]                             if (!has_future) {
[17:39:26.454]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.454]                                 info)
[17:39:26.454]                             }
[17:39:26.454]                             else {
[17:39:26.454]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.454]                                 info, version)
[17:39:26.454]                             }
[17:39:26.454]                             base::stop(msg)
[17:39:26.454]                           }
[17:39:26.454]                         })
[17:39:26.454]                       }
[17:39:26.454]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.454]                       base::options(mc.cores = 1L)
[17:39:26.454]                     }
[17:39:26.454]                     base::local({
[17:39:26.454]                       for (pkg in "stats") {
[17:39:26.454]                         base::loadNamespace(pkg)
[17:39:26.454]                         base::library(pkg, character.only = TRUE)
[17:39:26.454]                       }
[17:39:26.454]                     })
[17:39:26.454]                   }
[17:39:26.454]                   options(future.plan = NULL)
[17:39:26.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.454]                 }
[17:39:26.454]                 ...future.workdir <- getwd()
[17:39:26.454]             }
[17:39:26.454]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.454]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.454]         }
[17:39:26.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.454]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:26.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.454]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.454]             base::names(...future.oldOptions))
[17:39:26.454]     }
[17:39:26.454]     if (FALSE) {
[17:39:26.454]     }
[17:39:26.454]     else {
[17:39:26.454]         if (TRUE) {
[17:39:26.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.454]                 open = "w")
[17:39:26.454]         }
[17:39:26.454]         else {
[17:39:26.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.454]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.454]         }
[17:39:26.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.454]             base::sink(type = "output", split = FALSE)
[17:39:26.454]             base::close(...future.stdout)
[17:39:26.454]         }, add = TRUE)
[17:39:26.454]     }
[17:39:26.454]     ...future.frame <- base::sys.nframe()
[17:39:26.454]     ...future.conditions <- base::list()
[17:39:26.454]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.454]     if (FALSE) {
[17:39:26.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.454]     }
[17:39:26.454]     ...future.result <- base::tryCatch({
[17:39:26.454]         base::withCallingHandlers({
[17:39:26.454]             ...future.value <- base::withVisible(base::local({
[17:39:26.454]                 withCallingHandlers({
[17:39:26.454]                   {
[17:39:26.454]                     do.call(function(...) {
[17:39:26.454]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.454]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.454]                         ...future.globals.maxSize)) {
[17:39:26.454]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.454]                         on.exit(options(oopts), add = TRUE)
[17:39:26.454]                       }
[17:39:26.454]                       {
[17:39:26.454]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.454]                           FUN = function(jj) {
[17:39:26.454]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.454]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.454]                           })
[17:39:26.454]                       }
[17:39:26.454]                     }, args = future.call.arguments)
[17:39:26.454]                   }
[17:39:26.454]                 }, immediateCondition = function(cond) {
[17:39:26.454]                   save_rds <- function (object, pathname, ...) 
[17:39:26.454]                   {
[17:39:26.454]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.454]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.454]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.454]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.454]                         fi_tmp[["mtime"]])
[17:39:26.454]                     }
[17:39:26.454]                     tryCatch({
[17:39:26.454]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.454]                     }, error = function(ex) {
[17:39:26.454]                       msg <- conditionMessage(ex)
[17:39:26.454]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.454]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.454]                         fi_tmp[["mtime"]], msg)
[17:39:26.454]                       ex$message <- msg
[17:39:26.454]                       stop(ex)
[17:39:26.454]                     })
[17:39:26.454]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.454]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.454]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.454]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.454]                       fi <- file.info(pathname)
[17:39:26.454]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.454]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.454]                         fi[["size"]], fi[["mtime"]])
[17:39:26.454]                       stop(msg)
[17:39:26.454]                     }
[17:39:26.454]                     invisible(pathname)
[17:39:26.454]                   }
[17:39:26.454]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.454]                     rootPath = tempdir()) 
[17:39:26.454]                   {
[17:39:26.454]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.454]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.454]                       tmpdir = path, fileext = ".rds")
[17:39:26.454]                     save_rds(obj, file)
[17:39:26.454]                   }
[17:39:26.454]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.454]                   {
[17:39:26.454]                     inherits <- base::inherits
[17:39:26.454]                     invokeRestart <- base::invokeRestart
[17:39:26.454]                     is.null <- base::is.null
[17:39:26.454]                     muffled <- FALSE
[17:39:26.454]                     if (inherits(cond, "message")) {
[17:39:26.454]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.454]                       if (muffled) 
[17:39:26.454]                         invokeRestart("muffleMessage")
[17:39:26.454]                     }
[17:39:26.454]                     else if (inherits(cond, "warning")) {
[17:39:26.454]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.454]                       if (muffled) 
[17:39:26.454]                         invokeRestart("muffleWarning")
[17:39:26.454]                     }
[17:39:26.454]                     else if (inherits(cond, "condition")) {
[17:39:26.454]                       if (!is.null(pattern)) {
[17:39:26.454]                         computeRestarts <- base::computeRestarts
[17:39:26.454]                         grepl <- base::grepl
[17:39:26.454]                         restarts <- computeRestarts(cond)
[17:39:26.454]                         for (restart in restarts) {
[17:39:26.454]                           name <- restart$name
[17:39:26.454]                           if (is.null(name)) 
[17:39:26.454]                             next
[17:39:26.454]                           if (!grepl(pattern, name)) 
[17:39:26.454]                             next
[17:39:26.454]                           invokeRestart(restart)
[17:39:26.454]                           muffled <- TRUE
[17:39:26.454]                           break
[17:39:26.454]                         }
[17:39:26.454]                       }
[17:39:26.454]                     }
[17:39:26.454]                     invisible(muffled)
[17:39:26.454]                   }
[17:39:26.454]                   muffleCondition(cond)
[17:39:26.454]                 })
[17:39:26.454]             }))
[17:39:26.454]             future::FutureResult(value = ...future.value$value, 
[17:39:26.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.454]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.454]                     ...future.globalenv.names))
[17:39:26.454]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.454]         }, condition = base::local({
[17:39:26.454]             c <- base::c
[17:39:26.454]             inherits <- base::inherits
[17:39:26.454]             invokeRestart <- base::invokeRestart
[17:39:26.454]             length <- base::length
[17:39:26.454]             list <- base::list
[17:39:26.454]             seq.int <- base::seq.int
[17:39:26.454]             signalCondition <- base::signalCondition
[17:39:26.454]             sys.calls <- base::sys.calls
[17:39:26.454]             `[[` <- base::`[[`
[17:39:26.454]             `+` <- base::`+`
[17:39:26.454]             `<<-` <- base::`<<-`
[17:39:26.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.454]                   3L)]
[17:39:26.454]             }
[17:39:26.454]             function(cond) {
[17:39:26.454]                 is_error <- inherits(cond, "error")
[17:39:26.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.454]                   NULL)
[17:39:26.454]                 if (is_error) {
[17:39:26.454]                   sessionInformation <- function() {
[17:39:26.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.454]                       search = base::search(), system = base::Sys.info())
[17:39:26.454]                   }
[17:39:26.454]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.454]                     cond$call), session = sessionInformation(), 
[17:39:26.454]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.454]                   signalCondition(cond)
[17:39:26.454]                 }
[17:39:26.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.454]                 "immediateCondition"))) {
[17:39:26.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.454]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.454]                   if (TRUE && !signal) {
[17:39:26.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.454]                     {
[17:39:26.454]                       inherits <- base::inherits
[17:39:26.454]                       invokeRestart <- base::invokeRestart
[17:39:26.454]                       is.null <- base::is.null
[17:39:26.454]                       muffled <- FALSE
[17:39:26.454]                       if (inherits(cond, "message")) {
[17:39:26.454]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.454]                         if (muffled) 
[17:39:26.454]                           invokeRestart("muffleMessage")
[17:39:26.454]                       }
[17:39:26.454]                       else if (inherits(cond, "warning")) {
[17:39:26.454]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.454]                         if (muffled) 
[17:39:26.454]                           invokeRestart("muffleWarning")
[17:39:26.454]                       }
[17:39:26.454]                       else if (inherits(cond, "condition")) {
[17:39:26.454]                         if (!is.null(pattern)) {
[17:39:26.454]                           computeRestarts <- base::computeRestarts
[17:39:26.454]                           grepl <- base::grepl
[17:39:26.454]                           restarts <- computeRestarts(cond)
[17:39:26.454]                           for (restart in restarts) {
[17:39:26.454]                             name <- restart$name
[17:39:26.454]                             if (is.null(name)) 
[17:39:26.454]                               next
[17:39:26.454]                             if (!grepl(pattern, name)) 
[17:39:26.454]                               next
[17:39:26.454]                             invokeRestart(restart)
[17:39:26.454]                             muffled <- TRUE
[17:39:26.454]                             break
[17:39:26.454]                           }
[17:39:26.454]                         }
[17:39:26.454]                       }
[17:39:26.454]                       invisible(muffled)
[17:39:26.454]                     }
[17:39:26.454]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.454]                   }
[17:39:26.454]                 }
[17:39:26.454]                 else {
[17:39:26.454]                   if (TRUE) {
[17:39:26.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.454]                     {
[17:39:26.454]                       inherits <- base::inherits
[17:39:26.454]                       invokeRestart <- base::invokeRestart
[17:39:26.454]                       is.null <- base::is.null
[17:39:26.454]                       muffled <- FALSE
[17:39:26.454]                       if (inherits(cond, "message")) {
[17:39:26.454]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.454]                         if (muffled) 
[17:39:26.454]                           invokeRestart("muffleMessage")
[17:39:26.454]                       }
[17:39:26.454]                       else if (inherits(cond, "warning")) {
[17:39:26.454]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.454]                         if (muffled) 
[17:39:26.454]                           invokeRestart("muffleWarning")
[17:39:26.454]                       }
[17:39:26.454]                       else if (inherits(cond, "condition")) {
[17:39:26.454]                         if (!is.null(pattern)) {
[17:39:26.454]                           computeRestarts <- base::computeRestarts
[17:39:26.454]                           grepl <- base::grepl
[17:39:26.454]                           restarts <- computeRestarts(cond)
[17:39:26.454]                           for (restart in restarts) {
[17:39:26.454]                             name <- restart$name
[17:39:26.454]                             if (is.null(name)) 
[17:39:26.454]                               next
[17:39:26.454]                             if (!grepl(pattern, name)) 
[17:39:26.454]                               next
[17:39:26.454]                             invokeRestart(restart)
[17:39:26.454]                             muffled <- TRUE
[17:39:26.454]                             break
[17:39:26.454]                           }
[17:39:26.454]                         }
[17:39:26.454]                       }
[17:39:26.454]                       invisible(muffled)
[17:39:26.454]                     }
[17:39:26.454]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.454]                   }
[17:39:26.454]                 }
[17:39:26.454]             }
[17:39:26.454]         }))
[17:39:26.454]     }, error = function(ex) {
[17:39:26.454]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.454]                 ...future.rng), started = ...future.startTime, 
[17:39:26.454]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.454]             version = "1.8"), class = "FutureResult")
[17:39:26.454]     }, finally = {
[17:39:26.454]         if (!identical(...future.workdir, getwd())) 
[17:39:26.454]             setwd(...future.workdir)
[17:39:26.454]         {
[17:39:26.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.454]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.454]             }
[17:39:26.454]             base::options(...future.oldOptions)
[17:39:26.454]             if (.Platform$OS.type == "windows") {
[17:39:26.454]                 old_names <- names(...future.oldEnvVars)
[17:39:26.454]                 envs <- base::Sys.getenv()
[17:39:26.454]                 names <- names(envs)
[17:39:26.454]                 common <- intersect(names, old_names)
[17:39:26.454]                 added <- setdiff(names, old_names)
[17:39:26.454]                 removed <- setdiff(old_names, names)
[17:39:26.454]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.454]                   envs[common]]
[17:39:26.454]                 NAMES <- toupper(changed)
[17:39:26.454]                 args <- list()
[17:39:26.454]                 for (kk in seq_along(NAMES)) {
[17:39:26.454]                   name <- changed[[kk]]
[17:39:26.454]                   NAME <- NAMES[[kk]]
[17:39:26.454]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.454]                     next
[17:39:26.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.454]                 }
[17:39:26.454]                 NAMES <- toupper(added)
[17:39:26.454]                 for (kk in seq_along(NAMES)) {
[17:39:26.454]                   name <- added[[kk]]
[17:39:26.454]                   NAME <- NAMES[[kk]]
[17:39:26.454]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.454]                     next
[17:39:26.454]                   args[[name]] <- ""
[17:39:26.454]                 }
[17:39:26.454]                 NAMES <- toupper(removed)
[17:39:26.454]                 for (kk in seq_along(NAMES)) {
[17:39:26.454]                   name <- removed[[kk]]
[17:39:26.454]                   NAME <- NAMES[[kk]]
[17:39:26.454]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.454]                     next
[17:39:26.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.454]                 }
[17:39:26.454]                 if (length(args) > 0) 
[17:39:26.454]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.454]             }
[17:39:26.454]             else {
[17:39:26.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.454]             }
[17:39:26.454]             {
[17:39:26.454]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.454]                   0L) {
[17:39:26.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.454]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.454]                   base::options(opts)
[17:39:26.454]                 }
[17:39:26.454]                 {
[17:39:26.454]                   {
[17:39:26.454]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.454]                     NULL
[17:39:26.454]                   }
[17:39:26.454]                   options(future.plan = NULL)
[17:39:26.454]                   if (is.na(NA_character_)) 
[17:39:26.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.454]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.454]                     envir = parent.frame()) 
[17:39:26.454]                   {
[17:39:26.454]                     default_workers <- missing(workers)
[17:39:26.454]                     if (is.function(workers)) 
[17:39:26.454]                       workers <- workers()
[17:39:26.454]                     workers <- structure(as.integer(workers), 
[17:39:26.454]                       class = class(workers))
[17:39:26.454]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.454]                       1L)
[17:39:26.454]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.454]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.454]                       if (default_workers) 
[17:39:26.454]                         supportsMulticore(warn = TRUE)
[17:39:26.454]                       return(sequential(..., envir = envir))
[17:39:26.454]                     }
[17:39:26.454]                     oopts <- options(mc.cores = workers)
[17:39:26.454]                     on.exit(options(oopts))
[17:39:26.454]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.454]                       envir = envir)
[17:39:26.454]                     if (!future$lazy) 
[17:39:26.454]                       future <- run(future)
[17:39:26.454]                     invisible(future)
[17:39:26.454]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.454]                 }
[17:39:26.454]             }
[17:39:26.454]         }
[17:39:26.454]     })
[17:39:26.454]     if (TRUE) {
[17:39:26.454]         base::sink(type = "output", split = FALSE)
[17:39:26.454]         if (TRUE) {
[17:39:26.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.454]         }
[17:39:26.454]         else {
[17:39:26.454]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.454]         }
[17:39:26.454]         base::close(...future.stdout)
[17:39:26.454]         ...future.stdout <- NULL
[17:39:26.454]     }
[17:39:26.454]     ...future.result$conditions <- ...future.conditions
[17:39:26.454]     ...future.result$finished <- base::Sys.time()
[17:39:26.454]     ...future.result
[17:39:26.454] }
[17:39:26.458] assign_globals() ...
[17:39:26.458] List of 7
[17:39:26.458]  $ ...future.FUN            :function (x)  
[17:39:26.458]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:26.458]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:26.458]  $ future.call.arguments    : list()
[17:39:26.458]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.458]  $ ...future.elements_ii    :List of 2
[17:39:26.458]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.458]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:26.458]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.458]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:26.458]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.458]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:26.458]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.458]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:26.458]  $ ...future.seeds_ii       : NULL
[17:39:26.458]  $ ...future.globals.maxSize: NULL
[17:39:26.458]  - attr(*, "resolved")= logi FALSE
[17:39:26.458]  - attr(*, "total_size")= num 2320
[17:39:26.458]  - attr(*, "where")=List of 7
[17:39:26.458]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.458]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:39:26.458]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:39:26.458]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.458]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.458]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.458]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.458]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.458]  - attr(*, "already-done")= logi TRUE
[17:39:26.471] - reassign environment for ‘...future.FUN’
[17:39:26.472] - copied ‘...future.FUN’ to environment
[17:39:26.472] - copied ‘breaks’ to environment
[17:39:26.472] - copied ‘wool’ to environment
[17:39:26.472] - copied ‘future.call.arguments’ to environment
[17:39:26.472] - copied ‘...future.elements_ii’ to environment
[17:39:26.472] - copied ‘...future.seeds_ii’ to environment
[17:39:26.472] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.472] assign_globals() ... done
[17:39:26.473] requestCore(): workers = 2
[17:39:26.475] MulticoreFuture started
[17:39:26.476] - Launch lazy future ... done
[17:39:26.476] run() for ‘MulticoreFuture’ ... done
[17:39:26.477] Created future:
[17:39:26.477] plan(): Setting new future strategy stack:
[17:39:26.477] List of future strategies:
[17:39:26.477] 1. sequential:
[17:39:26.477]    - args: function (..., envir = parent.frame())
[17:39:26.477]    - tweaked: FALSE
[17:39:26.477]    - call: NULL
[17:39:26.479] plan(): nbrOfWorkers() = 1
[17:39:26.484] plan(): Setting new future strategy stack:
[17:39:26.484] List of future strategies:
[17:39:26.484] 1. multicore:
[17:39:26.484]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.484]    - tweaked: FALSE
[17:39:26.484]    - call: plan(strategy)
[17:39:26.490] plan(): nbrOfWorkers() = 2
[17:39:26.477] MulticoreFuture:
[17:39:26.477] Label: ‘future_by-2’
[17:39:26.477] Expression:
[17:39:26.477] {
[17:39:26.477]     do.call(function(...) {
[17:39:26.477]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.477]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.477]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.477]             on.exit(options(oopts), add = TRUE)
[17:39:26.477]         }
[17:39:26.477]         {
[17:39:26.477]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.477]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.477]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.477]             })
[17:39:26.477]         }
[17:39:26.477]     }, args = future.call.arguments)
[17:39:26.477] }
[17:39:26.477] Lazy evaluation: FALSE
[17:39:26.477] Asynchronous evaluation: TRUE
[17:39:26.477] Local evaluation: TRUE
[17:39:26.477] Environment: 0x5629710dba40
[17:39:26.477] Capture standard output: TRUE
[17:39:26.477] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.477] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[17:39:26.477] Packages: 1 packages (‘stats’)
[17:39:26.477] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.477] Resolved: FALSE
[17:39:26.477] Value: <not collected>
[17:39:26.477] Conditions captured: <none>
[17:39:26.477] Early signaling: FALSE
[17:39:26.477] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.477] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.491] Chunk #2 of 2 ... DONE
[17:39:26.492] Launching 2 futures (chunks) ... DONE
[17:39:26.492] Resolving 2 futures (chunks) ...
[17:39:26.492] resolve() on list ...
[17:39:26.492]  recursive: 0
[17:39:26.492]  length: 2
[17:39:26.492] 
[17:39:26.493] Future #1
[17:39:26.494] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:26.494] - nx: 2
[17:39:26.495] - relay: TRUE
[17:39:26.495] - stdout: TRUE
[17:39:26.495] - signal: TRUE
[17:39:26.495] - resignal: FALSE
[17:39:26.495] - force: TRUE
[17:39:26.495] - relayed: [n=2] FALSE, FALSE
[17:39:26.495] - queued futures: [n=2] FALSE, FALSE
[17:39:26.496]  - until=1
[17:39:26.496]  - relaying element #1
[17:39:26.496] - relayed: [n=2] TRUE, FALSE
[17:39:26.496] - queued futures: [n=2] TRUE, FALSE
[17:39:26.496] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:26.496]  length: 1 (resolved future 1)
[17:39:26.497] Future #2
[17:39:26.498] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:26.498] - nx: 2
[17:39:26.498] - relay: TRUE
[17:39:26.499] - stdout: TRUE
[17:39:26.499] - signal: TRUE
[17:39:26.499] - resignal: FALSE
[17:39:26.499] - force: TRUE
[17:39:26.499] - relayed: [n=2] TRUE, FALSE
[17:39:26.499] - queued futures: [n=2] TRUE, FALSE
[17:39:26.499]  - until=2
[17:39:26.499]  - relaying element #2
[17:39:26.500] - relayed: [n=2] TRUE, TRUE
[17:39:26.500] - queued futures: [n=2] TRUE, TRUE
[17:39:26.500] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:26.500]  length: 0 (resolved future 2)
[17:39:26.500] Relaying remaining futures
[17:39:26.500] signalConditionsASAP(NULL, pos=0) ...
[17:39:26.500] - nx: 2
[17:39:26.501] - relay: TRUE
[17:39:26.501] - stdout: TRUE
[17:39:26.501] - signal: TRUE
[17:39:26.501] - resignal: FALSE
[17:39:26.501] - force: TRUE
[17:39:26.501] - relayed: [n=2] TRUE, TRUE
[17:39:26.501] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:26.501] - relayed: [n=2] TRUE, TRUE
[17:39:26.501] - queued futures: [n=2] TRUE, TRUE
[17:39:26.502] signalConditionsASAP(NULL, pos=0) ... done
[17:39:26.502] resolve() on list ... DONE
[17:39:26.502]  - Number of value chunks collected: 2
[17:39:26.502] Resolving 2 futures (chunks) ... DONE
[17:39:26.502] Reducing values from 2 chunks ...
[17:39:26.502]  - Number of values collected after concatenation: 3
[17:39:26.502]  - Number of values expected: 3
[17:39:26.503] Reducing values from 2 chunks ... DONE
[17:39:26.503] future_lapply() ... DONE
[17:39:26.503] future_by_internal() ... DONE
[17:39:26.503] future_by_internal() ...
[17:39:26.504] future_lapply() ...
[17:39:26.508] Number of chunks: 2
[17:39:26.509] getGlobalsAndPackagesXApply() ...
[17:39:26.509]  - future.globals: TRUE
[17:39:26.547] getGlobalsAndPackages() ...
[17:39:26.547] Searching for globals...
[17:39:26.549] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:26.549] Searching for globals ... DONE
[17:39:26.549] Resolving globals: FALSE
[17:39:26.549] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:26.550] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:26.550] - globals: [1] ‘FUN’
[17:39:26.550] 
[17:39:26.550] getGlobalsAndPackages() ... DONE
[17:39:26.550]  - globals found/used: [n=1] ‘FUN’
[17:39:26.550]  - needed namespaces: [n=0] 
[17:39:26.550] Finding globals ... DONE
[17:39:26.550]  - use_args: TRUE
[17:39:26.550]  - Getting '...' globals ...
[17:39:26.551] resolve() on list ...
[17:39:26.551]  recursive: 0
[17:39:26.551]  length: 1
[17:39:26.551]  elements: ‘...’
[17:39:26.551]  length: 0 (resolved future 1)
[17:39:26.551] resolve() on list ... DONE
[17:39:26.551]    - '...' content: [n=0] 
[17:39:26.551] List of 1
[17:39:26.551]  $ ...: list()
[17:39:26.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.551]  - attr(*, "where")=List of 1
[17:39:26.551]   ..$ ...:<environment: 0x56297088a0b8> 
[17:39:26.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.551]  - attr(*, "resolved")= logi TRUE
[17:39:26.551]  - attr(*, "total_size")= num NA
[17:39:26.554]  - Getting '...' globals ... DONE
[17:39:26.554] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:26.554] List of 2
[17:39:26.554]  $ ...future.FUN:function (object, ...)  
[17:39:26.554]  $ ...          : list()
[17:39:26.554]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.554]  - attr(*, "where")=List of 2
[17:39:26.554]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:26.554]   ..$ ...          :<environment: 0x56297088a0b8> 
[17:39:26.554]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.554]  - attr(*, "resolved")= logi FALSE
[17:39:26.554]  - attr(*, "total_size")= num 1240
[17:39:26.557] Packages to be attached in all futures: [n=0] 
[17:39:26.557] getGlobalsAndPackagesXApply() ... DONE
[17:39:26.557] Number of futures (= number of chunks): 2
[17:39:26.557] Launching 2 futures (chunks) ...
[17:39:26.557] Chunk #1 of 2 ...
[17:39:26.557]  - Finding globals in 'X' for chunk #1 ...
[17:39:26.558] getGlobalsAndPackages() ...
[17:39:26.558] Searching for globals...
[17:39:26.558] 
[17:39:26.558] Searching for globals ... DONE
[17:39:26.558] - globals: [0] <none>
[17:39:26.558] getGlobalsAndPackages() ... DONE
[17:39:26.558]    + additional globals found: [n=0] 
[17:39:26.558]    + additional namespaces needed: [n=0] 
[17:39:26.559]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:26.559]  - seeds: <none>
[17:39:26.559] getGlobalsAndPackages() ...
[17:39:26.559] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.559] Resolving globals: FALSE
[17:39:26.559] Tweak future expression to call with '...' arguments ...
[17:39:26.559] {
[17:39:26.559]     do.call(function(...) {
[17:39:26.559]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.559]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.559]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.559]             on.exit(options(oopts), add = TRUE)
[17:39:26.559]         }
[17:39:26.559]         {
[17:39:26.559]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.559]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.559]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.559]             })
[17:39:26.559]         }
[17:39:26.559]     }, args = future.call.arguments)
[17:39:26.559] }
[17:39:26.559] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.560] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.560] 
[17:39:26.560] getGlobalsAndPackages() ... DONE
[17:39:26.560] run() for ‘Future’ ...
[17:39:26.560] - state: ‘created’
[17:39:26.561] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.564] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.565]   - Field: ‘label’
[17:39:26.565]   - Field: ‘local’
[17:39:26.565]   - Field: ‘owner’
[17:39:26.565]   - Field: ‘envir’
[17:39:26.565]   - Field: ‘workers’
[17:39:26.565]   - Field: ‘packages’
[17:39:26.565]   - Field: ‘gc’
[17:39:26.565]   - Field: ‘job’
[17:39:26.566]   - Field: ‘conditions’
[17:39:26.566]   - Field: ‘expr’
[17:39:26.566]   - Field: ‘uuid’
[17:39:26.566]   - Field: ‘seed’
[17:39:26.566]   - Field: ‘version’
[17:39:26.566]   - Field: ‘result’
[17:39:26.566]   - Field: ‘asynchronous’
[17:39:26.566]   - Field: ‘calls’
[17:39:26.566]   - Field: ‘globals’
[17:39:26.566]   - Field: ‘stdout’
[17:39:26.566]   - Field: ‘earlySignal’
[17:39:26.567]   - Field: ‘lazy’
[17:39:26.567]   - Field: ‘state’
[17:39:26.567] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.567] - Launch lazy future ...
[17:39:26.567] Packages needed by the future expression (n = 0): <none>
[17:39:26.567] Packages needed by future strategies (n = 0): <none>
[17:39:26.568] {
[17:39:26.568]     {
[17:39:26.568]         {
[17:39:26.568]             ...future.startTime <- base::Sys.time()
[17:39:26.568]             {
[17:39:26.568]                 {
[17:39:26.568]                   {
[17:39:26.568]                     {
[17:39:26.568]                       base::local({
[17:39:26.568]                         has_future <- base::requireNamespace("future", 
[17:39:26.568]                           quietly = TRUE)
[17:39:26.568]                         if (has_future) {
[17:39:26.568]                           ns <- base::getNamespace("future")
[17:39:26.568]                           version <- ns[[".package"]][["version"]]
[17:39:26.568]                           if (is.null(version)) 
[17:39:26.568]                             version <- utils::packageVersion("future")
[17:39:26.568]                         }
[17:39:26.568]                         else {
[17:39:26.568]                           version <- NULL
[17:39:26.568]                         }
[17:39:26.568]                         if (!has_future || version < "1.8.0") {
[17:39:26.568]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.568]                             "", base::R.version$version.string), 
[17:39:26.568]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:26.568]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:26.568]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.568]                               "release", "version")], collapse = " "), 
[17:39:26.568]                             hostname = base::Sys.info()[["nodename"]])
[17:39:26.568]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.568]                             info)
[17:39:26.568]                           info <- base::paste(info, collapse = "; ")
[17:39:26.568]                           if (!has_future) {
[17:39:26.568]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.568]                               info)
[17:39:26.568]                           }
[17:39:26.568]                           else {
[17:39:26.568]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.568]                               info, version)
[17:39:26.568]                           }
[17:39:26.568]                           base::stop(msg)
[17:39:26.568]                         }
[17:39:26.568]                       })
[17:39:26.568]                     }
[17:39:26.568]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.568]                     base::options(mc.cores = 1L)
[17:39:26.568]                   }
[17:39:26.568]                   options(future.plan = NULL)
[17:39:26.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.568]                 }
[17:39:26.568]                 ...future.workdir <- getwd()
[17:39:26.568]             }
[17:39:26.568]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.568]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.568]         }
[17:39:26.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:26.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.568]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.568]             base::names(...future.oldOptions))
[17:39:26.568]     }
[17:39:26.568]     if (FALSE) {
[17:39:26.568]     }
[17:39:26.568]     else {
[17:39:26.568]         if (TRUE) {
[17:39:26.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.568]                 open = "w")
[17:39:26.568]         }
[17:39:26.568]         else {
[17:39:26.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.568]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.568]         }
[17:39:26.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.568]             base::sink(type = "output", split = FALSE)
[17:39:26.568]             base::close(...future.stdout)
[17:39:26.568]         }, add = TRUE)
[17:39:26.568]     }
[17:39:26.568]     ...future.frame <- base::sys.nframe()
[17:39:26.568]     ...future.conditions <- base::list()
[17:39:26.568]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.568]     if (FALSE) {
[17:39:26.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.568]     }
[17:39:26.568]     ...future.result <- base::tryCatch({
[17:39:26.568]         base::withCallingHandlers({
[17:39:26.568]             ...future.value <- base::withVisible(base::local({
[17:39:26.568]                 withCallingHandlers({
[17:39:26.568]                   {
[17:39:26.568]                     do.call(function(...) {
[17:39:26.568]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.568]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.568]                         ...future.globals.maxSize)) {
[17:39:26.568]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.568]                         on.exit(options(oopts), add = TRUE)
[17:39:26.568]                       }
[17:39:26.568]                       {
[17:39:26.568]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.568]                           FUN = function(jj) {
[17:39:26.568]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.568]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.568]                           })
[17:39:26.568]                       }
[17:39:26.568]                     }, args = future.call.arguments)
[17:39:26.568]                   }
[17:39:26.568]                 }, immediateCondition = function(cond) {
[17:39:26.568]                   save_rds <- function (object, pathname, ...) 
[17:39:26.568]                   {
[17:39:26.568]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.568]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.568]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.568]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.568]                         fi_tmp[["mtime"]])
[17:39:26.568]                     }
[17:39:26.568]                     tryCatch({
[17:39:26.568]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.568]                     }, error = function(ex) {
[17:39:26.568]                       msg <- conditionMessage(ex)
[17:39:26.568]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.568]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.568]                         fi_tmp[["mtime"]], msg)
[17:39:26.568]                       ex$message <- msg
[17:39:26.568]                       stop(ex)
[17:39:26.568]                     })
[17:39:26.568]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.568]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.568]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.568]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.568]                       fi <- file.info(pathname)
[17:39:26.568]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.568]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.568]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.568]                         fi[["size"]], fi[["mtime"]])
[17:39:26.568]                       stop(msg)
[17:39:26.568]                     }
[17:39:26.568]                     invisible(pathname)
[17:39:26.568]                   }
[17:39:26.568]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.568]                     rootPath = tempdir()) 
[17:39:26.568]                   {
[17:39:26.568]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.568]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.568]                       tmpdir = path, fileext = ".rds")
[17:39:26.568]                     save_rds(obj, file)
[17:39:26.568]                   }
[17:39:26.568]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.568]                   {
[17:39:26.568]                     inherits <- base::inherits
[17:39:26.568]                     invokeRestart <- base::invokeRestart
[17:39:26.568]                     is.null <- base::is.null
[17:39:26.568]                     muffled <- FALSE
[17:39:26.568]                     if (inherits(cond, "message")) {
[17:39:26.568]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.568]                       if (muffled) 
[17:39:26.568]                         invokeRestart("muffleMessage")
[17:39:26.568]                     }
[17:39:26.568]                     else if (inherits(cond, "warning")) {
[17:39:26.568]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.568]                       if (muffled) 
[17:39:26.568]                         invokeRestart("muffleWarning")
[17:39:26.568]                     }
[17:39:26.568]                     else if (inherits(cond, "condition")) {
[17:39:26.568]                       if (!is.null(pattern)) {
[17:39:26.568]                         computeRestarts <- base::computeRestarts
[17:39:26.568]                         grepl <- base::grepl
[17:39:26.568]                         restarts <- computeRestarts(cond)
[17:39:26.568]                         for (restart in restarts) {
[17:39:26.568]                           name <- restart$name
[17:39:26.568]                           if (is.null(name)) 
[17:39:26.568]                             next
[17:39:26.568]                           if (!grepl(pattern, name)) 
[17:39:26.568]                             next
[17:39:26.568]                           invokeRestart(restart)
[17:39:26.568]                           muffled <- TRUE
[17:39:26.568]                           break
[17:39:26.568]                         }
[17:39:26.568]                       }
[17:39:26.568]                     }
[17:39:26.568]                     invisible(muffled)
[17:39:26.568]                   }
[17:39:26.568]                   muffleCondition(cond)
[17:39:26.568]                 })
[17:39:26.568]             }))
[17:39:26.568]             future::FutureResult(value = ...future.value$value, 
[17:39:26.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.568]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.568]                     ...future.globalenv.names))
[17:39:26.568]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.568]         }, condition = base::local({
[17:39:26.568]             c <- base::c
[17:39:26.568]             inherits <- base::inherits
[17:39:26.568]             invokeRestart <- base::invokeRestart
[17:39:26.568]             length <- base::length
[17:39:26.568]             list <- base::list
[17:39:26.568]             seq.int <- base::seq.int
[17:39:26.568]             signalCondition <- base::signalCondition
[17:39:26.568]             sys.calls <- base::sys.calls
[17:39:26.568]             `[[` <- base::`[[`
[17:39:26.568]             `+` <- base::`+`
[17:39:26.568]             `<<-` <- base::`<<-`
[17:39:26.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.568]                   3L)]
[17:39:26.568]             }
[17:39:26.568]             function(cond) {
[17:39:26.568]                 is_error <- inherits(cond, "error")
[17:39:26.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.568]                   NULL)
[17:39:26.568]                 if (is_error) {
[17:39:26.568]                   sessionInformation <- function() {
[17:39:26.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.568]                       search = base::search(), system = base::Sys.info())
[17:39:26.568]                   }
[17:39:26.568]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.568]                     cond$call), session = sessionInformation(), 
[17:39:26.568]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.568]                   signalCondition(cond)
[17:39:26.568]                 }
[17:39:26.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.568]                 "immediateCondition"))) {
[17:39:26.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.568]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.568]                   if (TRUE && !signal) {
[17:39:26.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.568]                     {
[17:39:26.568]                       inherits <- base::inherits
[17:39:26.568]                       invokeRestart <- base::invokeRestart
[17:39:26.568]                       is.null <- base::is.null
[17:39:26.568]                       muffled <- FALSE
[17:39:26.568]                       if (inherits(cond, "message")) {
[17:39:26.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.568]                         if (muffled) 
[17:39:26.568]                           invokeRestart("muffleMessage")
[17:39:26.568]                       }
[17:39:26.568]                       else if (inherits(cond, "warning")) {
[17:39:26.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.568]                         if (muffled) 
[17:39:26.568]                           invokeRestart("muffleWarning")
[17:39:26.568]                       }
[17:39:26.568]                       else if (inherits(cond, "condition")) {
[17:39:26.568]                         if (!is.null(pattern)) {
[17:39:26.568]                           computeRestarts <- base::computeRestarts
[17:39:26.568]                           grepl <- base::grepl
[17:39:26.568]                           restarts <- computeRestarts(cond)
[17:39:26.568]                           for (restart in restarts) {
[17:39:26.568]                             name <- restart$name
[17:39:26.568]                             if (is.null(name)) 
[17:39:26.568]                               next
[17:39:26.568]                             if (!grepl(pattern, name)) 
[17:39:26.568]                               next
[17:39:26.568]                             invokeRestart(restart)
[17:39:26.568]                             muffled <- TRUE
[17:39:26.568]                             break
[17:39:26.568]                           }
[17:39:26.568]                         }
[17:39:26.568]                       }
[17:39:26.568]                       invisible(muffled)
[17:39:26.568]                     }
[17:39:26.568]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.568]                   }
[17:39:26.568]                 }
[17:39:26.568]                 else {
[17:39:26.568]                   if (TRUE) {
[17:39:26.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.568]                     {
[17:39:26.568]                       inherits <- base::inherits
[17:39:26.568]                       invokeRestart <- base::invokeRestart
[17:39:26.568]                       is.null <- base::is.null
[17:39:26.568]                       muffled <- FALSE
[17:39:26.568]                       if (inherits(cond, "message")) {
[17:39:26.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.568]                         if (muffled) 
[17:39:26.568]                           invokeRestart("muffleMessage")
[17:39:26.568]                       }
[17:39:26.568]                       else if (inherits(cond, "warning")) {
[17:39:26.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.568]                         if (muffled) 
[17:39:26.568]                           invokeRestart("muffleWarning")
[17:39:26.568]                       }
[17:39:26.568]                       else if (inherits(cond, "condition")) {
[17:39:26.568]                         if (!is.null(pattern)) {
[17:39:26.568]                           computeRestarts <- base::computeRestarts
[17:39:26.568]                           grepl <- base::grepl
[17:39:26.568]                           restarts <- computeRestarts(cond)
[17:39:26.568]                           for (restart in restarts) {
[17:39:26.568]                             name <- restart$name
[17:39:26.568]                             if (is.null(name)) 
[17:39:26.568]                               next
[17:39:26.568]                             if (!grepl(pattern, name)) 
[17:39:26.568]                               next
[17:39:26.568]                             invokeRestart(restart)
[17:39:26.568]                             muffled <- TRUE
[17:39:26.568]                             break
[17:39:26.568]                           }
[17:39:26.568]                         }
[17:39:26.568]                       }
[17:39:26.568]                       invisible(muffled)
[17:39:26.568]                     }
[17:39:26.568]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.568]                   }
[17:39:26.568]                 }
[17:39:26.568]             }
[17:39:26.568]         }))
[17:39:26.568]     }, error = function(ex) {
[17:39:26.568]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.568]                 ...future.rng), started = ...future.startTime, 
[17:39:26.568]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.568]             version = "1.8"), class = "FutureResult")
[17:39:26.568]     }, finally = {
[17:39:26.568]         if (!identical(...future.workdir, getwd())) 
[17:39:26.568]             setwd(...future.workdir)
[17:39:26.568]         {
[17:39:26.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.568]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.568]             }
[17:39:26.568]             base::options(...future.oldOptions)
[17:39:26.568]             if (.Platform$OS.type == "windows") {
[17:39:26.568]                 old_names <- names(...future.oldEnvVars)
[17:39:26.568]                 envs <- base::Sys.getenv()
[17:39:26.568]                 names <- names(envs)
[17:39:26.568]                 common <- intersect(names, old_names)
[17:39:26.568]                 added <- setdiff(names, old_names)
[17:39:26.568]                 removed <- setdiff(old_names, names)
[17:39:26.568]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.568]                   envs[common]]
[17:39:26.568]                 NAMES <- toupper(changed)
[17:39:26.568]                 args <- list()
[17:39:26.568]                 for (kk in seq_along(NAMES)) {
[17:39:26.568]                   name <- changed[[kk]]
[17:39:26.568]                   NAME <- NAMES[[kk]]
[17:39:26.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.568]                     next
[17:39:26.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.568]                 }
[17:39:26.568]                 NAMES <- toupper(added)
[17:39:26.568]                 for (kk in seq_along(NAMES)) {
[17:39:26.568]                   name <- added[[kk]]
[17:39:26.568]                   NAME <- NAMES[[kk]]
[17:39:26.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.568]                     next
[17:39:26.568]                   args[[name]] <- ""
[17:39:26.568]                 }
[17:39:26.568]                 NAMES <- toupper(removed)
[17:39:26.568]                 for (kk in seq_along(NAMES)) {
[17:39:26.568]                   name <- removed[[kk]]
[17:39:26.568]                   NAME <- NAMES[[kk]]
[17:39:26.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.568]                     next
[17:39:26.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.568]                 }
[17:39:26.568]                 if (length(args) > 0) 
[17:39:26.568]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.568]             }
[17:39:26.568]             else {
[17:39:26.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.568]             }
[17:39:26.568]             {
[17:39:26.568]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.568]                   0L) {
[17:39:26.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.568]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.568]                   base::options(opts)
[17:39:26.568]                 }
[17:39:26.568]                 {
[17:39:26.568]                   {
[17:39:26.568]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.568]                     NULL
[17:39:26.568]                   }
[17:39:26.568]                   options(future.plan = NULL)
[17:39:26.568]                   if (is.na(NA_character_)) 
[17:39:26.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.568]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.568]                     envir = parent.frame()) 
[17:39:26.568]                   {
[17:39:26.568]                     default_workers <- missing(workers)
[17:39:26.568]                     if (is.function(workers)) 
[17:39:26.568]                       workers <- workers()
[17:39:26.568]                     workers <- structure(as.integer(workers), 
[17:39:26.568]                       class = class(workers))
[17:39:26.568]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.568]                       1L)
[17:39:26.568]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.568]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.568]                       if (default_workers) 
[17:39:26.568]                         supportsMulticore(warn = TRUE)
[17:39:26.568]                       return(sequential(..., envir = envir))
[17:39:26.568]                     }
[17:39:26.568]                     oopts <- options(mc.cores = workers)
[17:39:26.568]                     on.exit(options(oopts))
[17:39:26.568]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.568]                       envir = envir)
[17:39:26.568]                     if (!future$lazy) 
[17:39:26.568]                       future <- run(future)
[17:39:26.568]                     invisible(future)
[17:39:26.568]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.568]                 }
[17:39:26.568]             }
[17:39:26.568]         }
[17:39:26.568]     })
[17:39:26.568]     if (TRUE) {
[17:39:26.568]         base::sink(type = "output", split = FALSE)
[17:39:26.568]         if (TRUE) {
[17:39:26.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.568]         }
[17:39:26.568]         else {
[17:39:26.568]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.568]         }
[17:39:26.568]         base::close(...future.stdout)
[17:39:26.568]         ...future.stdout <- NULL
[17:39:26.568]     }
[17:39:26.568]     ...future.result$conditions <- ...future.conditions
[17:39:26.568]     ...future.result$finished <- base::Sys.time()
[17:39:26.568]     ...future.result
[17:39:26.568] }
[17:39:26.570] assign_globals() ...
[17:39:26.570] List of 5
[17:39:26.570]  $ ...future.FUN            :function (object, ...)  
[17:39:26.570]  $ future.call.arguments    : list()
[17:39:26.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.570]  $ ...future.elements_ii    :List of 1
[17:39:26.570]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.570]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:26.570]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.570]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:26.570]  $ ...future.seeds_ii       : NULL
[17:39:26.570]  $ ...future.globals.maxSize: NULL
[17:39:26.570]  - attr(*, "where")=List of 5
[17:39:26.570]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.570]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.570]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.570]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.570]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.570]  - attr(*, "resolved")= logi FALSE
[17:39:26.570]  - attr(*, "total_size")= num 1240
[17:39:26.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.570]  - attr(*, "already-done")= logi TRUE
[17:39:26.576] - copied ‘...future.FUN’ to environment
[17:39:26.576] - copied ‘future.call.arguments’ to environment
[17:39:26.577] - copied ‘...future.elements_ii’ to environment
[17:39:26.577] - copied ‘...future.seeds_ii’ to environment
[17:39:26.577] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.577] assign_globals() ... done
[17:39:26.577] requestCore(): workers = 2
[17:39:26.579] MulticoreFuture started
[17:39:26.580] - Launch lazy future ... done
[17:39:26.580] run() for ‘MulticoreFuture’ ... done
[17:39:26.580] Created future:
[17:39:26.581] plan(): Setting new future strategy stack:
[17:39:26.581] List of future strategies:
[17:39:26.581] 1. sequential:
[17:39:26.581]    - args: function (..., envir = parent.frame())
[17:39:26.581]    - tweaked: FALSE
[17:39:26.581]    - call: NULL
[17:39:26.582] plan(): nbrOfWorkers() = 1
[17:39:26.585] plan(): Setting new future strategy stack:
[17:39:26.585] List of future strategies:
[17:39:26.585] 1. multicore:
[17:39:26.585]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.585]    - tweaked: FALSE
[17:39:26.585]    - call: plan(strategy)
[17:39:26.591] plan(): nbrOfWorkers() = 2
[17:39:26.580] MulticoreFuture:
[17:39:26.580] Label: ‘future_by-1’
[17:39:26.580] Expression:
[17:39:26.580] {
[17:39:26.580]     do.call(function(...) {
[17:39:26.580]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.580]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.580]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.580]             on.exit(options(oopts), add = TRUE)
[17:39:26.580]         }
[17:39:26.580]         {
[17:39:26.580]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.580]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.580]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.580]             })
[17:39:26.580]         }
[17:39:26.580]     }, args = future.call.arguments)
[17:39:26.580] }
[17:39:26.580] Lazy evaluation: FALSE
[17:39:26.580] Asynchronous evaluation: TRUE
[17:39:26.580] Local evaluation: TRUE
[17:39:26.580] Environment: 0x5629707fed20
[17:39:26.580] Capture standard output: TRUE
[17:39:26.580] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.580] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.580] Packages: <none>
[17:39:26.580] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.580] Resolved: TRUE
[17:39:26.580] Value: <not collected>
[17:39:26.580] Conditions captured: <none>
[17:39:26.580] Early signaling: FALSE
[17:39:26.580] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.580] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.592] Chunk #1 of 2 ... DONE
[17:39:26.592] Chunk #2 of 2 ...
[17:39:26.592]  - Finding globals in 'X' for chunk #2 ...
[17:39:26.592] getGlobalsAndPackages() ...
[17:39:26.592] Searching for globals...
[17:39:26.593] 
[17:39:26.593] Searching for globals ... DONE
[17:39:26.593] - globals: [0] <none>
[17:39:26.593] getGlobalsAndPackages() ... DONE
[17:39:26.594]    + additional globals found: [n=0] 
[17:39:26.594]    + additional namespaces needed: [n=0] 
[17:39:26.594]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:26.594]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:26.594]  - seeds: <none>
[17:39:26.594] getGlobalsAndPackages() ...
[17:39:26.594] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.595] Resolving globals: FALSE
[17:39:26.595] Tweak future expression to call with '...' arguments ...
[17:39:26.595] {
[17:39:26.595]     do.call(function(...) {
[17:39:26.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.595]             on.exit(options(oopts), add = TRUE)
[17:39:26.595]         }
[17:39:26.595]         {
[17:39:26.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.595]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.595]             })
[17:39:26.595]         }
[17:39:26.595]     }, args = future.call.arguments)
[17:39:26.595] }
[17:39:26.595] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.596] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.596] 
[17:39:26.596] getGlobalsAndPackages() ... DONE
[17:39:26.597] run() for ‘Future’ ...
[17:39:26.597] - state: ‘created’
[17:39:26.597] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.602] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.602] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.602]   - Field: ‘label’
[17:39:26.602]   - Field: ‘local’
[17:39:26.602]   - Field: ‘owner’
[17:39:26.603]   - Field: ‘envir’
[17:39:26.603]   - Field: ‘workers’
[17:39:26.603]   - Field: ‘packages’
[17:39:26.603]   - Field: ‘gc’
[17:39:26.603]   - Field: ‘job’
[17:39:26.603]   - Field: ‘conditions’
[17:39:26.603]   - Field: ‘expr’
[17:39:26.604]   - Field: ‘uuid’
[17:39:26.604]   - Field: ‘seed’
[17:39:26.604]   - Field: ‘version’
[17:39:26.604]   - Field: ‘result’
[17:39:26.604]   - Field: ‘asynchronous’
[17:39:26.604]   - Field: ‘calls’
[17:39:26.604]   - Field: ‘globals’
[17:39:26.604]   - Field: ‘stdout’
[17:39:26.605]   - Field: ‘earlySignal’
[17:39:26.605]   - Field: ‘lazy’
[17:39:26.605]   - Field: ‘state’
[17:39:26.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.605] - Launch lazy future ...
[17:39:26.606] Packages needed by the future expression (n = 0): <none>
[17:39:26.606] Packages needed by future strategies (n = 0): <none>
[17:39:26.606] {
[17:39:26.606]     {
[17:39:26.606]         {
[17:39:26.606]             ...future.startTime <- base::Sys.time()
[17:39:26.606]             {
[17:39:26.606]                 {
[17:39:26.606]                   {
[17:39:26.606]                     {
[17:39:26.606]                       base::local({
[17:39:26.606]                         has_future <- base::requireNamespace("future", 
[17:39:26.606]                           quietly = TRUE)
[17:39:26.606]                         if (has_future) {
[17:39:26.606]                           ns <- base::getNamespace("future")
[17:39:26.606]                           version <- ns[[".package"]][["version"]]
[17:39:26.606]                           if (is.null(version)) 
[17:39:26.606]                             version <- utils::packageVersion("future")
[17:39:26.606]                         }
[17:39:26.606]                         else {
[17:39:26.606]                           version <- NULL
[17:39:26.606]                         }
[17:39:26.606]                         if (!has_future || version < "1.8.0") {
[17:39:26.606]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.606]                             "", base::R.version$version.string), 
[17:39:26.606]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:26.606]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:26.606]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.606]                               "release", "version")], collapse = " "), 
[17:39:26.606]                             hostname = base::Sys.info()[["nodename"]])
[17:39:26.606]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.606]                             info)
[17:39:26.606]                           info <- base::paste(info, collapse = "; ")
[17:39:26.606]                           if (!has_future) {
[17:39:26.606]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.606]                               info)
[17:39:26.606]                           }
[17:39:26.606]                           else {
[17:39:26.606]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.606]                               info, version)
[17:39:26.606]                           }
[17:39:26.606]                           base::stop(msg)
[17:39:26.606]                         }
[17:39:26.606]                       })
[17:39:26.606]                     }
[17:39:26.606]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.606]                     base::options(mc.cores = 1L)
[17:39:26.606]                   }
[17:39:26.606]                   options(future.plan = NULL)
[17:39:26.606]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.606]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.606]                 }
[17:39:26.606]                 ...future.workdir <- getwd()
[17:39:26.606]             }
[17:39:26.606]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.606]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.606]         }
[17:39:26.606]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.606]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:26.606]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.606]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.606]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.606]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.606]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.606]             base::names(...future.oldOptions))
[17:39:26.606]     }
[17:39:26.606]     if (FALSE) {
[17:39:26.606]     }
[17:39:26.606]     else {
[17:39:26.606]         if (TRUE) {
[17:39:26.606]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.606]                 open = "w")
[17:39:26.606]         }
[17:39:26.606]         else {
[17:39:26.606]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.606]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.606]         }
[17:39:26.606]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.606]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.606]             base::sink(type = "output", split = FALSE)
[17:39:26.606]             base::close(...future.stdout)
[17:39:26.606]         }, add = TRUE)
[17:39:26.606]     }
[17:39:26.606]     ...future.frame <- base::sys.nframe()
[17:39:26.606]     ...future.conditions <- base::list()
[17:39:26.606]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.606]     if (FALSE) {
[17:39:26.606]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.606]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.606]     }
[17:39:26.606]     ...future.result <- base::tryCatch({
[17:39:26.606]         base::withCallingHandlers({
[17:39:26.606]             ...future.value <- base::withVisible(base::local({
[17:39:26.606]                 withCallingHandlers({
[17:39:26.606]                   {
[17:39:26.606]                     do.call(function(...) {
[17:39:26.606]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.606]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.606]                         ...future.globals.maxSize)) {
[17:39:26.606]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.606]                         on.exit(options(oopts), add = TRUE)
[17:39:26.606]                       }
[17:39:26.606]                       {
[17:39:26.606]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.606]                           FUN = function(jj) {
[17:39:26.606]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.606]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.606]                           })
[17:39:26.606]                       }
[17:39:26.606]                     }, args = future.call.arguments)
[17:39:26.606]                   }
[17:39:26.606]                 }, immediateCondition = function(cond) {
[17:39:26.606]                   save_rds <- function (object, pathname, ...) 
[17:39:26.606]                   {
[17:39:26.606]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.606]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.606]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.606]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.606]                         fi_tmp[["mtime"]])
[17:39:26.606]                     }
[17:39:26.606]                     tryCatch({
[17:39:26.606]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.606]                     }, error = function(ex) {
[17:39:26.606]                       msg <- conditionMessage(ex)
[17:39:26.606]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.606]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.606]                         fi_tmp[["mtime"]], msg)
[17:39:26.606]                       ex$message <- msg
[17:39:26.606]                       stop(ex)
[17:39:26.606]                     })
[17:39:26.606]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.606]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.606]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.606]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.606]                       fi <- file.info(pathname)
[17:39:26.606]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.606]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.606]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.606]                         fi[["size"]], fi[["mtime"]])
[17:39:26.606]                       stop(msg)
[17:39:26.606]                     }
[17:39:26.606]                     invisible(pathname)
[17:39:26.606]                   }
[17:39:26.606]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.606]                     rootPath = tempdir()) 
[17:39:26.606]                   {
[17:39:26.606]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.606]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.606]                       tmpdir = path, fileext = ".rds")
[17:39:26.606]                     save_rds(obj, file)
[17:39:26.606]                   }
[17:39:26.606]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.606]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.606]                   {
[17:39:26.606]                     inherits <- base::inherits
[17:39:26.606]                     invokeRestart <- base::invokeRestart
[17:39:26.606]                     is.null <- base::is.null
[17:39:26.606]                     muffled <- FALSE
[17:39:26.606]                     if (inherits(cond, "message")) {
[17:39:26.606]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.606]                       if (muffled) 
[17:39:26.606]                         invokeRestart("muffleMessage")
[17:39:26.606]                     }
[17:39:26.606]                     else if (inherits(cond, "warning")) {
[17:39:26.606]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.606]                       if (muffled) 
[17:39:26.606]                         invokeRestart("muffleWarning")
[17:39:26.606]                     }
[17:39:26.606]                     else if (inherits(cond, "condition")) {
[17:39:26.606]                       if (!is.null(pattern)) {
[17:39:26.606]                         computeRestarts <- base::computeRestarts
[17:39:26.606]                         grepl <- base::grepl
[17:39:26.606]                         restarts <- computeRestarts(cond)
[17:39:26.606]                         for (restart in restarts) {
[17:39:26.606]                           name <- restart$name
[17:39:26.606]                           if (is.null(name)) 
[17:39:26.606]                             next
[17:39:26.606]                           if (!grepl(pattern, name)) 
[17:39:26.606]                             next
[17:39:26.606]                           invokeRestart(restart)
[17:39:26.606]                           muffled <- TRUE
[17:39:26.606]                           break
[17:39:26.606]                         }
[17:39:26.606]                       }
[17:39:26.606]                     }
[17:39:26.606]                     invisible(muffled)
[17:39:26.606]                   }
[17:39:26.606]                   muffleCondition(cond)
[17:39:26.606]                 })
[17:39:26.606]             }))
[17:39:26.606]             future::FutureResult(value = ...future.value$value, 
[17:39:26.606]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.606]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.606]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.606]                     ...future.globalenv.names))
[17:39:26.606]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.606]         }, condition = base::local({
[17:39:26.606]             c <- base::c
[17:39:26.606]             inherits <- base::inherits
[17:39:26.606]             invokeRestart <- base::invokeRestart
[17:39:26.606]             length <- base::length
[17:39:26.606]             list <- base::list
[17:39:26.606]             seq.int <- base::seq.int
[17:39:26.606]             signalCondition <- base::signalCondition
[17:39:26.606]             sys.calls <- base::sys.calls
[17:39:26.606]             `[[` <- base::`[[`
[17:39:26.606]             `+` <- base::`+`
[17:39:26.606]             `<<-` <- base::`<<-`
[17:39:26.606]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.606]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.606]                   3L)]
[17:39:26.606]             }
[17:39:26.606]             function(cond) {
[17:39:26.606]                 is_error <- inherits(cond, "error")
[17:39:26.606]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.606]                   NULL)
[17:39:26.606]                 if (is_error) {
[17:39:26.606]                   sessionInformation <- function() {
[17:39:26.606]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.606]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.606]                       search = base::search(), system = base::Sys.info())
[17:39:26.606]                   }
[17:39:26.606]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.606]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.606]                     cond$call), session = sessionInformation(), 
[17:39:26.606]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.606]                   signalCondition(cond)
[17:39:26.606]                 }
[17:39:26.606]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.606]                 "immediateCondition"))) {
[17:39:26.606]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.606]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.606]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.606]                   if (TRUE && !signal) {
[17:39:26.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.606]                     {
[17:39:26.606]                       inherits <- base::inherits
[17:39:26.606]                       invokeRestart <- base::invokeRestart
[17:39:26.606]                       is.null <- base::is.null
[17:39:26.606]                       muffled <- FALSE
[17:39:26.606]                       if (inherits(cond, "message")) {
[17:39:26.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.606]                         if (muffled) 
[17:39:26.606]                           invokeRestart("muffleMessage")
[17:39:26.606]                       }
[17:39:26.606]                       else if (inherits(cond, "warning")) {
[17:39:26.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.606]                         if (muffled) 
[17:39:26.606]                           invokeRestart("muffleWarning")
[17:39:26.606]                       }
[17:39:26.606]                       else if (inherits(cond, "condition")) {
[17:39:26.606]                         if (!is.null(pattern)) {
[17:39:26.606]                           computeRestarts <- base::computeRestarts
[17:39:26.606]                           grepl <- base::grepl
[17:39:26.606]                           restarts <- computeRestarts(cond)
[17:39:26.606]                           for (restart in restarts) {
[17:39:26.606]                             name <- restart$name
[17:39:26.606]                             if (is.null(name)) 
[17:39:26.606]                               next
[17:39:26.606]                             if (!grepl(pattern, name)) 
[17:39:26.606]                               next
[17:39:26.606]                             invokeRestart(restart)
[17:39:26.606]                             muffled <- TRUE
[17:39:26.606]                             break
[17:39:26.606]                           }
[17:39:26.606]                         }
[17:39:26.606]                       }
[17:39:26.606]                       invisible(muffled)
[17:39:26.606]                     }
[17:39:26.606]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.606]                   }
[17:39:26.606]                 }
[17:39:26.606]                 else {
[17:39:26.606]                   if (TRUE) {
[17:39:26.606]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.606]                     {
[17:39:26.606]                       inherits <- base::inherits
[17:39:26.606]                       invokeRestart <- base::invokeRestart
[17:39:26.606]                       is.null <- base::is.null
[17:39:26.606]                       muffled <- FALSE
[17:39:26.606]                       if (inherits(cond, "message")) {
[17:39:26.606]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.606]                         if (muffled) 
[17:39:26.606]                           invokeRestart("muffleMessage")
[17:39:26.606]                       }
[17:39:26.606]                       else if (inherits(cond, "warning")) {
[17:39:26.606]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.606]                         if (muffled) 
[17:39:26.606]                           invokeRestart("muffleWarning")
[17:39:26.606]                       }
[17:39:26.606]                       else if (inherits(cond, "condition")) {
[17:39:26.606]                         if (!is.null(pattern)) {
[17:39:26.606]                           computeRestarts <- base::computeRestarts
[17:39:26.606]                           grepl <- base::grepl
[17:39:26.606]                           restarts <- computeRestarts(cond)
[17:39:26.606]                           for (restart in restarts) {
[17:39:26.606]                             name <- restart$name
[17:39:26.606]                             if (is.null(name)) 
[17:39:26.606]                               next
[17:39:26.606]                             if (!grepl(pattern, name)) 
[17:39:26.606]                               next
[17:39:26.606]                             invokeRestart(restart)
[17:39:26.606]                             muffled <- TRUE
[17:39:26.606]                             break
[17:39:26.606]                           }
[17:39:26.606]                         }
[17:39:26.606]                       }
[17:39:26.606]                       invisible(muffled)
[17:39:26.606]                     }
[17:39:26.606]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.606]                   }
[17:39:26.606]                 }
[17:39:26.606]             }
[17:39:26.606]         }))
[17:39:26.606]     }, error = function(ex) {
[17:39:26.606]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.606]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.606]                 ...future.rng), started = ...future.startTime, 
[17:39:26.606]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.606]             version = "1.8"), class = "FutureResult")
[17:39:26.606]     }, finally = {
[17:39:26.606]         if (!identical(...future.workdir, getwd())) 
[17:39:26.606]             setwd(...future.workdir)
[17:39:26.606]         {
[17:39:26.606]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.606]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.606]             }
[17:39:26.606]             base::options(...future.oldOptions)
[17:39:26.606]             if (.Platform$OS.type == "windows") {
[17:39:26.606]                 old_names <- names(...future.oldEnvVars)
[17:39:26.606]                 envs <- base::Sys.getenv()
[17:39:26.606]                 names <- names(envs)
[17:39:26.606]                 common <- intersect(names, old_names)
[17:39:26.606]                 added <- setdiff(names, old_names)
[17:39:26.606]                 removed <- setdiff(old_names, names)
[17:39:26.606]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.606]                   envs[common]]
[17:39:26.606]                 NAMES <- toupper(changed)
[17:39:26.606]                 args <- list()
[17:39:26.606]                 for (kk in seq_along(NAMES)) {
[17:39:26.606]                   name <- changed[[kk]]
[17:39:26.606]                   NAME <- NAMES[[kk]]
[17:39:26.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.606]                     next
[17:39:26.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.606]                 }
[17:39:26.606]                 NAMES <- toupper(added)
[17:39:26.606]                 for (kk in seq_along(NAMES)) {
[17:39:26.606]                   name <- added[[kk]]
[17:39:26.606]                   NAME <- NAMES[[kk]]
[17:39:26.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.606]                     next
[17:39:26.606]                   args[[name]] <- ""
[17:39:26.606]                 }
[17:39:26.606]                 NAMES <- toupper(removed)
[17:39:26.606]                 for (kk in seq_along(NAMES)) {
[17:39:26.606]                   name <- removed[[kk]]
[17:39:26.606]                   NAME <- NAMES[[kk]]
[17:39:26.606]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.606]                     next
[17:39:26.606]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.606]                 }
[17:39:26.606]                 if (length(args) > 0) 
[17:39:26.606]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.606]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.606]             }
[17:39:26.606]             else {
[17:39:26.606]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.606]             }
[17:39:26.606]             {
[17:39:26.606]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.606]                   0L) {
[17:39:26.606]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.606]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.606]                   base::options(opts)
[17:39:26.606]                 }
[17:39:26.606]                 {
[17:39:26.606]                   {
[17:39:26.606]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.606]                     NULL
[17:39:26.606]                   }
[17:39:26.606]                   options(future.plan = NULL)
[17:39:26.606]                   if (is.na(NA_character_)) 
[17:39:26.606]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.606]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.606]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.606]                     envir = parent.frame()) 
[17:39:26.606]                   {
[17:39:26.606]                     default_workers <- missing(workers)
[17:39:26.606]                     if (is.function(workers)) 
[17:39:26.606]                       workers <- workers()
[17:39:26.606]                     workers <- structure(as.integer(workers), 
[17:39:26.606]                       class = class(workers))
[17:39:26.606]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.606]                       1L)
[17:39:26.606]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.606]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.606]                       if (default_workers) 
[17:39:26.606]                         supportsMulticore(warn = TRUE)
[17:39:26.606]                       return(sequential(..., envir = envir))
[17:39:26.606]                     }
[17:39:26.606]                     oopts <- options(mc.cores = workers)
[17:39:26.606]                     on.exit(options(oopts))
[17:39:26.606]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.606]                       envir = envir)
[17:39:26.606]                     if (!future$lazy) 
[17:39:26.606]                       future <- run(future)
[17:39:26.606]                     invisible(future)
[17:39:26.606]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.606]                 }
[17:39:26.606]             }
[17:39:26.606]         }
[17:39:26.606]     })
[17:39:26.606]     if (TRUE) {
[17:39:26.606]         base::sink(type = "output", split = FALSE)
[17:39:26.606]         if (TRUE) {
[17:39:26.606]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.606]         }
[17:39:26.606]         else {
[17:39:26.606]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.606]         }
[17:39:26.606]         base::close(...future.stdout)
[17:39:26.606]         ...future.stdout <- NULL
[17:39:26.606]     }
[17:39:26.606]     ...future.result$conditions <- ...future.conditions
[17:39:26.606]     ...future.result$finished <- base::Sys.time()
[17:39:26.606]     ...future.result
[17:39:26.606] }
[17:39:26.610] assign_globals() ...
[17:39:26.610] List of 5
[17:39:26.610]  $ ...future.FUN            :function (object, ...)  
[17:39:26.610]  $ future.call.arguments    : list()
[17:39:26.610]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.610]  $ ...future.elements_ii    :List of 2
[17:39:26.610]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.610]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:26.610]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.610]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:26.610]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.610]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:26.610]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.610]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:26.610]  $ ...future.seeds_ii       : NULL
[17:39:26.610]  $ ...future.globals.maxSize: NULL
[17:39:26.610]  - attr(*, "resolved")= logi FALSE
[17:39:26.610]  - attr(*, "total_size")= num 1240
[17:39:26.610]  - attr(*, "where")=List of 5
[17:39:26.610]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.610]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.610]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.610]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.610]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.610]  - attr(*, "already-done")= logi TRUE
[17:39:26.620] - copied ‘...future.FUN’ to environment
[17:39:26.620] - copied ‘future.call.arguments’ to environment
[17:39:26.620] - copied ‘...future.elements_ii’ to environment
[17:39:26.621] - copied ‘...future.seeds_ii’ to environment
[17:39:26.621] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.621] assign_globals() ... done
[17:39:26.621] requestCore(): workers = 2
[17:39:26.623] MulticoreFuture started
[17:39:26.624] - Launch lazy future ... done
[17:39:26.624] run() for ‘MulticoreFuture’ ... done
[17:39:26.624] Created future:
[17:39:26.625] plan(): Setting new future strategy stack:
[17:39:26.625] List of future strategies:
[17:39:26.625] 1. sequential:
[17:39:26.625]    - args: function (..., envir = parent.frame())
[17:39:26.625]    - tweaked: FALSE
[17:39:26.625]    - call: NULL
[17:39:26.626] plan(): nbrOfWorkers() = 1
[17:39:26.630] plan(): Setting new future strategy stack:
[17:39:26.630] List of future strategies:
[17:39:26.630] 1. multicore:
[17:39:26.630]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.630]    - tweaked: FALSE
[17:39:26.630]    - call: plan(strategy)
[17:39:26.635] plan(): nbrOfWorkers() = 2
[17:39:26.624] MulticoreFuture:
[17:39:26.624] Label: ‘future_by-2’
[17:39:26.624] Expression:
[17:39:26.624] {
[17:39:26.624]     do.call(function(...) {
[17:39:26.624]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.624]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.624]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.624]             on.exit(options(oopts), add = TRUE)
[17:39:26.624]         }
[17:39:26.624]         {
[17:39:26.624]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.624]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.624]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.624]             })
[17:39:26.624]         }
[17:39:26.624]     }, args = future.call.arguments)
[17:39:26.624] }
[17:39:26.624] Lazy evaluation: FALSE
[17:39:26.624] Asynchronous evaluation: TRUE
[17:39:26.624] Local evaluation: TRUE
[17:39:26.624] Environment: 0x5629707fed20
[17:39:26.624] Capture standard output: TRUE
[17:39:26.624] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.624] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.624] Packages: <none>
[17:39:26.624] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.624] Resolved: TRUE
[17:39:26.624] Value: <not collected>
[17:39:26.624] Conditions captured: <none>
[17:39:26.624] Early signaling: FALSE
[17:39:26.624] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.624] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.636] Chunk #2 of 2 ... DONE
[17:39:26.636] Launching 2 futures (chunks) ... DONE
[17:39:26.636] Resolving 2 futures (chunks) ...
[17:39:26.636] resolve() on list ...
[17:39:26.636]  recursive: 0
[17:39:26.637]  length: 2
[17:39:26.637] 
[17:39:26.637] Future #1
[17:39:26.638] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:26.638] - nx: 2
[17:39:26.638] - relay: TRUE
[17:39:26.639] - stdout: TRUE
[17:39:26.639] - signal: TRUE
[17:39:26.639] - resignal: FALSE
[17:39:26.639] - force: TRUE
[17:39:26.639] - relayed: [n=2] FALSE, FALSE
[17:39:26.639] - queued futures: [n=2] FALSE, FALSE
[17:39:26.639]  - until=1
[17:39:26.640]  - relaying element #1
[17:39:26.640] - relayed: [n=2] TRUE, FALSE
[17:39:26.640] - queued futures: [n=2] TRUE, FALSE
[17:39:26.640] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:26.640]  length: 1 (resolved future 1)
[17:39:26.641] Future #2
[17:39:26.641] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:26.641] - nx: 2
[17:39:26.642] - relay: TRUE
[17:39:26.642] - stdout: TRUE
[17:39:26.642] - signal: TRUE
[17:39:26.642] - resignal: FALSE
[17:39:26.642] - force: TRUE
[17:39:26.642] - relayed: [n=2] TRUE, FALSE
[17:39:26.642] - queued futures: [n=2] TRUE, FALSE
[17:39:26.642]  - until=2
[17:39:26.643]  - relaying element #2
[17:39:26.643] - relayed: [n=2] TRUE, TRUE
[17:39:26.643] - queued futures: [n=2] TRUE, TRUE
[17:39:26.643] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:26.643]  length: 0 (resolved future 2)
[17:39:26.643] Relaying remaining futures
[17:39:26.644] signalConditionsASAP(NULL, pos=0) ...
[17:39:26.644] - nx: 2
[17:39:26.644] - relay: TRUE
[17:39:26.644] - stdout: TRUE
[17:39:26.644] - signal: TRUE
[17:39:26.644] - resignal: FALSE
[17:39:26.644] - force: TRUE
[17:39:26.644] - relayed: [n=2] TRUE, TRUE
[17:39:26.644] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:26.645] - relayed: [n=2] TRUE, TRUE
[17:39:26.645] - queued futures: [n=2] TRUE, TRUE
[17:39:26.645] signalConditionsASAP(NULL, pos=0) ... done
[17:39:26.645] resolve() on list ... DONE
[17:39:26.645]  - Number of value chunks collected: 2
[17:39:26.645] Resolving 2 futures (chunks) ... DONE
[17:39:26.645] Reducing values from 2 chunks ...
[17:39:26.646]  - Number of values collected after concatenation: 3
[17:39:26.646]  - Number of values expected: 3
[17:39:26.646] Reducing values from 2 chunks ... DONE
[17:39:26.646] future_lapply() ... DONE
[17:39:26.646] future_by_internal() ... DONE
[17:39:26.647] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:39:26.648] future_lapply() ...
[17:39:26.653] Number of chunks: 2
[17:39:26.653] getGlobalsAndPackagesXApply() ...
[17:39:26.653]  - future.globals: TRUE
[17:39:26.653] getGlobalsAndPackages() ...
[17:39:26.654] Searching for globals...
[17:39:26.655] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:26.655] Searching for globals ... DONE
[17:39:26.655] Resolving globals: FALSE
[17:39:26.656] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:26.656] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:26.656] - globals: [1] ‘FUN’
[17:39:26.657] 
[17:39:26.657] getGlobalsAndPackages() ... DONE
[17:39:26.657]  - globals found/used: [n=1] ‘FUN’
[17:39:26.657]  - needed namespaces: [n=0] 
[17:39:26.657] Finding globals ... DONE
[17:39:26.657]  - use_args: TRUE
[17:39:26.657]  - Getting '...' globals ...
[17:39:26.658] resolve() on list ...
[17:39:26.658]  recursive: 0
[17:39:26.658]  length: 1
[17:39:26.658]  elements: ‘...’
[17:39:26.658]  length: 0 (resolved future 1)
[17:39:26.658] resolve() on list ... DONE
[17:39:26.658]    - '...' content: [n=0] 
[17:39:26.659] List of 1
[17:39:26.659]  $ ...: list()
[17:39:26.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.659]  - attr(*, "where")=List of 1
[17:39:26.659]   ..$ ...:<environment: 0x562972523d00> 
[17:39:26.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.659]  - attr(*, "resolved")= logi TRUE
[17:39:26.659]  - attr(*, "total_size")= num NA
[17:39:26.662]  - Getting '...' globals ... DONE
[17:39:26.662] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:26.663] List of 2
[17:39:26.663]  $ ...future.FUN:function (object, ...)  
[17:39:26.663]  $ ...          : list()
[17:39:26.663]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.663]  - attr(*, "where")=List of 2
[17:39:26.663]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:26.663]   ..$ ...          :<environment: 0x562972523d00> 
[17:39:26.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.663]  - attr(*, "resolved")= logi FALSE
[17:39:26.663]  - attr(*, "total_size")= num 1240
[17:39:26.666] Packages to be attached in all futures: [n=0] 
[17:39:26.666] getGlobalsAndPackagesXApply() ... DONE
[17:39:26.666] Number of futures (= number of chunks): 2
[17:39:26.666] Launching 2 futures (chunks) ...
[17:39:26.667] Chunk #1 of 2 ...
[17:39:26.667]  - Finding globals in 'X' for chunk #1 ...
[17:39:26.667] getGlobalsAndPackages() ...
[17:39:26.667] Searching for globals...
[17:39:26.667] 
[17:39:26.668] Searching for globals ... DONE
[17:39:26.668] - globals: [0] <none>
[17:39:26.668] getGlobalsAndPackages() ... DONE
[17:39:26.668]    + additional globals found: [n=0] 
[17:39:26.668]    + additional namespaces needed: [n=0] 
[17:39:26.668]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:26.668]  - seeds: <none>
[17:39:26.668] getGlobalsAndPackages() ...
[17:39:26.669] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.669] Resolving globals: FALSE
[17:39:26.669] Tweak future expression to call with '...' arguments ...
[17:39:26.669] {
[17:39:26.669]     do.call(function(...) {
[17:39:26.669]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.669]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.669]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.669]             on.exit(options(oopts), add = TRUE)
[17:39:26.669]         }
[17:39:26.669]         {
[17:39:26.669]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.669]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.669]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.669]             })
[17:39:26.669]         }
[17:39:26.669]     }, args = future.call.arguments)
[17:39:26.669] }
[17:39:26.669] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.670] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.670] 
[17:39:26.670] getGlobalsAndPackages() ... DONE
[17:39:26.670] run() for ‘Future’ ...
[17:39:26.671] - state: ‘created’
[17:39:26.671] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.675] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.675]   - Field: ‘label’
[17:39:26.675]   - Field: ‘local’
[17:39:26.675]   - Field: ‘owner’
[17:39:26.676]   - Field: ‘envir’
[17:39:26.676]   - Field: ‘workers’
[17:39:26.676]   - Field: ‘packages’
[17:39:26.676]   - Field: ‘gc’
[17:39:26.676]   - Field: ‘job’
[17:39:26.676]   - Field: ‘conditions’
[17:39:26.676]   - Field: ‘expr’
[17:39:26.676]   - Field: ‘uuid’
[17:39:26.677]   - Field: ‘seed’
[17:39:26.677]   - Field: ‘version’
[17:39:26.677]   - Field: ‘result’
[17:39:26.677]   - Field: ‘asynchronous’
[17:39:26.677]   - Field: ‘calls’
[17:39:26.677]   - Field: ‘globals’
[17:39:26.677]   - Field: ‘stdout’
[17:39:26.677]   - Field: ‘earlySignal’
[17:39:26.678]   - Field: ‘lazy’
[17:39:26.678]   - Field: ‘state’
[17:39:26.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.678] - Launch lazy future ...
[17:39:26.678] Packages needed by the future expression (n = 0): <none>
[17:39:26.678] Packages needed by future strategies (n = 0): <none>
[17:39:26.679] {
[17:39:26.679]     {
[17:39:26.679]         {
[17:39:26.679]             ...future.startTime <- base::Sys.time()
[17:39:26.679]             {
[17:39:26.679]                 {
[17:39:26.679]                   {
[17:39:26.679]                     {
[17:39:26.679]                       base::local({
[17:39:26.679]                         has_future <- base::requireNamespace("future", 
[17:39:26.679]                           quietly = TRUE)
[17:39:26.679]                         if (has_future) {
[17:39:26.679]                           ns <- base::getNamespace("future")
[17:39:26.679]                           version <- ns[[".package"]][["version"]]
[17:39:26.679]                           if (is.null(version)) 
[17:39:26.679]                             version <- utils::packageVersion("future")
[17:39:26.679]                         }
[17:39:26.679]                         else {
[17:39:26.679]                           version <- NULL
[17:39:26.679]                         }
[17:39:26.679]                         if (!has_future || version < "1.8.0") {
[17:39:26.679]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.679]                             "", base::R.version$version.string), 
[17:39:26.679]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:26.679]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:26.679]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.679]                               "release", "version")], collapse = " "), 
[17:39:26.679]                             hostname = base::Sys.info()[["nodename"]])
[17:39:26.679]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.679]                             info)
[17:39:26.679]                           info <- base::paste(info, collapse = "; ")
[17:39:26.679]                           if (!has_future) {
[17:39:26.679]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.679]                               info)
[17:39:26.679]                           }
[17:39:26.679]                           else {
[17:39:26.679]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.679]                               info, version)
[17:39:26.679]                           }
[17:39:26.679]                           base::stop(msg)
[17:39:26.679]                         }
[17:39:26.679]                       })
[17:39:26.679]                     }
[17:39:26.679]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.679]                     base::options(mc.cores = 1L)
[17:39:26.679]                   }
[17:39:26.679]                   options(future.plan = NULL)
[17:39:26.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.679]                 }
[17:39:26.679]                 ...future.workdir <- getwd()
[17:39:26.679]             }
[17:39:26.679]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.679]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.679]         }
[17:39:26.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:26.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.679]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.679]             base::names(...future.oldOptions))
[17:39:26.679]     }
[17:39:26.679]     if (FALSE) {
[17:39:26.679]     }
[17:39:26.679]     else {
[17:39:26.679]         if (TRUE) {
[17:39:26.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.679]                 open = "w")
[17:39:26.679]         }
[17:39:26.679]         else {
[17:39:26.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.679]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.679]         }
[17:39:26.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.679]             base::sink(type = "output", split = FALSE)
[17:39:26.679]             base::close(...future.stdout)
[17:39:26.679]         }, add = TRUE)
[17:39:26.679]     }
[17:39:26.679]     ...future.frame <- base::sys.nframe()
[17:39:26.679]     ...future.conditions <- base::list()
[17:39:26.679]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.679]     if (FALSE) {
[17:39:26.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.679]     }
[17:39:26.679]     ...future.result <- base::tryCatch({
[17:39:26.679]         base::withCallingHandlers({
[17:39:26.679]             ...future.value <- base::withVisible(base::local({
[17:39:26.679]                 withCallingHandlers({
[17:39:26.679]                   {
[17:39:26.679]                     do.call(function(...) {
[17:39:26.679]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.679]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.679]                         ...future.globals.maxSize)) {
[17:39:26.679]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.679]                         on.exit(options(oopts), add = TRUE)
[17:39:26.679]                       }
[17:39:26.679]                       {
[17:39:26.679]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.679]                           FUN = function(jj) {
[17:39:26.679]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.679]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.679]                           })
[17:39:26.679]                       }
[17:39:26.679]                     }, args = future.call.arguments)
[17:39:26.679]                   }
[17:39:26.679]                 }, immediateCondition = function(cond) {
[17:39:26.679]                   save_rds <- function (object, pathname, ...) 
[17:39:26.679]                   {
[17:39:26.679]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.679]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.679]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.679]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.679]                         fi_tmp[["mtime"]])
[17:39:26.679]                     }
[17:39:26.679]                     tryCatch({
[17:39:26.679]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.679]                     }, error = function(ex) {
[17:39:26.679]                       msg <- conditionMessage(ex)
[17:39:26.679]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.679]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.679]                         fi_tmp[["mtime"]], msg)
[17:39:26.679]                       ex$message <- msg
[17:39:26.679]                       stop(ex)
[17:39:26.679]                     })
[17:39:26.679]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.679]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.679]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.679]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.679]                       fi <- file.info(pathname)
[17:39:26.679]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.679]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.679]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.679]                         fi[["size"]], fi[["mtime"]])
[17:39:26.679]                       stop(msg)
[17:39:26.679]                     }
[17:39:26.679]                     invisible(pathname)
[17:39:26.679]                   }
[17:39:26.679]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.679]                     rootPath = tempdir()) 
[17:39:26.679]                   {
[17:39:26.679]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.679]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.679]                       tmpdir = path, fileext = ".rds")
[17:39:26.679]                     save_rds(obj, file)
[17:39:26.679]                   }
[17:39:26.679]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.679]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.679]                   {
[17:39:26.679]                     inherits <- base::inherits
[17:39:26.679]                     invokeRestart <- base::invokeRestart
[17:39:26.679]                     is.null <- base::is.null
[17:39:26.679]                     muffled <- FALSE
[17:39:26.679]                     if (inherits(cond, "message")) {
[17:39:26.679]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.679]                       if (muffled) 
[17:39:26.679]                         invokeRestart("muffleMessage")
[17:39:26.679]                     }
[17:39:26.679]                     else if (inherits(cond, "warning")) {
[17:39:26.679]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.679]                       if (muffled) 
[17:39:26.679]                         invokeRestart("muffleWarning")
[17:39:26.679]                     }
[17:39:26.679]                     else if (inherits(cond, "condition")) {
[17:39:26.679]                       if (!is.null(pattern)) {
[17:39:26.679]                         computeRestarts <- base::computeRestarts
[17:39:26.679]                         grepl <- base::grepl
[17:39:26.679]                         restarts <- computeRestarts(cond)
[17:39:26.679]                         for (restart in restarts) {
[17:39:26.679]                           name <- restart$name
[17:39:26.679]                           if (is.null(name)) 
[17:39:26.679]                             next
[17:39:26.679]                           if (!grepl(pattern, name)) 
[17:39:26.679]                             next
[17:39:26.679]                           invokeRestart(restart)
[17:39:26.679]                           muffled <- TRUE
[17:39:26.679]                           break
[17:39:26.679]                         }
[17:39:26.679]                       }
[17:39:26.679]                     }
[17:39:26.679]                     invisible(muffled)
[17:39:26.679]                   }
[17:39:26.679]                   muffleCondition(cond)
[17:39:26.679]                 })
[17:39:26.679]             }))
[17:39:26.679]             future::FutureResult(value = ...future.value$value, 
[17:39:26.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.679]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.679]                     ...future.globalenv.names))
[17:39:26.679]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.679]         }, condition = base::local({
[17:39:26.679]             c <- base::c
[17:39:26.679]             inherits <- base::inherits
[17:39:26.679]             invokeRestart <- base::invokeRestart
[17:39:26.679]             length <- base::length
[17:39:26.679]             list <- base::list
[17:39:26.679]             seq.int <- base::seq.int
[17:39:26.679]             signalCondition <- base::signalCondition
[17:39:26.679]             sys.calls <- base::sys.calls
[17:39:26.679]             `[[` <- base::`[[`
[17:39:26.679]             `+` <- base::`+`
[17:39:26.679]             `<<-` <- base::`<<-`
[17:39:26.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.679]                   3L)]
[17:39:26.679]             }
[17:39:26.679]             function(cond) {
[17:39:26.679]                 is_error <- inherits(cond, "error")
[17:39:26.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.679]                   NULL)
[17:39:26.679]                 if (is_error) {
[17:39:26.679]                   sessionInformation <- function() {
[17:39:26.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.679]                       search = base::search(), system = base::Sys.info())
[17:39:26.679]                   }
[17:39:26.679]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.679]                     cond$call), session = sessionInformation(), 
[17:39:26.679]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.679]                   signalCondition(cond)
[17:39:26.679]                 }
[17:39:26.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.679]                 "immediateCondition"))) {
[17:39:26.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.679]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.679]                   if (TRUE && !signal) {
[17:39:26.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.679]                     {
[17:39:26.679]                       inherits <- base::inherits
[17:39:26.679]                       invokeRestart <- base::invokeRestart
[17:39:26.679]                       is.null <- base::is.null
[17:39:26.679]                       muffled <- FALSE
[17:39:26.679]                       if (inherits(cond, "message")) {
[17:39:26.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.679]                         if (muffled) 
[17:39:26.679]                           invokeRestart("muffleMessage")
[17:39:26.679]                       }
[17:39:26.679]                       else if (inherits(cond, "warning")) {
[17:39:26.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.679]                         if (muffled) 
[17:39:26.679]                           invokeRestart("muffleWarning")
[17:39:26.679]                       }
[17:39:26.679]                       else if (inherits(cond, "condition")) {
[17:39:26.679]                         if (!is.null(pattern)) {
[17:39:26.679]                           computeRestarts <- base::computeRestarts
[17:39:26.679]                           grepl <- base::grepl
[17:39:26.679]                           restarts <- computeRestarts(cond)
[17:39:26.679]                           for (restart in restarts) {
[17:39:26.679]                             name <- restart$name
[17:39:26.679]                             if (is.null(name)) 
[17:39:26.679]                               next
[17:39:26.679]                             if (!grepl(pattern, name)) 
[17:39:26.679]                               next
[17:39:26.679]                             invokeRestart(restart)
[17:39:26.679]                             muffled <- TRUE
[17:39:26.679]                             break
[17:39:26.679]                           }
[17:39:26.679]                         }
[17:39:26.679]                       }
[17:39:26.679]                       invisible(muffled)
[17:39:26.679]                     }
[17:39:26.679]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.679]                   }
[17:39:26.679]                 }
[17:39:26.679]                 else {
[17:39:26.679]                   if (TRUE) {
[17:39:26.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.679]                     {
[17:39:26.679]                       inherits <- base::inherits
[17:39:26.679]                       invokeRestart <- base::invokeRestart
[17:39:26.679]                       is.null <- base::is.null
[17:39:26.679]                       muffled <- FALSE
[17:39:26.679]                       if (inherits(cond, "message")) {
[17:39:26.679]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.679]                         if (muffled) 
[17:39:26.679]                           invokeRestart("muffleMessage")
[17:39:26.679]                       }
[17:39:26.679]                       else if (inherits(cond, "warning")) {
[17:39:26.679]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.679]                         if (muffled) 
[17:39:26.679]                           invokeRestart("muffleWarning")
[17:39:26.679]                       }
[17:39:26.679]                       else if (inherits(cond, "condition")) {
[17:39:26.679]                         if (!is.null(pattern)) {
[17:39:26.679]                           computeRestarts <- base::computeRestarts
[17:39:26.679]                           grepl <- base::grepl
[17:39:26.679]                           restarts <- computeRestarts(cond)
[17:39:26.679]                           for (restart in restarts) {
[17:39:26.679]                             name <- restart$name
[17:39:26.679]                             if (is.null(name)) 
[17:39:26.679]                               next
[17:39:26.679]                             if (!grepl(pattern, name)) 
[17:39:26.679]                               next
[17:39:26.679]                             invokeRestart(restart)
[17:39:26.679]                             muffled <- TRUE
[17:39:26.679]                             break
[17:39:26.679]                           }
[17:39:26.679]                         }
[17:39:26.679]                       }
[17:39:26.679]                       invisible(muffled)
[17:39:26.679]                     }
[17:39:26.679]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.679]                   }
[17:39:26.679]                 }
[17:39:26.679]             }
[17:39:26.679]         }))
[17:39:26.679]     }, error = function(ex) {
[17:39:26.679]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.679]                 ...future.rng), started = ...future.startTime, 
[17:39:26.679]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.679]             version = "1.8"), class = "FutureResult")
[17:39:26.679]     }, finally = {
[17:39:26.679]         if (!identical(...future.workdir, getwd())) 
[17:39:26.679]             setwd(...future.workdir)
[17:39:26.679]         {
[17:39:26.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.679]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.679]             }
[17:39:26.679]             base::options(...future.oldOptions)
[17:39:26.679]             if (.Platform$OS.type == "windows") {
[17:39:26.679]                 old_names <- names(...future.oldEnvVars)
[17:39:26.679]                 envs <- base::Sys.getenv()
[17:39:26.679]                 names <- names(envs)
[17:39:26.679]                 common <- intersect(names, old_names)
[17:39:26.679]                 added <- setdiff(names, old_names)
[17:39:26.679]                 removed <- setdiff(old_names, names)
[17:39:26.679]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.679]                   envs[common]]
[17:39:26.679]                 NAMES <- toupper(changed)
[17:39:26.679]                 args <- list()
[17:39:26.679]                 for (kk in seq_along(NAMES)) {
[17:39:26.679]                   name <- changed[[kk]]
[17:39:26.679]                   NAME <- NAMES[[kk]]
[17:39:26.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.679]                     next
[17:39:26.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.679]                 }
[17:39:26.679]                 NAMES <- toupper(added)
[17:39:26.679]                 for (kk in seq_along(NAMES)) {
[17:39:26.679]                   name <- added[[kk]]
[17:39:26.679]                   NAME <- NAMES[[kk]]
[17:39:26.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.679]                     next
[17:39:26.679]                   args[[name]] <- ""
[17:39:26.679]                 }
[17:39:26.679]                 NAMES <- toupper(removed)
[17:39:26.679]                 for (kk in seq_along(NAMES)) {
[17:39:26.679]                   name <- removed[[kk]]
[17:39:26.679]                   NAME <- NAMES[[kk]]
[17:39:26.679]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.679]                     next
[17:39:26.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.679]                 }
[17:39:26.679]                 if (length(args) > 0) 
[17:39:26.679]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.679]             }
[17:39:26.679]             else {
[17:39:26.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.679]             }
[17:39:26.679]             {
[17:39:26.679]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.679]                   0L) {
[17:39:26.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.679]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.679]                   base::options(opts)
[17:39:26.679]                 }
[17:39:26.679]                 {
[17:39:26.679]                   {
[17:39:26.679]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.679]                     NULL
[17:39:26.679]                   }
[17:39:26.679]                   options(future.plan = NULL)
[17:39:26.679]                   if (is.na(NA_character_)) 
[17:39:26.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.679]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.679]                     envir = parent.frame()) 
[17:39:26.679]                   {
[17:39:26.679]                     default_workers <- missing(workers)
[17:39:26.679]                     if (is.function(workers)) 
[17:39:26.679]                       workers <- workers()
[17:39:26.679]                     workers <- structure(as.integer(workers), 
[17:39:26.679]                       class = class(workers))
[17:39:26.679]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.679]                       1L)
[17:39:26.679]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.679]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.679]                       if (default_workers) 
[17:39:26.679]                         supportsMulticore(warn = TRUE)
[17:39:26.679]                       return(sequential(..., envir = envir))
[17:39:26.679]                     }
[17:39:26.679]                     oopts <- options(mc.cores = workers)
[17:39:26.679]                     on.exit(options(oopts))
[17:39:26.679]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.679]                       envir = envir)
[17:39:26.679]                     if (!future$lazy) 
[17:39:26.679]                       future <- run(future)
[17:39:26.679]                     invisible(future)
[17:39:26.679]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.679]                 }
[17:39:26.679]             }
[17:39:26.679]         }
[17:39:26.679]     })
[17:39:26.679]     if (TRUE) {
[17:39:26.679]         base::sink(type = "output", split = FALSE)
[17:39:26.679]         if (TRUE) {
[17:39:26.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.679]         }
[17:39:26.679]         else {
[17:39:26.679]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.679]         }
[17:39:26.679]         base::close(...future.stdout)
[17:39:26.679]         ...future.stdout <- NULL
[17:39:26.679]     }
[17:39:26.679]     ...future.result$conditions <- ...future.conditions
[17:39:26.679]     ...future.result$finished <- base::Sys.time()
[17:39:26.679]     ...future.result
[17:39:26.679] }
[17:39:26.682] assign_globals() ...
[17:39:26.682] List of 5
[17:39:26.682]  $ ...future.FUN            :function (object, ...)  
[17:39:26.682]  $ future.call.arguments    : list()
[17:39:26.682]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.682]  $ ...future.elements_ii    :List of 1
[17:39:26.682]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.682]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:39:26.682]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.682]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:26.682]  $ ...future.seeds_ii       : NULL
[17:39:26.682]  $ ...future.globals.maxSize: NULL
[17:39:26.682]  - attr(*, "where")=List of 5
[17:39:26.682]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.682]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.682]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.682]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.682]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.682]  - attr(*, "resolved")= logi FALSE
[17:39:26.682]  - attr(*, "total_size")= num 1240
[17:39:26.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.682]  - attr(*, "already-done")= logi TRUE
[17:39:26.692] - copied ‘...future.FUN’ to environment
[17:39:26.692] - copied ‘future.call.arguments’ to environment
[17:39:26.693] - copied ‘...future.elements_ii’ to environment
[17:39:26.693] - copied ‘...future.seeds_ii’ to environment
[17:39:26.693] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.693] assign_globals() ... done
[17:39:26.693] requestCore(): workers = 2
[17:39:26.696] MulticoreFuture started
[17:39:26.696] - Launch lazy future ... done
[17:39:26.697] run() for ‘MulticoreFuture’ ... done
[17:39:26.697] Created future:
[17:39:26.697] plan(): Setting new future strategy stack:
[17:39:26.698] List of future strategies:
[17:39:26.698] 1. sequential:
[17:39:26.698]    - args: function (..., envir = parent.frame())
[17:39:26.698]    - tweaked: FALSE
[17:39:26.698]    - call: NULL
[17:39:26.699] plan(): nbrOfWorkers() = 1
[17:39:26.702] plan(): Setting new future strategy stack:
[17:39:26.703] List of future strategies:
[17:39:26.703] 1. multicore:
[17:39:26.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.703]    - tweaked: FALSE
[17:39:26.703]    - call: plan(strategy)
[17:39:26.708] plan(): nbrOfWorkers() = 2
[17:39:26.697] MulticoreFuture:
[17:39:26.697] Label: ‘future_by-1’
[17:39:26.697] Expression:
[17:39:26.697] {
[17:39:26.697]     do.call(function(...) {
[17:39:26.697]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.697]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.697]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.697]             on.exit(options(oopts), add = TRUE)
[17:39:26.697]         }
[17:39:26.697]         {
[17:39:26.697]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.697]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.697]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.697]             })
[17:39:26.697]         }
[17:39:26.697]     }, args = future.call.arguments)
[17:39:26.697] }
[17:39:26.697] Lazy evaluation: FALSE
[17:39:26.697] Asynchronous evaluation: TRUE
[17:39:26.697] Local evaluation: TRUE
[17:39:26.697] Environment: 0x5629724f0d68
[17:39:26.697] Capture standard output: TRUE
[17:39:26.697] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.697] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.697] Packages: <none>
[17:39:26.697] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.697] Resolved: TRUE
[17:39:26.697] Value: <not collected>
[17:39:26.697] Conditions captured: <none>
[17:39:26.697] Early signaling: FALSE
[17:39:26.697] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.697] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.709] Chunk #1 of 2 ... DONE
[17:39:26.709] Chunk #2 of 2 ...
[17:39:26.709]  - Finding globals in 'X' for chunk #2 ...
[17:39:26.709] getGlobalsAndPackages() ...
[17:39:26.709] Searching for globals...
[17:39:26.710] 
[17:39:26.710] Searching for globals ... DONE
[17:39:26.710] - globals: [0] <none>
[17:39:26.710] getGlobalsAndPackages() ... DONE
[17:39:26.711]    + additional globals found: [n=0] 
[17:39:26.711]    + additional namespaces needed: [n=0] 
[17:39:26.711]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:26.711]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:26.711]  - seeds: <none>
[17:39:26.711] getGlobalsAndPackages() ...
[17:39:26.711] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.712] Resolving globals: FALSE
[17:39:26.712] Tweak future expression to call with '...' arguments ...
[17:39:26.712] {
[17:39:26.712]     do.call(function(...) {
[17:39:26.712]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.712]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.712]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.712]             on.exit(options(oopts), add = TRUE)
[17:39:26.712]         }
[17:39:26.712]         {
[17:39:26.712]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.712]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.712]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.712]             })
[17:39:26.712]         }
[17:39:26.712]     }, args = future.call.arguments)
[17:39:26.712] }
[17:39:26.712] Tweak future expression to call with '...' arguments ... DONE
[17:39:26.713] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:26.713] 
[17:39:26.713] getGlobalsAndPackages() ... DONE
[17:39:26.714] run() for ‘Future’ ...
[17:39:26.714] - state: ‘created’
[17:39:26.714] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:26.719] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:26.719]   - Field: ‘label’
[17:39:26.719]   - Field: ‘local’
[17:39:26.719]   - Field: ‘owner’
[17:39:26.719]   - Field: ‘envir’
[17:39:26.720]   - Field: ‘workers’
[17:39:26.720]   - Field: ‘packages’
[17:39:26.720]   - Field: ‘gc’
[17:39:26.720]   - Field: ‘job’
[17:39:26.720]   - Field: ‘conditions’
[17:39:26.720]   - Field: ‘expr’
[17:39:26.720]   - Field: ‘uuid’
[17:39:26.721]   - Field: ‘seed’
[17:39:26.721]   - Field: ‘version’
[17:39:26.721]   - Field: ‘result’
[17:39:26.721]   - Field: ‘asynchronous’
[17:39:26.721]   - Field: ‘calls’
[17:39:26.721]   - Field: ‘globals’
[17:39:26.721]   - Field: ‘stdout’
[17:39:26.722]   - Field: ‘earlySignal’
[17:39:26.722]   - Field: ‘lazy’
[17:39:26.722]   - Field: ‘state’
[17:39:26.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:26.722] - Launch lazy future ...
[17:39:26.723] Packages needed by the future expression (n = 0): <none>
[17:39:26.723] Packages needed by future strategies (n = 0): <none>
[17:39:26.724] {
[17:39:26.724]     {
[17:39:26.724]         {
[17:39:26.724]             ...future.startTime <- base::Sys.time()
[17:39:26.724]             {
[17:39:26.724]                 {
[17:39:26.724]                   {
[17:39:26.724]                     {
[17:39:26.724]                       base::local({
[17:39:26.724]                         has_future <- base::requireNamespace("future", 
[17:39:26.724]                           quietly = TRUE)
[17:39:26.724]                         if (has_future) {
[17:39:26.724]                           ns <- base::getNamespace("future")
[17:39:26.724]                           version <- ns[[".package"]][["version"]]
[17:39:26.724]                           if (is.null(version)) 
[17:39:26.724]                             version <- utils::packageVersion("future")
[17:39:26.724]                         }
[17:39:26.724]                         else {
[17:39:26.724]                           version <- NULL
[17:39:26.724]                         }
[17:39:26.724]                         if (!has_future || version < "1.8.0") {
[17:39:26.724]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:26.724]                             "", base::R.version$version.string), 
[17:39:26.724]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:26.724]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:26.724]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:26.724]                               "release", "version")], collapse = " "), 
[17:39:26.724]                             hostname = base::Sys.info()[["nodename"]])
[17:39:26.724]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:26.724]                             info)
[17:39:26.724]                           info <- base::paste(info, collapse = "; ")
[17:39:26.724]                           if (!has_future) {
[17:39:26.724]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:26.724]                               info)
[17:39:26.724]                           }
[17:39:26.724]                           else {
[17:39:26.724]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:26.724]                               info, version)
[17:39:26.724]                           }
[17:39:26.724]                           base::stop(msg)
[17:39:26.724]                         }
[17:39:26.724]                       })
[17:39:26.724]                     }
[17:39:26.724]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:26.724]                     base::options(mc.cores = 1L)
[17:39:26.724]                   }
[17:39:26.724]                   options(future.plan = NULL)
[17:39:26.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:26.724]                 }
[17:39:26.724]                 ...future.workdir <- getwd()
[17:39:26.724]             }
[17:39:26.724]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:26.724]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:26.724]         }
[17:39:26.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:26.724]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:26.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:26.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:26.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:26.724]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:26.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:26.724]             base::names(...future.oldOptions))
[17:39:26.724]     }
[17:39:26.724]     if (FALSE) {
[17:39:26.724]     }
[17:39:26.724]     else {
[17:39:26.724]         if (TRUE) {
[17:39:26.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:26.724]                 open = "w")
[17:39:26.724]         }
[17:39:26.724]         else {
[17:39:26.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:26.724]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:26.724]         }
[17:39:26.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:26.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:26.724]             base::sink(type = "output", split = FALSE)
[17:39:26.724]             base::close(...future.stdout)
[17:39:26.724]         }, add = TRUE)
[17:39:26.724]     }
[17:39:26.724]     ...future.frame <- base::sys.nframe()
[17:39:26.724]     ...future.conditions <- base::list()
[17:39:26.724]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:26.724]     if (FALSE) {
[17:39:26.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:26.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:26.724]     }
[17:39:26.724]     ...future.result <- base::tryCatch({
[17:39:26.724]         base::withCallingHandlers({
[17:39:26.724]             ...future.value <- base::withVisible(base::local({
[17:39:26.724]                 withCallingHandlers({
[17:39:26.724]                   {
[17:39:26.724]                     do.call(function(...) {
[17:39:26.724]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.724]                       if (!identical(...future.globals.maxSize.org, 
[17:39:26.724]                         ...future.globals.maxSize)) {
[17:39:26.724]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.724]                         on.exit(options(oopts), add = TRUE)
[17:39:26.724]                       }
[17:39:26.724]                       {
[17:39:26.724]                         lapply(seq_along(...future.elements_ii), 
[17:39:26.724]                           FUN = function(jj) {
[17:39:26.724]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.724]                             ...future.FUN(...future.X_jj, ...)
[17:39:26.724]                           })
[17:39:26.724]                       }
[17:39:26.724]                     }, args = future.call.arguments)
[17:39:26.724]                   }
[17:39:26.724]                 }, immediateCondition = function(cond) {
[17:39:26.724]                   save_rds <- function (object, pathname, ...) 
[17:39:26.724]                   {
[17:39:26.724]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:26.724]                     if (file_test("-f", pathname_tmp)) {
[17:39:26.724]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.724]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:26.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.724]                         fi_tmp[["mtime"]])
[17:39:26.724]                     }
[17:39:26.724]                     tryCatch({
[17:39:26.724]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:26.724]                     }, error = function(ex) {
[17:39:26.724]                       msg <- conditionMessage(ex)
[17:39:26.724]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.724]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:26.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.724]                         fi_tmp[["mtime"]], msg)
[17:39:26.724]                       ex$message <- msg
[17:39:26.724]                       stop(ex)
[17:39:26.724]                     })
[17:39:26.724]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:26.724]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:26.724]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:26.724]                       fi_tmp <- file.info(pathname_tmp)
[17:39:26.724]                       fi <- file.info(pathname)
[17:39:26.724]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:26.724]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:26.724]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:26.724]                         fi[["size"]], fi[["mtime"]])
[17:39:26.724]                       stop(msg)
[17:39:26.724]                     }
[17:39:26.724]                     invisible(pathname)
[17:39:26.724]                   }
[17:39:26.724]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:26.724]                     rootPath = tempdir()) 
[17:39:26.724]                   {
[17:39:26.724]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:26.724]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:26.724]                       tmpdir = path, fileext = ".rds")
[17:39:26.724]                     save_rds(obj, file)
[17:39:26.724]                   }
[17:39:26.724]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0aLE4m/.future/immediateConditions")
[17:39:26.724]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.724]                   {
[17:39:26.724]                     inherits <- base::inherits
[17:39:26.724]                     invokeRestart <- base::invokeRestart
[17:39:26.724]                     is.null <- base::is.null
[17:39:26.724]                     muffled <- FALSE
[17:39:26.724]                     if (inherits(cond, "message")) {
[17:39:26.724]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:26.724]                       if (muffled) 
[17:39:26.724]                         invokeRestart("muffleMessage")
[17:39:26.724]                     }
[17:39:26.724]                     else if (inherits(cond, "warning")) {
[17:39:26.724]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:26.724]                       if (muffled) 
[17:39:26.724]                         invokeRestart("muffleWarning")
[17:39:26.724]                     }
[17:39:26.724]                     else if (inherits(cond, "condition")) {
[17:39:26.724]                       if (!is.null(pattern)) {
[17:39:26.724]                         computeRestarts <- base::computeRestarts
[17:39:26.724]                         grepl <- base::grepl
[17:39:26.724]                         restarts <- computeRestarts(cond)
[17:39:26.724]                         for (restart in restarts) {
[17:39:26.724]                           name <- restart$name
[17:39:26.724]                           if (is.null(name)) 
[17:39:26.724]                             next
[17:39:26.724]                           if (!grepl(pattern, name)) 
[17:39:26.724]                             next
[17:39:26.724]                           invokeRestart(restart)
[17:39:26.724]                           muffled <- TRUE
[17:39:26.724]                           break
[17:39:26.724]                         }
[17:39:26.724]                       }
[17:39:26.724]                     }
[17:39:26.724]                     invisible(muffled)
[17:39:26.724]                   }
[17:39:26.724]                   muffleCondition(cond)
[17:39:26.724]                 })
[17:39:26.724]             }))
[17:39:26.724]             future::FutureResult(value = ...future.value$value, 
[17:39:26.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.724]                   ...future.rng), globalenv = if (FALSE) 
[17:39:26.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:26.724]                     ...future.globalenv.names))
[17:39:26.724]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:26.724]         }, condition = base::local({
[17:39:26.724]             c <- base::c
[17:39:26.724]             inherits <- base::inherits
[17:39:26.724]             invokeRestart <- base::invokeRestart
[17:39:26.724]             length <- base::length
[17:39:26.724]             list <- base::list
[17:39:26.724]             seq.int <- base::seq.int
[17:39:26.724]             signalCondition <- base::signalCondition
[17:39:26.724]             sys.calls <- base::sys.calls
[17:39:26.724]             `[[` <- base::`[[`
[17:39:26.724]             `+` <- base::`+`
[17:39:26.724]             `<<-` <- base::`<<-`
[17:39:26.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:26.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:26.724]                   3L)]
[17:39:26.724]             }
[17:39:26.724]             function(cond) {
[17:39:26.724]                 is_error <- inherits(cond, "error")
[17:39:26.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:26.724]                   NULL)
[17:39:26.724]                 if (is_error) {
[17:39:26.724]                   sessionInformation <- function() {
[17:39:26.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:26.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:26.724]                       search = base::search(), system = base::Sys.info())
[17:39:26.724]                   }
[17:39:26.724]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:26.724]                     cond$call), session = sessionInformation(), 
[17:39:26.724]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:26.724]                   signalCondition(cond)
[17:39:26.724]                 }
[17:39:26.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:26.724]                 "immediateCondition"))) {
[17:39:26.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:26.724]                   ...future.conditions[[length(...future.conditions) + 
[17:39:26.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:26.724]                   if (TRUE && !signal) {
[17:39:26.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.724]                     {
[17:39:26.724]                       inherits <- base::inherits
[17:39:26.724]                       invokeRestart <- base::invokeRestart
[17:39:26.724]                       is.null <- base::is.null
[17:39:26.724]                       muffled <- FALSE
[17:39:26.724]                       if (inherits(cond, "message")) {
[17:39:26.724]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.724]                         if (muffled) 
[17:39:26.724]                           invokeRestart("muffleMessage")
[17:39:26.724]                       }
[17:39:26.724]                       else if (inherits(cond, "warning")) {
[17:39:26.724]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.724]                         if (muffled) 
[17:39:26.724]                           invokeRestart("muffleWarning")
[17:39:26.724]                       }
[17:39:26.724]                       else if (inherits(cond, "condition")) {
[17:39:26.724]                         if (!is.null(pattern)) {
[17:39:26.724]                           computeRestarts <- base::computeRestarts
[17:39:26.724]                           grepl <- base::grepl
[17:39:26.724]                           restarts <- computeRestarts(cond)
[17:39:26.724]                           for (restart in restarts) {
[17:39:26.724]                             name <- restart$name
[17:39:26.724]                             if (is.null(name)) 
[17:39:26.724]                               next
[17:39:26.724]                             if (!grepl(pattern, name)) 
[17:39:26.724]                               next
[17:39:26.724]                             invokeRestart(restart)
[17:39:26.724]                             muffled <- TRUE
[17:39:26.724]                             break
[17:39:26.724]                           }
[17:39:26.724]                         }
[17:39:26.724]                       }
[17:39:26.724]                       invisible(muffled)
[17:39:26.724]                     }
[17:39:26.724]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.724]                   }
[17:39:26.724]                 }
[17:39:26.724]                 else {
[17:39:26.724]                   if (TRUE) {
[17:39:26.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:26.724]                     {
[17:39:26.724]                       inherits <- base::inherits
[17:39:26.724]                       invokeRestart <- base::invokeRestart
[17:39:26.724]                       is.null <- base::is.null
[17:39:26.724]                       muffled <- FALSE
[17:39:26.724]                       if (inherits(cond, "message")) {
[17:39:26.724]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:26.724]                         if (muffled) 
[17:39:26.724]                           invokeRestart("muffleMessage")
[17:39:26.724]                       }
[17:39:26.724]                       else if (inherits(cond, "warning")) {
[17:39:26.724]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:26.724]                         if (muffled) 
[17:39:26.724]                           invokeRestart("muffleWarning")
[17:39:26.724]                       }
[17:39:26.724]                       else if (inherits(cond, "condition")) {
[17:39:26.724]                         if (!is.null(pattern)) {
[17:39:26.724]                           computeRestarts <- base::computeRestarts
[17:39:26.724]                           grepl <- base::grepl
[17:39:26.724]                           restarts <- computeRestarts(cond)
[17:39:26.724]                           for (restart in restarts) {
[17:39:26.724]                             name <- restart$name
[17:39:26.724]                             if (is.null(name)) 
[17:39:26.724]                               next
[17:39:26.724]                             if (!grepl(pattern, name)) 
[17:39:26.724]                               next
[17:39:26.724]                             invokeRestart(restart)
[17:39:26.724]                             muffled <- TRUE
[17:39:26.724]                             break
[17:39:26.724]                           }
[17:39:26.724]                         }
[17:39:26.724]                       }
[17:39:26.724]                       invisible(muffled)
[17:39:26.724]                     }
[17:39:26.724]                     muffleCondition(cond, pattern = "^muffle")
[17:39:26.724]                   }
[17:39:26.724]                 }
[17:39:26.724]             }
[17:39:26.724]         }))
[17:39:26.724]     }, error = function(ex) {
[17:39:26.724]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:26.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:26.724]                 ...future.rng), started = ...future.startTime, 
[17:39:26.724]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:26.724]             version = "1.8"), class = "FutureResult")
[17:39:26.724]     }, finally = {
[17:39:26.724]         if (!identical(...future.workdir, getwd())) 
[17:39:26.724]             setwd(...future.workdir)
[17:39:26.724]         {
[17:39:26.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:26.724]                 ...future.oldOptions$nwarnings <- NULL
[17:39:26.724]             }
[17:39:26.724]             base::options(...future.oldOptions)
[17:39:26.724]             if (.Platform$OS.type == "windows") {
[17:39:26.724]                 old_names <- names(...future.oldEnvVars)
[17:39:26.724]                 envs <- base::Sys.getenv()
[17:39:26.724]                 names <- names(envs)
[17:39:26.724]                 common <- intersect(names, old_names)
[17:39:26.724]                 added <- setdiff(names, old_names)
[17:39:26.724]                 removed <- setdiff(old_names, names)
[17:39:26.724]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:26.724]                   envs[common]]
[17:39:26.724]                 NAMES <- toupper(changed)
[17:39:26.724]                 args <- list()
[17:39:26.724]                 for (kk in seq_along(NAMES)) {
[17:39:26.724]                   name <- changed[[kk]]
[17:39:26.724]                   NAME <- NAMES[[kk]]
[17:39:26.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.724]                     next
[17:39:26.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.724]                 }
[17:39:26.724]                 NAMES <- toupper(added)
[17:39:26.724]                 for (kk in seq_along(NAMES)) {
[17:39:26.724]                   name <- added[[kk]]
[17:39:26.724]                   NAME <- NAMES[[kk]]
[17:39:26.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.724]                     next
[17:39:26.724]                   args[[name]] <- ""
[17:39:26.724]                 }
[17:39:26.724]                 NAMES <- toupper(removed)
[17:39:26.724]                 for (kk in seq_along(NAMES)) {
[17:39:26.724]                   name <- removed[[kk]]
[17:39:26.724]                   NAME <- NAMES[[kk]]
[17:39:26.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:26.724]                     next
[17:39:26.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:26.724]                 }
[17:39:26.724]                 if (length(args) > 0) 
[17:39:26.724]                   base::do.call(base::Sys.setenv, args = args)
[17:39:26.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:26.724]             }
[17:39:26.724]             else {
[17:39:26.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:26.724]             }
[17:39:26.724]             {
[17:39:26.724]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:26.724]                   0L) {
[17:39:26.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:26.724]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:26.724]                   base::options(opts)
[17:39:26.724]                 }
[17:39:26.724]                 {
[17:39:26.724]                   {
[17:39:26.724]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:26.724]                     NULL
[17:39:26.724]                   }
[17:39:26.724]                   options(future.plan = NULL)
[17:39:26.724]                   if (is.na(NA_character_)) 
[17:39:26.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:26.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:26.724]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:26.724]                     envir = parent.frame()) 
[17:39:26.724]                   {
[17:39:26.724]                     default_workers <- missing(workers)
[17:39:26.724]                     if (is.function(workers)) 
[17:39:26.724]                       workers <- workers()
[17:39:26.724]                     workers <- structure(as.integer(workers), 
[17:39:26.724]                       class = class(workers))
[17:39:26.724]                     stop_if_not(is.finite(workers), workers >= 
[17:39:26.724]                       1L)
[17:39:26.724]                     if ((workers == 1L && !inherits(workers, 
[17:39:26.724]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:26.724]                       if (default_workers) 
[17:39:26.724]                         supportsMulticore(warn = TRUE)
[17:39:26.724]                       return(sequential(..., envir = envir))
[17:39:26.724]                     }
[17:39:26.724]                     oopts <- options(mc.cores = workers)
[17:39:26.724]                     on.exit(options(oopts))
[17:39:26.724]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:26.724]                       envir = envir)
[17:39:26.724]                     if (!future$lazy) 
[17:39:26.724]                       future <- run(future)
[17:39:26.724]                     invisible(future)
[17:39:26.724]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:26.724]                 }
[17:39:26.724]             }
[17:39:26.724]         }
[17:39:26.724]     })
[17:39:26.724]     if (TRUE) {
[17:39:26.724]         base::sink(type = "output", split = FALSE)
[17:39:26.724]         if (TRUE) {
[17:39:26.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:26.724]         }
[17:39:26.724]         else {
[17:39:26.724]             ...future.result["stdout"] <- base::list(NULL)
[17:39:26.724]         }
[17:39:26.724]         base::close(...future.stdout)
[17:39:26.724]         ...future.stdout <- NULL
[17:39:26.724]     }
[17:39:26.724]     ...future.result$conditions <- ...future.conditions
[17:39:26.724]     ...future.result$finished <- base::Sys.time()
[17:39:26.724]     ...future.result
[17:39:26.724] }
[17:39:26.727] assign_globals() ...
[17:39:26.727] List of 5
[17:39:26.727]  $ ...future.FUN            :function (object, ...)  
[17:39:26.727]  $ future.call.arguments    : list()
[17:39:26.727]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:26.727]  $ ...future.elements_ii    :List of 2
[17:39:26.727]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.727]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:39:26.727]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.727]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:39:26.727]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:39:26.727]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:39:26.727]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:39:26.727]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:39:26.727]  $ ...future.seeds_ii       : NULL
[17:39:26.727]  $ ...future.globals.maxSize: NULL
[17:39:26.727]  - attr(*, "resolved")= logi FALSE
[17:39:26.727]  - attr(*, "total_size")= num 1240
[17:39:26.727]  - attr(*, "where")=List of 5
[17:39:26.727]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:26.727]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:26.727]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:26.727]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:26.727]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:26.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:26.727]  - attr(*, "already-done")= logi TRUE
[17:39:26.739] - copied ‘...future.FUN’ to environment
[17:39:26.739] - copied ‘future.call.arguments’ to environment
[17:39:26.739] - copied ‘...future.elements_ii’ to environment
[17:39:26.739] - copied ‘...future.seeds_ii’ to environment
[17:39:26.739] - copied ‘...future.globals.maxSize’ to environment
[17:39:26.739] assign_globals() ... done
[17:39:26.740] requestCore(): workers = 2
[17:39:26.742] MulticoreFuture started
[17:39:26.743] - Launch lazy future ... done
[17:39:26.743] run() for ‘MulticoreFuture’ ... done
[17:39:26.744] Created future:
[17:39:26.744] plan(): Setting new future strategy stack:
[17:39:26.744] List of future strategies:
[17:39:26.744] 1. sequential:
[17:39:26.744]    - args: function (..., envir = parent.frame())
[17:39:26.744]    - tweaked: FALSE
[17:39:26.744]    - call: NULL
[17:39:26.745] plan(): nbrOfWorkers() = 1
[17:39:26.750] plan(): Setting new future strategy stack:
[17:39:26.750] List of future strategies:
[17:39:26.750] 1. multicore:
[17:39:26.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:26.750]    - tweaked: FALSE
[17:39:26.750]    - call: plan(strategy)
[17:39:26.755] plan(): nbrOfWorkers() = 2
[17:39:26.744] MulticoreFuture:
[17:39:26.744] Label: ‘future_by-2’
[17:39:26.744] Expression:
[17:39:26.744] {
[17:39:26.744]     do.call(function(...) {
[17:39:26.744]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:26.744]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:26.744]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:26.744]             on.exit(options(oopts), add = TRUE)
[17:39:26.744]         }
[17:39:26.744]         {
[17:39:26.744]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:26.744]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:26.744]                 ...future.FUN(...future.X_jj, ...)
[17:39:26.744]             })
[17:39:26.744]         }
[17:39:26.744]     }, args = future.call.arguments)
[17:39:26.744] }
[17:39:26.744] Lazy evaluation: FALSE
[17:39:26.744] Asynchronous evaluation: TRUE
[17:39:26.744] Local evaluation: TRUE
[17:39:26.744] Environment: 0x5629724f0d68
[17:39:26.744] Capture standard output: TRUE
[17:39:26.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:26.744] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:26.744] Packages: <none>
[17:39:26.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:26.744] Resolved: TRUE
[17:39:26.744] Value: <not collected>
[17:39:26.744] Conditions captured: <none>
[17:39:26.744] Early signaling: FALSE
[17:39:26.744] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:26.744] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:26.756] Chunk #2 of 2 ... DONE
[17:39:26.756] Launching 2 futures (chunks) ... DONE
[17:39:26.757] Resolving 2 futures (chunks) ...
[17:39:26.757] resolve() on list ...
[17:39:26.757]  recursive: 0
[17:39:26.757]  length: 2
[17:39:26.757] 
[17:39:26.758] Future #1
[17:39:26.759] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:26.759] - nx: 2
[17:39:26.759] - relay: TRUE
[17:39:26.759] - stdout: TRUE
[17:39:26.759] - signal: TRUE
[17:39:26.759] - resignal: FALSE
[17:39:26.760] - force: TRUE
[17:39:26.760] - relayed: [n=2] FALSE, FALSE
[17:39:26.760] - queued futures: [n=2] FALSE, FALSE
[17:39:26.760]  - until=1
[17:39:26.760]  - relaying element #1
[17:39:26.760] - relayed: [n=2] TRUE, FALSE
[17:39:26.761] - queued futures: [n=2] TRUE, FALSE
[17:39:26.761] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:26.761]  length: 1 (resolved future 1)
[17:39:26.761] Future #2
[17:39:26.762] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:26.762] - nx: 2
[17:39:26.762] - relay: TRUE
[17:39:26.762] - stdout: TRUE
[17:39:26.762] - signal: TRUE
[17:39:26.763] - resignal: FALSE
[17:39:26.763] - force: TRUE
[17:39:26.763] - relayed: [n=2] TRUE, FALSE
[17:39:26.763] - queued futures: [n=2] TRUE, FALSE
[17:39:26.763]  - until=2
[17:39:26.763]  - relaying element #2
[17:39:26.763] - relayed: [n=2] TRUE, TRUE
[17:39:26.764] - queued futures: [n=2] TRUE, TRUE
[17:39:26.764] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:26.764]  length: 0 (resolved future 2)
[17:39:26.764] Relaying remaining futures
[17:39:26.764] signalConditionsASAP(NULL, pos=0) ...
[17:39:26.764] - nx: 2
[17:39:26.764] - relay: TRUE
[17:39:26.764] - stdout: TRUE
[17:39:26.764] - signal: TRUE
[17:39:26.765] - resignal: FALSE
[17:39:26.765] - force: TRUE
[17:39:26.765] - relayed: [n=2] TRUE, TRUE
[17:39:26.765] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:26.765] - relayed: [n=2] TRUE, TRUE
[17:39:26.765] - queued futures: [n=2] TRUE, TRUE
[17:39:26.765] signalConditionsASAP(NULL, pos=0) ... done
[17:39:26.765] resolve() on list ... DONE
[17:39:26.766]  - Number of value chunks collected: 2
[17:39:26.766] Resolving 2 futures (chunks) ... DONE
[17:39:26.766] Reducing values from 2 chunks ...
[17:39:26.766]  - Number of values collected after concatenation: 3
[17:39:26.766]  - Number of values expected: 3
[17:39:26.766] Reducing values from 2 chunks ... DONE
[17:39:26.766] future_lapply() ... DONE
[17:39:26.766] future_by_internal() ... DONE
[17:39:26.768] future_by_internal() ...
- plan('multisession') ...
[17:39:26.768] plan(): Setting new future strategy stack:
[17:39:26.768] List of future strategies:
[17:39:26.768] 1. multisession:
[17:39:26.768]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:26.768]    - tweaked: FALSE
[17:39:26.768]    - call: plan(strategy)
[17:39:26.769] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:26.769] multisession:
[17:39:26.769] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:26.769] - tweaked: FALSE
[17:39:26.769] - call: plan(strategy)
[17:39:26.775] getGlobalsAndPackages() ...
[17:39:26.776] Not searching for globals
[17:39:26.776] - globals: [0] <none>
[17:39:26.776] getGlobalsAndPackages() ... DONE
[17:39:26.776] [local output] makeClusterPSOCK() ...
[17:39:26.824] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:39:26.830] [local output] Base port: 11394
[17:39:26.830] [local output] Getting setup options for 2 cluster nodes ...
[17:39:26.830] [local output]  - Node 1 of 2 ...
[17:39:26.830] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:26.831] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0aLE4m/worker.rank=1.parallelly.parent=30678.77d643776e9d.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp0aLE4m/worker.rank=1.parallelly.parent=30678.77d643776e9d.pid")'’
[17:39:27.019] - Possible to infer worker's PID: TRUE
[17:39:27.019] [local output] Rscript port: 11394

[17:39:27.020] [local output]  - Node 2 of 2 ...
[17:39:27.020] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:27.021] [local output] Rscript port: 11394

[17:39:27.021] [local output] Getting setup options for 2 cluster nodes ... done
[17:39:27.021] [local output]  - Parallel setup requested for some PSOCK nodes
[17:39:27.022] [local output] Setting up PSOCK nodes in parallel
[17:39:27.022] List of 36
[17:39:27.022]  $ worker          : chr "localhost"
[17:39:27.022]   ..- attr(*, "localhost")= logi TRUE
[17:39:27.022]  $ master          : chr "localhost"
[17:39:27.022]  $ port            : int 11394
[17:39:27.022]  $ connectTimeout  : num 120
[17:39:27.022]  $ timeout         : num 2592000
[17:39:27.022]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:39:27.022]  $ homogeneous     : logi TRUE
[17:39:27.022]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:39:27.022]  $ rscript_envs    : NULL
[17:39:27.022]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:27.022]  $ rscript_startup : NULL
[17:39:27.022]  $ rscript_sh      : chr "sh"
[17:39:27.022]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:27.022]  $ methods         : logi TRUE
[17:39:27.022]  $ socketOptions   : chr "no-delay"
[17:39:27.022]  $ useXDR          : logi FALSE
[17:39:27.022]  $ outfile         : chr "/dev/null"
[17:39:27.022]  $ renice          : int NA
[17:39:27.022]  $ rshcmd          : NULL
[17:39:27.022]  $ user            : chr(0) 
[17:39:27.022]  $ revtunnel       : logi FALSE
[17:39:27.022]  $ rshlogfile      : NULL
[17:39:27.022]  $ rshopts         : chr(0) 
[17:39:27.022]  $ rank            : int 1
[17:39:27.022]  $ manual          : logi FALSE
[17:39:27.022]  $ dryrun          : logi FALSE
[17:39:27.022]  $ quiet           : logi FALSE
[17:39:27.022]  $ setup_strategy  : chr "parallel"
[17:39:27.022]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:27.022]  $ pidfile         : chr "/tmp/Rtmp0aLE4m/worker.rank=1.parallelly.parent=30678.77d643776e9d.pid"
[17:39:27.022]  $ rshcmd_label    : NULL
[17:39:27.022]  $ rsh_call        : NULL
[17:39:27.022]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:27.022]  $ localMachine    : logi TRUE
[17:39:27.022]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:39:27.022]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:39:27.022]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:39:27.022]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:39:27.022]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:39:27.022]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:39:27.022]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:39:27.022]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:39:27.022]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:39:27.022]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:39:27.022]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:39:27.022]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:39:27.022]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:39:27.022]  $ arguments       :List of 28
[17:39:27.022]   ..$ worker          : chr "localhost"
[17:39:27.022]   ..$ master          : NULL
[17:39:27.022]   ..$ port            : int 11394
[17:39:27.022]   ..$ connectTimeout  : num 120
[17:39:27.022]   ..$ timeout         : num 2592000
[17:39:27.022]   ..$ rscript         : NULL
[17:39:27.022]   ..$ homogeneous     : NULL
[17:39:27.022]   ..$ rscript_args    : NULL
[17:39:27.022]   ..$ rscript_envs    : NULL
[17:39:27.022]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:27.022]   ..$ rscript_startup : NULL
[17:39:27.022]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:39:27.022]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:27.022]   ..$ methods         : logi TRUE
[17:39:27.022]   ..$ socketOptions   : chr "no-delay"
[17:39:27.022]   ..$ useXDR          : logi FALSE
[17:39:27.022]   ..$ outfile         : chr "/dev/null"
[17:39:27.022]   ..$ renice          : int NA
[17:39:27.022]   ..$ rshcmd          : NULL
[17:39:27.022]   ..$ user            : NULL
[17:39:27.022]   ..$ revtunnel       : logi NA
[17:39:27.022]   ..$ rshlogfile      : NULL
[17:39:27.022]   ..$ rshopts         : NULL
[17:39:27.022]   ..$ rank            : int 1
[17:39:27.022]   ..$ manual          : logi FALSE
[17:39:27.022]   ..$ dryrun          : logi FALSE
[17:39:27.022]   ..$ quiet           : logi FALSE
[17:39:27.022]   ..$ setup_strategy  : chr "parallel"
[17:39:27.022]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:39:27.038] [local output] System call to launch all workers:
[17:39:27.038] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0aLE4m/worker.rank=1.parallelly.parent=30678.77d643776e9d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11394 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:39:27.038] [local output] Starting PSOCK main server
[17:39:27.040] [local output] Workers launched
[17:39:27.040] [local output] Waiting for workers to connect back
[17:39:27.040]  - [local output] 0 workers out of 2 ready
[17:39:27.307]  - [local output] 0 workers out of 2 ready
[17:39:27.307]  - [local output] 1 workers out of 2 ready
[17:39:27.310]  - [local output] 1 workers out of 2 ready
[17:39:27.311]  - [local output] 2 workers out of 2 ready
[17:39:27.311] [local output] Launching of workers completed
[17:39:27.311] [local output] Collecting session information from workers
[17:39:27.312] [local output]  - Worker #1 of 2
[17:39:27.312] [local output]  - Worker #2 of 2
[17:39:27.313] [local output] makeClusterPSOCK() ... done
[17:39:27.324] Packages needed by the future expression (n = 0): <none>
[17:39:27.324] Packages needed by future strategies (n = 0): <none>
[17:39:27.325] {
[17:39:27.325]     {
[17:39:27.325]         {
[17:39:27.325]             ...future.startTime <- base::Sys.time()
[17:39:27.325]             {
[17:39:27.325]                 {
[17:39:27.325]                   {
[17:39:27.325]                     {
[17:39:27.325]                       base::local({
[17:39:27.325]                         has_future <- base::requireNamespace("future", 
[17:39:27.325]                           quietly = TRUE)
[17:39:27.325]                         if (has_future) {
[17:39:27.325]                           ns <- base::getNamespace("future")
[17:39:27.325]                           version <- ns[[".package"]][["version"]]
[17:39:27.325]                           if (is.null(version)) 
[17:39:27.325]                             version <- utils::packageVersion("future")
[17:39:27.325]                         }
[17:39:27.325]                         else {
[17:39:27.325]                           version <- NULL
[17:39:27.325]                         }
[17:39:27.325]                         if (!has_future || version < "1.8.0") {
[17:39:27.325]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:27.325]                             "", base::R.version$version.string), 
[17:39:27.325]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:27.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:27.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:27.325]                               "release", "version")], collapse = " "), 
[17:39:27.325]                             hostname = base::Sys.info()[["nodename"]])
[17:39:27.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:27.325]                             info)
[17:39:27.325]                           info <- base::paste(info, collapse = "; ")
[17:39:27.325]                           if (!has_future) {
[17:39:27.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:27.325]                               info)
[17:39:27.325]                           }
[17:39:27.325]                           else {
[17:39:27.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:27.325]                               info, version)
[17:39:27.325]                           }
[17:39:27.325]                           base::stop(msg)
[17:39:27.325]                         }
[17:39:27.325]                       })
[17:39:27.325]                     }
[17:39:27.325]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:27.325]                     base::options(mc.cores = 1L)
[17:39:27.325]                   }
[17:39:27.325]                   options(future.plan = NULL)
[17:39:27.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:27.325]                 }
[17:39:27.325]                 ...future.workdir <- getwd()
[17:39:27.325]             }
[17:39:27.325]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:27.325]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:27.325]         }
[17:39:27.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:27.325]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:27.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:27.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:27.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:27.325]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:27.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:27.325]             base::names(...future.oldOptions))
[17:39:27.325]     }
[17:39:27.325]     if (FALSE) {
[17:39:27.325]     }
[17:39:27.325]     else {
[17:39:27.325]         if (TRUE) {
[17:39:27.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:27.325]                 open = "w")
[17:39:27.325]         }
[17:39:27.325]         else {
[17:39:27.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:27.325]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:27.325]         }
[17:39:27.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:27.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:27.325]             base::sink(type = "output", split = FALSE)
[17:39:27.325]             base::close(...future.stdout)
[17:39:27.325]         }, add = TRUE)
[17:39:27.325]     }
[17:39:27.325]     ...future.frame <- base::sys.nframe()
[17:39:27.325]     ...future.conditions <- base::list()
[17:39:27.325]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:27.325]     if (FALSE) {
[17:39:27.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:27.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:27.325]     }
[17:39:27.325]     ...future.result <- base::tryCatch({
[17:39:27.325]         base::withCallingHandlers({
[17:39:27.325]             ...future.value <- base::withVisible(base::local({
[17:39:27.325]                 ...future.makeSendCondition <- local({
[17:39:27.325]                   sendCondition <- NULL
[17:39:27.325]                   function(frame = 1L) {
[17:39:27.325]                     if (is.function(sendCondition)) 
[17:39:27.325]                       return(sendCondition)
[17:39:27.325]                     ns <- getNamespace("parallel")
[17:39:27.325]                     if (exists("sendData", mode = "function", 
[17:39:27.325]                       envir = ns)) {
[17:39:27.325]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:27.325]                         envir = ns)
[17:39:27.325]                       envir <- sys.frame(frame)
[17:39:27.325]                       master <- NULL
[17:39:27.325]                       while (!identical(envir, .GlobalEnv) && 
[17:39:27.325]                         !identical(envir, emptyenv())) {
[17:39:27.325]                         if (exists("master", mode = "list", envir = envir, 
[17:39:27.325]                           inherits = FALSE)) {
[17:39:27.325]                           master <- get("master", mode = "list", 
[17:39:27.325]                             envir = envir, inherits = FALSE)
[17:39:27.325]                           if (inherits(master, c("SOCKnode", 
[17:39:27.325]                             "SOCK0node"))) {
[17:39:27.325]                             sendCondition <<- function(cond) {
[17:39:27.325]                               data <- list(type = "VALUE", value = cond, 
[17:39:27.325]                                 success = TRUE)
[17:39:27.325]                               parallel_sendData(master, data)
[17:39:27.325]                             }
[17:39:27.325]                             return(sendCondition)
[17:39:27.325]                           }
[17:39:27.325]                         }
[17:39:27.325]                         frame <- frame + 1L
[17:39:27.325]                         envir <- sys.frame(frame)
[17:39:27.325]                       }
[17:39:27.325]                     }
[17:39:27.325]                     sendCondition <<- function(cond) NULL
[17:39:27.325]                   }
[17:39:27.325]                 })
[17:39:27.325]                 withCallingHandlers({
[17:39:27.325]                   NA
[17:39:27.325]                 }, immediateCondition = function(cond) {
[17:39:27.325]                   sendCondition <- ...future.makeSendCondition()
[17:39:27.325]                   sendCondition(cond)
[17:39:27.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.325]                   {
[17:39:27.325]                     inherits <- base::inherits
[17:39:27.325]                     invokeRestart <- base::invokeRestart
[17:39:27.325]                     is.null <- base::is.null
[17:39:27.325]                     muffled <- FALSE
[17:39:27.325]                     if (inherits(cond, "message")) {
[17:39:27.325]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:27.325]                       if (muffled) 
[17:39:27.325]                         invokeRestart("muffleMessage")
[17:39:27.325]                     }
[17:39:27.325]                     else if (inherits(cond, "warning")) {
[17:39:27.325]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:27.325]                       if (muffled) 
[17:39:27.325]                         invokeRestart("muffleWarning")
[17:39:27.325]                     }
[17:39:27.325]                     else if (inherits(cond, "condition")) {
[17:39:27.325]                       if (!is.null(pattern)) {
[17:39:27.325]                         computeRestarts <- base::computeRestarts
[17:39:27.325]                         grepl <- base::grepl
[17:39:27.325]                         restarts <- computeRestarts(cond)
[17:39:27.325]                         for (restart in restarts) {
[17:39:27.325]                           name <- restart$name
[17:39:27.325]                           if (is.null(name)) 
[17:39:27.325]                             next
[17:39:27.325]                           if (!grepl(pattern, name)) 
[17:39:27.325]                             next
[17:39:27.325]                           invokeRestart(restart)
[17:39:27.325]                           muffled <- TRUE
[17:39:27.325]                           break
[17:39:27.325]                         }
[17:39:27.325]                       }
[17:39:27.325]                     }
[17:39:27.325]                     invisible(muffled)
[17:39:27.325]                   }
[17:39:27.325]                   muffleCondition(cond)
[17:39:27.325]                 })
[17:39:27.325]             }))
[17:39:27.325]             future::FutureResult(value = ...future.value$value, 
[17:39:27.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.325]                   ...future.rng), globalenv = if (FALSE) 
[17:39:27.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:27.325]                     ...future.globalenv.names))
[17:39:27.325]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:27.325]         }, condition = base::local({
[17:39:27.325]             c <- base::c
[17:39:27.325]             inherits <- base::inherits
[17:39:27.325]             invokeRestart <- base::invokeRestart
[17:39:27.325]             length <- base::length
[17:39:27.325]             list <- base::list
[17:39:27.325]             seq.int <- base::seq.int
[17:39:27.325]             signalCondition <- base::signalCondition
[17:39:27.325]             sys.calls <- base::sys.calls
[17:39:27.325]             `[[` <- base::`[[`
[17:39:27.325]             `+` <- base::`+`
[17:39:27.325]             `<<-` <- base::`<<-`
[17:39:27.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:27.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:27.325]                   3L)]
[17:39:27.325]             }
[17:39:27.325]             function(cond) {
[17:39:27.325]                 is_error <- inherits(cond, "error")
[17:39:27.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:27.325]                   NULL)
[17:39:27.325]                 if (is_error) {
[17:39:27.325]                   sessionInformation <- function() {
[17:39:27.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:27.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:27.325]                       search = base::search(), system = base::Sys.info())
[17:39:27.325]                   }
[17:39:27.325]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:27.325]                     cond$call), session = sessionInformation(), 
[17:39:27.325]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:27.325]                   signalCondition(cond)
[17:39:27.325]                 }
[17:39:27.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:27.325]                 "immediateCondition"))) {
[17:39:27.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:27.325]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:27.325]                   if (TRUE && !signal) {
[17:39:27.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.325]                     {
[17:39:27.325]                       inherits <- base::inherits
[17:39:27.325]                       invokeRestart <- base::invokeRestart
[17:39:27.325]                       is.null <- base::is.null
[17:39:27.325]                       muffled <- FALSE
[17:39:27.325]                       if (inherits(cond, "message")) {
[17:39:27.325]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.325]                         if (muffled) 
[17:39:27.325]                           invokeRestart("muffleMessage")
[17:39:27.325]                       }
[17:39:27.325]                       else if (inherits(cond, "warning")) {
[17:39:27.325]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.325]                         if (muffled) 
[17:39:27.325]                           invokeRestart("muffleWarning")
[17:39:27.325]                       }
[17:39:27.325]                       else if (inherits(cond, "condition")) {
[17:39:27.325]                         if (!is.null(pattern)) {
[17:39:27.325]                           computeRestarts <- base::computeRestarts
[17:39:27.325]                           grepl <- base::grepl
[17:39:27.325]                           restarts <- computeRestarts(cond)
[17:39:27.325]                           for (restart in restarts) {
[17:39:27.325]                             name <- restart$name
[17:39:27.325]                             if (is.null(name)) 
[17:39:27.325]                               next
[17:39:27.325]                             if (!grepl(pattern, name)) 
[17:39:27.325]                               next
[17:39:27.325]                             invokeRestart(restart)
[17:39:27.325]                             muffled <- TRUE
[17:39:27.325]                             break
[17:39:27.325]                           }
[17:39:27.325]                         }
[17:39:27.325]                       }
[17:39:27.325]                       invisible(muffled)
[17:39:27.325]                     }
[17:39:27.325]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.325]                   }
[17:39:27.325]                 }
[17:39:27.325]                 else {
[17:39:27.325]                   if (TRUE) {
[17:39:27.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.325]                     {
[17:39:27.325]                       inherits <- base::inherits
[17:39:27.325]                       invokeRestart <- base::invokeRestart
[17:39:27.325]                       is.null <- base::is.null
[17:39:27.325]                       muffled <- FALSE
[17:39:27.325]                       if (inherits(cond, "message")) {
[17:39:27.325]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.325]                         if (muffled) 
[17:39:27.325]                           invokeRestart("muffleMessage")
[17:39:27.325]                       }
[17:39:27.325]                       else if (inherits(cond, "warning")) {
[17:39:27.325]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.325]                         if (muffled) 
[17:39:27.325]                           invokeRestart("muffleWarning")
[17:39:27.325]                       }
[17:39:27.325]                       else if (inherits(cond, "condition")) {
[17:39:27.325]                         if (!is.null(pattern)) {
[17:39:27.325]                           computeRestarts <- base::computeRestarts
[17:39:27.325]                           grepl <- base::grepl
[17:39:27.325]                           restarts <- computeRestarts(cond)
[17:39:27.325]                           for (restart in restarts) {
[17:39:27.325]                             name <- restart$name
[17:39:27.325]                             if (is.null(name)) 
[17:39:27.325]                               next
[17:39:27.325]                             if (!grepl(pattern, name)) 
[17:39:27.325]                               next
[17:39:27.325]                             invokeRestart(restart)
[17:39:27.325]                             muffled <- TRUE
[17:39:27.325]                             break
[17:39:27.325]                           }
[17:39:27.325]                         }
[17:39:27.325]                       }
[17:39:27.325]                       invisible(muffled)
[17:39:27.325]                     }
[17:39:27.325]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.325]                   }
[17:39:27.325]                 }
[17:39:27.325]             }
[17:39:27.325]         }))
[17:39:27.325]     }, error = function(ex) {
[17:39:27.325]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:27.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.325]                 ...future.rng), started = ...future.startTime, 
[17:39:27.325]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:27.325]             version = "1.8"), class = "FutureResult")
[17:39:27.325]     }, finally = {
[17:39:27.325]         if (!identical(...future.workdir, getwd())) 
[17:39:27.325]             setwd(...future.workdir)
[17:39:27.325]         {
[17:39:27.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:27.325]                 ...future.oldOptions$nwarnings <- NULL
[17:39:27.325]             }
[17:39:27.325]             base::options(...future.oldOptions)
[17:39:27.325]             if (.Platform$OS.type == "windows") {
[17:39:27.325]                 old_names <- names(...future.oldEnvVars)
[17:39:27.325]                 envs <- base::Sys.getenv()
[17:39:27.325]                 names <- names(envs)
[17:39:27.325]                 common <- intersect(names, old_names)
[17:39:27.325]                 added <- setdiff(names, old_names)
[17:39:27.325]                 removed <- setdiff(old_names, names)
[17:39:27.325]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:27.325]                   envs[common]]
[17:39:27.325]                 NAMES <- toupper(changed)
[17:39:27.325]                 args <- list()
[17:39:27.325]                 for (kk in seq_along(NAMES)) {
[17:39:27.325]                   name <- changed[[kk]]
[17:39:27.325]                   NAME <- NAMES[[kk]]
[17:39:27.325]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.325]                     next
[17:39:27.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.325]                 }
[17:39:27.325]                 NAMES <- toupper(added)
[17:39:27.325]                 for (kk in seq_along(NAMES)) {
[17:39:27.325]                   name <- added[[kk]]
[17:39:27.325]                   NAME <- NAMES[[kk]]
[17:39:27.325]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.325]                     next
[17:39:27.325]                   args[[name]] <- ""
[17:39:27.325]                 }
[17:39:27.325]                 NAMES <- toupper(removed)
[17:39:27.325]                 for (kk in seq_along(NAMES)) {
[17:39:27.325]                   name <- removed[[kk]]
[17:39:27.325]                   NAME <- NAMES[[kk]]
[17:39:27.325]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.325]                     next
[17:39:27.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.325]                 }
[17:39:27.325]                 if (length(args) > 0) 
[17:39:27.325]                   base::do.call(base::Sys.setenv, args = args)
[17:39:27.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:27.325]             }
[17:39:27.325]             else {
[17:39:27.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:27.325]             }
[17:39:27.325]             {
[17:39:27.325]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:27.325]                   0L) {
[17:39:27.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:27.325]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:27.325]                   base::options(opts)
[17:39:27.325]                 }
[17:39:27.325]                 {
[17:39:27.325]                   {
[17:39:27.325]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:27.325]                     NULL
[17:39:27.325]                   }
[17:39:27.325]                   options(future.plan = NULL)
[17:39:27.325]                   if (is.na(NA_character_)) 
[17:39:27.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:27.325]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:27.325]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:27.325]                     envir = parent.frame()) 
[17:39:27.325]                   {
[17:39:27.325]                     if (is.function(workers)) 
[17:39:27.325]                       workers <- workers()
[17:39:27.325]                     workers <- structure(as.integer(workers), 
[17:39:27.325]                       class = class(workers))
[17:39:27.325]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:27.325]                       workers >= 1)
[17:39:27.325]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:27.325]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:27.325]                     }
[17:39:27.325]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:27.325]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:27.325]                       envir = envir)
[17:39:27.325]                     if (!future$lazy) 
[17:39:27.325]                       future <- run(future)
[17:39:27.325]                     invisible(future)
[17:39:27.325]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:27.325]                 }
[17:39:27.325]             }
[17:39:27.325]         }
[17:39:27.325]     })
[17:39:27.325]     if (TRUE) {
[17:39:27.325]         base::sink(type = "output", split = FALSE)
[17:39:27.325]         if (TRUE) {
[17:39:27.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:27.325]         }
[17:39:27.325]         else {
[17:39:27.325]             ...future.result["stdout"] <- base::list(NULL)
[17:39:27.325]         }
[17:39:27.325]         base::close(...future.stdout)
[17:39:27.325]         ...future.stdout <- NULL
[17:39:27.325]     }
[17:39:27.325]     ...future.result$conditions <- ...future.conditions
[17:39:27.325]     ...future.result$finished <- base::Sys.time()
[17:39:27.325]     ...future.result
[17:39:27.325] }
[17:39:27.395] MultisessionFuture started
[17:39:27.396] result() for ClusterFuture ...
[17:39:27.396] receiveMessageFromWorker() for ClusterFuture ...
[17:39:27.396] - Validating connection of MultisessionFuture
[17:39:27.427] - received message: FutureResult
[17:39:27.428] - Received FutureResult
[17:39:27.428] - Erased future from FutureRegistry
[17:39:27.428] result() for ClusterFuture ...
[17:39:27.428] - result already collected: FutureResult
[17:39:27.428] result() for ClusterFuture ... done
[17:39:27.428] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:27.428] result() for ClusterFuture ... done
[17:39:27.428] result() for ClusterFuture ...
[17:39:27.428] - result already collected: FutureResult
[17:39:27.428] result() for ClusterFuture ... done
[17:39:27.429] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:27.432] plan(): nbrOfWorkers() = 2
[17:39:27.432] future_by_internal() ...
[17:39:27.432] future_lapply() ...
[17:39:27.436] Number of chunks: 2
[17:39:27.436] getGlobalsAndPackagesXApply() ...
[17:39:27.436]  - future.globals: TRUE
[17:39:27.436] getGlobalsAndPackages() ...
[17:39:27.437] Searching for globals...
[17:39:27.438] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:27.438] Searching for globals ... DONE
[17:39:27.438] Resolving globals: FALSE
[17:39:27.438] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:27.439] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:27.439] - globals: [1] ‘FUN’
[17:39:27.439] 
[17:39:27.439] getGlobalsAndPackages() ... DONE
[17:39:27.439]  - globals found/used: [n=1] ‘FUN’
[17:39:27.439]  - needed namespaces: [n=0] 
[17:39:27.439] Finding globals ... DONE
[17:39:27.439]  - use_args: TRUE
[17:39:27.439]  - Getting '...' globals ...
[17:39:27.440] resolve() on list ...
[17:39:27.440]  recursive: 0
[17:39:27.440]  length: 1
[17:39:27.440]  elements: ‘...’
[17:39:27.440]  length: 0 (resolved future 1)
[17:39:27.440] resolve() on list ... DONE
[17:39:27.440]    - '...' content: [n=0] 
[17:39:27.440] List of 1
[17:39:27.440]  $ ...: list()
[17:39:27.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:27.440]  - attr(*, "where")=List of 1
[17:39:27.440]   ..$ ...:<environment: 0x5629720a9520> 
[17:39:27.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:27.440]  - attr(*, "resolved")= logi TRUE
[17:39:27.440]  - attr(*, "total_size")= num NA
[17:39:27.443]  - Getting '...' globals ... DONE
[17:39:27.443] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:27.443] List of 2
[17:39:27.443]  $ ...future.FUN:function (object, ...)  
[17:39:27.443]  $ ...          : list()
[17:39:27.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:27.443]  - attr(*, "where")=List of 2
[17:39:27.443]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:27.443]   ..$ ...          :<environment: 0x5629720a9520> 
[17:39:27.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:27.443]  - attr(*, "resolved")= logi FALSE
[17:39:27.443]  - attr(*, "total_size")= num 1240
[17:39:27.446] Packages to be attached in all futures: [n=0] 
[17:39:27.446] getGlobalsAndPackagesXApply() ... DONE
[17:39:27.446] Number of futures (= number of chunks): 2
[17:39:27.446] Launching 2 futures (chunks) ...
[17:39:27.446] Chunk #1 of 2 ...
[17:39:27.446]  - Finding globals in 'X' for chunk #1 ...
[17:39:27.446] getGlobalsAndPackages() ...
[17:39:27.446] Searching for globals...
[17:39:27.447] 
[17:39:27.447] Searching for globals ... DONE
[17:39:27.447] - globals: [0] <none>
[17:39:27.447] getGlobalsAndPackages() ... DONE
[17:39:27.447]    + additional globals found: [n=0] 
[17:39:27.447]    + additional namespaces needed: [n=0] 
[17:39:27.447]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:27.447]  - seeds: <none>
[17:39:27.448] getGlobalsAndPackages() ...
[17:39:27.448] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.448] Resolving globals: FALSE
[17:39:27.448] Tweak future expression to call with '...' arguments ...
[17:39:27.448] {
[17:39:27.448]     do.call(function(...) {
[17:39:27.448]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.448]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.448]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.448]             on.exit(options(oopts), add = TRUE)
[17:39:27.448]         }
[17:39:27.448]         {
[17:39:27.448]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.448]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.448]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.448]             })
[17:39:27.448]         }
[17:39:27.448]     }, args = future.call.arguments)
[17:39:27.448] }
[17:39:27.448] Tweak future expression to call with '...' arguments ... DONE
[17:39:27.448] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.449] 
[17:39:27.449] getGlobalsAndPackages() ... DONE
[17:39:27.449] run() for ‘Future’ ...
[17:39:27.449] - state: ‘created’
[17:39:27.449] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:27.463] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.463] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:27.464]   - Field: ‘node’
[17:39:27.464]   - Field: ‘label’
[17:39:27.464]   - Field: ‘local’
[17:39:27.464]   - Field: ‘owner’
[17:39:27.464]   - Field: ‘envir’
[17:39:27.464]   - Field: ‘workers’
[17:39:27.464]   - Field: ‘packages’
[17:39:27.464]   - Field: ‘gc’
[17:39:27.464]   - Field: ‘conditions’
[17:39:27.464]   - Field: ‘persistent’
[17:39:27.464]   - Field: ‘expr’
[17:39:27.465]   - Field: ‘uuid’
[17:39:27.465]   - Field: ‘seed’
[17:39:27.465]   - Field: ‘version’
[17:39:27.465]   - Field: ‘result’
[17:39:27.465]   - Field: ‘asynchronous’
[17:39:27.465]   - Field: ‘calls’
[17:39:27.465]   - Field: ‘globals’
[17:39:27.465]   - Field: ‘stdout’
[17:39:27.465]   - Field: ‘earlySignal’
[17:39:27.465]   - Field: ‘lazy’
[17:39:27.465]   - Field: ‘state’
[17:39:27.466] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:27.466] - Launch lazy future ...
[17:39:27.466] Packages needed by the future expression (n = 0): <none>
[17:39:27.466] Packages needed by future strategies (n = 0): <none>
[17:39:27.467] {
[17:39:27.467]     {
[17:39:27.467]         {
[17:39:27.467]             ...future.startTime <- base::Sys.time()
[17:39:27.467]             {
[17:39:27.467]                 {
[17:39:27.467]                   {
[17:39:27.467]                     {
[17:39:27.467]                       base::local({
[17:39:27.467]                         has_future <- base::requireNamespace("future", 
[17:39:27.467]                           quietly = TRUE)
[17:39:27.467]                         if (has_future) {
[17:39:27.467]                           ns <- base::getNamespace("future")
[17:39:27.467]                           version <- ns[[".package"]][["version"]]
[17:39:27.467]                           if (is.null(version)) 
[17:39:27.467]                             version <- utils::packageVersion("future")
[17:39:27.467]                         }
[17:39:27.467]                         else {
[17:39:27.467]                           version <- NULL
[17:39:27.467]                         }
[17:39:27.467]                         if (!has_future || version < "1.8.0") {
[17:39:27.467]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:27.467]                             "", base::R.version$version.string), 
[17:39:27.467]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:27.467]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:27.467]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:27.467]                               "release", "version")], collapse = " "), 
[17:39:27.467]                             hostname = base::Sys.info()[["nodename"]])
[17:39:27.467]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:27.467]                             info)
[17:39:27.467]                           info <- base::paste(info, collapse = "; ")
[17:39:27.467]                           if (!has_future) {
[17:39:27.467]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:27.467]                               info)
[17:39:27.467]                           }
[17:39:27.467]                           else {
[17:39:27.467]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:27.467]                               info, version)
[17:39:27.467]                           }
[17:39:27.467]                           base::stop(msg)
[17:39:27.467]                         }
[17:39:27.467]                       })
[17:39:27.467]                     }
[17:39:27.467]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:27.467]                     base::options(mc.cores = 1L)
[17:39:27.467]                   }
[17:39:27.467]                   options(future.plan = NULL)
[17:39:27.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:27.467]                 }
[17:39:27.467]                 ...future.workdir <- getwd()
[17:39:27.467]             }
[17:39:27.467]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:27.467]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:27.467]         }
[17:39:27.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:27.467]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:27.467]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:27.467]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:27.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:27.467]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:27.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:27.467]             base::names(...future.oldOptions))
[17:39:27.467]     }
[17:39:27.467]     if (FALSE) {
[17:39:27.467]     }
[17:39:27.467]     else {
[17:39:27.467]         if (TRUE) {
[17:39:27.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:27.467]                 open = "w")
[17:39:27.467]         }
[17:39:27.467]         else {
[17:39:27.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:27.467]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:27.467]         }
[17:39:27.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:27.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:27.467]             base::sink(type = "output", split = FALSE)
[17:39:27.467]             base::close(...future.stdout)
[17:39:27.467]         }, add = TRUE)
[17:39:27.467]     }
[17:39:27.467]     ...future.frame <- base::sys.nframe()
[17:39:27.467]     ...future.conditions <- base::list()
[17:39:27.467]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:27.467]     if (FALSE) {
[17:39:27.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:27.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:27.467]     }
[17:39:27.467]     ...future.result <- base::tryCatch({
[17:39:27.467]         base::withCallingHandlers({
[17:39:27.467]             ...future.value <- base::withVisible(base::local({
[17:39:27.467]                 ...future.makeSendCondition <- local({
[17:39:27.467]                   sendCondition <- NULL
[17:39:27.467]                   function(frame = 1L) {
[17:39:27.467]                     if (is.function(sendCondition)) 
[17:39:27.467]                       return(sendCondition)
[17:39:27.467]                     ns <- getNamespace("parallel")
[17:39:27.467]                     if (exists("sendData", mode = "function", 
[17:39:27.467]                       envir = ns)) {
[17:39:27.467]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:27.467]                         envir = ns)
[17:39:27.467]                       envir <- sys.frame(frame)
[17:39:27.467]                       master <- NULL
[17:39:27.467]                       while (!identical(envir, .GlobalEnv) && 
[17:39:27.467]                         !identical(envir, emptyenv())) {
[17:39:27.467]                         if (exists("master", mode = "list", envir = envir, 
[17:39:27.467]                           inherits = FALSE)) {
[17:39:27.467]                           master <- get("master", mode = "list", 
[17:39:27.467]                             envir = envir, inherits = FALSE)
[17:39:27.467]                           if (inherits(master, c("SOCKnode", 
[17:39:27.467]                             "SOCK0node"))) {
[17:39:27.467]                             sendCondition <<- function(cond) {
[17:39:27.467]                               data <- list(type = "VALUE", value = cond, 
[17:39:27.467]                                 success = TRUE)
[17:39:27.467]                               parallel_sendData(master, data)
[17:39:27.467]                             }
[17:39:27.467]                             return(sendCondition)
[17:39:27.467]                           }
[17:39:27.467]                         }
[17:39:27.467]                         frame <- frame + 1L
[17:39:27.467]                         envir <- sys.frame(frame)
[17:39:27.467]                       }
[17:39:27.467]                     }
[17:39:27.467]                     sendCondition <<- function(cond) NULL
[17:39:27.467]                   }
[17:39:27.467]                 })
[17:39:27.467]                 withCallingHandlers({
[17:39:27.467]                   {
[17:39:27.467]                     do.call(function(...) {
[17:39:27.467]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.467]                       if (!identical(...future.globals.maxSize.org, 
[17:39:27.467]                         ...future.globals.maxSize)) {
[17:39:27.467]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.467]                         on.exit(options(oopts), add = TRUE)
[17:39:27.467]                       }
[17:39:27.467]                       {
[17:39:27.467]                         lapply(seq_along(...future.elements_ii), 
[17:39:27.467]                           FUN = function(jj) {
[17:39:27.467]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.467]                             ...future.FUN(...future.X_jj, ...)
[17:39:27.467]                           })
[17:39:27.467]                       }
[17:39:27.467]                     }, args = future.call.arguments)
[17:39:27.467]                   }
[17:39:27.467]                 }, immediateCondition = function(cond) {
[17:39:27.467]                   sendCondition <- ...future.makeSendCondition()
[17:39:27.467]                   sendCondition(cond)
[17:39:27.467]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.467]                   {
[17:39:27.467]                     inherits <- base::inherits
[17:39:27.467]                     invokeRestart <- base::invokeRestart
[17:39:27.467]                     is.null <- base::is.null
[17:39:27.467]                     muffled <- FALSE
[17:39:27.467]                     if (inherits(cond, "message")) {
[17:39:27.467]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:27.467]                       if (muffled) 
[17:39:27.467]                         invokeRestart("muffleMessage")
[17:39:27.467]                     }
[17:39:27.467]                     else if (inherits(cond, "warning")) {
[17:39:27.467]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:27.467]                       if (muffled) 
[17:39:27.467]                         invokeRestart("muffleWarning")
[17:39:27.467]                     }
[17:39:27.467]                     else if (inherits(cond, "condition")) {
[17:39:27.467]                       if (!is.null(pattern)) {
[17:39:27.467]                         computeRestarts <- base::computeRestarts
[17:39:27.467]                         grepl <- base::grepl
[17:39:27.467]                         restarts <- computeRestarts(cond)
[17:39:27.467]                         for (restart in restarts) {
[17:39:27.467]                           name <- restart$name
[17:39:27.467]                           if (is.null(name)) 
[17:39:27.467]                             next
[17:39:27.467]                           if (!grepl(pattern, name)) 
[17:39:27.467]                             next
[17:39:27.467]                           invokeRestart(restart)
[17:39:27.467]                           muffled <- TRUE
[17:39:27.467]                           break
[17:39:27.467]                         }
[17:39:27.467]                       }
[17:39:27.467]                     }
[17:39:27.467]                     invisible(muffled)
[17:39:27.467]                   }
[17:39:27.467]                   muffleCondition(cond)
[17:39:27.467]                 })
[17:39:27.467]             }))
[17:39:27.467]             future::FutureResult(value = ...future.value$value, 
[17:39:27.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.467]                   ...future.rng), globalenv = if (FALSE) 
[17:39:27.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:27.467]                     ...future.globalenv.names))
[17:39:27.467]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:27.467]         }, condition = base::local({
[17:39:27.467]             c <- base::c
[17:39:27.467]             inherits <- base::inherits
[17:39:27.467]             invokeRestart <- base::invokeRestart
[17:39:27.467]             length <- base::length
[17:39:27.467]             list <- base::list
[17:39:27.467]             seq.int <- base::seq.int
[17:39:27.467]             signalCondition <- base::signalCondition
[17:39:27.467]             sys.calls <- base::sys.calls
[17:39:27.467]             `[[` <- base::`[[`
[17:39:27.467]             `+` <- base::`+`
[17:39:27.467]             `<<-` <- base::`<<-`
[17:39:27.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:27.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:27.467]                   3L)]
[17:39:27.467]             }
[17:39:27.467]             function(cond) {
[17:39:27.467]                 is_error <- inherits(cond, "error")
[17:39:27.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:27.467]                   NULL)
[17:39:27.467]                 if (is_error) {
[17:39:27.467]                   sessionInformation <- function() {
[17:39:27.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:27.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:27.467]                       search = base::search(), system = base::Sys.info())
[17:39:27.467]                   }
[17:39:27.467]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:27.467]                     cond$call), session = sessionInformation(), 
[17:39:27.467]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:27.467]                   signalCondition(cond)
[17:39:27.467]                 }
[17:39:27.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:27.467]                 "immediateCondition"))) {
[17:39:27.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:27.467]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:27.467]                   if (TRUE && !signal) {
[17:39:27.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.467]                     {
[17:39:27.467]                       inherits <- base::inherits
[17:39:27.467]                       invokeRestart <- base::invokeRestart
[17:39:27.467]                       is.null <- base::is.null
[17:39:27.467]                       muffled <- FALSE
[17:39:27.467]                       if (inherits(cond, "message")) {
[17:39:27.467]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.467]                         if (muffled) 
[17:39:27.467]                           invokeRestart("muffleMessage")
[17:39:27.467]                       }
[17:39:27.467]                       else if (inherits(cond, "warning")) {
[17:39:27.467]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.467]                         if (muffled) 
[17:39:27.467]                           invokeRestart("muffleWarning")
[17:39:27.467]                       }
[17:39:27.467]                       else if (inherits(cond, "condition")) {
[17:39:27.467]                         if (!is.null(pattern)) {
[17:39:27.467]                           computeRestarts <- base::computeRestarts
[17:39:27.467]                           grepl <- base::grepl
[17:39:27.467]                           restarts <- computeRestarts(cond)
[17:39:27.467]                           for (restart in restarts) {
[17:39:27.467]                             name <- restart$name
[17:39:27.467]                             if (is.null(name)) 
[17:39:27.467]                               next
[17:39:27.467]                             if (!grepl(pattern, name)) 
[17:39:27.467]                               next
[17:39:27.467]                             invokeRestart(restart)
[17:39:27.467]                             muffled <- TRUE
[17:39:27.467]                             break
[17:39:27.467]                           }
[17:39:27.467]                         }
[17:39:27.467]                       }
[17:39:27.467]                       invisible(muffled)
[17:39:27.467]                     }
[17:39:27.467]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.467]                   }
[17:39:27.467]                 }
[17:39:27.467]                 else {
[17:39:27.467]                   if (TRUE) {
[17:39:27.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.467]                     {
[17:39:27.467]                       inherits <- base::inherits
[17:39:27.467]                       invokeRestart <- base::invokeRestart
[17:39:27.467]                       is.null <- base::is.null
[17:39:27.467]                       muffled <- FALSE
[17:39:27.467]                       if (inherits(cond, "message")) {
[17:39:27.467]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.467]                         if (muffled) 
[17:39:27.467]                           invokeRestart("muffleMessage")
[17:39:27.467]                       }
[17:39:27.467]                       else if (inherits(cond, "warning")) {
[17:39:27.467]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.467]                         if (muffled) 
[17:39:27.467]                           invokeRestart("muffleWarning")
[17:39:27.467]                       }
[17:39:27.467]                       else if (inherits(cond, "condition")) {
[17:39:27.467]                         if (!is.null(pattern)) {
[17:39:27.467]                           computeRestarts <- base::computeRestarts
[17:39:27.467]                           grepl <- base::grepl
[17:39:27.467]                           restarts <- computeRestarts(cond)
[17:39:27.467]                           for (restart in restarts) {
[17:39:27.467]                             name <- restart$name
[17:39:27.467]                             if (is.null(name)) 
[17:39:27.467]                               next
[17:39:27.467]                             if (!grepl(pattern, name)) 
[17:39:27.467]                               next
[17:39:27.467]                             invokeRestart(restart)
[17:39:27.467]                             muffled <- TRUE
[17:39:27.467]                             break
[17:39:27.467]                           }
[17:39:27.467]                         }
[17:39:27.467]                       }
[17:39:27.467]                       invisible(muffled)
[17:39:27.467]                     }
[17:39:27.467]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.467]                   }
[17:39:27.467]                 }
[17:39:27.467]             }
[17:39:27.467]         }))
[17:39:27.467]     }, error = function(ex) {
[17:39:27.467]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:27.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.467]                 ...future.rng), started = ...future.startTime, 
[17:39:27.467]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:27.467]             version = "1.8"), class = "FutureResult")
[17:39:27.467]     }, finally = {
[17:39:27.467]         if (!identical(...future.workdir, getwd())) 
[17:39:27.467]             setwd(...future.workdir)
[17:39:27.467]         {
[17:39:27.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:27.467]                 ...future.oldOptions$nwarnings <- NULL
[17:39:27.467]             }
[17:39:27.467]             base::options(...future.oldOptions)
[17:39:27.467]             if (.Platform$OS.type == "windows") {
[17:39:27.467]                 old_names <- names(...future.oldEnvVars)
[17:39:27.467]                 envs <- base::Sys.getenv()
[17:39:27.467]                 names <- names(envs)
[17:39:27.467]                 common <- intersect(names, old_names)
[17:39:27.467]                 added <- setdiff(names, old_names)
[17:39:27.467]                 removed <- setdiff(old_names, names)
[17:39:27.467]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:27.467]                   envs[common]]
[17:39:27.467]                 NAMES <- toupper(changed)
[17:39:27.467]                 args <- list()
[17:39:27.467]                 for (kk in seq_along(NAMES)) {
[17:39:27.467]                   name <- changed[[kk]]
[17:39:27.467]                   NAME <- NAMES[[kk]]
[17:39:27.467]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.467]                     next
[17:39:27.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.467]                 }
[17:39:27.467]                 NAMES <- toupper(added)
[17:39:27.467]                 for (kk in seq_along(NAMES)) {
[17:39:27.467]                   name <- added[[kk]]
[17:39:27.467]                   NAME <- NAMES[[kk]]
[17:39:27.467]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.467]                     next
[17:39:27.467]                   args[[name]] <- ""
[17:39:27.467]                 }
[17:39:27.467]                 NAMES <- toupper(removed)
[17:39:27.467]                 for (kk in seq_along(NAMES)) {
[17:39:27.467]                   name <- removed[[kk]]
[17:39:27.467]                   NAME <- NAMES[[kk]]
[17:39:27.467]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.467]                     next
[17:39:27.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.467]                 }
[17:39:27.467]                 if (length(args) > 0) 
[17:39:27.467]                   base::do.call(base::Sys.setenv, args = args)
[17:39:27.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:27.467]             }
[17:39:27.467]             else {
[17:39:27.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:27.467]             }
[17:39:27.467]             {
[17:39:27.467]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:27.467]                   0L) {
[17:39:27.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:27.467]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:27.467]                   base::options(opts)
[17:39:27.467]                 }
[17:39:27.467]                 {
[17:39:27.467]                   {
[17:39:27.467]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:27.467]                     NULL
[17:39:27.467]                   }
[17:39:27.467]                   options(future.plan = NULL)
[17:39:27.467]                   if (is.na(NA_character_)) 
[17:39:27.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:27.467]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:27.467]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:27.467]                     envir = parent.frame()) 
[17:39:27.467]                   {
[17:39:27.467]                     if (is.function(workers)) 
[17:39:27.467]                       workers <- workers()
[17:39:27.467]                     workers <- structure(as.integer(workers), 
[17:39:27.467]                       class = class(workers))
[17:39:27.467]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:27.467]                       workers >= 1)
[17:39:27.467]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:27.467]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:27.467]                     }
[17:39:27.467]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:27.467]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:27.467]                       envir = envir)
[17:39:27.467]                     if (!future$lazy) 
[17:39:27.467]                       future <- run(future)
[17:39:27.467]                     invisible(future)
[17:39:27.467]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:27.467]                 }
[17:39:27.467]             }
[17:39:27.467]         }
[17:39:27.467]     })
[17:39:27.467]     if (TRUE) {
[17:39:27.467]         base::sink(type = "output", split = FALSE)
[17:39:27.467]         if (TRUE) {
[17:39:27.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:27.467]         }
[17:39:27.467]         else {
[17:39:27.467]             ...future.result["stdout"] <- base::list(NULL)
[17:39:27.467]         }
[17:39:27.467]         base::close(...future.stdout)
[17:39:27.467]         ...future.stdout <- NULL
[17:39:27.467]     }
[17:39:27.467]     ...future.result$conditions <- ...future.conditions
[17:39:27.467]     ...future.result$finished <- base::Sys.time()
[17:39:27.467]     ...future.result
[17:39:27.467] }
[17:39:27.469] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:39:27.470] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:39:27.470] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:39:27.470] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:27.471] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:27.471] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[17:39:27.471] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[17:39:27.472] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:27.472] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:27.472] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:27.472] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:27.473] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:39:27.473] MultisessionFuture started
[17:39:27.473] - Launch lazy future ... done
[17:39:27.473] run() for ‘MultisessionFuture’ ... done
[17:39:27.474] Created future:
[17:39:27.474] MultisessionFuture:
[17:39:27.474] Label: ‘future_by-1’
[17:39:27.474] Expression:
[17:39:27.474] {
[17:39:27.474]     do.call(function(...) {
[17:39:27.474]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.474]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.474]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.474]             on.exit(options(oopts), add = TRUE)
[17:39:27.474]         }
[17:39:27.474]         {
[17:39:27.474]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.474]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.474]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.474]             })
[17:39:27.474]         }
[17:39:27.474]     }, args = future.call.arguments)
[17:39:27.474] }
[17:39:27.474] Lazy evaluation: FALSE
[17:39:27.474] Asynchronous evaluation: TRUE
[17:39:27.474] Local evaluation: TRUE
[17:39:27.474] Environment: R_GlobalEnv
[17:39:27.474] Capture standard output: TRUE
[17:39:27.474] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:27.474] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:27.474] Packages: <none>
[17:39:27.474] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:27.474] Resolved: FALSE
[17:39:27.474] Value: <not collected>
[17:39:27.474] Conditions captured: <none>
[17:39:27.474] Early signaling: FALSE
[17:39:27.474] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:27.474] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.486] Chunk #1 of 2 ... DONE
[17:39:27.486] Chunk #2 of 2 ...
[17:39:27.486]  - Finding globals in 'X' for chunk #2 ...
[17:39:27.486] getGlobalsAndPackages() ...
[17:39:27.486] Searching for globals...
[17:39:27.487] 
[17:39:27.487] Searching for globals ... DONE
[17:39:27.487] - globals: [0] <none>
[17:39:27.487] getGlobalsAndPackages() ... DONE
[17:39:27.487]    + additional globals found: [n=0] 
[17:39:27.487]    + additional namespaces needed: [n=0] 
[17:39:27.487]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:27.487]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:27.488]  - seeds: <none>
[17:39:27.488] getGlobalsAndPackages() ...
[17:39:27.488] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.488] Resolving globals: FALSE
[17:39:27.488] Tweak future expression to call with '...' arguments ...
[17:39:27.488] {
[17:39:27.488]     do.call(function(...) {
[17:39:27.488]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.488]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.488]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.488]             on.exit(options(oopts), add = TRUE)
[17:39:27.488]         }
[17:39:27.488]         {
[17:39:27.488]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.488]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.488]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.488]             })
[17:39:27.488]         }
[17:39:27.488]     }, args = future.call.arguments)
[17:39:27.488] }
[17:39:27.488] Tweak future expression to call with '...' arguments ... DONE
[17:39:27.489] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.489] 
[17:39:27.489] getGlobalsAndPackages() ... DONE
[17:39:27.489] run() for ‘Future’ ...
[17:39:27.489] - state: ‘created’
[17:39:27.489] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:27.505] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:27.505]   - Field: ‘node’
[17:39:27.506]   - Field: ‘label’
[17:39:27.506]   - Field: ‘local’
[17:39:27.506]   - Field: ‘owner’
[17:39:27.506]   - Field: ‘envir’
[17:39:27.506]   - Field: ‘workers’
[17:39:27.506]   - Field: ‘packages’
[17:39:27.506]   - Field: ‘gc’
[17:39:27.506]   - Field: ‘conditions’
[17:39:27.506]   - Field: ‘persistent’
[17:39:27.506]   - Field: ‘expr’
[17:39:27.507]   - Field: ‘uuid’
[17:39:27.507]   - Field: ‘seed’
[17:39:27.507]   - Field: ‘version’
[17:39:27.507]   - Field: ‘result’
[17:39:27.507]   - Field: ‘asynchronous’
[17:39:27.507]   - Field: ‘calls’
[17:39:27.507]   - Field: ‘globals’
[17:39:27.507]   - Field: ‘stdout’
[17:39:27.507]   - Field: ‘earlySignal’
[17:39:27.507]   - Field: ‘lazy’
[17:39:27.507]   - Field: ‘state’
[17:39:27.508] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:27.508] - Launch lazy future ...
[17:39:27.508] Packages needed by the future expression (n = 0): <none>
[17:39:27.508] Packages needed by future strategies (n = 0): <none>
[17:39:27.508] {
[17:39:27.508]     {
[17:39:27.508]         {
[17:39:27.508]             ...future.startTime <- base::Sys.time()
[17:39:27.508]             {
[17:39:27.508]                 {
[17:39:27.508]                   {
[17:39:27.508]                     {
[17:39:27.508]                       base::local({
[17:39:27.508]                         has_future <- base::requireNamespace("future", 
[17:39:27.508]                           quietly = TRUE)
[17:39:27.508]                         if (has_future) {
[17:39:27.508]                           ns <- base::getNamespace("future")
[17:39:27.508]                           version <- ns[[".package"]][["version"]]
[17:39:27.508]                           if (is.null(version)) 
[17:39:27.508]                             version <- utils::packageVersion("future")
[17:39:27.508]                         }
[17:39:27.508]                         else {
[17:39:27.508]                           version <- NULL
[17:39:27.508]                         }
[17:39:27.508]                         if (!has_future || version < "1.8.0") {
[17:39:27.508]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:27.508]                             "", base::R.version$version.string), 
[17:39:27.508]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:27.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:27.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:27.508]                               "release", "version")], collapse = " "), 
[17:39:27.508]                             hostname = base::Sys.info()[["nodename"]])
[17:39:27.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:27.508]                             info)
[17:39:27.508]                           info <- base::paste(info, collapse = "; ")
[17:39:27.508]                           if (!has_future) {
[17:39:27.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:27.508]                               info)
[17:39:27.508]                           }
[17:39:27.508]                           else {
[17:39:27.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:27.508]                               info, version)
[17:39:27.508]                           }
[17:39:27.508]                           base::stop(msg)
[17:39:27.508]                         }
[17:39:27.508]                       })
[17:39:27.508]                     }
[17:39:27.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:27.508]                     base::options(mc.cores = 1L)
[17:39:27.508]                   }
[17:39:27.508]                   options(future.plan = NULL)
[17:39:27.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:27.508]                 }
[17:39:27.508]                 ...future.workdir <- getwd()
[17:39:27.508]             }
[17:39:27.508]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:27.508]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:27.508]         }
[17:39:27.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:27.508]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:27.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:27.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:27.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:27.508]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:27.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:27.508]             base::names(...future.oldOptions))
[17:39:27.508]     }
[17:39:27.508]     if (FALSE) {
[17:39:27.508]     }
[17:39:27.508]     else {
[17:39:27.508]         if (TRUE) {
[17:39:27.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:27.508]                 open = "w")
[17:39:27.508]         }
[17:39:27.508]         else {
[17:39:27.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:27.508]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:27.508]         }
[17:39:27.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:27.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:27.508]             base::sink(type = "output", split = FALSE)
[17:39:27.508]             base::close(...future.stdout)
[17:39:27.508]         }, add = TRUE)
[17:39:27.508]     }
[17:39:27.508]     ...future.frame <- base::sys.nframe()
[17:39:27.508]     ...future.conditions <- base::list()
[17:39:27.508]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:27.508]     if (FALSE) {
[17:39:27.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:27.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:27.508]     }
[17:39:27.508]     ...future.result <- base::tryCatch({
[17:39:27.508]         base::withCallingHandlers({
[17:39:27.508]             ...future.value <- base::withVisible(base::local({
[17:39:27.508]                 ...future.makeSendCondition <- local({
[17:39:27.508]                   sendCondition <- NULL
[17:39:27.508]                   function(frame = 1L) {
[17:39:27.508]                     if (is.function(sendCondition)) 
[17:39:27.508]                       return(sendCondition)
[17:39:27.508]                     ns <- getNamespace("parallel")
[17:39:27.508]                     if (exists("sendData", mode = "function", 
[17:39:27.508]                       envir = ns)) {
[17:39:27.508]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:27.508]                         envir = ns)
[17:39:27.508]                       envir <- sys.frame(frame)
[17:39:27.508]                       master <- NULL
[17:39:27.508]                       while (!identical(envir, .GlobalEnv) && 
[17:39:27.508]                         !identical(envir, emptyenv())) {
[17:39:27.508]                         if (exists("master", mode = "list", envir = envir, 
[17:39:27.508]                           inherits = FALSE)) {
[17:39:27.508]                           master <- get("master", mode = "list", 
[17:39:27.508]                             envir = envir, inherits = FALSE)
[17:39:27.508]                           if (inherits(master, c("SOCKnode", 
[17:39:27.508]                             "SOCK0node"))) {
[17:39:27.508]                             sendCondition <<- function(cond) {
[17:39:27.508]                               data <- list(type = "VALUE", value = cond, 
[17:39:27.508]                                 success = TRUE)
[17:39:27.508]                               parallel_sendData(master, data)
[17:39:27.508]                             }
[17:39:27.508]                             return(sendCondition)
[17:39:27.508]                           }
[17:39:27.508]                         }
[17:39:27.508]                         frame <- frame + 1L
[17:39:27.508]                         envir <- sys.frame(frame)
[17:39:27.508]                       }
[17:39:27.508]                     }
[17:39:27.508]                     sendCondition <<- function(cond) NULL
[17:39:27.508]                   }
[17:39:27.508]                 })
[17:39:27.508]                 withCallingHandlers({
[17:39:27.508]                   {
[17:39:27.508]                     do.call(function(...) {
[17:39:27.508]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.508]                       if (!identical(...future.globals.maxSize.org, 
[17:39:27.508]                         ...future.globals.maxSize)) {
[17:39:27.508]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.508]                         on.exit(options(oopts), add = TRUE)
[17:39:27.508]                       }
[17:39:27.508]                       {
[17:39:27.508]                         lapply(seq_along(...future.elements_ii), 
[17:39:27.508]                           FUN = function(jj) {
[17:39:27.508]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.508]                             ...future.FUN(...future.X_jj, ...)
[17:39:27.508]                           })
[17:39:27.508]                       }
[17:39:27.508]                     }, args = future.call.arguments)
[17:39:27.508]                   }
[17:39:27.508]                 }, immediateCondition = function(cond) {
[17:39:27.508]                   sendCondition <- ...future.makeSendCondition()
[17:39:27.508]                   sendCondition(cond)
[17:39:27.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.508]                   {
[17:39:27.508]                     inherits <- base::inherits
[17:39:27.508]                     invokeRestart <- base::invokeRestart
[17:39:27.508]                     is.null <- base::is.null
[17:39:27.508]                     muffled <- FALSE
[17:39:27.508]                     if (inherits(cond, "message")) {
[17:39:27.508]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:27.508]                       if (muffled) 
[17:39:27.508]                         invokeRestart("muffleMessage")
[17:39:27.508]                     }
[17:39:27.508]                     else if (inherits(cond, "warning")) {
[17:39:27.508]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:27.508]                       if (muffled) 
[17:39:27.508]                         invokeRestart("muffleWarning")
[17:39:27.508]                     }
[17:39:27.508]                     else if (inherits(cond, "condition")) {
[17:39:27.508]                       if (!is.null(pattern)) {
[17:39:27.508]                         computeRestarts <- base::computeRestarts
[17:39:27.508]                         grepl <- base::grepl
[17:39:27.508]                         restarts <- computeRestarts(cond)
[17:39:27.508]                         for (restart in restarts) {
[17:39:27.508]                           name <- restart$name
[17:39:27.508]                           if (is.null(name)) 
[17:39:27.508]                             next
[17:39:27.508]                           if (!grepl(pattern, name)) 
[17:39:27.508]                             next
[17:39:27.508]                           invokeRestart(restart)
[17:39:27.508]                           muffled <- TRUE
[17:39:27.508]                           break
[17:39:27.508]                         }
[17:39:27.508]                       }
[17:39:27.508]                     }
[17:39:27.508]                     invisible(muffled)
[17:39:27.508]                   }
[17:39:27.508]                   muffleCondition(cond)
[17:39:27.508]                 })
[17:39:27.508]             }))
[17:39:27.508]             future::FutureResult(value = ...future.value$value, 
[17:39:27.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.508]                   ...future.rng), globalenv = if (FALSE) 
[17:39:27.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:27.508]                     ...future.globalenv.names))
[17:39:27.508]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:27.508]         }, condition = base::local({
[17:39:27.508]             c <- base::c
[17:39:27.508]             inherits <- base::inherits
[17:39:27.508]             invokeRestart <- base::invokeRestart
[17:39:27.508]             length <- base::length
[17:39:27.508]             list <- base::list
[17:39:27.508]             seq.int <- base::seq.int
[17:39:27.508]             signalCondition <- base::signalCondition
[17:39:27.508]             sys.calls <- base::sys.calls
[17:39:27.508]             `[[` <- base::`[[`
[17:39:27.508]             `+` <- base::`+`
[17:39:27.508]             `<<-` <- base::`<<-`
[17:39:27.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:27.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:27.508]                   3L)]
[17:39:27.508]             }
[17:39:27.508]             function(cond) {
[17:39:27.508]                 is_error <- inherits(cond, "error")
[17:39:27.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:27.508]                   NULL)
[17:39:27.508]                 if (is_error) {
[17:39:27.508]                   sessionInformation <- function() {
[17:39:27.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:27.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:27.508]                       search = base::search(), system = base::Sys.info())
[17:39:27.508]                   }
[17:39:27.508]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:27.508]                     cond$call), session = sessionInformation(), 
[17:39:27.508]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:27.508]                   signalCondition(cond)
[17:39:27.508]                 }
[17:39:27.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:27.508]                 "immediateCondition"))) {
[17:39:27.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:27.508]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:27.508]                   if (TRUE && !signal) {
[17:39:27.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.508]                     {
[17:39:27.508]                       inherits <- base::inherits
[17:39:27.508]                       invokeRestart <- base::invokeRestart
[17:39:27.508]                       is.null <- base::is.null
[17:39:27.508]                       muffled <- FALSE
[17:39:27.508]                       if (inherits(cond, "message")) {
[17:39:27.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.508]                         if (muffled) 
[17:39:27.508]                           invokeRestart("muffleMessage")
[17:39:27.508]                       }
[17:39:27.508]                       else if (inherits(cond, "warning")) {
[17:39:27.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.508]                         if (muffled) 
[17:39:27.508]                           invokeRestart("muffleWarning")
[17:39:27.508]                       }
[17:39:27.508]                       else if (inherits(cond, "condition")) {
[17:39:27.508]                         if (!is.null(pattern)) {
[17:39:27.508]                           computeRestarts <- base::computeRestarts
[17:39:27.508]                           grepl <- base::grepl
[17:39:27.508]                           restarts <- computeRestarts(cond)
[17:39:27.508]                           for (restart in restarts) {
[17:39:27.508]                             name <- restart$name
[17:39:27.508]                             if (is.null(name)) 
[17:39:27.508]                               next
[17:39:27.508]                             if (!grepl(pattern, name)) 
[17:39:27.508]                               next
[17:39:27.508]                             invokeRestart(restart)
[17:39:27.508]                             muffled <- TRUE
[17:39:27.508]                             break
[17:39:27.508]                           }
[17:39:27.508]                         }
[17:39:27.508]                       }
[17:39:27.508]                       invisible(muffled)
[17:39:27.508]                     }
[17:39:27.508]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.508]                   }
[17:39:27.508]                 }
[17:39:27.508]                 else {
[17:39:27.508]                   if (TRUE) {
[17:39:27.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.508]                     {
[17:39:27.508]                       inherits <- base::inherits
[17:39:27.508]                       invokeRestart <- base::invokeRestart
[17:39:27.508]                       is.null <- base::is.null
[17:39:27.508]                       muffled <- FALSE
[17:39:27.508]                       if (inherits(cond, "message")) {
[17:39:27.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.508]                         if (muffled) 
[17:39:27.508]                           invokeRestart("muffleMessage")
[17:39:27.508]                       }
[17:39:27.508]                       else if (inherits(cond, "warning")) {
[17:39:27.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.508]                         if (muffled) 
[17:39:27.508]                           invokeRestart("muffleWarning")
[17:39:27.508]                       }
[17:39:27.508]                       else if (inherits(cond, "condition")) {
[17:39:27.508]                         if (!is.null(pattern)) {
[17:39:27.508]                           computeRestarts <- base::computeRestarts
[17:39:27.508]                           grepl <- base::grepl
[17:39:27.508]                           restarts <- computeRestarts(cond)
[17:39:27.508]                           for (restart in restarts) {
[17:39:27.508]                             name <- restart$name
[17:39:27.508]                             if (is.null(name)) 
[17:39:27.508]                               next
[17:39:27.508]                             if (!grepl(pattern, name)) 
[17:39:27.508]                               next
[17:39:27.508]                             invokeRestart(restart)
[17:39:27.508]                             muffled <- TRUE
[17:39:27.508]                             break
[17:39:27.508]                           }
[17:39:27.508]                         }
[17:39:27.508]                       }
[17:39:27.508]                       invisible(muffled)
[17:39:27.508]                     }
[17:39:27.508]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.508]                   }
[17:39:27.508]                 }
[17:39:27.508]             }
[17:39:27.508]         }))
[17:39:27.508]     }, error = function(ex) {
[17:39:27.508]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:27.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.508]                 ...future.rng), started = ...future.startTime, 
[17:39:27.508]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:27.508]             version = "1.8"), class = "FutureResult")
[17:39:27.508]     }, finally = {
[17:39:27.508]         if (!identical(...future.workdir, getwd())) 
[17:39:27.508]             setwd(...future.workdir)
[17:39:27.508]         {
[17:39:27.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:27.508]                 ...future.oldOptions$nwarnings <- NULL
[17:39:27.508]             }
[17:39:27.508]             base::options(...future.oldOptions)
[17:39:27.508]             if (.Platform$OS.type == "windows") {
[17:39:27.508]                 old_names <- names(...future.oldEnvVars)
[17:39:27.508]                 envs <- base::Sys.getenv()
[17:39:27.508]                 names <- names(envs)
[17:39:27.508]                 common <- intersect(names, old_names)
[17:39:27.508]                 added <- setdiff(names, old_names)
[17:39:27.508]                 removed <- setdiff(old_names, names)
[17:39:27.508]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:27.508]                   envs[common]]
[17:39:27.508]                 NAMES <- toupper(changed)
[17:39:27.508]                 args <- list()
[17:39:27.508]                 for (kk in seq_along(NAMES)) {
[17:39:27.508]                   name <- changed[[kk]]
[17:39:27.508]                   NAME <- NAMES[[kk]]
[17:39:27.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.508]                     next
[17:39:27.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.508]                 }
[17:39:27.508]                 NAMES <- toupper(added)
[17:39:27.508]                 for (kk in seq_along(NAMES)) {
[17:39:27.508]                   name <- added[[kk]]
[17:39:27.508]                   NAME <- NAMES[[kk]]
[17:39:27.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.508]                     next
[17:39:27.508]                   args[[name]] <- ""
[17:39:27.508]                 }
[17:39:27.508]                 NAMES <- toupper(removed)
[17:39:27.508]                 for (kk in seq_along(NAMES)) {
[17:39:27.508]                   name <- removed[[kk]]
[17:39:27.508]                   NAME <- NAMES[[kk]]
[17:39:27.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.508]                     next
[17:39:27.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.508]                 }
[17:39:27.508]                 if (length(args) > 0) 
[17:39:27.508]                   base::do.call(base::Sys.setenv, args = args)
[17:39:27.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:27.508]             }
[17:39:27.508]             else {
[17:39:27.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:27.508]             }
[17:39:27.508]             {
[17:39:27.508]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:27.508]                   0L) {
[17:39:27.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:27.508]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:27.508]                   base::options(opts)
[17:39:27.508]                 }
[17:39:27.508]                 {
[17:39:27.508]                   {
[17:39:27.508]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:27.508]                     NULL
[17:39:27.508]                   }
[17:39:27.508]                   options(future.plan = NULL)
[17:39:27.508]                   if (is.na(NA_character_)) 
[17:39:27.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:27.508]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:27.508]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:27.508]                     envir = parent.frame()) 
[17:39:27.508]                   {
[17:39:27.508]                     if (is.function(workers)) 
[17:39:27.508]                       workers <- workers()
[17:39:27.508]                     workers <- structure(as.integer(workers), 
[17:39:27.508]                       class = class(workers))
[17:39:27.508]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:27.508]                       workers >= 1)
[17:39:27.508]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:27.508]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:27.508]                     }
[17:39:27.508]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:27.508]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:27.508]                       envir = envir)
[17:39:27.508]                     if (!future$lazy) 
[17:39:27.508]                       future <- run(future)
[17:39:27.508]                     invisible(future)
[17:39:27.508]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:27.508]                 }
[17:39:27.508]             }
[17:39:27.508]         }
[17:39:27.508]     })
[17:39:27.508]     if (TRUE) {
[17:39:27.508]         base::sink(type = "output", split = FALSE)
[17:39:27.508]         if (TRUE) {
[17:39:27.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:27.508]         }
[17:39:27.508]         else {
[17:39:27.508]             ...future.result["stdout"] <- base::list(NULL)
[17:39:27.508]         }
[17:39:27.508]         base::close(...future.stdout)
[17:39:27.508]         ...future.stdout <- NULL
[17:39:27.508]     }
[17:39:27.508]     ...future.result$conditions <- ...future.conditions
[17:39:27.508]     ...future.result$finished <- base::Sys.time()
[17:39:27.508]     ...future.result
[17:39:27.508] }
[17:39:27.579] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:39:27.579] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:39:27.579] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:39:27.580] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:27.580] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:27.580] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[17:39:27.581] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[17:39:27.581] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:27.581] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:27.581] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:27.582] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:27.582] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:39:27.582] MultisessionFuture started
[17:39:27.582] - Launch lazy future ... done
[17:39:27.583] run() for ‘MultisessionFuture’ ... done
[17:39:27.583] Created future:
[17:39:27.583] MultisessionFuture:
[17:39:27.583] Label: ‘future_by-2’
[17:39:27.583] Expression:
[17:39:27.583] {
[17:39:27.583]     do.call(function(...) {
[17:39:27.583]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.583]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.583]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.583]             on.exit(options(oopts), add = TRUE)
[17:39:27.583]         }
[17:39:27.583]         {
[17:39:27.583]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.583]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.583]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.583]             })
[17:39:27.583]         }
[17:39:27.583]     }, args = future.call.arguments)
[17:39:27.583] }
[17:39:27.583] Lazy evaluation: FALSE
[17:39:27.583] Asynchronous evaluation: TRUE
[17:39:27.583] Local evaluation: TRUE
[17:39:27.583] Environment: R_GlobalEnv
[17:39:27.583] Capture standard output: TRUE
[17:39:27.583] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:27.583] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:27.583] Packages: <none>
[17:39:27.583] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:27.583] Resolved: FALSE
[17:39:27.583] Value: <not collected>
[17:39:27.583] Conditions captured: <none>
[17:39:27.583] Early signaling: FALSE
[17:39:27.583] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:27.583] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.594] Chunk #2 of 2 ... DONE
[17:39:27.595] Launching 2 futures (chunks) ... DONE
[17:39:27.595] Resolving 2 futures (chunks) ...
[17:39:27.595] resolve() on list ...
[17:39:27.595]  recursive: 0
[17:39:27.595]  length: 2
[17:39:27.595] 
[17:39:27.596] receiveMessageFromWorker() for ClusterFuture ...
[17:39:27.596] - Validating connection of MultisessionFuture
[17:39:27.596] - received message: FutureResult
[17:39:27.596] - Received FutureResult
[17:39:27.596] - Erased future from FutureRegistry
[17:39:27.596] result() for ClusterFuture ...
[17:39:27.596] - result already collected: FutureResult
[17:39:27.596] result() for ClusterFuture ... done
[17:39:27.597] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:27.597] Future #1
[17:39:27.597] result() for ClusterFuture ...
[17:39:27.597] - result already collected: FutureResult
[17:39:27.597] result() for ClusterFuture ... done
[17:39:27.597] result() for ClusterFuture ...
[17:39:27.597] - result already collected: FutureResult
[17:39:27.597] result() for ClusterFuture ... done
[17:39:27.597] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:27.597] - nx: 2
[17:39:27.598] - relay: TRUE
[17:39:27.598] - stdout: TRUE
[17:39:27.598] - signal: TRUE
[17:39:27.598] - resignal: FALSE
[17:39:27.598] - force: TRUE
[17:39:27.598] - relayed: [n=2] FALSE, FALSE
[17:39:27.598] - queued futures: [n=2] FALSE, FALSE
[17:39:27.598]  - until=1
[17:39:27.600]  - relaying element #1
[17:39:27.601] result() for ClusterFuture ...
[17:39:27.601] - result already collected: FutureResult
[17:39:27.601] result() for ClusterFuture ... done
[17:39:27.601] result() for ClusterFuture ...
[17:39:27.601] - result already collected: FutureResult
[17:39:27.601] result() for ClusterFuture ... done
[17:39:27.601] result() for ClusterFuture ...
[17:39:27.601] - result already collected: FutureResult
[17:39:27.601] result() for ClusterFuture ... done
[17:39:27.601] result() for ClusterFuture ...
[17:39:27.601] - result already collected: FutureResult
[17:39:27.601] result() for ClusterFuture ... done
[17:39:27.602] - relayed: [n=2] TRUE, FALSE
[17:39:27.602] - queued futures: [n=2] TRUE, FALSE
[17:39:27.602] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:27.602]  length: 1 (resolved future 1)
[17:39:27.664] receiveMessageFromWorker() for ClusterFuture ...
[17:39:27.664] - Validating connection of MultisessionFuture
[17:39:27.665] - received message: FutureResult
[17:39:27.665] - Received FutureResult
[17:39:27.665] - Erased future from FutureRegistry
[17:39:27.665] result() for ClusterFuture ...
[17:39:27.665] - result already collected: FutureResult
[17:39:27.665] result() for ClusterFuture ... done
[17:39:27.665] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:27.665] Future #2
[17:39:27.665] result() for ClusterFuture ...
[17:39:27.666] - result already collected: FutureResult
[17:39:27.666] result() for ClusterFuture ... done
[17:39:27.666] result() for ClusterFuture ...
[17:39:27.666] - result already collected: FutureResult
[17:39:27.666] result() for ClusterFuture ... done
[17:39:27.666] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:27.666] - nx: 2
[17:39:27.666] - relay: TRUE
[17:39:27.666] - stdout: TRUE
[17:39:27.666] - signal: TRUE
[17:39:27.666] - resignal: FALSE
[17:39:27.666] - force: TRUE
[17:39:27.667] - relayed: [n=2] TRUE, FALSE
[17:39:27.667] - queued futures: [n=2] TRUE, FALSE
[17:39:27.667]  - until=2
[17:39:27.667]  - relaying element #2
[17:39:27.667] result() for ClusterFuture ...
[17:39:27.667] - result already collected: FutureResult
[17:39:27.667] result() for ClusterFuture ... done
[17:39:27.667] result() for ClusterFuture ...
[17:39:27.667] - result already collected: FutureResult
[17:39:27.667] result() for ClusterFuture ... done
[17:39:27.668] result() for ClusterFuture ...
[17:39:27.668] - result already collected: FutureResult
[17:39:27.668] result() for ClusterFuture ... done
[17:39:27.668] result() for ClusterFuture ...
[17:39:27.668] - result already collected: FutureResult
[17:39:27.668] result() for ClusterFuture ... done
[17:39:27.668] - relayed: [n=2] TRUE, TRUE
[17:39:27.668] - queued futures: [n=2] TRUE, TRUE
[17:39:27.668] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:27.668]  length: 0 (resolved future 2)
[17:39:27.668] Relaying remaining futures
[17:39:27.669] signalConditionsASAP(NULL, pos=0) ...
[17:39:27.669] - nx: 2
[17:39:27.669] - relay: TRUE
[17:39:27.669] - stdout: TRUE
[17:39:27.669] - signal: TRUE
[17:39:27.669] - resignal: FALSE
[17:39:27.669] - force: TRUE
[17:39:27.669] - relayed: [n=2] TRUE, TRUE
[17:39:27.669] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:27.669] - relayed: [n=2] TRUE, TRUE
[17:39:27.669] - queued futures: [n=2] TRUE, TRUE
[17:39:27.670] signalConditionsASAP(NULL, pos=0) ... done
[17:39:27.670] resolve() on list ... DONE
[17:39:27.670] result() for ClusterFuture ...
[17:39:27.670] - result already collected: FutureResult
[17:39:27.670] result() for ClusterFuture ... done
[17:39:27.670] result() for ClusterFuture ...
[17:39:27.670] - result already collected: FutureResult
[17:39:27.670] result() for ClusterFuture ... done
[17:39:27.670] result() for ClusterFuture ...
[17:39:27.670] - result already collected: FutureResult
[17:39:27.670] result() for ClusterFuture ... done
[17:39:27.670] result() for ClusterFuture ...
[17:39:27.671] - result already collected: FutureResult
[17:39:27.671] result() for ClusterFuture ... done
[17:39:27.671]  - Number of value chunks collected: 2
[17:39:27.671] Resolving 2 futures (chunks) ... DONE
[17:39:27.671] Reducing values from 2 chunks ...
[17:39:27.671]  - Number of values collected after concatenation: 3
[17:39:27.671]  - Number of values expected: 3
[17:39:27.671] Reducing values from 2 chunks ... DONE
[17:39:27.671] future_lapply() ... DONE
[17:39:27.671] future_by_internal() ... DONE
[17:39:27.672] future_by_internal() ...
[17:39:27.672] future_lapply() ...
[17:39:27.676] Number of chunks: 2
[17:39:27.676] getGlobalsAndPackagesXApply() ...
[17:39:27.676]  - future.globals: TRUE
[17:39:27.676] getGlobalsAndPackages() ...
[17:39:27.676] Searching for globals...
[17:39:27.677] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:27.678] Searching for globals ... DONE
[17:39:27.678] Resolving globals: FALSE
[17:39:27.678] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:27.678] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:27.678] - globals: [1] ‘FUN’
[17:39:27.679] 
[17:39:27.679] getGlobalsAndPackages() ... DONE
[17:39:27.679]  - globals found/used: [n=1] ‘FUN’
[17:39:27.679]  - needed namespaces: [n=0] 
[17:39:27.679] Finding globals ... DONE
[17:39:27.679]  - use_args: TRUE
[17:39:27.679]  - Getting '...' globals ...
[17:39:27.679] resolve() on list ...
[17:39:27.680]  recursive: 0
[17:39:27.680]  length: 1
[17:39:27.680]  elements: ‘...’
[17:39:27.680]  length: 0 (resolved future 1)
[17:39:27.680] resolve() on list ... DONE
[17:39:27.680]    - '...' content: [n=1] ‘digits’
[17:39:27.680] List of 1
[17:39:27.680]  $ ...:List of 1
[17:39:27.680]   ..$ digits: int 2
[17:39:27.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:27.680]  - attr(*, "where")=List of 1
[17:39:27.680]   ..$ ...:<environment: 0x562972add2a0> 
[17:39:27.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:27.680]  - attr(*, "resolved")= logi TRUE
[17:39:27.680]  - attr(*, "total_size")= num NA
[17:39:27.683]  - Getting '...' globals ... DONE
[17:39:27.683] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:27.683] List of 2
[17:39:27.683]  $ ...future.FUN:function (object, ...)  
[17:39:27.683]  $ ...          :List of 1
[17:39:27.683]   ..$ digits: int 2
[17:39:27.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:27.683]  - attr(*, "where")=List of 2
[17:39:27.683]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:27.683]   ..$ ...          :<environment: 0x562972add2a0> 
[17:39:27.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:27.683]  - attr(*, "resolved")= logi FALSE
[17:39:27.683]  - attr(*, "total_size")= num 1296
[17:39:27.686] Packages to be attached in all futures: [n=0] 
[17:39:27.686] getGlobalsAndPackagesXApply() ... DONE
[17:39:27.686] Number of futures (= number of chunks): 2
[17:39:27.687] Launching 2 futures (chunks) ...
[17:39:27.687] Chunk #1 of 2 ...
[17:39:27.687]  - Finding globals in 'X' for chunk #1 ...
[17:39:27.687] getGlobalsAndPackages() ...
[17:39:27.687] Searching for globals...
[17:39:27.687] 
[17:39:27.687] Searching for globals ... DONE
[17:39:27.687] - globals: [0] <none>
[17:39:27.688] getGlobalsAndPackages() ... DONE
[17:39:27.688]    + additional globals found: [n=0] 
[17:39:27.688]    + additional namespaces needed: [n=0] 
[17:39:27.688]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:27.688]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:27.688]  - seeds: <none>
[17:39:27.688] getGlobalsAndPackages() ...
[17:39:27.688] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.688] Resolving globals: FALSE
[17:39:27.688] Tweak future expression to call with '...' arguments ...
[17:39:27.689] {
[17:39:27.689]     do.call(function(...) {
[17:39:27.689]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.689]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.689]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.689]             on.exit(options(oopts), add = TRUE)
[17:39:27.689]         }
[17:39:27.689]         {
[17:39:27.689]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.689]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.689]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.689]             })
[17:39:27.689]         }
[17:39:27.689]     }, args = future.call.arguments)
[17:39:27.689] }
[17:39:27.689] Tweak future expression to call with '...' arguments ... DONE
[17:39:27.689] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.689] 
[17:39:27.689] getGlobalsAndPackages() ... DONE
[17:39:27.690] run() for ‘Future’ ...
[17:39:27.690] - state: ‘created’
[17:39:27.690] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:27.705] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:27.705]   - Field: ‘node’
[17:39:27.705]   - Field: ‘label’
[17:39:27.705]   - Field: ‘local’
[17:39:27.705]   - Field: ‘owner’
[17:39:27.705]   - Field: ‘envir’
[17:39:27.705]   - Field: ‘workers’
[17:39:27.706]   - Field: ‘packages’
[17:39:27.706]   - Field: ‘gc’
[17:39:27.706]   - Field: ‘conditions’
[17:39:27.706]   - Field: ‘persistent’
[17:39:27.706]   - Field: ‘expr’
[17:39:27.706]   - Field: ‘uuid’
[17:39:27.706]   - Field: ‘seed’
[17:39:27.706]   - Field: ‘version’
[17:39:27.706]   - Field: ‘result’
[17:39:27.706]   - Field: ‘asynchronous’
[17:39:27.706]   - Field: ‘calls’
[17:39:27.707]   - Field: ‘globals’
[17:39:27.707]   - Field: ‘stdout’
[17:39:27.707]   - Field: ‘earlySignal’
[17:39:27.707]   - Field: ‘lazy’
[17:39:27.707]   - Field: ‘state’
[17:39:27.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:27.707] - Launch lazy future ...
[17:39:27.707] Packages needed by the future expression (n = 0): <none>
[17:39:27.708] Packages needed by future strategies (n = 0): <none>
[17:39:27.708] {
[17:39:27.708]     {
[17:39:27.708]         {
[17:39:27.708]             ...future.startTime <- base::Sys.time()
[17:39:27.708]             {
[17:39:27.708]                 {
[17:39:27.708]                   {
[17:39:27.708]                     {
[17:39:27.708]                       base::local({
[17:39:27.708]                         has_future <- base::requireNamespace("future", 
[17:39:27.708]                           quietly = TRUE)
[17:39:27.708]                         if (has_future) {
[17:39:27.708]                           ns <- base::getNamespace("future")
[17:39:27.708]                           version <- ns[[".package"]][["version"]]
[17:39:27.708]                           if (is.null(version)) 
[17:39:27.708]                             version <- utils::packageVersion("future")
[17:39:27.708]                         }
[17:39:27.708]                         else {
[17:39:27.708]                           version <- NULL
[17:39:27.708]                         }
[17:39:27.708]                         if (!has_future || version < "1.8.0") {
[17:39:27.708]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:27.708]                             "", base::R.version$version.string), 
[17:39:27.708]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:27.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:27.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:27.708]                               "release", "version")], collapse = " "), 
[17:39:27.708]                             hostname = base::Sys.info()[["nodename"]])
[17:39:27.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:27.708]                             info)
[17:39:27.708]                           info <- base::paste(info, collapse = "; ")
[17:39:27.708]                           if (!has_future) {
[17:39:27.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:27.708]                               info)
[17:39:27.708]                           }
[17:39:27.708]                           else {
[17:39:27.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:27.708]                               info, version)
[17:39:27.708]                           }
[17:39:27.708]                           base::stop(msg)
[17:39:27.708]                         }
[17:39:27.708]                       })
[17:39:27.708]                     }
[17:39:27.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:27.708]                     base::options(mc.cores = 1L)
[17:39:27.708]                   }
[17:39:27.708]                   options(future.plan = NULL)
[17:39:27.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:27.708]                 }
[17:39:27.708]                 ...future.workdir <- getwd()
[17:39:27.708]             }
[17:39:27.708]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:27.708]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:27.708]         }
[17:39:27.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:27.708]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:27.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:27.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:27.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:27.708]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:27.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:27.708]             base::names(...future.oldOptions))
[17:39:27.708]     }
[17:39:27.708]     if (FALSE) {
[17:39:27.708]     }
[17:39:27.708]     else {
[17:39:27.708]         if (TRUE) {
[17:39:27.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:27.708]                 open = "w")
[17:39:27.708]         }
[17:39:27.708]         else {
[17:39:27.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:27.708]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:27.708]         }
[17:39:27.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:27.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:27.708]             base::sink(type = "output", split = FALSE)
[17:39:27.708]             base::close(...future.stdout)
[17:39:27.708]         }, add = TRUE)
[17:39:27.708]     }
[17:39:27.708]     ...future.frame <- base::sys.nframe()
[17:39:27.708]     ...future.conditions <- base::list()
[17:39:27.708]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:27.708]     if (FALSE) {
[17:39:27.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:27.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:27.708]     }
[17:39:27.708]     ...future.result <- base::tryCatch({
[17:39:27.708]         base::withCallingHandlers({
[17:39:27.708]             ...future.value <- base::withVisible(base::local({
[17:39:27.708]                 ...future.makeSendCondition <- local({
[17:39:27.708]                   sendCondition <- NULL
[17:39:27.708]                   function(frame = 1L) {
[17:39:27.708]                     if (is.function(sendCondition)) 
[17:39:27.708]                       return(sendCondition)
[17:39:27.708]                     ns <- getNamespace("parallel")
[17:39:27.708]                     if (exists("sendData", mode = "function", 
[17:39:27.708]                       envir = ns)) {
[17:39:27.708]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:27.708]                         envir = ns)
[17:39:27.708]                       envir <- sys.frame(frame)
[17:39:27.708]                       master <- NULL
[17:39:27.708]                       while (!identical(envir, .GlobalEnv) && 
[17:39:27.708]                         !identical(envir, emptyenv())) {
[17:39:27.708]                         if (exists("master", mode = "list", envir = envir, 
[17:39:27.708]                           inherits = FALSE)) {
[17:39:27.708]                           master <- get("master", mode = "list", 
[17:39:27.708]                             envir = envir, inherits = FALSE)
[17:39:27.708]                           if (inherits(master, c("SOCKnode", 
[17:39:27.708]                             "SOCK0node"))) {
[17:39:27.708]                             sendCondition <<- function(cond) {
[17:39:27.708]                               data <- list(type = "VALUE", value = cond, 
[17:39:27.708]                                 success = TRUE)
[17:39:27.708]                               parallel_sendData(master, data)
[17:39:27.708]                             }
[17:39:27.708]                             return(sendCondition)
[17:39:27.708]                           }
[17:39:27.708]                         }
[17:39:27.708]                         frame <- frame + 1L
[17:39:27.708]                         envir <- sys.frame(frame)
[17:39:27.708]                       }
[17:39:27.708]                     }
[17:39:27.708]                     sendCondition <<- function(cond) NULL
[17:39:27.708]                   }
[17:39:27.708]                 })
[17:39:27.708]                 withCallingHandlers({
[17:39:27.708]                   {
[17:39:27.708]                     do.call(function(...) {
[17:39:27.708]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.708]                       if (!identical(...future.globals.maxSize.org, 
[17:39:27.708]                         ...future.globals.maxSize)) {
[17:39:27.708]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.708]                         on.exit(options(oopts), add = TRUE)
[17:39:27.708]                       }
[17:39:27.708]                       {
[17:39:27.708]                         lapply(seq_along(...future.elements_ii), 
[17:39:27.708]                           FUN = function(jj) {
[17:39:27.708]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.708]                             ...future.FUN(...future.X_jj, ...)
[17:39:27.708]                           })
[17:39:27.708]                       }
[17:39:27.708]                     }, args = future.call.arguments)
[17:39:27.708]                   }
[17:39:27.708]                 }, immediateCondition = function(cond) {
[17:39:27.708]                   sendCondition <- ...future.makeSendCondition()
[17:39:27.708]                   sendCondition(cond)
[17:39:27.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.708]                   {
[17:39:27.708]                     inherits <- base::inherits
[17:39:27.708]                     invokeRestart <- base::invokeRestart
[17:39:27.708]                     is.null <- base::is.null
[17:39:27.708]                     muffled <- FALSE
[17:39:27.708]                     if (inherits(cond, "message")) {
[17:39:27.708]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:27.708]                       if (muffled) 
[17:39:27.708]                         invokeRestart("muffleMessage")
[17:39:27.708]                     }
[17:39:27.708]                     else if (inherits(cond, "warning")) {
[17:39:27.708]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:27.708]                       if (muffled) 
[17:39:27.708]                         invokeRestart("muffleWarning")
[17:39:27.708]                     }
[17:39:27.708]                     else if (inherits(cond, "condition")) {
[17:39:27.708]                       if (!is.null(pattern)) {
[17:39:27.708]                         computeRestarts <- base::computeRestarts
[17:39:27.708]                         grepl <- base::grepl
[17:39:27.708]                         restarts <- computeRestarts(cond)
[17:39:27.708]                         for (restart in restarts) {
[17:39:27.708]                           name <- restart$name
[17:39:27.708]                           if (is.null(name)) 
[17:39:27.708]                             next
[17:39:27.708]                           if (!grepl(pattern, name)) 
[17:39:27.708]                             next
[17:39:27.708]                           invokeRestart(restart)
[17:39:27.708]                           muffled <- TRUE
[17:39:27.708]                           break
[17:39:27.708]                         }
[17:39:27.708]                       }
[17:39:27.708]                     }
[17:39:27.708]                     invisible(muffled)
[17:39:27.708]                   }
[17:39:27.708]                   muffleCondition(cond)
[17:39:27.708]                 })
[17:39:27.708]             }))
[17:39:27.708]             future::FutureResult(value = ...future.value$value, 
[17:39:27.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.708]                   ...future.rng), globalenv = if (FALSE) 
[17:39:27.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:27.708]                     ...future.globalenv.names))
[17:39:27.708]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:27.708]         }, condition = base::local({
[17:39:27.708]             c <- base::c
[17:39:27.708]             inherits <- base::inherits
[17:39:27.708]             invokeRestart <- base::invokeRestart
[17:39:27.708]             length <- base::length
[17:39:27.708]             list <- base::list
[17:39:27.708]             seq.int <- base::seq.int
[17:39:27.708]             signalCondition <- base::signalCondition
[17:39:27.708]             sys.calls <- base::sys.calls
[17:39:27.708]             `[[` <- base::`[[`
[17:39:27.708]             `+` <- base::`+`
[17:39:27.708]             `<<-` <- base::`<<-`
[17:39:27.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:27.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:27.708]                   3L)]
[17:39:27.708]             }
[17:39:27.708]             function(cond) {
[17:39:27.708]                 is_error <- inherits(cond, "error")
[17:39:27.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:27.708]                   NULL)
[17:39:27.708]                 if (is_error) {
[17:39:27.708]                   sessionInformation <- function() {
[17:39:27.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:27.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:27.708]                       search = base::search(), system = base::Sys.info())
[17:39:27.708]                   }
[17:39:27.708]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:27.708]                     cond$call), session = sessionInformation(), 
[17:39:27.708]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:27.708]                   signalCondition(cond)
[17:39:27.708]                 }
[17:39:27.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:27.708]                 "immediateCondition"))) {
[17:39:27.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:27.708]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:27.708]                   if (TRUE && !signal) {
[17:39:27.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.708]                     {
[17:39:27.708]                       inherits <- base::inherits
[17:39:27.708]                       invokeRestart <- base::invokeRestart
[17:39:27.708]                       is.null <- base::is.null
[17:39:27.708]                       muffled <- FALSE
[17:39:27.708]                       if (inherits(cond, "message")) {
[17:39:27.708]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.708]                         if (muffled) 
[17:39:27.708]                           invokeRestart("muffleMessage")
[17:39:27.708]                       }
[17:39:27.708]                       else if (inherits(cond, "warning")) {
[17:39:27.708]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.708]                         if (muffled) 
[17:39:27.708]                           invokeRestart("muffleWarning")
[17:39:27.708]                       }
[17:39:27.708]                       else if (inherits(cond, "condition")) {
[17:39:27.708]                         if (!is.null(pattern)) {
[17:39:27.708]                           computeRestarts <- base::computeRestarts
[17:39:27.708]                           grepl <- base::grepl
[17:39:27.708]                           restarts <- computeRestarts(cond)
[17:39:27.708]                           for (restart in restarts) {
[17:39:27.708]                             name <- restart$name
[17:39:27.708]                             if (is.null(name)) 
[17:39:27.708]                               next
[17:39:27.708]                             if (!grepl(pattern, name)) 
[17:39:27.708]                               next
[17:39:27.708]                             invokeRestart(restart)
[17:39:27.708]                             muffled <- TRUE
[17:39:27.708]                             break
[17:39:27.708]                           }
[17:39:27.708]                         }
[17:39:27.708]                       }
[17:39:27.708]                       invisible(muffled)
[17:39:27.708]                     }
[17:39:27.708]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.708]                   }
[17:39:27.708]                 }
[17:39:27.708]                 else {
[17:39:27.708]                   if (TRUE) {
[17:39:27.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.708]                     {
[17:39:27.708]                       inherits <- base::inherits
[17:39:27.708]                       invokeRestart <- base::invokeRestart
[17:39:27.708]                       is.null <- base::is.null
[17:39:27.708]                       muffled <- FALSE
[17:39:27.708]                       if (inherits(cond, "message")) {
[17:39:27.708]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.708]                         if (muffled) 
[17:39:27.708]                           invokeRestart("muffleMessage")
[17:39:27.708]                       }
[17:39:27.708]                       else if (inherits(cond, "warning")) {
[17:39:27.708]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.708]                         if (muffled) 
[17:39:27.708]                           invokeRestart("muffleWarning")
[17:39:27.708]                       }
[17:39:27.708]                       else if (inherits(cond, "condition")) {
[17:39:27.708]                         if (!is.null(pattern)) {
[17:39:27.708]                           computeRestarts <- base::computeRestarts
[17:39:27.708]                           grepl <- base::grepl
[17:39:27.708]                           restarts <- computeRestarts(cond)
[17:39:27.708]                           for (restart in restarts) {
[17:39:27.708]                             name <- restart$name
[17:39:27.708]                             if (is.null(name)) 
[17:39:27.708]                               next
[17:39:27.708]                             if (!grepl(pattern, name)) 
[17:39:27.708]                               next
[17:39:27.708]                             invokeRestart(restart)
[17:39:27.708]                             muffled <- TRUE
[17:39:27.708]                             break
[17:39:27.708]                           }
[17:39:27.708]                         }
[17:39:27.708]                       }
[17:39:27.708]                       invisible(muffled)
[17:39:27.708]                     }
[17:39:27.708]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.708]                   }
[17:39:27.708]                 }
[17:39:27.708]             }
[17:39:27.708]         }))
[17:39:27.708]     }, error = function(ex) {
[17:39:27.708]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:27.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.708]                 ...future.rng), started = ...future.startTime, 
[17:39:27.708]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:27.708]             version = "1.8"), class = "FutureResult")
[17:39:27.708]     }, finally = {
[17:39:27.708]         if (!identical(...future.workdir, getwd())) 
[17:39:27.708]             setwd(...future.workdir)
[17:39:27.708]         {
[17:39:27.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:27.708]                 ...future.oldOptions$nwarnings <- NULL
[17:39:27.708]             }
[17:39:27.708]             base::options(...future.oldOptions)
[17:39:27.708]             if (.Platform$OS.type == "windows") {
[17:39:27.708]                 old_names <- names(...future.oldEnvVars)
[17:39:27.708]                 envs <- base::Sys.getenv()
[17:39:27.708]                 names <- names(envs)
[17:39:27.708]                 common <- intersect(names, old_names)
[17:39:27.708]                 added <- setdiff(names, old_names)
[17:39:27.708]                 removed <- setdiff(old_names, names)
[17:39:27.708]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:27.708]                   envs[common]]
[17:39:27.708]                 NAMES <- toupper(changed)
[17:39:27.708]                 args <- list()
[17:39:27.708]                 for (kk in seq_along(NAMES)) {
[17:39:27.708]                   name <- changed[[kk]]
[17:39:27.708]                   NAME <- NAMES[[kk]]
[17:39:27.708]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.708]                     next
[17:39:27.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.708]                 }
[17:39:27.708]                 NAMES <- toupper(added)
[17:39:27.708]                 for (kk in seq_along(NAMES)) {
[17:39:27.708]                   name <- added[[kk]]
[17:39:27.708]                   NAME <- NAMES[[kk]]
[17:39:27.708]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.708]                     next
[17:39:27.708]                   args[[name]] <- ""
[17:39:27.708]                 }
[17:39:27.708]                 NAMES <- toupper(removed)
[17:39:27.708]                 for (kk in seq_along(NAMES)) {
[17:39:27.708]                   name <- removed[[kk]]
[17:39:27.708]                   NAME <- NAMES[[kk]]
[17:39:27.708]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.708]                     next
[17:39:27.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.708]                 }
[17:39:27.708]                 if (length(args) > 0) 
[17:39:27.708]                   base::do.call(base::Sys.setenv, args = args)
[17:39:27.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:27.708]             }
[17:39:27.708]             else {
[17:39:27.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:27.708]             }
[17:39:27.708]             {
[17:39:27.708]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:27.708]                   0L) {
[17:39:27.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:27.708]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:27.708]                   base::options(opts)
[17:39:27.708]                 }
[17:39:27.708]                 {
[17:39:27.708]                   {
[17:39:27.708]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:27.708]                     NULL
[17:39:27.708]                   }
[17:39:27.708]                   options(future.plan = NULL)
[17:39:27.708]                   if (is.na(NA_character_)) 
[17:39:27.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:27.708]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:27.708]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:27.708]                     envir = parent.frame()) 
[17:39:27.708]                   {
[17:39:27.708]                     if (is.function(workers)) 
[17:39:27.708]                       workers <- workers()
[17:39:27.708]                     workers <- structure(as.integer(workers), 
[17:39:27.708]                       class = class(workers))
[17:39:27.708]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:27.708]                       workers >= 1)
[17:39:27.708]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:27.708]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:27.708]                     }
[17:39:27.708]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:27.708]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:27.708]                       envir = envir)
[17:39:27.708]                     if (!future$lazy) 
[17:39:27.708]                       future <- run(future)
[17:39:27.708]                     invisible(future)
[17:39:27.708]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:27.708]                 }
[17:39:27.708]             }
[17:39:27.708]         }
[17:39:27.708]     })
[17:39:27.708]     if (TRUE) {
[17:39:27.708]         base::sink(type = "output", split = FALSE)
[17:39:27.708]         if (TRUE) {
[17:39:27.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:27.708]         }
[17:39:27.708]         else {
[17:39:27.708]             ...future.result["stdout"] <- base::list(NULL)
[17:39:27.708]         }
[17:39:27.708]         base::close(...future.stdout)
[17:39:27.708]         ...future.stdout <- NULL
[17:39:27.708]     }
[17:39:27.708]     ...future.result$conditions <- ...future.conditions
[17:39:27.708]     ...future.result$finished <- base::Sys.time()
[17:39:27.708]     ...future.result
[17:39:27.708] }
[17:39:27.711] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[17:39:27.711] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:39:27.711] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:39:27.712] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:39:27.712] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:39:27.712] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[17:39:27.713] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[17:39:27.713] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:27.713] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:27.713] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:27.714] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:27.714] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[17:39:27.714] MultisessionFuture started
[17:39:27.715] - Launch lazy future ... done
[17:39:27.715] run() for ‘MultisessionFuture’ ... done
[17:39:27.715] Created future:
[17:39:27.715] MultisessionFuture:
[17:39:27.715] Label: ‘future_by-1’
[17:39:27.715] Expression:
[17:39:27.715] {
[17:39:27.715]     do.call(function(...) {
[17:39:27.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.715]             on.exit(options(oopts), add = TRUE)
[17:39:27.715]         }
[17:39:27.715]         {
[17:39:27.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.715]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.715]             })
[17:39:27.715]         }
[17:39:27.715]     }, args = future.call.arguments)
[17:39:27.715] }
[17:39:27.715] Lazy evaluation: FALSE
[17:39:27.715] Asynchronous evaluation: TRUE
[17:39:27.715] Local evaluation: TRUE
[17:39:27.715] Environment: R_GlobalEnv
[17:39:27.715] Capture standard output: TRUE
[17:39:27.715] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:27.715] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:27.715] Packages: <none>
[17:39:27.715] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:27.715] Resolved: FALSE
[17:39:27.715] Value: <not collected>
[17:39:27.715] Conditions captured: <none>
[17:39:27.715] Early signaling: FALSE
[17:39:27.715] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:27.715] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.726] Chunk #1 of 2 ... DONE
[17:39:27.727] Chunk #2 of 2 ...
[17:39:27.727]  - Finding globals in 'X' for chunk #2 ...
[17:39:27.727] getGlobalsAndPackages() ...
[17:39:27.727] Searching for globals...
[17:39:27.727] 
[17:39:27.727] Searching for globals ... DONE
[17:39:27.727] - globals: [0] <none>
[17:39:27.728] getGlobalsAndPackages() ... DONE
[17:39:27.728]    + additional globals found: [n=0] 
[17:39:27.728]    + additional namespaces needed: [n=0] 
[17:39:27.728]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:27.728]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:39:27.728]  - seeds: <none>
[17:39:27.728] getGlobalsAndPackages() ...
[17:39:27.728] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.728] Resolving globals: FALSE
[17:39:27.728] Tweak future expression to call with '...' arguments ...
[17:39:27.729] {
[17:39:27.729]     do.call(function(...) {
[17:39:27.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.729]             on.exit(options(oopts), add = TRUE)
[17:39:27.729]         }
[17:39:27.729]         {
[17:39:27.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.729]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.729]             })
[17:39:27.729]         }
[17:39:27.729]     }, args = future.call.arguments)
[17:39:27.729] }
[17:39:27.729] Tweak future expression to call with '...' arguments ... DONE
[17:39:27.729] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.729] 
[17:39:27.729] getGlobalsAndPackages() ... DONE
[17:39:27.730] run() for ‘Future’ ...
[17:39:27.730] - state: ‘created’
[17:39:27.730] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:27.744] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:27.744]   - Field: ‘node’
[17:39:27.744]   - Field: ‘label’
[17:39:27.745]   - Field: ‘local’
[17:39:27.745]   - Field: ‘owner’
[17:39:27.745]   - Field: ‘envir’
[17:39:27.745]   - Field: ‘workers’
[17:39:27.745]   - Field: ‘packages’
[17:39:27.745]   - Field: ‘gc’
[17:39:27.745]   - Field: ‘conditions’
[17:39:27.745]   - Field: ‘persistent’
[17:39:27.745]   - Field: ‘expr’
[17:39:27.745]   - Field: ‘uuid’
[17:39:27.745]   - Field: ‘seed’
[17:39:27.746]   - Field: ‘version’
[17:39:27.746]   - Field: ‘result’
[17:39:27.746]   - Field: ‘asynchronous’
[17:39:27.746]   - Field: ‘calls’
[17:39:27.746]   - Field: ‘globals’
[17:39:27.746]   - Field: ‘stdout’
[17:39:27.746]   - Field: ‘earlySignal’
[17:39:27.746]   - Field: ‘lazy’
[17:39:27.746]   - Field: ‘state’
[17:39:27.746] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:27.746] - Launch lazy future ...
[17:39:27.747] Packages needed by the future expression (n = 0): <none>
[17:39:27.747] Packages needed by future strategies (n = 0): <none>
[17:39:27.747] {
[17:39:27.747]     {
[17:39:27.747]         {
[17:39:27.747]             ...future.startTime <- base::Sys.time()
[17:39:27.747]             {
[17:39:27.747]                 {
[17:39:27.747]                   {
[17:39:27.747]                     {
[17:39:27.747]                       base::local({
[17:39:27.747]                         has_future <- base::requireNamespace("future", 
[17:39:27.747]                           quietly = TRUE)
[17:39:27.747]                         if (has_future) {
[17:39:27.747]                           ns <- base::getNamespace("future")
[17:39:27.747]                           version <- ns[[".package"]][["version"]]
[17:39:27.747]                           if (is.null(version)) 
[17:39:27.747]                             version <- utils::packageVersion("future")
[17:39:27.747]                         }
[17:39:27.747]                         else {
[17:39:27.747]                           version <- NULL
[17:39:27.747]                         }
[17:39:27.747]                         if (!has_future || version < "1.8.0") {
[17:39:27.747]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:27.747]                             "", base::R.version$version.string), 
[17:39:27.747]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:27.747]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:27.747]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:27.747]                               "release", "version")], collapse = " "), 
[17:39:27.747]                             hostname = base::Sys.info()[["nodename"]])
[17:39:27.747]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:27.747]                             info)
[17:39:27.747]                           info <- base::paste(info, collapse = "; ")
[17:39:27.747]                           if (!has_future) {
[17:39:27.747]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:27.747]                               info)
[17:39:27.747]                           }
[17:39:27.747]                           else {
[17:39:27.747]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:27.747]                               info, version)
[17:39:27.747]                           }
[17:39:27.747]                           base::stop(msg)
[17:39:27.747]                         }
[17:39:27.747]                       })
[17:39:27.747]                     }
[17:39:27.747]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:27.747]                     base::options(mc.cores = 1L)
[17:39:27.747]                   }
[17:39:27.747]                   options(future.plan = NULL)
[17:39:27.747]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.747]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:27.747]                 }
[17:39:27.747]                 ...future.workdir <- getwd()
[17:39:27.747]             }
[17:39:27.747]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:27.747]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:27.747]         }
[17:39:27.747]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:27.747]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:39:27.747]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:27.747]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:27.747]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:27.747]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:27.747]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:27.747]             base::names(...future.oldOptions))
[17:39:27.747]     }
[17:39:27.747]     if (FALSE) {
[17:39:27.747]     }
[17:39:27.747]     else {
[17:39:27.747]         if (TRUE) {
[17:39:27.747]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:27.747]                 open = "w")
[17:39:27.747]         }
[17:39:27.747]         else {
[17:39:27.747]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:27.747]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:27.747]         }
[17:39:27.747]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:27.747]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:27.747]             base::sink(type = "output", split = FALSE)
[17:39:27.747]             base::close(...future.stdout)
[17:39:27.747]         }, add = TRUE)
[17:39:27.747]     }
[17:39:27.747]     ...future.frame <- base::sys.nframe()
[17:39:27.747]     ...future.conditions <- base::list()
[17:39:27.747]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:27.747]     if (FALSE) {
[17:39:27.747]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:27.747]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:27.747]     }
[17:39:27.747]     ...future.result <- base::tryCatch({
[17:39:27.747]         base::withCallingHandlers({
[17:39:27.747]             ...future.value <- base::withVisible(base::local({
[17:39:27.747]                 ...future.makeSendCondition <- local({
[17:39:27.747]                   sendCondition <- NULL
[17:39:27.747]                   function(frame = 1L) {
[17:39:27.747]                     if (is.function(sendCondition)) 
[17:39:27.747]                       return(sendCondition)
[17:39:27.747]                     ns <- getNamespace("parallel")
[17:39:27.747]                     if (exists("sendData", mode = "function", 
[17:39:27.747]                       envir = ns)) {
[17:39:27.747]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:27.747]                         envir = ns)
[17:39:27.747]                       envir <- sys.frame(frame)
[17:39:27.747]                       master <- NULL
[17:39:27.747]                       while (!identical(envir, .GlobalEnv) && 
[17:39:27.747]                         !identical(envir, emptyenv())) {
[17:39:27.747]                         if (exists("master", mode = "list", envir = envir, 
[17:39:27.747]                           inherits = FALSE)) {
[17:39:27.747]                           master <- get("master", mode = "list", 
[17:39:27.747]                             envir = envir, inherits = FALSE)
[17:39:27.747]                           if (inherits(master, c("SOCKnode", 
[17:39:27.747]                             "SOCK0node"))) {
[17:39:27.747]                             sendCondition <<- function(cond) {
[17:39:27.747]                               data <- list(type = "VALUE", value = cond, 
[17:39:27.747]                                 success = TRUE)
[17:39:27.747]                               parallel_sendData(master, data)
[17:39:27.747]                             }
[17:39:27.747]                             return(sendCondition)
[17:39:27.747]                           }
[17:39:27.747]                         }
[17:39:27.747]                         frame <- frame + 1L
[17:39:27.747]                         envir <- sys.frame(frame)
[17:39:27.747]                       }
[17:39:27.747]                     }
[17:39:27.747]                     sendCondition <<- function(cond) NULL
[17:39:27.747]                   }
[17:39:27.747]                 })
[17:39:27.747]                 withCallingHandlers({
[17:39:27.747]                   {
[17:39:27.747]                     do.call(function(...) {
[17:39:27.747]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.747]                       if (!identical(...future.globals.maxSize.org, 
[17:39:27.747]                         ...future.globals.maxSize)) {
[17:39:27.747]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.747]                         on.exit(options(oopts), add = TRUE)
[17:39:27.747]                       }
[17:39:27.747]                       {
[17:39:27.747]                         lapply(seq_along(...future.elements_ii), 
[17:39:27.747]                           FUN = function(jj) {
[17:39:27.747]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.747]                             ...future.FUN(...future.X_jj, ...)
[17:39:27.747]                           })
[17:39:27.747]                       }
[17:39:27.747]                     }, args = future.call.arguments)
[17:39:27.747]                   }
[17:39:27.747]                 }, immediateCondition = function(cond) {
[17:39:27.747]                   sendCondition <- ...future.makeSendCondition()
[17:39:27.747]                   sendCondition(cond)
[17:39:27.747]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.747]                   {
[17:39:27.747]                     inherits <- base::inherits
[17:39:27.747]                     invokeRestart <- base::invokeRestart
[17:39:27.747]                     is.null <- base::is.null
[17:39:27.747]                     muffled <- FALSE
[17:39:27.747]                     if (inherits(cond, "message")) {
[17:39:27.747]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:27.747]                       if (muffled) 
[17:39:27.747]                         invokeRestart("muffleMessage")
[17:39:27.747]                     }
[17:39:27.747]                     else if (inherits(cond, "warning")) {
[17:39:27.747]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:27.747]                       if (muffled) 
[17:39:27.747]                         invokeRestart("muffleWarning")
[17:39:27.747]                     }
[17:39:27.747]                     else if (inherits(cond, "condition")) {
[17:39:27.747]                       if (!is.null(pattern)) {
[17:39:27.747]                         computeRestarts <- base::computeRestarts
[17:39:27.747]                         grepl <- base::grepl
[17:39:27.747]                         restarts <- computeRestarts(cond)
[17:39:27.747]                         for (restart in restarts) {
[17:39:27.747]                           name <- restart$name
[17:39:27.747]                           if (is.null(name)) 
[17:39:27.747]                             next
[17:39:27.747]                           if (!grepl(pattern, name)) 
[17:39:27.747]                             next
[17:39:27.747]                           invokeRestart(restart)
[17:39:27.747]                           muffled <- TRUE
[17:39:27.747]                           break
[17:39:27.747]                         }
[17:39:27.747]                       }
[17:39:27.747]                     }
[17:39:27.747]                     invisible(muffled)
[17:39:27.747]                   }
[17:39:27.747]                   muffleCondition(cond)
[17:39:27.747]                 })
[17:39:27.747]             }))
[17:39:27.747]             future::FutureResult(value = ...future.value$value, 
[17:39:27.747]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.747]                   ...future.rng), globalenv = if (FALSE) 
[17:39:27.747]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:27.747]                     ...future.globalenv.names))
[17:39:27.747]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:27.747]         }, condition = base::local({
[17:39:27.747]             c <- base::c
[17:39:27.747]             inherits <- base::inherits
[17:39:27.747]             invokeRestart <- base::invokeRestart
[17:39:27.747]             length <- base::length
[17:39:27.747]             list <- base::list
[17:39:27.747]             seq.int <- base::seq.int
[17:39:27.747]             signalCondition <- base::signalCondition
[17:39:27.747]             sys.calls <- base::sys.calls
[17:39:27.747]             `[[` <- base::`[[`
[17:39:27.747]             `+` <- base::`+`
[17:39:27.747]             `<<-` <- base::`<<-`
[17:39:27.747]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:27.747]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:27.747]                   3L)]
[17:39:27.747]             }
[17:39:27.747]             function(cond) {
[17:39:27.747]                 is_error <- inherits(cond, "error")
[17:39:27.747]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:27.747]                   NULL)
[17:39:27.747]                 if (is_error) {
[17:39:27.747]                   sessionInformation <- function() {
[17:39:27.747]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:27.747]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:27.747]                       search = base::search(), system = base::Sys.info())
[17:39:27.747]                   }
[17:39:27.747]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.747]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:27.747]                     cond$call), session = sessionInformation(), 
[17:39:27.747]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:27.747]                   signalCondition(cond)
[17:39:27.747]                 }
[17:39:27.747]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:27.747]                 "immediateCondition"))) {
[17:39:27.747]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:27.747]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.747]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:27.747]                   if (TRUE && !signal) {
[17:39:27.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.747]                     {
[17:39:27.747]                       inherits <- base::inherits
[17:39:27.747]                       invokeRestart <- base::invokeRestart
[17:39:27.747]                       is.null <- base::is.null
[17:39:27.747]                       muffled <- FALSE
[17:39:27.747]                       if (inherits(cond, "message")) {
[17:39:27.747]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.747]                         if (muffled) 
[17:39:27.747]                           invokeRestart("muffleMessage")
[17:39:27.747]                       }
[17:39:27.747]                       else if (inherits(cond, "warning")) {
[17:39:27.747]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.747]                         if (muffled) 
[17:39:27.747]                           invokeRestart("muffleWarning")
[17:39:27.747]                       }
[17:39:27.747]                       else if (inherits(cond, "condition")) {
[17:39:27.747]                         if (!is.null(pattern)) {
[17:39:27.747]                           computeRestarts <- base::computeRestarts
[17:39:27.747]                           grepl <- base::grepl
[17:39:27.747]                           restarts <- computeRestarts(cond)
[17:39:27.747]                           for (restart in restarts) {
[17:39:27.747]                             name <- restart$name
[17:39:27.747]                             if (is.null(name)) 
[17:39:27.747]                               next
[17:39:27.747]                             if (!grepl(pattern, name)) 
[17:39:27.747]                               next
[17:39:27.747]                             invokeRestart(restart)
[17:39:27.747]                             muffled <- TRUE
[17:39:27.747]                             break
[17:39:27.747]                           }
[17:39:27.747]                         }
[17:39:27.747]                       }
[17:39:27.747]                       invisible(muffled)
[17:39:27.747]                     }
[17:39:27.747]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.747]                   }
[17:39:27.747]                 }
[17:39:27.747]                 else {
[17:39:27.747]                   if (TRUE) {
[17:39:27.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.747]                     {
[17:39:27.747]                       inherits <- base::inherits
[17:39:27.747]                       invokeRestart <- base::invokeRestart
[17:39:27.747]                       is.null <- base::is.null
[17:39:27.747]                       muffled <- FALSE
[17:39:27.747]                       if (inherits(cond, "message")) {
[17:39:27.747]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.747]                         if (muffled) 
[17:39:27.747]                           invokeRestart("muffleMessage")
[17:39:27.747]                       }
[17:39:27.747]                       else if (inherits(cond, "warning")) {
[17:39:27.747]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.747]                         if (muffled) 
[17:39:27.747]                           invokeRestart("muffleWarning")
[17:39:27.747]                       }
[17:39:27.747]                       else if (inherits(cond, "condition")) {
[17:39:27.747]                         if (!is.null(pattern)) {
[17:39:27.747]                           computeRestarts <- base::computeRestarts
[17:39:27.747]                           grepl <- base::grepl
[17:39:27.747]                           restarts <- computeRestarts(cond)
[17:39:27.747]                           for (restart in restarts) {
[17:39:27.747]                             name <- restart$name
[17:39:27.747]                             if (is.null(name)) 
[17:39:27.747]                               next
[17:39:27.747]                             if (!grepl(pattern, name)) 
[17:39:27.747]                               next
[17:39:27.747]                             invokeRestart(restart)
[17:39:27.747]                             muffled <- TRUE
[17:39:27.747]                             break
[17:39:27.747]                           }
[17:39:27.747]                         }
[17:39:27.747]                       }
[17:39:27.747]                       invisible(muffled)
[17:39:27.747]                     }
[17:39:27.747]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.747]                   }
[17:39:27.747]                 }
[17:39:27.747]             }
[17:39:27.747]         }))
[17:39:27.747]     }, error = function(ex) {
[17:39:27.747]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:27.747]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.747]                 ...future.rng), started = ...future.startTime, 
[17:39:27.747]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:27.747]             version = "1.8"), class = "FutureResult")
[17:39:27.747]     }, finally = {
[17:39:27.747]         if (!identical(...future.workdir, getwd())) 
[17:39:27.747]             setwd(...future.workdir)
[17:39:27.747]         {
[17:39:27.747]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:27.747]                 ...future.oldOptions$nwarnings <- NULL
[17:39:27.747]             }
[17:39:27.747]             base::options(...future.oldOptions)
[17:39:27.747]             if (.Platform$OS.type == "windows") {
[17:39:27.747]                 old_names <- names(...future.oldEnvVars)
[17:39:27.747]                 envs <- base::Sys.getenv()
[17:39:27.747]                 names <- names(envs)
[17:39:27.747]                 common <- intersect(names, old_names)
[17:39:27.747]                 added <- setdiff(names, old_names)
[17:39:27.747]                 removed <- setdiff(old_names, names)
[17:39:27.747]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:27.747]                   envs[common]]
[17:39:27.747]                 NAMES <- toupper(changed)
[17:39:27.747]                 args <- list()
[17:39:27.747]                 for (kk in seq_along(NAMES)) {
[17:39:27.747]                   name <- changed[[kk]]
[17:39:27.747]                   NAME <- NAMES[[kk]]
[17:39:27.747]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.747]                     next
[17:39:27.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.747]                 }
[17:39:27.747]                 NAMES <- toupper(added)
[17:39:27.747]                 for (kk in seq_along(NAMES)) {
[17:39:27.747]                   name <- added[[kk]]
[17:39:27.747]                   NAME <- NAMES[[kk]]
[17:39:27.747]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.747]                     next
[17:39:27.747]                   args[[name]] <- ""
[17:39:27.747]                 }
[17:39:27.747]                 NAMES <- toupper(removed)
[17:39:27.747]                 for (kk in seq_along(NAMES)) {
[17:39:27.747]                   name <- removed[[kk]]
[17:39:27.747]                   NAME <- NAMES[[kk]]
[17:39:27.747]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.747]                     next
[17:39:27.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.747]                 }
[17:39:27.747]                 if (length(args) > 0) 
[17:39:27.747]                   base::do.call(base::Sys.setenv, args = args)
[17:39:27.747]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:27.747]             }
[17:39:27.747]             else {
[17:39:27.747]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:27.747]             }
[17:39:27.747]             {
[17:39:27.747]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:27.747]                   0L) {
[17:39:27.747]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:27.747]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:27.747]                   base::options(opts)
[17:39:27.747]                 }
[17:39:27.747]                 {
[17:39:27.747]                   {
[17:39:27.747]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:27.747]                     NULL
[17:39:27.747]                   }
[17:39:27.747]                   options(future.plan = NULL)
[17:39:27.747]                   if (is.na(NA_character_)) 
[17:39:27.747]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.747]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:27.747]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:27.747]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:27.747]                     envir = parent.frame()) 
[17:39:27.747]                   {
[17:39:27.747]                     if (is.function(workers)) 
[17:39:27.747]                       workers <- workers()
[17:39:27.747]                     workers <- structure(as.integer(workers), 
[17:39:27.747]                       class = class(workers))
[17:39:27.747]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:27.747]                       workers >= 1)
[17:39:27.747]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:27.747]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:27.747]                     }
[17:39:27.747]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:27.747]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:27.747]                       envir = envir)
[17:39:27.747]                     if (!future$lazy) 
[17:39:27.747]                       future <- run(future)
[17:39:27.747]                     invisible(future)
[17:39:27.747]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:27.747]                 }
[17:39:27.747]             }
[17:39:27.747]         }
[17:39:27.747]     })
[17:39:27.747]     if (TRUE) {
[17:39:27.747]         base::sink(type = "output", split = FALSE)
[17:39:27.747]         if (TRUE) {
[17:39:27.747]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:27.747]         }
[17:39:27.747]         else {
[17:39:27.747]             ...future.result["stdout"] <- base::list(NULL)
[17:39:27.747]         }
[17:39:27.747]         base::close(...future.stdout)
[17:39:27.747]         ...future.stdout <- NULL
[17:39:27.747]     }
[17:39:27.747]     ...future.result$conditions <- ...future.conditions
[17:39:27.747]     ...future.result$finished <- base::Sys.time()
[17:39:27.747]     ...future.result
[17:39:27.747] }
[17:39:27.750] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[17:39:27.750] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:39:27.751] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:39:27.751] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[17:39:27.751] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[17:39:27.751] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[17:39:27.752] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[17:39:27.752] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:27.752] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:27.752] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:27.752] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:27.753] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[17:39:27.753] MultisessionFuture started
[17:39:27.753] - Launch lazy future ... done
[17:39:27.753] run() for ‘MultisessionFuture’ ... done
[17:39:27.753] Created future:
[17:39:27.753] MultisessionFuture:
[17:39:27.753] Label: ‘future_by-2’
[17:39:27.753] Expression:
[17:39:27.753] {
[17:39:27.753]     do.call(function(...) {
[17:39:27.753]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.753]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.753]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.753]             on.exit(options(oopts), add = TRUE)
[17:39:27.753]         }
[17:39:27.753]         {
[17:39:27.753]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.753]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.753]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.753]             })
[17:39:27.753]         }
[17:39:27.753]     }, args = future.call.arguments)
[17:39:27.753] }
[17:39:27.753] Lazy evaluation: FALSE
[17:39:27.753] Asynchronous evaluation: TRUE
[17:39:27.753] Local evaluation: TRUE
[17:39:27.753] Environment: R_GlobalEnv
[17:39:27.753] Capture standard output: TRUE
[17:39:27.753] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:27.753] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:27.753] Packages: <none>
[17:39:27.753] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:27.753] Resolved: FALSE
[17:39:27.753] Value: <not collected>
[17:39:27.753] Conditions captured: <none>
[17:39:27.753] Early signaling: FALSE
[17:39:27.753] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:27.753] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.765] Chunk #2 of 2 ... DONE
[17:39:27.765] Launching 2 futures (chunks) ... DONE
[17:39:27.765] Resolving 2 futures (chunks) ...
[17:39:27.765] resolve() on list ...
[17:39:27.765]  recursive: 0
[17:39:27.766]  length: 2
[17:39:27.766] 
[17:39:27.766] receiveMessageFromWorker() for ClusterFuture ...
[17:39:27.766] - Validating connection of MultisessionFuture
[17:39:27.766] - received message: FutureResult
[17:39:27.766] - Received FutureResult
[17:39:27.767] - Erased future from FutureRegistry
[17:39:27.767] result() for ClusterFuture ...
[17:39:27.767] - result already collected: FutureResult
[17:39:27.767] result() for ClusterFuture ... done
[17:39:27.767] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:27.767] Future #1
[17:39:27.767] result() for ClusterFuture ...
[17:39:27.767] - result already collected: FutureResult
[17:39:27.767] result() for ClusterFuture ... done
[17:39:27.767] result() for ClusterFuture ...
[17:39:27.768] - result already collected: FutureResult
[17:39:27.768] result() for ClusterFuture ... done
[17:39:27.768] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:27.768] - nx: 2
[17:39:27.768] - relay: TRUE
[17:39:27.768] - stdout: TRUE
[17:39:27.768] - signal: TRUE
[17:39:27.768] - resignal: FALSE
[17:39:27.768] - force: TRUE
[17:39:27.768] - relayed: [n=2] FALSE, FALSE
[17:39:27.768] - queued futures: [n=2] FALSE, FALSE
[17:39:27.769]  - until=1
[17:39:27.769]  - relaying element #1
[17:39:27.769] result() for ClusterFuture ...
[17:39:27.769] - result already collected: FutureResult
[17:39:27.769] result() for ClusterFuture ... done
[17:39:27.769] result() for ClusterFuture ...
[17:39:27.769] - result already collected: FutureResult
[17:39:27.769] result() for ClusterFuture ... done
[17:39:27.769] result() for ClusterFuture ...
[17:39:27.769] - result already collected: FutureResult
[17:39:27.769] result() for ClusterFuture ... done
[17:39:27.770] result() for ClusterFuture ...
[17:39:27.770] - result already collected: FutureResult
[17:39:27.770] result() for ClusterFuture ... done
[17:39:27.770] - relayed: [n=2] TRUE, FALSE
[17:39:27.770] - queued futures: [n=2] TRUE, FALSE
[17:39:27.770] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:27.770]  length: 1 (resolved future 1)
[17:39:27.800] receiveMessageFromWorker() for ClusterFuture ...
[17:39:27.800] - Validating connection of MultisessionFuture
[17:39:27.800] - received message: FutureResult
[17:39:27.800] - Received FutureResult
[17:39:27.800] - Erased future from FutureRegistry
[17:39:27.801] result() for ClusterFuture ...
[17:39:27.801] - result already collected: FutureResult
[17:39:27.801] result() for ClusterFuture ... done
[17:39:27.801] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:27.801] Future #2
[17:39:27.801] result() for ClusterFuture ...
[17:39:27.801] - result already collected: FutureResult
[17:39:27.801] result() for ClusterFuture ... done
[17:39:27.801] result() for ClusterFuture ...
[17:39:27.801] - result already collected: FutureResult
[17:39:27.801] result() for ClusterFuture ... done
[17:39:27.802] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:27.802] - nx: 2
[17:39:27.802] - relay: TRUE
[17:39:27.802] - stdout: TRUE
[17:39:27.802] - signal: TRUE
[17:39:27.802] - resignal: FALSE
[17:39:27.802] - force: TRUE
[17:39:27.802] - relayed: [n=2] TRUE, FALSE
[17:39:27.802] - queued futures: [n=2] TRUE, FALSE
[17:39:27.802]  - until=2
[17:39:27.802]  - relaying element #2
[17:39:27.803] result() for ClusterFuture ...
[17:39:27.803] - result already collected: FutureResult
[17:39:27.803] result() for ClusterFuture ... done
[17:39:27.803] result() for ClusterFuture ...
[17:39:27.803] - result already collected: FutureResult
[17:39:27.803] result() for ClusterFuture ... done
[17:39:27.803] result() for ClusterFuture ...
[17:39:27.803] - result already collected: FutureResult
[17:39:27.803] result() for ClusterFuture ... done
[17:39:27.803] result() for ClusterFuture ...
[17:39:27.803] - result already collected: FutureResult
[17:39:27.804] result() for ClusterFuture ... done
[17:39:27.804] - relayed: [n=2] TRUE, TRUE
[17:39:27.804] - queued futures: [n=2] TRUE, TRUE
[17:39:27.804] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:27.804]  length: 0 (resolved future 2)
[17:39:27.804] Relaying remaining futures
[17:39:27.804] signalConditionsASAP(NULL, pos=0) ...
[17:39:27.804] - nx: 2
[17:39:27.804] - relay: TRUE
[17:39:27.804] - stdout: TRUE
[17:39:27.804] - signal: TRUE
[17:39:27.805] - resignal: FALSE
[17:39:27.805] - force: TRUE
[17:39:27.805] - relayed: [n=2] TRUE, TRUE
[17:39:27.805] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:27.805] - relayed: [n=2] TRUE, TRUE
[17:39:27.805] - queued futures: [n=2] TRUE, TRUE
[17:39:27.805] signalConditionsASAP(NULL, pos=0) ... done
[17:39:27.805] resolve() on list ... DONE
[17:39:27.805] result() for ClusterFuture ...
[17:39:27.805] - result already collected: FutureResult
[17:39:27.805] result() for ClusterFuture ... done
[17:39:27.806] result() for ClusterFuture ...
[17:39:27.806] - result already collected: FutureResult
[17:39:27.806] result() for ClusterFuture ... done
[17:39:27.806] result() for ClusterFuture ...
[17:39:27.806] - result already collected: FutureResult
[17:39:27.806] result() for ClusterFuture ... done
[17:39:27.806] result() for ClusterFuture ...
[17:39:27.806] - result already collected: FutureResult
[17:39:27.806] result() for ClusterFuture ... done
[17:39:27.806]  - Number of value chunks collected: 2
[17:39:27.806] Resolving 2 futures (chunks) ... DONE
[17:39:27.807] Reducing values from 2 chunks ...
[17:39:27.807]  - Number of values collected after concatenation: 6
[17:39:27.807]  - Number of values expected: 6
[17:39:27.807] Reducing values from 2 chunks ... DONE
[17:39:27.807] future_lapply() ... DONE
[17:39:27.807] future_by_internal() ... DONE
[17:39:27.808] future_by_internal() ...
[17:39:27.808] future_lapply() ...
[17:39:27.813] Number of chunks: 2
[17:39:27.813] getGlobalsAndPackagesXApply() ...
[17:39:27.813]  - future.globals: TRUE
[17:39:27.813] getGlobalsAndPackages() ...
[17:39:27.813] Searching for globals...
[17:39:27.815] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:27.815] Searching for globals ... DONE
[17:39:27.815] Resolving globals: FALSE
[17:39:27.815] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:39:27.816] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:39:27.816] - globals: [1] ‘FUN’
[17:39:27.816] - packages: [1] ‘stats’
[17:39:27.816] getGlobalsAndPackages() ... DONE
[17:39:27.816]  - globals found/used: [n=1] ‘FUN’
[17:39:27.816]  - needed namespaces: [n=1] ‘stats’
[17:39:27.816] Finding globals ... DONE
[17:39:27.817]  - use_args: TRUE
[17:39:27.817]  - Getting '...' globals ...
[17:39:27.817] resolve() on list ...
[17:39:27.817]  recursive: 0
[17:39:27.817]  length: 1
[17:39:27.817]  elements: ‘...’
[17:39:27.817]  length: 0 (resolved future 1)
[17:39:27.817] resolve() on list ... DONE
[17:39:27.818]    - '...' content: [n=1] ‘singular.ok’
[17:39:27.818] List of 1
[17:39:27.818]  $ ...:List of 1
[17:39:27.818]   ..$ singular.ok: logi FALSE
[17:39:27.818]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:27.818]  - attr(*, "where")=List of 1
[17:39:27.818]   ..$ ...:<environment: 0x562970a28548> 
[17:39:27.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:27.818]  - attr(*, "resolved")= logi TRUE
[17:39:27.818]  - attr(*, "total_size")= num NA
[17:39:27.821]  - Getting '...' globals ... DONE
[17:39:27.823] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:27.823] List of 2
[17:39:27.823]  $ ...future.FUN:function (x, ...)  
[17:39:27.823]  $ ...          :List of 1
[17:39:27.823]   ..$ singular.ok: logi FALSE
[17:39:27.823]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:27.823]  - attr(*, "where")=List of 2
[17:39:27.823]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:27.823]   ..$ ...          :<environment: 0x562970a28548> 
[17:39:27.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:27.823]  - attr(*, "resolved")= logi FALSE
[17:39:27.823]  - attr(*, "total_size")= num 5384
[17:39:27.826] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:27.826] getGlobalsAndPackagesXApply() ... DONE
[17:39:27.826] Number of futures (= number of chunks): 2
[17:39:27.826] Launching 2 futures (chunks) ...
[17:39:27.826] Chunk #1 of 2 ...
[17:39:27.826]  - Finding globals in 'X' for chunk #1 ...
[17:39:27.826] getGlobalsAndPackages() ...
[17:39:27.827] Searching for globals...
[17:39:27.827] 
[17:39:27.827] Searching for globals ... DONE
[17:39:27.827] - globals: [0] <none>
[17:39:27.827] getGlobalsAndPackages() ... DONE
[17:39:27.827]    + additional globals found: [n=0] 
[17:39:27.827]    + additional namespaces needed: [n=0] 
[17:39:27.827]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:27.827]  - seeds: <none>
[17:39:27.828] getGlobalsAndPackages() ...
[17:39:27.828] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.828] Resolving globals: FALSE
[17:39:27.828] Tweak future expression to call with '...' arguments ...
[17:39:27.828] {
[17:39:27.828]     do.call(function(...) {
[17:39:27.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.828]             on.exit(options(oopts), add = TRUE)
[17:39:27.828]         }
[17:39:27.828]         {
[17:39:27.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.828]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.828]             })
[17:39:27.828]         }
[17:39:27.828]     }, args = future.call.arguments)
[17:39:27.828] }
[17:39:27.828] Tweak future expression to call with '...' arguments ... DONE
[17:39:27.829] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.829] 
[17:39:27.829] getGlobalsAndPackages() ... DONE
[17:39:27.829] run() for ‘Future’ ...
[17:39:27.829] - state: ‘created’
[17:39:27.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:27.843] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:27.844]   - Field: ‘node’
[17:39:27.844]   - Field: ‘label’
[17:39:27.844]   - Field: ‘local’
[17:39:27.844]   - Field: ‘owner’
[17:39:27.844]   - Field: ‘envir’
[17:39:27.844]   - Field: ‘workers’
[17:39:27.844]   - Field: ‘packages’
[17:39:27.844]   - Field: ‘gc’
[17:39:27.844]   - Field: ‘conditions’
[17:39:27.844]   - Field: ‘persistent’
[17:39:27.844]   - Field: ‘expr’
[17:39:27.845]   - Field: ‘uuid’
[17:39:27.845]   - Field: ‘seed’
[17:39:27.845]   - Field: ‘version’
[17:39:27.845]   - Field: ‘result’
[17:39:27.845]   - Field: ‘asynchronous’
[17:39:27.845]   - Field: ‘calls’
[17:39:27.845]   - Field: ‘globals’
[17:39:27.845]   - Field: ‘stdout’
[17:39:27.845]   - Field: ‘earlySignal’
[17:39:27.845]   - Field: ‘lazy’
[17:39:27.845]   - Field: ‘state’
[17:39:27.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:27.846] - Launch lazy future ...
[17:39:27.846] Packages needed by the future expression (n = 1): ‘stats’
[17:39:27.846] Packages needed by future strategies (n = 0): <none>
[17:39:27.846] {
[17:39:27.846]     {
[17:39:27.846]         {
[17:39:27.846]             ...future.startTime <- base::Sys.time()
[17:39:27.846]             {
[17:39:27.846]                 {
[17:39:27.846]                   {
[17:39:27.846]                     {
[17:39:27.846]                       {
[17:39:27.846]                         base::local({
[17:39:27.846]                           has_future <- base::requireNamespace("future", 
[17:39:27.846]                             quietly = TRUE)
[17:39:27.846]                           if (has_future) {
[17:39:27.846]                             ns <- base::getNamespace("future")
[17:39:27.846]                             version <- ns[[".package"]][["version"]]
[17:39:27.846]                             if (is.null(version)) 
[17:39:27.846]                               version <- utils::packageVersion("future")
[17:39:27.846]                           }
[17:39:27.846]                           else {
[17:39:27.846]                             version <- NULL
[17:39:27.846]                           }
[17:39:27.846]                           if (!has_future || version < "1.8.0") {
[17:39:27.846]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:27.846]                               "", base::R.version$version.string), 
[17:39:27.846]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:27.846]                                 base::R.version$platform, 8 * 
[17:39:27.846]                                   base::.Machine$sizeof.pointer), 
[17:39:27.846]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:27.846]                                 "release", "version")], collapse = " "), 
[17:39:27.846]                               hostname = base::Sys.info()[["nodename"]])
[17:39:27.846]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:27.846]                               info)
[17:39:27.846]                             info <- base::paste(info, collapse = "; ")
[17:39:27.846]                             if (!has_future) {
[17:39:27.846]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:27.846]                                 info)
[17:39:27.846]                             }
[17:39:27.846]                             else {
[17:39:27.846]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:27.846]                                 info, version)
[17:39:27.846]                             }
[17:39:27.846]                             base::stop(msg)
[17:39:27.846]                           }
[17:39:27.846]                         })
[17:39:27.846]                       }
[17:39:27.846]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:27.846]                       base::options(mc.cores = 1L)
[17:39:27.846]                     }
[17:39:27.846]                     base::local({
[17:39:27.846]                       for (pkg in "stats") {
[17:39:27.846]                         base::loadNamespace(pkg)
[17:39:27.846]                         base::library(pkg, character.only = TRUE)
[17:39:27.846]                       }
[17:39:27.846]                     })
[17:39:27.846]                   }
[17:39:27.846]                   options(future.plan = NULL)
[17:39:27.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:27.846]                 }
[17:39:27.846]                 ...future.workdir <- getwd()
[17:39:27.846]             }
[17:39:27.846]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:27.846]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:27.846]         }
[17:39:27.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:27.846]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:27.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:27.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:27.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:27.846]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:27.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:27.846]             base::names(...future.oldOptions))
[17:39:27.846]     }
[17:39:27.846]     if (FALSE) {
[17:39:27.846]     }
[17:39:27.846]     else {
[17:39:27.846]         if (TRUE) {
[17:39:27.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:27.846]                 open = "w")
[17:39:27.846]         }
[17:39:27.846]         else {
[17:39:27.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:27.846]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:27.846]         }
[17:39:27.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:27.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:27.846]             base::sink(type = "output", split = FALSE)
[17:39:27.846]             base::close(...future.stdout)
[17:39:27.846]         }, add = TRUE)
[17:39:27.846]     }
[17:39:27.846]     ...future.frame <- base::sys.nframe()
[17:39:27.846]     ...future.conditions <- base::list()
[17:39:27.846]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:27.846]     if (FALSE) {
[17:39:27.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:27.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:27.846]     }
[17:39:27.846]     ...future.result <- base::tryCatch({
[17:39:27.846]         base::withCallingHandlers({
[17:39:27.846]             ...future.value <- base::withVisible(base::local({
[17:39:27.846]                 ...future.makeSendCondition <- local({
[17:39:27.846]                   sendCondition <- NULL
[17:39:27.846]                   function(frame = 1L) {
[17:39:27.846]                     if (is.function(sendCondition)) 
[17:39:27.846]                       return(sendCondition)
[17:39:27.846]                     ns <- getNamespace("parallel")
[17:39:27.846]                     if (exists("sendData", mode = "function", 
[17:39:27.846]                       envir = ns)) {
[17:39:27.846]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:27.846]                         envir = ns)
[17:39:27.846]                       envir <- sys.frame(frame)
[17:39:27.846]                       master <- NULL
[17:39:27.846]                       while (!identical(envir, .GlobalEnv) && 
[17:39:27.846]                         !identical(envir, emptyenv())) {
[17:39:27.846]                         if (exists("master", mode = "list", envir = envir, 
[17:39:27.846]                           inherits = FALSE)) {
[17:39:27.846]                           master <- get("master", mode = "list", 
[17:39:27.846]                             envir = envir, inherits = FALSE)
[17:39:27.846]                           if (inherits(master, c("SOCKnode", 
[17:39:27.846]                             "SOCK0node"))) {
[17:39:27.846]                             sendCondition <<- function(cond) {
[17:39:27.846]                               data <- list(type = "VALUE", value = cond, 
[17:39:27.846]                                 success = TRUE)
[17:39:27.846]                               parallel_sendData(master, data)
[17:39:27.846]                             }
[17:39:27.846]                             return(sendCondition)
[17:39:27.846]                           }
[17:39:27.846]                         }
[17:39:27.846]                         frame <- frame + 1L
[17:39:27.846]                         envir <- sys.frame(frame)
[17:39:27.846]                       }
[17:39:27.846]                     }
[17:39:27.846]                     sendCondition <<- function(cond) NULL
[17:39:27.846]                   }
[17:39:27.846]                 })
[17:39:27.846]                 withCallingHandlers({
[17:39:27.846]                   {
[17:39:27.846]                     do.call(function(...) {
[17:39:27.846]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.846]                       if (!identical(...future.globals.maxSize.org, 
[17:39:27.846]                         ...future.globals.maxSize)) {
[17:39:27.846]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.846]                         on.exit(options(oopts), add = TRUE)
[17:39:27.846]                       }
[17:39:27.846]                       {
[17:39:27.846]                         lapply(seq_along(...future.elements_ii), 
[17:39:27.846]                           FUN = function(jj) {
[17:39:27.846]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.846]                             ...future.FUN(...future.X_jj, ...)
[17:39:27.846]                           })
[17:39:27.846]                       }
[17:39:27.846]                     }, args = future.call.arguments)
[17:39:27.846]                   }
[17:39:27.846]                 }, immediateCondition = function(cond) {
[17:39:27.846]                   sendCondition <- ...future.makeSendCondition()
[17:39:27.846]                   sendCondition(cond)
[17:39:27.846]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.846]                   {
[17:39:27.846]                     inherits <- base::inherits
[17:39:27.846]                     invokeRestart <- base::invokeRestart
[17:39:27.846]                     is.null <- base::is.null
[17:39:27.846]                     muffled <- FALSE
[17:39:27.846]                     if (inherits(cond, "message")) {
[17:39:27.846]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:27.846]                       if (muffled) 
[17:39:27.846]                         invokeRestart("muffleMessage")
[17:39:27.846]                     }
[17:39:27.846]                     else if (inherits(cond, "warning")) {
[17:39:27.846]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:27.846]                       if (muffled) 
[17:39:27.846]                         invokeRestart("muffleWarning")
[17:39:27.846]                     }
[17:39:27.846]                     else if (inherits(cond, "condition")) {
[17:39:27.846]                       if (!is.null(pattern)) {
[17:39:27.846]                         computeRestarts <- base::computeRestarts
[17:39:27.846]                         grepl <- base::grepl
[17:39:27.846]                         restarts <- computeRestarts(cond)
[17:39:27.846]                         for (restart in restarts) {
[17:39:27.846]                           name <- restart$name
[17:39:27.846]                           if (is.null(name)) 
[17:39:27.846]                             next
[17:39:27.846]                           if (!grepl(pattern, name)) 
[17:39:27.846]                             next
[17:39:27.846]                           invokeRestart(restart)
[17:39:27.846]                           muffled <- TRUE
[17:39:27.846]                           break
[17:39:27.846]                         }
[17:39:27.846]                       }
[17:39:27.846]                     }
[17:39:27.846]                     invisible(muffled)
[17:39:27.846]                   }
[17:39:27.846]                   muffleCondition(cond)
[17:39:27.846]                 })
[17:39:27.846]             }))
[17:39:27.846]             future::FutureResult(value = ...future.value$value, 
[17:39:27.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.846]                   ...future.rng), globalenv = if (FALSE) 
[17:39:27.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:27.846]                     ...future.globalenv.names))
[17:39:27.846]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:27.846]         }, condition = base::local({
[17:39:27.846]             c <- base::c
[17:39:27.846]             inherits <- base::inherits
[17:39:27.846]             invokeRestart <- base::invokeRestart
[17:39:27.846]             length <- base::length
[17:39:27.846]             list <- base::list
[17:39:27.846]             seq.int <- base::seq.int
[17:39:27.846]             signalCondition <- base::signalCondition
[17:39:27.846]             sys.calls <- base::sys.calls
[17:39:27.846]             `[[` <- base::`[[`
[17:39:27.846]             `+` <- base::`+`
[17:39:27.846]             `<<-` <- base::`<<-`
[17:39:27.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:27.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:27.846]                   3L)]
[17:39:27.846]             }
[17:39:27.846]             function(cond) {
[17:39:27.846]                 is_error <- inherits(cond, "error")
[17:39:27.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:27.846]                   NULL)
[17:39:27.846]                 if (is_error) {
[17:39:27.846]                   sessionInformation <- function() {
[17:39:27.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:27.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:27.846]                       search = base::search(), system = base::Sys.info())
[17:39:27.846]                   }
[17:39:27.846]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:27.846]                     cond$call), session = sessionInformation(), 
[17:39:27.846]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:27.846]                   signalCondition(cond)
[17:39:27.846]                 }
[17:39:27.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:27.846]                 "immediateCondition"))) {
[17:39:27.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:27.846]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:27.846]                   if (TRUE && !signal) {
[17:39:27.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.846]                     {
[17:39:27.846]                       inherits <- base::inherits
[17:39:27.846]                       invokeRestart <- base::invokeRestart
[17:39:27.846]                       is.null <- base::is.null
[17:39:27.846]                       muffled <- FALSE
[17:39:27.846]                       if (inherits(cond, "message")) {
[17:39:27.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.846]                         if (muffled) 
[17:39:27.846]                           invokeRestart("muffleMessage")
[17:39:27.846]                       }
[17:39:27.846]                       else if (inherits(cond, "warning")) {
[17:39:27.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.846]                         if (muffled) 
[17:39:27.846]                           invokeRestart("muffleWarning")
[17:39:27.846]                       }
[17:39:27.846]                       else if (inherits(cond, "condition")) {
[17:39:27.846]                         if (!is.null(pattern)) {
[17:39:27.846]                           computeRestarts <- base::computeRestarts
[17:39:27.846]                           grepl <- base::grepl
[17:39:27.846]                           restarts <- computeRestarts(cond)
[17:39:27.846]                           for (restart in restarts) {
[17:39:27.846]                             name <- restart$name
[17:39:27.846]                             if (is.null(name)) 
[17:39:27.846]                               next
[17:39:27.846]                             if (!grepl(pattern, name)) 
[17:39:27.846]                               next
[17:39:27.846]                             invokeRestart(restart)
[17:39:27.846]                             muffled <- TRUE
[17:39:27.846]                             break
[17:39:27.846]                           }
[17:39:27.846]                         }
[17:39:27.846]                       }
[17:39:27.846]                       invisible(muffled)
[17:39:27.846]                     }
[17:39:27.846]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.846]                   }
[17:39:27.846]                 }
[17:39:27.846]                 else {
[17:39:27.846]                   if (TRUE) {
[17:39:27.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.846]                     {
[17:39:27.846]                       inherits <- base::inherits
[17:39:27.846]                       invokeRestart <- base::invokeRestart
[17:39:27.846]                       is.null <- base::is.null
[17:39:27.846]                       muffled <- FALSE
[17:39:27.846]                       if (inherits(cond, "message")) {
[17:39:27.846]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.846]                         if (muffled) 
[17:39:27.846]                           invokeRestart("muffleMessage")
[17:39:27.846]                       }
[17:39:27.846]                       else if (inherits(cond, "warning")) {
[17:39:27.846]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.846]                         if (muffled) 
[17:39:27.846]                           invokeRestart("muffleWarning")
[17:39:27.846]                       }
[17:39:27.846]                       else if (inherits(cond, "condition")) {
[17:39:27.846]                         if (!is.null(pattern)) {
[17:39:27.846]                           computeRestarts <- base::computeRestarts
[17:39:27.846]                           grepl <- base::grepl
[17:39:27.846]                           restarts <- computeRestarts(cond)
[17:39:27.846]                           for (restart in restarts) {
[17:39:27.846]                             name <- restart$name
[17:39:27.846]                             if (is.null(name)) 
[17:39:27.846]                               next
[17:39:27.846]                             if (!grepl(pattern, name)) 
[17:39:27.846]                               next
[17:39:27.846]                             invokeRestart(restart)
[17:39:27.846]                             muffled <- TRUE
[17:39:27.846]                             break
[17:39:27.846]                           }
[17:39:27.846]                         }
[17:39:27.846]                       }
[17:39:27.846]                       invisible(muffled)
[17:39:27.846]                     }
[17:39:27.846]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.846]                   }
[17:39:27.846]                 }
[17:39:27.846]             }
[17:39:27.846]         }))
[17:39:27.846]     }, error = function(ex) {
[17:39:27.846]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:27.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.846]                 ...future.rng), started = ...future.startTime, 
[17:39:27.846]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:27.846]             version = "1.8"), class = "FutureResult")
[17:39:27.846]     }, finally = {
[17:39:27.846]         if (!identical(...future.workdir, getwd())) 
[17:39:27.846]             setwd(...future.workdir)
[17:39:27.846]         {
[17:39:27.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:27.846]                 ...future.oldOptions$nwarnings <- NULL
[17:39:27.846]             }
[17:39:27.846]             base::options(...future.oldOptions)
[17:39:27.846]             if (.Platform$OS.type == "windows") {
[17:39:27.846]                 old_names <- names(...future.oldEnvVars)
[17:39:27.846]                 envs <- base::Sys.getenv()
[17:39:27.846]                 names <- names(envs)
[17:39:27.846]                 common <- intersect(names, old_names)
[17:39:27.846]                 added <- setdiff(names, old_names)
[17:39:27.846]                 removed <- setdiff(old_names, names)
[17:39:27.846]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:27.846]                   envs[common]]
[17:39:27.846]                 NAMES <- toupper(changed)
[17:39:27.846]                 args <- list()
[17:39:27.846]                 for (kk in seq_along(NAMES)) {
[17:39:27.846]                   name <- changed[[kk]]
[17:39:27.846]                   NAME <- NAMES[[kk]]
[17:39:27.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.846]                     next
[17:39:27.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.846]                 }
[17:39:27.846]                 NAMES <- toupper(added)
[17:39:27.846]                 for (kk in seq_along(NAMES)) {
[17:39:27.846]                   name <- added[[kk]]
[17:39:27.846]                   NAME <- NAMES[[kk]]
[17:39:27.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.846]                     next
[17:39:27.846]                   args[[name]] <- ""
[17:39:27.846]                 }
[17:39:27.846]                 NAMES <- toupper(removed)
[17:39:27.846]                 for (kk in seq_along(NAMES)) {
[17:39:27.846]                   name <- removed[[kk]]
[17:39:27.846]                   NAME <- NAMES[[kk]]
[17:39:27.846]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.846]                     next
[17:39:27.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.846]                 }
[17:39:27.846]                 if (length(args) > 0) 
[17:39:27.846]                   base::do.call(base::Sys.setenv, args = args)
[17:39:27.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:27.846]             }
[17:39:27.846]             else {
[17:39:27.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:27.846]             }
[17:39:27.846]             {
[17:39:27.846]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:27.846]                   0L) {
[17:39:27.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:27.846]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:27.846]                   base::options(opts)
[17:39:27.846]                 }
[17:39:27.846]                 {
[17:39:27.846]                   {
[17:39:27.846]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:27.846]                     NULL
[17:39:27.846]                   }
[17:39:27.846]                   options(future.plan = NULL)
[17:39:27.846]                   if (is.na(NA_character_)) 
[17:39:27.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:27.846]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:27.846]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:27.846]                     envir = parent.frame()) 
[17:39:27.846]                   {
[17:39:27.846]                     if (is.function(workers)) 
[17:39:27.846]                       workers <- workers()
[17:39:27.846]                     workers <- structure(as.integer(workers), 
[17:39:27.846]                       class = class(workers))
[17:39:27.846]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:27.846]                       workers >= 1)
[17:39:27.846]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:27.846]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:27.846]                     }
[17:39:27.846]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:27.846]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:27.846]                       envir = envir)
[17:39:27.846]                     if (!future$lazy) 
[17:39:27.846]                       future <- run(future)
[17:39:27.846]                     invisible(future)
[17:39:27.846]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:27.846]                 }
[17:39:27.846]             }
[17:39:27.846]         }
[17:39:27.846]     })
[17:39:27.846]     if (TRUE) {
[17:39:27.846]         base::sink(type = "output", split = FALSE)
[17:39:27.846]         if (TRUE) {
[17:39:27.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:27.846]         }
[17:39:27.846]         else {
[17:39:27.846]             ...future.result["stdout"] <- base::list(NULL)
[17:39:27.846]         }
[17:39:27.846]         base::close(...future.stdout)
[17:39:27.846]         ...future.stdout <- NULL
[17:39:27.846]     }
[17:39:27.846]     ...future.result$conditions <- ...future.conditions
[17:39:27.846]     ...future.result$finished <- base::Sys.time()
[17:39:27.846]     ...future.result
[17:39:27.846] }
[17:39:27.849] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[17:39:27.849] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[17:39:27.850] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[17:39:27.850] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:39:27.850] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:39:27.851] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:39:27.851] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:39:27.851] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:27.851] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:27.851] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:27.852] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:27.852] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[17:39:27.852] MultisessionFuture started
[17:39:27.852] - Launch lazy future ... done
[17:39:27.853] run() for ‘MultisessionFuture’ ... done
[17:39:27.853] Created future:
[17:39:27.853] MultisessionFuture:
[17:39:27.853] Label: ‘future_by-1’
[17:39:27.853] Expression:
[17:39:27.853] {
[17:39:27.853]     do.call(function(...) {
[17:39:27.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.853]             on.exit(options(oopts), add = TRUE)
[17:39:27.853]         }
[17:39:27.853]         {
[17:39:27.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.853]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.853]             })
[17:39:27.853]         }
[17:39:27.853]     }, args = future.call.arguments)
[17:39:27.853] }
[17:39:27.853] Lazy evaluation: FALSE
[17:39:27.853] Asynchronous evaluation: TRUE
[17:39:27.853] Local evaluation: TRUE
[17:39:27.853] Environment: R_GlobalEnv
[17:39:27.853] Capture standard output: TRUE
[17:39:27.853] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:27.853] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:27.853] Packages: 1 packages (‘stats’)
[17:39:27.853] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:27.853] Resolved: FALSE
[17:39:27.853] Value: <not collected>
[17:39:27.853] Conditions captured: <none>
[17:39:27.853] Early signaling: FALSE
[17:39:27.853] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:27.853] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.864] Chunk #1 of 2 ... DONE
[17:39:27.864] Chunk #2 of 2 ...
[17:39:27.864]  - Finding globals in 'X' for chunk #2 ...
[17:39:27.864] getGlobalsAndPackages() ...
[17:39:27.865] Searching for globals...
[17:39:27.865] 
[17:39:27.865] Searching for globals ... DONE
[17:39:27.865] - globals: [0] <none>
[17:39:27.865] getGlobalsAndPackages() ... DONE
[17:39:27.865]    + additional globals found: [n=0] 
[17:39:27.865]    + additional namespaces needed: [n=0] 
[17:39:27.866]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:27.866]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:27.866]  - seeds: <none>
[17:39:27.866] getGlobalsAndPackages() ...
[17:39:27.866] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.866] Resolving globals: FALSE
[17:39:27.866] Tweak future expression to call with '...' arguments ...
[17:39:27.866] {
[17:39:27.866]     do.call(function(...) {
[17:39:27.866]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.866]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.866]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.866]             on.exit(options(oopts), add = TRUE)
[17:39:27.866]         }
[17:39:27.866]         {
[17:39:27.866]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.866]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.866]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.866]             })
[17:39:27.866]         }
[17:39:27.866]     }, args = future.call.arguments)
[17:39:27.866] }
[17:39:27.867] Tweak future expression to call with '...' arguments ... DONE
[17:39:27.867] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.867] 
[17:39:27.867] getGlobalsAndPackages() ... DONE
[17:39:27.867] run() for ‘Future’ ...
[17:39:27.867] - state: ‘created’
[17:39:27.868] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:27.882] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.882] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:27.882]   - Field: ‘node’
[17:39:27.882]   - Field: ‘label’
[17:39:27.882]   - Field: ‘local’
[17:39:27.882]   - Field: ‘owner’
[17:39:27.882]   - Field: ‘envir’
[17:39:27.882]   - Field: ‘workers’
[17:39:27.882]   - Field: ‘packages’
[17:39:27.883]   - Field: ‘gc’
[17:39:27.883]   - Field: ‘conditions’
[17:39:27.883]   - Field: ‘persistent’
[17:39:27.883]   - Field: ‘expr’
[17:39:27.883]   - Field: ‘uuid’
[17:39:27.883]   - Field: ‘seed’
[17:39:27.883]   - Field: ‘version’
[17:39:27.883]   - Field: ‘result’
[17:39:27.883]   - Field: ‘asynchronous’
[17:39:27.883]   - Field: ‘calls’
[17:39:27.883]   - Field: ‘globals’
[17:39:27.884]   - Field: ‘stdout’
[17:39:27.884]   - Field: ‘earlySignal’
[17:39:27.884]   - Field: ‘lazy’
[17:39:27.884]   - Field: ‘state’
[17:39:27.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:27.884] - Launch lazy future ...
[17:39:27.884] Packages needed by the future expression (n = 1): ‘stats’
[17:39:27.884] Packages needed by future strategies (n = 0): <none>
[17:39:27.885] {
[17:39:27.885]     {
[17:39:27.885]         {
[17:39:27.885]             ...future.startTime <- base::Sys.time()
[17:39:27.885]             {
[17:39:27.885]                 {
[17:39:27.885]                   {
[17:39:27.885]                     {
[17:39:27.885]                       {
[17:39:27.885]                         base::local({
[17:39:27.885]                           has_future <- base::requireNamespace("future", 
[17:39:27.885]                             quietly = TRUE)
[17:39:27.885]                           if (has_future) {
[17:39:27.885]                             ns <- base::getNamespace("future")
[17:39:27.885]                             version <- ns[[".package"]][["version"]]
[17:39:27.885]                             if (is.null(version)) 
[17:39:27.885]                               version <- utils::packageVersion("future")
[17:39:27.885]                           }
[17:39:27.885]                           else {
[17:39:27.885]                             version <- NULL
[17:39:27.885]                           }
[17:39:27.885]                           if (!has_future || version < "1.8.0") {
[17:39:27.885]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:27.885]                               "", base::R.version$version.string), 
[17:39:27.885]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:27.885]                                 base::R.version$platform, 8 * 
[17:39:27.885]                                   base::.Machine$sizeof.pointer), 
[17:39:27.885]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:27.885]                                 "release", "version")], collapse = " "), 
[17:39:27.885]                               hostname = base::Sys.info()[["nodename"]])
[17:39:27.885]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:27.885]                               info)
[17:39:27.885]                             info <- base::paste(info, collapse = "; ")
[17:39:27.885]                             if (!has_future) {
[17:39:27.885]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:27.885]                                 info)
[17:39:27.885]                             }
[17:39:27.885]                             else {
[17:39:27.885]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:27.885]                                 info, version)
[17:39:27.885]                             }
[17:39:27.885]                             base::stop(msg)
[17:39:27.885]                           }
[17:39:27.885]                         })
[17:39:27.885]                       }
[17:39:27.885]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:27.885]                       base::options(mc.cores = 1L)
[17:39:27.885]                     }
[17:39:27.885]                     base::local({
[17:39:27.885]                       for (pkg in "stats") {
[17:39:27.885]                         base::loadNamespace(pkg)
[17:39:27.885]                         base::library(pkg, character.only = TRUE)
[17:39:27.885]                       }
[17:39:27.885]                     })
[17:39:27.885]                   }
[17:39:27.885]                   options(future.plan = NULL)
[17:39:27.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:27.885]                 }
[17:39:27.885]                 ...future.workdir <- getwd()
[17:39:27.885]             }
[17:39:27.885]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:27.885]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:27.885]         }
[17:39:27.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:27.885]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:27.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:27.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:27.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:27.885]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:27.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:27.885]             base::names(...future.oldOptions))
[17:39:27.885]     }
[17:39:27.885]     if (FALSE) {
[17:39:27.885]     }
[17:39:27.885]     else {
[17:39:27.885]         if (TRUE) {
[17:39:27.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:27.885]                 open = "w")
[17:39:27.885]         }
[17:39:27.885]         else {
[17:39:27.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:27.885]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:27.885]         }
[17:39:27.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:27.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:27.885]             base::sink(type = "output", split = FALSE)
[17:39:27.885]             base::close(...future.stdout)
[17:39:27.885]         }, add = TRUE)
[17:39:27.885]     }
[17:39:27.885]     ...future.frame <- base::sys.nframe()
[17:39:27.885]     ...future.conditions <- base::list()
[17:39:27.885]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:27.885]     if (FALSE) {
[17:39:27.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:27.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:27.885]     }
[17:39:27.885]     ...future.result <- base::tryCatch({
[17:39:27.885]         base::withCallingHandlers({
[17:39:27.885]             ...future.value <- base::withVisible(base::local({
[17:39:27.885]                 ...future.makeSendCondition <- local({
[17:39:27.885]                   sendCondition <- NULL
[17:39:27.885]                   function(frame = 1L) {
[17:39:27.885]                     if (is.function(sendCondition)) 
[17:39:27.885]                       return(sendCondition)
[17:39:27.885]                     ns <- getNamespace("parallel")
[17:39:27.885]                     if (exists("sendData", mode = "function", 
[17:39:27.885]                       envir = ns)) {
[17:39:27.885]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:27.885]                         envir = ns)
[17:39:27.885]                       envir <- sys.frame(frame)
[17:39:27.885]                       master <- NULL
[17:39:27.885]                       while (!identical(envir, .GlobalEnv) && 
[17:39:27.885]                         !identical(envir, emptyenv())) {
[17:39:27.885]                         if (exists("master", mode = "list", envir = envir, 
[17:39:27.885]                           inherits = FALSE)) {
[17:39:27.885]                           master <- get("master", mode = "list", 
[17:39:27.885]                             envir = envir, inherits = FALSE)
[17:39:27.885]                           if (inherits(master, c("SOCKnode", 
[17:39:27.885]                             "SOCK0node"))) {
[17:39:27.885]                             sendCondition <<- function(cond) {
[17:39:27.885]                               data <- list(type = "VALUE", value = cond, 
[17:39:27.885]                                 success = TRUE)
[17:39:27.885]                               parallel_sendData(master, data)
[17:39:27.885]                             }
[17:39:27.885]                             return(sendCondition)
[17:39:27.885]                           }
[17:39:27.885]                         }
[17:39:27.885]                         frame <- frame + 1L
[17:39:27.885]                         envir <- sys.frame(frame)
[17:39:27.885]                       }
[17:39:27.885]                     }
[17:39:27.885]                     sendCondition <<- function(cond) NULL
[17:39:27.885]                   }
[17:39:27.885]                 })
[17:39:27.885]                 withCallingHandlers({
[17:39:27.885]                   {
[17:39:27.885]                     do.call(function(...) {
[17:39:27.885]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.885]                       if (!identical(...future.globals.maxSize.org, 
[17:39:27.885]                         ...future.globals.maxSize)) {
[17:39:27.885]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.885]                         on.exit(options(oopts), add = TRUE)
[17:39:27.885]                       }
[17:39:27.885]                       {
[17:39:27.885]                         lapply(seq_along(...future.elements_ii), 
[17:39:27.885]                           FUN = function(jj) {
[17:39:27.885]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.885]                             ...future.FUN(...future.X_jj, ...)
[17:39:27.885]                           })
[17:39:27.885]                       }
[17:39:27.885]                     }, args = future.call.arguments)
[17:39:27.885]                   }
[17:39:27.885]                 }, immediateCondition = function(cond) {
[17:39:27.885]                   sendCondition <- ...future.makeSendCondition()
[17:39:27.885]                   sendCondition(cond)
[17:39:27.885]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.885]                   {
[17:39:27.885]                     inherits <- base::inherits
[17:39:27.885]                     invokeRestart <- base::invokeRestart
[17:39:27.885]                     is.null <- base::is.null
[17:39:27.885]                     muffled <- FALSE
[17:39:27.885]                     if (inherits(cond, "message")) {
[17:39:27.885]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:27.885]                       if (muffled) 
[17:39:27.885]                         invokeRestart("muffleMessage")
[17:39:27.885]                     }
[17:39:27.885]                     else if (inherits(cond, "warning")) {
[17:39:27.885]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:27.885]                       if (muffled) 
[17:39:27.885]                         invokeRestart("muffleWarning")
[17:39:27.885]                     }
[17:39:27.885]                     else if (inherits(cond, "condition")) {
[17:39:27.885]                       if (!is.null(pattern)) {
[17:39:27.885]                         computeRestarts <- base::computeRestarts
[17:39:27.885]                         grepl <- base::grepl
[17:39:27.885]                         restarts <- computeRestarts(cond)
[17:39:27.885]                         for (restart in restarts) {
[17:39:27.885]                           name <- restart$name
[17:39:27.885]                           if (is.null(name)) 
[17:39:27.885]                             next
[17:39:27.885]                           if (!grepl(pattern, name)) 
[17:39:27.885]                             next
[17:39:27.885]                           invokeRestart(restart)
[17:39:27.885]                           muffled <- TRUE
[17:39:27.885]                           break
[17:39:27.885]                         }
[17:39:27.885]                       }
[17:39:27.885]                     }
[17:39:27.885]                     invisible(muffled)
[17:39:27.885]                   }
[17:39:27.885]                   muffleCondition(cond)
[17:39:27.885]                 })
[17:39:27.885]             }))
[17:39:27.885]             future::FutureResult(value = ...future.value$value, 
[17:39:27.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.885]                   ...future.rng), globalenv = if (FALSE) 
[17:39:27.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:27.885]                     ...future.globalenv.names))
[17:39:27.885]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:27.885]         }, condition = base::local({
[17:39:27.885]             c <- base::c
[17:39:27.885]             inherits <- base::inherits
[17:39:27.885]             invokeRestart <- base::invokeRestart
[17:39:27.885]             length <- base::length
[17:39:27.885]             list <- base::list
[17:39:27.885]             seq.int <- base::seq.int
[17:39:27.885]             signalCondition <- base::signalCondition
[17:39:27.885]             sys.calls <- base::sys.calls
[17:39:27.885]             `[[` <- base::`[[`
[17:39:27.885]             `+` <- base::`+`
[17:39:27.885]             `<<-` <- base::`<<-`
[17:39:27.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:27.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:27.885]                   3L)]
[17:39:27.885]             }
[17:39:27.885]             function(cond) {
[17:39:27.885]                 is_error <- inherits(cond, "error")
[17:39:27.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:27.885]                   NULL)
[17:39:27.885]                 if (is_error) {
[17:39:27.885]                   sessionInformation <- function() {
[17:39:27.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:27.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:27.885]                       search = base::search(), system = base::Sys.info())
[17:39:27.885]                   }
[17:39:27.885]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:27.885]                     cond$call), session = sessionInformation(), 
[17:39:27.885]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:27.885]                   signalCondition(cond)
[17:39:27.885]                 }
[17:39:27.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:27.885]                 "immediateCondition"))) {
[17:39:27.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:27.885]                   ...future.conditions[[length(...future.conditions) + 
[17:39:27.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:27.885]                   if (TRUE && !signal) {
[17:39:27.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.885]                     {
[17:39:27.885]                       inherits <- base::inherits
[17:39:27.885]                       invokeRestart <- base::invokeRestart
[17:39:27.885]                       is.null <- base::is.null
[17:39:27.885]                       muffled <- FALSE
[17:39:27.885]                       if (inherits(cond, "message")) {
[17:39:27.885]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.885]                         if (muffled) 
[17:39:27.885]                           invokeRestart("muffleMessage")
[17:39:27.885]                       }
[17:39:27.885]                       else if (inherits(cond, "warning")) {
[17:39:27.885]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.885]                         if (muffled) 
[17:39:27.885]                           invokeRestart("muffleWarning")
[17:39:27.885]                       }
[17:39:27.885]                       else if (inherits(cond, "condition")) {
[17:39:27.885]                         if (!is.null(pattern)) {
[17:39:27.885]                           computeRestarts <- base::computeRestarts
[17:39:27.885]                           grepl <- base::grepl
[17:39:27.885]                           restarts <- computeRestarts(cond)
[17:39:27.885]                           for (restart in restarts) {
[17:39:27.885]                             name <- restart$name
[17:39:27.885]                             if (is.null(name)) 
[17:39:27.885]                               next
[17:39:27.885]                             if (!grepl(pattern, name)) 
[17:39:27.885]                               next
[17:39:27.885]                             invokeRestart(restart)
[17:39:27.885]                             muffled <- TRUE
[17:39:27.885]                             break
[17:39:27.885]                           }
[17:39:27.885]                         }
[17:39:27.885]                       }
[17:39:27.885]                       invisible(muffled)
[17:39:27.885]                     }
[17:39:27.885]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.885]                   }
[17:39:27.885]                 }
[17:39:27.885]                 else {
[17:39:27.885]                   if (TRUE) {
[17:39:27.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:27.885]                     {
[17:39:27.885]                       inherits <- base::inherits
[17:39:27.885]                       invokeRestart <- base::invokeRestart
[17:39:27.885]                       is.null <- base::is.null
[17:39:27.885]                       muffled <- FALSE
[17:39:27.885]                       if (inherits(cond, "message")) {
[17:39:27.885]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:27.885]                         if (muffled) 
[17:39:27.885]                           invokeRestart("muffleMessage")
[17:39:27.885]                       }
[17:39:27.885]                       else if (inherits(cond, "warning")) {
[17:39:27.885]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:27.885]                         if (muffled) 
[17:39:27.885]                           invokeRestart("muffleWarning")
[17:39:27.885]                       }
[17:39:27.885]                       else if (inherits(cond, "condition")) {
[17:39:27.885]                         if (!is.null(pattern)) {
[17:39:27.885]                           computeRestarts <- base::computeRestarts
[17:39:27.885]                           grepl <- base::grepl
[17:39:27.885]                           restarts <- computeRestarts(cond)
[17:39:27.885]                           for (restart in restarts) {
[17:39:27.885]                             name <- restart$name
[17:39:27.885]                             if (is.null(name)) 
[17:39:27.885]                               next
[17:39:27.885]                             if (!grepl(pattern, name)) 
[17:39:27.885]                               next
[17:39:27.885]                             invokeRestart(restart)
[17:39:27.885]                             muffled <- TRUE
[17:39:27.885]                             break
[17:39:27.885]                           }
[17:39:27.885]                         }
[17:39:27.885]                       }
[17:39:27.885]                       invisible(muffled)
[17:39:27.885]                     }
[17:39:27.885]                     muffleCondition(cond, pattern = "^muffle")
[17:39:27.885]                   }
[17:39:27.885]                 }
[17:39:27.885]             }
[17:39:27.885]         }))
[17:39:27.885]     }, error = function(ex) {
[17:39:27.885]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:27.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:27.885]                 ...future.rng), started = ...future.startTime, 
[17:39:27.885]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:27.885]             version = "1.8"), class = "FutureResult")
[17:39:27.885]     }, finally = {
[17:39:27.885]         if (!identical(...future.workdir, getwd())) 
[17:39:27.885]             setwd(...future.workdir)
[17:39:27.885]         {
[17:39:27.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:27.885]                 ...future.oldOptions$nwarnings <- NULL
[17:39:27.885]             }
[17:39:27.885]             base::options(...future.oldOptions)
[17:39:27.885]             if (.Platform$OS.type == "windows") {
[17:39:27.885]                 old_names <- names(...future.oldEnvVars)
[17:39:27.885]                 envs <- base::Sys.getenv()
[17:39:27.885]                 names <- names(envs)
[17:39:27.885]                 common <- intersect(names, old_names)
[17:39:27.885]                 added <- setdiff(names, old_names)
[17:39:27.885]                 removed <- setdiff(old_names, names)
[17:39:27.885]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:27.885]                   envs[common]]
[17:39:27.885]                 NAMES <- toupper(changed)
[17:39:27.885]                 args <- list()
[17:39:27.885]                 for (kk in seq_along(NAMES)) {
[17:39:27.885]                   name <- changed[[kk]]
[17:39:27.885]                   NAME <- NAMES[[kk]]
[17:39:27.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.885]                     next
[17:39:27.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.885]                 }
[17:39:27.885]                 NAMES <- toupper(added)
[17:39:27.885]                 for (kk in seq_along(NAMES)) {
[17:39:27.885]                   name <- added[[kk]]
[17:39:27.885]                   NAME <- NAMES[[kk]]
[17:39:27.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.885]                     next
[17:39:27.885]                   args[[name]] <- ""
[17:39:27.885]                 }
[17:39:27.885]                 NAMES <- toupper(removed)
[17:39:27.885]                 for (kk in seq_along(NAMES)) {
[17:39:27.885]                   name <- removed[[kk]]
[17:39:27.885]                   NAME <- NAMES[[kk]]
[17:39:27.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:27.885]                     next
[17:39:27.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:27.885]                 }
[17:39:27.885]                 if (length(args) > 0) 
[17:39:27.885]                   base::do.call(base::Sys.setenv, args = args)
[17:39:27.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:27.885]             }
[17:39:27.885]             else {
[17:39:27.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:27.885]             }
[17:39:27.885]             {
[17:39:27.885]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:27.885]                   0L) {
[17:39:27.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:27.885]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:27.885]                   base::options(opts)
[17:39:27.885]                 }
[17:39:27.885]                 {
[17:39:27.885]                   {
[17:39:27.885]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:27.885]                     NULL
[17:39:27.885]                   }
[17:39:27.885]                   options(future.plan = NULL)
[17:39:27.885]                   if (is.na(NA_character_)) 
[17:39:27.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:27.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:27.885]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:27.885]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:27.885]                     envir = parent.frame()) 
[17:39:27.885]                   {
[17:39:27.885]                     if (is.function(workers)) 
[17:39:27.885]                       workers <- workers()
[17:39:27.885]                     workers <- structure(as.integer(workers), 
[17:39:27.885]                       class = class(workers))
[17:39:27.885]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:27.885]                       workers >= 1)
[17:39:27.885]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:27.885]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:27.885]                     }
[17:39:27.885]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:27.885]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:27.885]                       envir = envir)
[17:39:27.885]                     if (!future$lazy) 
[17:39:27.885]                       future <- run(future)
[17:39:27.885]                     invisible(future)
[17:39:27.885]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:27.885]                 }
[17:39:27.885]             }
[17:39:27.885]         }
[17:39:27.885]     })
[17:39:27.885]     if (TRUE) {
[17:39:27.885]         base::sink(type = "output", split = FALSE)
[17:39:27.885]         if (TRUE) {
[17:39:27.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:27.885]         }
[17:39:27.885]         else {
[17:39:27.885]             ...future.result["stdout"] <- base::list(NULL)
[17:39:27.885]         }
[17:39:27.885]         base::close(...future.stdout)
[17:39:27.885]         ...future.stdout <- NULL
[17:39:27.885]     }
[17:39:27.885]     ...future.result$conditions <- ...future.conditions
[17:39:27.885]     ...future.result$finished <- base::Sys.time()
[17:39:27.885]     ...future.result
[17:39:27.885] }
[17:39:27.888] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[17:39:27.888] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[17:39:27.888] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[17:39:27.889] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[17:39:27.889] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[17:39:27.889] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:39:27.890] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:39:27.890] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:27.890] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:27.890] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:27.891] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:27.891] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[17:39:27.891] MultisessionFuture started
[17:39:27.891] - Launch lazy future ... done
[17:39:27.892] run() for ‘MultisessionFuture’ ... done
[17:39:27.892] Created future:
[17:39:27.892] MultisessionFuture:
[17:39:27.892] Label: ‘future_by-2’
[17:39:27.892] Expression:
[17:39:27.892] {
[17:39:27.892]     do.call(function(...) {
[17:39:27.892]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.892]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.892]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.892]             on.exit(options(oopts), add = TRUE)
[17:39:27.892]         }
[17:39:27.892]         {
[17:39:27.892]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.892]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.892]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.892]             })
[17:39:27.892]         }
[17:39:27.892]     }, args = future.call.arguments)
[17:39:27.892] }
[17:39:27.892] Lazy evaluation: FALSE
[17:39:27.892] Asynchronous evaluation: TRUE
[17:39:27.892] Local evaluation: TRUE
[17:39:27.892] Environment: R_GlobalEnv
[17:39:27.892] Capture standard output: TRUE
[17:39:27.892] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:27.892] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:27.892] Packages: 1 packages (‘stats’)
[17:39:27.892] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:27.892] Resolved: FALSE
[17:39:27.892] Value: <not collected>
[17:39:27.892] Conditions captured: <none>
[17:39:27.892] Early signaling: FALSE
[17:39:27.892] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:27.892] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.903] Chunk #2 of 2 ... DONE
[17:39:27.904] Launching 2 futures (chunks) ... DONE
[17:39:27.904] Resolving 2 futures (chunks) ...
[17:39:27.904] resolve() on list ...
[17:39:27.904]  recursive: 0
[17:39:27.904]  length: 2
[17:39:27.904] 
[17:39:27.905] receiveMessageFromWorker() for ClusterFuture ...
[17:39:27.905] - Validating connection of MultisessionFuture
[17:39:27.905] - received message: FutureResult
[17:39:27.905] - Received FutureResult
[17:39:27.905] - Erased future from FutureRegistry
[17:39:27.905] result() for ClusterFuture ...
[17:39:27.905] - result already collected: FutureResult
[17:39:27.905] result() for ClusterFuture ... done
[17:39:27.905] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:27.906] Future #1
[17:39:27.906] result() for ClusterFuture ...
[17:39:27.906] - result already collected: FutureResult
[17:39:27.906] result() for ClusterFuture ... done
[17:39:27.906] result() for ClusterFuture ...
[17:39:27.906] - result already collected: FutureResult
[17:39:27.906] result() for ClusterFuture ... done
[17:39:27.906] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:27.906] - nx: 2
[17:39:27.906] - relay: TRUE
[17:39:27.906] - stdout: TRUE
[17:39:27.907] - signal: TRUE
[17:39:27.907] - resignal: FALSE
[17:39:27.907] - force: TRUE
[17:39:27.907] - relayed: [n=2] FALSE, FALSE
[17:39:27.907] - queued futures: [n=2] FALSE, FALSE
[17:39:27.907]  - until=1
[17:39:27.907]  - relaying element #1
[17:39:27.907] result() for ClusterFuture ...
[17:39:27.907] - result already collected: FutureResult
[17:39:27.907] result() for ClusterFuture ... done
[17:39:27.907] result() for ClusterFuture ...
[17:39:27.908] - result already collected: FutureResult
[17:39:27.908] result() for ClusterFuture ... done
[17:39:27.908] result() for ClusterFuture ...
[17:39:27.908] - result already collected: FutureResult
[17:39:27.908] result() for ClusterFuture ... done
[17:39:27.908] result() for ClusterFuture ...
[17:39:27.908] - result already collected: FutureResult
[17:39:27.908] result() for ClusterFuture ... done
[17:39:27.908] - relayed: [n=2] TRUE, FALSE
[17:39:27.908] - queued futures: [n=2] TRUE, FALSE
[17:39:27.908] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:27.909]  length: 1 (resolved future 1)
[17:39:27.950] receiveMessageFromWorker() for ClusterFuture ...
[17:39:27.950] - Validating connection of MultisessionFuture
[17:39:27.951] - received message: FutureResult
[17:39:27.951] - Received FutureResult
[17:39:27.951] - Erased future from FutureRegistry
[17:39:27.951] result() for ClusterFuture ...
[17:39:27.951] - result already collected: FutureResult
[17:39:27.951] result() for ClusterFuture ... done
[17:39:27.951] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:27.951] Future #2
[17:39:27.952] result() for ClusterFuture ...
[17:39:27.952] - result already collected: FutureResult
[17:39:27.952] result() for ClusterFuture ... done
[17:39:27.952] result() for ClusterFuture ...
[17:39:27.952] - result already collected: FutureResult
[17:39:27.952] result() for ClusterFuture ... done
[17:39:27.952] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:27.952] - nx: 2
[17:39:27.952] - relay: TRUE
[17:39:27.952] - stdout: TRUE
[17:39:27.952] - signal: TRUE
[17:39:27.952] - resignal: FALSE
[17:39:27.953] - force: TRUE
[17:39:27.953] - relayed: [n=2] TRUE, FALSE
[17:39:27.953] - queued futures: [n=2] TRUE, FALSE
[17:39:27.953]  - until=2
[17:39:27.953]  - relaying element #2
[17:39:27.953] result() for ClusterFuture ...
[17:39:27.953] - result already collected: FutureResult
[17:39:27.953] result() for ClusterFuture ... done
[17:39:27.953] result() for ClusterFuture ...
[17:39:27.953] - result already collected: FutureResult
[17:39:27.953] result() for ClusterFuture ... done
[17:39:27.954] result() for ClusterFuture ...
[17:39:27.954] - result already collected: FutureResult
[17:39:27.954] result() for ClusterFuture ... done
[17:39:27.954] result() for ClusterFuture ...
[17:39:27.954] - result already collected: FutureResult
[17:39:27.954] result() for ClusterFuture ... done
[17:39:27.954] - relayed: [n=2] TRUE, TRUE
[17:39:27.954] - queued futures: [n=2] TRUE, TRUE
[17:39:27.954] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:27.954]  length: 0 (resolved future 2)
[17:39:27.954] Relaying remaining futures
[17:39:27.955] signalConditionsASAP(NULL, pos=0) ...
[17:39:27.955] - nx: 2
[17:39:27.955] - relay: TRUE
[17:39:27.955] - stdout: TRUE
[17:39:27.955] - signal: TRUE
[17:39:27.955] - resignal: FALSE
[17:39:27.955] - force: TRUE
[17:39:27.955] - relayed: [n=2] TRUE, TRUE
[17:39:27.955] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:27.955] - relayed: [n=2] TRUE, TRUE
[17:39:27.955] - queued futures: [n=2] TRUE, TRUE
[17:39:27.956] signalConditionsASAP(NULL, pos=0) ... done
[17:39:27.956] resolve() on list ... DONE
[17:39:27.956] result() for ClusterFuture ...
[17:39:27.956] - result already collected: FutureResult
[17:39:27.956] result() for ClusterFuture ... done
[17:39:27.956] result() for ClusterFuture ...
[17:39:27.956] - result already collected: FutureResult
[17:39:27.956] result() for ClusterFuture ... done
[17:39:27.956] result() for ClusterFuture ...
[17:39:27.956] - result already collected: FutureResult
[17:39:27.956] result() for ClusterFuture ... done
[17:39:27.957] result() for ClusterFuture ...
[17:39:27.957] - result already collected: FutureResult
[17:39:27.957] result() for ClusterFuture ... done
[17:39:27.957]  - Number of value chunks collected: 2
[17:39:27.957] Resolving 2 futures (chunks) ... DONE
[17:39:27.957] Reducing values from 2 chunks ...
[17:39:27.957]  - Number of values collected after concatenation: 3
[17:39:27.957]  - Number of values expected: 3
[17:39:27.957] Reducing values from 2 chunks ... DONE
[17:39:27.957] future_lapply() ... DONE
[17:39:27.957] future_by_internal() ... DONE
[17:39:27.961] future_by_internal() ...
[17:39:27.962] future_lapply() ...
[17:39:27.966] Number of chunks: 2
[17:39:27.966] getGlobalsAndPackagesXApply() ...
[17:39:27.967]  - future.globals: TRUE
[17:39:27.967] getGlobalsAndPackages() ...
[17:39:27.967] Searching for globals...
[17:39:27.969] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:39:27.969] Searching for globals ... DONE
[17:39:27.969] Resolving globals: FALSE
[17:39:27.970] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:39:27.970] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:39:27.970] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:27.970] - packages: [1] ‘stats’
[17:39:27.970] getGlobalsAndPackages() ... DONE
[17:39:27.970]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:39:27.971]  - needed namespaces: [n=1] ‘stats’
[17:39:27.971] Finding globals ... DONE
[17:39:27.971]  - use_args: TRUE
[17:39:27.971]  - Getting '...' globals ...
[17:39:27.971] resolve() on list ...
[17:39:27.971]  recursive: 0
[17:39:27.971]  length: 1
[17:39:27.971]  elements: ‘...’
[17:39:27.972]  length: 0 (resolved future 1)
[17:39:27.972] resolve() on list ... DONE
[17:39:27.972]    - '...' content: [n=0] 
[17:39:27.972] List of 1
[17:39:27.972]  $ ...: list()
[17:39:27.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:27.972]  - attr(*, "where")=List of 1
[17:39:27.972]   ..$ ...:<environment: 0x562971a16708> 
[17:39:27.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:27.972]  - attr(*, "resolved")= logi TRUE
[17:39:27.972]  - attr(*, "total_size")= num NA
[17:39:27.974]  - Getting '...' globals ... DONE
[17:39:27.975] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:39:27.975] List of 4
[17:39:27.975]  $ ...future.FUN:function (x)  
[17:39:27.975]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:39:27.975]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:39:27.975]  $ ...          : list()
[17:39:27.975]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:27.975]  - attr(*, "where")=List of 4
[17:39:27.975]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:27.975]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:39:27.975]   ..$ wool         :<environment: R_EmptyEnv> 
[17:39:27.975]   ..$ ...          :<environment: 0x562971a16708> 
[17:39:27.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:27.975]  - attr(*, "resolved")= logi FALSE
[17:39:27.975]  - attr(*, "total_size")= num 2320
[17:39:27.978] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:27.978] getGlobalsAndPackagesXApply() ... DONE
[17:39:27.979] Number of futures (= number of chunks): 2
[17:39:27.979] Launching 2 futures (chunks) ...
[17:39:27.979] Chunk #1 of 2 ...
[17:39:27.979]  - Finding globals in 'X' for chunk #1 ...
[17:39:27.979] getGlobalsAndPackages() ...
[17:39:27.979] Searching for globals...
[17:39:27.980] 
[17:39:27.980] Searching for globals ... DONE
[17:39:27.980] - globals: [0] <none>
[17:39:27.980] getGlobalsAndPackages() ... DONE
[17:39:27.980]    + additional globals found: [n=0] 
[17:39:27.980]    + additional namespaces needed: [n=0] 
[17:39:27.980]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:27.980]  - seeds: <none>
[17:39:27.980] getGlobalsAndPackages() ...
[17:39:27.980] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.981] Resolving globals: FALSE
[17:39:27.981] Tweak future expression to call with '...' arguments ...
[17:39:27.981] {
[17:39:27.981]     do.call(function(...) {
[17:39:27.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:27.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:27.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:27.981]             on.exit(options(oopts), add = TRUE)
[17:39:27.981]         }
[17:39:27.981]         {
[17:39:27.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:27.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:27.981]                 ...future.FUN(...future.X_jj, ...)
[17:39:27.981]             })
[17:39:27.981]         }
[17:39:27.981]     }, args = future.call.arguments)
[17:39:27.981] }
[17:39:27.981] Tweak future expression to call with '...' arguments ... DONE
[17:39:27.981] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:27.982] 
[17:39:27.982] getGlobalsAndPackages() ... DONE
[17:39:27.982] run() for ‘Future’ ...
[17:39:27.982] - state: ‘created’
[17:39:27.982] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:27.997] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:27.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:27.997]   - Field: ‘node’
[17:39:27.997]   - Field: ‘label’
[17:39:27.997]   - Field: ‘local’
[17:39:27.997]   - Field: ‘owner’
[17:39:27.998]   - Field: ‘envir’
[17:39:27.998]   - Field: ‘workers’
[17:39:27.998]   - Field: ‘packages’
[17:39:27.998]   - Field: ‘gc’
[17:39:27.998]   - Field: ‘conditions’
[17:39:27.998]   - Field: ‘persistent’
[17:39:27.998]   - Field: ‘expr’
[17:39:27.998]   - Field: ‘uuid’
[17:39:27.998]   - Field: ‘seed’
[17:39:27.998]   - Field: ‘version’
[17:39:27.999]   - Field: ‘result’
[17:39:27.999]   - Field: ‘asynchronous’
[17:39:27.999]   - Field: ‘calls’
[17:39:27.999]   - Field: ‘globals’
[17:39:27.999]   - Field: ‘stdout’
[17:39:27.999]   - Field: ‘earlySignal’
[17:39:27.999]   - Field: ‘lazy’
[17:39:27.999]   - Field: ‘state’
[17:39:27.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:27.999] - Launch lazy future ...
[17:39:28.000] Packages needed by the future expression (n = 1): ‘stats’
[17:39:28.000] Packages needed by future strategies (n = 0): <none>
[17:39:28.003] {
[17:39:28.003]     {
[17:39:28.003]         {
[17:39:28.003]             ...future.startTime <- base::Sys.time()
[17:39:28.003]             {
[17:39:28.003]                 {
[17:39:28.003]                   {
[17:39:28.003]                     {
[17:39:28.003]                       {
[17:39:28.003]                         base::local({
[17:39:28.003]                           has_future <- base::requireNamespace("future", 
[17:39:28.003]                             quietly = TRUE)
[17:39:28.003]                           if (has_future) {
[17:39:28.003]                             ns <- base::getNamespace("future")
[17:39:28.003]                             version <- ns[[".package"]][["version"]]
[17:39:28.003]                             if (is.null(version)) 
[17:39:28.003]                               version <- utils::packageVersion("future")
[17:39:28.003]                           }
[17:39:28.003]                           else {
[17:39:28.003]                             version <- NULL
[17:39:28.003]                           }
[17:39:28.003]                           if (!has_future || version < "1.8.0") {
[17:39:28.003]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.003]                               "", base::R.version$version.string), 
[17:39:28.003]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:28.003]                                 base::R.version$platform, 8 * 
[17:39:28.003]                                   base::.Machine$sizeof.pointer), 
[17:39:28.003]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.003]                                 "release", "version")], collapse = " "), 
[17:39:28.003]                               hostname = base::Sys.info()[["nodename"]])
[17:39:28.003]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.003]                               info)
[17:39:28.003]                             info <- base::paste(info, collapse = "; ")
[17:39:28.003]                             if (!has_future) {
[17:39:28.003]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.003]                                 info)
[17:39:28.003]                             }
[17:39:28.003]                             else {
[17:39:28.003]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.003]                                 info, version)
[17:39:28.003]                             }
[17:39:28.003]                             base::stop(msg)
[17:39:28.003]                           }
[17:39:28.003]                         })
[17:39:28.003]                       }
[17:39:28.003]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:28.003]                       base::options(mc.cores = 1L)
[17:39:28.003]                     }
[17:39:28.003]                     base::local({
[17:39:28.003]                       for (pkg in "stats") {
[17:39:28.003]                         base::loadNamespace(pkg)
[17:39:28.003]                         base::library(pkg, character.only = TRUE)
[17:39:28.003]                       }
[17:39:28.003]                     })
[17:39:28.003]                   }
[17:39:28.003]                   options(future.plan = NULL)
[17:39:28.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.003]                 }
[17:39:28.003]                 ...future.workdir <- getwd()
[17:39:28.003]             }
[17:39:28.003]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.003]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.003]         }
[17:39:28.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.003]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:28.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.003]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.003]             base::names(...future.oldOptions))
[17:39:28.003]     }
[17:39:28.003]     if (FALSE) {
[17:39:28.003]     }
[17:39:28.003]     else {
[17:39:28.003]         if (TRUE) {
[17:39:28.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.003]                 open = "w")
[17:39:28.003]         }
[17:39:28.003]         else {
[17:39:28.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.003]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.003]         }
[17:39:28.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.003]             base::sink(type = "output", split = FALSE)
[17:39:28.003]             base::close(...future.stdout)
[17:39:28.003]         }, add = TRUE)
[17:39:28.003]     }
[17:39:28.003]     ...future.frame <- base::sys.nframe()
[17:39:28.003]     ...future.conditions <- base::list()
[17:39:28.003]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.003]     if (FALSE) {
[17:39:28.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.003]     }
[17:39:28.003]     ...future.result <- base::tryCatch({
[17:39:28.003]         base::withCallingHandlers({
[17:39:28.003]             ...future.value <- base::withVisible(base::local({
[17:39:28.003]                 ...future.makeSendCondition <- local({
[17:39:28.003]                   sendCondition <- NULL
[17:39:28.003]                   function(frame = 1L) {
[17:39:28.003]                     if (is.function(sendCondition)) 
[17:39:28.003]                       return(sendCondition)
[17:39:28.003]                     ns <- getNamespace("parallel")
[17:39:28.003]                     if (exists("sendData", mode = "function", 
[17:39:28.003]                       envir = ns)) {
[17:39:28.003]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:28.003]                         envir = ns)
[17:39:28.003]                       envir <- sys.frame(frame)
[17:39:28.003]                       master <- NULL
[17:39:28.003]                       while (!identical(envir, .GlobalEnv) && 
[17:39:28.003]                         !identical(envir, emptyenv())) {
[17:39:28.003]                         if (exists("master", mode = "list", envir = envir, 
[17:39:28.003]                           inherits = FALSE)) {
[17:39:28.003]                           master <- get("master", mode = "list", 
[17:39:28.003]                             envir = envir, inherits = FALSE)
[17:39:28.003]                           if (inherits(master, c("SOCKnode", 
[17:39:28.003]                             "SOCK0node"))) {
[17:39:28.003]                             sendCondition <<- function(cond) {
[17:39:28.003]                               data <- list(type = "VALUE", value = cond, 
[17:39:28.003]                                 success = TRUE)
[17:39:28.003]                               parallel_sendData(master, data)
[17:39:28.003]                             }
[17:39:28.003]                             return(sendCondition)
[17:39:28.003]                           }
[17:39:28.003]                         }
[17:39:28.003]                         frame <- frame + 1L
[17:39:28.003]                         envir <- sys.frame(frame)
[17:39:28.003]                       }
[17:39:28.003]                     }
[17:39:28.003]                     sendCondition <<- function(cond) NULL
[17:39:28.003]                   }
[17:39:28.003]                 })
[17:39:28.003]                 withCallingHandlers({
[17:39:28.003]                   {
[17:39:28.003]                     do.call(function(...) {
[17:39:28.003]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.003]                       if (!identical(...future.globals.maxSize.org, 
[17:39:28.003]                         ...future.globals.maxSize)) {
[17:39:28.003]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.003]                         on.exit(options(oopts), add = TRUE)
[17:39:28.003]                       }
[17:39:28.003]                       {
[17:39:28.003]                         lapply(seq_along(...future.elements_ii), 
[17:39:28.003]                           FUN = function(jj) {
[17:39:28.003]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.003]                             ...future.FUN(...future.X_jj, ...)
[17:39:28.003]                           })
[17:39:28.003]                       }
[17:39:28.003]                     }, args = future.call.arguments)
[17:39:28.003]                   }
[17:39:28.003]                 }, immediateCondition = function(cond) {
[17:39:28.003]                   sendCondition <- ...future.makeSendCondition()
[17:39:28.003]                   sendCondition(cond)
[17:39:28.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.003]                   {
[17:39:28.003]                     inherits <- base::inherits
[17:39:28.003]                     invokeRestart <- base::invokeRestart
[17:39:28.003]                     is.null <- base::is.null
[17:39:28.003]                     muffled <- FALSE
[17:39:28.003]                     if (inherits(cond, "message")) {
[17:39:28.003]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:28.003]                       if (muffled) 
[17:39:28.003]                         invokeRestart("muffleMessage")
[17:39:28.003]                     }
[17:39:28.003]                     else if (inherits(cond, "warning")) {
[17:39:28.003]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:28.003]                       if (muffled) 
[17:39:28.003]                         invokeRestart("muffleWarning")
[17:39:28.003]                     }
[17:39:28.003]                     else if (inherits(cond, "condition")) {
[17:39:28.003]                       if (!is.null(pattern)) {
[17:39:28.003]                         computeRestarts <- base::computeRestarts
[17:39:28.003]                         grepl <- base::grepl
[17:39:28.003]                         restarts <- computeRestarts(cond)
[17:39:28.003]                         for (restart in restarts) {
[17:39:28.003]                           name <- restart$name
[17:39:28.003]                           if (is.null(name)) 
[17:39:28.003]                             next
[17:39:28.003]                           if (!grepl(pattern, name)) 
[17:39:28.003]                             next
[17:39:28.003]                           invokeRestart(restart)
[17:39:28.003]                           muffled <- TRUE
[17:39:28.003]                           break
[17:39:28.003]                         }
[17:39:28.003]                       }
[17:39:28.003]                     }
[17:39:28.003]                     invisible(muffled)
[17:39:28.003]                   }
[17:39:28.003]                   muffleCondition(cond)
[17:39:28.003]                 })
[17:39:28.003]             }))
[17:39:28.003]             future::FutureResult(value = ...future.value$value, 
[17:39:28.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.003]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.003]                     ...future.globalenv.names))
[17:39:28.003]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.003]         }, condition = base::local({
[17:39:28.003]             c <- base::c
[17:39:28.003]             inherits <- base::inherits
[17:39:28.003]             invokeRestart <- base::invokeRestart
[17:39:28.003]             length <- base::length
[17:39:28.003]             list <- base::list
[17:39:28.003]             seq.int <- base::seq.int
[17:39:28.003]             signalCondition <- base::signalCondition
[17:39:28.003]             sys.calls <- base::sys.calls
[17:39:28.003]             `[[` <- base::`[[`
[17:39:28.003]             `+` <- base::`+`
[17:39:28.003]             `<<-` <- base::`<<-`
[17:39:28.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.003]                   3L)]
[17:39:28.003]             }
[17:39:28.003]             function(cond) {
[17:39:28.003]                 is_error <- inherits(cond, "error")
[17:39:28.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.003]                   NULL)
[17:39:28.003]                 if (is_error) {
[17:39:28.003]                   sessionInformation <- function() {
[17:39:28.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.003]                       search = base::search(), system = base::Sys.info())
[17:39:28.003]                   }
[17:39:28.003]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.003]                     cond$call), session = sessionInformation(), 
[17:39:28.003]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.003]                   signalCondition(cond)
[17:39:28.003]                 }
[17:39:28.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.003]                 "immediateCondition"))) {
[17:39:28.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.003]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.003]                   if (TRUE && !signal) {
[17:39:28.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.003]                     {
[17:39:28.003]                       inherits <- base::inherits
[17:39:28.003]                       invokeRestart <- base::invokeRestart
[17:39:28.003]                       is.null <- base::is.null
[17:39:28.003]                       muffled <- FALSE
[17:39:28.003]                       if (inherits(cond, "message")) {
[17:39:28.003]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.003]                         if (muffled) 
[17:39:28.003]                           invokeRestart("muffleMessage")
[17:39:28.003]                       }
[17:39:28.003]                       else if (inherits(cond, "warning")) {
[17:39:28.003]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.003]                         if (muffled) 
[17:39:28.003]                           invokeRestart("muffleWarning")
[17:39:28.003]                       }
[17:39:28.003]                       else if (inherits(cond, "condition")) {
[17:39:28.003]                         if (!is.null(pattern)) {
[17:39:28.003]                           computeRestarts <- base::computeRestarts
[17:39:28.003]                           grepl <- base::grepl
[17:39:28.003]                           restarts <- computeRestarts(cond)
[17:39:28.003]                           for (restart in restarts) {
[17:39:28.003]                             name <- restart$name
[17:39:28.003]                             if (is.null(name)) 
[17:39:28.003]                               next
[17:39:28.003]                             if (!grepl(pattern, name)) 
[17:39:28.003]                               next
[17:39:28.003]                             invokeRestart(restart)
[17:39:28.003]                             muffled <- TRUE
[17:39:28.003]                             break
[17:39:28.003]                           }
[17:39:28.003]                         }
[17:39:28.003]                       }
[17:39:28.003]                       invisible(muffled)
[17:39:28.003]                     }
[17:39:28.003]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.003]                   }
[17:39:28.003]                 }
[17:39:28.003]                 else {
[17:39:28.003]                   if (TRUE) {
[17:39:28.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.003]                     {
[17:39:28.003]                       inherits <- base::inherits
[17:39:28.003]                       invokeRestart <- base::invokeRestart
[17:39:28.003]                       is.null <- base::is.null
[17:39:28.003]                       muffled <- FALSE
[17:39:28.003]                       if (inherits(cond, "message")) {
[17:39:28.003]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.003]                         if (muffled) 
[17:39:28.003]                           invokeRestart("muffleMessage")
[17:39:28.003]                       }
[17:39:28.003]                       else if (inherits(cond, "warning")) {
[17:39:28.003]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.003]                         if (muffled) 
[17:39:28.003]                           invokeRestart("muffleWarning")
[17:39:28.003]                       }
[17:39:28.003]                       else if (inherits(cond, "condition")) {
[17:39:28.003]                         if (!is.null(pattern)) {
[17:39:28.003]                           computeRestarts <- base::computeRestarts
[17:39:28.003]                           grepl <- base::grepl
[17:39:28.003]                           restarts <- computeRestarts(cond)
[17:39:28.003]                           for (restart in restarts) {
[17:39:28.003]                             name <- restart$name
[17:39:28.003]                             if (is.null(name)) 
[17:39:28.003]                               next
[17:39:28.003]                             if (!grepl(pattern, name)) 
[17:39:28.003]                               next
[17:39:28.003]                             invokeRestart(restart)
[17:39:28.003]                             muffled <- TRUE
[17:39:28.003]                             break
[17:39:28.003]                           }
[17:39:28.003]                         }
[17:39:28.003]                       }
[17:39:28.003]                       invisible(muffled)
[17:39:28.003]                     }
[17:39:28.003]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.003]                   }
[17:39:28.003]                 }
[17:39:28.003]             }
[17:39:28.003]         }))
[17:39:28.003]     }, error = function(ex) {
[17:39:28.003]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.003]                 ...future.rng), started = ...future.startTime, 
[17:39:28.003]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.003]             version = "1.8"), class = "FutureResult")
[17:39:28.003]     }, finally = {
[17:39:28.003]         if (!identical(...future.workdir, getwd())) 
[17:39:28.003]             setwd(...future.workdir)
[17:39:28.003]         {
[17:39:28.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.003]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.003]             }
[17:39:28.003]             base::options(...future.oldOptions)
[17:39:28.003]             if (.Platform$OS.type == "windows") {
[17:39:28.003]                 old_names <- names(...future.oldEnvVars)
[17:39:28.003]                 envs <- base::Sys.getenv()
[17:39:28.003]                 names <- names(envs)
[17:39:28.003]                 common <- intersect(names, old_names)
[17:39:28.003]                 added <- setdiff(names, old_names)
[17:39:28.003]                 removed <- setdiff(old_names, names)
[17:39:28.003]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.003]                   envs[common]]
[17:39:28.003]                 NAMES <- toupper(changed)
[17:39:28.003]                 args <- list()
[17:39:28.003]                 for (kk in seq_along(NAMES)) {
[17:39:28.003]                   name <- changed[[kk]]
[17:39:28.003]                   NAME <- NAMES[[kk]]
[17:39:28.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.003]                     next
[17:39:28.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.003]                 }
[17:39:28.003]                 NAMES <- toupper(added)
[17:39:28.003]                 for (kk in seq_along(NAMES)) {
[17:39:28.003]                   name <- added[[kk]]
[17:39:28.003]                   NAME <- NAMES[[kk]]
[17:39:28.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.003]                     next
[17:39:28.003]                   args[[name]] <- ""
[17:39:28.003]                 }
[17:39:28.003]                 NAMES <- toupper(removed)
[17:39:28.003]                 for (kk in seq_along(NAMES)) {
[17:39:28.003]                   name <- removed[[kk]]
[17:39:28.003]                   NAME <- NAMES[[kk]]
[17:39:28.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.003]                     next
[17:39:28.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.003]                 }
[17:39:28.003]                 if (length(args) > 0) 
[17:39:28.003]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.003]             }
[17:39:28.003]             else {
[17:39:28.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.003]             }
[17:39:28.003]             {
[17:39:28.003]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.003]                   0L) {
[17:39:28.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.003]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.003]                   base::options(opts)
[17:39:28.003]                 }
[17:39:28.003]                 {
[17:39:28.003]                   {
[17:39:28.003]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:28.003]                     NULL
[17:39:28.003]                   }
[17:39:28.003]                   options(future.plan = NULL)
[17:39:28.003]                   if (is.na(NA_character_)) 
[17:39:28.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.003]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:28.003]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:28.003]                     envir = parent.frame()) 
[17:39:28.003]                   {
[17:39:28.003]                     if (is.function(workers)) 
[17:39:28.003]                       workers <- workers()
[17:39:28.003]                     workers <- structure(as.integer(workers), 
[17:39:28.003]                       class = class(workers))
[17:39:28.003]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:28.003]                       workers >= 1)
[17:39:28.003]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:28.003]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:28.003]                     }
[17:39:28.003]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:28.003]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:28.003]                       envir = envir)
[17:39:28.003]                     if (!future$lazy) 
[17:39:28.003]                       future <- run(future)
[17:39:28.003]                     invisible(future)
[17:39:28.003]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.003]                 }
[17:39:28.003]             }
[17:39:28.003]         }
[17:39:28.003]     })
[17:39:28.003]     if (TRUE) {
[17:39:28.003]         base::sink(type = "output", split = FALSE)
[17:39:28.003]         if (TRUE) {
[17:39:28.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.003]         }
[17:39:28.003]         else {
[17:39:28.003]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.003]         }
[17:39:28.003]         base::close(...future.stdout)
[17:39:28.003]         ...future.stdout <- NULL
[17:39:28.003]     }
[17:39:28.003]     ...future.result$conditions <- ...future.conditions
[17:39:28.003]     ...future.result$finished <- base::Sys.time()
[17:39:28.003]     ...future.result
[17:39:28.003] }
[17:39:28.005] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[17:39:28.006] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[17:39:28.006] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[17:39:28.006] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[17:39:28.007] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[17:39:28.007] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[17:39:28.007] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[17:39:28.008] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:28.008] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:28.008] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:39:28.009] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:39:28.009] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:28.009] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:28.009] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:28.009] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:28.010] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[17:39:28.010] MultisessionFuture started
[17:39:28.010] - Launch lazy future ... done
[17:39:28.010] run() for ‘MultisessionFuture’ ... done
[17:39:28.010] Created future:
[17:39:28.010] MultisessionFuture:
[17:39:28.010] Label: ‘future_by-1’
[17:39:28.010] Expression:
[17:39:28.010] {
[17:39:28.010]     do.call(function(...) {
[17:39:28.010]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.010]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.010]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.010]             on.exit(options(oopts), add = TRUE)
[17:39:28.010]         }
[17:39:28.010]         {
[17:39:28.010]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.010]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.010]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.010]             })
[17:39:28.010]         }
[17:39:28.010]     }, args = future.call.arguments)
[17:39:28.010] }
[17:39:28.010] Lazy evaluation: FALSE
[17:39:28.010] Asynchronous evaluation: TRUE
[17:39:28.010] Local evaluation: TRUE
[17:39:28.010] Environment: 0x562971665188
[17:39:28.010] Capture standard output: TRUE
[17:39:28.010] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.010] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[17:39:28.010] Packages: 1 packages (‘stats’)
[17:39:28.010] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.010] Resolved: FALSE
[17:39:28.010] Value: <not collected>
[17:39:28.010] Conditions captured: <none>
[17:39:28.010] Early signaling: FALSE
[17:39:28.010] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:28.010] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.022] Chunk #1 of 2 ... DONE
[17:39:28.022] Chunk #2 of 2 ...
[17:39:28.022]  - Finding globals in 'X' for chunk #2 ...
[17:39:28.023] getGlobalsAndPackages() ...
[17:39:28.023] Searching for globals...
[17:39:28.023] 
[17:39:28.023] Searching for globals ... DONE
[17:39:28.023] - globals: [0] <none>
[17:39:28.023] getGlobalsAndPackages() ... DONE
[17:39:28.023]    + additional globals found: [n=0] 
[17:39:28.024]    + additional namespaces needed: [n=0] 
[17:39:28.024]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:28.024]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:28.024]  - seeds: <none>
[17:39:28.024] getGlobalsAndPackages() ...
[17:39:28.024] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.024] Resolving globals: FALSE
[17:39:28.024] Tweak future expression to call with '...' arguments ...
[17:39:28.024] {
[17:39:28.024]     do.call(function(...) {
[17:39:28.024]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.024]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.024]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.024]             on.exit(options(oopts), add = TRUE)
[17:39:28.024]         }
[17:39:28.024]         {
[17:39:28.024]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.024]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.024]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.024]             })
[17:39:28.024]         }
[17:39:28.024]     }, args = future.call.arguments)
[17:39:28.024] }
[17:39:28.025] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.025] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.025] 
[17:39:28.025] getGlobalsAndPackages() ... DONE
[17:39:28.026] run() for ‘Future’ ...
[17:39:28.026] - state: ‘created’
[17:39:28.026] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:28.040] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.040] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:28.040]   - Field: ‘node’
[17:39:28.040]   - Field: ‘label’
[17:39:28.041]   - Field: ‘local’
[17:39:28.041]   - Field: ‘owner’
[17:39:28.041]   - Field: ‘envir’
[17:39:28.041]   - Field: ‘workers’
[17:39:28.041]   - Field: ‘packages’
[17:39:28.041]   - Field: ‘gc’
[17:39:28.041]   - Field: ‘conditions’
[17:39:28.041]   - Field: ‘persistent’
[17:39:28.041]   - Field: ‘expr’
[17:39:28.041]   - Field: ‘uuid’
[17:39:28.041]   - Field: ‘seed’
[17:39:28.042]   - Field: ‘version’
[17:39:28.042]   - Field: ‘result’
[17:39:28.042]   - Field: ‘asynchronous’
[17:39:28.042]   - Field: ‘calls’
[17:39:28.042]   - Field: ‘globals’
[17:39:28.042]   - Field: ‘stdout’
[17:39:28.042]   - Field: ‘earlySignal’
[17:39:28.042]   - Field: ‘lazy’
[17:39:28.042]   - Field: ‘state’
[17:39:28.042] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:28.042] - Launch lazy future ...
[17:39:28.043] Packages needed by the future expression (n = 1): ‘stats’
[17:39:28.043] Packages needed by future strategies (n = 0): <none>
[17:39:28.043] {
[17:39:28.043]     {
[17:39:28.043]         {
[17:39:28.043]             ...future.startTime <- base::Sys.time()
[17:39:28.043]             {
[17:39:28.043]                 {
[17:39:28.043]                   {
[17:39:28.043]                     {
[17:39:28.043]                       {
[17:39:28.043]                         base::local({
[17:39:28.043]                           has_future <- base::requireNamespace("future", 
[17:39:28.043]                             quietly = TRUE)
[17:39:28.043]                           if (has_future) {
[17:39:28.043]                             ns <- base::getNamespace("future")
[17:39:28.043]                             version <- ns[[".package"]][["version"]]
[17:39:28.043]                             if (is.null(version)) 
[17:39:28.043]                               version <- utils::packageVersion("future")
[17:39:28.043]                           }
[17:39:28.043]                           else {
[17:39:28.043]                             version <- NULL
[17:39:28.043]                           }
[17:39:28.043]                           if (!has_future || version < "1.8.0") {
[17:39:28.043]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.043]                               "", base::R.version$version.string), 
[17:39:28.043]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:28.043]                                 base::R.version$platform, 8 * 
[17:39:28.043]                                   base::.Machine$sizeof.pointer), 
[17:39:28.043]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.043]                                 "release", "version")], collapse = " "), 
[17:39:28.043]                               hostname = base::Sys.info()[["nodename"]])
[17:39:28.043]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.043]                               info)
[17:39:28.043]                             info <- base::paste(info, collapse = "; ")
[17:39:28.043]                             if (!has_future) {
[17:39:28.043]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.043]                                 info)
[17:39:28.043]                             }
[17:39:28.043]                             else {
[17:39:28.043]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.043]                                 info, version)
[17:39:28.043]                             }
[17:39:28.043]                             base::stop(msg)
[17:39:28.043]                           }
[17:39:28.043]                         })
[17:39:28.043]                       }
[17:39:28.043]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:28.043]                       base::options(mc.cores = 1L)
[17:39:28.043]                     }
[17:39:28.043]                     base::local({
[17:39:28.043]                       for (pkg in "stats") {
[17:39:28.043]                         base::loadNamespace(pkg)
[17:39:28.043]                         base::library(pkg, character.only = TRUE)
[17:39:28.043]                       }
[17:39:28.043]                     })
[17:39:28.043]                   }
[17:39:28.043]                   options(future.plan = NULL)
[17:39:28.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.043]                 }
[17:39:28.043]                 ...future.workdir <- getwd()
[17:39:28.043]             }
[17:39:28.043]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.043]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.043]         }
[17:39:28.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.043]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:28.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.043]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.043]             base::names(...future.oldOptions))
[17:39:28.043]     }
[17:39:28.043]     if (FALSE) {
[17:39:28.043]     }
[17:39:28.043]     else {
[17:39:28.043]         if (TRUE) {
[17:39:28.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.043]                 open = "w")
[17:39:28.043]         }
[17:39:28.043]         else {
[17:39:28.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.043]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.043]         }
[17:39:28.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.043]             base::sink(type = "output", split = FALSE)
[17:39:28.043]             base::close(...future.stdout)
[17:39:28.043]         }, add = TRUE)
[17:39:28.043]     }
[17:39:28.043]     ...future.frame <- base::sys.nframe()
[17:39:28.043]     ...future.conditions <- base::list()
[17:39:28.043]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.043]     if (FALSE) {
[17:39:28.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.043]     }
[17:39:28.043]     ...future.result <- base::tryCatch({
[17:39:28.043]         base::withCallingHandlers({
[17:39:28.043]             ...future.value <- base::withVisible(base::local({
[17:39:28.043]                 ...future.makeSendCondition <- local({
[17:39:28.043]                   sendCondition <- NULL
[17:39:28.043]                   function(frame = 1L) {
[17:39:28.043]                     if (is.function(sendCondition)) 
[17:39:28.043]                       return(sendCondition)
[17:39:28.043]                     ns <- getNamespace("parallel")
[17:39:28.043]                     if (exists("sendData", mode = "function", 
[17:39:28.043]                       envir = ns)) {
[17:39:28.043]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:28.043]                         envir = ns)
[17:39:28.043]                       envir <- sys.frame(frame)
[17:39:28.043]                       master <- NULL
[17:39:28.043]                       while (!identical(envir, .GlobalEnv) && 
[17:39:28.043]                         !identical(envir, emptyenv())) {
[17:39:28.043]                         if (exists("master", mode = "list", envir = envir, 
[17:39:28.043]                           inherits = FALSE)) {
[17:39:28.043]                           master <- get("master", mode = "list", 
[17:39:28.043]                             envir = envir, inherits = FALSE)
[17:39:28.043]                           if (inherits(master, c("SOCKnode", 
[17:39:28.043]                             "SOCK0node"))) {
[17:39:28.043]                             sendCondition <<- function(cond) {
[17:39:28.043]                               data <- list(type = "VALUE", value = cond, 
[17:39:28.043]                                 success = TRUE)
[17:39:28.043]                               parallel_sendData(master, data)
[17:39:28.043]                             }
[17:39:28.043]                             return(sendCondition)
[17:39:28.043]                           }
[17:39:28.043]                         }
[17:39:28.043]                         frame <- frame + 1L
[17:39:28.043]                         envir <- sys.frame(frame)
[17:39:28.043]                       }
[17:39:28.043]                     }
[17:39:28.043]                     sendCondition <<- function(cond) NULL
[17:39:28.043]                   }
[17:39:28.043]                 })
[17:39:28.043]                 withCallingHandlers({
[17:39:28.043]                   {
[17:39:28.043]                     do.call(function(...) {
[17:39:28.043]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.043]                       if (!identical(...future.globals.maxSize.org, 
[17:39:28.043]                         ...future.globals.maxSize)) {
[17:39:28.043]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.043]                         on.exit(options(oopts), add = TRUE)
[17:39:28.043]                       }
[17:39:28.043]                       {
[17:39:28.043]                         lapply(seq_along(...future.elements_ii), 
[17:39:28.043]                           FUN = function(jj) {
[17:39:28.043]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.043]                             ...future.FUN(...future.X_jj, ...)
[17:39:28.043]                           })
[17:39:28.043]                       }
[17:39:28.043]                     }, args = future.call.arguments)
[17:39:28.043]                   }
[17:39:28.043]                 }, immediateCondition = function(cond) {
[17:39:28.043]                   sendCondition <- ...future.makeSendCondition()
[17:39:28.043]                   sendCondition(cond)
[17:39:28.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.043]                   {
[17:39:28.043]                     inherits <- base::inherits
[17:39:28.043]                     invokeRestart <- base::invokeRestart
[17:39:28.043]                     is.null <- base::is.null
[17:39:28.043]                     muffled <- FALSE
[17:39:28.043]                     if (inherits(cond, "message")) {
[17:39:28.043]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:28.043]                       if (muffled) 
[17:39:28.043]                         invokeRestart("muffleMessage")
[17:39:28.043]                     }
[17:39:28.043]                     else if (inherits(cond, "warning")) {
[17:39:28.043]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:28.043]                       if (muffled) 
[17:39:28.043]                         invokeRestart("muffleWarning")
[17:39:28.043]                     }
[17:39:28.043]                     else if (inherits(cond, "condition")) {
[17:39:28.043]                       if (!is.null(pattern)) {
[17:39:28.043]                         computeRestarts <- base::computeRestarts
[17:39:28.043]                         grepl <- base::grepl
[17:39:28.043]                         restarts <- computeRestarts(cond)
[17:39:28.043]                         for (restart in restarts) {
[17:39:28.043]                           name <- restart$name
[17:39:28.043]                           if (is.null(name)) 
[17:39:28.043]                             next
[17:39:28.043]                           if (!grepl(pattern, name)) 
[17:39:28.043]                             next
[17:39:28.043]                           invokeRestart(restart)
[17:39:28.043]                           muffled <- TRUE
[17:39:28.043]                           break
[17:39:28.043]                         }
[17:39:28.043]                       }
[17:39:28.043]                     }
[17:39:28.043]                     invisible(muffled)
[17:39:28.043]                   }
[17:39:28.043]                   muffleCondition(cond)
[17:39:28.043]                 })
[17:39:28.043]             }))
[17:39:28.043]             future::FutureResult(value = ...future.value$value, 
[17:39:28.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.043]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.043]                     ...future.globalenv.names))
[17:39:28.043]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.043]         }, condition = base::local({
[17:39:28.043]             c <- base::c
[17:39:28.043]             inherits <- base::inherits
[17:39:28.043]             invokeRestart <- base::invokeRestart
[17:39:28.043]             length <- base::length
[17:39:28.043]             list <- base::list
[17:39:28.043]             seq.int <- base::seq.int
[17:39:28.043]             signalCondition <- base::signalCondition
[17:39:28.043]             sys.calls <- base::sys.calls
[17:39:28.043]             `[[` <- base::`[[`
[17:39:28.043]             `+` <- base::`+`
[17:39:28.043]             `<<-` <- base::`<<-`
[17:39:28.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.043]                   3L)]
[17:39:28.043]             }
[17:39:28.043]             function(cond) {
[17:39:28.043]                 is_error <- inherits(cond, "error")
[17:39:28.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.043]                   NULL)
[17:39:28.043]                 if (is_error) {
[17:39:28.043]                   sessionInformation <- function() {
[17:39:28.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.043]                       search = base::search(), system = base::Sys.info())
[17:39:28.043]                   }
[17:39:28.043]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.043]                     cond$call), session = sessionInformation(), 
[17:39:28.043]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.043]                   signalCondition(cond)
[17:39:28.043]                 }
[17:39:28.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.043]                 "immediateCondition"))) {
[17:39:28.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.043]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.043]                   if (TRUE && !signal) {
[17:39:28.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.043]                     {
[17:39:28.043]                       inherits <- base::inherits
[17:39:28.043]                       invokeRestart <- base::invokeRestart
[17:39:28.043]                       is.null <- base::is.null
[17:39:28.043]                       muffled <- FALSE
[17:39:28.043]                       if (inherits(cond, "message")) {
[17:39:28.043]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.043]                         if (muffled) 
[17:39:28.043]                           invokeRestart("muffleMessage")
[17:39:28.043]                       }
[17:39:28.043]                       else if (inherits(cond, "warning")) {
[17:39:28.043]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.043]                         if (muffled) 
[17:39:28.043]                           invokeRestart("muffleWarning")
[17:39:28.043]                       }
[17:39:28.043]                       else if (inherits(cond, "condition")) {
[17:39:28.043]                         if (!is.null(pattern)) {
[17:39:28.043]                           computeRestarts <- base::computeRestarts
[17:39:28.043]                           grepl <- base::grepl
[17:39:28.043]                           restarts <- computeRestarts(cond)
[17:39:28.043]                           for (restart in restarts) {
[17:39:28.043]                             name <- restart$name
[17:39:28.043]                             if (is.null(name)) 
[17:39:28.043]                               next
[17:39:28.043]                             if (!grepl(pattern, name)) 
[17:39:28.043]                               next
[17:39:28.043]                             invokeRestart(restart)
[17:39:28.043]                             muffled <- TRUE
[17:39:28.043]                             break
[17:39:28.043]                           }
[17:39:28.043]                         }
[17:39:28.043]                       }
[17:39:28.043]                       invisible(muffled)
[17:39:28.043]                     }
[17:39:28.043]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.043]                   }
[17:39:28.043]                 }
[17:39:28.043]                 else {
[17:39:28.043]                   if (TRUE) {
[17:39:28.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.043]                     {
[17:39:28.043]                       inherits <- base::inherits
[17:39:28.043]                       invokeRestart <- base::invokeRestart
[17:39:28.043]                       is.null <- base::is.null
[17:39:28.043]                       muffled <- FALSE
[17:39:28.043]                       if (inherits(cond, "message")) {
[17:39:28.043]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.043]                         if (muffled) 
[17:39:28.043]                           invokeRestart("muffleMessage")
[17:39:28.043]                       }
[17:39:28.043]                       else if (inherits(cond, "warning")) {
[17:39:28.043]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.043]                         if (muffled) 
[17:39:28.043]                           invokeRestart("muffleWarning")
[17:39:28.043]                       }
[17:39:28.043]                       else if (inherits(cond, "condition")) {
[17:39:28.043]                         if (!is.null(pattern)) {
[17:39:28.043]                           computeRestarts <- base::computeRestarts
[17:39:28.043]                           grepl <- base::grepl
[17:39:28.043]                           restarts <- computeRestarts(cond)
[17:39:28.043]                           for (restart in restarts) {
[17:39:28.043]                             name <- restart$name
[17:39:28.043]                             if (is.null(name)) 
[17:39:28.043]                               next
[17:39:28.043]                             if (!grepl(pattern, name)) 
[17:39:28.043]                               next
[17:39:28.043]                             invokeRestart(restart)
[17:39:28.043]                             muffled <- TRUE
[17:39:28.043]                             break
[17:39:28.043]                           }
[17:39:28.043]                         }
[17:39:28.043]                       }
[17:39:28.043]                       invisible(muffled)
[17:39:28.043]                     }
[17:39:28.043]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.043]                   }
[17:39:28.043]                 }
[17:39:28.043]             }
[17:39:28.043]         }))
[17:39:28.043]     }, error = function(ex) {
[17:39:28.043]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.043]                 ...future.rng), started = ...future.startTime, 
[17:39:28.043]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.043]             version = "1.8"), class = "FutureResult")
[17:39:28.043]     }, finally = {
[17:39:28.043]         if (!identical(...future.workdir, getwd())) 
[17:39:28.043]             setwd(...future.workdir)
[17:39:28.043]         {
[17:39:28.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.043]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.043]             }
[17:39:28.043]             base::options(...future.oldOptions)
[17:39:28.043]             if (.Platform$OS.type == "windows") {
[17:39:28.043]                 old_names <- names(...future.oldEnvVars)
[17:39:28.043]                 envs <- base::Sys.getenv()
[17:39:28.043]                 names <- names(envs)
[17:39:28.043]                 common <- intersect(names, old_names)
[17:39:28.043]                 added <- setdiff(names, old_names)
[17:39:28.043]                 removed <- setdiff(old_names, names)
[17:39:28.043]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.043]                   envs[common]]
[17:39:28.043]                 NAMES <- toupper(changed)
[17:39:28.043]                 args <- list()
[17:39:28.043]                 for (kk in seq_along(NAMES)) {
[17:39:28.043]                   name <- changed[[kk]]
[17:39:28.043]                   NAME <- NAMES[[kk]]
[17:39:28.043]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.043]                     next
[17:39:28.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.043]                 }
[17:39:28.043]                 NAMES <- toupper(added)
[17:39:28.043]                 for (kk in seq_along(NAMES)) {
[17:39:28.043]                   name <- added[[kk]]
[17:39:28.043]                   NAME <- NAMES[[kk]]
[17:39:28.043]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.043]                     next
[17:39:28.043]                   args[[name]] <- ""
[17:39:28.043]                 }
[17:39:28.043]                 NAMES <- toupper(removed)
[17:39:28.043]                 for (kk in seq_along(NAMES)) {
[17:39:28.043]                   name <- removed[[kk]]
[17:39:28.043]                   NAME <- NAMES[[kk]]
[17:39:28.043]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.043]                     next
[17:39:28.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.043]                 }
[17:39:28.043]                 if (length(args) > 0) 
[17:39:28.043]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.043]             }
[17:39:28.043]             else {
[17:39:28.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.043]             }
[17:39:28.043]             {
[17:39:28.043]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.043]                   0L) {
[17:39:28.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.043]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.043]                   base::options(opts)
[17:39:28.043]                 }
[17:39:28.043]                 {
[17:39:28.043]                   {
[17:39:28.043]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:28.043]                     NULL
[17:39:28.043]                   }
[17:39:28.043]                   options(future.plan = NULL)
[17:39:28.043]                   if (is.na(NA_character_)) 
[17:39:28.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.043]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:28.043]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:28.043]                     envir = parent.frame()) 
[17:39:28.043]                   {
[17:39:28.043]                     if (is.function(workers)) 
[17:39:28.043]                       workers <- workers()
[17:39:28.043]                     workers <- structure(as.integer(workers), 
[17:39:28.043]                       class = class(workers))
[17:39:28.043]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:28.043]                       workers >= 1)
[17:39:28.043]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:28.043]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:28.043]                     }
[17:39:28.043]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:28.043]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:28.043]                       envir = envir)
[17:39:28.043]                     if (!future$lazy) 
[17:39:28.043]                       future <- run(future)
[17:39:28.043]                     invisible(future)
[17:39:28.043]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.043]                 }
[17:39:28.043]             }
[17:39:28.043]         }
[17:39:28.043]     })
[17:39:28.043]     if (TRUE) {
[17:39:28.043]         base::sink(type = "output", split = FALSE)
[17:39:28.043]         if (TRUE) {
[17:39:28.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.043]         }
[17:39:28.043]         else {
[17:39:28.043]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.043]         }
[17:39:28.043]         base::close(...future.stdout)
[17:39:28.043]         ...future.stdout <- NULL
[17:39:28.043]     }
[17:39:28.043]     ...future.result$conditions <- ...future.conditions
[17:39:28.043]     ...future.result$finished <- base::Sys.time()
[17:39:28.043]     ...future.result
[17:39:28.043] }
[17:39:28.046] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[17:39:28.046] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[17:39:28.047] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[17:39:28.047] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[17:39:28.047] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[17:39:28.048] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[17:39:28.048] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[17:39:28.048] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:28.049] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:28.049] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:39:28.049] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:39:28.049] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:28.050] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:28.050] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:28.050] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:28.050] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[17:39:28.051] MultisessionFuture started
[17:39:28.051] - Launch lazy future ... done
[17:39:28.051] run() for ‘MultisessionFuture’ ... done
[17:39:28.051] Created future:
[17:39:28.051] MultisessionFuture:
[17:39:28.051] Label: ‘future_by-2’
[17:39:28.051] Expression:
[17:39:28.051] {
[17:39:28.051]     do.call(function(...) {
[17:39:28.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.051]             on.exit(options(oopts), add = TRUE)
[17:39:28.051]         }
[17:39:28.051]         {
[17:39:28.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.051]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.051]             })
[17:39:28.051]         }
[17:39:28.051]     }, args = future.call.arguments)
[17:39:28.051] }
[17:39:28.051] Lazy evaluation: FALSE
[17:39:28.051] Asynchronous evaluation: TRUE
[17:39:28.051] Local evaluation: TRUE
[17:39:28.051] Environment: 0x562971665188
[17:39:28.051] Capture standard output: TRUE
[17:39:28.051] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.051] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[17:39:28.051] Packages: 1 packages (‘stats’)
[17:39:28.051] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.051] Resolved: FALSE
[17:39:28.051] Value: <not collected>
[17:39:28.051] Conditions captured: <none>
[17:39:28.051] Early signaling: FALSE
[17:39:28.051] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:28.051] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.063] Chunk #2 of 2 ... DONE
[17:39:28.063] Launching 2 futures (chunks) ... DONE
[17:39:28.063] Resolving 2 futures (chunks) ...
[17:39:28.064] resolve() on list ...
[17:39:28.064]  recursive: 0
[17:39:28.064]  length: 2
[17:39:28.064] 
[17:39:28.064] receiveMessageFromWorker() for ClusterFuture ...
[17:39:28.064] - Validating connection of MultisessionFuture
[17:39:28.065] - received message: FutureResult
[17:39:28.065] - Received FutureResult
[17:39:28.065] - Erased future from FutureRegistry
[17:39:28.065] result() for ClusterFuture ...
[17:39:28.065] - result already collected: FutureResult
[17:39:28.065] result() for ClusterFuture ... done
[17:39:28.065] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:28.065] Future #1
[17:39:28.065] result() for ClusterFuture ...
[17:39:28.066] - result already collected: FutureResult
[17:39:28.066] result() for ClusterFuture ... done
[17:39:28.066] result() for ClusterFuture ...
[17:39:28.066] - result already collected: FutureResult
[17:39:28.066] result() for ClusterFuture ... done
[17:39:28.066] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:28.066] - nx: 2
[17:39:28.066] - relay: TRUE
[17:39:28.066] - stdout: TRUE
[17:39:28.066] - signal: TRUE
[17:39:28.066] - resignal: FALSE
[17:39:28.066] - force: TRUE
[17:39:28.067] - relayed: [n=2] FALSE, FALSE
[17:39:28.067] - queued futures: [n=2] FALSE, FALSE
[17:39:28.067]  - until=1
[17:39:28.067]  - relaying element #1
[17:39:28.067] result() for ClusterFuture ...
[17:39:28.067] - result already collected: FutureResult
[17:39:28.067] result() for ClusterFuture ... done
[17:39:28.067] result() for ClusterFuture ...
[17:39:28.067] - result already collected: FutureResult
[17:39:28.067] result() for ClusterFuture ... done
[17:39:28.067] result() for ClusterFuture ...
[17:39:28.068] - result already collected: FutureResult
[17:39:28.068] result() for ClusterFuture ... done
[17:39:28.068] result() for ClusterFuture ...
[17:39:28.068] - result already collected: FutureResult
[17:39:28.068] result() for ClusterFuture ... done
[17:39:28.068] - relayed: [n=2] TRUE, FALSE
[17:39:28.068] - queued futures: [n=2] TRUE, FALSE
[17:39:28.068] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:28.068]  length: 1 (resolved future 1)
[17:39:28.110] receiveMessageFromWorker() for ClusterFuture ...
[17:39:28.110] - Validating connection of MultisessionFuture
[17:39:28.110] - received message: FutureResult
[17:39:28.111] - Received FutureResult
[17:39:28.111] - Erased future from FutureRegistry
[17:39:28.111] result() for ClusterFuture ...
[17:39:28.111] - result already collected: FutureResult
[17:39:28.111] result() for ClusterFuture ... done
[17:39:28.111] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:28.111] Future #2
[17:39:28.111] result() for ClusterFuture ...
[17:39:28.111] - result already collected: FutureResult
[17:39:28.111] result() for ClusterFuture ... done
[17:39:28.112] result() for ClusterFuture ...
[17:39:28.112] - result already collected: FutureResult
[17:39:28.112] result() for ClusterFuture ... done
[17:39:28.112] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:28.112] - nx: 2
[17:39:28.112] - relay: TRUE
[17:39:28.112] - stdout: TRUE
[17:39:28.112] - signal: TRUE
[17:39:28.112] - resignal: FALSE
[17:39:28.112] - force: TRUE
[17:39:28.112] - relayed: [n=2] TRUE, FALSE
[17:39:28.112] - queued futures: [n=2] TRUE, FALSE
[17:39:28.113]  - until=2
[17:39:28.113]  - relaying element #2
[17:39:28.113] result() for ClusterFuture ...
[17:39:28.113] - result already collected: FutureResult
[17:39:28.113] result() for ClusterFuture ... done
[17:39:28.113] result() for ClusterFuture ...
[17:39:28.113] - result already collected: FutureResult
[17:39:28.113] result() for ClusterFuture ... done
[17:39:28.113] result() for ClusterFuture ...
[17:39:28.113] - result already collected: FutureResult
[17:39:28.114] result() for ClusterFuture ... done
[17:39:28.114] result() for ClusterFuture ...
[17:39:28.114] - result already collected: FutureResult
[17:39:28.114] result() for ClusterFuture ... done
[17:39:28.114] - relayed: [n=2] TRUE, TRUE
[17:39:28.114] - queued futures: [n=2] TRUE, TRUE
[17:39:28.114] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:28.114]  length: 0 (resolved future 2)
[17:39:28.114] Relaying remaining futures
[17:39:28.114] signalConditionsASAP(NULL, pos=0) ...
[17:39:28.114] - nx: 2
[17:39:28.115] - relay: TRUE
[17:39:28.115] - stdout: TRUE
[17:39:28.115] - signal: TRUE
[17:39:28.115] - resignal: FALSE
[17:39:28.115] - force: TRUE
[17:39:28.115] - relayed: [n=2] TRUE, TRUE
[17:39:28.115] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:28.115] - relayed: [n=2] TRUE, TRUE
[17:39:28.115] - queued futures: [n=2] TRUE, TRUE
[17:39:28.115] signalConditionsASAP(NULL, pos=0) ... done
[17:39:28.115] resolve() on list ... DONE
[17:39:28.116] result() for ClusterFuture ...
[17:39:28.116] - result already collected: FutureResult
[17:39:28.116] result() for ClusterFuture ... done
[17:39:28.116] result() for ClusterFuture ...
[17:39:28.116] - result already collected: FutureResult
[17:39:28.116] result() for ClusterFuture ... done
[17:39:28.116] result() for ClusterFuture ...
[17:39:28.116] - result already collected: FutureResult
[17:39:28.116] result() for ClusterFuture ... done
[17:39:28.116] result() for ClusterFuture ...
[17:39:28.116] - result already collected: FutureResult
[17:39:28.116] result() for ClusterFuture ... done
[17:39:28.117]  - Number of value chunks collected: 2
[17:39:28.117] Resolving 2 futures (chunks) ... DONE
[17:39:28.117] Reducing values from 2 chunks ...
[17:39:28.117]  - Number of values collected after concatenation: 3
[17:39:28.117]  - Number of values expected: 3
[17:39:28.117] Reducing values from 2 chunks ... DONE
[17:39:28.117] future_lapply() ... DONE
[17:39:28.117] future_by_internal() ... DONE
[17:39:28.118] future_by_internal() ...
[17:39:28.118] future_lapply() ...
[17:39:28.122] Number of chunks: 2
[17:39:28.122] getGlobalsAndPackagesXApply() ...
[17:39:28.122]  - future.globals: TRUE
[17:39:28.122] getGlobalsAndPackages() ...
[17:39:28.122] Searching for globals...
[17:39:28.123] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:28.124] Searching for globals ... DONE
[17:39:28.124] Resolving globals: FALSE
[17:39:28.124] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:28.124] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:28.125] - globals: [1] ‘FUN’
[17:39:28.125] 
[17:39:28.125] getGlobalsAndPackages() ... DONE
[17:39:28.125]  - globals found/used: [n=1] ‘FUN’
[17:39:28.125]  - needed namespaces: [n=0] 
[17:39:28.125] Finding globals ... DONE
[17:39:28.125]  - use_args: TRUE
[17:39:28.125]  - Getting '...' globals ...
[17:39:28.125] resolve() on list ...
[17:39:28.126]  recursive: 0
[17:39:28.126]  length: 1
[17:39:28.126]  elements: ‘...’
[17:39:28.126]  length: 0 (resolved future 1)
[17:39:28.126] resolve() on list ... DONE
[17:39:28.126]    - '...' content: [n=0] 
[17:39:28.126] List of 1
[17:39:28.126]  $ ...: list()
[17:39:28.126]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.126]  - attr(*, "where")=List of 1
[17:39:28.126]   ..$ ...:<environment: 0x5629720d6758> 
[17:39:28.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.126]  - attr(*, "resolved")= logi TRUE
[17:39:28.126]  - attr(*, "total_size")= num NA
[17:39:28.129]  - Getting '...' globals ... DONE
[17:39:28.129] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:28.129] List of 2
[17:39:28.129]  $ ...future.FUN:function (object, ...)  
[17:39:28.129]  $ ...          : list()
[17:39:28.129]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.129]  - attr(*, "where")=List of 2
[17:39:28.129]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:28.129]   ..$ ...          :<environment: 0x5629720d6758> 
[17:39:28.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.129]  - attr(*, "resolved")= logi FALSE
[17:39:28.129]  - attr(*, "total_size")= num 1240
[17:39:28.131] Packages to be attached in all futures: [n=0] 
[17:39:28.132] getGlobalsAndPackagesXApply() ... DONE
[17:39:28.132] Number of futures (= number of chunks): 2
[17:39:28.132] Launching 2 futures (chunks) ...
[17:39:28.132] Chunk #1 of 2 ...
[17:39:28.132]  - Finding globals in 'X' for chunk #1 ...
[17:39:28.132] getGlobalsAndPackages() ...
[17:39:28.132] Searching for globals...
[17:39:28.133] 
[17:39:28.133] Searching for globals ... DONE
[17:39:28.133] - globals: [0] <none>
[17:39:28.133] getGlobalsAndPackages() ... DONE
[17:39:28.133]    + additional globals found: [n=0] 
[17:39:28.133]    + additional namespaces needed: [n=0] 
[17:39:28.133]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:28.133]  - seeds: <none>
[17:39:28.133] getGlobalsAndPackages() ...
[17:39:28.133] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.133] Resolving globals: FALSE
[17:39:28.134] Tweak future expression to call with '...' arguments ...
[17:39:28.134] {
[17:39:28.134]     do.call(function(...) {
[17:39:28.134]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.134]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.134]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.134]             on.exit(options(oopts), add = TRUE)
[17:39:28.134]         }
[17:39:28.134]         {
[17:39:28.134]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.134]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.134]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.134]             })
[17:39:28.134]         }
[17:39:28.134]     }, args = future.call.arguments)
[17:39:28.134] }
[17:39:28.134] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.134] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.134] 
[17:39:28.134] getGlobalsAndPackages() ... DONE
[17:39:28.135] run() for ‘Future’ ...
[17:39:28.135] - state: ‘created’
[17:39:28.135] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:28.149] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:28.149]   - Field: ‘node’
[17:39:28.149]   - Field: ‘label’
[17:39:28.149]   - Field: ‘local’
[17:39:28.149]   - Field: ‘owner’
[17:39:28.149]   - Field: ‘envir’
[17:39:28.149]   - Field: ‘workers’
[17:39:28.150]   - Field: ‘packages’
[17:39:28.150]   - Field: ‘gc’
[17:39:28.150]   - Field: ‘conditions’
[17:39:28.150]   - Field: ‘persistent’
[17:39:28.150]   - Field: ‘expr’
[17:39:28.150]   - Field: ‘uuid’
[17:39:28.150]   - Field: ‘seed’
[17:39:28.150]   - Field: ‘version’
[17:39:28.150]   - Field: ‘result’
[17:39:28.150]   - Field: ‘asynchronous’
[17:39:28.150]   - Field: ‘calls’
[17:39:28.151]   - Field: ‘globals’
[17:39:28.151]   - Field: ‘stdout’
[17:39:28.151]   - Field: ‘earlySignal’
[17:39:28.151]   - Field: ‘lazy’
[17:39:28.151]   - Field: ‘state’
[17:39:28.151] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:28.151] - Launch lazy future ...
[17:39:28.151] Packages needed by the future expression (n = 0): <none>
[17:39:28.152] Packages needed by future strategies (n = 0): <none>
[17:39:28.152] {
[17:39:28.152]     {
[17:39:28.152]         {
[17:39:28.152]             ...future.startTime <- base::Sys.time()
[17:39:28.152]             {
[17:39:28.152]                 {
[17:39:28.152]                   {
[17:39:28.152]                     {
[17:39:28.152]                       base::local({
[17:39:28.152]                         has_future <- base::requireNamespace("future", 
[17:39:28.152]                           quietly = TRUE)
[17:39:28.152]                         if (has_future) {
[17:39:28.152]                           ns <- base::getNamespace("future")
[17:39:28.152]                           version <- ns[[".package"]][["version"]]
[17:39:28.152]                           if (is.null(version)) 
[17:39:28.152]                             version <- utils::packageVersion("future")
[17:39:28.152]                         }
[17:39:28.152]                         else {
[17:39:28.152]                           version <- NULL
[17:39:28.152]                         }
[17:39:28.152]                         if (!has_future || version < "1.8.0") {
[17:39:28.152]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.152]                             "", base::R.version$version.string), 
[17:39:28.152]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:28.152]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:28.152]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.152]                               "release", "version")], collapse = " "), 
[17:39:28.152]                             hostname = base::Sys.info()[["nodename"]])
[17:39:28.152]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.152]                             info)
[17:39:28.152]                           info <- base::paste(info, collapse = "; ")
[17:39:28.152]                           if (!has_future) {
[17:39:28.152]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.152]                               info)
[17:39:28.152]                           }
[17:39:28.152]                           else {
[17:39:28.152]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.152]                               info, version)
[17:39:28.152]                           }
[17:39:28.152]                           base::stop(msg)
[17:39:28.152]                         }
[17:39:28.152]                       })
[17:39:28.152]                     }
[17:39:28.152]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:28.152]                     base::options(mc.cores = 1L)
[17:39:28.152]                   }
[17:39:28.152]                   options(future.plan = NULL)
[17:39:28.152]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.152]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.152]                 }
[17:39:28.152]                 ...future.workdir <- getwd()
[17:39:28.152]             }
[17:39:28.152]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.152]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.152]         }
[17:39:28.152]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.152]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:28.152]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.152]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.152]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.152]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.152]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.152]             base::names(...future.oldOptions))
[17:39:28.152]     }
[17:39:28.152]     if (FALSE) {
[17:39:28.152]     }
[17:39:28.152]     else {
[17:39:28.152]         if (TRUE) {
[17:39:28.152]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.152]                 open = "w")
[17:39:28.152]         }
[17:39:28.152]         else {
[17:39:28.152]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.152]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.152]         }
[17:39:28.152]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.152]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.152]             base::sink(type = "output", split = FALSE)
[17:39:28.152]             base::close(...future.stdout)
[17:39:28.152]         }, add = TRUE)
[17:39:28.152]     }
[17:39:28.152]     ...future.frame <- base::sys.nframe()
[17:39:28.152]     ...future.conditions <- base::list()
[17:39:28.152]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.152]     if (FALSE) {
[17:39:28.152]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.152]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.152]     }
[17:39:28.152]     ...future.result <- base::tryCatch({
[17:39:28.152]         base::withCallingHandlers({
[17:39:28.152]             ...future.value <- base::withVisible(base::local({
[17:39:28.152]                 ...future.makeSendCondition <- local({
[17:39:28.152]                   sendCondition <- NULL
[17:39:28.152]                   function(frame = 1L) {
[17:39:28.152]                     if (is.function(sendCondition)) 
[17:39:28.152]                       return(sendCondition)
[17:39:28.152]                     ns <- getNamespace("parallel")
[17:39:28.152]                     if (exists("sendData", mode = "function", 
[17:39:28.152]                       envir = ns)) {
[17:39:28.152]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:28.152]                         envir = ns)
[17:39:28.152]                       envir <- sys.frame(frame)
[17:39:28.152]                       master <- NULL
[17:39:28.152]                       while (!identical(envir, .GlobalEnv) && 
[17:39:28.152]                         !identical(envir, emptyenv())) {
[17:39:28.152]                         if (exists("master", mode = "list", envir = envir, 
[17:39:28.152]                           inherits = FALSE)) {
[17:39:28.152]                           master <- get("master", mode = "list", 
[17:39:28.152]                             envir = envir, inherits = FALSE)
[17:39:28.152]                           if (inherits(master, c("SOCKnode", 
[17:39:28.152]                             "SOCK0node"))) {
[17:39:28.152]                             sendCondition <<- function(cond) {
[17:39:28.152]                               data <- list(type = "VALUE", value = cond, 
[17:39:28.152]                                 success = TRUE)
[17:39:28.152]                               parallel_sendData(master, data)
[17:39:28.152]                             }
[17:39:28.152]                             return(sendCondition)
[17:39:28.152]                           }
[17:39:28.152]                         }
[17:39:28.152]                         frame <- frame + 1L
[17:39:28.152]                         envir <- sys.frame(frame)
[17:39:28.152]                       }
[17:39:28.152]                     }
[17:39:28.152]                     sendCondition <<- function(cond) NULL
[17:39:28.152]                   }
[17:39:28.152]                 })
[17:39:28.152]                 withCallingHandlers({
[17:39:28.152]                   {
[17:39:28.152]                     do.call(function(...) {
[17:39:28.152]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.152]                       if (!identical(...future.globals.maxSize.org, 
[17:39:28.152]                         ...future.globals.maxSize)) {
[17:39:28.152]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.152]                         on.exit(options(oopts), add = TRUE)
[17:39:28.152]                       }
[17:39:28.152]                       {
[17:39:28.152]                         lapply(seq_along(...future.elements_ii), 
[17:39:28.152]                           FUN = function(jj) {
[17:39:28.152]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.152]                             ...future.FUN(...future.X_jj, ...)
[17:39:28.152]                           })
[17:39:28.152]                       }
[17:39:28.152]                     }, args = future.call.arguments)
[17:39:28.152]                   }
[17:39:28.152]                 }, immediateCondition = function(cond) {
[17:39:28.152]                   sendCondition <- ...future.makeSendCondition()
[17:39:28.152]                   sendCondition(cond)
[17:39:28.152]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.152]                   {
[17:39:28.152]                     inherits <- base::inherits
[17:39:28.152]                     invokeRestart <- base::invokeRestart
[17:39:28.152]                     is.null <- base::is.null
[17:39:28.152]                     muffled <- FALSE
[17:39:28.152]                     if (inherits(cond, "message")) {
[17:39:28.152]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:28.152]                       if (muffled) 
[17:39:28.152]                         invokeRestart("muffleMessage")
[17:39:28.152]                     }
[17:39:28.152]                     else if (inherits(cond, "warning")) {
[17:39:28.152]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:28.152]                       if (muffled) 
[17:39:28.152]                         invokeRestart("muffleWarning")
[17:39:28.152]                     }
[17:39:28.152]                     else if (inherits(cond, "condition")) {
[17:39:28.152]                       if (!is.null(pattern)) {
[17:39:28.152]                         computeRestarts <- base::computeRestarts
[17:39:28.152]                         grepl <- base::grepl
[17:39:28.152]                         restarts <- computeRestarts(cond)
[17:39:28.152]                         for (restart in restarts) {
[17:39:28.152]                           name <- restart$name
[17:39:28.152]                           if (is.null(name)) 
[17:39:28.152]                             next
[17:39:28.152]                           if (!grepl(pattern, name)) 
[17:39:28.152]                             next
[17:39:28.152]                           invokeRestart(restart)
[17:39:28.152]                           muffled <- TRUE
[17:39:28.152]                           break
[17:39:28.152]                         }
[17:39:28.152]                       }
[17:39:28.152]                     }
[17:39:28.152]                     invisible(muffled)
[17:39:28.152]                   }
[17:39:28.152]                   muffleCondition(cond)
[17:39:28.152]                 })
[17:39:28.152]             }))
[17:39:28.152]             future::FutureResult(value = ...future.value$value, 
[17:39:28.152]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.152]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.152]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.152]                     ...future.globalenv.names))
[17:39:28.152]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.152]         }, condition = base::local({
[17:39:28.152]             c <- base::c
[17:39:28.152]             inherits <- base::inherits
[17:39:28.152]             invokeRestart <- base::invokeRestart
[17:39:28.152]             length <- base::length
[17:39:28.152]             list <- base::list
[17:39:28.152]             seq.int <- base::seq.int
[17:39:28.152]             signalCondition <- base::signalCondition
[17:39:28.152]             sys.calls <- base::sys.calls
[17:39:28.152]             `[[` <- base::`[[`
[17:39:28.152]             `+` <- base::`+`
[17:39:28.152]             `<<-` <- base::`<<-`
[17:39:28.152]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.152]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.152]                   3L)]
[17:39:28.152]             }
[17:39:28.152]             function(cond) {
[17:39:28.152]                 is_error <- inherits(cond, "error")
[17:39:28.152]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.152]                   NULL)
[17:39:28.152]                 if (is_error) {
[17:39:28.152]                   sessionInformation <- function() {
[17:39:28.152]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.152]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.152]                       search = base::search(), system = base::Sys.info())
[17:39:28.152]                   }
[17:39:28.152]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.152]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.152]                     cond$call), session = sessionInformation(), 
[17:39:28.152]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.152]                   signalCondition(cond)
[17:39:28.152]                 }
[17:39:28.152]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.152]                 "immediateCondition"))) {
[17:39:28.152]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.152]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.152]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.152]                   if (TRUE && !signal) {
[17:39:28.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.152]                     {
[17:39:28.152]                       inherits <- base::inherits
[17:39:28.152]                       invokeRestart <- base::invokeRestart
[17:39:28.152]                       is.null <- base::is.null
[17:39:28.152]                       muffled <- FALSE
[17:39:28.152]                       if (inherits(cond, "message")) {
[17:39:28.152]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.152]                         if (muffled) 
[17:39:28.152]                           invokeRestart("muffleMessage")
[17:39:28.152]                       }
[17:39:28.152]                       else if (inherits(cond, "warning")) {
[17:39:28.152]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.152]                         if (muffled) 
[17:39:28.152]                           invokeRestart("muffleWarning")
[17:39:28.152]                       }
[17:39:28.152]                       else if (inherits(cond, "condition")) {
[17:39:28.152]                         if (!is.null(pattern)) {
[17:39:28.152]                           computeRestarts <- base::computeRestarts
[17:39:28.152]                           grepl <- base::grepl
[17:39:28.152]                           restarts <- computeRestarts(cond)
[17:39:28.152]                           for (restart in restarts) {
[17:39:28.152]                             name <- restart$name
[17:39:28.152]                             if (is.null(name)) 
[17:39:28.152]                               next
[17:39:28.152]                             if (!grepl(pattern, name)) 
[17:39:28.152]                               next
[17:39:28.152]                             invokeRestart(restart)
[17:39:28.152]                             muffled <- TRUE
[17:39:28.152]                             break
[17:39:28.152]                           }
[17:39:28.152]                         }
[17:39:28.152]                       }
[17:39:28.152]                       invisible(muffled)
[17:39:28.152]                     }
[17:39:28.152]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.152]                   }
[17:39:28.152]                 }
[17:39:28.152]                 else {
[17:39:28.152]                   if (TRUE) {
[17:39:28.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.152]                     {
[17:39:28.152]                       inherits <- base::inherits
[17:39:28.152]                       invokeRestart <- base::invokeRestart
[17:39:28.152]                       is.null <- base::is.null
[17:39:28.152]                       muffled <- FALSE
[17:39:28.152]                       if (inherits(cond, "message")) {
[17:39:28.152]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.152]                         if (muffled) 
[17:39:28.152]                           invokeRestart("muffleMessage")
[17:39:28.152]                       }
[17:39:28.152]                       else if (inherits(cond, "warning")) {
[17:39:28.152]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.152]                         if (muffled) 
[17:39:28.152]                           invokeRestart("muffleWarning")
[17:39:28.152]                       }
[17:39:28.152]                       else if (inherits(cond, "condition")) {
[17:39:28.152]                         if (!is.null(pattern)) {
[17:39:28.152]                           computeRestarts <- base::computeRestarts
[17:39:28.152]                           grepl <- base::grepl
[17:39:28.152]                           restarts <- computeRestarts(cond)
[17:39:28.152]                           for (restart in restarts) {
[17:39:28.152]                             name <- restart$name
[17:39:28.152]                             if (is.null(name)) 
[17:39:28.152]                               next
[17:39:28.152]                             if (!grepl(pattern, name)) 
[17:39:28.152]                               next
[17:39:28.152]                             invokeRestart(restart)
[17:39:28.152]                             muffled <- TRUE
[17:39:28.152]                             break
[17:39:28.152]                           }
[17:39:28.152]                         }
[17:39:28.152]                       }
[17:39:28.152]                       invisible(muffled)
[17:39:28.152]                     }
[17:39:28.152]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.152]                   }
[17:39:28.152]                 }
[17:39:28.152]             }
[17:39:28.152]         }))
[17:39:28.152]     }, error = function(ex) {
[17:39:28.152]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.152]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.152]                 ...future.rng), started = ...future.startTime, 
[17:39:28.152]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.152]             version = "1.8"), class = "FutureResult")
[17:39:28.152]     }, finally = {
[17:39:28.152]         if (!identical(...future.workdir, getwd())) 
[17:39:28.152]             setwd(...future.workdir)
[17:39:28.152]         {
[17:39:28.152]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.152]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.152]             }
[17:39:28.152]             base::options(...future.oldOptions)
[17:39:28.152]             if (.Platform$OS.type == "windows") {
[17:39:28.152]                 old_names <- names(...future.oldEnvVars)
[17:39:28.152]                 envs <- base::Sys.getenv()
[17:39:28.152]                 names <- names(envs)
[17:39:28.152]                 common <- intersect(names, old_names)
[17:39:28.152]                 added <- setdiff(names, old_names)
[17:39:28.152]                 removed <- setdiff(old_names, names)
[17:39:28.152]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.152]                   envs[common]]
[17:39:28.152]                 NAMES <- toupper(changed)
[17:39:28.152]                 args <- list()
[17:39:28.152]                 for (kk in seq_along(NAMES)) {
[17:39:28.152]                   name <- changed[[kk]]
[17:39:28.152]                   NAME <- NAMES[[kk]]
[17:39:28.152]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.152]                     next
[17:39:28.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.152]                 }
[17:39:28.152]                 NAMES <- toupper(added)
[17:39:28.152]                 for (kk in seq_along(NAMES)) {
[17:39:28.152]                   name <- added[[kk]]
[17:39:28.152]                   NAME <- NAMES[[kk]]
[17:39:28.152]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.152]                     next
[17:39:28.152]                   args[[name]] <- ""
[17:39:28.152]                 }
[17:39:28.152]                 NAMES <- toupper(removed)
[17:39:28.152]                 for (kk in seq_along(NAMES)) {
[17:39:28.152]                   name <- removed[[kk]]
[17:39:28.152]                   NAME <- NAMES[[kk]]
[17:39:28.152]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.152]                     next
[17:39:28.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.152]                 }
[17:39:28.152]                 if (length(args) > 0) 
[17:39:28.152]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.152]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.152]             }
[17:39:28.152]             else {
[17:39:28.152]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.152]             }
[17:39:28.152]             {
[17:39:28.152]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.152]                   0L) {
[17:39:28.152]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.152]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.152]                   base::options(opts)
[17:39:28.152]                 }
[17:39:28.152]                 {
[17:39:28.152]                   {
[17:39:28.152]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:28.152]                     NULL
[17:39:28.152]                   }
[17:39:28.152]                   options(future.plan = NULL)
[17:39:28.152]                   if (is.na(NA_character_)) 
[17:39:28.152]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.152]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.152]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:28.152]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:28.152]                     envir = parent.frame()) 
[17:39:28.152]                   {
[17:39:28.152]                     if (is.function(workers)) 
[17:39:28.152]                       workers <- workers()
[17:39:28.152]                     workers <- structure(as.integer(workers), 
[17:39:28.152]                       class = class(workers))
[17:39:28.152]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:28.152]                       workers >= 1)
[17:39:28.152]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:28.152]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:28.152]                     }
[17:39:28.152]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:28.152]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:28.152]                       envir = envir)
[17:39:28.152]                     if (!future$lazy) 
[17:39:28.152]                       future <- run(future)
[17:39:28.152]                     invisible(future)
[17:39:28.152]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.152]                 }
[17:39:28.152]             }
[17:39:28.152]         }
[17:39:28.152]     })
[17:39:28.152]     if (TRUE) {
[17:39:28.152]         base::sink(type = "output", split = FALSE)
[17:39:28.152]         if (TRUE) {
[17:39:28.152]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.152]         }
[17:39:28.152]         else {
[17:39:28.152]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.152]         }
[17:39:28.152]         base::close(...future.stdout)
[17:39:28.152]         ...future.stdout <- NULL
[17:39:28.152]     }
[17:39:28.152]     ...future.result$conditions <- ...future.conditions
[17:39:28.152]     ...future.result$finished <- base::Sys.time()
[17:39:28.152]     ...future.result
[17:39:28.152] }
[17:39:28.155] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:39:28.155] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:39:28.155] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:39:28.156] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:28.156] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:28.156] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:39:28.156] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:39:28.156] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:28.157] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:28.157] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:28.157] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:28.157] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:39:28.158] MultisessionFuture started
[17:39:28.158] - Launch lazy future ... done
[17:39:28.158] run() for ‘MultisessionFuture’ ... done
[17:39:28.158] Created future:
[17:39:28.158] MultisessionFuture:
[17:39:28.158] Label: ‘future_by-1’
[17:39:28.158] Expression:
[17:39:28.158] {
[17:39:28.158]     do.call(function(...) {
[17:39:28.158]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.158]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.158]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.158]             on.exit(options(oopts), add = TRUE)
[17:39:28.158]         }
[17:39:28.158]         {
[17:39:28.158]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.158]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.158]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.158]             })
[17:39:28.158]         }
[17:39:28.158]     }, args = future.call.arguments)
[17:39:28.158] }
[17:39:28.158] Lazy evaluation: FALSE
[17:39:28.158] Asynchronous evaluation: TRUE
[17:39:28.158] Local evaluation: TRUE
[17:39:28.158] Environment: 0x562972100ff0
[17:39:28.158] Capture standard output: TRUE
[17:39:28.158] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.158] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:28.158] Packages: <none>
[17:39:28.158] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.158] Resolved: FALSE
[17:39:28.158] Value: <not collected>
[17:39:28.158] Conditions captured: <none>
[17:39:28.158] Early signaling: FALSE
[17:39:28.158] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:28.158] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.170] Chunk #1 of 2 ... DONE
[17:39:28.170] Chunk #2 of 2 ...
[17:39:28.170]  - Finding globals in 'X' for chunk #2 ...
[17:39:28.170] getGlobalsAndPackages() ...
[17:39:28.170] Searching for globals...
[17:39:28.171] 
[17:39:28.171] Searching for globals ... DONE
[17:39:28.171] - globals: [0] <none>
[17:39:28.171] getGlobalsAndPackages() ... DONE
[17:39:28.171]    + additional globals found: [n=0] 
[17:39:28.171]    + additional namespaces needed: [n=0] 
[17:39:28.171]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:28.172]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:28.172]  - seeds: <none>
[17:39:28.172] getGlobalsAndPackages() ...
[17:39:28.172] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.172] Resolving globals: FALSE
[17:39:28.172] Tweak future expression to call with '...' arguments ...
[17:39:28.172] {
[17:39:28.172]     do.call(function(...) {
[17:39:28.172]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.172]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.172]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.172]             on.exit(options(oopts), add = TRUE)
[17:39:28.172]         }
[17:39:28.172]         {
[17:39:28.172]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.172]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.172]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.172]             })
[17:39:28.172]         }
[17:39:28.172]     }, args = future.call.arguments)
[17:39:28.172] }
[17:39:28.172] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.173] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.173] 
[17:39:28.173] getGlobalsAndPackages() ... DONE
[17:39:28.173] run() for ‘Future’ ...
[17:39:28.173] - state: ‘created’
[17:39:28.174] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:28.189] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:28.189]   - Field: ‘node’
[17:39:28.189]   - Field: ‘label’
[17:39:28.189]   - Field: ‘local’
[17:39:28.189]   - Field: ‘owner’
[17:39:28.190]   - Field: ‘envir’
[17:39:28.190]   - Field: ‘workers’
[17:39:28.190]   - Field: ‘packages’
[17:39:28.190]   - Field: ‘gc’
[17:39:28.190]   - Field: ‘conditions’
[17:39:28.190]   - Field: ‘persistent’
[17:39:28.190]   - Field: ‘expr’
[17:39:28.190]   - Field: ‘uuid’
[17:39:28.190]   - Field: ‘seed’
[17:39:28.190]   - Field: ‘version’
[17:39:28.191]   - Field: ‘result’
[17:39:28.191]   - Field: ‘asynchronous’
[17:39:28.191]   - Field: ‘calls’
[17:39:28.191]   - Field: ‘globals’
[17:39:28.191]   - Field: ‘stdout’
[17:39:28.191]   - Field: ‘earlySignal’
[17:39:28.191]   - Field: ‘lazy’
[17:39:28.191]   - Field: ‘state’
[17:39:28.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:28.191] - Launch lazy future ...
[17:39:28.192] Packages needed by the future expression (n = 0): <none>
[17:39:28.192] Packages needed by future strategies (n = 0): <none>
[17:39:28.192] {
[17:39:28.192]     {
[17:39:28.192]         {
[17:39:28.192]             ...future.startTime <- base::Sys.time()
[17:39:28.192]             {
[17:39:28.192]                 {
[17:39:28.192]                   {
[17:39:28.192]                     {
[17:39:28.192]                       base::local({
[17:39:28.192]                         has_future <- base::requireNamespace("future", 
[17:39:28.192]                           quietly = TRUE)
[17:39:28.192]                         if (has_future) {
[17:39:28.192]                           ns <- base::getNamespace("future")
[17:39:28.192]                           version <- ns[[".package"]][["version"]]
[17:39:28.192]                           if (is.null(version)) 
[17:39:28.192]                             version <- utils::packageVersion("future")
[17:39:28.192]                         }
[17:39:28.192]                         else {
[17:39:28.192]                           version <- NULL
[17:39:28.192]                         }
[17:39:28.192]                         if (!has_future || version < "1.8.0") {
[17:39:28.192]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.192]                             "", base::R.version$version.string), 
[17:39:28.192]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:28.192]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:28.192]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.192]                               "release", "version")], collapse = " "), 
[17:39:28.192]                             hostname = base::Sys.info()[["nodename"]])
[17:39:28.192]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.192]                             info)
[17:39:28.192]                           info <- base::paste(info, collapse = "; ")
[17:39:28.192]                           if (!has_future) {
[17:39:28.192]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.192]                               info)
[17:39:28.192]                           }
[17:39:28.192]                           else {
[17:39:28.192]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.192]                               info, version)
[17:39:28.192]                           }
[17:39:28.192]                           base::stop(msg)
[17:39:28.192]                         }
[17:39:28.192]                       })
[17:39:28.192]                     }
[17:39:28.192]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:28.192]                     base::options(mc.cores = 1L)
[17:39:28.192]                   }
[17:39:28.192]                   options(future.plan = NULL)
[17:39:28.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.192]                 }
[17:39:28.192]                 ...future.workdir <- getwd()
[17:39:28.192]             }
[17:39:28.192]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.192]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.192]         }
[17:39:28.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.192]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:28.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.192]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.192]             base::names(...future.oldOptions))
[17:39:28.192]     }
[17:39:28.192]     if (FALSE) {
[17:39:28.192]     }
[17:39:28.192]     else {
[17:39:28.192]         if (TRUE) {
[17:39:28.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.192]                 open = "w")
[17:39:28.192]         }
[17:39:28.192]         else {
[17:39:28.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.192]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.192]         }
[17:39:28.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.192]             base::sink(type = "output", split = FALSE)
[17:39:28.192]             base::close(...future.stdout)
[17:39:28.192]         }, add = TRUE)
[17:39:28.192]     }
[17:39:28.192]     ...future.frame <- base::sys.nframe()
[17:39:28.192]     ...future.conditions <- base::list()
[17:39:28.192]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.192]     if (FALSE) {
[17:39:28.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.192]     }
[17:39:28.192]     ...future.result <- base::tryCatch({
[17:39:28.192]         base::withCallingHandlers({
[17:39:28.192]             ...future.value <- base::withVisible(base::local({
[17:39:28.192]                 ...future.makeSendCondition <- local({
[17:39:28.192]                   sendCondition <- NULL
[17:39:28.192]                   function(frame = 1L) {
[17:39:28.192]                     if (is.function(sendCondition)) 
[17:39:28.192]                       return(sendCondition)
[17:39:28.192]                     ns <- getNamespace("parallel")
[17:39:28.192]                     if (exists("sendData", mode = "function", 
[17:39:28.192]                       envir = ns)) {
[17:39:28.192]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:28.192]                         envir = ns)
[17:39:28.192]                       envir <- sys.frame(frame)
[17:39:28.192]                       master <- NULL
[17:39:28.192]                       while (!identical(envir, .GlobalEnv) && 
[17:39:28.192]                         !identical(envir, emptyenv())) {
[17:39:28.192]                         if (exists("master", mode = "list", envir = envir, 
[17:39:28.192]                           inherits = FALSE)) {
[17:39:28.192]                           master <- get("master", mode = "list", 
[17:39:28.192]                             envir = envir, inherits = FALSE)
[17:39:28.192]                           if (inherits(master, c("SOCKnode", 
[17:39:28.192]                             "SOCK0node"))) {
[17:39:28.192]                             sendCondition <<- function(cond) {
[17:39:28.192]                               data <- list(type = "VALUE", value = cond, 
[17:39:28.192]                                 success = TRUE)
[17:39:28.192]                               parallel_sendData(master, data)
[17:39:28.192]                             }
[17:39:28.192]                             return(sendCondition)
[17:39:28.192]                           }
[17:39:28.192]                         }
[17:39:28.192]                         frame <- frame + 1L
[17:39:28.192]                         envir <- sys.frame(frame)
[17:39:28.192]                       }
[17:39:28.192]                     }
[17:39:28.192]                     sendCondition <<- function(cond) NULL
[17:39:28.192]                   }
[17:39:28.192]                 })
[17:39:28.192]                 withCallingHandlers({
[17:39:28.192]                   {
[17:39:28.192]                     do.call(function(...) {
[17:39:28.192]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.192]                       if (!identical(...future.globals.maxSize.org, 
[17:39:28.192]                         ...future.globals.maxSize)) {
[17:39:28.192]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.192]                         on.exit(options(oopts), add = TRUE)
[17:39:28.192]                       }
[17:39:28.192]                       {
[17:39:28.192]                         lapply(seq_along(...future.elements_ii), 
[17:39:28.192]                           FUN = function(jj) {
[17:39:28.192]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.192]                             ...future.FUN(...future.X_jj, ...)
[17:39:28.192]                           })
[17:39:28.192]                       }
[17:39:28.192]                     }, args = future.call.arguments)
[17:39:28.192]                   }
[17:39:28.192]                 }, immediateCondition = function(cond) {
[17:39:28.192]                   sendCondition <- ...future.makeSendCondition()
[17:39:28.192]                   sendCondition(cond)
[17:39:28.192]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.192]                   {
[17:39:28.192]                     inherits <- base::inherits
[17:39:28.192]                     invokeRestart <- base::invokeRestart
[17:39:28.192]                     is.null <- base::is.null
[17:39:28.192]                     muffled <- FALSE
[17:39:28.192]                     if (inherits(cond, "message")) {
[17:39:28.192]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:28.192]                       if (muffled) 
[17:39:28.192]                         invokeRestart("muffleMessage")
[17:39:28.192]                     }
[17:39:28.192]                     else if (inherits(cond, "warning")) {
[17:39:28.192]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:28.192]                       if (muffled) 
[17:39:28.192]                         invokeRestart("muffleWarning")
[17:39:28.192]                     }
[17:39:28.192]                     else if (inherits(cond, "condition")) {
[17:39:28.192]                       if (!is.null(pattern)) {
[17:39:28.192]                         computeRestarts <- base::computeRestarts
[17:39:28.192]                         grepl <- base::grepl
[17:39:28.192]                         restarts <- computeRestarts(cond)
[17:39:28.192]                         for (restart in restarts) {
[17:39:28.192]                           name <- restart$name
[17:39:28.192]                           if (is.null(name)) 
[17:39:28.192]                             next
[17:39:28.192]                           if (!grepl(pattern, name)) 
[17:39:28.192]                             next
[17:39:28.192]                           invokeRestart(restart)
[17:39:28.192]                           muffled <- TRUE
[17:39:28.192]                           break
[17:39:28.192]                         }
[17:39:28.192]                       }
[17:39:28.192]                     }
[17:39:28.192]                     invisible(muffled)
[17:39:28.192]                   }
[17:39:28.192]                   muffleCondition(cond)
[17:39:28.192]                 })
[17:39:28.192]             }))
[17:39:28.192]             future::FutureResult(value = ...future.value$value, 
[17:39:28.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.192]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.192]                     ...future.globalenv.names))
[17:39:28.192]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.192]         }, condition = base::local({
[17:39:28.192]             c <- base::c
[17:39:28.192]             inherits <- base::inherits
[17:39:28.192]             invokeRestart <- base::invokeRestart
[17:39:28.192]             length <- base::length
[17:39:28.192]             list <- base::list
[17:39:28.192]             seq.int <- base::seq.int
[17:39:28.192]             signalCondition <- base::signalCondition
[17:39:28.192]             sys.calls <- base::sys.calls
[17:39:28.192]             `[[` <- base::`[[`
[17:39:28.192]             `+` <- base::`+`
[17:39:28.192]             `<<-` <- base::`<<-`
[17:39:28.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.192]                   3L)]
[17:39:28.192]             }
[17:39:28.192]             function(cond) {
[17:39:28.192]                 is_error <- inherits(cond, "error")
[17:39:28.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.192]                   NULL)
[17:39:28.192]                 if (is_error) {
[17:39:28.192]                   sessionInformation <- function() {
[17:39:28.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.192]                       search = base::search(), system = base::Sys.info())
[17:39:28.192]                   }
[17:39:28.192]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.192]                     cond$call), session = sessionInformation(), 
[17:39:28.192]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.192]                   signalCondition(cond)
[17:39:28.192]                 }
[17:39:28.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.192]                 "immediateCondition"))) {
[17:39:28.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.192]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.192]                   if (TRUE && !signal) {
[17:39:28.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.192]                     {
[17:39:28.192]                       inherits <- base::inherits
[17:39:28.192]                       invokeRestart <- base::invokeRestart
[17:39:28.192]                       is.null <- base::is.null
[17:39:28.192]                       muffled <- FALSE
[17:39:28.192]                       if (inherits(cond, "message")) {
[17:39:28.192]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.192]                         if (muffled) 
[17:39:28.192]                           invokeRestart("muffleMessage")
[17:39:28.192]                       }
[17:39:28.192]                       else if (inherits(cond, "warning")) {
[17:39:28.192]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.192]                         if (muffled) 
[17:39:28.192]                           invokeRestart("muffleWarning")
[17:39:28.192]                       }
[17:39:28.192]                       else if (inherits(cond, "condition")) {
[17:39:28.192]                         if (!is.null(pattern)) {
[17:39:28.192]                           computeRestarts <- base::computeRestarts
[17:39:28.192]                           grepl <- base::grepl
[17:39:28.192]                           restarts <- computeRestarts(cond)
[17:39:28.192]                           for (restart in restarts) {
[17:39:28.192]                             name <- restart$name
[17:39:28.192]                             if (is.null(name)) 
[17:39:28.192]                               next
[17:39:28.192]                             if (!grepl(pattern, name)) 
[17:39:28.192]                               next
[17:39:28.192]                             invokeRestart(restart)
[17:39:28.192]                             muffled <- TRUE
[17:39:28.192]                             break
[17:39:28.192]                           }
[17:39:28.192]                         }
[17:39:28.192]                       }
[17:39:28.192]                       invisible(muffled)
[17:39:28.192]                     }
[17:39:28.192]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.192]                   }
[17:39:28.192]                 }
[17:39:28.192]                 else {
[17:39:28.192]                   if (TRUE) {
[17:39:28.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.192]                     {
[17:39:28.192]                       inherits <- base::inherits
[17:39:28.192]                       invokeRestart <- base::invokeRestart
[17:39:28.192]                       is.null <- base::is.null
[17:39:28.192]                       muffled <- FALSE
[17:39:28.192]                       if (inherits(cond, "message")) {
[17:39:28.192]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.192]                         if (muffled) 
[17:39:28.192]                           invokeRestart("muffleMessage")
[17:39:28.192]                       }
[17:39:28.192]                       else if (inherits(cond, "warning")) {
[17:39:28.192]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.192]                         if (muffled) 
[17:39:28.192]                           invokeRestart("muffleWarning")
[17:39:28.192]                       }
[17:39:28.192]                       else if (inherits(cond, "condition")) {
[17:39:28.192]                         if (!is.null(pattern)) {
[17:39:28.192]                           computeRestarts <- base::computeRestarts
[17:39:28.192]                           grepl <- base::grepl
[17:39:28.192]                           restarts <- computeRestarts(cond)
[17:39:28.192]                           for (restart in restarts) {
[17:39:28.192]                             name <- restart$name
[17:39:28.192]                             if (is.null(name)) 
[17:39:28.192]                               next
[17:39:28.192]                             if (!grepl(pattern, name)) 
[17:39:28.192]                               next
[17:39:28.192]                             invokeRestart(restart)
[17:39:28.192]                             muffled <- TRUE
[17:39:28.192]                             break
[17:39:28.192]                           }
[17:39:28.192]                         }
[17:39:28.192]                       }
[17:39:28.192]                       invisible(muffled)
[17:39:28.192]                     }
[17:39:28.192]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.192]                   }
[17:39:28.192]                 }
[17:39:28.192]             }
[17:39:28.192]         }))
[17:39:28.192]     }, error = function(ex) {
[17:39:28.192]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.192]                 ...future.rng), started = ...future.startTime, 
[17:39:28.192]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.192]             version = "1.8"), class = "FutureResult")
[17:39:28.192]     }, finally = {
[17:39:28.192]         if (!identical(...future.workdir, getwd())) 
[17:39:28.192]             setwd(...future.workdir)
[17:39:28.192]         {
[17:39:28.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.192]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.192]             }
[17:39:28.192]             base::options(...future.oldOptions)
[17:39:28.192]             if (.Platform$OS.type == "windows") {
[17:39:28.192]                 old_names <- names(...future.oldEnvVars)
[17:39:28.192]                 envs <- base::Sys.getenv()
[17:39:28.192]                 names <- names(envs)
[17:39:28.192]                 common <- intersect(names, old_names)
[17:39:28.192]                 added <- setdiff(names, old_names)
[17:39:28.192]                 removed <- setdiff(old_names, names)
[17:39:28.192]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.192]                   envs[common]]
[17:39:28.192]                 NAMES <- toupper(changed)
[17:39:28.192]                 args <- list()
[17:39:28.192]                 for (kk in seq_along(NAMES)) {
[17:39:28.192]                   name <- changed[[kk]]
[17:39:28.192]                   NAME <- NAMES[[kk]]
[17:39:28.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.192]                     next
[17:39:28.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.192]                 }
[17:39:28.192]                 NAMES <- toupper(added)
[17:39:28.192]                 for (kk in seq_along(NAMES)) {
[17:39:28.192]                   name <- added[[kk]]
[17:39:28.192]                   NAME <- NAMES[[kk]]
[17:39:28.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.192]                     next
[17:39:28.192]                   args[[name]] <- ""
[17:39:28.192]                 }
[17:39:28.192]                 NAMES <- toupper(removed)
[17:39:28.192]                 for (kk in seq_along(NAMES)) {
[17:39:28.192]                   name <- removed[[kk]]
[17:39:28.192]                   NAME <- NAMES[[kk]]
[17:39:28.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.192]                     next
[17:39:28.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.192]                 }
[17:39:28.192]                 if (length(args) > 0) 
[17:39:28.192]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.192]             }
[17:39:28.192]             else {
[17:39:28.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.192]             }
[17:39:28.192]             {
[17:39:28.192]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.192]                   0L) {
[17:39:28.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.192]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.192]                   base::options(opts)
[17:39:28.192]                 }
[17:39:28.192]                 {
[17:39:28.192]                   {
[17:39:28.192]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:28.192]                     NULL
[17:39:28.192]                   }
[17:39:28.192]                   options(future.plan = NULL)
[17:39:28.192]                   if (is.na(NA_character_)) 
[17:39:28.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.192]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:28.192]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:28.192]                     envir = parent.frame()) 
[17:39:28.192]                   {
[17:39:28.192]                     if (is.function(workers)) 
[17:39:28.192]                       workers <- workers()
[17:39:28.192]                     workers <- structure(as.integer(workers), 
[17:39:28.192]                       class = class(workers))
[17:39:28.192]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:28.192]                       workers >= 1)
[17:39:28.192]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:28.192]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:28.192]                     }
[17:39:28.192]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:28.192]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:28.192]                       envir = envir)
[17:39:28.192]                     if (!future$lazy) 
[17:39:28.192]                       future <- run(future)
[17:39:28.192]                     invisible(future)
[17:39:28.192]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.192]                 }
[17:39:28.192]             }
[17:39:28.192]         }
[17:39:28.192]     })
[17:39:28.192]     if (TRUE) {
[17:39:28.192]         base::sink(type = "output", split = FALSE)
[17:39:28.192]         if (TRUE) {
[17:39:28.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.192]         }
[17:39:28.192]         else {
[17:39:28.192]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.192]         }
[17:39:28.192]         base::close(...future.stdout)
[17:39:28.192]         ...future.stdout <- NULL
[17:39:28.192]     }
[17:39:28.192]     ...future.result$conditions <- ...future.conditions
[17:39:28.192]     ...future.result$finished <- base::Sys.time()
[17:39:28.192]     ...future.result
[17:39:28.192] }
[17:39:28.195] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:39:28.195] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:39:28.196] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:39:28.196] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:28.196] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:28.197] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:39:28.197] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:39:28.197] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:28.197] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:28.198] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:28.198] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:28.198] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:39:28.198] MultisessionFuture started
[17:39:28.199] - Launch lazy future ... done
[17:39:28.199] run() for ‘MultisessionFuture’ ... done
[17:39:28.199] Created future:
[17:39:28.199] MultisessionFuture:
[17:39:28.199] Label: ‘future_by-2’
[17:39:28.199] Expression:
[17:39:28.199] {
[17:39:28.199]     do.call(function(...) {
[17:39:28.199]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.199]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.199]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.199]             on.exit(options(oopts), add = TRUE)
[17:39:28.199]         }
[17:39:28.199]         {
[17:39:28.199]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.199]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.199]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.199]             })
[17:39:28.199]         }
[17:39:28.199]     }, args = future.call.arguments)
[17:39:28.199] }
[17:39:28.199] Lazy evaluation: FALSE
[17:39:28.199] Asynchronous evaluation: TRUE
[17:39:28.199] Local evaluation: TRUE
[17:39:28.199] Environment: 0x562972100ff0
[17:39:28.199] Capture standard output: TRUE
[17:39:28.199] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.199] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:28.199] Packages: <none>
[17:39:28.199] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.199] Resolved: FALSE
[17:39:28.199] Value: <not collected>
[17:39:28.199] Conditions captured: <none>
[17:39:28.199] Early signaling: FALSE
[17:39:28.199] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:28.199] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.212] Chunk #2 of 2 ... DONE
[17:39:28.212] Launching 2 futures (chunks) ... DONE
[17:39:28.212] Resolving 2 futures (chunks) ...
[17:39:28.212] resolve() on list ...
[17:39:28.212]  recursive: 0
[17:39:28.212]  length: 2
[17:39:28.212] 
[17:39:28.213] receiveMessageFromWorker() for ClusterFuture ...
[17:39:28.213] - Validating connection of MultisessionFuture
[17:39:28.213] - received message: FutureResult
[17:39:28.213] - Received FutureResult
[17:39:28.213] - Erased future from FutureRegistry
[17:39:28.215] result() for ClusterFuture ...
[17:39:28.216] - result already collected: FutureResult
[17:39:28.216] result() for ClusterFuture ... done
[17:39:28.216] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:28.216] Future #1
[17:39:28.216] result() for ClusterFuture ...
[17:39:28.216] - result already collected: FutureResult
[17:39:28.216] result() for ClusterFuture ... done
[17:39:28.216] result() for ClusterFuture ...
[17:39:28.216] - result already collected: FutureResult
[17:39:28.216] result() for ClusterFuture ... done
[17:39:28.216] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:28.217] - nx: 2
[17:39:28.217] - relay: TRUE
[17:39:28.217] - stdout: TRUE
[17:39:28.217] - signal: TRUE
[17:39:28.217] - resignal: FALSE
[17:39:28.217] - force: TRUE
[17:39:28.217] - relayed: [n=2] FALSE, FALSE
[17:39:28.217] - queued futures: [n=2] FALSE, FALSE
[17:39:28.217]  - until=1
[17:39:28.217]  - relaying element #1
[17:39:28.217] result() for ClusterFuture ...
[17:39:28.217] - result already collected: FutureResult
[17:39:28.218] result() for ClusterFuture ... done
[17:39:28.218] result() for ClusterFuture ...
[17:39:28.218] - result already collected: FutureResult
[17:39:28.218] result() for ClusterFuture ... done
[17:39:28.218] result() for ClusterFuture ...
[17:39:28.218] - result already collected: FutureResult
[17:39:28.218] result() for ClusterFuture ... done
[17:39:28.218] result() for ClusterFuture ...
[17:39:28.218] - result already collected: FutureResult
[17:39:28.218] result() for ClusterFuture ... done
[17:39:28.218] - relayed: [n=2] TRUE, FALSE
[17:39:28.219] - queued futures: [n=2] TRUE, FALSE
[17:39:28.219] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:28.219]  length: 1 (resolved future 1)
[17:39:28.245] receiveMessageFromWorker() for ClusterFuture ...
[17:39:28.245] - Validating connection of MultisessionFuture
[17:39:28.245] - received message: FutureResult
[17:39:28.245] - Received FutureResult
[17:39:28.245] - Erased future from FutureRegistry
[17:39:28.245] result() for ClusterFuture ...
[17:39:28.246] - result already collected: FutureResult
[17:39:28.246] result() for ClusterFuture ... done
[17:39:28.246] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:28.246] Future #2
[17:39:28.246] result() for ClusterFuture ...
[17:39:28.246] - result already collected: FutureResult
[17:39:28.246] result() for ClusterFuture ... done
[17:39:28.246] result() for ClusterFuture ...
[17:39:28.246] - result already collected: FutureResult
[17:39:28.246] result() for ClusterFuture ... done
[17:39:28.246] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:28.246] - nx: 2
[17:39:28.247] - relay: TRUE
[17:39:28.247] - stdout: TRUE
[17:39:28.247] - signal: TRUE
[17:39:28.247] - resignal: FALSE
[17:39:28.247] - force: TRUE
[17:39:28.247] - relayed: [n=2] TRUE, FALSE
[17:39:28.247] - queued futures: [n=2] TRUE, FALSE
[17:39:28.247]  - until=2
[17:39:28.247]  - relaying element #2
[17:39:28.247] result() for ClusterFuture ...
[17:39:28.247] - result already collected: FutureResult
[17:39:28.248] result() for ClusterFuture ... done
[17:39:28.248] result() for ClusterFuture ...
[17:39:28.248] - result already collected: FutureResult
[17:39:28.248] result() for ClusterFuture ... done
[17:39:28.248] result() for ClusterFuture ...
[17:39:28.248] - result already collected: FutureResult
[17:39:28.248] result() for ClusterFuture ... done
[17:39:28.248] result() for ClusterFuture ...
[17:39:28.248] - result already collected: FutureResult
[17:39:28.248] result() for ClusterFuture ... done
[17:39:28.248] - relayed: [n=2] TRUE, TRUE
[17:39:28.248] - queued futures: [n=2] TRUE, TRUE
[17:39:28.249] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:28.249]  length: 0 (resolved future 2)
[17:39:28.249] Relaying remaining futures
[17:39:28.249] signalConditionsASAP(NULL, pos=0) ...
[17:39:28.249] - nx: 2
[17:39:28.249] - relay: TRUE
[17:39:28.249] - stdout: TRUE
[17:39:28.249] - signal: TRUE
[17:39:28.249] - resignal: FALSE
[17:39:28.249] - force: TRUE
[17:39:28.249] - relayed: [n=2] TRUE, TRUE
[17:39:28.249] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:28.250] - relayed: [n=2] TRUE, TRUE
[17:39:28.250] - queued futures: [n=2] TRUE, TRUE
[17:39:28.250] signalConditionsASAP(NULL, pos=0) ... done
[17:39:28.250] resolve() on list ... DONE
[17:39:28.250] result() for ClusterFuture ...
[17:39:28.250] - result already collected: FutureResult
[17:39:28.250] result() for ClusterFuture ... done
[17:39:28.250] result() for ClusterFuture ...
[17:39:28.250] - result already collected: FutureResult
[17:39:28.250] result() for ClusterFuture ... done
[17:39:28.250] result() for ClusterFuture ...
[17:39:28.251] - result already collected: FutureResult
[17:39:28.251] result() for ClusterFuture ... done
[17:39:28.251] result() for ClusterFuture ...
[17:39:28.251] - result already collected: FutureResult
[17:39:28.251] result() for ClusterFuture ... done
[17:39:28.251]  - Number of value chunks collected: 2
[17:39:28.251] Resolving 2 futures (chunks) ... DONE
[17:39:28.251] Reducing values from 2 chunks ...
[17:39:28.251]  - Number of values collected after concatenation: 3
[17:39:28.251]  - Number of values expected: 3
[17:39:28.251] Reducing values from 2 chunks ... DONE
[17:39:28.252] future_lapply() ... DONE
[17:39:28.252] future_by_internal() ... DONE
[17:39:28.252] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:39:28.253] future_lapply() ...
[17:39:28.257] Number of chunks: 2
[17:39:28.257] getGlobalsAndPackagesXApply() ...
[17:39:28.257]  - future.globals: TRUE
[17:39:28.257] getGlobalsAndPackages() ...
[17:39:28.257] Searching for globals...
[17:39:28.258] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:28.258] Searching for globals ... DONE
[17:39:28.258] Resolving globals: FALSE
[17:39:28.259] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:39:28.259] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:39:28.259] - globals: [1] ‘FUN’
[17:39:28.259] 
[17:39:28.259] getGlobalsAndPackages() ... DONE
[17:39:28.259]  - globals found/used: [n=1] ‘FUN’
[17:39:28.260]  - needed namespaces: [n=0] 
[17:39:28.260] Finding globals ... DONE
[17:39:28.260]  - use_args: TRUE
[17:39:28.260]  - Getting '...' globals ...
[17:39:28.260] resolve() on list ...
[17:39:28.260]  recursive: 0
[17:39:28.260]  length: 1
[17:39:28.260]  elements: ‘...’
[17:39:28.260]  length: 0 (resolved future 1)
[17:39:28.261] resolve() on list ... DONE
[17:39:28.261]    - '...' content: [n=0] 
[17:39:28.261] List of 1
[17:39:28.261]  $ ...: list()
[17:39:28.261]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.261]  - attr(*, "where")=List of 1
[17:39:28.261]   ..$ ...:<environment: 0x5629729bf730> 
[17:39:28.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.261]  - attr(*, "resolved")= logi TRUE
[17:39:28.261]  - attr(*, "total_size")= num NA
[17:39:28.263]  - Getting '...' globals ... DONE
[17:39:28.263] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:28.264] List of 2
[17:39:28.264]  $ ...future.FUN:function (object, ...)  
[17:39:28.264]  $ ...          : list()
[17:39:28.264]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:28.264]  - attr(*, "where")=List of 2
[17:39:28.264]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:28.264]   ..$ ...          :<environment: 0x5629729bf730> 
[17:39:28.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:28.264]  - attr(*, "resolved")= logi FALSE
[17:39:28.264]  - attr(*, "total_size")= num 1240
[17:39:28.266] Packages to be attached in all futures: [n=0] 
[17:39:28.266] getGlobalsAndPackagesXApply() ... DONE
[17:39:28.266] Number of futures (= number of chunks): 2
[17:39:28.266] Launching 2 futures (chunks) ...
[17:39:28.267] Chunk #1 of 2 ...
[17:39:28.267]  - Finding globals in 'X' for chunk #1 ...
[17:39:28.267] getGlobalsAndPackages() ...
[17:39:28.267] Searching for globals...
[17:39:28.267] 
[17:39:28.267] Searching for globals ... DONE
[17:39:28.267] - globals: [0] <none>
[17:39:28.267] getGlobalsAndPackages() ... DONE
[17:39:28.268]    + additional globals found: [n=0] 
[17:39:28.268]    + additional namespaces needed: [n=0] 
[17:39:28.268]  - Finding globals in 'X' for chunk #1 ... DONE
[17:39:28.268]  - seeds: <none>
[17:39:28.268] getGlobalsAndPackages() ...
[17:39:28.268] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.268] Resolving globals: FALSE
[17:39:28.268] Tweak future expression to call with '...' arguments ...
[17:39:28.268] {
[17:39:28.268]     do.call(function(...) {
[17:39:28.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.268]             on.exit(options(oopts), add = TRUE)
[17:39:28.268]         }
[17:39:28.268]         {
[17:39:28.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.268]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.268]             })
[17:39:28.268]         }
[17:39:28.268]     }, args = future.call.arguments)
[17:39:28.268] }
[17:39:28.269] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.269] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.269] 
[17:39:28.269] getGlobalsAndPackages() ... DONE
[17:39:28.269] run() for ‘Future’ ...
[17:39:28.269] - state: ‘created’
[17:39:28.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:28.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:28.284]   - Field: ‘node’
[17:39:28.284]   - Field: ‘label’
[17:39:28.284]   - Field: ‘local’
[17:39:28.284]   - Field: ‘owner’
[17:39:28.284]   - Field: ‘envir’
[17:39:28.284]   - Field: ‘workers’
[17:39:28.284]   - Field: ‘packages’
[17:39:28.284]   - Field: ‘gc’
[17:39:28.285]   - Field: ‘conditions’
[17:39:28.285]   - Field: ‘persistent’
[17:39:28.285]   - Field: ‘expr’
[17:39:28.285]   - Field: ‘uuid’
[17:39:28.285]   - Field: ‘seed’
[17:39:28.285]   - Field: ‘version’
[17:39:28.285]   - Field: ‘result’
[17:39:28.285]   - Field: ‘asynchronous’
[17:39:28.285]   - Field: ‘calls’
[17:39:28.285]   - Field: ‘globals’
[17:39:28.285]   - Field: ‘stdout’
[17:39:28.286]   - Field: ‘earlySignal’
[17:39:28.286]   - Field: ‘lazy’
[17:39:28.286]   - Field: ‘state’
[17:39:28.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:28.286] - Launch lazy future ...
[17:39:28.286] Packages needed by the future expression (n = 0): <none>
[17:39:28.286] Packages needed by future strategies (n = 0): <none>
[17:39:28.287] {
[17:39:28.287]     {
[17:39:28.287]         {
[17:39:28.287]             ...future.startTime <- base::Sys.time()
[17:39:28.287]             {
[17:39:28.287]                 {
[17:39:28.287]                   {
[17:39:28.287]                     {
[17:39:28.287]                       base::local({
[17:39:28.287]                         has_future <- base::requireNamespace("future", 
[17:39:28.287]                           quietly = TRUE)
[17:39:28.287]                         if (has_future) {
[17:39:28.287]                           ns <- base::getNamespace("future")
[17:39:28.287]                           version <- ns[[".package"]][["version"]]
[17:39:28.287]                           if (is.null(version)) 
[17:39:28.287]                             version <- utils::packageVersion("future")
[17:39:28.287]                         }
[17:39:28.287]                         else {
[17:39:28.287]                           version <- NULL
[17:39:28.287]                         }
[17:39:28.287]                         if (!has_future || version < "1.8.0") {
[17:39:28.287]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.287]                             "", base::R.version$version.string), 
[17:39:28.287]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:28.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:28.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.287]                               "release", "version")], collapse = " "), 
[17:39:28.287]                             hostname = base::Sys.info()[["nodename"]])
[17:39:28.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.287]                             info)
[17:39:28.287]                           info <- base::paste(info, collapse = "; ")
[17:39:28.287]                           if (!has_future) {
[17:39:28.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.287]                               info)
[17:39:28.287]                           }
[17:39:28.287]                           else {
[17:39:28.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.287]                               info, version)
[17:39:28.287]                           }
[17:39:28.287]                           base::stop(msg)
[17:39:28.287]                         }
[17:39:28.287]                       })
[17:39:28.287]                     }
[17:39:28.287]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:28.287]                     base::options(mc.cores = 1L)
[17:39:28.287]                   }
[17:39:28.287]                   options(future.plan = NULL)
[17:39:28.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.287]                 }
[17:39:28.287]                 ...future.workdir <- getwd()
[17:39:28.287]             }
[17:39:28.287]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.287]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.287]         }
[17:39:28.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:28.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.287]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.287]             base::names(...future.oldOptions))
[17:39:28.287]     }
[17:39:28.287]     if (FALSE) {
[17:39:28.287]     }
[17:39:28.287]     else {
[17:39:28.287]         if (TRUE) {
[17:39:28.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.287]                 open = "w")
[17:39:28.287]         }
[17:39:28.287]         else {
[17:39:28.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.287]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.287]         }
[17:39:28.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.287]             base::sink(type = "output", split = FALSE)
[17:39:28.287]             base::close(...future.stdout)
[17:39:28.287]         }, add = TRUE)
[17:39:28.287]     }
[17:39:28.287]     ...future.frame <- base::sys.nframe()
[17:39:28.287]     ...future.conditions <- base::list()
[17:39:28.287]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.287]     if (FALSE) {
[17:39:28.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.287]     }
[17:39:28.287]     ...future.result <- base::tryCatch({
[17:39:28.287]         base::withCallingHandlers({
[17:39:28.287]             ...future.value <- base::withVisible(base::local({
[17:39:28.287]                 ...future.makeSendCondition <- local({
[17:39:28.287]                   sendCondition <- NULL
[17:39:28.287]                   function(frame = 1L) {
[17:39:28.287]                     if (is.function(sendCondition)) 
[17:39:28.287]                       return(sendCondition)
[17:39:28.287]                     ns <- getNamespace("parallel")
[17:39:28.287]                     if (exists("sendData", mode = "function", 
[17:39:28.287]                       envir = ns)) {
[17:39:28.287]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:28.287]                         envir = ns)
[17:39:28.287]                       envir <- sys.frame(frame)
[17:39:28.287]                       master <- NULL
[17:39:28.287]                       while (!identical(envir, .GlobalEnv) && 
[17:39:28.287]                         !identical(envir, emptyenv())) {
[17:39:28.287]                         if (exists("master", mode = "list", envir = envir, 
[17:39:28.287]                           inherits = FALSE)) {
[17:39:28.287]                           master <- get("master", mode = "list", 
[17:39:28.287]                             envir = envir, inherits = FALSE)
[17:39:28.287]                           if (inherits(master, c("SOCKnode", 
[17:39:28.287]                             "SOCK0node"))) {
[17:39:28.287]                             sendCondition <<- function(cond) {
[17:39:28.287]                               data <- list(type = "VALUE", value = cond, 
[17:39:28.287]                                 success = TRUE)
[17:39:28.287]                               parallel_sendData(master, data)
[17:39:28.287]                             }
[17:39:28.287]                             return(sendCondition)
[17:39:28.287]                           }
[17:39:28.287]                         }
[17:39:28.287]                         frame <- frame + 1L
[17:39:28.287]                         envir <- sys.frame(frame)
[17:39:28.287]                       }
[17:39:28.287]                     }
[17:39:28.287]                     sendCondition <<- function(cond) NULL
[17:39:28.287]                   }
[17:39:28.287]                 })
[17:39:28.287]                 withCallingHandlers({
[17:39:28.287]                   {
[17:39:28.287]                     do.call(function(...) {
[17:39:28.287]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.287]                       if (!identical(...future.globals.maxSize.org, 
[17:39:28.287]                         ...future.globals.maxSize)) {
[17:39:28.287]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.287]                         on.exit(options(oopts), add = TRUE)
[17:39:28.287]                       }
[17:39:28.287]                       {
[17:39:28.287]                         lapply(seq_along(...future.elements_ii), 
[17:39:28.287]                           FUN = function(jj) {
[17:39:28.287]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.287]                             ...future.FUN(...future.X_jj, ...)
[17:39:28.287]                           })
[17:39:28.287]                       }
[17:39:28.287]                     }, args = future.call.arguments)
[17:39:28.287]                   }
[17:39:28.287]                 }, immediateCondition = function(cond) {
[17:39:28.287]                   sendCondition <- ...future.makeSendCondition()
[17:39:28.287]                   sendCondition(cond)
[17:39:28.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.287]                   {
[17:39:28.287]                     inherits <- base::inherits
[17:39:28.287]                     invokeRestart <- base::invokeRestart
[17:39:28.287]                     is.null <- base::is.null
[17:39:28.287]                     muffled <- FALSE
[17:39:28.287]                     if (inherits(cond, "message")) {
[17:39:28.287]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:28.287]                       if (muffled) 
[17:39:28.287]                         invokeRestart("muffleMessage")
[17:39:28.287]                     }
[17:39:28.287]                     else if (inherits(cond, "warning")) {
[17:39:28.287]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:28.287]                       if (muffled) 
[17:39:28.287]                         invokeRestart("muffleWarning")
[17:39:28.287]                     }
[17:39:28.287]                     else if (inherits(cond, "condition")) {
[17:39:28.287]                       if (!is.null(pattern)) {
[17:39:28.287]                         computeRestarts <- base::computeRestarts
[17:39:28.287]                         grepl <- base::grepl
[17:39:28.287]                         restarts <- computeRestarts(cond)
[17:39:28.287]                         for (restart in restarts) {
[17:39:28.287]                           name <- restart$name
[17:39:28.287]                           if (is.null(name)) 
[17:39:28.287]                             next
[17:39:28.287]                           if (!grepl(pattern, name)) 
[17:39:28.287]                             next
[17:39:28.287]                           invokeRestart(restart)
[17:39:28.287]                           muffled <- TRUE
[17:39:28.287]                           break
[17:39:28.287]                         }
[17:39:28.287]                       }
[17:39:28.287]                     }
[17:39:28.287]                     invisible(muffled)
[17:39:28.287]                   }
[17:39:28.287]                   muffleCondition(cond)
[17:39:28.287]                 })
[17:39:28.287]             }))
[17:39:28.287]             future::FutureResult(value = ...future.value$value, 
[17:39:28.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.287]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.287]                     ...future.globalenv.names))
[17:39:28.287]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.287]         }, condition = base::local({
[17:39:28.287]             c <- base::c
[17:39:28.287]             inherits <- base::inherits
[17:39:28.287]             invokeRestart <- base::invokeRestart
[17:39:28.287]             length <- base::length
[17:39:28.287]             list <- base::list
[17:39:28.287]             seq.int <- base::seq.int
[17:39:28.287]             signalCondition <- base::signalCondition
[17:39:28.287]             sys.calls <- base::sys.calls
[17:39:28.287]             `[[` <- base::`[[`
[17:39:28.287]             `+` <- base::`+`
[17:39:28.287]             `<<-` <- base::`<<-`
[17:39:28.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.287]                   3L)]
[17:39:28.287]             }
[17:39:28.287]             function(cond) {
[17:39:28.287]                 is_error <- inherits(cond, "error")
[17:39:28.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.287]                   NULL)
[17:39:28.287]                 if (is_error) {
[17:39:28.287]                   sessionInformation <- function() {
[17:39:28.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.287]                       search = base::search(), system = base::Sys.info())
[17:39:28.287]                   }
[17:39:28.287]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.287]                     cond$call), session = sessionInformation(), 
[17:39:28.287]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.287]                   signalCondition(cond)
[17:39:28.287]                 }
[17:39:28.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.287]                 "immediateCondition"))) {
[17:39:28.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.287]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.287]                   if (TRUE && !signal) {
[17:39:28.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.287]                     {
[17:39:28.287]                       inherits <- base::inherits
[17:39:28.287]                       invokeRestart <- base::invokeRestart
[17:39:28.287]                       is.null <- base::is.null
[17:39:28.287]                       muffled <- FALSE
[17:39:28.287]                       if (inherits(cond, "message")) {
[17:39:28.287]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.287]                         if (muffled) 
[17:39:28.287]                           invokeRestart("muffleMessage")
[17:39:28.287]                       }
[17:39:28.287]                       else if (inherits(cond, "warning")) {
[17:39:28.287]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.287]                         if (muffled) 
[17:39:28.287]                           invokeRestart("muffleWarning")
[17:39:28.287]                       }
[17:39:28.287]                       else if (inherits(cond, "condition")) {
[17:39:28.287]                         if (!is.null(pattern)) {
[17:39:28.287]                           computeRestarts <- base::computeRestarts
[17:39:28.287]                           grepl <- base::grepl
[17:39:28.287]                           restarts <- computeRestarts(cond)
[17:39:28.287]                           for (restart in restarts) {
[17:39:28.287]                             name <- restart$name
[17:39:28.287]                             if (is.null(name)) 
[17:39:28.287]                               next
[17:39:28.287]                             if (!grepl(pattern, name)) 
[17:39:28.287]                               next
[17:39:28.287]                             invokeRestart(restart)
[17:39:28.287]                             muffled <- TRUE
[17:39:28.287]                             break
[17:39:28.287]                           }
[17:39:28.287]                         }
[17:39:28.287]                       }
[17:39:28.287]                       invisible(muffled)
[17:39:28.287]                     }
[17:39:28.287]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.287]                   }
[17:39:28.287]                 }
[17:39:28.287]                 else {
[17:39:28.287]                   if (TRUE) {
[17:39:28.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.287]                     {
[17:39:28.287]                       inherits <- base::inherits
[17:39:28.287]                       invokeRestart <- base::invokeRestart
[17:39:28.287]                       is.null <- base::is.null
[17:39:28.287]                       muffled <- FALSE
[17:39:28.287]                       if (inherits(cond, "message")) {
[17:39:28.287]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.287]                         if (muffled) 
[17:39:28.287]                           invokeRestart("muffleMessage")
[17:39:28.287]                       }
[17:39:28.287]                       else if (inherits(cond, "warning")) {
[17:39:28.287]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.287]                         if (muffled) 
[17:39:28.287]                           invokeRestart("muffleWarning")
[17:39:28.287]                       }
[17:39:28.287]                       else if (inherits(cond, "condition")) {
[17:39:28.287]                         if (!is.null(pattern)) {
[17:39:28.287]                           computeRestarts <- base::computeRestarts
[17:39:28.287]                           grepl <- base::grepl
[17:39:28.287]                           restarts <- computeRestarts(cond)
[17:39:28.287]                           for (restart in restarts) {
[17:39:28.287]                             name <- restart$name
[17:39:28.287]                             if (is.null(name)) 
[17:39:28.287]                               next
[17:39:28.287]                             if (!grepl(pattern, name)) 
[17:39:28.287]                               next
[17:39:28.287]                             invokeRestart(restart)
[17:39:28.287]                             muffled <- TRUE
[17:39:28.287]                             break
[17:39:28.287]                           }
[17:39:28.287]                         }
[17:39:28.287]                       }
[17:39:28.287]                       invisible(muffled)
[17:39:28.287]                     }
[17:39:28.287]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.287]                   }
[17:39:28.287]                 }
[17:39:28.287]             }
[17:39:28.287]         }))
[17:39:28.287]     }, error = function(ex) {
[17:39:28.287]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.287]                 ...future.rng), started = ...future.startTime, 
[17:39:28.287]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.287]             version = "1.8"), class = "FutureResult")
[17:39:28.287]     }, finally = {
[17:39:28.287]         if (!identical(...future.workdir, getwd())) 
[17:39:28.287]             setwd(...future.workdir)
[17:39:28.287]         {
[17:39:28.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.287]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.287]             }
[17:39:28.287]             base::options(...future.oldOptions)
[17:39:28.287]             if (.Platform$OS.type == "windows") {
[17:39:28.287]                 old_names <- names(...future.oldEnvVars)
[17:39:28.287]                 envs <- base::Sys.getenv()
[17:39:28.287]                 names <- names(envs)
[17:39:28.287]                 common <- intersect(names, old_names)
[17:39:28.287]                 added <- setdiff(names, old_names)
[17:39:28.287]                 removed <- setdiff(old_names, names)
[17:39:28.287]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.287]                   envs[common]]
[17:39:28.287]                 NAMES <- toupper(changed)
[17:39:28.287]                 args <- list()
[17:39:28.287]                 for (kk in seq_along(NAMES)) {
[17:39:28.287]                   name <- changed[[kk]]
[17:39:28.287]                   NAME <- NAMES[[kk]]
[17:39:28.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.287]                     next
[17:39:28.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.287]                 }
[17:39:28.287]                 NAMES <- toupper(added)
[17:39:28.287]                 for (kk in seq_along(NAMES)) {
[17:39:28.287]                   name <- added[[kk]]
[17:39:28.287]                   NAME <- NAMES[[kk]]
[17:39:28.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.287]                     next
[17:39:28.287]                   args[[name]] <- ""
[17:39:28.287]                 }
[17:39:28.287]                 NAMES <- toupper(removed)
[17:39:28.287]                 for (kk in seq_along(NAMES)) {
[17:39:28.287]                   name <- removed[[kk]]
[17:39:28.287]                   NAME <- NAMES[[kk]]
[17:39:28.287]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.287]                     next
[17:39:28.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.287]                 }
[17:39:28.287]                 if (length(args) > 0) 
[17:39:28.287]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.287]             }
[17:39:28.287]             else {
[17:39:28.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.287]             }
[17:39:28.287]             {
[17:39:28.287]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.287]                   0L) {
[17:39:28.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.287]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.287]                   base::options(opts)
[17:39:28.287]                 }
[17:39:28.287]                 {
[17:39:28.287]                   {
[17:39:28.287]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:28.287]                     NULL
[17:39:28.287]                   }
[17:39:28.287]                   options(future.plan = NULL)
[17:39:28.287]                   if (is.na(NA_character_)) 
[17:39:28.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.287]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:28.287]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:28.287]                     envir = parent.frame()) 
[17:39:28.287]                   {
[17:39:28.287]                     if (is.function(workers)) 
[17:39:28.287]                       workers <- workers()
[17:39:28.287]                     workers <- structure(as.integer(workers), 
[17:39:28.287]                       class = class(workers))
[17:39:28.287]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:28.287]                       workers >= 1)
[17:39:28.287]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:28.287]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:28.287]                     }
[17:39:28.287]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:28.287]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:28.287]                       envir = envir)
[17:39:28.287]                     if (!future$lazy) 
[17:39:28.287]                       future <- run(future)
[17:39:28.287]                     invisible(future)
[17:39:28.287]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.287]                 }
[17:39:28.287]             }
[17:39:28.287]         }
[17:39:28.287]     })
[17:39:28.287]     if (TRUE) {
[17:39:28.287]         base::sink(type = "output", split = FALSE)
[17:39:28.287]         if (TRUE) {
[17:39:28.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.287]         }
[17:39:28.287]         else {
[17:39:28.287]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.287]         }
[17:39:28.287]         base::close(...future.stdout)
[17:39:28.287]         ...future.stdout <- NULL
[17:39:28.287]     }
[17:39:28.287]     ...future.result$conditions <- ...future.conditions
[17:39:28.287]     ...future.result$finished <- base::Sys.time()
[17:39:28.287]     ...future.result
[17:39:28.287] }
[17:39:28.289] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:39:28.290] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:39:28.290] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:39:28.290] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:28.291] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:28.291] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:39:28.291] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:39:28.291] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:28.292] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:28.292] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:28.292] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:28.292] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:39:28.293] MultisessionFuture started
[17:39:28.293] - Launch lazy future ... done
[17:39:28.293] run() for ‘MultisessionFuture’ ... done
[17:39:28.293] Created future:
[17:39:28.293] MultisessionFuture:
[17:39:28.293] Label: ‘future_by-1’
[17:39:28.293] Expression:
[17:39:28.293] {
[17:39:28.293]     do.call(function(...) {
[17:39:28.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.293]             on.exit(options(oopts), add = TRUE)
[17:39:28.293]         }
[17:39:28.293]         {
[17:39:28.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.293]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.293]             })
[17:39:28.293]         }
[17:39:28.293]     }, args = future.call.arguments)
[17:39:28.293] }
[17:39:28.293] Lazy evaluation: FALSE
[17:39:28.293] Asynchronous evaluation: TRUE
[17:39:28.293] Local evaluation: TRUE
[17:39:28.293] Environment: 0x5629729f0cd8
[17:39:28.293] Capture standard output: TRUE
[17:39:28.293] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.293] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:28.293] Packages: <none>
[17:39:28.293] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.293] Resolved: FALSE
[17:39:28.293] Value: <not collected>
[17:39:28.293] Conditions captured: <none>
[17:39:28.293] Early signaling: FALSE
[17:39:28.293] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:28.293] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.305] Chunk #1 of 2 ... DONE
[17:39:28.305] Chunk #2 of 2 ...
[17:39:28.305]  - Finding globals in 'X' for chunk #2 ...
[17:39:28.305] getGlobalsAndPackages() ...
[17:39:28.305] Searching for globals...
[17:39:28.306] 
[17:39:28.306] Searching for globals ... DONE
[17:39:28.306] - globals: [0] <none>
[17:39:28.306] getGlobalsAndPackages() ... DONE
[17:39:28.306]    + additional globals found: [n=0] 
[17:39:28.306]    + additional namespaces needed: [n=0] 
[17:39:28.306]  - Finding globals in 'X' for chunk #2 ... DONE
[17:39:28.306]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:39:28.307]  - seeds: <none>
[17:39:28.307] getGlobalsAndPackages() ...
[17:39:28.307] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.307] Resolving globals: FALSE
[17:39:28.307] Tweak future expression to call with '...' arguments ...
[17:39:28.307] {
[17:39:28.307]     do.call(function(...) {
[17:39:28.307]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.307]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.307]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.307]             on.exit(options(oopts), add = TRUE)
[17:39:28.307]         }
[17:39:28.307]         {
[17:39:28.307]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.307]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.307]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.307]             })
[17:39:28.307]         }
[17:39:28.307]     }, args = future.call.arguments)
[17:39:28.307] }
[17:39:28.307] Tweak future expression to call with '...' arguments ... DONE
[17:39:28.308] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:28.308] 
[17:39:28.308] getGlobalsAndPackages() ... DONE
[17:39:28.308] run() for ‘Future’ ...
[17:39:28.308] - state: ‘created’
[17:39:28.308] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:28.322] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:28.323]   - Field: ‘node’
[17:39:28.323]   - Field: ‘label’
[17:39:28.323]   - Field: ‘local’
[17:39:28.323]   - Field: ‘owner’
[17:39:28.323]   - Field: ‘envir’
[17:39:28.323]   - Field: ‘workers’
[17:39:28.323]   - Field: ‘packages’
[17:39:28.323]   - Field: ‘gc’
[17:39:28.323]   - Field: ‘conditions’
[17:39:28.324]   - Field: ‘persistent’
[17:39:28.324]   - Field: ‘expr’
[17:39:28.324]   - Field: ‘uuid’
[17:39:28.324]   - Field: ‘seed’
[17:39:28.324]   - Field: ‘version’
[17:39:28.324]   - Field: ‘result’
[17:39:28.324]   - Field: ‘asynchronous’
[17:39:28.324]   - Field: ‘calls’
[17:39:28.324]   - Field: ‘globals’
[17:39:28.324]   - Field: ‘stdout’
[17:39:28.324]   - Field: ‘earlySignal’
[17:39:28.325]   - Field: ‘lazy’
[17:39:28.325]   - Field: ‘state’
[17:39:28.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:28.325] - Launch lazy future ...
[17:39:28.325] Packages needed by the future expression (n = 0): <none>
[17:39:28.325] Packages needed by future strategies (n = 0): <none>
[17:39:28.326] {
[17:39:28.326]     {
[17:39:28.326]         {
[17:39:28.326]             ...future.startTime <- base::Sys.time()
[17:39:28.326]             {
[17:39:28.326]                 {
[17:39:28.326]                   {
[17:39:28.326]                     {
[17:39:28.326]                       base::local({
[17:39:28.326]                         has_future <- base::requireNamespace("future", 
[17:39:28.326]                           quietly = TRUE)
[17:39:28.326]                         if (has_future) {
[17:39:28.326]                           ns <- base::getNamespace("future")
[17:39:28.326]                           version <- ns[[".package"]][["version"]]
[17:39:28.326]                           if (is.null(version)) 
[17:39:28.326]                             version <- utils::packageVersion("future")
[17:39:28.326]                         }
[17:39:28.326]                         else {
[17:39:28.326]                           version <- NULL
[17:39:28.326]                         }
[17:39:28.326]                         if (!has_future || version < "1.8.0") {
[17:39:28.326]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:28.326]                             "", base::R.version$version.string), 
[17:39:28.326]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:28.326]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:28.326]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:28.326]                               "release", "version")], collapse = " "), 
[17:39:28.326]                             hostname = base::Sys.info()[["nodename"]])
[17:39:28.326]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:28.326]                             info)
[17:39:28.326]                           info <- base::paste(info, collapse = "; ")
[17:39:28.326]                           if (!has_future) {
[17:39:28.326]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:28.326]                               info)
[17:39:28.326]                           }
[17:39:28.326]                           else {
[17:39:28.326]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:28.326]                               info, version)
[17:39:28.326]                           }
[17:39:28.326]                           base::stop(msg)
[17:39:28.326]                         }
[17:39:28.326]                       })
[17:39:28.326]                     }
[17:39:28.326]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:28.326]                     base::options(mc.cores = 1L)
[17:39:28.326]                   }
[17:39:28.326]                   options(future.plan = NULL)
[17:39:28.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:28.326]                 }
[17:39:28.326]                 ...future.workdir <- getwd()
[17:39:28.326]             }
[17:39:28.326]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:28.326]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:28.326]         }
[17:39:28.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:28.326]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:39:28.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:28.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:28.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:28.326]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:28.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:28.326]             base::names(...future.oldOptions))
[17:39:28.326]     }
[17:39:28.326]     if (FALSE) {
[17:39:28.326]     }
[17:39:28.326]     else {
[17:39:28.326]         if (TRUE) {
[17:39:28.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:28.326]                 open = "w")
[17:39:28.326]         }
[17:39:28.326]         else {
[17:39:28.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:28.326]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:28.326]         }
[17:39:28.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:28.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:28.326]             base::sink(type = "output", split = FALSE)
[17:39:28.326]             base::close(...future.stdout)
[17:39:28.326]         }, add = TRUE)
[17:39:28.326]     }
[17:39:28.326]     ...future.frame <- base::sys.nframe()
[17:39:28.326]     ...future.conditions <- base::list()
[17:39:28.326]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:28.326]     if (FALSE) {
[17:39:28.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:28.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:28.326]     }
[17:39:28.326]     ...future.result <- base::tryCatch({
[17:39:28.326]         base::withCallingHandlers({
[17:39:28.326]             ...future.value <- base::withVisible(base::local({
[17:39:28.326]                 ...future.makeSendCondition <- local({
[17:39:28.326]                   sendCondition <- NULL
[17:39:28.326]                   function(frame = 1L) {
[17:39:28.326]                     if (is.function(sendCondition)) 
[17:39:28.326]                       return(sendCondition)
[17:39:28.326]                     ns <- getNamespace("parallel")
[17:39:28.326]                     if (exists("sendData", mode = "function", 
[17:39:28.326]                       envir = ns)) {
[17:39:28.326]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:28.326]                         envir = ns)
[17:39:28.326]                       envir <- sys.frame(frame)
[17:39:28.326]                       master <- NULL
[17:39:28.326]                       while (!identical(envir, .GlobalEnv) && 
[17:39:28.326]                         !identical(envir, emptyenv())) {
[17:39:28.326]                         if (exists("master", mode = "list", envir = envir, 
[17:39:28.326]                           inherits = FALSE)) {
[17:39:28.326]                           master <- get("master", mode = "list", 
[17:39:28.326]                             envir = envir, inherits = FALSE)
[17:39:28.326]                           if (inherits(master, c("SOCKnode", 
[17:39:28.326]                             "SOCK0node"))) {
[17:39:28.326]                             sendCondition <<- function(cond) {
[17:39:28.326]                               data <- list(type = "VALUE", value = cond, 
[17:39:28.326]                                 success = TRUE)
[17:39:28.326]                               parallel_sendData(master, data)
[17:39:28.326]                             }
[17:39:28.326]                             return(sendCondition)
[17:39:28.326]                           }
[17:39:28.326]                         }
[17:39:28.326]                         frame <- frame + 1L
[17:39:28.326]                         envir <- sys.frame(frame)
[17:39:28.326]                       }
[17:39:28.326]                     }
[17:39:28.326]                     sendCondition <<- function(cond) NULL
[17:39:28.326]                   }
[17:39:28.326]                 })
[17:39:28.326]                 withCallingHandlers({
[17:39:28.326]                   {
[17:39:28.326]                     do.call(function(...) {
[17:39:28.326]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.326]                       if (!identical(...future.globals.maxSize.org, 
[17:39:28.326]                         ...future.globals.maxSize)) {
[17:39:28.326]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.326]                         on.exit(options(oopts), add = TRUE)
[17:39:28.326]                       }
[17:39:28.326]                       {
[17:39:28.326]                         lapply(seq_along(...future.elements_ii), 
[17:39:28.326]                           FUN = function(jj) {
[17:39:28.326]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.326]                             ...future.FUN(...future.X_jj, ...)
[17:39:28.326]                           })
[17:39:28.326]                       }
[17:39:28.326]                     }, args = future.call.arguments)
[17:39:28.326]                   }
[17:39:28.326]                 }, immediateCondition = function(cond) {
[17:39:28.326]                   sendCondition <- ...future.makeSendCondition()
[17:39:28.326]                   sendCondition(cond)
[17:39:28.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.326]                   {
[17:39:28.326]                     inherits <- base::inherits
[17:39:28.326]                     invokeRestart <- base::invokeRestart
[17:39:28.326]                     is.null <- base::is.null
[17:39:28.326]                     muffled <- FALSE
[17:39:28.326]                     if (inherits(cond, "message")) {
[17:39:28.326]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:28.326]                       if (muffled) 
[17:39:28.326]                         invokeRestart("muffleMessage")
[17:39:28.326]                     }
[17:39:28.326]                     else if (inherits(cond, "warning")) {
[17:39:28.326]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:28.326]                       if (muffled) 
[17:39:28.326]                         invokeRestart("muffleWarning")
[17:39:28.326]                     }
[17:39:28.326]                     else if (inherits(cond, "condition")) {
[17:39:28.326]                       if (!is.null(pattern)) {
[17:39:28.326]                         computeRestarts <- base::computeRestarts
[17:39:28.326]                         grepl <- base::grepl
[17:39:28.326]                         restarts <- computeRestarts(cond)
[17:39:28.326]                         for (restart in restarts) {
[17:39:28.326]                           name <- restart$name
[17:39:28.326]                           if (is.null(name)) 
[17:39:28.326]                             next
[17:39:28.326]                           if (!grepl(pattern, name)) 
[17:39:28.326]                             next
[17:39:28.326]                           invokeRestart(restart)
[17:39:28.326]                           muffled <- TRUE
[17:39:28.326]                           break
[17:39:28.326]                         }
[17:39:28.326]                       }
[17:39:28.326]                     }
[17:39:28.326]                     invisible(muffled)
[17:39:28.326]                   }
[17:39:28.326]                   muffleCondition(cond)
[17:39:28.326]                 })
[17:39:28.326]             }))
[17:39:28.326]             future::FutureResult(value = ...future.value$value, 
[17:39:28.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.326]                   ...future.rng), globalenv = if (FALSE) 
[17:39:28.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:28.326]                     ...future.globalenv.names))
[17:39:28.326]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:28.326]         }, condition = base::local({
[17:39:28.326]             c <- base::c
[17:39:28.326]             inherits <- base::inherits
[17:39:28.326]             invokeRestart <- base::invokeRestart
[17:39:28.326]             length <- base::length
[17:39:28.326]             list <- base::list
[17:39:28.326]             seq.int <- base::seq.int
[17:39:28.326]             signalCondition <- base::signalCondition
[17:39:28.326]             sys.calls <- base::sys.calls
[17:39:28.326]             `[[` <- base::`[[`
[17:39:28.326]             `+` <- base::`+`
[17:39:28.326]             `<<-` <- base::`<<-`
[17:39:28.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:28.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:28.326]                   3L)]
[17:39:28.326]             }
[17:39:28.326]             function(cond) {
[17:39:28.326]                 is_error <- inherits(cond, "error")
[17:39:28.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:28.326]                   NULL)
[17:39:28.326]                 if (is_error) {
[17:39:28.326]                   sessionInformation <- function() {
[17:39:28.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:28.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:28.326]                       search = base::search(), system = base::Sys.info())
[17:39:28.326]                   }
[17:39:28.326]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:28.326]                     cond$call), session = sessionInformation(), 
[17:39:28.326]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:28.326]                   signalCondition(cond)
[17:39:28.326]                 }
[17:39:28.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:28.326]                 "immediateCondition"))) {
[17:39:28.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:28.326]                   ...future.conditions[[length(...future.conditions) + 
[17:39:28.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:28.326]                   if (TRUE && !signal) {
[17:39:28.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.326]                     {
[17:39:28.326]                       inherits <- base::inherits
[17:39:28.326]                       invokeRestart <- base::invokeRestart
[17:39:28.326]                       is.null <- base::is.null
[17:39:28.326]                       muffled <- FALSE
[17:39:28.326]                       if (inherits(cond, "message")) {
[17:39:28.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.326]                         if (muffled) 
[17:39:28.326]                           invokeRestart("muffleMessage")
[17:39:28.326]                       }
[17:39:28.326]                       else if (inherits(cond, "warning")) {
[17:39:28.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.326]                         if (muffled) 
[17:39:28.326]                           invokeRestart("muffleWarning")
[17:39:28.326]                       }
[17:39:28.326]                       else if (inherits(cond, "condition")) {
[17:39:28.326]                         if (!is.null(pattern)) {
[17:39:28.326]                           computeRestarts <- base::computeRestarts
[17:39:28.326]                           grepl <- base::grepl
[17:39:28.326]                           restarts <- computeRestarts(cond)
[17:39:28.326]                           for (restart in restarts) {
[17:39:28.326]                             name <- restart$name
[17:39:28.326]                             if (is.null(name)) 
[17:39:28.326]                               next
[17:39:28.326]                             if (!grepl(pattern, name)) 
[17:39:28.326]                               next
[17:39:28.326]                             invokeRestart(restart)
[17:39:28.326]                             muffled <- TRUE
[17:39:28.326]                             break
[17:39:28.326]                           }
[17:39:28.326]                         }
[17:39:28.326]                       }
[17:39:28.326]                       invisible(muffled)
[17:39:28.326]                     }
[17:39:28.326]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.326]                   }
[17:39:28.326]                 }
[17:39:28.326]                 else {
[17:39:28.326]                   if (TRUE) {
[17:39:28.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:28.326]                     {
[17:39:28.326]                       inherits <- base::inherits
[17:39:28.326]                       invokeRestart <- base::invokeRestart
[17:39:28.326]                       is.null <- base::is.null
[17:39:28.326]                       muffled <- FALSE
[17:39:28.326]                       if (inherits(cond, "message")) {
[17:39:28.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:28.326]                         if (muffled) 
[17:39:28.326]                           invokeRestart("muffleMessage")
[17:39:28.326]                       }
[17:39:28.326]                       else if (inherits(cond, "warning")) {
[17:39:28.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:28.326]                         if (muffled) 
[17:39:28.326]                           invokeRestart("muffleWarning")
[17:39:28.326]                       }
[17:39:28.326]                       else if (inherits(cond, "condition")) {
[17:39:28.326]                         if (!is.null(pattern)) {
[17:39:28.326]                           computeRestarts <- base::computeRestarts
[17:39:28.326]                           grepl <- base::grepl
[17:39:28.326]                           restarts <- computeRestarts(cond)
[17:39:28.326]                           for (restart in restarts) {
[17:39:28.326]                             name <- restart$name
[17:39:28.326]                             if (is.null(name)) 
[17:39:28.326]                               next
[17:39:28.326]                             if (!grepl(pattern, name)) 
[17:39:28.326]                               next
[17:39:28.326]                             invokeRestart(restart)
[17:39:28.326]                             muffled <- TRUE
[17:39:28.326]                             break
[17:39:28.326]                           }
[17:39:28.326]                         }
[17:39:28.326]                       }
[17:39:28.326]                       invisible(muffled)
[17:39:28.326]                     }
[17:39:28.326]                     muffleCondition(cond, pattern = "^muffle")
[17:39:28.326]                   }
[17:39:28.326]                 }
[17:39:28.326]             }
[17:39:28.326]         }))
[17:39:28.326]     }, error = function(ex) {
[17:39:28.326]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:28.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:28.326]                 ...future.rng), started = ...future.startTime, 
[17:39:28.326]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:28.326]             version = "1.8"), class = "FutureResult")
[17:39:28.326]     }, finally = {
[17:39:28.326]         if (!identical(...future.workdir, getwd())) 
[17:39:28.326]             setwd(...future.workdir)
[17:39:28.326]         {
[17:39:28.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:28.326]                 ...future.oldOptions$nwarnings <- NULL
[17:39:28.326]             }
[17:39:28.326]             base::options(...future.oldOptions)
[17:39:28.326]             if (.Platform$OS.type == "windows") {
[17:39:28.326]                 old_names <- names(...future.oldEnvVars)
[17:39:28.326]                 envs <- base::Sys.getenv()
[17:39:28.326]                 names <- names(envs)
[17:39:28.326]                 common <- intersect(names, old_names)
[17:39:28.326]                 added <- setdiff(names, old_names)
[17:39:28.326]                 removed <- setdiff(old_names, names)
[17:39:28.326]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:28.326]                   envs[common]]
[17:39:28.326]                 NAMES <- toupper(changed)
[17:39:28.326]                 args <- list()
[17:39:28.326]                 for (kk in seq_along(NAMES)) {
[17:39:28.326]                   name <- changed[[kk]]
[17:39:28.326]                   NAME <- NAMES[[kk]]
[17:39:28.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.326]                     next
[17:39:28.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.326]                 }
[17:39:28.326]                 NAMES <- toupper(added)
[17:39:28.326]                 for (kk in seq_along(NAMES)) {
[17:39:28.326]                   name <- added[[kk]]
[17:39:28.326]                   NAME <- NAMES[[kk]]
[17:39:28.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.326]                     next
[17:39:28.326]                   args[[name]] <- ""
[17:39:28.326]                 }
[17:39:28.326]                 NAMES <- toupper(removed)
[17:39:28.326]                 for (kk in seq_along(NAMES)) {
[17:39:28.326]                   name <- removed[[kk]]
[17:39:28.326]                   NAME <- NAMES[[kk]]
[17:39:28.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:28.326]                     next
[17:39:28.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:28.326]                 }
[17:39:28.326]                 if (length(args) > 0) 
[17:39:28.326]                   base::do.call(base::Sys.setenv, args = args)
[17:39:28.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:28.326]             }
[17:39:28.326]             else {
[17:39:28.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:28.326]             }
[17:39:28.326]             {
[17:39:28.326]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:28.326]                   0L) {
[17:39:28.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:28.326]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:28.326]                   base::options(opts)
[17:39:28.326]                 }
[17:39:28.326]                 {
[17:39:28.326]                   {
[17:39:28.326]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:28.326]                     NULL
[17:39:28.326]                   }
[17:39:28.326]                   options(future.plan = NULL)
[17:39:28.326]                   if (is.na(NA_character_)) 
[17:39:28.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:28.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:28.326]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:28.326]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:28.326]                     envir = parent.frame()) 
[17:39:28.326]                   {
[17:39:28.326]                     if (is.function(workers)) 
[17:39:28.326]                       workers <- workers()
[17:39:28.326]                     workers <- structure(as.integer(workers), 
[17:39:28.326]                       class = class(workers))
[17:39:28.326]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:28.326]                       workers >= 1)
[17:39:28.326]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:28.326]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:28.326]                     }
[17:39:28.326]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:28.326]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:28.326]                       envir = envir)
[17:39:28.326]                     if (!future$lazy) 
[17:39:28.326]                       future <- run(future)
[17:39:28.326]                     invisible(future)
[17:39:28.326]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:28.326]                 }
[17:39:28.326]             }
[17:39:28.326]         }
[17:39:28.326]     })
[17:39:28.326]     if (TRUE) {
[17:39:28.326]         base::sink(type = "output", split = FALSE)
[17:39:28.326]         if (TRUE) {
[17:39:28.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:28.326]         }
[17:39:28.326]         else {
[17:39:28.326]             ...future.result["stdout"] <- base::list(NULL)
[17:39:28.326]         }
[17:39:28.326]         base::close(...future.stdout)
[17:39:28.326]         ...future.stdout <- NULL
[17:39:28.326]     }
[17:39:28.326]     ...future.result$conditions <- ...future.conditions
[17:39:28.326]     ...future.result$finished <- base::Sys.time()
[17:39:28.326]     ...future.result
[17:39:28.326] }
[17:39:28.328] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:39:28.329] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:39:28.329] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:39:28.329] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:28.330] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:28.330] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:39:28.330] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:39:28.330] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:28.331] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:28.331] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:28.331] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:28.331] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:39:28.332] MultisessionFuture started
[17:39:28.332] - Launch lazy future ... done
[17:39:28.332] run() for ‘MultisessionFuture’ ... done
[17:39:28.332] Created future:
[17:39:28.332] MultisessionFuture:
[17:39:28.332] Label: ‘future_by-2’
[17:39:28.332] Expression:
[17:39:28.332] {
[17:39:28.332]     do.call(function(...) {
[17:39:28.332]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:28.332]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:28.332]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:28.332]             on.exit(options(oopts), add = TRUE)
[17:39:28.332]         }
[17:39:28.332]         {
[17:39:28.332]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:28.332]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:28.332]                 ...future.FUN(...future.X_jj, ...)
[17:39:28.332]             })
[17:39:28.332]         }
[17:39:28.332]     }, args = future.call.arguments)
[17:39:28.332] }
[17:39:28.332] Lazy evaluation: FALSE
[17:39:28.332] Asynchronous evaluation: TRUE
[17:39:28.332] Local evaluation: TRUE
[17:39:28.332] Environment: 0x5629729f0cd8
[17:39:28.332] Capture standard output: TRUE
[17:39:28.332] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:28.332] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:28.332] Packages: <none>
[17:39:28.332] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:28.332] Resolved: FALSE
[17:39:28.332] Value: <not collected>
[17:39:28.332] Conditions captured: <none>
[17:39:28.332] Early signaling: FALSE
[17:39:28.332] Owner process: f066bc6d-4f18-ba7c-565b-14f4eb177314
[17:39:28.332] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:28.344] Chunk #2 of 2 ... DONE
[17:39:28.344] Launching 2 futures (chunks) ... DONE
[17:39:28.344] Resolving 2 futures (chunks) ...
[17:39:28.344] resolve() on list ...
[17:39:28.344]  recursive: 0
[17:39:28.345]  length: 2
[17:39:28.345] 
[17:39:28.345] receiveMessageFromWorker() for ClusterFuture ...
[17:39:28.345] - Validating connection of MultisessionFuture
[17:39:28.345] - received message: FutureResult
[17:39:28.346] - Received FutureResult
[17:39:28.346] - Erased future from FutureRegistry
[17:39:28.346] result() for ClusterFuture ...
[17:39:28.346] - result already collected: FutureResult
[17:39:28.346] result() for ClusterFuture ... done
[17:39:28.346] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:28.346] Future #1
[17:39:28.346] result() for ClusterFuture ...
[17:39:28.346] - result already collected: FutureResult
[17:39:28.346] result() for ClusterFuture ... done
[17:39:28.346] result() for ClusterFuture ...
[17:39:28.347] - result already collected: FutureResult
[17:39:28.347] result() for ClusterFuture ... done
[17:39:28.347] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:28.347] - nx: 2
[17:39:28.347] - relay: TRUE
[17:39:28.347] - stdout: TRUE
[17:39:28.347] - signal: TRUE
[17:39:28.347] - resignal: FALSE
[17:39:28.347] - force: TRUE
[17:39:28.347] - relayed: [n=2] FALSE, FALSE
[17:39:28.347] - queued futures: [n=2] FALSE, FALSE
[17:39:28.348]  - until=1
[17:39:28.348]  - relaying element #1
[17:39:28.348] result() for ClusterFuture ...
[17:39:28.348] - result already collected: FutureResult
[17:39:28.348] result() for ClusterFuture ... done
[17:39:28.348] result() for ClusterFuture ...
[17:39:28.348] - result already collected: FutureResult
[17:39:28.348] result() for ClusterFuture ... done
[17:39:28.348] result() for ClusterFuture ...
[17:39:28.348] - result already collected: FutureResult
[17:39:28.348] result() for ClusterFuture ... done
[17:39:28.349] result() for ClusterFuture ...
[17:39:28.349] - result already collected: FutureResult
[17:39:28.349] result() for ClusterFuture ... done
[17:39:28.349] - relayed: [n=2] TRUE, FALSE
[17:39:28.349] - queued futures: [n=2] TRUE, FALSE
[17:39:28.349] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:28.349]  length: 1 (resolved future 1)
[17:39:28.391] receiveMessageFromWorker() for ClusterFuture ...
[17:39:28.391] - Validating connection of MultisessionFuture
[17:39:28.391] - received message: FutureResult
[17:39:28.391] - Received FutureResult
[17:39:28.391] - Erased future from FutureRegistry
[17:39:28.392] result() for ClusterFuture ...
[17:39:28.392] - result already collected: FutureResult
[17:39:28.392] result() for ClusterFuture ... done
[17:39:28.392] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:28.392] Future #2
[17:39:28.392] result() for ClusterFuture ...
[17:39:28.392] - result already collected: FutureResult
[17:39:28.392] result() for ClusterFuture ... done
[17:39:28.392] result() for ClusterFuture ...
[17:39:28.392] - result already collected: FutureResult
[17:39:28.392] result() for ClusterFuture ... done
[17:39:28.392] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:28.393] - nx: 2
[17:39:28.393] - relay: TRUE
[17:39:28.393] - stdout: TRUE
[17:39:28.393] - signal: TRUE
[17:39:28.393] - resignal: FALSE
[17:39:28.393] - force: TRUE
[17:39:28.393] - relayed: [n=2] TRUE, FALSE
[17:39:28.393] - queued futures: [n=2] TRUE, FALSE
[17:39:28.393]  - until=2
[17:39:28.393]  - relaying element #2
[17:39:28.393] result() for ClusterFuture ...
[17:39:28.394] - result already collected: FutureResult
[17:39:28.394] result() for ClusterFuture ... done
[17:39:28.394] result() for ClusterFuture ...
[17:39:28.394] - result already collected: FutureResult
[17:39:28.394] result() for ClusterFuture ... done
[17:39:28.394] result() for ClusterFuture ...
[17:39:28.394] - result already collected: FutureResult
[17:39:28.394] result() for ClusterFuture ... done
[17:39:28.394] result() for ClusterFuture ...
[17:39:28.394] - result already collected: FutureResult
[17:39:28.394] result() for ClusterFuture ... done
[17:39:28.395] - relayed: [n=2] TRUE, TRUE
[17:39:28.395] - queued futures: [n=2] TRUE, TRUE
[17:39:28.395] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:28.395]  length: 0 (resolved future 2)
[17:39:28.395] Relaying remaining futures
[17:39:28.395] signalConditionsASAP(NULL, pos=0) ...
[17:39:28.395] - nx: 2
[17:39:28.395] - relay: TRUE
[17:39:28.395] - stdout: TRUE
[17:39:28.395] - signal: TRUE
[17:39:28.395] - resignal: FALSE
[17:39:28.396] - force: TRUE
[17:39:28.396] - relayed: [n=2] TRUE, TRUE
[17:39:28.396] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:28.396] - relayed: [n=2] TRUE, TRUE
[17:39:28.396] - queued futures: [n=2] TRUE, TRUE
[17:39:28.396] signalConditionsASAP(NULL, pos=0) ... done
[17:39:28.396] resolve() on list ... DONE
[17:39:28.396] result() for ClusterFuture ...
[17:39:28.396] - result already collected: FutureResult
[17:39:28.396] result() for ClusterFuture ... done
[17:39:28.396] result() for ClusterFuture ...
[17:39:28.397] - result already collected: FutureResult
[17:39:28.397] result() for ClusterFuture ... done
[17:39:28.397] result() for ClusterFuture ...
[17:39:28.397] - result already collected: FutureResult
[17:39:28.397] result() for ClusterFuture ... done
[17:39:28.397] result() for ClusterFuture ...
[17:39:28.397] - result already collected: FutureResult
[17:39:28.397] result() for ClusterFuture ... done
[17:39:28.397]  - Number of value chunks collected: 2
[17:39:28.397] Resolving 2 futures (chunks) ... DONE
[17:39:28.398] Reducing values from 2 chunks ...
[17:39:28.398]  - Number of values collected after concatenation: 3
[17:39:28.398]  - Number of values expected: 3
[17:39:28.398] Reducing values from 2 chunks ... DONE
[17:39:28.398] future_lapply() ... DONE
[17:39:28.398] future_by_internal() ... DONE
[17:39:28.399] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[17:39:28.400] plan(): Setting new future strategy stack:
[17:39:28.400] List of future strategies:
[17:39:28.400] 1. FutureStrategy:
[17:39:28.400]    - args: function (..., envir = parent.frame())
[17:39:28.400]    - tweaked: FALSE
[17:39:28.400]    - call: future::plan(oplan)
[17:39:28.401] plan(): nbrOfWorkers() = 1
> 
