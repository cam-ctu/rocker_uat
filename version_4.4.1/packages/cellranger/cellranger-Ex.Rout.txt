
R version 4.4.1 (2024-06-14) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "cellranger"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('cellranger')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("A1_to_R1C1")
> ### * A1_to_R1C1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: A1_to_R1C1
> ### Title: Convert cell reference strings from A1 to R1C1 format
> ### Aliases: A1_to_R1C1
> 
> ### ** Examples
> 
> A1_to_R1C1("$A$1")
[1] "R1C1"
> A1_to_R1C1("A1")                 ## raises a warning, returns NA
Warning: Mixed or relative cell references found ... NAs generated
[1] NA
> A1_to_R1C1("A1", strict = FALSE) ## unless strict = FALSE
[1] "R1C1"
> A1_to_R1C1(c("A1", "B$4")) ## raises a warning, includes an NA, because
Warning: Mixed or relative cell references found ... NAs generated
[1] NA NA
> A1_to_R1C1(c("A1", "B$4"), strict = FALSE) ## mixed ref always returns NA
Warning: Mixed or relative cell references found ... NAs generated
[1] "R1C1" NA    
> 
> 
> 
> cleanEx()
> nameEx("R1C1_to_A1")
> ### * R1C1_to_A1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: R1C1_to_A1
> ### Title: Convert R1C1 positioning notation to A1 notation
> ### Aliases: R1C1_to_A1
> 
> ### ** Examples
> 
> R1C1_to_A1("R1C1")
[1] "$A$1"
> R1C1_to_A1("R10C52", strict = FALSE)
[1] "AZ10"
> R1C1_to_A1(c("R1C1", "R10C52", "RC4", "R[-3]C[9]"))
Warning: Ambiguous cell references ... NAs generated
[1] "$A$1"   "$AZ$10" NA       NA      
> 
> 
> 
> cleanEx()
> nameEx("anchored")
> ### * anchored
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anchored
> ### Title: Specify cell limits via an anchor cell
> ### Aliases: anchored
> 
> ### ** Examples
> 
> anchored()
<cell_limits (1, 1) x (1, 1)>
> as.range(anchored())
[1] "R1C1:R1C1"
> dim(anchored())
[1] 1 1
> 
> anchored("Q24")
<cell_limits (24, 17) x (24, 17)>
> as.range(anchored("Q24"))
[1] "R24C17:R24C17"
> dim(anchored("Q24"))
[1] 1 1
> 
> anchored(anchor = "R4C2", dim = c(8, 2))
<cell_limits (4, 2) x (11, 3)>
> as.range(anchored(anchor = "R4C2", dim = c(8, 2)))
[1] "R4C2:R11C3"
> as.range(anchored(anchor = "R4C2", dim = c(8, 2)), fo = "A1")
[1] "B4:C11"
> dim(anchored(anchor = "R4C2", dim = c(8, 2)))
[1] 8 2
> 
> (input <- head(iris))
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa
> anchored(input = input)
<cell_limits (1, 1) x (7, 5)>
> as.range(anchored(input = input))
[1] "R1C1:R7C5"
> dim(anchored(input = input))
[1] 7 5
> 
> anchored(input = input, col_names = FALSE)
<cell_limits (1, 1) x (6, 5)>
> as.range(anchored(input = input, col_names = FALSE))
[1] "R1C1:R6C5"
> dim(anchored(input = input, col_names = FALSE))
[1] 6 5
> 
> (input <- LETTERS[1:8])
[1] "A" "B" "C" "D" "E" "F" "G" "H"
> anchored(input = input)
<cell_limits (1, 1) x (8, 1)>
> as.range(anchored(input = input))
[1] "R1C1:R8C1"
> dim(anchored(input = input))
[1] 8 1
> 
> anchored(input = input, byrow = TRUE)
<cell_limits (1, 1) x (1, 8)>
> as.range(anchored(input = input, byrow = TRUE))
[1] "R1C1:R1C8"
> dim(anchored(input = input, byrow = TRUE))
[1] 1 8
> 
> 
> 
> 
> cleanEx()
> nameEx("as.cell_addr")
> ### * as.cell_addr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.cell_addr
> ### Title: Convert to a cell_addr object
> ### Aliases: as.cell_addr as.cell_addr.character as.cell_addr.ra_ref
> ###   as.cell_addr_v as.cell_addr_v.character as.cell_addr_v.list
> 
> ### ** Examples
> 
> as.cell_addr(ra_ref())
<cell_addr: 1 cells>
Warning: `as_data_frame()` was deprecated in tibble 2.0.0.
ℹ Please use `as_tibble()` (with slightly different semantics) to convert to a
  tibble, or `as.data.frame()` to convert to a data frame.
ℹ The deprecated feature was likely used in the cellranger package.
  Please report the issue at <https://github.com/rsheets/cellranger/issues>.
# A tibble: 1 × 2
    row   col
  <int> <int>
1     1     1

> rar <- ra_ref(2, TRUE, 5, TRUE)
> as.cell_addr(rar)
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1     2     5

> ## mixed reference
> rar <- ra_ref(2, FALSE, 5, TRUE)
> as.cell_addr(rar)
Warning: Non-absolute references found ... NAs generated
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1    NA     5

> ra_ref_list <-
+   list(ra_ref(), ra_ref(2, TRUE, 5, TRUE), ra_ref(2, FALSE, 5, TRUE))
> as.cell_addr_v(ra_ref_list)
Warning: Non-absolute references found ... NAs generated
<cell_addr: 3 cells>
# A tibble: 3 × 2
    row   col
  <int> <int>
1     1     1
2     2     5
3    NA     5

> as.cell_addr("$D$12")
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1    12     4

> as.cell_addr("R4C3")
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1     4     3

> as.cell_addr(c("$C$4", "$D$12"))
<cell_addr: 2 cells>
# A tibble: 2 × 2
    row   col
  <int> <int>
1     4     3
2    12     4

> as.cell_addr("$F2")
Warning: Non-absolute references found ... NAs generated
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1    NA     6

> as.cell_addr("R[-4]C3")
Warning: Non-absolute references found ... NAs generated
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1    NA     3

> as.cell_addr("F2", strict = FALSE)
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1     2     6

> 
> 
> 
> cleanEx()
> nameEx("as.ra_ref")
> ### * as.ra_ref
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.ra_ref
> ### Title: Convert to a ra_ref object
> ### Aliases: as.ra_ref as.ra_ref.cell_addr as.ra_ref.character as.ra_ref_v
> ###   as.ra_ref_v.cell_addr as.ra_ref_v.character
> 
> ### ** Examples
> 
> ## as.ra_ref.character()
> as.ra_ref("$F$2")
<ra_ref>
   row: 2 (abs)
   col: 6 (abs)
 R2C6
> as.ra_ref("R[-4]C3")
<ra_ref>
   row: -4 (rel)
   col: 3 (abs)
 R[-4]C3
> as.ra_ref("B4")
Warning: Non-absolute A1-formatted reference ... NAs generated
<ra_ref>
   row: NA (rel)
   col: NA (rel)
 NA
> as.ra_ref("B4", strict = FALSE)
<ra_ref>
   row: 4 (abs)
   col: 2 (abs)
 R4C2
> as.ra_ref("B$4")
Warning: Non-absolute A1-formatted reference ... NAs generated
<ra_ref>
   row: 4 (abs)
   col: NA (rel)
 NA
> 
> ## this is actually ambiguous! is format A1 or R1C1 format?
> as.ra_ref("RC2")
Warning: Not clear if cell reference is in A1 or R1C1 format. Example:
RC2
Defaulting to R1C1
<ra_ref>
   row: 0 (rel)
   col: 2 (abs)
 RC2
> ## format could be specified in this case
> as.ra_ref("RC2", fo = "R1C1")
<ra_ref>
   row: 0 (rel)
   col: 2 (abs)
 RC2
> as.ra_ref("RC2", fo = "A1", strict = FALSE)
<ra_ref>
   row: 2 (abs)
   col: 471 (abs)
 R2C471
> 
> ## as.ra_ref_v.character()
> cs <- c("$A$1", "Sheet1!$F$14", "Sheet2!B$4", "D9")
> ## Not run: 
> ##D ## won't work because as.ra_ref requires length one input
> ##D as.ra_ref(cs)
> ## End(Not run)
> ## use as.ra_ref_v instead
> as.ra_ref_v(cs, strict = FALSE)
Warning: Non-absolute A1-formatted reference ... NAs generated
$`$A$1`
<ra_ref>
   row: 1 (abs)
   col: 1 (abs)
 R1C1

$`$F$14`
<ra_ref>
   row: 14 (abs)
   col: 6 (abs)
 sheet: Sheet1
 Sheet1!R14C6

$`B$4`
<ra_ref>
   row: 4 (abs)
   col: NA (rel)
 sheet: Sheet2
 NA

$D9
<ra_ref>
   row: 9 (abs)
   col: 4 (abs)
 R9C4

> ## as.ra_ref.cell_addr
> ca <- cell_addr(2, 5)
> as.ra_ref(ca)
<ra_ref>
   row: 2 (abs)
   col: 5 (abs)
 R2C5
> ## as.ra_ref_v.cell_addr()
> 
> ca <- cell_addr(1:3, 1)
> ## Not run: 
> ##D ## won't work because as.ra_ref methods not natively vectorized
> ##D as.ra_ref(ca)
> ## End(Not run)
> ## use as.ra_ref_v instead
> as.ra_ref_v(ca)
[[1]]
<ra_ref>
   row: 1 (abs)
   col: 1 (abs)
 R1C1

[[2]]
<ra_ref>
   row: 2 (abs)
   col: 1 (abs)
 R2C1

[[3]]
<ra_ref>
   row: 3 (abs)
   col: 1 (abs)
 R3C1

> 
> 
> 
> cleanEx()
> nameEx("as.range")
> ### * as.range
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.range
> ### Title: Convert a cell_limits object to a cell range
> ### Aliases: as.range
> 
> ### ** Examples
> 
> rgCL <- cell_limits(ul = c(1, 2), lr = c(7, 6))
> as.range(rgCL)
[1] "R1C2:R7C6"
> as.range(rgCL, fo = "A1")
[1] "B1:F7"
> 
> rgCL_ws <- cell_limits(ul = c(1, 2), lr = c(7, 6), sheet = "A Sheet")
> as.range(rgCL_ws)
[1] "'A Sheet'!R1C2:R7C6"
> as.range(rgCL_ws, fo = "A1")
[1] "'A Sheet'!B1:F7"
> 
> 
> 
> cleanEx()
> nameEx("cell_addr")
> ### * cell_addr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cell_addr
> ### Title: cell_addr class
> ### Aliases: cell_addr
> 
> ### ** Examples
> 
> cell_addr(4, 3)
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1     4     3

> (ca <- cell_addr(1:4, 3))
<cell_addr: 4 cells>
# A tibble: 4 × 2
    row   col
  <int> <int>
1     1     3
2     2     3
3     3     3
4     4     3

> ca[2:3]
<cell_addr: 2 cells>
# A tibble: 2 × 2
    row   col
  <int> <int>
1     2     3
2     3     3

> ca[[4]]
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1     4     3

> length(ca)
[1] 4
> 
> 
> 
> cleanEx()
> nameEx("cell_cols")
> ### * cell_cols
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cell_cols
> ### Title: Specify cell limits only for columns
> ### Aliases: cell_cols
> 
> ### ** Examples
> 
> cell_cols(c(NA, 3))
<cell_limits (-, 1) x (-, 3)>
> cell_cols(c(7, NA))
<cell_limits (-, 7) x (-, -)>
> cell_cols(4:16)
<cell_limits (-, 4) x (-, 16)>
> cell_cols(c(3, NA, 10))
<cell_limits (-, 3) x (-, 10)>
> 
> cell_cols("C:G")
<cell_limits (-, 3) x (-, 7)>
> cell_cols(c("B", NA))
<cell_limits (-, 2) x (-, -)>
> cell_cols(LETTERS)
<cell_limits (-, 1) x (-, 26)>
> 
> 
> 
> 
> cleanEx()
> nameEx("cell_limits")
> ### * cell_limits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cell_limits
> ### Title: Create a cell_limits object
> ### Aliases: as.cell_limits as.cell_limits.NULL as.cell_limits.cell_limits
> ###   as.cell_limits.character cell_limits dim.cell_limits
> 
> ### ** Examples
> 
> cell_limits(c(1, 3), c(1, 5))
<cell_limits (1, 3) x (1, 5)>
> cell_limits(c(NA, 7), c(3, NA))
<cell_limits (1, 7) x (3, -)>
> cell_limits(c(NA, 7))
<cell_limits (-, 7) x (-, -)>
> cell_limits(lr = c(3, 7))
<cell_limits (1, 1) x (3, 7)>
> 
> cell_limits(c(1, 3), c(1, 5), "Sheet1")
<cell_limits (1, 3) x (1, 5) in 'Sheet1'>
> cell_limits(c(1, 3), c(1, 5), "Spaces are evil")
<cell_limits (1, 3) x (1, 5) in 'Spaces are evil'>
> 
> dim(as.cell_limits("A1:F10"))
[1] 10  6
> 
> as.cell_limits("A1")
<cell_limits (1, 1) x (1, 1)>
> as.cell_limits("$Q$24")
<cell_limits (24, 17) x (24, 17)>
> as.cell_limits("A1:D8")
<cell_limits (1, 1) x (8, 4)>
> as.cell_limits("R5C11")
<cell_limits (5, 11) x (5, 11)>
> as.cell_limits("R2C3:R6C9")
<cell_limits (2, 3) x (6, 9)>
> as.cell_limits("Sheet1!R2C3:R6C9")
<cell_limits (2, 3) x (6, 9) in 'Sheet1'>
> as.cell_limits("'Spaces are evil'!R2C3:R6C9")
<cell_limits (2, 3) x (6, 9) in 'Spaces are evil'>
> 
> ## Not run: 
> ##D ## explicitly mixed A1 references won't work
> ##D as.cell_limits("A$2")
> ##D ## mixed or relative R1C1 references won't work
> ##D as.cell_limits("RC[4]")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("cell_rows")
> ### * cell_rows
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cell_rows
> ### Title: Specify cell limits only for rows
> ### Aliases: cell_rows
> 
> ### ** Examples
> 
> cell_rows(c(NA, 3))
<cell_limits (1, -) x (3, -)>
> cell_rows(c(7, NA))
<cell_limits (7, -) x (-, -)>
> cell_rows(4:16)
<cell_limits (4, -) x (16, -)>
> cell_rows(c(3, NA, 10))
<cell_limits (3, -) x (10, -)>
> 
> dim(cell_rows(1:5))
[1]  5 NA
> 
> 
> 
> 
> cleanEx()
> nameEx("guess_fo")
> ### * guess_fo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guess_fo
> ### Title: Guess cell reference string format
> ### Aliases: guess_fo
> 
> ### ** Examples
> 
> A1 <- c("A1", "$A1", "A$1", "$A$1", "a1")
> guess_fo(A1)
[1] "A1" "A1" "A1" "A1" "A1"
> R1C1 <- c("R1C1", "R1C[-1]", "R[-1]C1", "R[-1]C[9]")
> guess_fo(R1C1)
[1] "R1C1" "R1C1" "R1C1" "R1C1"
> 
> guess_fo("RC2")
Warning: Not clear if cell reference is in A1 or R1C1 format. Example:
RC2
Defaulting to R1C1
[1] "R1C1"
> guess_fo("12")
Warning: Cell reference follows neither the A1 nor R1C1 format. Example:
12
NAs generated.
[1] NA
> guess_fo(12)
Warning: Cell reference follows neither the A1 nor R1C1 format. Example:
12
NAs generated.
[1] NA
> 
> 
> 
> cleanEx()
> nameEx("is_A1")
> ### * is_A1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_A1
> ### Title: Test cell reference strings
> ### Aliases: is_A1 is_R1C1
> 
> ### ** Examples
> 
> is_A1("A1")
[1] TRUE
> is_R1C1("A1")
[1] FALSE
> is_R1C1("R4C12")
[1] TRUE
> 
> x <- c("A1", "$A4", "$b$12", "RC1", "R[-4]C9", "R5C3")
> data.frame(x, is_A1(x), is_R1C1(x))
        x is_A1.x. is_R1C1.x.
1      A1     TRUE      FALSE
2     $A4     TRUE      FALSE
3   $b$12     TRUE      FALSE
4     RC1     TRUE       TRUE
5 R[-4]C9    FALSE       TRUE
6    R5C3    FALSE       TRUE
> 
> 
> 
> cleanEx()
> nameEx("letter-num-conversion")
> ### * letter-num-conversion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: letter-num-conversion
> ### Title: Convert between letter and integer representations of column IDs
> ### Aliases: letter-num-conversion letter_to_num num_to_letter
> 
> ### ** Examples
> 
> letter_to_num('Z')
[1] 26
> letter_to_num(c('AA', 'ZZ', 'ABD', 'ZZZ'))
[1]    27   702   732 18278
> letter_to_num(c(NA, ''))
[1] NA NA
> num_to_letter(28)
[1] "AB"
> num_to_letter(900)
[1] "AHP"
> num_to_letter(18278)
[1] "ZZZ"
> num_to_letter(c(25, 52, 900, 18278))
[1] "Y"   "AZ"  "AHP" "ZZZ"
> num_to_letter(c(NA, 0, 4.8, -4))
[1] NA  NA  "D" NA 
> 
> 
> 
> cleanEx()
> nameEx("print.ra_ref")
> ### * print.ra_ref
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.ra_ref
> ### Title: Print ra_ref object
> ### Aliases: print.ra_ref
> 
> ### ** Examples
> 
> (rar <- ra_ref(3, TRUE, 1, TRUE))
<ra_ref>
   row: 3 (abs)
   col: 1 (abs)
 R3C1
> print(ra_ref(), fo = "A1")
<ra_ref>
   row: 1 (abs)
   col: 1 (abs)
 $A$1
> 
> 
> 
> 
> cleanEx()
> nameEx("ra_ref")
> ### * ra_ref
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ra_ref
> ### Title: ra_ref class
> ### Aliases: ra_ref
> 
> ### ** Examples
> 
> ra_ref()
<ra_ref>
   row: 1 (abs)
   col: 1 (abs)
 R1C1
> ra_ref(row_ref = 3, col_ref = 2)
<ra_ref>
   row: 3 (abs)
   col: 2 (abs)
 R3C2
> ra_ref(row_ref = 10, row_abs = FALSE, col_ref = 3, col_abs = TRUE)
<ra_ref>
   row: 10 (rel)
   col: 3 (abs)
 R[10]C3
> ra_ref(sheet = "a sheet")
<ra_ref>
   row: 1 (abs)
   col: 1 (abs)
 sheet: 'a sheet'
 'a sheet'!R1C1
> 
> 
> 
> cleanEx()
> nameEx("to_string")
> ### * to_string
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: to_string
> ### Title: Get string representation of cell references
> ### Aliases: to_string to_string.cell_addr to_string.ra_ref to_string_v
> ###   to_string_v.cell_addr to_string_v.list
> 
> ### ** Examples
> 
> ## exactly one ra_ref --> string
> to_string(ra_ref())
[1] "R1C1"
> to_string(ra_ref(), fo = "A1")
[1] "$A$1"
> to_string(ra_ref(), fo = "A1", strict = FALSE)
[1] "A1"
> to_string(ra_ref(row_ref = 3, col_ref = 2))
[1] "R3C2"
> to_string(ra_ref(row_ref = 3, col_ref = 2, sheet = "helloooo"))
[1] "helloooo!R3C2"
> (mixed_ref <- ra_ref(row_ref = 10, row_abs = FALSE, col_ref = 3))
<ra_ref>
   row: 10 (rel)
   col: 3 (abs)
 R[10]C3
> to_string(mixed_ref)
[1] "R[10]C3"
> 
> ## this will raise warning and generate NA, because row reference is
> ## relative and format is A1
> to_string(mixed_ref, fo = "A1")
Warning: Only absolute references can be converted to an A1 formatted string ... NAs generated
[1] NA
> 
> ## a list of ra_ref's --> character vector
> ra_ref_list <-
+   list(ra_ref(), ra_ref(2, TRUE, 5, TRUE), ra_ref(2, FALSE, 5, TRUE))
> to_string_v(ra_ref_list)
[1] "R1C1"   "R2C5"   "R[2]C5"
> 
> ## cell_addr --> string
> (ca <- cell_addr(3, 8))
<cell_addr: 1 cells>
# A tibble: 1 × 2
    row   col
  <int> <int>
1     3     8

> to_string(ca)
[1] "R3C8"
> to_string(ca, fo = "A1")
[1] "$H$3"
> 
> (ca <- cell_addr(1:4, 3))
<cell_addr: 4 cells>
# A tibble: 4 × 2
    row   col
  <int> <int>
1     1     3
2     2     3
3     3     3
4     4     3

> to_string(ca)
[1] "R1C3" "R2C3" "R3C3" "R4C3"
> to_string(ca, fo = "A1")
[1] "$C$1" "$C$2" "$C$3" "$C$4"
> ## explicitly go from cell_addr, length > 1 --> character vector
> (ca <- cell_addr(1:4, 3))
<cell_addr: 4 cells>
# A tibble: 4 × 2
    row   col
  <int> <int>
1     1     3
2     2     3
3     3     3
4     4     3

> to_string_v(ca)
[1] "R1C3" "R2C3" "R3C3" "R4C3"
> to_string_v(ca, fo = "A1")
[1] "$C$1" "$C$2" "$C$3" "$C$4"
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.565 0.025 0.59 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
