
R version 4.4.1 (2024-06-14) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "bit"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('bit')

Attaching package: ‘bit’

The following object is masked from ‘package:base’:

    xor

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("CoercionToStandard")
> ### * CoercionToStandard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CoercionToStandard
> ### Title: Coercion from bit, bitwhich, which and ri to logical, integer,
> ###   double
> ### Aliases: CoercionToStandard as.logical.bit as.integer.bit as.double.bit
> ###   as.integer.bitwhich as.double.bitwhich as.logical.bitwhich
> ###   as.logical.ri as.integer.ri as.double.ri as.logical.which
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> 
>   x <- ri(2, 5, 10)
>   y <- as.logical(x)
>   y
 [1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
>   stopifnot(identical(y, as.logical(as.bit(x))))
>   stopifnot(identical(y, as.logical(as.bitwhich(x))))
> 
>   y <- as.integer(x)
>   y
 [1] 0 1 1 1 1 0 0 0 0 0
>   stopifnot(identical(y, as.integer(as.logical(x))))
>   stopifnot(identical(y, as.integer(as.bit(x))))
>   stopifnot(identical(y, as.integer(as.bitwhich(x))))
> 
>   y <- as.double(x)
>   y
 [1] 0 1 1 1 1 0 0 0 0 0
>   stopifnot(identical(y, as.double(as.logical(x))))
>   stopifnot(identical(y, as.double(as.bit(x))))
>   stopifnot(identical(y, as.double(as.bitwhich(x))))
> 
> 
> 
> cleanEx()
> nameEx("Extract")
> ### * Extract
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Extract
> ### Title: Extract or replace part of an boolean vector
> ### Aliases: Extract [[.bit [[<-.bit [.bit [<-.bit [[.bitwhich
> ###   [[<-.bitwhich [.bitwhich [<-.bitwhich
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> 
>   x <- as.bit(c(FALSE, NA, TRUE))
>   x[] <- c(FALSE, NA, TRUE)
>   x[1:2]
[1] FALSE FALSE
attr(,"vmode")
[1] "boolean"
>   x[-3]
[1] FALSE FALSE
attr(,"vmode")
[1] "boolean"
>   x[ri(1,2)]
[1] FALSE FALSE
attr(,"vmode")
[1] "boolean"
>   x[as.bitwhich(c(TRUE,TRUE,FALSE))]
[1] FALSE FALSE
attr(,"vmode")
[1] "boolean"
>   x[[1]]
[1] FALSE
attr(,"vmode")
[1] "boolean"
>   x[] <- TRUE
>   x[1:2] <- FALSE
>   x[[1]] <- TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("Metadata")
> ### * Metadata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Metadata
> ### Title: Generics related to cache access
> ### Aliases: Metadata is.sorted is.sorted<- na.count na.count<- nvalid
> ###   nunique nunique<- nties nties<-
> ### Keywords: environment methods
> 
> ### ** Examples
> 
> 	methods("na.count")
no methods found
> 
> 
> 
> cleanEx()
> nameEx("PhysVirt")
> ### * PhysVirt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: physical.default
> ### Title: Physical and virtual attributes
> ### Aliases: physical.default physical<-.default virtual.default
> ###   virtual<-.default print.physical print.virtual PhysVirt physical
> ###   physical<- virtual virtual<-
> ### Keywords: IO attribute data
> 
> ### ** Examples
> 
> 
>   physical(bit(12))
$vmode
[1] "boolean"

>   virtual(bit(12))
$Length
[1] 12

> 
> 
> 
> cleanEx()
> nameEx("Summaries")
> ### * Summaries
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Summaries
> ### Title: Summaries of boolean vectors
> ### Aliases: Summaries all.bit any.bit anyNA.bit sum.bit min.bit max.bit
> ###   range.bit summary.bit all.bitwhich any.bitwhich anyNA.bitwhich
> ###   sum.bitwhich min.bitwhich max.bitwhich range.bitwhich
> ###   summary.bitwhich all.which any.which anyNA.which sum.which min.which
> ###   max.which range.which summary.which all.booltype any.booltype
> ###   anyNA.booltype sum.booltype min.booltype max.booltype range.booltype
> ###   summary.booltype all.ri any.ri anyNA.ri sum.ri min.ri max.ri range.ri
> ###   summary.ri
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> 
>   l <- c(NA, FALSE, TRUE)
>   b <- as.bit(l)
>   
>   all(l)
[1] FALSE
>   all(b)
[1] FALSE
>   all(b, range=c(3,3))
[1] TRUE
>   all.booltype(l, range=c(3,3))
[1] TRUE
>   
>   min(l)
[1] NA
>   min(b)
[1] 3
>   
>   sum(l)
[1] NA
>   sum(b)
[1] 1
>   
>   summary(l)
   Mode   FALSE    TRUE    NA's 
logical       1       1       1 
>   summary(b)
FALSE  TRUE  Min.  Max. 
    2     1     3     3 
>   summary.booltype(l)
FALSE  TRUE  Min.  Max. 
    2     1     3     3 
> 
> 
> 
> cleanEx()
> nameEx("as.bit")
> ### * as.bit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.bit.NULL
> ### Title: Coercing to bit
> ### Aliases: as.bit.NULL as.bit.bit as.bit.logical as.bit.integer
> ###   as.bit.double as.bit.bitwhich as.bit.which as.bit.ri as.bit
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> as.bit(c(0L,1L,2L,-2L,NA))
bit length=5 occupying only 1 int32
    1     2     3     4     5 
FALSE  TRUE  TRUE  TRUE FALSE 
> as.bit(c(0,1,2,-2,NA))
bit length=5 occupying only 1 int32
    1     2     3     4     5 
FALSE  TRUE  TRUE  TRUE FALSE 
> 
> as.bit(c(FALSE, NA, TRUE))
bit length=3 occupying only 1 int32
    1     2     3 
FALSE FALSE  TRUE 
> 
> 
> 
> 
> cleanEx()
> nameEx("as.bitwhich")
> ### * as.bitwhich
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.bitwhich.NULL
> ### Title: Coercing to bitwhich
> ### Aliases: as.bitwhich.NULL as.bitwhich.bitwhich as.bitwhich.which
> ###   as.bitwhich.ri as.bitwhich.integer as.bitwhich.double
> ###   as.bitwhich.logical as.bitwhich.bit as.bitwhich
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> as.bitwhich(c(0L,1L,2L,-2L,NA))
bitwhich: 3/5 occupying only 2 int32 in -1 representation
    1     2     3     4     5 
FALSE  TRUE  TRUE  TRUE FALSE 
> as.bitwhich(c(0,1,2,-2,NA))
bitwhich: 3/5 occupying only 2 int32 in -1 representation
    1     2     3     4     5 
FALSE  TRUE  TRUE  TRUE FALSE 
> 
>  as.bitwhich(c(NA,NA,NA))
bitwhich: 0/3 occupying only 1 int32 in FALSE representation
    1     2     3 
FALSE FALSE FALSE 
>  as.bitwhich(c(FALSE, FALSE, FALSE))
bitwhich: 0/3 occupying only 1 int32 in FALSE representation
    1     2     3 
FALSE FALSE FALSE 
>  as.bitwhich(c(FALSE, FALSE, TRUE))
bitwhich: 1/3 occupying only 1 int32 in 1 representation
    1     2     3 
FALSE FALSE  TRUE 
>  as.bitwhich(c(FALSE, TRUE, TRUE))
bitwhich: 2/3 occupying only 1 int32 in -1 representation
    1     2     3 
FALSE  TRUE  TRUE 
>  as.bitwhich(c(TRUE, TRUE, TRUE))
bitwhich: 3/3 occupying only 1 int32 in TRUE representation
   1    2    3 
TRUE TRUE TRUE 
> 
> 
> 
> 
> cleanEx()
> nameEx("as.booltype")
> ### * as.booltype
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.booltype.default
> ### Title: Coerce to booltype (generic)
> ### Aliases: as.booltype.default as.booltype
> 
> ### ** Examples
> 
> as.booltype(0:1)
[1] FALSE  TRUE
> as.booltype(0:1, "logical")
[1] FALSE  TRUE
> as.booltype(0:1, "bit")
bit length=2 occupying only 1 int32
    1     2 
FALSE  TRUE 
> as.booltype(0:1, "bitwhich")
bitwhich: 1/2 occupying only 1 int32 in 1 representation
    1     2 
FALSE  TRUE 
> as.booltype(0:1, "which", maxindex=2)
[1] 1
attr(,"maxindex")
[1] 2
attr(,"class")
[1] "booltype" "which"   
> as.booltype(0:1, "ri")
range index (ri) from 2 to 2 maxindex NA 
> 
> 
> 
> cleanEx()
> nameEx("as.character.bit")
> ### * as.character.bit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.character.bit
> ### Title: Coerce bit to character
> ### Aliases: as.character.bit
> 
> ### ** Examples
> 
> as.character(bit(12))
 [1] "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0"
> 
> 
> 
> cleanEx()
> nameEx("as.character.bitwhich")
> ### * as.character.bitwhich
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.character.bitwhich
> ### Title: Coerce bitwhich to character
> ### Aliases: as.character.bitwhich
> 
> ### ** Examples
> 
> as.character(bitwhich(12))
 [1] "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0"
> 
> 
> 
> cleanEx()
> nameEx("as.ri")
> ### * as.ri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.ri.ri
> ### Title: Coerce to ri
> ### Aliases: as.ri.ri as.ri.default as.ri
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> as.ri(c(FALSE, TRUE, FALSE, TRUE))
range index (ri) from 2 to 4 maxindex 4 
> 
> 
> 
> cleanEx()
> nameEx("as.which")
> ### * as.which
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.which.which
> ### Title: Coercion to (positive) integer positions
> ### Aliases: as.which.which as.which.NULL as.which.numeric as.which.integer
> ###   as.which.logical as.which.ri as.which.bit as.which.bitwhich as.which
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> 
>   r <- ri(5, 20, 100)
>   x <- as.which(r)
>   x
 [1]  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
attr(,"maxindex")
[1] 100
attr(,"class")
[1] "booltype" "which"   
> 
>   stopifnot(identical(x, as.which(as.logical(r))))
>   stopifnot(identical(x, as.which(as.bitwhich(r))))
>   stopifnot(identical(x, as.which(as.bit(r))))
> 
> 
> 
> 
> cleanEx()
> nameEx("bbatch")
> ### * bbatch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bbatch
> ### Title: Balanced Batch sizes
> ### Aliases: bbatch
> ### Keywords: IO data
> 
> ### ** Examples
> 
> 
>   bbatch(100, 24)
$b
[1] 20

$nb
[1] 5

$rb
[1] 0

> 
> 
> 
> 
> cleanEx()
> nameEx("bit")
> ### * bit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bit
> ### Title: Create empty bit vector
> ### Aliases: bit
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> bit(12)
bit length=12 occupying only 1 int32
    1     2     3     4     5     6     7     8     9    10    11    12 
FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
> !bit(12)
bit length=12 occupying only 1 int32
   1    2    3    4    5    6    7    8    9   10   11   12 
TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 
> str(bit(128))
bit  [1:128] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
> 
> 
> 
> cleanEx()
> nameEx("bit_in")
> ### * bit_in
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bit_in
> ### Title: bit %in%
> ### Aliases: bit_in
> 
> ### ** Examples
> 
> bit_in(1:2, 2:3)
bit length=2 occupying only 1 int32
    1     2 
FALSE  TRUE 
> bit_in(1:2, 2:3, retFUN=as.logical)
[1] FALSE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("bit_init")
> ### * bit_init
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .BITS
> ### Title: Initializing bit masks
> ### Aliases: .BITS bit_init bit_done
> ### Keywords: classes datasets logic
> 
> ### ** Examples
> 
> 
>   bit_done()
NULL
>   bit_init()
NULL
> 
> 
> 
> 
> cleanEx()
> nameEx("bit_rangediff")
> ### * bit_rangediff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bit_rangediff
> ### Title: bit range difference
> ### Aliases: bit_rangediff
> 
> ### ** Examples
> 
> bit_rangediff(c(1L,6L), c(3L,4L))
[1] 1 2 5 6
> bit_rangediff(c(6L,1L), c(3L,4L))
[1] 6 5 2 1
> bit_rangediff(c(6L,1L), c(3L,4L), revx=TRUE)
[1] -1 -2 -3 -4 -5 -6
> bit_rangediff(c(6L,1L), c(3L,4L), revx=TRUE, revy=TRUE)
[1] -1 -2 -5 -6
> 
> 
> 
> cleanEx()
> nameEx("bit_setops")
> ### * bit_setops
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bit_setops
> ### Title: bit set operations
> ### Aliases: bit_setops bit_union bit_intersect bit_setdiff bit_symdiff
> ###   bit_setequal
> 
> ### ** Examples
> 
> bit_union(1:2, 2:3)
[1] 1 2 3
> bit_intersect(1:2, 2:3)
[1] 2
> bit_setdiff(1:2, 2:3)
[1] 1
> bit_symdiff(1:2, 2:3)
[1] 1 3
> bit_setequal(1:2, 2:3)
[1] FALSE
> bit_setequal(1:2, 2:1)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("bit_sort")
> ### * bit_sort
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bit_sort
> ### Title: bit sort
> ### Aliases: bit_sort
> 
> ### ** Examples
> 
> bit_sort(c(2L,1L,NA,NA,1L,2L))
[1] 1 1 2 2
> bit_sort(c(2L,1L,NA,NA,1L,2L), na.last=FALSE)
[1] NA NA  1  1  2  2
> bit_sort(c(2L,1L,NA,NA,1L,2L), na.last=TRUE)
[1]  1  1  2  2 NA NA
> 
> ## Not run: 
> ##D x <- sample(1e7, replace=TRUE)
> ##D system.time(bit_sort(x))
> ##D system.time(sort(x))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("bit_sort_unique")
> ### * bit_sort_unique
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bit_sort_unique
> ### Title: bit sort unique
> ### Aliases: bit_sort_unique
> 
> ### ** Examples
> 
> bit_sort_unique(c(2L,1L,NA,NA,1L,2L))
[1] 1 2
> bit_sort_unique(c(2L,1L,NA,NA,1L,2L), na.last=FALSE)
[1] NA  1  2
> bit_sort_unique(c(2L,1L,NA,NA,1L,2L), na.last=TRUE)
[1]  1  2 NA
> bit_sort_unique(c(2L,1L,NA,NA,1L,2L), decreasing = TRUE)
[1] 2 1
> bit_sort_unique(c(2L,1L,NA,NA,1L,2L), decreasing = TRUE, na.last=FALSE)
[1] NA  2  1
> bit_sort_unique(c(2L,1L,NA,NA,1L,2L), decreasing = TRUE, na.last=TRUE)
[1]  2  1 NA
> 
> ## Not run: 
> ##D x <- sample(1e7, replace=TRUE)
> ##D system.time(bit_sort_unique(x))
> ##D system.time(sort(unique(x)))
> ##D x <- sample(1e7)
> ##D system.time(bit_sort_unique(x))
> ##D system.time(sort(x))
> ## End(Not run)
>  
> 
> 
> 
> cleanEx()
> nameEx("bit_unidup")
> ### * bit_unidup
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bit_unidup
> ### Title: bit unique and duplicated
> ### Aliases: bit_unidup bit_unique bit_duplicated bit_anyDuplicated
> ###   bit_sumDuplicated
> 
> ### ** Examples
> 
> bit_unique(c(2L,1L,NA,NA,1L,2L))
[1]  2  1 NA
> bit_unique(c(2L,1L,NA,NA,1L,2L), na.rm=FALSE)
[1]  2  1 NA NA
> bit_unique(c(2L,1L,NA,NA,1L,2L), na.rm=TRUE)
[1] 2 1
> 
> bit_duplicated(c(2L,1L,NA,NA,1L,2L))
bit length=6 occupying only 1 int32
    1     2     3     4     5     6 
FALSE FALSE FALSE  TRUE  TRUE  TRUE 
> bit_duplicated(c(2L,1L,NA,NA,1L,2L), na.rm=FALSE)
bit length=6 occupying only 1 int32
    1     2     3     4     5     6 
FALSE FALSE FALSE FALSE  TRUE  TRUE 
> bit_duplicated(c(2L,1L,NA,NA,1L,2L), na.rm=TRUE)
bit length=6 occupying only 1 int32
    1     2     3     4     5     6 
FALSE FALSE  TRUE  TRUE  TRUE  TRUE 
> 
> bit_anyDuplicated(c(2L,1L,NA,NA,1L,2L))
[1] 4
> bit_anyDuplicated(c(2L,1L,NA,NA,1L,2L), na.rm=FALSE)
[1] 5
> bit_anyDuplicated(c(2L,1L,NA,NA,1L,2L), na.rm=TRUE)
[1] 3
> 
> bit_sumDuplicated(c(2L,1L,NA,NA,1L,2L))
[1] 3
> bit_sumDuplicated(c(2L,1L,NA,NA,1L,2L), na.rm=FALSE)
[1] 2
> bit_sumDuplicated(c(2L,1L,NA,NA,1L,2L), na.rm=TRUE)
[1] 4
> 
> 
> 
> cleanEx()
> nameEx("bitsort")
> ### * bitsort
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bitsort
> ### Title: Low-level sorting: bit sort
> ### Aliases: bitsort
> 
> ### ** Examples
> 
> bitsort(c(2L,0L,1L,NA,2L))
[1] 0 1 2 2
> bitsort(c(2L,0L,1L,NA,2L), na.last=TRUE)
[1]  0  1  2  2 NA
> bitsort(c(2L,0L,1L,NA,2L), na.last=FALSE)
[1] NA  0  1  2  2
> 
> 
> 
> cleanEx()
> nameEx("bitwhich")
> ### * bitwhich
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bitwhich
> ### Title: Create bitwhich vector (skewed boolean)
> ### Aliases: bitwhich
> 
> ### ** Examples
> 
> bitwhich()
bitwhich: 0/0 occupying only 0 int32 in  representation
> bitwhich(12)
bitwhich: 0/12 occupying only 1 int32 in FALSE representation
    1     2     3     4     5     6     7     8     9    10    11    12 
FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
> bitwhich(12, x=TRUE)
bitwhich: 12/12 occupying only 1 int32 in TRUE representation
   1    2    3    4    5    6    7    8    9   10   11   12 
TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 
> bitwhich(12, x=3)
bitwhich: 1/12 occupying only 1 int32 in 1 representation
    1     2     3     4     5     6     7     8     9    10    11    12 
FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
> bitwhich(12, x=-3)
bitwhich: 11/12 occupying only 1 int32 in -1 representation
    1     2     3     4     5     6     7     8     9    10    11    12 
 TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE 
> bitwhich(12, x=integer())
bitwhich: 0/12 occupying only 1 int32 in FALSE representation
    1     2     3     4     5     6     7     8     9    10    11    12 
FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
> bitwhich(12, x=integer(), xempty=TRUE)
bitwhich: 12/12 occupying only 1 int32 in TRUE representation
   1    2    3    4    5    6    7    8    9   10   11   12 
TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 
> 
> 
> 
> cleanEx()
> nameEx("bitwhich_representation")
> ### * bitwhich_representation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bitwhich_representation
> ### Title: Diagnose representation of bitwhich
> ### Aliases: bitwhich_representation
> 
> ### ** Examples
> 
> bitwhich_representation(bitwhich())
logical(0)
> bitwhich_representation(bitwhich(12,FALSE))
[1] FALSE
> bitwhich_representation(bitwhich(12,TRUE))
[1] TRUE
> bitwhich_representation(bitwhich(12, -3))
[1] -1
> bitwhich_representation(bitwhich(12, 3))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("booltype")
> ### * booltype
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: booltype
> ### Title: Diagnosing boolean types
> ### Aliases: booltype
> 
> ### ** Examples
> 
> unname(booltypes)
[1] nobool   logical  bit      bitwhich which    ri      
Levels: nobool < logical < bit < bitwhich < which < ri
> str(booltypes)
 Ord.factor w/ 6 levels "nobool"<"logical"<..: 1 2 3 4 5 6
 - attr(*, "names")= chr [1:6] "nobool" "logical" "bit" "bitwhich" ...
> sapply(list(double(),integer(),logical(),bit(),bitwhich(),as.which(),ri(1,2,3)), booltype)
  double  integer                                              
  nobool   nobool  logical      bit bitwhich    which       ri 
Levels: nobool logical bit bitwhich which ri
> 
> 
> 
> cleanEx()
> nameEx("c.booltype")
> ### * c.booltype
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: c.booltype
> ### Title: Concatenating booltype vectors
> ### Aliases: c.booltype c.bit c.bitwhich
> ### Keywords: classes logic
> 
> ### ** Examples
> 
>  c(bit(4), !bit(4))
bit length=8 occupying only 1 int32
    1     2     3     4     5     6     7     8 
FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE 
>  c(bit(4), !bitwhich(4))
bit length=8 occupying only 1 int32
    1     2     3     4     5     6     7     8 
FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE 
>  c(bitwhich(4), !bit(4))
bit length=8 occupying only 1 int32
    1     2     3     4     5     6     7     8 
FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE 
>  c(ri(1,2,4), !bit(4))
bit length=8 occupying only 1 int32
    1     2     3     4     5     6     7     8 
 TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE 
>  c(bit(4), !logical(4))
[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
>  message("logical in first argument does not dispatch: c(logical(4), bit(4))")
logical in first argument does not dispatch: c(logical(4), bit(4))
>  c.booltype(logical(4), !bit(4))
[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("chunk")
> ### * chunk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chunk
> ### Title: Methods for chunked range index
> ### Aliases: chunk chunk.default
> ### Keywords: data
> 
> ### ** Examples
> 
>   chunk(complex(1e7))
$`1:1000000`
range index (ri) from 1 to 1000000 maxindex 10000000 

$`1000001:2000000`
range index (ri) from 1000001 to 2000000 maxindex 10000000 

$`2000001:3000000`
range index (ri) from 2000001 to 3000000 maxindex 10000000 

$`3000001:4000000`
range index (ri) from 3000001 to 4000000 maxindex 10000000 

$`4000001:5000000`
range index (ri) from 4000001 to 5000000 maxindex 10000000 

$`5000001:6000000`
range index (ri) from 5000001 to 6000000 maxindex 10000000 

$`6000001:7000000`
range index (ri) from 6000001 to 7000000 maxindex 10000000 

$`7000001:8000000`
range index (ri) from 7000001 to 8000000 maxindex 10000000 

$`8000001:9000000`
range index (ri) from 8000001 to 9000000 maxindex 10000000 

$`9000001:10000000`
range index (ri) from 9000001 to 10000000 maxindex 10000000 

>   chunk(raw(1e7))
$`1:10000000`
range index (ri) from 1 to 10000000 maxindex 10000000 

>   chunk(raw(1e7), length=3)
$`1:2500000`
range index (ri) from 1 to 2500000 maxindex 10000000 

$`2500001:5000000`
range index (ri) from 2500001 to 5000000 maxindex 10000000 

$`5000001:10000000`
range index (ri) from 5000001 to 10000000 maxindex 10000000 

>   
>   chunks(1,10,3)
$`1:3`
range index (ri) from 1 to 3 maxindex NA 

$`4:6`
range index (ri) from 4 to 6 maxindex NA 

$`7:9`
range index (ri) from 7 to 9 maxindex NA 

$`10:10`
range index (ri) from 10 to 10 maxindex NA 

>   # no longer do
>   chunk(1,100,10)
$`1:1`
range index (ri) from 1 to 1 maxindex 1 

>   # but for bckward compatibility this works
>   chunk(from=1,to=100,by=10)
$`1:10`
range index (ri) from 1 to 10 maxindex NA 

$`11:20`
range index (ri) from 11 to 20 maxindex NA 

$`21:30`
range index (ri) from 21 to 30 maxindex NA 

$`31:40`
range index (ri) from 31 to 40 maxindex NA 

$`41:50`
range index (ri) from 41 to 50 maxindex NA 

$`51:60`
range index (ri) from 51 to 60 maxindex NA 

$`61:70`
range index (ri) from 61 to 70 maxindex NA 

$`71:80`
range index (ri) from 71 to 80 maxindex NA 

$`81:90`
range index (ri) from 81 to 90 maxindex NA 

$`91:100`
range index (ri) from 91 to 100 maxindex NA 

>   
> 
> 
> 
> cleanEx()
> nameEx("chunks")
> ### * chunks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chunks
> ### Title: Function for chunked range index
> ### Aliases: chunks
> ### Keywords: data
> 
> ### ** Examples
> 
> 
>   chunks(1, 100, by=30)
$`1:25`
range index (ri) from 1 to 25 maxindex NA 

$`26:50`
range index (ri) from 26 to 50 maxindex NA 

$`51:75`
range index (ri) from 51 to 75 maxindex NA 

$`76:100`
range index (ri) from 76 to 100 maxindex NA 

>   chunks(1, 100, by=30, method="seq")
$`1:30`
range index (ri) from 1 to 30 maxindex NA 

$`31:60`
range index (ri) from 31 to 60 maxindex NA 

$`61:90`
range index (ri) from 61 to 90 maxindex NA 

$`91:100`
range index (ri) from 91 to 100 maxindex NA 

>    ## Not run: 
> ##D require(foreach)
> ##D m <- 10000
> ##D k <- 1000
> ##D n <- m*k
> ##D message("Four ways to loop from 1 to n. Slowest foreach to fastest chunk is 1700:1 
> ##D on a dual core notebook with 3GB RAM\n")
> ##D z <- 0L; 
> ##D print(k*system.time({it <- icount(m); foreach (i = it) %do% { z <- i; NULL }}))
> ##D z
> ##D 
> ##D z <- 0L
> ##D print(system.time({i <- 0L; while (i<n) {i <- i + 1L; z <- i}}))
> ##D z
> ##D 
> ##D z <- 0L
> ##D print(system.time(for (i in 1:n) z <- i))
> ##D z
> ##D 
> ##D z <- 0L; n <- m*k; 
> ##D print(system.time(for (ch in chunks(1, n, by=m)){for (i in ch[1]:ch[2])z <- i}))
> ##D z
> ##D 
> ##D message("Seven ways to calculate sum(1:n). 
> ##D  Slowest foreach to fastest chunk is 61000:1 on a dual core notebook with 3GB RAM\n")
> ##D print(k*system.time({it <- icount(m); foreach (i = it, .combine="+") %do% { i }}))
> ##D 
> ##D z <- 0; 
> ##D print(k*system.time({it <- icount(m); foreach (i = it) %do% { z <- z + i; NULL }}))
> ##D z
> ##D 
> ##D z <- 0; print(system.time({i <- 0L;while (i<n) {i <- i + 1L; z <- z + i}})); z
> ##D 
> ##D z <- 0; print(system.time(for (i in 1:n) z <- z + i)); z
> ##D 
> ##D print(system.time(sum(as.double(1:n))))
> ##D 
> ##D z <- 0; n <- m*k
> ##D print(system.time(for (ch in chunks(1, n, by=m)){for (i in ch[1]:ch[2])z <- z + i}))
> ##D z
> ##D 
> ##D z <- 0; n <- m*k
> ##D print(system.time(for (ch in chunks(1, n, by=m)){z <- z+sum(as.double(ch[1]:ch[2]))}))
> ##D z
> ##D    
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("clone")
> ### * clone
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clone
> ### Title: Cloning ff and ram objects
> ### Aliases: clone clone.default
> ### Keywords: IO data
> 
> ### ** Examples
> 
> 
>   x <- 1:12
>   y <- x
>   still.identical(x,y)
[1] TRUE
>   y[1] <- y[1]
>   still.identical(x,y)
[1] FALSE
>   y <- clone(x)
>   still.identical(x,y)
[1] FALSE
>   rm(x,y); gc()
         used (Mb) gc trigger  (Mb) max used (Mb)
Ncells 434852 23.3     893342  47.8   692348   37
Vcells 813345  6.3   21653169 165.3 23327254  178
> 
> 
> 
> 
> cleanEx()
> nameEx("copy_vector")
> ### * copy_vector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: copy_vector
> ### Title: Copy atomic R vector
> ### Aliases: copy_vector
> 
> ### ** Examples
> 
> x <- factor(letters)
> y <- x
> z <- copy_vector(x)
> still.identical(x,y)
[1] TRUE
> still.identical(x,z)
[1] FALSE
> str(x)
 Factor w/ 26 levels "a","b","c","d",..: 1 2 3 4 5 6 7 8 9 10 ...
> str(y)
 Factor w/ 26 levels "a","b","c","d",..: 1 2 3 4 5 6 7 8 9 10 ...
> str(z)
 int [1:26] 1 2 3 4 5 6 7 8 9 10 ...
> 
> 
> 
> cleanEx()
> nameEx("countsort")
> ### * countsort
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: countsort
> ### Title: Low-level sorting: counting sort
> ### Aliases: countsort
> 
> ### ** Examples
> 
> countsort(c(2L,0L,1L,NA,2L))
[1] 0 1 2 2
> countsort(c(2L,0L,1L,NA,2L), na.last=TRUE)
[1]  0  1  2  2 NA
> countsort(c(2L,0L,1L,NA,2L), na.last=FALSE)
[1] NA  0  1  2  2
> 
> 
> 
> cleanEx()
> nameEx("firstNA")
> ### * firstNA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: firstNA
> ### Title: Position of first NA
> ### Aliases: firstNA
> 
> ### ** Examples
> 
> x <- c(FALSE,NA,TRUE)
> firstNA(x)
[1] 2
> reverse_vector(x)
[1]  TRUE    NA FALSE
> ## Not run: 
> ##D x <- 1:1e7
> ##D system.time(rev(x))
> ##D system.time(reverse_vector(x))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("get_length")
> ### * get_length
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_length
> ### Title: Get C length of a vector
> ### Aliases: get_length
> 
> ### ** Examples
> 
> length(bit(12))
[1] 12
> get_length(bit(12))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("getsetattr")
> ### * getsetattr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getsetattr
> ### Title: Attribute setting by reference
> ### Aliases: getsetattr setattr setattributes
> ### Keywords: attributes
> 
> ### ** Examples
> 
> 
>   x <- as.single(runif(10))
>   attr(x, "Csingle")
[1] TRUE
> 
>   f <- function(x)attr(x, "Csingle") <- NULL
>   g <- function(x)setattr(x, "Csingle", NULL)
> 
>   f(x)
>   x
 [1] 0.26550866 0.37212390 0.57285336 0.90820779 0.20168193 0.89838968
 [7] 0.94467527 0.66079779 0.62911404 0.06178627
attr(,"Csingle")
[1] TRUE
>   g(x)
>   x
 [1] 0.26550866 0.37212390 0.57285336 0.90820779 0.20168193 0.89838968
 [7] 0.94467527 0.66079779 0.62911404 0.06178627
> 
>  ## Not run: 
> ##D 
> ##D   # restart R
> ##D   library(bit)
> ##D 
> ##D   mysingle <- function(length = 0){
> ##D     ret <- double(length)
> ##D     setattr(ret, "Csingle", TRUE)
> ##D     ret
> ##D   }
> ##D 
> ##D   # show that mysinge gives exactly the same result as single
> ##D   identical(single(10), mysingle(10))
> ##D 
> ##D   # look at the speedup and memory-savings of mysingle compared to single
> ##D   system.time(mysingle(1e7))
> ##D   memory.size(max=TRUE)
> ##D   system.time(single(1e7))
> ##D   memory.size(max=TRUE)
> ##D 
> ##D   # look at the memory limits
> ##D   # on my win32 machine the first line fails beause of not enough RAM, the second works
> ##D   x <- single(1e8)
> ##D   x <- mysingle(1e8)
> ##D 
> ##D   # .g. performance with factors
> ##D   x <- rep(factor(letters), length.out=1e7)
> ##D   x[1:10]
> ##D   # look how fast one can do this
> ##D   system.time(setattr(x, "levels", rev(letters)))
> ##D   x[1:10]
> ##D   # look at the performance loss in time caused by the non-needed copying
> ##D   system.time(levels(x) <- letters)
> ##D   x[1:10]
> ##D 
> ##D 
> ##D   # restart R
> ##D   library(bit)
> ##D 
> ##D   simplefactor <- function(n){
> ##D     factor(rep(1:2, length.out=n))
> ##D   }
> ##D 
> ##D   mysimplefactor <- function(n){
> ##D     ret <- rep(1:2, length.out=n)
> ##D     setattr(ret, "levels", as.character(1:2))
> ##D     setattr(ret, "class", "factor")
> ##D     ret
> ##D   }
> ##D 
> ##D   identical(simplefactor(10), mysimplefactor(10))
> ##D 
> ##D   system.time(x <- mysimplefactor(1e7))
> ##D   memory.size(max=TRUE)
> ##D   system.time(setattr(x, "levels", c("a","b")))
> ##D   memory.size(max=TRUE)
> ##D   x[1:4]
> ##D   memory.size(max=TRUE)
> ##D   rm(x)
> ##D   gc()
> ##D 
> ##D   system.time(x <- simplefactor(1e7))
> ##D   memory.size(max=TRUE)
> ##D   system.time(levels(x) <- c("x","y"))
> ##D   memory.size(max=TRUE)
> ##D   x[1:4]
> ##D   memory.size(max=TRUE)
> ##D   rm(x)
> ##D   gc()
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("in.bitwhich")
> ### * in.bitwhich
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: in.bitwhich
> ### Title: Check existence of integers in table
> ### Aliases: in.bitwhich
> 
> ### ** Examples
> 
> x <- bitwhich(100)
> x[3] <- TRUE
> in.bitwhich(c(NA,2,3), x)
[1] FALSE FALSE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("intrle")
> ### * intrle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: intrle
> ### Title: Hybrid Index, C-coded utilities
> ### Aliases: intrle intisasc intisdesc
> ### Keywords: IO data
> 
> ### ** Examples
> 
> 
>   intrle(sample(1:10))
NULL
>   intrle(diff(1:10))
Run Length Encoding
  lengths: int 9
  values : int 1
>   intisasc(1:10)
[1] TRUE
>   intisasc(10:1)
[1] FALSE
>   intisasc(c(NA, 1:10))
[1] NA
>   intisdesc(1:10)
[1] FALSE
>   intisdesc(c(10:1, NA))
[1] TRUE
>   intisdesc(c(10:6, NA, 5:1))
[1] FALSE
>   intisdesc(c(10:6, NA, 5:1), na.method="skip")
[1] TRUE
>   intisdesc(c(10:6, NA, 5:1), na.method="break")
[1] NA
> 
> 
> 
> 
> cleanEx()
> nameEx("is.booltype")
> ### * is.booltype
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.booltype
> ### Title: Testing for boolean types
> ### Aliases: is.booltype is.bit is.bitwhich is.which is.hi is.ri
> 
> ### ** Examples
> 
> sapply(list(double(),integer(),logical(),bit(),bitwhich(),as.which(),ri(1,2,3)), is.booltype)
[1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.na.bit")
> ### * is.na.bit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.na.bit
> ### Title: Test for NA in bit and bitwhich
> ### Aliases: is.na.bit is.na.bitwhich
> 
> ### ** Examples
> 
> is.na(bit(6))
[1] FALSE
> is.na(bitwhich(6))
bitwhich: 0/6 occupying only 1 int32 in FALSE representation
    1     2     3     4     5     6 
FALSE FALSE FALSE FALSE FALSE FALSE 
> 
> 
> 
> cleanEx()
> nameEx("length.bit")
> ### * length.bit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: length.bit
> ### Title: Getting and setting length of bit, bitwhich and ri objects
> ### Aliases: length.bit length<-.bit length.bitwhich length<-.bitwhich
> ###   length.ri
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> 
>   stopifnot(length(ri(1, 1, 32))==32)
> 
>   x <- as.bit(ri(32, 32, 32))
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==1)
>   length(x) <- 16
>   stopifnot(length(x)==16)
>   stopifnot(sum(x)==0)
>   length(x) <- 32
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==0)
> 
>   x <- as.bit(ri(1, 1, 32))
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==1)
>   length(x) <- 16
>   stopifnot(length(x)==16)
>   stopifnot(sum(x)==1)
>   length(x) <- 32
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==1)
> 
>   x <- as.bitwhich(bit(32))
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==0)
>   length(x) <- 16
>   stopifnot(length(x)==16)
>   stopifnot(sum(x)==0)
>   length(x) <- 32
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==0)
> 
>   x <- as.bitwhich(!bit(32))
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==32)
>   length(x) <- 16
>   stopifnot(length(x)==16)
>   stopifnot(sum(x)==16)
>   length(x) <- 32
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==32)
> 
>   x <- as.bitwhich(ri(32, 32, 32))
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==1)
>   length(x) <- 16
>   stopifnot(length(x)==16)
>   stopifnot(sum(x)==0)
>   length(x) <- 32
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==0)
> 
>   x <- as.bitwhich(ri(2, 32, 32))
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==31)
>   length(x) <- 16
>   stopifnot(length(x)==16)
>   stopifnot(sum(x)==15)
>   length(x) <- 32
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==31)
> 
>   x <- as.bitwhich(ri(1, 1, 32))
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==1)
>   length(x) <- 16
>   stopifnot(length(x)==16)
>   stopifnot(sum(x)==1)
>   length(x) <- 32
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==1)
> 
>   x <- as.bitwhich(ri(1, 31, 32))
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==31)
>   message("NOTE the change from 'some excluded' to 'all excluded' here")
NOTE the change from 'some excluded' to 'all excluded' here
>   length(x) <- 16
>   stopifnot(length(x)==16)
>   stopifnot(sum(x)==16)
>   length(x) <- 32
>   stopifnot(length(x)==32)
>   stopifnot(sum(x)==32)
> 
> 
> 
> 
> cleanEx()
> nameEx("maxindex")
> ### * maxindex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: maxindex.default
> ### Title: Get maxindex (length of boolean vector) and poslength (number of
> ###   'selected' elements)
> ### Aliases: maxindex.default poslength.default maxindex.logical
> ###   poslength.logical maxindex.bit poslength.bit maxindex.bitwhich
> ###   poslength.bitwhich maxindex.which poslength.which maxindex.ri
> ###   poslength.ri maxindex poslength
> 
> ### ** Examples
> 
> r <- ri(1,2,12)
> i <- as.which(r)
> w <- as.bitwhich(r)
> b <- as.bit(r)
> l <- as.logical(r)
> u <- which(l)      # unclassed which
> 
> sapply(list(r=r,u=u,i=i,w=w,b=b,l=l), function(x){
+   c(length=length(x), sum=sum(x), maxindex=maxindex(x), poslength=poslength(x))
+ })
           r  u  i  w  b  l
length    12  2  2 12 12 12
sum        2  3  2  2  2  2
maxindex  12 NA 12 12 12 12
poslength  2 NA  2  2  2  2
> 
> 
> 
> cleanEx()
> nameEx("merge_rev")
> ### * merge_rev
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: merge_rev
> ### Title: Fast functions for sorted sets of integer
> ### Aliases: merge_rev merge_match merge_in merge_notin merge_duplicated
> ###   merge_anyDuplicated merge_sumDuplicated merge_unique merge_union
> ###   merge_setdiff merge_symdiff merge_intersect merge_setequal
> ###   merge_rangein merge_rangenotin merge_rangesect merge_rangediff
> ###   merge_first merge_last merge_firstin merge_lastin merge_firstnotin
> ###   merge_lastnotin
> 
> ### ** Examples
> 
> merge_rev(1:9)
[1] -9 -8 -7 -6 -5 -4 -3 -2 -1
> 
> merge_match(1:7, 3:9)
[1] NA NA  1  2  3  4  5
> #' merge_match(merge_rev(1:7), 3:9)
> merge_match(merge_rev(1:7), 3:9, revx=TRUE)
[1] NA NA  1  2  3  4  5
> merge_match(merge_rev(1:7), 3:9, revy=TRUE)
[1]  3  4  5  6  7 NA NA
> merge_match(merge_rev(1:7), merge_rev(3:9))
[1]  3  4  5  6  7 NA NA
> 
> merge_in(1:7, 3:9)
[1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
> merge_notin(1:7, 3:9)
[1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
> 
> merge_anyDuplicated(c(1L,1L,2L,3L))
[1] TRUE
> merge_duplicated(c(1L,1L,2L,3L))
[1] FALSE  TRUE FALSE FALSE
> merge_unique(c(1L,1L,2L,3L))
[1] 1 2 3
> 
> merge_union(c(1L,2L,2L,2L), c(2L,2L,3L))
[1] 1 2 3
> merge_union(c(1L,2L,2L,2L), c(2L,2L,3L), method="exact")
[1] 1 2 2 2 3
> merge_union(c(1L,2L,2L,2L), c(2L,2L,3L), method="all")
[1] 1 2 2 2 2 2 3
> 
> merge_setdiff(c(1L,2L,2L,2L), c(2L,2L,3L))
[1] 1
> merge_setdiff(c(1L,2L,2L,2L), c(2L,2L,3L), method="exact")
[1] 1 2
> merge_setdiff(c(1L,2L,2L), c(2L,2L,2L,3L), method="exact")
[1] 1
> 
> merge_symdiff(c(1L,2L,2L,2L), c(2L,2L,3L))
[1] 1 3
> merge_symdiff(c(1L,2L,2L,2L), c(2L,2L,3L), method="exact")
[1] 1 2 3
> merge_symdiff(c(1L,2L,2L), c(2L,2L,2L,3L), method="exact")
[1] 1 2 3
> 
> merge_intersect(c(1L,2L,2L,2L), c(2L,2L,3L))
[1] 2
> merge_intersect(c(1L,2L,2L,2L), c(2L,2L,3L), method="exact")
[1] 2 2
> 
> merge_setequal(c(1L,2L,2L), c(1L,2L))
[1] TRUE
> merge_setequal(c(1L,2L,2L), c(1L,2L,2L))
[1] TRUE
> merge_setequal(c(1L,2L,2L), c(1L,2L), method="exact")
[1] FALSE
> merge_setequal(c(1L,2L,2L), c(1L,2L,2L), method="exact")
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("print.bit")
> ### * print.bit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.bit
> ### Title: Print method for bit
> ### Aliases: print.bit
> 
> ### ** Examples
> 
> print(bit(120))
bit length=120 occupying only 4 int32
    1     2     3     4     5     6     7     8         113   114   115   116 
FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE    .. FALSE FALSE FALSE FALSE 
  117   118   119   120 
FALSE FALSE FALSE FALSE 
> 
> 
> 
> cleanEx()
> nameEx("quicksort2")
> ### * quicksort2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quicksort2
> ### Title: Low-level sorting: binary quicksort
> ### Aliases: quicksort2
> 
> ### ** Examples
> 
> quicksort2(c(2L,0L,1L,NA,2L))
[1] 0 1 2 2
> quicksort2(c(2L,0L,1L,NA,2L), na.last=TRUE)
[1]  0  1  2  2 NA
> quicksort2(c(2L,0L,1L,NA,2L), na.last=FALSE)
[1] NA  0  1  2  2
> 
> 
> 
> cleanEx()
> nameEx("quicksort3")
> ### * quicksort3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quicksort3
> ### Title: Low-level sorting: threeway quicksort
> ### Aliases: quicksort3
> 
> ### ** Examples
> 
> countsort(c(2L,0L,1L,NA,2L))
[1] 0 1 2 2
> countsort(c(2L,0L,1L,NA,2L), na.last=TRUE)
[1]  0  1  2  2 NA
> countsort(c(2L,0L,1L,NA,2L), na.last=FALSE)
[1] NA  0  1  2  2
> 
> 
> 
> cleanEx()
> nameEx("range_na")
> ### * range_na
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: range_na
> ### Title: Get range and number of NAs
> ### Aliases: range_na
> 
> ### ** Examples
> 
> range_na(c(0L,1L,2L,NA))
[1] 0 2 1
> 
> 
> 
> cleanEx()
> nameEx("range_nanozero")
> ### * range_nanozero
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: range_nanozero
> ### Title: Remove zeros and get range and number of NAs
> ### Aliases: range_nanozero
> 
> ### ** Examples
> 
> range_nanozero(c(0L,1L,2L,NA))
[1]  1  2 NA
attr(,"range_na")
[1] 1 2 1
> 
> 
> 
> cleanEx()
> nameEx("range_sortna")
> ### * range_sortna
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: range_sortna
> ### Title: Prepare for sorting and get range, number of NAs and
> ###   unsortedness
> ### Aliases: range_sortna
> 
> ### ** Examples
> 
> range_sortna(c(0L,1L,NA,2L))
[1] 0 1 2
attr(,"range_sortna")
[1] 0 2 0 0
> range_sortna(c(2L,NA,1L,0L))
[1] 2 1 0
attr(,"range_sortna")
[1] 0 2 0 1
> range_sortna(c(0L,1L,NA,2L), na.last=TRUE)
[1]  0  1  2 NA
attr(,"range_sortna")
[1] 0 2 1 0
> range_sortna(c(2L,NA,1L,0L), na.last=TRUE)
[1]  2  1  0 NA
attr(,"range_sortna")
[1] 0 2 1 1
> range_sortna(c(0L,1L,NA,2L), na.last=FALSE)
[1] NA  0  1  2
attr(,"range_sortna")
[1] 0 2 1 0
> range_sortna(c(2L,NA,1L,0L), na.last=FALSE)
[1] NA  2  1  0
attr(,"range_sortna")
[1] 0 2 1 1
> 
> 
> 
> cleanEx()
> nameEx("rep.booltype")
> ### * rep.booltype
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rep.booltype
> ### Title: Replicating bit and bitwhich vectors
> ### Aliases: rep.booltype rep.bit rep.bitwhich
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> 
>  rep(as.bit(c(FALSE,TRUE)), 2)
bit length=4 occupying only 1 int32
    1     2     3     4 
FALSE  TRUE FALSE  TRUE 
>  rep(as.bit(c(FALSE,TRUE)), length.out=7)
bit length=7 occupying only 1 int32
    1     2     3     4     5     6     7 
FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE 
>  rep(as.bitwhich(c(FALSE,TRUE)), 2)
bitwhich: 2/4 occupying only 2 int32 in 1 representation
    1     2     3     4 
FALSE  TRUE FALSE  TRUE 
>  rep(as.bitwhich(c(FALSE,TRUE)), length.out=1)
bitwhich: 0/1 occupying only 1 int32 in FALSE representation
    1 
FALSE 
> 
> 
> 
> cleanEx()
> nameEx("repeat.time")
> ### * repeat.time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: repeat.time
> ### Title: Adaptive timer
> ### Aliases: repeat.time
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
>   system.time(1+1)
   user  system elapsed 
      0       0       0 
>   repeat.time(1+1)
        user       system      elapsed 
4.098626e-06 1.294303e-06 5.392929e-06 
>   system.time(sort(runif(1e6)))
   user  system elapsed 
  0.073   0.000   0.072 
>   repeat.time(sort(runif(1e6)))
    user   system  elapsed 
0.065250 0.005875 0.071125 
> 
> 
> 
> 
> cleanEx()
> nameEx("repfromto")
> ### * repfromto
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: repfromto
> ### Title: Virtual recycling
> ### Aliases: repfromto repfromto<-
> ### Keywords: IO data
> 
> ### ** Examples
> 
> 
>   message("a simple example")
a simple example
>   repfromto(0:9, 11, 20)
 [1] 0 1 2 3 4 5 6 7 8 9
> 
> 
> 
> 
> cleanEx()
> nameEx("rev.booltype")
> ### * rev.booltype
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rev.booltype
> ### Title: Reversing bit and bitwhich vectors
> ### Aliases: rev.booltype rev.bit rev.bitwhich
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> 
>  rev(as.bit(c(FALSE,TRUE)))
bit length=2 occupying only 1 int32
    1     2 
 TRUE FALSE 
>  rev(as.bitwhich(c(FALSE,TRUE)))
bitwhich: 1/2 occupying only 1 int32 in 1 representation
    1     2 
 TRUE FALSE 
> 
> 
> 
> cleanEx()
> nameEx("reverse_vector")
> ### * reverse_vector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reverse_vector
> ### Title: Reverse atomic vector
> ### Aliases: reverse_vector
> 
> ### ** Examples
> 
> x <- factor(letters)
> rev(x)
 [1] z y x w v u t s r q p o n m l k j i h g f e d c b a
Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z
> reverse_vector(x)
 [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2
[26]  1
> ## Not run: 
> ##D x <- 1:1e7
> ##D system.time(rev(x))
> ##D system.time(reverse_vector(x))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ri")
> ### * ri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ri
> ### Title: Range index
> ### Aliases: ri print.ri
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> 
>  bit(12)[ri(1,6)]
[1] FALSE FALSE FALSE FALSE FALSE FALSE
attr(,"vmode")
[1] "boolean"
> 
> 
> 
> 
> cleanEx()
> nameEx("rlepack")
> ### * rlepack
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rlepack
> ### Title: Hybrid Index, rle-pack utilities
> ### Aliases: rlepack rlepack.integer rleunpack rleunpack.rlepack
> ###   rev.rlepack unique.rlepack anyDuplicated.rlepack
> ### Keywords: IO data
> 
> ### ** Examples
> 
> 
>   x <- rlepack(rep(0L, 10))
> ## Don't show: 
>  for (x in list(10:1, 1:10, c(10:1,1:10), c(1:10,10:1), sample(100), sample(100, 100, TRUE), sample(10, 100, TRUE))){
+    stopifnot(identical(rleunpack(rlepack(x)), x))
+    stopifnot(identical(rleunpack(unique(rlepack(x))), unique(x)))
+    stopifnot(identical(anyDuplicated(rlepack(x)), anyDuplicated(x)))
+  }
> ## End(Don't show)
> 
> 
> 
> 
> cleanEx()
> nameEx("still.identical")
> ### * still.identical
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: still.identical
> ### Title: Test for C-level identity of two atomic vectors
> ### Aliases: still.identical
> 
> ### ** Examples
> 
> x <- 1:2
> y <- x
> z <- copy_vector(x)
> still.identical(y,x)
[1] TRUE
> still.identical(z,x)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("str.bit")
> ### * str.bit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str.bit
> ### Title: Str method for bit
> ### Aliases: str.bit
> 
> ### ** Examples
> 
> str(bit(120))
bit  [1:120] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
> 
> 
> 
> cleanEx()
> nameEx("str.bitwhich")
> ### * str.bitwhich
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str.bitwhich
> ### Title: Str method for bitwhich
> ### Aliases: str.bitwhich
> 
> ### ** Examples
> 
> str(bitwhich(120))
bitwhich  [1:120] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
> 
> 
> 
> cleanEx()
> nameEx("symdiff")
> ### * symdiff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: symdiff
> ### Title: Symmetric set complement
> ### Aliases: symdiff
> 
> ### ** Examples
> 
> symdiff(c(1L,2L,2L), c(2L,3L))
[1] 1 3
> symdiff(c(2L,3L), c(1L,2L,2L))
[1] 3 1
> 
> 
> 
> cleanEx()
> nameEx("unattr")
> ### * unattr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unattr
> ### Title: Attribute removal
> ### Aliases: unattr
> ### Keywords: attribute
> 
> ### ** Examples
> 
> 
>   bit(2)[]
[1] FALSE FALSE
attr(,"vmode")
[1] "boolean"
>   unattr(bit(2)[])
[1] FALSE FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("vecseq")
> ### * vecseq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vecseq
> ### Title: Vectorized Sequences
> ### Aliases: vecseq
> ### Keywords: manip
> 
> ### ** Examples
> 
> 
>   sequence(c(3,4))
[1] 1 2 3 1 2 3 4
>   vecseq(c(3,4))
[1] 1 2 3 1 2 3 4
>   vecseq(c(1,11), c(5, 15))
 [1]  1  2  3  4  5 11 12 13 14 15
>   vecseq(c(1,11), c(5, 15), concat=FALSE, eval=FALSE)
[[1]]
1:5

[[2]]
11:15

>   vecseq(c(1,11), c(5, 15), concat=FALSE, eval=TRUE)
[[1]]
[1] 1 2 3 4 5

[[2]]
[1] 11 12 13 14 15

>   vecseq(c(1,11), c(5, 15), concat=TRUE, eval=FALSE)
c(1:5, 11:15)
>   vecseq(c(1,11), c(5, 15), concat=TRUE, eval=TRUE)
 [1]  1  2  3  4  5 11 12 13 14 15
> 
> 
> 
> 
> cleanEx()
> nameEx("xor")
> ### * xor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xor.default
> ### Title: Boolean operators and functions
> ### Aliases: xor.default xor.logical !.bit &.bit |.bit ==.bit !=.bit
> ###   xor.bit !.bitwhich &.bitwhich |.bitwhich ==.bitwhich !=.bitwhich
> ###   xor.bitwhich &.booltype |.booltype ==.booltype !=.booltype
> ###   xor.booltype xor
> ### Keywords: classes logic
> 
> ### ** Examples
> 
> 
>   x <- c(FALSE, FALSE, FALSE, NA, NA, NA, TRUE, TRUE, TRUE)
>   y <- c(FALSE, NA, TRUE, FALSE, NA, TRUE, FALSE, NA, TRUE)
>   
>   x|y
[1] FALSE    NA  TRUE    NA    NA  TRUE  TRUE  TRUE  TRUE
>   x|as.bit(y)
[1] FALSE FALSE  TRUE    NA    NA  TRUE  TRUE  TRUE  TRUE
>   x|as.bitwhich(y)
[1] FALSE FALSE  TRUE    NA    NA  TRUE  TRUE  TRUE  TRUE
>   x|as.which(y)
[1] FALSE FALSE  TRUE    NA    NA  TRUE  TRUE  TRUE  TRUE
>   x|ri(1,1,9)
[1]  TRUE FALSE FALSE    NA    NA    NA  TRUE  TRUE  TRUE
>   
>   
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.27 0.198 1.468 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
