
R version 4.4.1 (2024-06-14) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library("matrixStats")
> 
> for (mode in c("logical", "integer", "double")) {
+   cat("mode: ", mode, "", sep = "")
+   n <- 2L
+   x <- runif(n, min = -5, max = 5)
+   if (mode == "logical") {
+     x <- x > 0
+   }
+   storage.mode(x) <- mode
+   str(x)
+ 
+   cat("All weights are 1\n")
+   w <- rep(1, times = n)
+   m0 <- weighted.mean(x, w)
+   m1 <- weightedMean(x, w)
+   str(list(m0 = m0, m1 = m1))
+   stopifnot(identical(m1, m0))
+ 
+   cat("First weight is 5\n")
+   # Pull the mean towards zero
+   w[1] <- 5
+   str(w)
+   m0 <- weighted.mean(x, w)
+   m1 <- weightedMean(x, w)
+   str(list(m0 = m0, m1 = m1))
+   stopifnot(identical(m1, m0))
+ 
+   cat("All weights are 0\n")
+   # All weights set to zero
+   w <- rep(0, times = n)
+   m0 <- weighted.mean(x, w)
+   m1 <- weightedMean(x, w)
+   str(list(m0 = m0, m1 = m1))
+   stopifnot(identical(m1, m0))
+ 
+   cat("First weight is 8.5\n")
+   # Put even more weight on the zero
+   w[1] <- 8.5
+   m0 <- weighted.mean(x, w)
+   m1 <- weightedMean(x, w)
+   str(list(m0 = m0, m1 = m1))
+   stopifnot(identical(m1, m0))
+ 
+   cat("First weight is Inf\n")
+   # All weight on the first value
+   w[1] <- Inf
+   m0 <- weighted.mean(x, w)
+   m1 <- weightedMean(x, w)
+   str(list(m0 = m0, m1 = m1))
+   stopifnot(identical(m1, m0))
+ 
+   cat("Last weight is Inf\n")
+   # All weight on the last value
+   w[1] <- 1
+   w[n] <- Inf
+   m0 <- weighted.mean(x, w)
+   m1 <- weightedMean(x, w)
+   str(list(m0 = m0, m1 = m1))
+   stopifnot(identical(m1, m0))
+ } # for (mode ...)
mode: logical logi [1:2] TRUE FALSE
All weights are 1
List of 2
 $ m0: num 0.5
 $ m1: num 0.5
First weight is 5
 num [1:2] 5 1
List of 2
 $ m0: num 0.833
 $ m1: num 0.833
All weights are 0
List of 2
 $ m0: num NaN
 $ m1: num NaN
First weight is 8.5
List of 2
 $ m0: num 1
 $ m1: num 1
First weight is Inf
List of 2
 $ m0: num NaN
 $ m1: num NaN
Last weight is Inf
List of 2
 $ m0: num NaN
 $ m1: num NaN
mode: integer int [1:2] 4 4
All weights are 1
List of 2
 $ m0: num 4
 $ m1: num 4
First weight is 5
 num [1:2] 5 1
List of 2
 $ m0: num 4
 $ m1: num 4
All weights are 0
List of 2
 $ m0: num NaN
 $ m1: num NaN
First weight is 8.5
List of 2
 $ m0: num 4
 $ m1: num 4
First weight is Inf
List of 2
 $ m0: num NaN
 $ m1: num NaN
Last weight is Inf
List of 2
 $ m0: num NaN
 $ m1: num NaN
mode: double num [1:2] -3.27 2.87
All weights are 1
List of 2
 $ m0: num -0.202
 $ m1: num -0.202
First weight is 5
 num [1:2] 5 1
List of 2
 $ m0: num -2.25
 $ m1: num -2.25
All weights are 0
List of 2
 $ m0: num NaN
 $ m1: num NaN
First weight is 8.5
List of 2
 $ m0: num -3.27
 $ m1: num -3.27
First weight is Inf
List of 2
 $ m0: num NaN
 $ m1: num NaN
Last weight is Inf
List of 2
 $ m0: num NaN
 $ m1: num NaN
> 
> 
> message("*** Testing for missing values")
*** Testing for missing values
> # NA tests
> xs <- list(A = c(1, 2, 3), B = c(NA, 2, 3), C = c(NA, 2, 3))
> ws <- list(A = c(1, 1, 1), B = c(NA, 1, 1), C = c(1, NA, 1))
> ## NOTE: The (B, B) case with na.rm = TRUE is interesting because
> ## even if NAs in 'w' are not dropped by na.rm = TRUE, this one
> ## is because 'x' is dropped and therefore that first element
> ## is skipped in the computation.  It basically does
> ##   keep <- !is.na(x); x <- x[keep]; w <- w[keep]
> ## without looking at 'w'.
> for (x in xs) {
+   for (mode in c("logical", "integer", "double")) {
+     storage.mode(x) <- mode
+     for (w in ws) {
+       for (na.rm in c(FALSE, TRUE)) {
+         cat(sprintf("mode: %s, na.rm = %s\n", mode, na.rm))
+         str(list(x = x, w = w))
+         m0 <- weighted.mean(x, w, na.rm = na.rm)
+         m1 <- weightedMean(x, w, na.rm = na.rm)
+         str(list(m0 = m0, m1 = m1))
+         stopifnot(all.equal(m1, m0))
+       }
+     }
+   }
+ }
mode: logical, na.rm = FALSE
List of 2
 $ x: logi [1:3] TRUE TRUE TRUE
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: logical, na.rm = TRUE
List of 2
 $ x: logi [1:3] TRUE TRUE TRUE
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: logical, na.rm = FALSE
List of 2
 $ x: logi [1:3] TRUE TRUE TRUE
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = TRUE
List of 2
 $ x: logi [1:3] TRUE TRUE TRUE
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = FALSE
List of 2
 $ x: logi [1:3] TRUE TRUE TRUE
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = TRUE
List of 2
 $ x: logi [1:3] TRUE TRUE TRUE
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = FALSE
List of 2
 $ x: int [1:3] 1 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: integer, na.rm = TRUE
List of 2
 $ x: int [1:3] 1 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: integer, na.rm = FALSE
List of 2
 $ x: int [1:3] 1 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = TRUE
List of 2
 $ x: int [1:3] 1 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = FALSE
List of 2
 $ x: int [1:3] 1 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = TRUE
List of 2
 $ x: int [1:3] 1 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = FALSE
List of 2
 $ x: num [1:3] 1 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: double, na.rm = TRUE
List of 2
 $ x: num [1:3] 1 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: double, na.rm = FALSE
List of 2
 $ x: num [1:3] 1 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = TRUE
List of 2
 $ x: num [1:3] 1 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = FALSE
List of 2
 $ x: num [1:3] 1 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = TRUE
List of 2
 $ x: num [1:3] 1 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = FALSE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = TRUE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: logical, na.rm = FALSE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = TRUE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: logical, na.rm = FALSE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = TRUE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = FALSE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = TRUE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: integer, na.rm = FALSE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = TRUE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: integer, na.rm = FALSE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = TRUE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = FALSE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = TRUE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: double, na.rm = FALSE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = TRUE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: double, na.rm = FALSE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = TRUE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = FALSE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = TRUE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: logical, na.rm = FALSE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = TRUE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: logical, na.rm = FALSE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: logical, na.rm = TRUE
List of 2
 $ x: logi [1:3] NA TRUE TRUE
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = FALSE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = TRUE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: integer, na.rm = FALSE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = TRUE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: integer, na.rm = FALSE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: integer, na.rm = TRUE
List of 2
 $ x: int [1:3] NA 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = FALSE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = TRUE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] 1 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: double, na.rm = FALSE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = TRUE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] NA 1 1
List of 2
 $ m0: num 1
 $ m1: num 1
mode: double, na.rm = FALSE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
mode: double, na.rm = TRUE
List of 2
 $ x: num [1:3] NA 1 1
 $ w: num [1:3] 1 NA 1
List of 2
 $ m0: num NA
 $ m1: num NA
> 
