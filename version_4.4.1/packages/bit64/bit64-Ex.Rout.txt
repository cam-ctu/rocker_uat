
R version 4.4.1 (2024-06-14) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "bit64"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('bit64')
Loading required package: bit

Attaching package: ‘bit’

The following object is masked from ‘package:base’:

    xor

Attaching package bit64
package:bit64 (c) 2011-2017 Jens Oehlschlaegel
creators: integer64 runif64 seq :
coercion: as.integer64 as.vector as.logical as.integer as.double as.character as.bitstring
logical operator: ! & | xor != == < <= >= >
arithmetic operator: + - * / %/% %% ^
math: sign abs sqrt log log2 log10
math: floor ceiling trunc round
querying: is.integer64 is.vector [is.atomic} [length] format print str
values: is.na is.nan is.finite is.infinite
aggregation: any all min max range sum prod
cumulation: diff cummin cummax cumsum cumprod
access: length<- [ [<- [[ [[<-
combine: c rep cbind rbind as.data.frame
WARNING don't use as subscripts
WARNING semantics differ from integer
for more help type ?bit64

Attaching package: ‘bit64’

The following object is masked from ‘package:utils’:

    hashtab

The following objects are masked from ‘package:base’:

    :, %in%, is.double, match, order, rank

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("all.equal.integer64")
> ### * all.equal.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all.equal.integer64
> ### Title: Test if two integer64 vectors are all.equal
> ### Aliases: all.equal.integer64
> 
> ### ** Examples
> 
>   all.equal(as.integer64(1:10), as.integer64(0:9))
[1] "Mean relative difference: 0.1818182"
>   all.equal(as.integer64(1:10), as.integer(1:10))
[1] TRUE
>   all.equal(as.integer64(1:10), as.double(1:10))
[1] TRUE
>   all.equal(as.integer64(1), as.double(1e300))
Error in as.integer64.double(current) : 
  (converted from warning) NAs produced by integer64 overflow
[1] "while coercing 'current' to 'integer64': (converted from warning) NAs produced by integer64 overflow"
> 
> 
> 
> cleanEx()
> nameEx("as.character.integer64")
> ### * as.character.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.character.integer64
> ### Title: Coerce from integer64
> ### Aliases: as.character.integer64 as.double.integer64
> ###   as.integer.integer64 as.logical.integer64 as.bitstring
> ###   print.bitstring as.bitstring.integer64 as.factor.integer64
> ###   as.ordered.integer64 as.list.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   as.character(lim.integer64())
[1] "-9223372036854775807" "9223372036854775807" 
>   as.bitstring(lim.integer64())
[1] "1000000000000000000000000000000000000000000000000000000000000001"
[2] "0111111111111111111111111111111111111111111111111111111111111111"
>   as.bitstring(as.integer64(c(
+    -2,-1,NA,0:2
+   )))
[1] "1111111111111111111111111111111111111111111111111111111111111110"
[2] "1111111111111111111111111111111111111111111111111111111111111111"
[3] "1000000000000000000000000000000000000000000000000000000000000000"
[4] "0000000000000000000000000000000000000000000000000000000000000000"
[5] "0000000000000000000000000000000000000000000000000000000000000001"
[6] "0000000000000000000000000000000000000000000000000000000000000010"
> 
> 
> 
> cleanEx()
> nameEx("as.data.frame.integer64")
> ### * as.data.frame.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.data.frame.integer64
> ### Title: integer64: Coercing to data.frame column
> ### Aliases: as.data.frame.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   as.data.frame.integer64(as.integer64(1:12))
    x
1   1
2   2
3   3
4   4
5   5
6   6
7   7
8   8
9   9
10 10
11 11
12 12
>   data.frame(a=1:12, b=as.integer64(1:12))
    a  b
1   1  1
2   2  2
3   3  3
4   4  4
5   5  5
6   6  6
7   7  7
8   8  8
9   9  9
10 10 10
11 11 11
12 12 12
> 
> 
> 
> cleanEx()
> nameEx("as.integer64.character")
> ### * as.integer64.character
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.integer64.character
> ### Title: Coerce to integer64
> ### Aliases: as.integer64 as.integer64.integer64 as.integer64.NULL
> ###   as.integer64.bitstring as.integer64.character as.integer64.double
> ###   as.integer64.integer as.integer64.logical as.integer64.factor
> ###   NA_integer64_
> ### Keywords: classes manip
> 
> ### ** Examples
> 
> as.integer64(as.character(lim.integer64()))
integer64
[1] -9223372036854775807 9223372036854775807 
> as.integer64(
+   structure(c("1111111111111111111111111111111111111111111111111111111111111110", 
+               "1111111111111111111111111111111111111111111111111111111111111111", 
+               "1000000000000000000000000000000000000000000000000000000000000000",
+               "0000000000000000000000000000000000000000000000000000000000000000", 
+               "0000000000000000000000000000000000000000000000000000000000000001", 
+               "0000000000000000000000000000000000000000000000000000000000000010" 
+   ), class = "bitstring")
+ )
integer64
[1] -2   -1   <NA> 0    1    2   
> as.integer64(
+  structure(c("............................................................... ", 
+              "................................................................", 
+              ".                                                               ",
+              "", 
+              ".", 
+              "10"
+   ), class = "bitstring")
+ )
integer64
[1] -2   -1   <NA> 0    1    2   
> 
> 
> 
> cleanEx()
> nameEx("benchmark64")
> ### * benchmark64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: benchmark64
> ### Title: Function for measuring algorithmic performance of high-level and
> ###   low-level integer64 functions
> ### Aliases: benchmark64 optimizer64
> ### Keywords: misc
> 
> ### ** Examples
> 
> message("this small example using system.time does not give serious timings\n
+ this we do this only to run regression tests")
this small example using system.time does not give serious timings

this we do this only to run regression tests
> benchmark64(nsmall=2^7, nbig=2^13, timefun=function(expr)system.time(expr, gcFirst=FALSE))

compare performance for a complete sessions of calls

=== 32-bit ===
check data range, mean etc.
get all percentiles for plotting distribution shape
list the upper and lower permille of values
OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame
check if any values are duplicated
since not unique, then check distribution of frequencies
OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates
check whether we find a match for each fact in the dimension table
check whether there are any dimension table entries not in the fact table
check whether we find a match for each fact in a parallel fact table
find positions of facts in dimension table for joining
find positions of facts in parallel fact table for joining
out of curiosity: how well rank-correlated are fact and parallel fact table?
        32-bit 64-bit hashcache sortordercache ordercache allcache
seconds  0.019      0         0              0          0        0
factor   1.000    Inf       Inf            Inf        Inf      Inf

=== 64-bit ===
check data range, mean etc.
get all percentiles for plotting distribution shape
list the upper and lower permille of values
OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame
check if any values are duplicated
since not unique, then check distribution of frequencies
OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates
check whether we find a match for each fact in the dimension table
check whether there are any dimension table entries not in the fact table
check whether we find a match for each fact in a parallel fact table
find positions of facts in dimension table for joining
find positions of facts in parallel fact table for joining
out of curiosity: how well rank-correlated are fact and parallel fact table?
        32-bit 64-bit hashcache sortordercache ordercache allcache
seconds  0.019  0.006         0              0          0        0
factor   1.000  3.167       Inf            Inf        Inf      Inf

=== hashcache ===
check data range, mean etc.
get all percentiles for plotting distribution shape
list the upper and lower permille of values
OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame
check if any values are duplicated
since not unique, then check distribution of frequencies
OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates
check whether we find a match for each fact in the dimension table
check whether there are any dimension table entries not in the fact table
check whether we find a match for each fact in a parallel fact table
find positions of facts in dimension table for joining
find positions of facts in parallel fact table for joining
out of curiosity: how well rank-correlated are fact and parallel fact table?
        32-bit 64-bit hashcache sortordercache ordercache allcache
seconds  0.019  0.006     0.006              0          0        0
factor   1.000  3.167     3.167            Inf        Inf      Inf

=== sortordercache ===
check data range, mean etc.
get all percentiles for plotting distribution shape
list the upper and lower permille of values
OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame
check if any values are duplicated
since not unique, then check distribution of frequencies
OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates
check whether we find a match for each fact in the dimension table
check whether there are any dimension table entries not in the fact table
check whether we find a match for each fact in a parallel fact table
find positions of facts in dimension table for joining
find positions of facts in parallel fact table for joining
out of curiosity: how well rank-correlated are fact and parallel fact table?
        32-bit 64-bit hashcache sortordercache ordercache allcache
seconds  0.019  0.006     0.006          0.003          0        0
factor   1.000  3.167     3.167          6.333        Inf      Inf

=== ordercache ===
check data range, mean etc.
get all percentiles for plotting distribution shape
list the upper and lower permille of values
OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame
check if any values are duplicated
since not unique, then check distribution of frequencies
OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates
check whether we find a match for each fact in the dimension table
check whether there are any dimension table entries not in the fact table
check whether we find a match for each fact in a parallel fact table
find positions of facts in dimension table for joining
find positions of facts in parallel fact table for joining
out of curiosity: how well rank-correlated are fact and parallel fact table?
        32-bit 64-bit hashcache sortordercache ordercache allcache
seconds  0.019  0.006     0.006          0.003      0.004        0
factor   1.000  3.167     3.167          6.333      4.750      Inf

=== allcache ===
check data range, mean etc.
get all percentiles for plotting distribution shape
list the upper and lower permille of values
OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame
check if any values are duplicated
since not unique, then check distribution of frequencies
OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates
check whether we find a match for each fact in the dimension table
check whether there are any dimension table entries not in the fact table
check whether we find a match for each fact in a parallel fact table
find positions of facts in dimension table for joining
find positions of facts in parallel fact table for joining
out of curiosity: how well rank-correlated are fact and parallel fact table?
        32-bit 64-bit hashcache sortordercache ordercache allcache
seconds  0.019  0.006     0.006          0.003      0.004    0.004
factor   1.000  3.167     3.167          6.333      4.750    4.750

now let's look more systematically at the components involved
32-bit match(s,b)
32-bit s %in% b
32-bit match(b,s)
32-bit b %in% s
32-bit match(b,b)
32-bit b %in% b
32-bit duplicated(b)
32-bit unique(b)
32-bit table(b)
32-bit sort(b)
32-bit order(b)
32-bit rank(b)
32-bit quantile(b)
32-bit summary(b)
seconds              32-bit 64-bit hashcache sortordercache ordercache allcache
cache          0.000  0.000     0.000          0.000      0.000    0.000
match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000
s %in% b       0.000  0.000     0.000          0.000      0.000    0.000
match(b,s)     0.001  0.000     0.000          0.000      0.000    0.000
b %in% s       0.000  0.000     0.000          0.000      0.000    0.000
match(b,b)     0.000  0.000     0.000          0.000      0.000    0.000
b %in% b       0.001  0.000     0.000          0.000      0.000    0.000
duplicated(b)  0.000  0.000     0.000          0.000      0.000    0.000
unique(b)      0.000  0.000     0.000          0.000      0.000    0.000
table(b)       0.004  0.000     0.000          0.000      0.000    0.000
sort(b)        0.001  0.000     0.000          0.000      0.000    0.000
order(b)       0.000  0.000     0.000          0.000      0.000    0.000
rank(b)        0.001  0.000     0.000          0.000      0.000    0.000
quantile(b)    0.000  0.000     0.000          0.000      0.000    0.000
summary(b)     0.001  0.000     0.000          0.000      0.000    0.000
SESSION        0.019  0.006     0.006          0.003      0.004    0.004
factor              32-bit 64-bit hashcache sortordercache ordercache allcache
cache            NaN    NaN       NaN            NaN        NaN      NaN
match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN
s %in% b         NaN    NaN       NaN            NaN        NaN      NaN
match(b,s)         1    Inf       Inf            Inf        Inf      Inf
b %in% s         NaN    NaN       NaN            NaN        NaN      NaN
match(b,b)       NaN    NaN       NaN            NaN        NaN      NaN
b %in% b           1    Inf       Inf            Inf        Inf      Inf
duplicated(b)    NaN    NaN       NaN            NaN        NaN      NaN
unique(b)        NaN    NaN       NaN            NaN        NaN      NaN
table(b)           1    Inf       Inf            Inf        Inf      Inf
sort(b)            1    Inf       Inf            Inf        Inf      Inf
order(b)         NaN    NaN       NaN            NaN        NaN      NaN
rank(b)            1    Inf       Inf            Inf        Inf      Inf
quantile(b)      NaN    NaN       NaN            NaN        NaN      NaN
summary(b)         1    Inf       Inf            Inf        Inf      Inf
SESSION            1  3.167     3.167          6.333       4.75     4.75
64-bit match(s,b)
64-bit s %in% b
64-bit match(b,s)
64-bit b %in% s
64-bit match(b,b)
64-bit b %in% b
64-bit duplicated(b)
64-bit unique(b)
64-bit table(b)
64-bit sort(b)
64-bit order(b)
64-bit rank(b)
64-bit quantile(b)
64-bit summary(b)
seconds              32-bit 64-bit hashcache sortordercache ordercache allcache
cache          0.000  0.000     0.000          0.000      0.000    0.000
match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000
s %in% b       0.000  0.000     0.000          0.000      0.000    0.000
match(b,s)     0.001  0.001     0.000          0.000      0.000    0.000
b %in% s       0.000  0.000     0.000          0.000      0.000    0.000
match(b,b)     0.000  0.000     0.000          0.000      0.000    0.000
b %in% b       0.001  0.000     0.000          0.000      0.000    0.000
duplicated(b)  0.000  0.001     0.000          0.000      0.000    0.000
unique(b)      0.000  0.000     0.000          0.000      0.000    0.000
table(b)       0.004  0.000     0.000          0.000      0.000    0.000
sort(b)        0.001  0.000     0.000          0.000      0.000    0.000
order(b)       0.000  0.000     0.000          0.000      0.000    0.000
rank(b)        0.001  0.000     0.000          0.000      0.000    0.000
quantile(b)    0.000  0.001     0.000          0.000      0.000    0.000
summary(b)     0.001  0.000     0.000          0.000      0.000    0.000
SESSION        0.019  0.006     0.006          0.003      0.004    0.004
factor              32-bit 64-bit hashcache sortordercache ordercache allcache
cache            NaN    NaN       NaN            NaN        NaN      NaN
match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN
s %in% b         NaN    NaN       NaN            NaN        NaN      NaN
match(b,s)         1  1.000       Inf            Inf        Inf      Inf
b %in% s         NaN    NaN       NaN            NaN        NaN      NaN
match(b,b)       NaN    NaN       NaN            NaN        NaN      NaN
b %in% b           1    Inf       Inf            Inf        Inf      Inf
duplicated(b)    NaN  0.000       NaN            NaN        NaN      NaN
unique(b)        NaN    NaN       NaN            NaN        NaN      NaN
table(b)           1    Inf       Inf            Inf        Inf      Inf
sort(b)            1    Inf       Inf            Inf        Inf      Inf
order(b)         NaN    NaN       NaN            NaN        NaN      NaN
rank(b)            1    Inf       Inf            Inf        Inf      Inf
quantile(b)      NaN  0.000       NaN            NaN        NaN      NaN
summary(b)         1    Inf       Inf            Inf        Inf      Inf
SESSION            1  3.167     3.167          6.333       4.75     4.75
hashcache cache
hashcache match(s,b)
hashcache s %in% b
hashcache match(b,s)
hashcache b %in% s
hashcache match(b,b)
hashcache b %in% b
hashcache duplicated(b)
hashcache unique(b)
hashcache table(b)
hashcache sort(b)
hashcache order(b)
hashcache rank(b)
hashcache quantile(b)
hashcache summary(b)
seconds              32-bit 64-bit hashcache sortordercache ordercache allcache
cache          0.000  0.000     0.000          0.000      0.000    0.000
match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000
s %in% b       0.000  0.000     0.001          0.000      0.000    0.000
match(b,s)     0.001  0.001     0.000          0.000      0.000    0.000
b %in% s       0.000  0.000     0.000          0.000      0.000    0.000
match(b,b)     0.000  0.000     0.000          0.000      0.000    0.000
b %in% b       0.001  0.000     0.000          0.000      0.000    0.000
duplicated(b)  0.000  0.001     0.001          0.000      0.000    0.000
unique(b)      0.000  0.000     0.000          0.000      0.000    0.000
table(b)       0.004  0.000     0.000          0.000      0.000    0.000
sort(b)        0.001  0.000     0.000          0.000      0.000    0.000
order(b)       0.000  0.000     0.001          0.000      0.000    0.000
rank(b)        0.001  0.000     0.000          0.000      0.000    0.000
quantile(b)    0.000  0.001     0.001          0.000      0.000    0.000
summary(b)     0.001  0.000     0.000          0.000      0.000    0.000
SESSION        0.019  0.006     0.006          0.003      0.004    0.004
factor              32-bit 64-bit hashcache sortordercache ordercache allcache
cache            NaN    NaN       NaN            NaN        NaN      NaN
match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN
s %in% b         NaN    NaN     0.000            NaN        NaN      NaN
match(b,s)         1  1.000       Inf            Inf        Inf      Inf
b %in% s         NaN    NaN       NaN            NaN        NaN      NaN
match(b,b)       NaN    NaN       NaN            NaN        NaN      NaN
b %in% b           1    Inf       Inf            Inf        Inf      Inf
duplicated(b)    NaN  0.000     0.000            NaN        NaN      NaN
unique(b)        NaN    NaN       NaN            NaN        NaN      NaN
table(b)           1    Inf       Inf            Inf        Inf      Inf
sort(b)            1    Inf       Inf            Inf        Inf      Inf
order(b)         NaN    NaN     0.000            NaN        NaN      NaN
rank(b)            1    Inf       Inf            Inf        Inf      Inf
quantile(b)      NaN  0.000     0.000            NaN        NaN      NaN
summary(b)         1    Inf       Inf            Inf        Inf      Inf
SESSION            1  3.167     3.167          6.333       4.75     4.75
sortordercache cache
sortordercache match(s,b)
sortordercache s %in% b
sortordercache match(b,s)
sortordercache b %in% s
sortordercache match(b,b)
sortordercache b %in% b
sortordercache duplicated(b)
sortordercache unique(b)
sortordercache table(b)
sortordercache sort(b)
sortordercache order(b)
sortordercache rank(b)
sortordercache quantile(b)
sortordercache summary(b)
seconds              32-bit 64-bit hashcache sortordercache ordercache allcache
cache          0.000  0.000     0.000          0.001      0.000    0.000
match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000
s %in% b       0.000  0.000     0.001          0.000      0.000    0.000
match(b,s)     0.001  0.001     0.000          0.000      0.000    0.000
b %in% s       0.000  0.000     0.000          0.001      0.000    0.000
match(b,b)     0.000  0.000     0.000          0.000      0.000    0.000
b %in% b       0.001  0.000     0.000          0.000      0.000    0.000
duplicated(b)  0.000  0.001     0.001          0.000      0.000    0.000
unique(b)      0.000  0.000     0.000          0.001      0.000    0.000
table(b)       0.004  0.000     0.000          0.000      0.000    0.000
sort(b)        0.001  0.000     0.000          0.000      0.000    0.000
order(b)       0.000  0.000     0.001          0.000      0.000    0.000
rank(b)        0.001  0.000     0.000          0.000      0.000    0.000
quantile(b)    0.000  0.001     0.001          0.001      0.000    0.000
summary(b)     0.001  0.000     0.000          0.000      0.000    0.000
SESSION        0.019  0.006     0.006          0.003      0.004    0.004
factor              32-bit 64-bit hashcache sortordercache ordercache allcache
cache            NaN    NaN       NaN          0.000        NaN      NaN
match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN
s %in% b         NaN    NaN     0.000            NaN        NaN      NaN
match(b,s)         1  1.000       Inf            Inf        Inf      Inf
b %in% s         NaN    NaN       NaN          0.000        NaN      NaN
match(b,b)       NaN    NaN       NaN            NaN        NaN      NaN
b %in% b           1    Inf       Inf            Inf        Inf      Inf
duplicated(b)    NaN  0.000     0.000            NaN        NaN      NaN
unique(b)        NaN    NaN       NaN          0.000        NaN      NaN
table(b)           1    Inf       Inf            Inf        Inf      Inf
sort(b)            1    Inf       Inf            Inf        Inf      Inf
order(b)         NaN    NaN     0.000            NaN        NaN      NaN
rank(b)            1    Inf       Inf            Inf        Inf      Inf
quantile(b)      NaN  0.000     0.000          0.000        NaN      NaN
summary(b)         1    Inf       Inf            Inf        Inf      Inf
SESSION            1  3.167     3.167          6.333       4.75     4.75
ordercache cache
ordercache match(s,b)
ordercache s %in% b
ordercache match(b,s)
ordercache b %in% s
ordercache match(b,b)
ordercache b %in% b
ordercache duplicated(b)
ordercache unique(b)
ordercache table(b)
ordercache sort(b)
ordercache order(b)
ordercache rank(b)
ordercache quantile(b)
ordercache summary(b)
seconds              32-bit 64-bit hashcache sortordercache ordercache allcache
cache          0.000  0.000     0.000          0.001      0.001    0.000
match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000
s %in% b       0.000  0.000     0.001          0.000      0.000    0.000
match(b,s)     0.001  0.001     0.000          0.000      0.000    0.000
b %in% s       0.000  0.000     0.000          0.001      0.000    0.000
match(b,b)     0.000  0.000     0.000          0.000      0.000    0.000
b %in% b       0.001  0.000     0.000          0.000      0.000    0.000
duplicated(b)  0.000  0.001     0.001          0.000      0.000    0.000
unique(b)      0.000  0.000     0.000          0.001      0.000    0.000
table(b)       0.004  0.000     0.000          0.000      0.001    0.000
sort(b)        0.001  0.000     0.000          0.000      0.000    0.000
order(b)       0.000  0.000     0.001          0.000      0.000    0.000
rank(b)        0.001  0.000     0.000          0.000      0.000    0.000
quantile(b)    0.000  0.001     0.001          0.001      0.000    0.000
summary(b)     0.001  0.000     0.000          0.000      0.000    0.000
SESSION        0.019  0.006     0.006          0.003      0.004    0.004
factor              32-bit 64-bit hashcache sortordercache ordercache allcache
cache            NaN    NaN       NaN          0.000       0.00      NaN
match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN
s %in% b         NaN    NaN     0.000            NaN        NaN      NaN
match(b,s)         1  1.000       Inf            Inf        Inf      Inf
b %in% s         NaN    NaN       NaN          0.000        NaN      NaN
match(b,b)       NaN    NaN       NaN            NaN        NaN      NaN
b %in% b           1    Inf       Inf            Inf        Inf      Inf
duplicated(b)    NaN  0.000     0.000            NaN        NaN      NaN
unique(b)        NaN    NaN       NaN          0.000        NaN      NaN
table(b)           1    Inf       Inf            Inf       4.00      Inf
sort(b)            1    Inf       Inf            Inf        Inf      Inf
order(b)         NaN    NaN     0.000            NaN        NaN      NaN
rank(b)            1    Inf       Inf            Inf        Inf      Inf
quantile(b)      NaN  0.000     0.000          0.000        NaN      NaN
summary(b)         1    Inf       Inf            Inf        Inf      Inf
SESSION            1  3.167     3.167          6.333       4.75     4.75
allcache cache
allcache match(s,b)
allcache s %in% b
allcache match(b,s)
allcache b %in% s
allcache match(b,b)
allcache b %in% b
allcache duplicated(b)
allcache unique(b)
allcache table(b)
allcache sort(b)
allcache order(b)
allcache rank(b)
allcache quantile(b)
allcache summary(b)
seconds              32-bit 64-bit hashcache sortordercache ordercache allcache
cache          0.000  0.000     0.000          0.001      0.001    0.001
match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000
s %in% b       0.000  0.000     0.001          0.000      0.000    0.000
match(b,s)     0.001  0.001     0.000          0.000      0.000    0.000
b %in% s       0.000  0.000     0.000          0.001      0.000    0.000
match(b,b)     0.000  0.000     0.000          0.000      0.000    0.000
b %in% b       0.001  0.000     0.000          0.000      0.000    0.000
duplicated(b)  0.000  0.001     0.001          0.000      0.000    0.000
unique(b)      0.000  0.000     0.000          0.001      0.000    0.000
table(b)       0.004  0.000     0.000          0.000      0.001    0.000
sort(b)        0.001  0.000     0.000          0.000      0.000    0.000
order(b)       0.000  0.000     0.001          0.000      0.000    0.000
rank(b)        0.001  0.000     0.000          0.000      0.000    0.000
quantile(b)    0.000  0.001     0.001          0.001      0.000    0.000
summary(b)     0.001  0.000     0.000          0.000      0.000    0.000
SESSION        0.019  0.006     0.006          0.003      0.004    0.004
factor              32-bit 64-bit hashcache sortordercache ordercache allcache
cache            NaN    NaN       NaN          0.000       0.00     0.00
match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN
s %in% b         NaN    NaN     0.000            NaN        NaN      NaN
match(b,s)         1  1.000       Inf            Inf        Inf      Inf
b %in% s         NaN    NaN       NaN          0.000        NaN      NaN
match(b,b)       NaN    NaN       NaN            NaN        NaN      NaN
b %in% b           1    Inf       Inf            Inf        Inf      Inf
duplicated(b)    NaN  0.000     0.000            NaN        NaN      NaN
unique(b)        NaN    NaN       NaN          0.000        NaN      NaN
table(b)           1    Inf       Inf            Inf       4.00      Inf
sort(b)            1    Inf       Inf            Inf        Inf      Inf
order(b)         NaN    NaN     0.000            NaN        NaN      NaN
rank(b)            1    Inf       Inf            Inf        Inf      Inf
quantile(b)      NaN  0.000     0.000          0.000        NaN      NaN
summary(b)         1    Inf       Inf            Inf        Inf      Inf
SESSION            1  3.167     3.167          6.333       4.75     4.75
              32-bit 64-bit hashcache sortordercache ordercache allcache
cache          0.000  0.000     0.000          0.001      0.001    0.001
match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000
s %in% b       0.000  0.000     0.001          0.000      0.000    0.000
match(b,s)     0.001  0.001     0.000          0.000      0.000    0.000
b %in% s       0.000  0.000     0.000          0.001      0.000    0.000
match(b,b)     0.000  0.000     0.000          0.000      0.000    0.000
b %in% b       0.001  0.000     0.000          0.000      0.000    0.000
duplicated(b)  0.000  0.001     0.001          0.000      0.000    0.000
unique(b)      0.000  0.000     0.000          0.001      0.000    0.000
table(b)       0.004  0.000     0.000          0.000      0.001    0.000
sort(b)        0.001  0.000     0.000          0.000      0.000    0.000
order(b)       0.000  0.000     0.001          0.000      0.000    0.000
rank(b)        0.001  0.000     0.000          0.000      0.000    0.000
quantile(b)    0.000  0.001     0.001          0.001      0.000    0.000
summary(b)     0.001  0.000     0.000          0.000      0.000    0.000
SESSION        0.019  0.006     0.006          0.003      0.004    0.004
> optimizer64(nsmall=2^7, nbig=2^13, timefun=function(expr)system.time(expr, gcFirst=FALSE)
+ , plot=FALSE
+ )
match: timings of different methods
%in%: timings of different methods
duplicated: timings of different methods
unique: timings of different methods
unipos: timings of different methods
table: timings of different methods
rank: timings of different methods
quantile: timings of different methods
           128        8192      
match      numeric,27 numeric,27
%in%       numeric,30 numeric,30
duplicated numeric,30 numeric,30
unique     numeric,45 numeric,45
unipos     numeric,42 numeric,42
table      numeric,39 numeric,39
rank       numeric,21 numeric,21
quantile   numeric,18 numeric,18
> ## Not run: 
> ##D message("for real measurement of sufficiently large datasets run this on your machine")
> ##D benchmark64()
> ##D optimizer64()
> ## End(Not run)
> message("let's look at the performance results on Core i7 Lenovo T410 with 8 GB RAM")
let's look at the performance results on Core i7 Lenovo T410 with 8 GB RAM
> data(benchmark64.data)
> print(benchmark64.data)
                    32-bit       64-bit    hashcache sortordercache
cache         2.546532e-05 1.522116e-05  3.340000000   4.900000e+00
match(s,b)    2.370000e+00 6.300000e-01  0.004950495   3.785714e-02
s %in% b      2.390000e+00 6.700000e-01  0.004761905   3.333333e-02
match(b,s)    1.280000e+00 6.200000e-01  0.630000000   6.400000e-01
b %in% s      1.390000e+00 6.300000e-01  0.630000000   6.400000e-01
match(b,b)    7.020000e+00 3.860000e+00  2.260000000   4.230000e+00
b %in% b      7.420000e+00 3.790000e+00  2.200000000   4.130000e+00
duplicated(b) 2.620000e+00 2.090000e+00  0.500000000   6.100000e-01
unique(b)     2.860000e+00 2.090000e+00  1.830000000   7.500000e-01
table(b)      5.105700e+02 2.260000e+00  2.430000000   5.000000e-01
sort(b)       8.420000e+00 1.610000e+00  1.590000000   2.233333e-01
order(b)      5.349000e+01 2.590000e+00  2.540000000   1.120000e-01
rank(b)       5.614000e+01 3.200000e+00  3.280000000   9.000000e-01
quantile(b)   9.600000e-01 1.590000e+00  1.600000000   6.318348e-04
summary(b)    1.640000e+00 1.640000e+00  1.670000000   4.727273e-02
SESSION       8.499700e+02 3.680002e+01 33.954807692   2.131084e+01
                ordercache     allcache
cache         23.620000000 8.590000e+00
match(s,b)     0.166666667 4.950495e-03
s %in% b       0.170000000 4.761905e-03
match(b,s)     0.620000000 6.200000e-01
b %in% s       0.630000000 6.300000e-01
match(b,b)     4.260000000 2.280000e+00
b %in% b       4.180000000 2.210000e+00
duplicated(b)  1.760000000 6.000000e-01
unique(b)      1.890000000 1.820000e+00
table(b)       2.360000000 5.300000e-01
sort(b)        1.510000000 1.833333e-01
order(b)       0.083333333 9.333333e-02
rank(b)        2.910000000 9.200000e-01
quantile(b)    0.000618047 6.082725e-04
summary(b)     0.047272727 4.818182e-02
SESSION       49.277285479 2.187034e+01
> 
> matplot(log2(benchmark64.data[-1,1]/benchmark64.data[-1,])
+ , pch=c("3", "6", "h", "s", "o", "a") 
+ , xlab="tasks [last=session]"
+ , ylab="log2(relative speed) [bigger is better]"
+ )
> matplot(t(log2(benchmark64.data[-1,1]/benchmark64.data[-1,]))
+ , type="b", axes=FALSE 
+ , lwd=c(rep(1, 14), 3)
+ , xlab="context"
+ , ylab="log2(relative speed) [bigger is better]"
+ )
> axis(1
+ , labels=c("32-bit", "64-bit", "hash", "sortorder", "order", "hash+sortorder")
+ , at=1:6
+ )
> axis(2)
> data(optimizer64.data)
> print(optimizer64.data)
           65536      33554432  
match      numeric,27 numeric,27
%in%       numeric,30 numeric,30
duplicated numeric,30 numeric,30
unique     numeric,45 numeric,45
unipos     numeric,42 numeric,42
table      numeric,39 numeric,39
rank       numeric,21 numeric,21
quantile   numeric,18 numeric,18
> oldpar <- par(no.readonly = TRUE)
> par(mfrow=c(2,1))
> par(cex=0.7)
> for (i in 1:nrow(optimizer64.data)){
+  for (j in 1:2){
+    tim <- optimizer64.data[[i,j]]
+   barplot(t(tim))
+   if (rownames(optimizer64.data)[i]=="match")
+    title(paste("match", colnames(optimizer64.data)[j], "in", colnames(optimizer64.data)[3-j]))
+   else if (rownames(optimizer64.data)[i]=="%in%")
+    title(paste(colnames(optimizer64.data)[j], "%in%", colnames(optimizer64.data)[3-j]))
+   else
+    title(paste(rownames(optimizer64.data)[i], colnames(optimizer64.data)[j]))
+  }
+ }
> par(mfrow=c(1,1))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("benchmark64.data")
> ### * benchmark64.data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: benchmark64.data
> ### Title: Results of performance measurement on a Core i7 Lenovo T410 8 GB
> ###   RAM under Windows 7 64bit
> ### Aliases: benchmark64.data
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(benchmark64.data)
> print(benchmark64.data)
                    32-bit       64-bit    hashcache sortordercache
cache         2.546532e-05 1.522116e-05  3.340000000   4.900000e+00
match(s,b)    2.370000e+00 6.300000e-01  0.004950495   3.785714e-02
s %in% b      2.390000e+00 6.700000e-01  0.004761905   3.333333e-02
match(b,s)    1.280000e+00 6.200000e-01  0.630000000   6.400000e-01
b %in% s      1.390000e+00 6.300000e-01  0.630000000   6.400000e-01
match(b,b)    7.020000e+00 3.860000e+00  2.260000000   4.230000e+00
b %in% b      7.420000e+00 3.790000e+00  2.200000000   4.130000e+00
duplicated(b) 2.620000e+00 2.090000e+00  0.500000000   6.100000e-01
unique(b)     2.860000e+00 2.090000e+00  1.830000000   7.500000e-01
table(b)      5.105700e+02 2.260000e+00  2.430000000   5.000000e-01
sort(b)       8.420000e+00 1.610000e+00  1.590000000   2.233333e-01
order(b)      5.349000e+01 2.590000e+00  2.540000000   1.120000e-01
rank(b)       5.614000e+01 3.200000e+00  3.280000000   9.000000e-01
quantile(b)   9.600000e-01 1.590000e+00  1.600000000   6.318348e-04
summary(b)    1.640000e+00 1.640000e+00  1.670000000   4.727273e-02
SESSION       8.499700e+02 3.680002e+01 33.954807692   2.131084e+01
                ordercache     allcache
cache         23.620000000 8.590000e+00
match(s,b)     0.166666667 4.950495e-03
s %in% b       0.170000000 4.761905e-03
match(b,s)     0.620000000 6.200000e-01
b %in% s       0.630000000 6.300000e-01
match(b,b)     4.260000000 2.280000e+00
b %in% b       4.180000000 2.210000e+00
duplicated(b)  1.760000000 6.000000e-01
unique(b)      1.890000000 1.820000e+00
table(b)       2.360000000 5.300000e-01
sort(b)        1.510000000 1.833333e-01
order(b)       0.083333333 9.333333e-02
rank(b)        2.910000000 9.200000e-01
quantile(b)    0.000618047 6.082725e-04
summary(b)     0.047272727 4.818182e-02
SESSION       49.277285479 2.187034e+01
> matplot(log2(benchmark64.data[-1,1]/benchmark64.data[-1,])
+ , pch=c("3", "6", "h", "s", "o", "a")
+ , xlab="tasks [last=session]"
+ , ylab="log2(relative speed) [bigger is better]"
+ )
> matplot(t(log2(benchmark64.data[-1,1]/benchmark64.data[-1,]))
+ , axes=FALSE
+ , type="b"
+ , lwd=c(rep(1, 14), 3)
+ , xlab="context"
+ , ylab="log2(relative speed) [bigger is better]"
+ )
> axis(1
+ , labels=c("32-bit", "64-bit", "hash", "sortorder", "order", "hash+sortorder")
+ , at=1:6
+ )
> axis(2)
> 
> 
> 
> cleanEx()
> nameEx("bit64-package")
> ### * bit64-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bit64-package
> ### Title: A S3 class for vectors of 64bit integers
> ### Aliases: bit64-package bit64 integer64 is.integer64
> ###   is.integer.integer64 is.vector.integer64 length<-.integer64
> ###   print.integer64 str.integer64
> ### Keywords: package classes manip
> 
> ### ** Examples
> 
> message("Using integer64 in vector")
Using integer64 in vector
> x <- integer64(8)    # create 64 bit vector
> x
integer64
[1] 0 0 0 0 0 0 0 0
> is.atomic(x)         # TRUE
[1] TRUE
> is.integer64(x)      # TRUE
[1] TRUE
> is.numeric(x)        # TRUE
[1] TRUE
> is.integer(x)        # FALSE - debatable
[1] FALSE
> is.double(x)         # FALSE - might change
[1] FALSE
> x[] <- 1:2           # assigned value is recycled as usual
> x[1:6]               # subscripting as usual
integer64
[1] 1 2 1 2 1 2
> length(x) <- 13      # changing length as usual
> x
integer64
 [1] 1 2 1 2 1 2 1 2 0 0 0 0 0
> rep(x, 2)            # replicate as usual
integer64
 [1] 1 2 1 2 1 2 1 2 0 0 0 0 0 1 2 1 2 1 2 1 2 0 0 0 0 0
> seq(as.integer64(1), 10)     # seq.integer64 is dispatched on first given argument
integer64
 [1] 1  2  3  4  5  6  7  8  9  10
> seq(to=as.integer64(10), 1)  # seq.integer64 is dispatched on first given argument
integer64
 [1] 1  2  3  4  5  6  7  8  9  10
> seq.integer64(along.with=x)  # or call seq.integer64 directly
integer64
 [1] 1  2  3  4  5  6  7  8  9  10 11 12 13
> # c.integer64 is dispatched only if *first* argument is integer64 ...
> x <- c(x,runif(length(x), max=100))
> # ... and coerces everything to integer64 - including double
> x
integer64
 [1] 1  2  1  2  1  2  1  2  0  0  0  0  0  26 37 57 90 20 89 94 66 62 6  20 17
[26] 68
> names(x) <- letters  # use names as usual
> x
integer64
 a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z 
 1  2  1  2  1  2  1  2  0  0  0  0  0 26 37 57 90 20 89 94 66 62  6 20 17 68 
> 
> message("Using integer64 in array - note that 'matrix' currently does not work")
Using integer64 in array - note that 'matrix' currently does not work
> message("as.vector.integer64 removed as requested by the CRAN maintainer")
as.vector.integer64 removed as requested by the CRAN maintainer
> message("as consequence 'array' also does not work anymore")
as consequence 'array' also does not work anymore
> message("we still can create a matrix or array by assigning 'dim'")
we still can create a matrix or array by assigning 'dim'
> y <- rep(as.integer64(NA), 12)
> dim(y) <- c(3,4)
> dimnames(y) <- list(letters[1:3], LETTERS[1:4])
> y["a",] <- 1:2       # assigning as usual
> y
integer64
  A    B    C    D   
a 1    2    1    2   
b <NA> <NA> <NA> <NA>
c <NA> <NA> <NA> <NA>
> y[1:2,-4]            # subscripting as usual
integer64
  A    B    C   
a 1    2    1   
b <NA> <NA> <NA>
> # cbind.integer64 dispatched on any argument and coerces everything to integer64
> cbind(E=1:3, F=runif(3, 0, 100), G=c("-1","0","1"), y)
integer64
  E F  G  A    B    C    D   
a 1 38 -1 1    2    1    2   
b 2 76 0  <NA> <NA> <NA> <NA>
c 3 49 1  <NA> <NA> <NA> <NA>
> 
> message("Using integer64 in data.frame")
Using integer64 in data.frame
> str(as.data.frame(x))
'data.frame':	26 obs. of  1 variable:
 $ x:integer64 1 2 1 2 1 2 1 2 ... 
> str(as.data.frame(y))
'data.frame':	3 obs. of  4 variables:
 $ A:integer64 1 NA NA 
 $ B:integer64 2 NA NA 
 $ C:integer64 1 NA NA 
 $ D:integer64 2 NA NA 
> str(data.frame(y))
'data.frame':	3 obs. of  4 variables:
 $ A:integer64 1 NA NA 
 $ B:integer64 2 NA NA 
 $ C:integer64 1 NA NA 
 $ D:integer64 2 NA NA 
> str(data.frame(I(y)))
'data.frame':	3 obs. of  1 variable:
 $ y:integer64 1 NA NA 2 NA NA 1 NA ... 
> d <- data.frame(x=x, y=runif(length(x), 0, 100))
> d
   x         y
a  1 71.761851
b  2 99.190609
c  1 38.003518
d  2 77.744522
e  1 93.470523
f  2 21.214252
g  1 65.167377
h  2 12.555510
i  0 26.722067
j  0 38.611409
k  0  1.339033
l  0 38.238796
m  0 86.969085
n 26 34.034900
o 37 48.208012
p 57 59.956583
q 90 49.354131
r 20 18.621760
s 89 82.737332
t 94 66.846674
u 66 79.423986
v 62 10.794363
w  6 72.371095
x 20 41.127443
y 17 82.094629
z 68 64.706019
> d$x
integer64
 [1] 1  2  1  2  1  2  1  2  0  0  0  0  0  26 37 57 90 20 89 94 66 62 6  20 17
[26] 68
> 
> message("Using integer64 with csv files")
Using integer64 with csv files
> fi64 <- tempfile()
> write.csv(d, file=fi64, row.names=FALSE)
> e <- read.csv(fi64, colClasses=c("integer64", NA))
> unlink(fi64)
> str(e)
'data.frame':	26 obs. of  2 variables:
 $ x:integer64 1 2 1 2 1 2 1 2 ... 
 $ y: num  71.8 99.2 38 77.7 93.5 ...
> identical.integer64(d$x,e$x)
[1] TRUE
> 
> message("Serializing and unserializing integer64")
Serializing and unserializing integer64
> dput(d, fi64)
> e <- dget(fi64)
> identical.integer64(d$x,e$x)
[1] TRUE
> e <- d[,]
> save(e, file=fi64)
> rm(e)
> load(file=fi64)
> identical.integer64(d,e)
[1] TRUE
> 
> ### A couple of unit tests follow hidden in a dontshow{} directive ###
>   ## Don't show: 
> message("Testing identical.integer64")
Testing identical.integer64
> i64 <- as.double(NA); class(i64) <- "integer64"
> stopifnot(identical(unclass(i64-1), unclass(i64+1)))
> stopifnot(identical(i64-1, i64+1))
> stopifnot(!identical.integer64(i64-1, i64+1))
> 
> message("Testing dispatch of 'c' method")
Testing dispatch of 'c' method
> stopifnot(identical.integer64(c(integer64(0), NA), as.integer64(NA)))
> message("Dispatch on the second argument fails and we want to be notified once that changes")
Dispatch on the second argument fails and we want to be notified once that changes
> stopifnot(!identical.integer64(c(NA, integer64(0)), as.integer64(NA)))
> 
> message("Testing minus and plus")
Testing minus and plus
> d64 <- c(-.Machine$double.base^.Machine$double.digits, -.Machine$integer.max, -1, 0, 1, .Machine$integer.max, .Machine$double.base^.Machine$double.digits)
> i64 <- as.integer64(d64)
> stopifnot(identical.integer64(i64-1+1,i64))
> stopifnot(identical.integer64(i64+1-1,i64))
> 
> message("Testing minus and plus edge cases and 'rev'\nUBSAN signed integer overflow expected for type 'long long int'\nThis is a false UBSAN alarm because overflow is detected and NA returned")
Testing minus and plus edge cases and 'rev'
UBSAN signed integer overflow expected for type 'long long int'
This is a false UBSAN alarm because overflow is detected and NA returned
> stopifnot(identical.integer64(lim.integer64()+1-1, c(lim.integer64()[1], NA)))
Warning in `+.integer64`(lim.integer64(), 1) :
  NAs produced by integer64 overflow
> stopifnot(identical.integer64(rev(lim.integer64())-1+1, c(lim.integer64()[2], NA)))
Warning in `-.integer64`(rev(lim.integer64()), 1) :
  NAs produced by integer64 overflow
> 
> message("Testing 'range.integer64', multiplication and integer division")
Testing 'range.integer64', multiplication and integer division
> i64 <- integer64(63)
> i64[1] <- 1
> for (i in 2:63)
+ 	i64[i] <- 2*i64[i-1]
> stopifnot(identical.integer64(i64 * rev(i64), rep(i64[63], 63)))
> for (i in 63:2)
+ 	i64[i-1] <- i64[i]%/%2
> stopifnot(identical.integer64(i64 * rev(i64), rep(i64[63], 63)))
> for (i in 63:2)
+ 	i64[i-1] <- i64[i]/2
> stopifnot(identical.integer64(i64 * rev(i64), rep(i64[63], 63)))
> stopifnot(identical.integer64(c( -i64[63] - (i64[63]-1), i64[63]+(i64[63]-1) ), lim.integer64()))
> 
> stopifnot(identical.integer64(i64[-1]%/%2*as.integer64(2), i64[-1]))
> stopifnot(identical.integer64(i64[-1]%/%2L*as.integer64(2), i64[-1]))
> stopifnot(identical.integer64(i64[-1]/2*as.integer64(2), i64[-1]))
> stopifnot(identical.integer64(i64[-1]/2*as.integer64(2), i64[-1]))
> 
> stopifnot(identical.integer64(i64[-63]*2%/%2, i64[-63]))
> stopifnot(identical.integer64(i64[-63]*2L%/%2L, i64[-63]))
> stopifnot(identical.integer64(as.integer64(i64[-63]*2/2), i64[-63]))
> stopifnot(identical.integer64(as.integer64(i64[-63]*2L/2L), i64[-63]))
> 
> message("Testing sqrt, power and log")
Testing sqrt, power and log
> stopifnot(identical.integer64( as.integer64(sqrt(i64[-1][c(FALSE, TRUE)])*sqrt(i64[-1][c(FALSE, TRUE)])), i64[-1][c(FALSE, TRUE)] ))
> 
> stopifnot(identical.integer64(as.integer64(2)^(0:62), i64))
> stopifnot(identical.integer64(as.integer64(0:62), as.integer64(round(log2(i64)))))
> stopifnot(identical.integer64(as.integer64(round(log(as.integer64(2)^(0:62), 2))), as.integer64(0:62)))
> stopifnot(identical.integer64(as.integer64(round(log(as.integer64(3)^(0:39), 3))), as.integer64(0:39)))
> stopifnot(identical.integer64(as.integer64(round(log(as.integer64(10)^(0:18), 10))), as.integer64(0:18)))
> stopifnot(identical.integer64(as.integer64(round(log10(as.integer64(10)^(0:18)))), as.integer64(0:18)))
> 
> stopifnot(identical.integer64((as.integer64(2)^(1:62))^(1/1:62), as.integer64(rep(2, 62))))
> stopifnot(identical.integer64((as.integer64(3)^(1:39))^(1/1:39), as.integer64(rep(3, 39))))
> stopifnot(identical.integer64((as.integer64(10)^(1:18))^(1/1:18), as.integer64(rep(10, 18))))
> 
> message("Testing c and rep")
Testing c and rep
> stopifnot(identical.integer64( as.integer64(rep(1:3, 1:3)), rep(as.integer64(1:3), 1:3)))
> stopifnot(identical.integer64( as.integer64(rep(1:3, 3)), rep(as.integer64(1:3), 3)))
> 
> x <- as.double(c(NA,NA,NA))
> class(x) <- "integer64"
> x <- x + -1:1
> stopifnot(identical.integer64(rep(x, 3), c(x,x,x) ))
> stopifnot(identical.integer64(c.integer64(list(x,x,x), recursive=TRUE), c(x,x,x) ))
> 
> message("Testing seq")
Testing seq
> stopifnot(identical.integer64(seq(as.integer64(1), 10, 2), as.integer64(seq(1, 10, 2)) ))
> stopifnot(identical.integer64(seq(as.integer64(1), by=2, length.out=5), as.integer64(seq(1, by=2, length.out=5)) ))
> stopifnot(identical.integer64(seq(as.integer64(1), by=2, length.out=6), as.integer64(seq(1, by=2, length.out=6)) ))
> stopifnot(identical.integer64(seq.integer64(along.with=3:5), as.integer64(seq(along.with=3:5)) ))
> stopifnot(identical.integer64(seq(as.integer64(1), to=-9), as.integer64(seq(1, to=-9)) ))
> 
> message("Testing cbind and rbind")
Testing cbind and rbind
> stopifnot(identical.integer64( cbind(as.integer64(1:3), 1:3), {x <- rep(as.integer64(1:3), 2); dim(x)<-c(3,2);x}))
> stopifnot(identical.integer64( rbind(as.integer64(1:3), 1:3), t({x <- rep(as.integer64(1:3), 2); dim(x)<-c(3,2);x})))
> 
> message("Testing coercion")
Testing coercion
> stopifnot(identical( as.double(as.integer64(c(NA, seq(0, 9, 0.25)))), as.double(as.integer(c(NA, seq(0, 9, 0.25))))))
> stopifnot(identical( as.character(as.integer64(c(NA, seq(0, 9, 0.25)))), as.character(as.integer(c(NA, seq(0, 9, 0.25))))))
> stopifnot(identical( as.integer(as.integer64(c(NA, seq(0, 9, 0.25)))), as.integer(c(NA, seq(0, 9, 0.25)))))
> stopifnot(identical( as.logical(as.integer64(c(NA, seq(0, 9, 0.25)))), as.logical(as.integer(c(NA, seq(0, 9, 0.25))))))
> stopifnot(identical( as.integer(as.integer64(c(NA, FALSE, TRUE))), as.integer(c(NA, FALSE, TRUE))))
> stopifnot(identical( as.integer64(as.integer(as.integer64(-9:9))), as.integer64(-9:9)))
> stopifnot(identical( as.integer64(as.double(as.integer64(-9:9))), as.integer64(-9:9)))
> stopifnot(identical( as.integer64(as.character(as.integer64(-9:9))), as.integer64(-9:9)))
> stopifnot(identical( as.integer64(as.character(lim.integer64())), lim.integer64()))
> 
> message("-- testing logical operators --")
-- testing logical operators --
> stopifnot(identical.integer64(!c(NA, -1:1), !c(as.integer64(NA), -1:1)))
> stopifnot(identical.integer64(rep(c(NA, -1:1), 4)&rep(c(NA, -1:1), rep(4, 4)), as.integer64(rep(c(NA, -1:1), 4))&as.integer64(rep(c(NA, -1:1), rep(4, 4)))))
> stopifnot(identical.integer64(rep(c(NA, -1:1), 4)|rep(c(NA, -1:1), rep(4, 4)), as.integer64(rep(c(NA, -1:1), 4))|as.integer64(rep(c(NA, -1:1), rep(4, 4)))))
> stopifnot(identical.integer64(xor(rep(c(NA, -1:1), 4),rep(c(NA, -1:1), rep(4, 4))), xor(as.integer64(rep(c(NA, -1:1), 4)),as.integer64(rep(c(NA, -1:1), rep(4, 4))))))
default
> 
> message("-- testing comparison operators --")
-- testing comparison operators --
> stopifnot(identical.integer64(rep(c(NA, -1:1), 4)==rep(c(NA, -1:1), rep(4, 4)), as.integer64(rep(c(NA, -1:1), 4))==as.integer64(rep(c(NA, -1:1), rep(4, 4)))))
> stopifnot(identical.integer64(rep(c(NA, -1:1), 4)!=rep(c(NA, -1:1), rep(4, 4)), as.integer64(rep(c(NA, -1:1), 4))!=as.integer64(rep(c(NA, -1:1), rep(4, 4)))))
> stopifnot(identical.integer64(rep(c(NA, -1:1), 4)>rep(c(NA, -1:1), rep(4, 4)), as.integer64(rep(c(NA, -1:1), 4))>as.integer64(rep(c(NA, -1:1), rep(4, 4)))))
> stopifnot(identical.integer64(rep(c(NA, -1:1), 4)>=rep(c(NA, -1:1), rep(4, 4)), as.integer64(rep(c(NA, -1:1), 4))>=as.integer64(rep(c(NA, -1:1), rep(4, 4)))))
> stopifnot(identical.integer64(rep(c(NA, -1:1), 4)<rep(c(NA, -1:1), rep(4, 4)), as.integer64(rep(c(NA, -1:1), 4))<as.integer64(rep(c(NA, -1:1), rep(4, 4)))))
> stopifnot(identical.integer64(rep(c(NA, -1:1), 4)<=rep(c(NA, -1:1), rep(4, 4)), as.integer64(rep(c(NA, -1:1), 4))<=as.integer64(rep(c(NA, -1:1), rep(4, 4)))))
> 
> message("-- testing vector functions --")
-- testing vector functions --
> stopifnot(identical.integer64( is.na(as.integer64(c(NA, -1:1))), is.na(c(NA, -1:1)) ))
> stopifnot(identical.integer64( format(as.integer64(c(NA, -1:1))), format(c(NA, -1:1)) ))
> stopifnot(identical.integer64( abs(as.integer64(c(NA, -1:1))), as.integer64(abs(c(NA, -1:1))) ))
> stopifnot(identical.integer64( sign(as.integer64(c(NA, -1:1))), as.integer64(sign(c(NA, -1:1))) ))
> stopifnot(identical.integer64( ceiling(as.integer64(c(NA, -1:1))), as.integer64(ceiling(c(NA, -1:1))) ))
> stopifnot(identical.integer64( floor(as.integer64(c(NA, -1:1))), as.integer64(floor(c(NA, -1:1))) ))
> stopifnot(identical.integer64( trunc(as.integer64(c(NA, -1:1))), as.integer64(trunc(c(NA, -1:1))) ))
> stopifnot(identical.integer64( signif(as.integer64(c(NA, -1:1))), as.integer64(c(NA, -1:1)) ))
> 
> message("Testing summary functions")
Testing summary functions
> stopifnot(identical(all(as.integer(1)), all(as.integer64(1))))
> stopifnot(identical(all(as.integer(0)), all(as.integer64(0))))
> stopifnot(identical(all(as.integer(NA)), all(as.integer64(NA))))
> stopifnot(identical(all(as.integer(NA), na.rm=TRUE), all(as.integer64(NA), na.rm=TRUE)))
> stopifnot(identical(all(as.integer(1), NA), all(as.integer64(1), NA)))
> stopifnot(identical(all(as.integer(0), NA), all(as.integer64(0), NA)))
> stopifnot(identical(all(as.integer(1), NA, na.rm=TRUE), all(as.integer64(1), NA, na.rm=TRUE)))
> stopifnot(identical(all(as.integer(0), NA, na.rm=TRUE), all(as.integer64(0), NA, na.rm=TRUE)))
> stopifnot(identical(all(as.integer(c(1, NA))), all(as.integer64(c(1, NA)))))
> stopifnot(identical(all(as.integer(c(0, NA))), all(as.integer64(c(0, NA)))))
> stopifnot(identical(all(as.integer(c(1, NA)), na.rm=TRUE), all(as.integer64(c(1, NA)), na.rm=TRUE)))
> stopifnot(identical(all(as.integer(c(0, NA)), na.rm=TRUE), all(as.integer64(c(0, NA)), na.rm=TRUE)))
> 
> stopifnot(identical(any(as.integer(1)), any(as.integer64(1))))
> stopifnot(identical(any(as.integer(0)), any(as.integer64(0))))
> stopifnot(identical(any(as.integer(NA)), any(as.integer64(NA))))
> stopifnot(identical(any(as.integer(NA), na.rm=TRUE), any(as.integer64(NA), na.rm=TRUE)))
> stopifnot(identical(any(as.integer(1), NA), any(as.integer64(1), NA)))
> stopifnot(identical(any(as.integer(0), NA), any(as.integer64(0), NA)))
> stopifnot(identical(any(as.integer(1), NA, na.rm=TRUE), any(as.integer64(1), NA, na.rm=TRUE)))
> stopifnot(identical(any(as.integer(0), NA, na.rm=TRUE), any(as.integer64(0), NA, na.rm=TRUE)))
> stopifnot(identical(any(as.integer(c(1, NA))), any(as.integer64(c(1, NA)))))
> stopifnot(identical(any(as.integer(c(0, NA))), any(as.integer64(c(0, NA)))))
> stopifnot(identical(any(as.integer(c(1, NA)), na.rm=TRUE), any(as.integer64(c(1, NA)), na.rm=TRUE)))
> stopifnot(identical(any(as.integer(c(0, NA)), na.rm=TRUE), any(as.integer64(c(0, NA)), na.rm=TRUE)))
> 
> stopifnot(identical.integer64(as.integer64(sum(c(2, 3, NA))), sum(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(sum(c(2, 3, NA), na.rm=TRUE)), sum(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(sum(c(2, 3, NA))), sum(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(sum(c(2, 3, NA), na.rm=TRUE)), sum(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(sum(2, 3, NA)), sum(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(sum(2, 3, NA, na.rm=TRUE)), sum(as.integer64(2), 3, NA, na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(sum(2, 3, NA)), sum(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(sum(2, 3, NA, na.rm=TRUE)), sum(as.integer64(2), 3, NA, na.rm=TRUE)))
> 
> stopifnot(identical.integer64(as.integer64(prod(c(2, 3, NA))), prod(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(prod(c(2, 3, NA), na.rm=TRUE)), prod(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(prod(c(2, 3, NA))), prod(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(prod(c(2, 3, NA), na.rm=TRUE)), prod(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(prod(2, 3, NA)), prod(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(prod(2, 3, NA, na.rm=TRUE)), prod(as.integer64(2), 3, NA, na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(prod(2, 3, NA)), prod(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(prod(2, 3, NA, na.rm=TRUE)), prod(as.integer64(2), 3, NA, na.rm=TRUE)))
> 
> stopifnot(identical.integer64(as.integer64(min(c(2, 3, NA))), min(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(min(c(2, 3, NA), na.rm=TRUE)), min(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(min(c(2, 3, NA))), min(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(min(c(2, 3, NA), na.rm=TRUE)), min(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(min(2, 3, NA)), min(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(min(2, 3, NA, na.rm=TRUE)), min(as.integer64(2), 3, NA, na.rm=TRUE)))
Warning in min(e, na.rm = na.rm) :
  no non-missing arguments to min; returning Inf
Warning in as.integer64.double(min(e, na.rm = na.rm)) :
  NAs produced by integer64 overflow
> stopifnot(identical.integer64(as.integer64(min(2, 3, NA)), min(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(min(2, 3, NA, na.rm=TRUE)), min(as.integer64(2), 3, NA, na.rm=TRUE)))
Warning in min(e, na.rm = na.rm) :
  no non-missing arguments to min; returning Inf
Warning in as.integer64.double(min(e, na.rm = na.rm)) :
  NAs produced by integer64 overflow
> 
> stopifnot(identical.integer64(as.integer64(max(c(2, 3, NA))), max(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(max(c(2, 3, NA), na.rm=TRUE)), max(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(max(c(2, 3, NA))), max(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(max(c(2, 3, NA), na.rm=TRUE)), max(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(max(2, 3, NA)), max(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(max(2, 3, NA, na.rm=TRUE)), max(as.integer64(2), 3, NA, na.rm=TRUE)))
Warning in max(e, na.rm = na.rm) :
  no non-missing arguments to max; returning -Inf
Warning in as.integer64.double(max(e, na.rm = na.rm)) :
  NAs produced by integer64 overflow
> stopifnot(identical.integer64(as.integer64(max(2, 3, NA)), max(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(max(2, 3, NA, na.rm=TRUE)), max(as.integer64(2), 3, NA, na.rm=TRUE)))
Warning in max(e, na.rm = na.rm) :
  no non-missing arguments to max; returning -Inf
Warning in as.integer64.double(max(e, na.rm = na.rm)) :
  NAs produced by integer64 overflow
> 
> stopifnot(identical.integer64(as.integer64(range(c(2, 3, NA))), range(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(range(c(2, 3, NA), na.rm=TRUE)), range(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(range(c(2, 3, NA))), range(as.integer64(c(2, 3, NA)))))
> stopifnot(identical.integer64(as.integer64(range(c(2, 3, NA), na.rm=TRUE)), range(as.integer64(c(2, 3, NA)), na.rm=TRUE)))
> stopifnot(identical.integer64(as.integer64(range(2, 3, NA)), range(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(range(2, 3, NA, na.rm=TRUE)), range(as.integer64(2), 3, NA, na.rm=TRUE)))
Warning in min(x, na.rm = na.rm) :
  no non-missing arguments to min; returning Inf
Warning in max(x, na.rm = na.rm) :
  no non-missing arguments to max; returning -Inf
Warning in as.integer64.double(range(e, na.rm = na.rm)) :
  NAs produced by integer64 overflow
> stopifnot(identical.integer64(as.integer64(range(2, 3, NA)), range(as.integer64(2), 3, NA)))
> stopifnot(identical.integer64(as.integer64(range(2, 3, NA, na.rm=TRUE)), range(as.integer64(2), 3, NA, na.rm=TRUE)))
Warning in min(x, na.rm = na.rm) :
  no non-missing arguments to min; returning Inf
Warning in max(x, na.rm = na.rm) :
  no non-missing arguments to max; returning -Inf
Warning in as.integer64.double(range(e, na.rm = na.rm)) :
  NAs produced by integer64 overflow
> 
> message("-- testing cummulative functions --")
-- testing cummulative functions --
> stopifnot(identical.integer64(as.integer64(cumsum(c(2, 3, NA, 1, 4))), cumsum(as.integer64(c(2, 3, NA, 1, 4)))))
> stopifnot(identical.integer64(as.integer64(cumprod(c(2, 3, NA, 1, 4))), cumprod(as.integer64(c(2, 3, NA, 1, 4)))))
> stopifnot(identical.integer64(as.integer64(cummin(c(2, 3, NA, 1, 4))), cummin(as.integer64(c(2, 3, NA, 1, 4)))))
> stopifnot(identical.integer64(as.integer64(cummax(c(2, 3, NA, 1, 4))), cummax(as.integer64(c(2, 3, NA, 1, 4)))))
> 
> message("testing diff")
testing diff
> d64 <- diffinv(rep(.Machine$integer.max, 100), lag=2, differences=2)
> i64 <- as.integer64(d64)
> identical(diff(d64, lag=2, differences=2), as.double(diff(i64, lag=2, differences=2)))
[1] TRUE
> 
>   
> ## End(Don't show)
> 
>   ## Not run: 
> ##D message("== Differences between integer64 and int64 ==")
> ##D require(bit64)
> ##D require(int64)
> ##D 
> ##D message("-- integer64 is atomic --")
> ##D is.atomic(integer64())
> ##D #is.atomic(int64())
> ##D str(integer64(3))
> ##D #str(int64(3))
> ##D 
> ##D message("-- The following performance numbers are measured under RWin64  --")
> ##D message("-- under RWin32 the advantage of integer64 over int64 is smaller --")
> ##D 
> ##D message("-- integer64 needs 7x/5x less RAM than int64 under 64/32 bit OS
> ##D (and twice the RAM of integer as it should be) --")
> ##D #as.vector(object.size(int64(1e6))/object.size(integer64(1e6)))
> ##D as.vector(object.size(integer64(1e6))/object.size(integer(1e6)))
> ##D 
> ##D message("-- integer64 creates 2000x/1300x faster than int64 under 64/32 bit OS
> ##D (and 3x the time of integer) --")
> ##D t32 <- system.time(integer(1e8))
> ##D t64 <- system.time(integer64(1e8))
> ##D #T64 <- system.time(int64(1e7))*10  # using 1e8 as above stalls our R on an i7 8 GB RAM Thinkpad
> ##D #T64/t64
> ##D t64/t32
> ##D 
> ##D i32 <- sample(1e6)
> ##D d64 <- as.double(i32)
> ##D 
> ##D message("-- the following timings are rather conservative since timings
> ##D  of integer64 include garbage collection -- due to looped calls")
> ##D message("-- integer64 coerces 900x/100x faster than int64
> ##D  under 64/32 bit OS (and 2x the time of coercing to integer) --")
> ##D t32 <- system.time(for(i in 1:1000)as.integer(d64))
> ##D t64 <- system.time(for(i in 1:1000)as.integer64(d64))
> ##D #T64 <- system.time(as.int64(d64))*1000
> ##D #T64/t64
> ##D t64/t32
> ##D td64 <- system.time(for(i in 1:1000)as.double(i32))
> ##D t64 <- system.time(for(i in 1:1000)as.integer64(i32))
> ##D #T64 <- system.time(for(i in 1:10)as.int64(i32))*100
> ##D #T64/t64
> ##D t64/td64
> ##D 
> ##D message("-- integer64 serializes 4x/0.8x faster than int64
> ##D  under 64/32 bit OS (and less than 2x/6x the time of integer or double) --")
> ##D t32 <- system.time(for(i in 1:10)serialize(i32, NULL))
> ##D td64 <- system.time(for(i in 1:10)serialize(d64, NULL))
> ##D i64 <- as.integer64(i32);
> ##D t64 <- system.time(for(i in 1:10)serialize(i64, NULL))
> ##D rm(i64); gc()
> ##D #I64 <- as.int64(i32);
> ##D #T64 <- system.time(for(i in 1:10)serialize(I64, NULL))
> ##D #rm(I64); gc()
> ##D #T64/t64
> ##D t64/t32
> ##D t64/td64
> ##D 
> ##D 
> ##D message("-- integer64 adds 250x/60x faster than int64
> ##D  under 64/32 bit OS (and less than 6x the time of integer or double) --")
> ##D td64 <- system.time(for(i in 1:100)d64+d64)
> ##D t32 <- system.time(for(i in 1:100)i32+i32)
> ##D i64 <- as.integer64(i32);
> ##D t64 <- system.time(for(i in 1:100)i64+i64)
> ##D rm(i64); gc()
> ##D #I64 <- as.int64(i32);
> ##D #T64 <- system.time(for(i in 1:10)I64+I64)*10
> ##D #rm(I64); gc()
> ##D #T64/t64
> ##D t64/t32
> ##D t64/td64
> ##D 
> ##D message("-- integer64 sums 3x/0.2x faster than int64
> ##D (and at about 5x/60X the time of integer and double) --")
> ##D td64 <- system.time(for(i in 1:100)sum(d64))
> ##D t32 <- system.time(for(i in 1:100)sum(i32))
> ##D i64 <- as.integer64(i32);
> ##D t64 <- system.time(for(i in 1:100)sum(i64))
> ##D rm(i64); gc()
> ##D #I64 <- as.int64(i32);
> ##D #T64 <- system.time(for(i in 1:100)sum(I64))
> ##D #rm(I64); gc()
> ##D #T64/t64
> ##D t64/t32
> ##D t64/td64
> ##D 
> ##D message("-- integer64 diffs 5x/0.85x faster than integer and double
> ##D (int64 version 1.0 does not support diff) --")
> ##D td64 <- system.time(for(i in 1:10)diff(d64, lag=2L, differences=2L))
> ##D t32 <- system.time(for(i in 1:10)diff(i32, lag=2L, differences=2L))
> ##D i64 <- as.integer64(i32);
> ##D t64 <- system.time(for(i in 1:10)diff(i64, lag=2L, differences=2L))
> ##D rm(i64); gc()
> ##D t64/t32
> ##D t64/td64
> ##D 
> ##D 
> ##D message("-- integer64 subscripts 1000x/340x faster than int64
> ##D (and at the same speed / 10x slower as integer) --")
> ##D ts32 <- system.time(for(i in 1:1000)sample(1e6, 1e3))
> ##D t32<- system.time(for(i in 1:1000)i32[sample(1e6, 1e3)])
> ##D i64 <- as.integer64(i32);
> ##D t64 <- system.time(for(i in 1:1000)i64[sample(1e6, 1e3)])
> ##D rm(i64); gc()
> ##D #I64 <- as.int64(i32);
> ##D #T64 <- system.time(for(i in 1:100)I64[sample(1e6, 1e3)])*10
> ##D #rm(I64); gc()
> ##D #(T64-ts32)/(t64-ts32)
> ##D (t64-ts32)/(t32-ts32)
> ##D 
> ##D message("-- integer64 assigns 200x/90x faster than int64
> ##D (and 50x/160x slower than integer) --")
> ##D ts32 <- system.time(for(i in 1:100)sample(1e6, 1e3))
> ##D t32 <- system.time(for(i in 1:100)i32[sample(1e6, 1e3)] <- 1:1e3)
> ##D i64 <- as.integer64(i32);
> ##D i64 <- system.time(for(i in 1:100)i64[sample(1e6, 1e3)] <- 1:1e3)
> ##D rm(i64); gc()
> ##D #I64 <- as.int64(i32);
> ##D #I64 <- system.time(for(i in 1:10)I64[sample(1e6, 1e3)] <- 1:1e3)*10
> ##D #rm(I64); gc()
> ##D #(T64-ts32)/(t64-ts32)
> ##D (t64-ts32)/(t32-ts32)
> ##D 
> ##D 
> ##D tdfi32 <- system.time(dfi32 <- data.frame(a=i32, b=i32, c=i32))
> ##D tdfsi32 <- system.time(dfi32[1e6:1,])
> ##D fi32 <- tempfile()
> ##D tdfwi32 <- system.time(write.csv(dfi32, file=fi32, row.names=FALSE))
> ##D tdfri32 <- system.time(read.csv(fi32, colClasses=rep("integer", 3)))
> ##D unlink(fi32)
> ##D rm(dfi32); gc()
> ##D 
> ##D i64 <- as.integer64(i32);
> ##D tdfi64 <- system.time(dfi64 <- data.frame(a=i64, b=i64, c=i64))
> ##D tdfsi64 <- system.time(dfi64[1e6:1,])
> ##D fi64 <- tempfile()
> ##D tdfwi64 <- system.time(write.csv(dfi64, file=fi64, row.names=FALSE))
> ##D tdfri64 <- system.time(read.csv(fi64, colClasses=rep("integer64", 3)))
> ##D unlink(fi64)
> ##D rm(i64, dfi64); gc()
> ##D 
> ##D #I64 <- as.int64(i32);
> ##D #tdfI64 <- system.time(dfI64<-data.frame(a=I64, b=I64, c=I64))
> ##D #tdfsI64 <- system.time(dfI64[1e6:1,])
> ##D #fI64 <- tempfile()
> ##D #tdfwI64 <- system.time(write.csv(dfI64, file=fI64, row.names=FALSE))
> ##D #tdfrI64 <- system.time(read.csv(fI64, colClasses=rep("int64", 3)))
> ##D #unlink(fI64)
> ##D #rm(I64, dfI64); gc()
> ##D 
> ##D message("-- integer64 coerces 40x/6x faster to data.frame than int64
> ##D (and factor 1/9 slower than integer) --")
> ##D #tdfI64/tdfi64
> ##D tdfi64/tdfi32
> ##D message("-- integer64 subscripts from data.frame 20x/2.5x faster than int64
> ##D  (and 3x/13x slower than integer) --")
> ##D #tdfsI64/tdfsi64
> ##D tdfsi64/tdfsi32
> ##D message("-- integer64 csv writes about 2x/0.5x faster than int64
> ##D (and about 1.5x/5x slower than integer) --")
> ##D #tdfwI64/tdfwi64
> ##D tdfwi64/tdfwi32
> ##D message("-- integer64 csv reads about 3x/1.5 faster than int64
> ##D (and about 2x slower than integer) --")
> ##D #tdfrI64/tdfri64
> ##D tdfri64/tdfri32
> ##D 
> ##D rm(i32, d64); gc()
> ##D 
> ##D 
> ##D message("-- investigating the impact on garbage collection: --")
> ##D message("-- the fragmented structure of int64 messes up R's RAM --")
> ##D message("-- and slows down R's gargbage collection just by existing --")
> ##D 
> ##D td32 <- double(21)
> ##D td32[1] <- system.time(d64 <- double(1e7))[3]
> ##D for (i in 2:11)td32[i] <- system.time(gc(), gcFirst=FALSE)[3]
> ##D rm(d64)
> ##D for (i in 12:21)td32[i] <- system.time(gc(), gcFirst=FALSE)[3]
> ##D 
> ##D t64 <- double(21)
> ##D t64[1] <- system.time(i64 <- integer64(1e7))[3]
> ##D for (i in 2:11)t64[i] <- system.time(gc(), gcFirst=FALSE)[3]
> ##D rm(i64)
> ##D for (i in 12:21)t64[i] <- system.time(gc(), gcFirst=FALSE)[3]
> ##D 
> ##D #T64 <- double(21)
> ##D #T64[1] <- system.time(I64 <- int64(1e7))[3]
> ##D #for (i in 2:11)T64[i] <- system.time(gc(), gcFirst=FALSE)[3]
> ##D #rm(I64)
> ##D #for (i in 12:21)T64[i] <- system.time(gc(), gcFirst=FALSE)[3]
> ##D 
> ##D #matplot(1:21, cbind(td32, t64, T64), pch=c("d","i","I"), log="y")
> ##D matplot(1:21, cbind(td32, t64), pch=c("d","i"), log="y")
> ##D   
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("bit64S3")
> ### * bit64S3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bit64S3
> ### Title: Turning base R functions into S3 generics for bit64
> ### Aliases: bit64S3 : :.default :.integer64 is.double is.double.default
> ###   is.double.integer64 match match.default %in% %in%.default rank
> ###   rank.default order order.default
> ### Keywords: methods
> 
> ### ** Examples
> 
>  is.double(as.integer64(1))
[1] FALSE
> 	as.integer64(1):9
integer64
[1] 1 2 3 4 5 6 7 8 9
>  match(as.integer64(2), as.integer64(0:3))
[1] 3
>  as.integer64(2) %in% as.integer64(0:3)
[1] TRUE
>  
>  unique(as.integer64(c(1,1,2)))
integer64
[1] 1 2
>  rank(as.integer64(c(1,1,2)))
[1] 1.5 1.5 3.0
>  
>  
>  
>  
>  
>  
>  order(as.integer64(c(1,NA,2)))
[1] 1 3 2
>  
>  ## Don't show: 
>  stopifnot(identical(match(as.integer64(2), as.integer64(0:3)), match(2, 0:3)))
>  stopifnot(identical(as.integer64(2) %in% as.integer64(0:3), 2 %in% 0:3))
>  
>  stopifnot(identical(unique(as.integer64(c(1,1,2))), as.integer64(unique(c(1,1,2)))))
>  stopifnot(identical(rank(as.integer64(c(1,1,2))), rank(c(1,1,2))))
>  
>  
>  
>  
>  
>  
>  stopifnot(identical(order(as.integer64(c(1,NA,2))), order(c(1,NA,2))))
>  stopifnot(identical(order(as.integer64(c(1,NA,2)), decreasing=TRUE), order(c(1,NA,2), decreasing=TRUE)))
>  
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("c.integer64")
> ### * c.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: c.integer64
> ### Title: Concatenating integer64 vectors
> ### Aliases: c.integer64 cbind.integer64 rbind.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   c(as.integer64(1), 2:6)
integer64
[1] 1 2 3 4 5 6
>   cbind(1:6, as.integer(1:6))
     [,1] [,2]
[1,]    1    1
[2,]    2    2
[3,]    3    3
[4,]    4    4
[5,]    5    5
[6,]    6    6
>   rbind(1:6, as.integer(1:6))
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    2    3    4    5    6
[2,]    1    2    3    4    5    6
> 
> 
> 
> cleanEx()
> nameEx("cache")
> ### * cache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cache
> ### Title: Atomic Caching
> ### Aliases: cache newcache jamcache setcache getcache remcache print.cache
> ### Keywords: environment
> 
> ### ** Examples
> 
> 	x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> 	y <- x
> 	still.identical(x,y)
[1] TRUE
> 	y[1] <- NA
> 	still.identical(x,y)
[1] FALSE
> 	mycache <- newcache(x)
> 	ls(mycache)
[1] "x"
> 	mycache
cache_integer64: x
> 	rm(mycache)
> 	jamcache(x)
cache_integer64: x
> 	cache(x)
cache_integer64: x
> 	x[1] <- NA
> 	cache(x)
Warning in cache(x) : removed outdated cache
NULL
> 	getcache(x, "abc")
NULL
> 	setcache(x, "abc", 1)
cache_integer64: abc - x
> 	getcache(x, "abc")
[1] 1
> 	remcache(x)
> 	cache(x)
NULL
> 
> 
> 
> cleanEx()
> nameEx("cumsum.integer64")
> ### * cumsum.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cumsum.integer64
> ### Title: Cumulative Sums, Products, Extremes and lagged differences
> ### Aliases: cummin.integer64 cummax.integer64 cumsum.integer64
> ###   cumprod.integer64 diff.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   cumsum(rep(as.integer64(1), 12))
integer64
 [1] 1  2  3  4  5  6  7  8  9  10 11 12
>   diff(as.integer64(c(0,1:12)))
integer64
 [1] 1 1 1 1 1 1 1 1 1 1 1 1
>   cumsum(as.integer64(c(0, 1:12)))
integer64
 [1] 0  1  3  6  10 15 21 28 36 45 55 66 78
>   diff(cumsum(as.integer64(c(0,0,1:12))), differences=2)
integer64
 [1] 1 1 1 1 1 1 1 1 1 1 1 1
> 
> 
> 
> cleanEx()
> nameEx("duplicated.integer64")
> ### * duplicated.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: duplicated.integer64
> ### Title: Determine Duplicate Elements of integer64
> ### Aliases: duplicated.integer64
> ### Keywords: logic manip
> 
> ### ** Examples
> 
> x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> duplicated(x)
 [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE
[13]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE
[25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
> 
> stopifnot(identical(duplicated(x),  duplicated(as.integer(x))))
> 
> 
> 
> cleanEx()
> nameEx("extract.replace.integer64")
> ### * extract.replace.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extract.replace.integer64
> ### Title: Extract or Replace Parts of an integer64 vector
> ### Aliases: [.integer64 [[.integer64 [[<-.integer64 [<-.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   as.integer64(1:12)[1:3]
integer64
[1] 1 2 3
>   x <- as.integer64(1:12)
>   dim(x) <- c(3,4)
>   x
integer64
     [,1] [,2] [,3] [,4]
[1,] 1    4    7    10  
[2,] 2    5    8    11  
[3,] 3    6    9    12  
>   x[]
integer64
     [,1] [,2] [,3] [,4]
[1,] 1    4    7    10  
[2,] 2    5    8    11  
[3,] 3    6    9    12  
>   x[,2:3]
integer64
     [,1] [,2]
[1,] 4    7   
[2,] 5    8   
[3,] 6    9   
>   ## Don't show: 
>     r <- c(runif64(1e3, lim.integer64()[1], lim.integer64()[2]), NA, -2:2)
>     stopifnot(identical(r, as.integer64(as.bitstring(r))))
>   
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("format.integer64")
> ### * format.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format.integer64
> ### Title: Unary operators and functions for integer64 vectors
> ### Aliases: format.integer64 is.na.integer64 is.nan.integer64
> ###   is.finite.integer64 is.infinite.integer64 !.integer64 sign.integer64
> ###   abs.integer64 sqrt.integer64 log.integer64 log2.integer64
> ###   log10.integer64 floor.integer64 ceiling.integer64 trunc.integer64
> ###   round.integer64 signif.integer64 scale.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   sqrt(as.integer64(1:12))
 [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
 [9] 3.000000 3.162278 3.316625 3.464102
> ## Don't show: 
> i <- -999:999
> for (s in -3:3){
+ r <- as.integer64(round(as.integer(i), s))
+   r64 <- round(as.integer64(i), s)
+   stopifnot(identical(r,r64))
+ }
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("hashcache")
> ### * hashcache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hashcache
> ### Title: Big caching of hashing, sorting, ordering
> ### Aliases: hashcache sortcache sortordercache ordercache
> ### Keywords: environment
> 
> ### ** Examples
> 
> 	x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
>  sortordercache(x)
> 
> 
> 
> cleanEx()
> nameEx("hashmap")
> ### * hashmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hashmap
> ### Title: Hashing for 64bit integers
> ### Aliases: hashfun hashfun.integer64 hashmap hashmap.integer64 hashpos
> ###   hashpos.cache_integer64 hashrev hashrev.cache_integer64 hashfin
> ###   hashfin.cache_integer64 hashrin hashrin.cache_integer64 hashdup
> ###   hashdup.cache_integer64 hashuni hashuni.cache_integer64 hashmapuni
> ###   hashmapuni.integer64 hashupo hashupo.cache_integer64 hashmapupo
> ###   hashmapupo.integer64 hashtab hashtab.cache_integer64 hashmaptab
> ###   hashmaptab.integer64
> ### Keywords: programming manip
> 
> ### ** Examples
> 
> x <- as.integer64(sample(c(NA, 0:9)))
> y <- as.integer64(sample(c(NA, 1:9), 10, TRUE))
> hashfun(y)
 [1]  8  7  7  8  1  8 11 15  7  7
> hx <- hashmap(x)
> hy <- hashmap(y)
> ls(hy)
[1] "hashbits" "hashmap"  "nhash"    "nunique"  "x"       
> hashpos(hy, x)
 [1] NA NA  5  1 NA NA NA  4  8  7  2
> hashrev(hx, y)
 [1] NA NA  5  1 NA NA NA  4  8  7  2
> hashfin(hy, x)
 [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
> hashrin(hx, y)
 [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
> hashdup(hy)
 [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE
> hashuni(hy)
integer64
[1] 5    4    <NA> 9    6    8   
> hashuni(hy, keep.order=TRUE)
integer64
[1] <NA> 4    9    5    6    8   
> hashmapuni(y)
integer64
[1] <NA> 4    9    5    6    8   
> hashupo(hy)
[1] 5 2 1 4 7 8
> hashupo(hy, keep.order=TRUE)
[1] 1 2 4 5 7 8
> hashmapupo(y)
[1] 1 2 4 5 7 8
> hashtab(hy)
$values
integer64
[1] 5    4    <NA> 9    6    8   

$counts
[1] 1 4 1 2 1 1

> hashmaptab(y)
$values
integer64
[1] 5    4    <NA> 9    6    8   

$counts
[1] 1 4 1 2 1 1

> 
> stopifnot(identical(match(as.integer(x),as.integer(y)),hashpos(hy, x)))
> stopifnot(identical(match(as.integer(x),as.integer(y)),hashrev(hx, y)))
> stopifnot(identical(as.integer(x) %in% as.integer(y), hashfin(hy, x)))
> stopifnot(identical(as.integer(x) %in% as.integer(y), hashrin(hx, y)))
> stopifnot(identical(duplicated(as.integer(y)), hashdup(hy)))
> stopifnot(identical(as.integer64(unique(as.integer(y))), hashuni(hy, keep.order=TRUE)))
> stopifnot(identical(sort(hashuni(hy, keep.order=FALSE)), sort(hashuni(hy, keep.order=TRUE))))
> stopifnot(identical(y[hashupo(hy, keep.order=FALSE)], hashuni(hy, keep.order=FALSE)))
> stopifnot(identical(y[hashupo(hy, keep.order=TRUE)], hashuni(hy, keep.order=TRUE)))
> stopifnot(identical(hashpos(hy, hashuni(hy, keep.order=TRUE)), hashupo(hy, keep.order=TRUE)))
> stopifnot(identical(hashpos(hy, hashuni(hy, keep.order=FALSE)), hashupo(hy, keep.order=FALSE)))
> stopifnot(identical(hashuni(hy, keep.order=FALSE), hashtab(hy)$values))
> stopifnot(identical(as.vector(table(as.integer(y), useNA="ifany"))
+ , hashtab(hy)$counts[order.integer64(hashtab(hy)$values)]))
> stopifnot(identical(hashuni(hy, keep.order=TRUE), hashmapuni(y)))
> stopifnot(identical(hashupo(hy, keep.order=TRUE), hashmapupo(y)))
> stopifnot(identical(hashtab(hy), hashmaptab(y)))
> 
> 	## Not run: 
> ##D 	message("explore speed given size of the hasmap in 2^hashbits and size of the data")
> ##D 	message("more hashbits means more random access and less collisions")
> ##D 	message("i.e. more data means less random access and more collisions")
> ##D 	bits <- 24
> ##D 	b <- seq(-1, 0, 0.1)
> ##D 	tim <- matrix(NA, length(b), 2, dimnames=list(b, c("bits","bits+1")))
> ##D     for (i in 1:length(b)){
> ##D 	  n <- as.integer(2^(bits+b[i]))
> ##D 	  x <- as.integer64(sample(n))
> ##D 	  tim[i,1] <- repeat.time(hashmap(x, hashbits=bits))[3]
> ##D 	  tim[i,2] <- repeat.time(hashmap(x, hashbits=bits+1))[3]
> ##D 	  print(tim)
> ##D       matplot(b, tim)
> ##D 	}
> ##D 	message("we conclude that n*sqrt(2) is enough to avoid collisions")
> ##D 	
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("identical.integer64")
> ### * identical.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: identical.integer64
> ### Title: Identity function for class 'integer64'
> ### Aliases: identical.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   i64 <- as.double(NA); class(i64) <- "integer64"
>   identical(i64-1, i64+1)
[1] TRUE
>   identical.integer64(i64-1, i64+1)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("is.sorted.integer64")
> ### * is.sorted.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.sorted.integer64
> ### Title: Small cache access methods
> ### Aliases: is.sorted.integer64 na.count.integer64 nvalid.integer64
> ###   nunique.integer64 nties.integer64
> ### Keywords: environment methods
> 
> ### ** Examples
> 
> 	x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
>  length(x)
[1] 32
>  na.count(x)
[1] 17
>  nvalid(x)
[1] 15
>  nunique(x)
[1] 7
>  nties(x)
[1] 30
>  table.integer64(x)
x
<NA>    1    2    3    5    6    9 
  17    5    1    2    3    3    1 
>  x
integer64
 [1] <NA> <NA> <NA> <NA> 2    5    9    <NA> 1    5    1    <NA> <NA> 6    <NA>
[16] <NA> 5    <NA> <NA> <NA> 1    3    6    <NA> <NA> <NA> 1    1    <NA> 6   
[31] 3    <NA>
> 
> 
> 
> cleanEx()
> nameEx("keypos")
> ### * keypos
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: keypos
> ### Title: Extract Positions in redundant dimension table
> ### Aliases: keypos keypos.integer64
> ### Keywords: manip univar
> 
> ### ** Examples
> 
> x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> keypos(x)
 [1] 1 1 1 1 3 5 7 1 2 5 2 1 1 6 1 1 5 1 1 1 2 4 6 1 1 1 2 2 1 6 4 1
> 
> stopifnot(identical(keypos(x),  match.integer64(x, sort(unique(x), na.last=FALSE))))
> 
> 
> 
> cleanEx()
> nameEx("match.integer64")
> ### * match.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match.integer64
> ### Title: 64-bit integer matching
> ### Aliases: match.integer64 %in%.integer64
> ### Keywords: manip logic
> 
> ### ** Examples
> 
> x <- as.integer64(c(NA, 0:9), 32)
> table <- as.integer64(c(1:9, NA))
> match.integer64(x, table)
 [1] 10 NA  1  2  3  4  5  6  7  8  9
> "%in%.integer64"(x, table)
 [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
> 
> x <- as.integer64(sample(c(rep(NA, 9), 0:9), 32, TRUE))
> table <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> stopifnot(identical(match.integer64(x, table), match(as.integer(x), as.integer(table))))
> stopifnot(identical("%in%.integer64"(x, table), as.integer(x) %in% as.integer(table)))
> 
> ## Not run: 
> ##D 	message("check when reverse hash-lookup beats standard hash-lookup")
> ##D 	e <- 4:24
> ##D 	timx <- timy <- matrix(NA, length(e), length(e), dimnames=list(e,e))
> ##D 	for (iy in seq_along(e))
> ##D 	for (ix in 1:iy){
> ##D 		nx <- 2^e[ix]
> ##D 		ny <- 2^e[iy]
> ##D 		x <- as.integer64(sample(ny, nx, FALSE))
> ##D 		y <- as.integer64(sample(ny, ny, FALSE))
> ##D 		#hashfun(x, bits=as.integer(5))
> ##D 		timx[ix,iy] <- repeat.time({
> ##D 		hx <- hashmap(x)
> ##D 		py <- hashrev(hx, y)
> ##D 		})[3]
> ##D 		timy[ix,iy] <- repeat.time({
> ##D 		hy <- hashmap(y)
> ##D 		px <- hashpos(hy, x)
> ##D 		})[3]
> ##D 		#identical(px, py)
> ##D 		print(round(timx[1:iy,1:iy]/timy[1:iy,1:iy], 2), na.print="")
> ##D 	}
> ##D 
> ##D 	message("explore best low-level method given size of x and table")
> ##D 	B1 <- 1:27
> ##D 	B2 <- 1:27
> ##D 	tim <- array(NA, dim=c(length(B1), length(B2), 5)
> ##D  , dimnames=list(B1, B2, c("hashpos","hashrev","sortpos1","sortpos2","sortpos3")))
> ##D 	for (i1 in B1)
> ##D 	for (i2 in B2)
> ##D 	{
> ##D 	  b1 <- B1[i1]
> ##D 	  b2 <- B1[i2]
> ##D 	  n1 <- 2^b1
> ##D 	  n2 <- 2^b2
> ##D 	  x1 <- as.integer64(c(sample(n2, n1-1, TRUE), NA))
> ##D 	  x2 <- as.integer64(c(sample(n2, n2-1, TRUE), NA))
> ##D 	  tim[i1,i2,1] <- repeat.time({h <- hashmap(x2);hashpos(h, x1);rm(h)})[3]
> ##D 	  tim[i1,i2,2] <- repeat.time({h <- hashmap(x1);hashrev(h, x2);rm(h)})[3]
> ##D 	  s <- clone(x2); o <- seq_along(s); ramsortorder(s, o)
> ##D 	  tim[i1,i2,3] <- repeat.time(sortorderpos(s, o, x1, method=1))[3]
> ##D 	  tim[i1,i2,4] <- repeat.time(sortorderpos(s, o, x1, method=2))[3]
> ##D 	  tim[i1,i2,5] <- repeat.time(sortorderpos(s, o, x1, method=3))[3]
> ##D 	  rm(s,o)
> ##D 	  print(apply(tim, 1:2, function(ti)if(any(is.na(ti)))NA else which.min(ti)))
> ##D 	}
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("optimizer64.data")
> ### * optimizer64.data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: optimizer64.data
> ### Title: Results of performance measurement on a Core i7 Lenovo T410 8 GB
> ###   RAM under Windows 7 64bit
> ### Aliases: optimizer64.data
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(optimizer64.data)
> print(optimizer64.data)
           65536      33554432  
match      numeric,27 numeric,27
%in%       numeric,30 numeric,30
duplicated numeric,30 numeric,30
unique     numeric,45 numeric,45
unipos     numeric,42 numeric,42
table      numeric,39 numeric,39
rank       numeric,21 numeric,21
quantile   numeric,18 numeric,18
> oldpar <- par(no.readonly = TRUE)
> par(mfrow=c(2,1))
> par(cex=0.7)
> for (i in 1:nrow(optimizer64.data)){
+  for (j in 1:2){
+    tim <- optimizer64.data[[i,j]]
+   barplot(t(tim))
+   if (rownames(optimizer64.data)[i]=="match")
+    title(paste("match", colnames(optimizer64.data)[j], "in", colnames(optimizer64.data)[3-j]))
+   else if (rownames(optimizer64.data)[i]=="%in%")
+    title(paste(colnames(optimizer64.data)[j], "%in%", colnames(optimizer64.data)[3-j]))
+   else
+    title(paste(rownames(optimizer64.data)[i], colnames(optimizer64.data)[j]))
+  }
+ }
> par(mfrow=c(1,1))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("plusclass")
> ### * plusclass
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plusclass
> ### Title: integer64: Maintaining S3 class attribute
> ### Aliases: plusclass minusclass
> ### Keywords: classes manip internal
> 
> ### ** Examples
> 
>   plusclass("inheritingclass","integer64")
[1] "inheritingclass" "integer64"      
>   minusclass(c("inheritingclass","integer64"), "integer64")
[1] "inheritingclass"
> 
> 
> 
> cleanEx()
> nameEx("prank")
> ### * prank
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prank
> ### Title: (P)ercent (Rank)s
> ### Aliases: prank prank.integer64
> ### Keywords: univar
> 
> ### ** Examples
> 
> x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> prank(x)
 [1]        NA        NA        NA        NA 0.3571429 0.6428571 1.0000000
 [8]        NA 0.1428571 0.6428571 0.1428571        NA        NA 0.8571429
[15]        NA        NA 0.6428571        NA        NA        NA 0.1428571
[22] 0.4642857 0.8571429        NA        NA        NA 0.1428571 0.1428571
[29]        NA 0.8571429 0.4642857        NA
> 
> x <- x[!is.na(x)]
> stopifnot(identical(x,  unname(qtile(x, probs=prank(x)))))
> 
> 
> 
> cleanEx()
> nameEx("qtile")
> ### * qtile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qtile
> ### Title: (Q)uan(Tile)s
> ### Aliases: qtile qtile.integer64 quantile.integer64 median.integer64
> ###   mean.integer64 summary.integer64
> ### Keywords: univar
> 
> ### ** Examples
> 
> x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> qtile(x, probs=seq(0, 1, 0.25))
integer64
  0%  25%  50%  75% 100% 
   1    1    3    6    9 
> quantile(x, probs=seq(0, 1, 0.25), na.rm=TRUE)
integer64
  0%  25%  50%  75% 100% 
   1    1    3    6    9 
> median(x, na.rm=TRUE)
integer64
[1] 3
> summary(x)
integer64
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
      1       1       3       3       6       9      17 
> 
> x <- x[!is.na(x)]
> stopifnot(identical(x,  unname(qtile(x, probs=prank(x)))))
> 
> 
> 
> cleanEx()
> nameEx("ramsort.integer64")
> ### * ramsort.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ramsort.integer64
> ### Title: Low-level intger64 methods for in-RAM sorting and ordering
> ### Aliases: ramsort.integer64 shellsort.integer64 quicksort.integer64
> ###   mergesort.integer64 radixsort.integer64 ramorder.integer64
> ###   shellorder.integer64 quickorder.integer64 mergeorder.integer64
> ###   radixorder.integer64 ramsortorder.integer64 shellsortorder.integer64
> ###   quicksortorder.integer64 mergesortorder.integer64
> ###   radixsortorder.integer64
> ### Keywords: programming manip
> 
> ### ** Examples
> 
>   x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
>   x
integer64
 [1] <NA> <NA> <NA> <NA> 2    5    9    <NA> 1    5    1    <NA> <NA> 6    <NA>
[16] <NA> 5    <NA> <NA> <NA> 1    3    6    <NA> <NA> <NA> 1    1    <NA> 6   
[31] 3    <NA>
>   message("ramsort example")
ramsort example
>   s <- clone(x)
>   ramsort(s)
[1] 17
>   message("s has been changed in-place - whether or not ramsort uses an in-place algorithm")
s has been changed in-place - whether or not ramsort uses an in-place algorithm
>   s
integer64
 [1] <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA>
[16] <NA> <NA> 1    1    1    1    1    2    3    3    5    5    5    6    6   
[31] 6    9   
>   message("ramorder example")
ramorder example
>   s <- clone(x)
>   o <- seq_along(s)
>   ramorder(s, o)
[1] 17
>   message("o has been changed in-place - s remains unchanged")
o has been changed in-place - s remains unchanged
>   s
integer64
 [1] <NA> <NA> <NA> <NA> 2    5    9    <NA> 1    5    1    <NA> <NA> 6    <NA>
[16] <NA> 5    <NA> <NA> <NA> 1    3    6    <NA> <NA> <NA> 1    1    <NA> 6   
[31] 3    <NA>
>   o
 [1]  1  2  3  4  8 12 13 15 16 18 19 20 24 25 26 29 32  9 11 21 27 28  5 22 31
[26]  6 10 17 14 23 30  7
>   s[o]
integer64
 [1] <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA>
[16] <NA> <NA> 1    1    1    1    1    2    3    3    5    5    5    6    6   
[31] 6    9   
>   message("ramsortorder example")
ramsortorder example
>   o <- seq_along(s)
>   ramsortorder(s, o)
[1] 17
>   message("s and o have both been changed in-place - this is much faster")
s and o have both been changed in-place - this is much faster
>   s
integer64
 [1] <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA>
[16] <NA> <NA> 1    1    1    1    1    2    3    3    5    5    5    6    6   
[31] 6    9   
>   o
 [1]  1  2  3  4  8 12 13 15 16 18 19 20 24 25 26 29 32  9 11 21 27 28  5 22 31
[26]  6 10 17 14 23 30  7
> 
> 
> 
> cleanEx()
> nameEx("rank.integer64")
> ### * rank.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rank.integer64
> ### Title: Sample Ranks from integer64
> ### Aliases: rank.integer64
> ### Keywords: univar
> 
> ### ** Examples
> 
> x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> rank.integer64(x)
 [1]   NA   NA   NA   NA  6.0 10.0 15.0   NA  3.0 10.0  3.0   NA   NA 13.0   NA
[16]   NA 10.0   NA   NA   NA  3.0  7.5 13.0   NA   NA   NA  3.0  3.0   NA 13.0
[31]  7.5   NA
> 
> stopifnot(identical(rank.integer64(x),  rank(as.integer(x)
+ , na.last="keep", ties.method = "average")))
> 
> 
> 
> cleanEx()
> nameEx("rep.integer64")
> ### * rep.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rep.integer64
> ### Title: Replicate elements of integer64 vectors
> ### Aliases: rep.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   rep(as.integer64(1:2), 6)
integer64
 [1] 1 2 1 2 1 2 1 2 1 2 1 2
>   rep(as.integer64(1:2), c(6,6))
integer64
 [1] 1 1 1 1 1 1 2 2 2 2 2 2
>   rep(as.integer64(1:2), length.out=6)
integer64
[1] 1 2 1 2 1 2
> 
> 
> 
> cleanEx()
> nameEx("runif64")
> ### * runif64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: runif64
> ### Title: integer64: random numbers
> ### Aliases: runif64
> ### Keywords: classes distribution sysdata
> 
> ### ** Examples
> 
>   runif64(12)
integer64
 [1] -2358897695403777998 7530104633388598430  7348992561071091027 
 [4] 2966195729679662345  -8083616515568591307 -5966474807582474256
 [7] -2137909046254978381 -42441489123093557   9074065842717972665 
[10] 5117960993792195660  -5310033235587573872 -6907289311707392118
>   runif64(12, -16, 16)
integer64
 [1] -11 -16 4   -3  0   -3  -13 -8  14  5   -13 3  
>   runif64(12, 0, as.integer64(2^60)-1)  # not 2^60-1 !
integer64
 [1] 96505186687183302   898531255141091217  1056948207401509324
 [4] 681905296395208100  343741485486124735  587163319727106601 
 [7] 804340261977210000  366991965138801881  147883504982520426 
[10] 300878769130959103  5927493316981934    496961746629393387 
>   var(runif(1e4))
[1] 0.08487272
>   var(as.double(runif64(1e4, 0, 2^40))/2^40)  # ~ = 1/12 = .08333
[1] 0.08224966
> 
>   table(sample(16, replace=FALSE))

 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 
 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 
>   table(runif64(16, 1, 16, replace=FALSE))

 1  2  3  4  5  7  8 10 13 14 16 
 1  1  1  1  1  1  1  1  4  1  3 
>   table(sample(16, replace=TRUE))

 1  3  4  5  6  7  8 10 11 13 14 
 1  1  1  1  1  3  2  3  1  1  1 
>   table(runif64(16, 1, 16, replace=TRUE))

 2  3  4  7  8  9 11 15 16 
 1  1  2  3  3  3  1  1  1 
> 
> 
> 
> cleanEx()
> nameEx("seq.integer64")
> ### * seq.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: seq.integer64
> ### Title: integer64: Sequence Generation
> ### Aliases: seq.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   # colon not activated: as.integer64(1):12
>   seq(as.integer64(1), 12, 2)
integer64
[1] 1  3  5  7  9  11
>   seq(as.integer64(1), by=2, length.out=6)
integer64
[1] 1  3  5  7  9  11
> 
> 
> 
> cleanEx()
> nameEx("sort.integer64")
> ### * sort.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sort.integer64
> ### Title: High-level intger64 methods for sorting and ordering
> ### Aliases: sort.integer64 order.integer64
> ### Keywords: programming manip
> 
> ### ** Examples
> 
>   x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
>   x
integer64
 [1] <NA> <NA> <NA> <NA> 2    5    9    <NA> 1    5    1    <NA> <NA> 6    <NA>
[16] <NA> 5    <NA> <NA> <NA> 1    3    6    <NA> <NA> <NA> 1    1    <NA> 6   
[31] 3    <NA>
>   sort(x)
integer64
 [1] 1    1    1    1    1    2    3    3    5    5    5    6    6    6    9   
[16] <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA>
[31] <NA> <NA>
>   message("the following has default optimize='time' which is faster but requires more RAM
+ , this calls 'ramorder'")
the following has default optimize='time' which is faster but requires more RAM
, this calls 'ramorder'
>   order.integer64(x)
 [1]  9 11 21 27 28  5 22 31  6 10 17 14 23 30  7  1  2  3  4  8 12 13 15 16 18
[26] 19 20 24 25 26 29 32
>   message("slower with less RAM, this calls 'ramsortorder'")
slower with less RAM, this calls 'ramsortorder'
>   order.integer64(x, optimize="memory")
 [1]  9 11 21 27 28  5 22 31  6 10 17 14 23 30  7  1  2  3  4  8 12 13 15 16 18
[26] 19 20 24 25 26 29 32
> 
> 
> 
> cleanEx()
> nameEx("sortnut")
> ### * sortnut
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sortnut
> ### Title: Searching and other uses of sorting for 64bit integers
> ### Aliases: sortnut sortnut.integer64 ordernut ordernut.integer64 sortfin
> ###   sortfin.integer64 orderpos orderpos.integer64 orderfin
> ###   orderfin.integer64 sortorderpos sortorderpos.integer64 orderdup
> ###   orderdup.integer64 sortorderdup sortorderdup.integer64 sortuni
> ###   sortuni.integer64 orderuni orderuni.integer64 sortorderuni
> ###   sortorderuni.integer64 orderupo orderupo.integer64 sortorderupo
> ###   sortorderupo.integer64 ordertie ordertie.integer64 sortordertie
> ###   sortordertie.integer64 sorttab sorttab.integer64 ordertab
> ###   ordertab.integer64 sortordertab sortordertab.integer64 orderkey
> ###   orderkey.integer64 sortorderkey sortorderkey.integer64 orderrnk
> ###   orderrnk.integer64 sortorderrnk sortorderrnk.integer64 sortqtl
> ###   sortqtl.integer64 orderqtl orderqtl.integer64
> ### Keywords: programming manip
> 
> ### ** Examples
> 
>  message("check the code of 'optimizer64' for examples:")
check the code of 'optimizer64' for examples:
>  print(optimizer64)
function (nsmall = 2^16, nbig = 2^25, timefun = repeat.time, 
    what = c("match", "%in%", "duplicated", "unique", "unipos", 
        "table", "rank", "quantile"), uniorder = c("original", 
        "values", "any"), taborder = c("values", "counts"), plot = TRUE) 
{
    uniorder <- match.arg(uniorder)
    taborder <- match.arg(taborder)
    ret <- vector("list", 2 * length(what))
    dim(ret) <- c(length(what), 2L)
    dimnames(ret) <- list(what, c(nsmall, nbig))
    if (plot) {
        oldpar <- par(no.readonly = TRUE)
        on.exit(par(oldpar))
        par(mfrow = c(2, 1))
    }
    if ("match" %in% what) {
        message("match: timings of different methods")
        N1 <- c(nsmall, nbig)
        N2 <- c(nbig, nsmall)
        for (i in seq_along(N1)) {
            n1 <- N1[i]
            n2 <- N2[i]
            x1 <- c(sample(n2, n1 - 1, TRUE), NA)
            x2 <- c(sample(n2, n2 - 1, TRUE), NA)
            tim <- matrix(0, 9, 3)
            dimnames(tim) <- list(c("match", "match.64", "hashpos", 
                "hashrev", "sortorderpos", "orderpos", "hashcache", 
                "sortorder.cache", "order.cache"), c("prep", 
                "both", "use"))
            tim["match", "both"] <- timefun({
                p <- match(x1, x2)
            })[3]
            x1 <- as.integer64(x1)
            x2 <- as.integer64(x2)
            tim["match.64", "both"] <- timefun({
                p2 <- match.integer64(x1, x2)
            })[3]
            stopifnot(identical(p2, p))
            tim["hashpos", "prep"] <- timefun({
                h2 <- hashmap(x2)
            })[3]
            tim["hashpos", "use"] <- timefun({
                p2 <- hashpos(h2, x1)
            })[3]
            stopifnot(identical(p2, p))
            tim["hashrev", "prep"] <- timefun({
                h1 <- hashmap(x1)
            })[3]
            tim["hashrev", "use"] <- timefun({
                p1 <- hashrev(h1, x2)
            })[3]
            stopifnot(identical(p2, p))
            tim["sortorderpos", "prep"] <- system.time({
                s2 <- clone(x2)
                o2 <- seq_along(x2)
                ramsortorder(s2, o2, na.last = FALSE)
            })[3]
            tim["sortorderpos", "use"] <- timefun({
                p2 <- sortorderpos(s2, o2, x1)
            })[3]
            stopifnot(identical(p2, p))
            tim["orderpos", "prep"] <- timefun({
                o2 <- seq_along(x2)
                ramorder(x2, o2, na.last = FALSE)
            })[3]
            tim["orderpos", "use"] <- timefun({
                p2 <- orderpos(x2, o2, x1, method = 2)
            })[3]
            stopifnot(identical(p2, p))
            hashcache(x2)
            tim["hashcache", "use"] <- timefun({
                p2 <- match.integer64(x1, x2)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x2)
            sortordercache(x2)
            tim["sortorder.cache", "use"] <- timefun({
                p2 <- match.integer64(x1, x2)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x2)
            ordercache(x2)
            tim["order.cache", "use"] <- timefun({
                p2 <- match.integer64(x1, x2)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x2)
            if (plot) {
                barplot(t(tim))
                n <- format(c(n1, n2))
                title(paste("match", n[1], "in", n[2]))
            }
            ret[["match", as.character(n1)]] <- tim
        }
    }
    if ("%in%" %in% what) {
        message("%in%: timings of different methods")
        N1 <- c(nsmall, nbig)
        N2 <- c(nbig, nsmall)
        for (i in seq_along(N1)) {
            n1 <- N1[i]
            n2 <- N2[i]
            x1 <- c(sample(n2, n1 - 1, TRUE), NA)
            x2 <- c(sample(n2, n2 - 1, TRUE), NA)
            tim <- matrix(0, 10, 3)
            dimnames(tim) <- list(c("%in%", "match.64", "%in%.64", 
                "hashfin", "hashrin", "sortfin", "orderfin", 
                "hash.cache", "sortorder.cache", "order.cache"), 
                c("prep", "both", "use"))
            tim["%in%", "both"] <- timefun({
                p <- x1 %in% x2
            })[3]
            x1 <- as.integer64(x1)
            x2 <- as.integer64(x2)
            tim["match.64", "both"] <- timefun({
                p2 <- match.integer64(x1, x2, nomatch = 0L) > 
                  0L
            })[3]
            stopifnot(identical(p2, p))
            tim["%in%.64", "both"] <- timefun({
                p2 <- `%in%.integer64`(x1, x2)
            })[3]
            stopifnot(identical(p2, p))
            tim["hashfin", "prep"] <- timefun({
                h2 <- hashmap(x2)
            })[3]
            tim["hashfin", "use"] <- timefun({
                p2 <- hashfin(h2, x1)
            })[3]
            stopifnot(identical(p2, p))
            tim["hashrin", "prep"] <- timefun({
                h1 <- hashmap(x1)
            })[3]
            tim["hashrin", "use"] <- timefun({
                p1 <- hashrin(h1, x2)
            })[3]
            stopifnot(identical(p2, p))
            tim["sortfin", "prep"] <- timefun({
                s2 <- clone(x2)
                ramsort(s2, na.last = FALSE)
            })[3]
            tim["sortfin", "use"] <- timefun({
                p2 <- sortfin(s2, x1)
            })[3]
            stopifnot(identical(p2, p))
            tim["orderfin", "prep"] <- timefun({
                o2 <- seq_along(x2)
                ramorder(x2, o2, na.last = FALSE)
            })[3]
            tim["orderfin", "use"] <- timefun({
                p2 <- orderfin(x2, o2, x1)
            })[3]
            stopifnot(identical(p2, p))
            hashcache(x2)
            tim["hash.cache", "use"] <- timefun({
                p2 <- `%in%.integer64`(x1, x2)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x2)
            sortordercache(x2)
            tim["sortorder.cache", "use"] <- timefun({
                p2 <- `%in%.integer64`(x1, x2)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x2)
            ordercache(x2)
            tim["order.cache", "use"] <- timefun({
                p2 <- `%in%.integer64`(x1, x2)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x2)
            if (plot) {
                barplot(t(tim))
                n <- format(c(n1, n2))
                title(paste(n[1], "%in%", n[2]))
            }
            ret[["%in%", as.character(n1)]] <- tim
        }
    }
    if ("duplicated" %in% what) {
        message("duplicated: timings of different methods")
        N <- c(nsmall, nbig)
        for (i in seq_along(N)) {
            n <- N[i]
            x <- c(sample(n, n - 1, TRUE), NA)
            tim <- matrix(0, 10, 3)
            dimnames(tim) <- list(c("duplicated", "duplicated.64", 
                "hashdup", "sortorderdup1", "sortorderdup2", 
                "orderdup1", "orderdup2", "hash.cache", "sortorder.cache", 
                "order.cache"), c("prep", "both", "use"))
            tim["duplicated", "both"] <- timefun({
                p <- duplicated(x)
            })[3]
            x <- as.integer64(x)
            tim["duplicated.64", "both"] <- timefun({
                p2 <- duplicated(x)
            })[3]
            stopifnot(identical(p2, p))
            tim["hashdup", "prep"] <- timefun({
                h <- hashmap(x)
            })[3]
            tim["hashdup", "use"] <- timefun({
                p2 <- hashdup(h)
            })[3]
            stopifnot(identical(p2, p))
            tim["sortorderdup1", "prep"] <- timefun({
                s <- clone(x)
                o <- seq_along(x)
                ramsortorder(s, o, na.last = FALSE)
                nunique <- sortnut(s)[1]
            })[3]
            tim["sortorderdup1", "use"] <- timefun({
                p2 <- sortorderdup(s, o, method = 1)
            })[3]
            stopifnot(identical(p2, p))
            tim["sortorderdup2", "prep"] <- tim["sortorderdup1", 
                "prep"]
            tim["sortorderdup2", "use"] <- timefun({
                p2 <- sortorderdup(s, o, method = 2)
            })[3]
            stopifnot(identical(p2, p))
            tim["orderdup1", "prep"] <- timefun({
                o <- seq_along(x)
                ramorder(x, o, na.last = FALSE)
                nunique <- ordernut(x, o)[1]
            })[3]
            tim["orderdup1", "use"] <- timefun({
                p2 <- orderdup(x, o, method = 1)
            })[3]
            stopifnot(identical(p2, p))
            tim["orderdup2", "prep"] <- tim["orderdup1", "prep"]
            tim["orderdup2", "use"] <- timefun({
                p2 <- orderdup(x, o, method = 2)
            })[3]
            stopifnot(identical(p2, p))
            hashcache(x)
            tim["hash.cache", "use"] <- timefun({
                p2 <- duplicated(x)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x)
            sortordercache(x)
            tim["sortorder.cache", "use"] <- timefun({
                p2 <- duplicated(x)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x)
            ordercache(x)
            tim["order.cache", "use"] <- timefun({
                p2 <- duplicated(x)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x)
            if (plot) {
                barplot(t(tim), cex.names = 0.7)
                title(paste("duplicated(", n, ")", sep = ""))
            }
            ret[["duplicated", as.character(n)]] <- tim
        }
    }
    if ("unique" %in% what) {
        message("unique: timings of different methods")
        N <- c(nsmall, nbig)
        for (i in seq_along(N)) {
            n <- N[i]
            x <- c(sample(n, n - 1, TRUE), NA)
            tim <- matrix(0, 15, 3)
            dimnames(tim) <- list(c("unique", "unique.64", "hashmapuni", 
                "hashuni", "hashunikeep", "sortuni", "sortunikeep", 
                "orderuni", "orderunikeep", "hashdup", "sortorderdup", 
                "hash.cache", "sort.cache", "sortorder.cache", 
                "order.cache"), c("prep", "both", "use"))
            tim["unique", "both"] <- timefun({
                p <- unique(x)
            })[3]
            x <- as.integer64(x)
            p <- as.integer64(p)
            if (uniorder == "values") 
                ramsort(p, na.last = FALSE)
            tim["unique.64", "both"] <- timefun({
                p2 <- unique(x, order = uniorder)
            })[3]
            if (uniorder != "any") 
                stopifnot(identical.integer64(p2, p))
            tim["hashmapuni", "both"] <- timefun({
                p2 <- hashmapuni(x)
            })[3]
            if (uniorder == "original") 
                stopifnot(identical.integer64(p2, p))
            tim["hashuni", "prep"] <- timefun({
                h <- hashmap(x)
            })[3]
            tim["hashuni", "use"] <- timefun({
                p2 <- hashuni(h)
            })[3]
            if (uniorder == "values") 
                stopifnot(identical.integer64(sort(p2, na.last = FALSE), 
                  p))
            tim["hashunikeep", "prep"] <- tim["hashuni", "prep"]
            tim["hashunikeep", "use"] <- timefun({
                p2 <- hashuni(h, keep.order = TRUE)
            })[3]
            if (uniorder == "original") 
                stopifnot(identical.integer64(p2, p))
            tim["sortuni", "prep"] <- timefun({
                s <- clone(x)
                ramsort(s, na.last = FALSE)
                nunique <- sortnut(s)[1]
            })[3]
            tim["sortuni", "use"] <- timefun({
                p2 <- sortuni(s, nunique)
            })[3]
            if (uniorder == "values") 
                stopifnot(identical.integer64(sort(p2, na.last = FALSE), 
                  p))
            tim["sortunikeep", "prep"] <- timefun({
                s <- clone(x)
                o <- seq_along(x)
                ramsortorder(s, o, na.last = FALSE)
                nunique <- sortnut(s)[1]
            })[3]
            tim["sortunikeep", "use"] <- timefun({
                p2 <- sortorderuni(x, s, o, nunique)
            })[3]
            if (uniorder == "original") 
                stopifnot(identical.integer64(p2, p))
            tim["orderuni", "prep"] <- timefun({
                o <- seq_along(x)
                ramorder(x, o, na.last = FALSE)
                nunique <- ordernut(x, o)[1]
            })[3]
            tim["orderuni", "use"] <- timefun({
                p2 <- orderuni(x, o, nunique)
            })[3]
            if (uniorder == "values") 
                stopifnot(identical.integer64(sort(p2, na.last = FALSE), 
                  p))
            tim["orderunikeep", "prep"] <- tim["orderuni", "prep"]
            tim["orderunikeep", "use"] <- timefun({
                p2 <- orderuni(x, o, nunique, keep.order = TRUE)
                nunique <- ordernut(x, o)[1]
            })[3]
            if (uniorder == "original") 
                stopifnot(identical.integer64(p2, p))
            tim["hashdup", "prep"] <- tim["hashuni", "prep"]
            tim["hashdup", "use"] <- timefun({
                p2 <- x[!hashdup(h)]
            })[3]
            if (uniorder == "original") 
                stopifnot(identical.integer64(p2, p))
            tim["sortorderdup", "prep"] <- tim["sortunikeep", 
                "prep"]
            tim["sortorderdup", "use"] <- timefun({
                p2 <- x[!sortorderdup(s, o)]
            })[3]
            if (uniorder == "original") 
                stopifnot(identical.integer64(p2, p))
            hashcache(x)
            tim["hash.cache", "use"] <- timefun({
                p2 <- unique(x, order = uniorder)
            })[3]
            if (uniorder != "any") 
                stopifnot(identical.integer64(p2, p))
            remcache(x)
            sortcache(x)
            tim["sort.cache", "use"] <- timefun({
                p2 <- unique(x, order = uniorder)
            })[3]
            if (uniorder != "any") 
                stopifnot(identical.integer64(p2, p))
            remcache(x)
            sortordercache(x)
            tim["sortorder.cache", "use"] <- timefun({
                p2 <- unique(x, order = uniorder)
            })[3]
            if (uniorder != "any") 
                stopifnot(identical.integer64(p2, p))
            remcache(x)
            ordercache(x)
            tim["order.cache", "use"] <- timefun({
                p2 <- unique(x, order = uniorder)
            })[3]
            if (uniorder != "any") 
                stopifnot(identical.integer64(p2, p))
            remcache(x)
            if (plot) {
                barplot(t(tim), cex.names = 0.7)
                title(paste("unique(", n, ", order=", uniorder, 
                  ")", sep = ""))
            }
            ret[["unique", as.character(n)]] <- tim
        }
    }
    if ("unipos" %in% what) {
        message("unipos: timings of different methods")
        N <- c(nsmall, nbig)
        for (i in seq_along(N)) {
            n <- N[i]
            x <- c(sample(n, n - 1, TRUE), NA)
            tim <- matrix(0, 14, 3)
            dimnames(tim) <- list(c("unique", "unipos.64", "hashmapupo", 
                "hashupo", "hashupokeep", "sortorderupo", "sortorderupokeep", 
                "orderupo", "orderupokeep", "hashdup", "sortorderdup", 
                "hash.cache", "sortorder.cache", "order.cache"), 
                c("prep", "both", "use"))
            tim["unique", "both"] <- timefun({
                unique(x)
            })[3]
            x <- as.integer64(x)
            tim["unipos.64", "both"] <- timefun({
                p <- unipos(x, order = uniorder)
            })[3]
            tim["hashmapupo", "both"] <- timefun({
                p2 <- hashmapupo(x)
            })[3]
            if (uniorder == "original") 
                stopifnot(identical(p2, p))
            tim["hashupo", "prep"] <- timefun({
                h <- hashmap(x)
            })[3]
            tim["hashupo", "use"] <- timefun({
                p2 <- hashupo(h)
            })[3]
            if (uniorder == "values") 
                stopifnot(identical(sort(p2, na.last = FALSE), 
                  sort(p, na.last = FALSE)))
            tim["hashupokeep", "prep"] <- tim["hashupo", "prep"]
            tim["hashupokeep", "use"] <- timefun({
                p2 <- hashupo(h, keep.order = TRUE)
            })[3]
            if (uniorder == "original") 
                stopifnot(identical(p2, p))
            tim["sortorderupo", "prep"] <- timefun({
                s <- clone(x)
                o <- seq_along(x)
                ramsortorder(s, o, na.last = FALSE)
                nunique <- sortnut(s)[1]
            })[3]
            tim["sortorderupo", "use"] <- timefun({
                p2 <- sortorderupo(s, o, nunique)
            })[3]
            if (uniorder == "values") 
                stopifnot(identical(p2, p))
            tim["sortorderupokeep", "prep"] <- timefun({
                s <- clone(x)
                o <- seq_along(x)
                ramsortorder(s, o, na.last = FALSE)
                nunique <- sortnut(s)[1]
            })[3]
            tim["sortorderupokeep", "use"] <- timefun({
                p2 <- sortorderupo(s, o, nunique, keep.order = TRUE)
            })[3]
            if (uniorder == "original") 
                stopifnot(identical(p2, p))
            tim["orderupo", "prep"] <- timefun({
                o <- seq_along(x)
                ramorder(x, o, na.last = FALSE)
                nunique <- ordernut(x, o)[1]
            })[3]
            tim["orderupo", "use"] <- timefun({
                p2 <- orderupo(x, o, nunique)
            })[3]
            if (uniorder == "values") 
                stopifnot(identical(p2, p))
            tim["orderupokeep", "prep"] <- tim["orderupo", "prep"]
            tim["orderupokeep", "use"] <- timefun({
                p2 <- orderupo(x, o, nunique, keep.order = TRUE)
                nunique <- ordernut(x, o)[1]
            })[3]
            if (uniorder == "original") 
                stopifnot(identical(p2, p))
            tim["hashdup", "prep"] <- tim["hashupo", "prep"]
            tim["hashdup", "use"] <- timefun({
                p2 <- (1:n)[!hashdup(h)]
            })[3]
            if (uniorder == "original") 
                stopifnot(identical(p2, p))
            tim["sortorderdup", "prep"] <- tim["sortorderupokeep", 
                "prep"]
            tim["sortorderdup", "use"] <- timefun({
                p2 <- (1:n)[!sortorderdup(s, o)]
            })[3]
            if (uniorder == "original") 
                stopifnot(identical(p2, p))
            hashcache(x)
            tim["hash.cache", "use"] <- timefun({
                p2 <- unipos(x, order = uniorder)
            })[3]
            if (uniorder != "any") 
                stopifnot(identical(p2, p))
            remcache(x)
            sortordercache(x)
            tim["sortorder.cache", "use"] <- timefun({
                p2 <- unipos(x, order = uniorder)
            })[3]
            if (uniorder != "any") 
                stopifnot(identical(p2, p))
            remcache(x)
            ordercache(x)
            tim["order.cache", "use"] <- timefun({
                p2 <- unipos(x, order = uniorder)
            })[3]
            if (uniorder != "any") 
                stopifnot(identical(p2, p))
            remcache(x)
            if (plot) {
                barplot(t(tim), cex.names = 0.7)
                title(paste("unipos(", n, ", order=", uniorder, 
                  ")", sep = ""))
            }
            ret[["unipos", as.character(n)]] <- tim
        }
    }
    if ("table" %in% what) {
        message("table: timings of different methods")
        N <- c(nsmall, nbig)
        for (i in seq_along(N)) {
            n <- N[i]
            x <- c(sample(1024, n - 1, TRUE), NA)
            tim <- matrix(0, 13, 3)
            dimnames(tim) <- list(c("tabulate", "table", "table.64", 
                "hashmaptab", "hashtab", "hashtab2", "sorttab", 
                "sortordertab", "ordertab", "ordertabkeep", "hash.cache", 
                "sort.cache", "order.cache"), c("prep", "both", 
                "use"))
            tim["tabulate", "both"] <- timefun({
                tabulate(x)
            })[3]
            tim["table", "both"] <- timefun({
                p <- table(x, exclude = NULL)
            })[3]
            p <- p[-length(p)]
            x <- as.integer64(x)
            tim["table.64", "both"] <- timefun({
                p2 <- table.integer64(x, order = taborder)
            })[3]
            p2 <- p2[-1]
            stopifnot(identical(p2, p))
            tim["hashmaptab", "both"] <- timefun({
                p <- hashmaptab(x)
            })[3]
            tim["hashtab", "prep"] <- timefun({
                h <- hashmap(x)
            })[3]
            tim["hashtab", "use"] <- timefun({
                p2 <- hashtab(h)
            })[3]
            stopifnot(identical(p2, p))
            tim["hashtab2", "prep"] <- tim["hashtab", "prep"] + 
                timefun({
                  h <- hashmap(x, nunique = h$nunique)
                })[3]
            tim["hashtab2", "use"] <- timefun({
                p2 <- hashtab(h)
            })[3]
            sortp <- function(p) {
                s <- p$values
                o <- seq_along(s)
                ramsortorder(s, o, na.last = FALSE)
                list(values = s, counts = p$counts[o])
            }
            p <- sortp(p)
            p2 <- sortp(p2)
            stopifnot(identical(p2, p))
            tim["sorttab", "prep"] <- timefun({
                s <- clone(x)
                ramsort(s, na.last = FALSE)
                nunique <- sortnut(s)[1]
            })[3]
            tim["sorttab", "use"] <- timefun({
                p2 <- list(values = sortuni(s, nunique), counts = sorttab(s, 
                  nunique))
            })[3]
            stopifnot(identical(p2, p))
            tim["sortordertab", "prep"] <- timefun({
                s <- clone(x)
                o <- seq_along(x)
                ramsortorder(s, o, na.last = FALSE)
                nunique <- sortnut(s)[1]
            })[3]
            tim["sortordertab", "use"] <- timefun({
                p2 <- list(values = sortorderuni(x, s, o, nunique), 
                  counts = sortordertab(s, o))
            })[3]
            p2 <- sortp(p2)
            stopifnot(identical(p2, p))
            tim["ordertab", "prep"] <- timefun({
                o <- seq_along(x)
                ramorder(x, o, na.last = FALSE)
                nunique <- ordernut(x, o)[1]
            })[3]
            tim["ordertab", "use"] <- timefun({
                p2 <- list(values = orderuni(x, o, nunique), 
                  counts = ordertab(x, o, nunique))
            })[3]
            stopifnot(identical(p2, p))
            tim["ordertabkeep", "prep"] <- tim["ordertab", "prep"]
            tim["ordertabkeep", "use"] <- timefun({
                p2 <- list(values = orderuni(x, o, nunique, keep.order = TRUE), 
                  counts = ordertab(x, o, nunique, keep.order = TRUE))
            })[3]
            p2 <- sortp(p2)
            stopifnot(identical(p2, p))
            hashcache(x)
            tim["hash.cache", "use"] <- timefun({
                p <- table.integer64(x, order = taborder)
            })[3]
            remcache(x)
            sortordercache(x)
            tim["sort.cache", "use"] <- timefun({
                p2 <- table.integer64(x, order = taborder)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x)
            ordercache(x)
            tim["order.cache", "use"] <- timefun({
                p2 <- table.integer64(x, order = taborder)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x)
            if (plot) {
                barplot(t(tim), cex.names = 0.7)
                title(paste("table.integer64(", n, ", order=", 
                  taborder, ")", sep = ""))
            }
            ret[["table", as.character(n)]] <- tim
        }
    }
    if ("rank" %in% what) {
        message("rank: timings of different methods")
        N <- c(nsmall, nbig)
        for (i in seq_along(N)) {
            n <- N[i]
            x <- c(sample(n, n - 1, TRUE), NA)
            tim <- matrix(0, 7, 3)
            dimnames(tim) <- list(c("rank", "rank.keep", "rank.64", 
                "sortorderrnk", "orderrnk", "sort.cache", "order.cache"), 
                c("prep", "both", "use"))
            tim["rank", "both"] <- timefun({
                rank(x)
            })[3]
            tim["rank.keep", "both"] <- timefun({
                p <- rank(x, na.last = "keep")
            })[3]
            x <- as.integer64(x)
            tim["rank.64", "both"] <- timefun({
                p2 <- rank.integer64(x)
            })[3]
            stopifnot(identical(p2, p))
            tim["sortorderrnk", "prep"] <- timefun({
                s <- clone(x)
                o <- seq_along(x)
                na.count <- ramsortorder(s, o, na.last = FALSE)
            })[3]
            tim["sortorderrnk", "use"] <- timefun({
                p2 <- sortorderrnk(s, o, na.count)
            })[3]
            stopifnot(identical(p2, p))
            tim["orderrnk", "prep"] <- timefun({
                o <- seq_along(x)
                na.count <- ramorder(x, o, na.last = FALSE)
            })[3]
            tim["orderrnk", "use"] <- timefun({
                p2 <- orderrnk(x, o, na.count)
            })[3]
            stopifnot(identical(p2, p))
            sortordercache(x)
            tim["sort.cache", "use"] <- timefun({
                p2 <- rank.integer64(x)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x)
            ordercache(x)
            tim["order.cache", "use"] <- timefun({
                p2 <- rank.integer64(x)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x)
            if (plot) {
                barplot(t(tim), cex.names = 0.7)
                title(paste("rank.integer64(", n, ")", sep = ""))
            }
            ret[["rank", as.character(n)]] <- tim
        }
    }
    if ("quantile" %in% what) {
        message("quantile: timings of different methods")
        N <- c(nsmall, nbig)
        for (i in seq_along(N)) {
            n <- N[i]
            x <- c(sample(n, n - 1, TRUE), NA)
            tim <- matrix(0, 6, 3)
            dimnames(tim) <- list(c("quantile", "quantile.64", 
                "sortqtl", "orderqtl", "sort.cache", "order.cache"), 
                c("prep", "both", "use"))
            tim["quantile", "both"] <- timefun({
                p <- quantile(x, type = 1, na.rm = TRUE)
            })[3]
            p2 <- p
            p <- as.integer64(p2)
            names(p) <- names(p2)
            x <- as.integer64(x)
            tim["quantile.64", "both"] <- timefun({
                p2 <- quantile(x, na.rm = TRUE)
            })[3]
            stopifnot(identical(p2, p))
            tim["sortqtl", "prep"] <- timefun({
                s <- clone(x)
                na.count <- ramsort(s, na.last = FALSE)
            })[3]
            tim["sortqtl", "use"] <- timefun({
                p2 <- sortqtl(s, na.count, seq(0, 1, 0.25))
            })[3]
            stopifnot(identical(unname(p2), unname(p)))
            tim["orderqtl", "prep"] <- timefun({
                o <- seq_along(x)
                na.count <- ramorder(x, o, na.last = FALSE)
            })[3]
            tim["orderqtl", "use"] <- timefun({
                p2 <- orderqtl(x, o, na.count, seq(0, 1, 0.25))
            })[3]
            stopifnot(identical(unname(p2), unname(p)))
            sortordercache(x)
            tim["sort.cache", "use"] <- timefun({
                p2 <- quantile(x, na.rm = TRUE)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x)
            ordercache(x)
            tim["order.cache", "use"] <- timefun({
                p2 <- quantile(x, na.rm = TRUE)
            })[3]
            stopifnot(identical(p2, p))
            remcache(x)
            if (plot) {
                barplot(t(tim), cex.names = 0.7)
                title(paste("quantile(", n, ")", sep = ""))
            }
            ret[["quantile", as.character(n)]] <- tim
        }
    }
    ret
}
<bytecode: 0x55f4fd3e7f70>
<environment: namespace:bit64>
> 
> 
> 
> cleanEx()
> nameEx("sum.integer64")
> ### * sum.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sum.integer64
> ### Title: Summary functions for integer64 vectors
> ### Aliases: all.integer64 any.integer64 min.integer64 max.integer64
> ###   range.integer64 lim.integer64 sum.integer64 prod.integer64
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   lim.integer64()
integer64
[1] -9223372036854775807 9223372036854775807 
>   range(as.integer64(1:12))
integer64
[1] 1  12
> 
> 
> 
> cleanEx()
> nameEx("table.integer64")
> ### * table.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: table.integer64
> ### Title: Cross Tabulation and Table Creation for integer64
> ### Aliases: table.integer64
> ### Keywords: category
> 
> ### ** Examples
> 
> message("pure integer64 examples")
pure integer64 examples
> x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> y <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> z <- sample(c(rep(NA, 9), letters), 32, TRUE)
> table.integer64(x)
x
<NA>    1    2    3    5    6    9 
  17    5    1    2    3    3    1 
> table.integer64(x, order="counts")
x
   2    9    3    6    5    1 <NA> 
   1    1    2    3    3    5   17 
> table.integer64(x, y)
      y
x      <NA>  1  2  3  4  5  7  8  9
  <NA>   10  0  1  3  1  1  1  0  0
  1       1  0  0  0  2  1  0  1  0
  2       0  1  0  0  0  0  0  0  0
  3       2  0  0  0  0  0  0  0  0
  5       2  0  0  0  0  0  0  0  1
  6       1  0  0  0  1  0  1  0  0
  9       0  0  0  0  0  1  0  0  0
> table.integer64(x, y, return="data.frame")
      x    y Freq
1  <NA> <NA>   10
2     1 <NA>    1
3     3 <NA>    2
4     5 <NA>    2
5     6 <NA>    1
6     2    1    1
7  <NA>    2    1
8  <NA>    3    3
9  <NA>    4    1
10    1    4    2
11    6    4    1
12 <NA>    5    1
13    1    5    1
14    9    5    1
15 <NA>    7    1
16    6    7    1
17    1    8    1
18    5    9    1
> 
> message("via as.integer64.factor we can use 'table.integer64' also for factors")
via as.integer64.factor we can use 'table.integer64' also for factors
> table.integer64(x, as.integer64(as.factor(z)))
      
x      <NA> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
  <NA>    4 1 1 0 1 1 0 1 1 0  1  1  1  1  1  1  0  0  0  1
  1       0 0 0 1 0 0 0 0 1 0  0  0  0  1  0  0  1  0  1  0
  2       0 0 0 0 0 0 0 0 0 1  0  0  0  0  0  0  0  0  0  0
  3       0 0 0 0 0 0 0 0 0 0  0  0  1  0  0  0  0  1  0  0
  5       0 0 0 0 0 0 1 0 0 0  1  0  0  1  0  0  0  0  0  0
  6       1 0 0 0 0 0 1 0 0 0  0  1  0  0  0  0  0  0  0  0
  9       0 0 0 0 0 0 0 0 0 0  0  1  0  0  0  0  0  0  0  0
> 
> message("via as.factor.integer64 we can also use 'table' for integer64")
via as.factor.integer64 we can also use 'table' for integer64
> table(x)
x
1 2 3 5 6 9 
5 1 2 3 3 1 
> table(x, exclude=NULL)
x
<NA>    1    2    3    5    6    9 
  17    5    1    2    3    3    1 
> table(x, z, exclude=NULL)
      z
x      a c e f h j l m n o q s t u v w x y z <NA>
  <NA> 1 1 0 1 1 0 1 1 0 1 1 1 1 1 1 0 0 0 1    4
  1    0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 1 0 1 0    0
  2    0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0    0
  3    0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0    0
  5    0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0    0
  6    0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0    1
  9    0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0    0
> 
> ## Don't show: 
>  stopifnot(identical(table.integer64(as.integer64(c(1,1,2))), table(c(1,1,2))))
>  stopifnot(identical(table.integer64(as.integer64(c(1,1,2)),as.integer64(c(3,4,4))), table(c(1,1,2),c(3,4,4))))
>  message("the following works with three warnings due to coercion")
the following works with three warnings due to coercion
>  stopifnot(identical(table.integer64(c(1,1,2)), table(c(1,1,2))))
Warning in table.integer64(c(1, 1, 2)) :
  coercing first argument to integer64
>  stopifnot(identical(table.integer64(as.integer64(c(1,1,2)),c(3,4,4)), table(c(1,1,2),c(3,4,4))))
Warning in table.integer64(as.integer64(c(1, 1, 2)), c(3, 4, 4)) :
  coercing argument 2 to integer64
>  stopifnot(identical(table.integer64(c(1,1,2),as.integer64(c(3,4,4))), table(c(1,1,2),c(3,4,4))))
Warning in table.integer64(c(1, 1, 2), as.integer64(c(3, 4, 4))) :
  coercing argument 1 to integer64
>  message("the following works because of as.factor.integer64")
the following works because of as.factor.integer64
>  stopifnot(identical(table(as.integer64(c(1,1,2))), table(c(1,1,2))))  
>  stopifnot(identical(table(as.integer64(c(1,1,2)),as.integer64(c(3,4,4))), table(c(1,1,2),c(3,4,4))))
>  stopifnot(identical(table(as.integer64(c(1,1,2)),c(3,4,4)), table(c(1,1,2),c(3,4,4))))
>  stopifnot(identical(table(c(1,1,2),as.integer64(c(3,4,4))), table(c(1,1,2),c(3,4,4))))
> ## End(Don't show)
> 
> 
> 
> 
> cleanEx()
> nameEx("tiepos")
> ### * tiepos
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tiepos
> ### Title: Extract Positions of Tied Elements
> ### Aliases: tiepos tiepos.integer64
> ### Keywords: manip univar
> 
> ### ** Examples
> 
> x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> tiepos(x)
 [1]  1  2  3  4  6  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
[26] 28 29 30 31 32
> 
> stopifnot(identical(tiepos(x),  (1:length(x))[duplicated(x) | rev(duplicated(rev(x)))]))
> 
> 
> 
> cleanEx()
> nameEx("unipos")
> ### * unipos
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unipos
> ### Title: Extract Positions of Unique Elements
> ### Aliases: unipos unipos.integer64
> ### Keywords: manip logic
> 
> ### ** Examples
> 
> x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> unipos(x)
[1]  1  5  6  7  9 14 22
> unipos(x, order="values")
[1]  1  9  5 22  6 14  7
> 
> stopifnot(identical(unipos(x),  (1:length(x))[!duplicated(x)]))
> stopifnot(identical(unipos(x),  match.integer64(unique(x), x)))
> stopifnot(identical(unipos(x, order="values"),  match.integer64(unique(x, order="values"), x)))
> stopifnot(identical(unique(x),  x[unipos(x)]))
> stopifnot(identical(unique(x, order="values"),  x[unipos(x, order="values")]))
> 
> 
> 
> cleanEx()
> nameEx("unique.integer64")
> ### * unique.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unique.integer64
> ### Title: Extract Unique Elements from integer64
> ### Aliases: unique.integer64
> ### Keywords: manip logic
> 
> ### ** Examples
> 
> x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
> unique(x)
integer64
[1] <NA> 2    5    9    1    6    3   
> unique(x, order="values")
integer64
[1] <NA> 1    2    3    5    6    9   
> 
> stopifnot(identical(unique(x),  x[!duplicated(x)]))
> stopifnot(identical(unique(x),  as.integer64(unique(as.integer(x)))))
> stopifnot(identical(unique(x, order="values")
+ ,  as.integer64(sort(unique(as.integer(x)), na.last=FALSE))))
> 
> 
> 
> cleanEx()
> nameEx("xor.integer64")
> ### * xor.integer64
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xor.integer64
> ### Title: Binary operators for integer64 vectors
> ### Aliases: &.integer64 |.integer64 xor.integer64 !=.integer64
> ###   ==.integer64 <.integer64 <=.integer64 >.integer64 >=.integer64
> ###   +.integer64 -.integer64 *.integer64 ^.integer64 /.integer64
> ###   %/%.integer64 %%.integer64 binattr
> ### Keywords: classes manip
> 
> ### ** Examples
> 
>   as.integer64(1:12) - 1
integer64
 [1] 0  1  2  3  4  5  6  7  8  9  10 11
>   options(integer64_semantics="new")
>   d <- 2.5
>   i <- as.integer64(5)
>   d/i  # new 0.5
[1] 0.5
>   d*i  # new 13
integer64
[1] 13
>   i*d  # new 13
integer64
[1] 13
>   options(integer64_semantics="old")
>   d/i  # old: 0.4
[1] 0.4
>   d*i  # old: 10
integer64
[1] 10
>   i*d  # old: 13
integer64
[1] 13
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.415 0.052 0.466 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
