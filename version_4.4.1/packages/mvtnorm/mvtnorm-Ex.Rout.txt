
R version 4.4.1 (2024-06-14) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "mvtnorm"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('mvtnorm')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Mvnorm")
> ### * Mvnorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Mvnorm
> ### Title: Multivariate Normal Density and Random Deviates
> ### Aliases: dmvnorm rmvnorm
> ### Keywords: distribution multivariate
> 
> ### ** Examples
> 
> dmvnorm(x=c(0,0))
[1] 0.1591549
> dmvnorm(x=c(0,0), mean=c(1,1))
[1] 0.05854983
> 
> sigma <- matrix(c(4,2,2,3), ncol=2)
> x <- rmvnorm(n=500, mean=c(1,2), sigma=sigma)
> colMeans(x)
[1] 0.9492868 1.9916602
> var(x)
         [,1]     [,2]
[1,] 4.276371 2.105874
[2,] 2.105874 3.186058
> dS <- dmvnorm(x, sigma = sigma)
> 
> ### alternative interface
> C <- t(chol(sigma))
> (C <- ltMatrices(C[lower.tri(C, diag = TRUE)], diag = TRUE))
, , 1

  1        2
1 2 0.000000
2 1 1.414214

> dC <- exp(ldmvnorm(obs = t(x), chol = C, logLik = FALSE))
> all.equal(dS, dC)
[1] TRUE
> 
> x <- rmvnorm(n=500, mean=c(1,2), sigma=sigma, method="chol")
> colMeans(x)
[1] 0.8724731 1.9804160
> var(x)
         [,1]     [,2]
[1,] 4.804847 2.430442
[2,] 2.430442 3.148344
> 
> plot(x)
> 
> 
> 
> cleanEx()
> nameEx("Mvt")
> ### * Mvt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Mvt
> ### Title: The Multivariate t Distribution
> ### Aliases: dmvt rmvt
> ### Keywords: distribution multivariate
> 
> ### ** Examples
> 
> ## basic evaluation
> dmvt(x = c(0,0), sigma = diag(2))
[1] -1.837877
> 
> ## check behavior for df=0 and df=Inf
> x <- c(1.23, 4.56)
> mu <- 1:2
> Sigma <- diag(2)
> x0 <- dmvt(x, delta = mu, sigma = Sigma, df = 0) # default log = TRUE!
> x8 <- dmvt(x, delta = mu, sigma = Sigma, df = Inf) # default log = TRUE!
> xn <- dmvnorm(x, mean = mu, sigma = Sigma, log = TRUE)
> stopifnot(identical(x0, x8), identical(x0, xn))
> 
> ## X ~ t_3(0, diag(2))
> x <- rmvt(100, sigma = diag(2), df = 3) # t_3(0, diag(2)) sample
> plot(x)
> 
> ## X ~ t_3(mu, Sigma)
> n <- 1000
> mu <- 1:2
> Sigma <- matrix(c(4, 2, 2, 3), ncol=2)
> set.seed(271)
> x <- rep(mu, each=n) + rmvt(n, sigma=Sigma, df=3)
> plot(x)
> 
> ## Note that the call rmvt(n, mean=mu, sigma=Sigma, df=3) does *not*
> ## give a valid sample from t_3(mu, Sigma)! [and thus throws an error]
> try(rmvt(n, mean=mu, sigma=Sigma, df=3))
Error in rmvt(n, mean = mu, sigma = Sigma, df = 3) : 
  Providing 'mean' does *not* sample from a multivariate t distribution!
> 
> ## df=Inf correctly samples from a multivariate normal distribution
> set.seed(271)
> x <- rep(mu, each=n) + rmvt(n, sigma=Sigma, df=Inf)
> set.seed(271)
> x. <- rmvnorm(n, mean=mu, sigma=Sigma)
> stopifnot(identical(x, x.))
> 
> 
> 
> cleanEx()
> nameEx("lpmvnorm")
> ### * lpmvnorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lpmvnorm
> ### Title: Multivariate Normal Log-likelihood and Score Functions
> ### Aliases: lpmvnorm slpmvnorm ldmvnorm sldmvnorm ldpmvnorm sldpmvnorm
> ### Keywords: distribution
> 
> ### ** Examples
> 
> 
>   ### five observations
>   N <- 5L
>   ### dimension
>   J <- 4L
> 
>   ### lower and upper bounds, ie interval-censoring
>   lwr <- matrix(-runif(N * J), nrow = J)
>   upr <- matrix(runif(N * J), nrow = J)
> 
>   ### Cholesky factor
>   (C <- ltMatrices(runif(J * (J + 1) / 2), diag = TRUE))
, , 1

          1         2         3         4
1 0.8209463 0.0000000 0.0000000 0.0000000
2 0.6470602 0.5297196 0.0000000 0.0000000
3 0.7829328 0.7893562 0.4772301 0.0000000
4 0.5530363 0.0233312 0.7323137 0.6927316

>   ### corresponding covariance matrix
>   (S <- as.array(Tcrossprod(C))[,,1])
          1         2         3         4
1 0.6739528 0.5312017 0.6427457 0.4540131
2 0.5312017 0.6992897 0.9247421 0.3702068
3 0.6427457 0.9247421 1.4638155 0.8008890
4 0.4540131 0.3702068 0.8008890 1.3225539
> 
>   ### plain Monte-Carlo (Genz, 1992)
>   w <- NULL
>   M <- 25000
>   ### quasi-Monte-Carlo (Genz & Bretz, 2002, but with different weights)
>   if (require("qrng")) w <- t(ghalton(M * N, J - 1))
Loading required package: qrng
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘qrng’
> 
>   ### log-likelihood
>   lpmvnorm(lower = lwr, upper = upr, chol = C, w = w, M = M)
[1] -15.5953
> 
>   ### compare with pmvnorm
>   exp(lpmvnorm(lower = lwr, upper = upr, chol = C, logLik = FALSE, w = w, M = M))
[1] 0.04271354 0.03233400 0.02741596 0.07624042 0.05777393
>   sapply(1:N, function(i) pmvnorm(lower = lwr[,i], upper = upr[,i], sigma = S))
[1] 0.04241213 0.03227667 0.02736207 0.07638590 0.05773975
> 
>   ### log-lik contributions and score matrix
>   slpmvnorm(lower = lwr, upper = upr, chol = C, w = w, M = M, logLik = TRUE)
$logLik
[1] -3.160663 -3.437095 -3.597088 -2.570486 -2.851228

$mean
        [,1]        [,2]        [,3]        [,4]       [,5]
1  1.2636290  0.54961686 -0.06975832 -0.07681186  0.6152772
2 -1.7864825 -0.07261756  0.62240700 -0.33390855 -2.4867855
3  0.8823566 -0.49913251 -0.38459934  0.17164447  1.5981786
4 -0.7112882  0.02507101  0.23330228  0.07530071 -0.5653040

$lower
        [,1]        [,2]       [,3]       [,4]         [,5]
1 -1.3793932 -2.31128432 -0.2275828 -0.4829680 -0.712921386
2 -0.5943762 -0.05142497 -2.4451243 -1.3324552 -0.002742758
3 -1.0021649 -0.68149699 -0.9549039 -0.2818038 -1.704876313
4 -0.5558271 -0.87206911 -1.3206695 -0.7919590 -0.478895112

$upper
       [,1]      [,2]      [,3]      [,4]       [,5]
1 0.1157642 1.7616675 0.2973412 0.5597798 0.09764414
2 2.3808587 0.1240425 1.8227173 1.6663638 2.48952821
3 0.1198082 1.1806295 1.3395033 0.1101593 0.10669773
4 1.2671153 0.8469981 1.0873672 0.7166582 1.04419915

$chol
, , 1

           1          2          3         4
1 -0.5779261  0.0000000  0.0000000  0.000000
2 -0.6985878 -0.5176976  0.0000000  0.000000
3  0.2535623 -0.5710865 -0.8379626  0.000000
4 -0.2174070  0.3546668 -0.3374541 -0.440023

, , 2

             1          2          3          4
1 -1.141241817  0.0000000  0.0000000  0.0000000
2 -0.016843901 -0.1570552  0.0000000  0.0000000
3 -0.025689010 -0.6384583 -0.2839690  0.0000000
4 -0.008686545  0.2612742 -0.5307853 -0.7401622

, , 3

           1          2          3          4
1 -0.4893992  0.0000000  0.0000000  0.0000000
2 -0.7346087 -0.5589732  0.0000000  0.0000000
3  0.2366696 -0.5516519 -1.2410793  0.0000000
4 -0.1522077  0.2855386 -0.2812269 -0.8685336

, , 4

            1          2          3          4
1 -0.74071169  0.0000000  0.0000000  0.0000000
2 -0.34233227 -1.1338031  0.0000000  0.0000000
3  0.04536192 -0.1899340 -0.4058354  0.0000000
4 -0.09562576  0.1221941 -0.4786488 -0.6823205

, , 5

            1          2          3          4
1 -0.71765773  0.0000000  0.0000000  0.0000000
2 -0.08759095 -0.4054459  0.0000000  0.0000000
3 -0.15612097 -0.6369255 -0.2098316  0.0000000
4 -0.02868912  0.2842285 -0.5826842 -0.5280902


> 
> 
> 
> 
> cleanEx()
> nameEx("ltMatrices")
> ### * ltMatrices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ltMatrices
> ### Title: Multiple Lower Triangular or Symmetric Matrices
> ### Aliases: ltMatrices syMatrices Tcrossprod Crossprod diagonals Mult
> ###   Mult.ltMatrices Mult.syMatrices solve.ltMatrices logdet
> ###   as.array.ltMatrices as.array.syMatrices diagonals.ltMatrices
> ###   diagonals.syMatrices diagonals.matrix diagonals<-
> ###   diagonals<-.ltMatrices diagonals<-.syMatrices diagonals.integer
> ###   is.ltMatrices is.syMatrices as.ltMatrices as.ltMatrices.ltMatrices
> ###   as.ltMatrices.syMatrices as.syMatrices is.chol is.invchol as.chol
> ###   as.invchol Lower_tri chol.syMatrices aperm.chol aperm.invchol
> ###   aperm.ltMatrices aperm.syMatrices deperma adddiag chol2cov
> ###   invchol2chol chol2invchol invchol2cov invchol2pre chol2pre Dchol
> ###   invcholD chol2cor invchol2cor invchol2pc chol2pc vectrick standardize
> ###   destandardize
> ### Keywords: matrix
> 
> ### ** Examples
> 
> 
>   J <- 4L
>   N <- 2L
>   dm <- paste0("d", 1:J)
>   xm <- paste0("x", 1:N)
>   (C <- ltMatrices(matrix(runif(N * J * (J + 1) / 2), 
+                           ncol = N, dimnames = list(NULL, xm)), 
+                    diag = TRUE, names = dm))
, , x1

          d1        d2        d3         d4
d1 0.2655087 0.0000000 0.0000000 0.00000000
d2 0.3721239 0.2016819 0.0000000 0.00000000
d3 0.5728534 0.8983897 0.6607978 0.00000000
d4 0.9082078 0.9446753 0.6291140 0.06178627

, , x2

          d1        d2        d3        d4
d1 0.2059746 0.0000000 0.0000000 0.0000000
d2 0.1765568 0.7698414 0.0000000 0.0000000
d3 0.6870228 0.4976992 0.9919061 0.0000000
d4 0.3841037 0.7176185 0.3800352 0.7774452

> 
>   ## dimensions and names
>   dim(C)
[1] 2 4 4
>   dimnames(C)
[[1]]
[1] "x1" "x2"

[[2]]
[1] "d1" "d2" "d3" "d4"

[[3]]
[1] "d1" "d2" "d3" "d4"

>   names(C)
 [1] "d1.d1" "d2.d1" "d3.d1" "d4.d1" "d2.d2" "d3.d2" "d4.d2" "d3.d3" "d4.d3"
[10] "d4.d4"
> 
>   ## subset
>   C[,2:3]
, , x1

          d2        d3
d2 0.2016819 0.0000000
d3 0.8983897 0.6607978

, , x2

          d2        d3
d2 0.7698414 0.0000000
d3 0.4976992 0.9919061

> 
>   ## multiplication
>   y <- matrix(runif(N * J), nrow = J)
>   Mult(C, y)
          x1         x2
d1 0.2481723 0.05504066
d2 0.3906115 0.34442623
d3 1.1566603 0.38903735
d4 1.4670471 0.68209756
> 
>   ## solve
>   solve(C)
, , x1

           d1        d2         d3       d4
d1   3.766355  0.000000   0.000000  0.00000
d2  -6.949313  4.958302   0.000000  0.00000
d3   6.182862 -6.741075   1.513322  0.00000
d4 -12.066025 -7.171180 -15.408800 16.18483

, , x2

              d1         d2         d3       d4
d1  4.8549681459  0.0000000  0.0000000 0.000000
d2 -1.1134467271  1.2989688  0.0000000 0.000000
d3 -2.8040078172 -0.6517712  1.0081600 0.000000
d4 -0.0002054465 -0.8804068 -0.4928145 1.286264

>   solve(C, y)
           x1         x2
d1   3.520432  1.2973478
d2  -5.443692  0.2040142
d3   5.335277 -0.9874473
d4 -20.808913  0.1452606
> 
>   ## tcrossprod
>   Tcrossprod(C)
, , x1

           d1         d2        d3        d4
d1 0.07049485 0.09880212 0.1520975 0.2411370
d2 0.09880212 0.17915180 0.3943614 0.5284898
d3 0.15209753 0.39436139 1.5719187 1.7846736
d4 0.24113704 0.52848976 1.7846736 2.1168548

, , x2

           d1        d2        d3        d4
d1 0.04242553 0.0363662 0.1415092 0.0791156
d2 0.03636620 0.6238281 0.5044480 0.6202686
d3 0.14150924 0.5044480 1.7035826 0.9980054
d4 0.07911560 0.6202686 0.9980054 1.4113598

> 
>   ## convert to matrix
>   as.array(solve(C[1,]))[,,1]
           d1        d2         d3       d4
d1   3.766355  0.000000   0.000000  0.00000
d2  -6.949313  4.958302   0.000000  0.00000
d3   6.182862 -6.741075   1.513322  0.00000
d4 -12.066025 -7.171180 -15.408800 16.18483
> 
> 
> 
> 
> cleanEx()
> nameEx("pmvnorm")
> ### * pmvnorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pmvnorm
> ### Title: Multivariate Normal Distribution
> ### Aliases: pmvnorm
> ### Keywords: distribution
> 
> ### ** Examples
> 
> 
> n <- 5
> mean <- rep(0, 5)
> lower <- rep(-1, 5)
> upper <- rep(3, 5)
> corr <- diag(5)
> corr[lower.tri(corr)] <- 0.5
> corr[upper.tri(corr)] <- 0.5
> prob <- pmvnorm(lower, upper, mean, corr)
> print(prob)
[1] 0.5800051
attr(,"error")
[1] 0.0002696831
attr(,"msg")
[1] "Normal Completion"
> 
> stopifnot(pmvnorm(lower=-Inf, upper=3, mean=0, sigma=1) == pnorm(3))
> 
> a <- pmvnorm(lower=-Inf,upper=c(.3,.5),mean=c(2,4),diag(2))
> 
> stopifnot(round(a,16) == round(prod(pnorm(c(.3,.5),c(2,4))),16))
> 
> a <- pmvnorm(lower=-Inf,upper=c(.3,.5,1),mean=c(2,4,1),diag(3))
> 
> stopifnot(round(a,16) == round(prod(pnorm(c(.3,.5,1),c(2,4,1))),16))
> 
> # Example from R News paper (original by Genz, 1992):
> 
> m <- 3
> sigma <- diag(3)
> sigma[2,1] <- 3/5
> sigma[3,1] <- 1/3
> sigma[3,2] <- 11/15
> pmvnorm(lower=rep(-Inf, m), upper=c(1,4,2), mean=rep(0, m), corr=sigma)
[1] 0.8279847
attr(,"error")
[1] 2.658133e-07
attr(,"msg")
[1] "Normal Completion"
> 
> # Correlation and Covariance
> 
> a <- pmvnorm(lower=-Inf, upper=c(2,2), sigma = diag(2)*2)
> b <- pmvnorm(lower=-Inf, upper=c(2,2)/sqrt(2), corr=diag(2))
> stopifnot(all.equal(round(a,5) , round(b, 5)))
> 
> 
> 
> 
> cleanEx()
> nameEx("pmvt")
> ### * pmvt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pmvt
> ### Title: Multivariate t Distribution
> ### Aliases: pmvt
> ### Keywords: distribution
> 
> ### ** Examples
> 
> 
> n <- 5
> lower <- -1
> upper <- 3
> df <- 4
> corr <- diag(5)
> corr[lower.tri(corr)] <- 0.5
> delta <- rep(0, 5)
> prob <- pmvt(lower=lower, upper=upper, delta=delta, df=df, corr=corr)
> print(prob)
[1] 0.5063832
attr(,"error")
[1] 0.0002426557
attr(,"msg")
[1] "Normal Completion"
> 
> pmvt(lower=-Inf, upper=3, df = 3, sigma = 1) == pt(3, 3)
upper 
 TRUE 
> 
> # Example from R News paper (original by Edwards and Berry, 1987)
> 
> n <- c(26, 24, 20, 33, 32)
> V <- diag(1/n)
> df <- 130
> C <- c(1,1,1,0,0,-1,0,0,1,0,0,-1,0,0,1,0,0,0,-1,-1,0,0,-1,0,0)
> C <- matrix(C, ncol=5)
> ### scale matrix
> cv <- C %*% tcrossprod(V, C)
> ### correlation matrix
> cr <- cov2cor(cv)
> delta <- rep(0,5)
> 
> myfct <- function(q, alpha) {
+   lower <- rep(-q, ncol(cv))
+   upper <- rep(q, ncol(cv))
+   pmvt(lower=lower, upper=upper, delta=delta, df=df,
+        corr=cr, abseps=0.0001) - alpha
+ }
> 
> ### uniroot for this simple problem
> round(uniroot(myfct, lower=1, upper=5, alpha=0.95)$root, 3)
[1] 2.561
> 
> # compare pmvt and pmvnorm for large df:
> 
> a <- pmvnorm(lower=-Inf, upper=1, mean=rep(0, 5), corr=diag(5))
> b <- pmvt(lower=-Inf, upper=1, delta=rep(0, 5), df=300,
+           corr=diag(5))
> a
[1] 0.4215702
attr(,"error")
[1] 0
attr(,"msg")
[1] "Normal Completion"
> b
[1] 0.4211423
attr(,"error")
[1] 2.31377e-06
attr(,"msg")
[1] "Normal Completion"
> 
> stopifnot(round(a, 2) == round(b, 2))
> 
> # correlation and scale matrix
> 
> a <- pmvt(lower=-Inf, upper=2, delta=rep(0,5), df=3,
+           sigma = diag(5)*2)
> b <- pmvt(lower=-Inf, upper=2/sqrt(2), delta=rep(0,5),
+           df=3, corr=diag(5))
> attributes(a) <- NULL
> attributes(b) <- NULL
> a
[1] 0.5653944
> b
[1] 0.5654
> stopifnot(all.equal(round(a,3) , round(b, 3)))
> 
> a <- pmvt(0, 1,df=10)
> attributes(a) <- NULL
> b <- pt(1, df=10) - pt(0, df=10)
> stopifnot(all.equal(round(a,10) , round(b, 10)))
> 
> 
> 
> 
> cleanEx()
> nameEx("qmvnorm")
> ### * qmvnorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qmvnorm
> ### Title: Quantiles of the Multivariate Normal Distribution
> ### Aliases: qmvnorm
> ### Keywords: distribution
> 
> ### ** Examples
> 
> qmvnorm(0.95, sigma = diag(2), tail = "both")
$quantile
[1] 2.236422

$f.quantile
[1] -1.310417e-06

attr(,"message")
[1] "Normal Completion"
> 
> 
> 
> cleanEx()
> nameEx("qmvt")
> ### * qmvt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qmvt
> ### Title: Quantiles of the Multivariate t Distribution
> ### Aliases: qmvt
> ### Keywords: distribution
> 
> ### ** Examples
> 
> ## basic evaluation
> qmvt(0.95, df = 16, tail = "both")
$quantile
[1] 2.119905

$f.quantile
[1] 0.975

> 
> ## check behavior for df=0 and df=Inf
> Sigma <- diag(2)
> set.seed(29)
> q0 <- qmvt(0.95, sigma = Sigma, df = 0,   tail = "both")$quantile
> set.seed(29)
> q8 <- qmvt(0.95, sigma = Sigma, df = Inf, tail = "both")$quantile
> set.seed(29)
> qn <- qmvnorm(0.95, sigma = Sigma, tail = "both")$quantile
> stopifnot(identical(q0, q8),
+           isTRUE(all.equal(q0, qn, tol = (.Machine$double.eps)^(1/3))))
> 
> ## if neither sigma nor corr are provided, corr = 1 is used internally
> df <- 0
> set.seed(29)
> qt95 <- qmvt(0.95, df = df, tail = "both")$quantile
> set.seed(29)
> qt95.c <- qmvt(0.95, df = df, corr  = 1, tail = "both")$quantile
> set.seed(29)
> qt95.s <- qmvt(0.95, df = df, sigma = 1, tail = "both")$quantile
> stopifnot(identical(qt95, qt95.c),
+           identical(qt95, qt95.s))
> 
> df <- 4
> set.seed(29)
> qt95 <- qmvt(0.95, df = df, tail = "both")$quantile
> set.seed(29)
> qt95.c <- qmvt(0.95, df = df, corr  = 1, tail = "both")$quantile
> set.seed(29)
> qt95.s <- qmvt(0.95, df = df, sigma = 1, tail = "both")$quantile
> stopifnot(identical(qt95, qt95.c),
+           identical(qt95, qt95.s))
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.071 0.026 1.097 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
