
R version 4.4.1 (2024-06-14) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "bitops"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('bitops')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("bitAnd")
> ### * bitAnd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bitAnd
> ### Title: Bitwise And, Or and Xor Operations
> ### Aliases: bitAnd bitOr bitXor %&% %|% %^%
> ### Keywords: arith utilities
> 
> ### ** Examples
> 
> bitAnd(15,7) == 7 ;  identical(15 %&% 7, bitAnd(15, 7))
[1] TRUE
[1] TRUE
> bitOr(15,7) == 15 ;  identical(15 %|% 7, bitOr (15, 7))
[1] TRUE
[1] TRUE
> bitXor(15,7) == 8 ;  identical(15 %^% 7, bitXor(15,7))
[1] TRUE
[1] TRUE
> bitOr(-1,0) == 4294967295 ; identical(-1 %|% 0, bitOr(-1,0))
[1] TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("bitFlip")
> ### * bitFlip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bitFlip
> ### Title: Binary Flip (Not) Operator
> ### Aliases: bitFlip
> ### Keywords: arith utilities
> 
> ### ** Examples
> 
> bitFlip(0:5)
[1] 4294967295 4294967294 4294967293 4294967292 4294967291 4294967290
> ##
> bitUnique <- function(x) bitFlip(bitFlip(x)) # "identity" when x in  0:(2^32-1)
> bitUnique(  0:16 ) # identical (well, double precision)
 [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
> bitUnique(-(1:16)) # 4294967295 ...
 [1] 4294967295 4294967294 4294967293 4294967292 4294967291 4294967290
 [7] 4294967289 4294967288 4294967287 4294967286 4294967285 4294967284
[13] 4294967283 4294967282 4294967281 4294967280
> stopifnot(
+   identical(bitUnique(-(1:16)), 2^32 -(1:16)),
+   bitFlip(-1) == 0,
+   bitFlip(0 ) == 2^32 - 1,
+   bitFlip(0, bitWidth=8) == 255
+ )
> 
> 
> 
> cleanEx()
> nameEx("bitShiftL")
> ### * bitShiftL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bitShiftL
> ### Title: Bitwise Shift Operator (to the Left or Right)
> ### Aliases: bitShiftL bitShiftR %<<% %>>%
> ### Keywords: arith utilities
> 
> ### ** Examples
> 
>  bitShiftL(0:4, 1) # 0 2 4 6 8
[1] 0 2 4 6 8
>  bitShiftL(0:3, 2) # 0 4 8 12
[1]  0  4  8 12
> 
>  stopifnot(exprs = {
+      identical(bitShiftL(0:4, 1), 0:4 %<<% 1)
+      identical(bitShiftR(0:3, 2), 0:3 %>>% 2)
+ })
> 
>  bitShiftR(0:7, 1) # 0 0  1 1  2 2  3 3 <==> N %/% 2
[1] 0 0 1 1 2 2 3 3
>  bitShiftR(0:7, 2) # 0 0 0 0  1 1 1 1   <==> N %/% 4
[1] 0 0 0 0 1 1 1 1
>  ## all outputs are "unsigned integer" :
>  stopifnot( bitShiftL(-1, 0) == 2^32 - 1   ,
+             bitShiftL(-7, 0) == 4294967289 ,
+             bitShiftL(-7, 0) == bitShiftR(-7, 0))
> 
>  bitShiftR(-1,1) == 2147483647
[1] TRUE
>  bitShiftL(2147483647,1) == 4294967294 # <==> * 2
[1] TRUE
>  bitShiftL( -1,       1) == 4294967294
[1] TRUE
> 
>  bitShiftL(47, 32) # is 47
[1] 47
> 
> ## 5 Christmas trees  ( bitShiftL *rotates* to the left)
> t(outer(1:5, 0:40, bitShiftL))
            [,1]       [,2]       [,3]       [,4]       [,5]
 [1,]          1          2          3          4          5
 [2,]          2          4          6          8         10
 [3,]          4          8         12         16         20
 [4,]          8         16         24         32         40
 [5,]         16         32         48         64         80
 [6,]         32         64         96        128        160
 [7,]         64        128        192        256        320
 [8,]        128        256        384        512        640
 [9,]        256        512        768       1024       1280
[10,]        512       1024       1536       2048       2560
[11,]       1024       2048       3072       4096       5120
[12,]       2048       4096       6144       8192      10240
[13,]       4096       8192      12288      16384      20480
[14,]       8192      16384      24576      32768      40960
[15,]      16384      32768      49152      65536      81920
[16,]      32768      65536      98304     131072     163840
[17,]      65536     131072     196608     262144     327680
[18,]     131072     262144     393216     524288     655360
[19,]     262144     524288     786432    1048576    1310720
[20,]     524288    1048576    1572864    2097152    2621440
[21,]    1048576    2097152    3145728    4194304    5242880
[22,]    2097152    4194304    6291456    8388608   10485760
[23,]    4194304    8388608   12582912   16777216   20971520
[24,]    8388608   16777216   25165824   33554432   41943040
[25,]   16777216   33554432   50331648   67108864   83886080
[26,]   33554432   67108864  100663296  134217728  167772160
[27,]   67108864  134217728  201326592  268435456  335544320
[28,]  134217728  268435456  402653184  536870912  671088640
[29,]  268435456  536870912  805306368 1073741824 1342177280
[30,]  536870912 1073741824 1610612736 2147483648 2684354560
[31,] 1073741824 2147483648 3221225472          0 1073741824
[32,] 2147483648          0 2147483648          0 2147483648
[33,]          1          2          3          4          5
[34,]          2          4          6          8         10
[35,]          4          8         12         16         20
[36,]          8         16         24         32         40
[37,]         16         32         48         64         80
[38,]         32         64         96        128        160
[39,]         64        128        192        256        320
[40,]        128        256        384        512        640
[41,]        256        512        768       1024       1280
> 
> N <- as.numeric( rpois(1000, 100) )
> stopifnot(identical(bitShiftL(N,0),   N),
+           identical(bitShiftL(N,1), 2*N),
+           identical(bitShiftL(N,2), 4*N),
+           ## right shift:
+           identical(bitShiftR(N,2), N %/% 4),
+           identical(bitShiftR(N,4), N %/% 16))
> 
> 
> 
> cleanEx()
> nameEx("cksum")
> ### * cksum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cksum
> ### Title: Compute Check Sum
> ### Aliases: cksum
> ### Keywords: arith utilities
> 
> ### ** Examples
> 
>    b <- "I would rather have a bottle in front of me than frontal lobotomy\n"
>  stopifnot(cksum(b) == 1342168430)
>  (bv <- strsplit(b, " ")[[1]])
 [1] "I"          "would"      "rather"     "have"       "a"         
 [6] "bottle"     "in"         "front"      "of"         "me"        
[11] "than"       "frontal"    "lobotomy\n"
>  cksum(bv) # now a vector of length 13
 [1] 3794341002  351271217 2629646443 3986024602 1220704766 2750897933
 [7] 3122994064 3007351831  884913104 1172616461 3405771722 2111744547
[13] 1881082391
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.057 0.014 0.071 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
