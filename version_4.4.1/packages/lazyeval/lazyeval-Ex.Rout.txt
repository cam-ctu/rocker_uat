
R version 4.4.1 (2024-06-14) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "lazyeval"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('lazyeval')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("as.lazy")
> ### * as.lazy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.lazy
> ### Title: Convert an object to a lazy expression or lazy dots.
> ### Aliases: as.lazy as.lazy_dots
> 
> ### ** Examples
> 
> as.lazy(~ x + 1)
<lazy>
  expr: x + 1
  env:  <environment: R_GlobalEnv>
> as.lazy(quote(x + 1), globalenv())
<lazy>
  expr: x + 1
  env:  <environment: R_GlobalEnv>
> as.lazy("x + 1", globalenv())
<lazy>
  expr: x + 1
  env:  <environment: R_GlobalEnv>
> 
> as.lazy_dots(list(~x, y = ~z + 1))
[[1]]
<lazy>
  expr: x
  env:  <environment: R_GlobalEnv>

$y
<lazy>
  expr: z + 1
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> as.lazy_dots(c("a", "b", "c"), globalenv())
[[1]]
<lazy>
  expr: a
  env:  <environment: R_GlobalEnv>

[[2]]
<lazy>
  expr: b
  env:  <environment: R_GlobalEnv>

[[3]]
<lazy>
  expr: c
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> as.lazy_dots(~x)
[[1]]
<lazy>
  expr: x
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> as.lazy_dots(quote(x), globalenv())
[[1]]
<lazy>
  expr: x
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> as.lazy_dots(quote(f()), globalenv())
[[1]]
<lazy>
  expr: f()
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> as.lazy_dots(lazy(x))
[[1]]
<lazy>
  expr: x
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> 
> 
> 
> cleanEx()
> nameEx("as_name")
> ### * as_name
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_name
> ### Title: Coerce an object to a name or call.
> ### Aliases: as_name as_call
> 
> ### ** Examples
> 
> as_name("x + y")
`x + y`
> as_call("x + y")
x + y
> 
> as_call(~ f)
f()
> as_name(~ f())
f
> 
> 
> 
> cleanEx()
> nameEx("ast_")
> ### * ast_
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ast_
> ### Title: Display a call (or expression) as a tree.
> ### Aliases: ast_ ast
> 
> ### ** Examples
> 
> ast(f(x, 1, g(), h(i())))
┗ ()
 ┗ `f
 ┗ `x
 ┗  1
 ┗ ()
  ┗ `g
 ┗ ()
  ┗ `h
  ┗ ()
   ┗ `i 
> ast(if (TRUE) 3 else 4)
┗ ()
 ┗ `if
 ┗  TRUE
 ┗  3
 ┗  4 
> ast(function(a = 1, b = 2) {a + b + 10})
┗ ()
 ┗ `function
 ┗ []
  ┗ a = 1
  ┗ b = 2
 ┗ ()
  ┗ `{
  ┗ ()
   ┗ `+
   ┗ ()
    ┗ `+
    ┗ `a
    ┗ `b
   ┗  10
 ┗ <NULL> 
> ast(f(x)(y)(z))
┗ ()
 ┗ ()
  ┗ ()
   ┗ `f
   ┗ `x
  ┗ `y
 ┗ `z 
> 
> ast_(quote(f(x, 1, g(), h(i()))))
┗ ()
 ┗ `f
 ┗ `x
 ┗  1
 ┗ ()
  ┗ `g
 ┗ ()
  ┗ `h
  ┗ ()
   ┗ `i 
> ast_(quote(if (TRUE) 3 else 4))
┗ ()
 ┗ `if
 ┗  TRUE
 ┗  3
 ┗  4 
> ast_(expression(1, 2, 3))
┗  1

┗  2

┗  3 
> 
> 
> 
> cleanEx()
> nameEx("auto_name")
> ### * auto_name
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: auto_name
> ### Title: Automatically name all components of a lazy dots.
> ### Aliases: auto_name
> ### Keywords: internal
> 
> ### ** Examples
> 
> x <- lazy_dots(1 + 2, mean(mpg))
> auto_name(x)
$`1 + 2`
<lazy>
  expr: 1 + 2
  env:  <environment: R_GlobalEnv>

$`mean(mpg)`
<lazy>
  expr: mean(mpg)
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> 
> auto_name(list(~f, quote(x)))
$f
~f

$x
x

> 
> 
> 
> cleanEx()
> nameEx("call_modify")
> ### * call_modify
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: call_modify
> ### Title: Modify the arguments of a call.
> ### Aliases: call_modify call_standardise
> 
> ### ** Examples
> 
> call <- quote(mean(x, na.rm = TRUE))
> call_standardise(call)
mean(x = x, na.rm = TRUE)
> 
> # Modify an existing argument
> call_modify(call, list(na.rm = FALSE))
mean(x = x, na.rm = FALSE)
> call_modify(call, list(x = quote(y)))
mean(x = y, na.rm = TRUE)
> 
> # Remove an argument
> call_modify(call, list(na.rm = NULL))
mean(x = x)
> 
> # Add a new argument
> call_modify(call, list(trim = 0.1))
mean(x = x, na.rm = TRUE, trim = 0.1)
> 
> # Add an explicit missing argument
> call_modify(call, list(na.rm = quote(expr = )))
mean(x = x, na.rm = )
> 
> 
> 
> cleanEx()
> nameEx("call_new")
> ### * call_new
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: call_new
> ### Title: Create a call by "hand"
> ### Aliases: call_new
> 
> ### ** Examples
> 
> # f can either be a string, a symbol or a call
> call_new("f", a = 1)
f(a = 1)
> call_new(quote(f), a = 1)
f(a = 1)
> call_new(quote(f()), a = 1)
f()(a = 1)
> 
> #' Can supply arguments individually or in a list
> call_new(quote(f), a = 1, b = 2)
f(a = 1, b = 2)
> call_new(quote(f), .args = list(a = 1, b = 2))
f(a = 1, b = 2)
> 
> 
> 
> cleanEx()
> nameEx("common_env")
> ### * common_env
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: common_env
> ### Title: Find common environment in list of lazy objects.
> ### Aliases: common_env
> ### Keywords: internal
> 
> ### ** Examples
> 
> common_env(lazy_dots(a, b, c))
<environment: R_GlobalEnv>
> 
> f <- function(x) ~x
> common_env(list(f(1)))
<environment: 0x55e7f43dc268>
> common_env(list(f(1), f(2)))
<environment: base>
> 
> 
> 
> cleanEx()
> nameEx("expr_label")
> ### * expr_label
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expr_label
> ### Title: Find the expression associated with an argument
> ### Aliases: expr_label expr_text expr_find expr_env
> 
> ### ** Examples
> 
> # Unlike substitute(), expr_find() finds the original expression
> f <- function(x) g(x)
> g <- function(y) h(y)
> h <- function(z) list(substitute(z), expr_find(z))
> 
> f(1 + 2 + 3)
[[1]]
y

[[2]]
1 + 2 + 3

> 
> expr_label(10)
[1] "10"
> # Names a quoted with ``
> expr_label(x)
[1] "`x`"
> # Strings are encoded
> expr_label("a\nb")
[1] "\"a\\nb\""
> # Expressions are captured
> expr_label(a + b + c)
[1] "`a + b + c`"
> # Long expressions are collapsed
> expr_label(foo({
+   1 + 2
+   print(x)
+ }))
[1] "`foo(...)`"
> 
> 
> 
> cleanEx()
> nameEx("f_capture")
> ### * f_capture
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: f_capture
> ### Title: Make a promise explicit by converting into a formula.
> ### Aliases: f_capture dots_capture
> 
> ### ** Examples
> 
> f_capture(a + b)
~a + b
> dots_capture(a + b, c + d, e + f)
[[1]]
~a + b

[[2]]
~c + d

[[3]]
~e + f

> 
> # These functions will follow a chain of promises back to the
> # original definition
> f <- function(x) g(x)
> g <- function(y) h(y)
> h <- function(z) f_capture(z)
> f(a + b + c)
~a + b + c
> 
> 
> 
> cleanEx()
> nameEx("f_eval")
> ### * f_eval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: f_eval_rhs
> ### Title: Evaluate a formula
> ### Aliases: f_eval_rhs f_eval_lhs f_eval find_data
> 
> ### ** Examples
> 
> f_eval(~ 1 + 2 + 3)
[1] 6
> 
> # formulas automatically capture their enclosing environment
> foo <- function(x) {
+   y <- 10
+   ~ x + y
+ }
> f <- foo(1)
> f
~x + y
<environment: 0x55e7f449eb58>
> f_eval(f)
[1] 11
> 
> # If you supply data, f_eval will look their first:
> f_eval(~ cyl, mtcars)
 [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4
> 
> # To avoid ambiguity, you can use .env and .data pronouns to be
> # explicit:
> cyl <- 10
> f_eval(~ .data$cyl, mtcars)
 [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4
> f_eval(~ .env$cyl, mtcars)
[1] 10
> 
> # Imagine you are computing the mean of a variable:
> f_eval(~ mean(cyl), mtcars)
[1] 6.1875
> # How can you change the variable that's being computed?
> # The easiest way is "unquote" with uq()
> # See ?f_interp for more details
> var <- ~ cyl
> f_eval(~ mean( uq(var) ), mtcars)
[1] 6.1875
> 
> 
> 
> cleanEx()
> nameEx("f_interp")
> ### * f_interp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: f_interp
> ### Title: Interpolate a formula
> ### Aliases: f_interp uq uqs uqf
> 
> ### ** Examples
> 
> f_interp(x ~ 1 + uq(1 + 2 + 3) + 10)
x ~ 1 + 6 + 10
> 
> # Use uqs() if you want to add multiple arguments to a function
> # It must evaluate to a list
> args <- list(1:10, na.rm = TRUE)
> f_interp(~ mean( uqs(args) ))
~mean(1:10, na.rm = TRUE)
> 
> # You can combine the two
> var <- quote(xyz)
> extra_args <- list(trim = 0.9)
> f_interp(~ mean( uq(var) , uqs(extra_args) ))
~mean(xyz, trim = 0.9)
> 
> foo <- function(n) {
+   ~ 1 + uq(n)
+ }
> f <- foo(10)
> f
~1 + uq(n)
<environment: 0x55e7f45587d0>
> f_interp(f)
~1 + 10
<environment: 0x55e7f45587d0>
> 
> 
> 
> cleanEx()
> nameEx("f_list")
> ### * f_list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: f_list
> ### Title: Build a named list from the LHS of formulas
> ### Aliases: f_list as_f_list
> 
> ### ** Examples
> 
> f_list("y" ~ x)
$y
~x

> f_list(a = "y" ~ a, ~ b, c = ~c)
$y
~a

[[2]]
~b

$c
~c

> 
> 
> 
> cleanEx()
> nameEx("f_new")
> ### * f_new
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: f_new
> ### Title: Create a formula object by "hand".
> ### Aliases: f_new
> 
> ### ** Examples
> 
> f_new(quote(a))
~a
> f_new(quote(a), quote(b))
b ~ a
> 
> 
> 
> cleanEx()
> nameEx("f_rhs")
> ### * f_rhs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: f_rhs
> ### Title: Get/set formula components.
> ### Aliases: f_rhs f_rhs<- f_lhs f_lhs<- f_env f_env<-
> 
> ### ** Examples
> 
> f_rhs(~ 1 + 2 + 3)
1 + 2 + 3
> f_rhs(~ x)
x
> f_rhs(~ "A")
[1] "A"
> f_rhs(1 ~ 2)
[1] 2
> 
> f_lhs(~ y)
NULL
> f_lhs(x ~ y)
x
> 
> f_env(~ x)
<environment: R_GlobalEnv>
> 
> 
> 
> cleanEx()
> nameEx("f_text")
> ### * f_text
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: f_text
> ### Title: Turn RHS of formula into a string/label.
> ### Aliases: f_text f_label
> 
> ### ** Examples
> 
> f <- ~ a + b + bc
> f_text(f)
[1] "a + b + bc"
> f_label(f)
[1] "`a + b + bc`"
> 
> # Names a quoted with ``
> f_label(~ x)
[1] "`x`"
> # Strings are encoded
> f_label(~ "a\nb")
[1] "\"a\\nb\""
> # Long expressions are collapsed
> f_label(~ foo({
+   1 + 2
+   print(x)
+ }))
[1] "`foo(...)`"
> 
> 
> 
> cleanEx()
> nameEx("f_unwrap")
> ### * f_unwrap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: f_unwrap
> ### Title: Unwrap a formula
> ### Aliases: f_unwrap
> 
> ### ** Examples
> 
> n <- 100
> f <- ~ x + n
> f_unwrap(f)
~x + 100
<environment: package:lazyeval>
attr(,"name")
[1] "package:lazyeval"
attr(,"path")
[1] "/usr/local/lib/R/site-library/lazyeval"
> 
> 
> 
> cleanEx()
> nameEx("function_new")
> ### * function_new
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: function_new
> ### Title: Create a function by "hand"
> ### Aliases: function_new
> 
> ### ** Examples
> 
> f <- function(x) x + 3
> g <- function_new(alist(x = ), quote(x + 3))
> 
> # The components of the functions are identical
> identical(formals(f), formals(g))
[1] TRUE
> identical(body(f), body(g))
[1] TRUE
> identical(environment(f), environment(g))
[1] TRUE
> 
> # But the functions are not identical because f has src code reference
> identical(f, g)
[1] TRUE
> 
> attr(f, "srcref") <- NULL
> # Now they are:
> stopifnot(identical(f, g))
> 
> 
> 
> cleanEx()
> nameEx("interp")
> ### * interp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interp
> ### Title: Interpolate values into an expression.
> ### Aliases: interp
> 
> ### ** Examples
> 
> # Interp works with formulas, lazy objects, quoted calls and strings
> interp(~ x + y, x = 10)
~10 + y
> interp(lazy(x + y), x = 10)
<lazy>
  expr: 10 + y
  env:  <environment: R_GlobalEnv>
> interp(quote(x + y), x = 10)
10 + y
> interp("x + y", x = 10)
[1] "10 + y"
> 
> # Use as.name if you have a character string that gives a
> # variable name
> interp(~ mean(var), var = as.name("mpg"))
~mean(mpg)
> # or supply the quoted name directly
> interp(~ mean(var), var = quote(mpg))
~mean(mpg)
> 
> # Or a function!
> interp(~ f(a, b), f = as.name("+"))
~a + b
> # Remember every action in R is a function call:
> # http://adv-r.had.co.nz/Functions.html#all-calls
> 
> # If you've built up a list of values through some other
> # mechanism, use .values
> interp(~ x + y, .values = list(x = 10))
~10 + y
> 
> # You can also interpolate variables defined in the current
> # environment, but this is a little risky.
> y <- 10
> interp(~ x + y, .values = environment())
~x + 10
> 
> 
> 
> cleanEx()
> nameEx("is_formula")
> ### * is_formula
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_formula
> ### Title: Is object a formula?
> ### Aliases: is_formula
> 
> ### ** Examples
> 
> is_formula(~ 10)
[1] TRUE
> is_formula(10)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("is_lang")
> ### * is_lang
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_lang
> ### Title: Is an object a language object?
> ### Aliases: is_lang is_name is_call is_pairlist is_atomic
> 
> ### ** Examples
> 
> q1 <- quote(1)
> is_lang(q1)
[1] TRUE
> is_atomic(q1)
[1] TRUE
> 
> q2 <- quote(x)
> is_lang(q2)
[1] TRUE
> is_name(q2)
[1] TRUE
> 
> q3 <- quote(x + 1)
> is_lang(q3)
[1] TRUE
> is_call(q3)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("lazy_")
> ### * lazy_
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lazy_
> ### Title: Capture expression for later lazy evaluation.
> ### Aliases: lazy_ lazy
> 
> ### ** Examples
> 
> lazy_(quote(a + x), globalenv())
<lazy>
  expr: a + x
  env:  <environment: R_GlobalEnv>
> 
> # Lazy is designed to be used inside a function - you should
> # give it the name of a function argument (a promise)
> f <- function(x = b - a) {
+   lazy(x)
+ }
> f()
<lazy>
  expr: b - a
  env:  <environment: 0x55e7f463b538>
> f(a + b / c)
<lazy>
  expr: a + b/c
  env:  <environment: R_GlobalEnv>
> 
> # Lazy also works when called from the global environment. This makes
> # easy to play with interactively.
> lazy(a + b / c)
<lazy>
  expr: a + b/c
  env:  <environment: R_GlobalEnv>
> 
> # By default, lazy will climb all the way back to the initial promise
> # This is handy if you have if you have nested functions:
> g <- function(y) f(y)
> h <- function(z) g(z)
> f(a + b)
<lazy>
  expr: a + b
  env:  <environment: R_GlobalEnv>
> g(a + b)
<lazy>
  expr: a + b
  env:  <environment: R_GlobalEnv>
> h(a + b)
<lazy>
  expr: a + b
  env:  <environment: R_GlobalEnv>
> 
> # To avoid this behavour, set .follow_symbols = FALSE
> # See vignette("chained-promises") for details
> 
> 
> 
> cleanEx()
> nameEx("lazy_dots")
> ### * lazy_dots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lazy_dots
> ### Title: Capture ... (dots) for later lazy evaluation.
> ### Aliases: lazy_dots
> 
> ### ** Examples
> 
> lazy_dots(x = 1)
$x
<lazy>
  expr: 1
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> lazy_dots(a, b, c * 4)
[[1]]
<lazy>
  expr: a
  env:  <environment: R_GlobalEnv>

[[2]]
<lazy>
  expr: b
  env:  <environment: R_GlobalEnv>

[[3]]
<lazy>
  expr: c * 4
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> 
> f <- function(x = a + b, ...) {
+   lazy_dots(x = x, y = a + b, ...)
+ }
> f(z = a + b)
$x
<lazy>
  expr: x
  env:  <environment: 0x55e7f4921858>

$y
<lazy>
  expr: a + b
  env:  <environment: 0x55e7f4921858>

$z
<lazy>
  expr: a + b
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> f(z = a + b, .follow_symbols = TRUE)
$x
<lazy>
  expr: a + b
  env:  <environment: 0x55e7f4938710>

$y
<lazy>
  expr: a + b
  env:  <environment: 0x55e7f4938710>

$z
<lazy>
  expr: a + b
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> 
> # .follow_symbols is off by default because it causes problems
> # with lazy loaded objects
> lazy_dots(letters)
[[1]]
<lazy>
  expr: letters
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> lazy_dots(letters, .follow_symbols = TRUE)
[[1]]
<lazy>
  expr: letters
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> 
> # You can also modify a dots like a list. Anything on the RHS will
> # be coerced to a lazy.
> l <- lazy_dots(x = 1)
> l$y <- quote(f)
> l[c("y", "x")]
$y
<lazy>
  expr: f
  env:  <environment: R_GlobalEnv>

$x
<lazy>
  expr: 1
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> l["z"] <- list(~g)
> 
> c(lazy_dots(x = 1), lazy_dots(f))
$x
<lazy>
  expr: 1
  env:  <environment: R_GlobalEnv>

[[2]]
<lazy>
  expr: f
  env:  <environment: R_GlobalEnv>

attr(,"class")
[1] "lazy_dots"
> 
> 
> 
> cleanEx()
> nameEx("lazy_eval")
> ### * lazy_eval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lazy_eval
> ### Title: Evaluate a lazy expression.
> ### Aliases: lazy_eval
> 
> ### ** Examples
> 
> f <- function(x) {
+   z <- 100
+   ~ x + z
+ }
> z <- 10
> lazy_eval(f(10))
[1] 110
> lazy_eval(f(10), list(x = 100))
[1] 200
> lazy_eval(f(10), list(x = 1, z = 1))
[1] 2
> 
> lazy_eval(lazy_dots(a = x, b = z), list(x = 10))
$a
[1] 10

$b
[1] 10

> 
> 
> 
> cleanEx()
> nameEx("make_call")
> ### * make_call
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_call
> ### Title: Make a call with 'lazy_dots' as arguments.
> ### Aliases: make_call
> 
> ### ** Examples
> 
> make_call(quote(f), lazy_dots(x = 1, 2))
<lazy>
  expr: f(x = 1, 2)
  env:  <environment: R_GlobalEnv>
> make_call(quote(f), list(x = 1, y = ~x))
<lazy>
  expr: f(x = 1, y = x)
  env:  <environment: base>
> make_call(quote(f), ~x)
<lazy>
  expr: f(x)
  env:  <environment: R_GlobalEnv>
> 
> # If no known or no common environment, fails back to baseenv()
> make_call(quote(f), quote(x))
<lazy>
  expr: f(x)
  env:  <environment: base>
> 
> 
> 
> cleanEx()
> nameEx("missing_arg")
> ### * missing_arg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: missing_arg
> ### Title: Generate a missing argument.
> ### Aliases: missing_arg
> 
> ### ** Examples
> 
> f_interp(~f(x = uq(missing_arg())))
~f(x = )
> f_interp(~f(x = uq(NULL)))
~f(x = NULL)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.084 0.009 0.093 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
