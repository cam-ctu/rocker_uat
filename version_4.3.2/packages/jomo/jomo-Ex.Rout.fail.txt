
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "jomo"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('jomo')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("jomo.MCMCchain")
> ### * jomo.MCMCchain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo.MCMCchain
> ### Title: JM Imputation - A tool to check convergence of the MCMC
> ### Aliases: jomo.MCMCchain
> 
> ### ** Examples
> 
> 
>   # define all the inputs:
>   
>   Y<-cldata[,c("measure","age")]
>   clus<-cldata[,c("city")]
>   nburn=as.integer(200);
>   
>   #And finally we run the imputation function:
>   imp<-jomo.MCMCchain(Y,clus=clus,nburn=nburn)
Clustered data, using functions for two-level imputation.
Found  2 continuous outcomes and no categorical. Using function jomo1rancon. 
....................The posterior mean of the fixed effects estimates is:
               X1
measure 0.6655405
age     0.3094749

The posterior mean of the random effects estimates is:
   measure.Z1      age.Z1
0  0.41794002 -0.28258523
1  0.60229986 -0.37163158
2 -0.36102615  0.15469539
3  1.06039170  0.03938371
4 -0.41964912 -0.11211047
5  0.10707736 -0.28046132
6  0.10095477  0.22028967
7 -0.09418288  0.23530210
8 -0.26928229 -0.41146692
9 -0.14584808  0.07512890

The posterior mean of the level 1 covariance matrices is:
            measure         age
measure  1.00350365 -0.09585593
age     -0.09585593  3.49522404

The posterior mean of the level 2 covariance matrix is:
            measure.Z1      age.Z1
measure*Z1  0.37897394 -0.02881529
age*Z1     -0.02881529  0.22255685
>   #We can check the convergence of the first element of beta:
>   
>   plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")
>   
>   #Or similarly we can check the convergence of any element of the level 2 covariance matrix:
>   
>   plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
> 
> 
> 
> cleanEx()
> nameEx("jomo")
> ### * jomo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo
> ### Title: Joint Modelling Imputation
> ### Aliases: jomo
> 
> ### ** Examples
> 
> 
>   # define all the inputs:
>   
>   Y<-cldata[,c("measure","age")]
>   clus<-cldata[,c("city")]
>   nburn=as.integer(200);
>   nbetween=as.integer(200);
>   nimp=as.integer(5);
>   
>   
>   #And finally we run the imputation function:
>   imp<-jomo(Y,clus=clus,nburn=nburn,nbetween=nbetween,nimp=nimp)
Clustered data, using functions for two-level imputation.
Found  2 continuous outcomes and no categorical. Using function jomo1rancon. 
....................First imputation registered. 
....................Imputation number  2 registered 
....................Imputation number  3 registered 
....................Imputation number  4 registered 
....................Imputation number  5 registered 
The posterior mean of the fixed effects estimates is:
               X1
measure 0.8258795
age     0.2289910

The posterior mean of the random effects estimates is:
   measure.Z1      age.Z1
0  0.25479507 -0.20461961
1  0.42865165 -0.29700103
2 -0.52156498  0.22377082
3  0.90840869  0.16063075
4 -0.58221915 -0.04105992
5 -0.03788197 -0.21928126
6 -0.05525023  0.28393631
7 -0.25505282  0.30971719
8 -0.43100440 -0.34355184
9 -0.28088228  0.16514950

The posterior mean of the level 1 covariance matrices is:
           measure        age
measure  0.9932926 -0.1077829
age     -0.1077829  3.5026089

The posterior mean of the level 2 covariance matrix is:
            measure.Z1      age.Z1
measure*Z1  0.36909521 -0.01515055
age*Z1     -0.01515055  0.22883342
>   
>   # Finally we show how to fit the model and combine estimate with Rubin's rules
>   # Here we use mitml, other options are available in mice, mitools, etc etc
> 
>   #if (requireNamespace("mitml", quietly = TRUE)&requireNamespace("lme4", quietly = TRUE)) {
>     #imp.mitml<-jomo2mitml.list(imp)
>     #fit.i<-with(imp.mitml, lmer(measure~age+(1|clus)))
>     #fit.MI<-testEstimates(fit.i, var.comp=T)
>  # }
> 
>   #we could even run imputation with fixed or random cluster-specific covariance matrices:
>   
>   #imp<-jomo(Y,clus=clus,nburn=nburn,nbetween=nbetween,nimp=nimp, meth="fixed")
>   #or:
>   #imp<-jomo(Y,clus=clus,nburn=nburn,nbetween=nbetween,nimp=nimp, meth="random")
>   
>   #if we do not add clus as imput, functions for single level imputation are used:
>   
>   #imp<-jomo(Y)
>   
>   
> 
>   
>   
> 
> 
> 
> cleanEx()
> nameEx("jomo.clmm.MCMCchain")
> ### * jomo.clmm.MCMCchain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo.clmm.MCMCchain
> ### Title: clmm Compatible JM Imputation - A tool to check convergence of
> ###   the MCMC
> ### Aliases: jomo.clmm.MCMCchain
> 
> ### ** Examples
> 
> 
>   # make sure social is a factor:
>   
>   cldata<-within(cldata, social<-factor(social))
>   
>   # we define the data frame with all the variables 
>   
>   data<-cldata[,c("measure","age", "social", "city")]
>   
>   # And the formula of the substantive lm model 
>   # social as an outcome only because it is the only ordinal variable in the dataset...
>   
>   formula<-as.formula(social~age+measure+(1|city))
>   
>   #And finally we run the imputation function:
>   
>   imp<-jomo.clmm.MCMCchain(formula,data, nburn=100)
This function is beta software. Please use carefully and report any bug to the package mantainer
..........First imputation registered. 
The posterior mean of the substantive model fixed effects estimates is:
               age    measure        1|2       2|3      3|4
social -0.02655046 0.02832252 -0.4176594 0.2768608 1.118634
The posterior mean of the substantive model residual variance is:
[1] 1
The posterior mean of the substantive model random effects covariance matrix is:
            (Intercept)
(Intercept)   0.2803047
The posterior mean of the substantive model random effects estimates is:
  (Intercept)
0  -0.1593817
1  -0.6336053
2  -0.4525832
3  -0.1119719
4   0.1227633
5   0.7257102
6   0.5691808
7   0.5550438
8   0.1403781
9  -0.4707765
>   
>   # We can check, for example, the convergence of the first element of beta:
>   
>   # plot(c(1:100),imp$collectbeta[1,1,1:100],type="l")
>   
>   
> 
> 
> 
> cleanEx()
> nameEx("jomo.clmm")
> ### * jomo.clmm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo.clmm
> ### Title: Joint Modelling Imputation Compatible with Cumulative Link Mixed
> ###   Model
> ### Aliases: jomo.clmm
> 
> ### ** Examples
> 
> 
> 
>   # make sure social is a factor:
>   
>   cldata<-within(cldata, social<-factor(social))
>   
>   # we define the data frame with all the variables 
>   
>   data<-cldata[,c("measure","age", "social", "city")]
>   
>   # And the formula of the substantive lm model 
>   # social as an outcome only because it is the only ordinal variable in the dataset...
>   
>   formula<-as.formula(social~age+measure+(1|city))
>   
>   #And finally we run the imputation function:
>   
>   # imp<-jomo.clmm(formula,data, nburn=1000, nbetween=1000, nimp=2)
>   
>   # Note the function is commented out to avoid time consuming examples, 
>   # which go against CRAN policies. 
>   # Check help page for function jomo to see how to fit the model and 
>   # combine estimates with Rubin's rules
>   
>   
>   
> 
> 
> 
> cleanEx()
> nameEx("jomo.coxph.MCMCchain")
> ### * jomo.coxph.MCMCchain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo.coxph.MCMCchain
> ### Title: coxph Compatible JM Imputation - A tool to check convergence of
> ###   the MCMC
> ### Aliases: jomo.coxph.MCMCchain
> 
> ### ** Examples
> 
>     # define substantive model
> 
>     formula<-as.formula(Surv(time, status) ~ measure + sex + I(measure^2))
>     
>     #Run imputation
>     
> if (requireNamespace("survival", quietly = TRUE)) {
+   library(survival)
+   #imp<-jomo.coxph.MCMCchain(formula,surdata, nburn = 100)
+   }
>     
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("jomo.coxph")
> ### * jomo.coxph
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo.coxph
> ### Title: Joint Modelling Imputation Compatible with Cox Proportional
> ###   Hazards Model
> ### Aliases: jomo.coxph
> 
> ### ** Examples
> 
> #define substantive model
> formula<-as.formula(Surv(time, status) ~ measure + sex + I(measure^2))
> 
> #Run imputation
> if (requireNamespace("survival", quietly = TRUE)) {
+   library(survival)
+   #imp<-jomo.coxph(formula,surdata, nburn = 100, nbetween = 100, nimp=5)
+ }
>   # Check help page for function jomo to see how to fit the model and 
>   # combine estimates with Rubin's rules
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("jomo.glm.MCMCchain")
> ### * jomo.glm.MCMCchain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo.glm.MCMCchain
> ### Title: glm Compatible JM Imputation - A tool to check convergence of
> ###   the MCMC
> ### Aliases: jomo.glm.MCMCchain
> 
> ### ** Examples
> 
> 
>   # make sure sex is a factor:
>   
>   sldata<-within(sldata, sex<-factor(sex))
>   
>   # we define the data frame with all the variables 
>   
>   data<-sldata[,c("measure","age", "sex")]
>   
>   # And the formula of the substantive lm model 
>   # sex as an outcome only because it is the only binary variable in the dataset...
>   
>   formula<-as.formula(sex~age+measure)
>   
>   #And finally we run the imputation function:
>   
>   imp<-jomo.glm.MCMCchain(formula,data, nburn=10)
This function is beta software. Use carefully and please report any bug to the package mantainer
.First imputation registered. 
The posterior mean of the substantive model fixed effects estimates is:
    (Intercept)          age    measure
sex   0.1789578 -0.002422949 0.05877437
The posterior mean of the substantive model residual variance is:
[1] 1
>   
>   # Note we are using only 10 iterations to avoid time consuming examples,
>   # which go against CRAN policies. In real applications we would use
>   # much larger burn-ins (around 1000, to say the least).
>   
>   # We can check, for example, the convergence of the first element of beta:
>   
>   plot(c(1:10),imp$collectbeta[1,1,1:10],type="l")
>   
>   
> 
> 
> 
> cleanEx()
> nameEx("jomo.glm")
> ### * jomo.glm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo.glm
> ### Title: Joint Modelling Imputation Compatible with glm Model
> ### Aliases: jomo.glm
> 
> ### ** Examples
> 
> 
>    # make sure sex is a factor:
>   
>   sldata<-within(sldata, sex<-factor(sex))
>   
>   # we define the data frame with all the variables 
>   
>   data<-sldata[,c("measure","age", "sex")]
>   
>   # And the formula of the substantive lm model 
>   # sex as an outcome only because it is the only binary variable in the dataset...
>   
>   formula<-as.formula(sex~age+measure)
>   
>   #And finally we run the imputation function:
>   
>   imp<-jomo.glm(formula,data, nburn=10, nbetween=10, nimp=2)
This function is beta software. Use carefully and please report any bug to the package mantainer
.First imputation registered. 
.Imputation number  2 registered 
The posterior mean of the substantive model fixed effects estimates is:
    (Intercept)          age   measure
sex  -0.1511536 0.0006110846 0.1537506
The posterior mean of the substantive model residual variance is:
[1] 1
>   
>   # Note we are using only 10 iterations to avoid time consuming examples, 
>   # which go against CRAN policies. In real applications we would use
>   # much larger burn-ins (around 1000) and at least 5 imputations.
>   # Check help page for function jomo to see how to fit the model and 
>   # combine estimates with Rubin's rules
> 
>   
> 
> 
> 
> cleanEx()
> nameEx("jomo.glmer.MCMCchain")
> ### * jomo.glmer.MCMCchain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo.glmer.MCMCchain
> ### Title: glmer Compatible JM Imputation - A tool to check convergence of
> ###   the MCMC
> ### Aliases: jomo.glmer.MCMCchain
> 
> ### ** Examples
> 
> 
>   # make sure sex is a factor:
>   
>   cldata<-within(cldata, sex<-factor(sex))
>   
>   # we define the data frame with all the variables 
>   
>   data<-cldata[,c("measure","age", "sex", "city")]
>   
>   # And the formula of the substantive lm model 
>   # sex as an outcome only because it is the only binary variable in the dataset...
>   
>   formula<-as.formula(sex~age+measure+(1|city))
>   
>   #And finally we run the imputation function:
>   
>   imp<-jomo.glmer.MCMCchain(formula,data, nburn=100)
This function is beta software. Please use carefully and report any bug to the package mantainer
Error in initializePtr() : 
  function 'cholmod_factor_ldetA' not provided by package 'Matrix'
Calls: jomo.glmer.MCMCchain ... initialize -> <Anonymous> -> initializePtr -> .Call
Execution halted
