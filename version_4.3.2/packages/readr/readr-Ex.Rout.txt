
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "readr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('readr')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Tokenizers")
> ### * Tokenizers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Tokenizers
> ### Title: Tokenizers.
> ### Aliases: Tokenizers tokenizer_delim tokenizer_csv tokenizer_tsv
> ###   tokenizer_line tokenizer_log tokenizer_fwf tokenizer_ws
> ### Keywords: internal
> 
> ### ** Examples
> 
> tokenizer_csv()
$delim
[1] ","

$quote
[1] "\""

$na
[1] "NA"

$quoted_na
[1] TRUE

$comment
[1] ""

$trim_ws
[1] TRUE

$escape_double
[1] TRUE

$escape_backslash
[1] FALSE

$skip_empty_rows
[1] TRUE

attr(,"class")
[1] "tokenizer_delim"
> 
> 
> 
> cleanEx()
> nameEx("as.col_spec")
> ### * as.col_spec
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.col_spec
> ### Title: Generate a column specification
> ### Aliases: as.col_spec
> ### Keywords: internal
> 
> ### ** Examples
> 
> as.col_spec("cccnnn")
cols(
  col_character(),
  col_character(),
  col_character(),
  col_number(),
  col_number(),
  col_number()
)
> 
> 
> 
> cleanEx()
> nameEx("callback")
> ### * callback
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: callback
> ### Title: Callback classes
> ### Aliases: callback ChunkCallback SideEffectChunkCallback
> ###   DataFrameCallback ListCallback AccumulateCallback
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## If given a regular function it is converted to a SideEffectChunkCallback
> 
> # view structure of each chunk
> read_lines_chunked(readr_example("mtcars.csv"), str, chunk_size = 5)
 chr [1:5] "\"mpg\",\"cyl\",\"disp\",\"hp\",\"drat\",\"wt\",\"qsec\",\"vs\",\"am\",\"gear\",\"carb\"" ...
 chr [1:5] "18.7,8,360,175,3.15,3.44,17.02,0,0,3,2" ...
 chr [1:5] "19.2,6,167.6,123,3.92,3.44,18.3,1,0,4,4" ...
 chr [1:5] "10.4,8,472,205,2.93,5.25,17.98,0,0,3,4" ...
 chr [1:5] "33.9,4,71.1,65,4.22,1.835,19.9,1,1,4,1" ...
 chr [1:5] "19.2,8,400,175,3.08,3.845,17.05,0,0,3,2" ...
 chr [1:3] "19.7,6,145,175,3.62,2.77,15.5,0,1,5,6" ...
NULL
> 
> # Print starting line of each chunk
> f <- function(x, pos) print(pos)
> read_lines_chunked(readr_example("mtcars.csv"), SideEffectChunkCallback$new(f), chunk_size = 5)
[1] 1
[1] 6
[1] 11
[1] 16
[1] 21
[1] 26
[1] 31
NULL
> 
> # If combined results are desired you can use the DataFrameCallback
> 
> # Cars with 3 gears
> f <- function(x, pos) subset(x, gear == 3)
> read_csv_chunked(readr_example("mtcars.csv"), DataFrameCallback$new(f), chunk_size = 5)

── Column specification ────────────────────────────────────────────────────────
cols(
  mpg = col_double(),
  cyl = col_double(),
  disp = col_double(),
  hp = col_double(),
  drat = col_double(),
  wt = col_double(),
  qsec = col_double(),
  vs = col_double(),
  am = col_double(),
  gear = col_double(),
  carb = col_double()
)

# A tibble: 15 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 2  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 3  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 4  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 5  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3
 6  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3
 7  15.2     8  276.   180  3.07  3.78  18       0     0     3     3
 8  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
 9  10.4     8  460    215  3     5.42  17.8     0     0     3     4
10  14.7     8  440    230  3.23  5.34  17.4     0     0     3     4
11  21.5     4  120.    97  3.7   2.46  20.0     1     0     3     1
12  15.5     8  318    150  2.76  3.52  16.9     0     0     3     2
13  15.2     8  304    150  3.15  3.44  17.3     0     0     3     2
14  13.3     8  350    245  3.73  3.84  15.4     0     0     3     4
15  19.2     8  400    175  3.08  3.84  17.0     0     0     3     2
> 
> # The ListCallback can be used for more flexible output
> f <- function(x, pos) x$mpg[x$hp > 100]
> read_csv_chunked(readr_example("mtcars.csv"), ListCallback$new(f), chunk_size = 5)

── Column specification ────────────────────────────────────────────────────────
cols(
  mpg = col_double(),
  cyl = col_double(),
  disp = col_double(),
  hp = col_double(),
  drat = col_double(),
  wt = col_double(),
  qsec = col_double(),
  vs = col_double(),
  am = col_double(),
  gear = col_double(),
  carb = col_double()
)

[[1]]
[1] 21.0 21.0 21.4 18.7

[[2]]
[1] 18.1 14.3 19.2

[[3]]
[1] 17.8 16.4 17.3 15.2 10.4

[[4]]
[1] 10.4 14.7

[[5]]
[1] 15.5 15.2 13.3 19.2

[[6]]
[1] 30.4 15.8 19.7

[[7]]
[1] 15.0 21.4

> 
> # The AccumulateCallback accumulates results from each chunk
> f <- function(x, pos, acc) sum(x$mpg) + acc
> read_csv_chunked(readr_example("mtcars.csv"), AccumulateCallback$new(f, acc = 0), chunk_size = 5)

── Column specification ────────────────────────────────────────────────────────
cols(
  mpg = col_double(),
  cyl = col_double(),
  disp = col_double(),
  hp = col_double(),
  drat = col_double(),
  wt = col_double(),
  qsec = col_double(),
  vs = col_double(),
  am = col_double(),
  gear = col_double(),
  carb = col_double()
)

[1] 642.9
> 
> 
> 
> cleanEx()
> nameEx("cols")
> ### * cols
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cols
> ### Title: Create column specification
> ### Aliases: cols cols_only
> 
> ### ** Examples
> 
> cols(a = col_integer())
cols(
  a = col_integer()
)
> cols_only(a = col_integer())
cols_only(
  a = col_integer()
)
> 
> # You can also use the standard abbreviations
> cols(a = "i")
cols(
  a = col_integer()
)
> cols(a = "i", b = "d", c = "_")
cols(
  a = col_integer(),
  b = col_double(),
  c = col_skip()
)
> 
> # You can also use multiple sets of column definitions by combining
> # them like so:
> 
> t1 <- cols(
+   column_one = col_integer(),
+   column_two = col_number()
+ )
> 
> t2 <- cols(
+   column_three = col_character()
+ )
> 
> t3 <- t1
> t3$cols <- c(t1$cols, t2$cols)
> t3
cols(
  column_one = col_integer(),
  column_two = col_number(),
  column_three = col_character()
)
> 
> 
> 
> cleanEx()
> nameEx("count_fields")
> ### * count_fields
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: count_fields
> ### Title: Count the number of fields in each line of a file
> ### Aliases: count_fields
> 
> ### ** Examples
> 
> count_fields(readr_example("mtcars.csv"), tokenizer_csv())
 [1] 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11
[26] 11 11 11 11 11 11 11 11
> 
> 
> 
> cleanEx()
> nameEx("datasource")
> ### * datasource
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: datasource
> ### Title: Create a source object.
> ### Aliases: datasource
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Literal csv
> datasource("a,b,c\n1,2,3")
[[1]]
[1] "a,b,c\n1,2,3"

$skip
[1] 0

$skip_empty_rows
[1] FALSE

$comment
[1] ""

$skip_quote
[1] TRUE

attr(,"class")
[1] "source_string" "source"       
> datasource(charToRaw("a,b,c\n1,2,3"))
[[1]]
 [1] 61 2c 62 2c 63 0a 31 2c 32 2c 33

$skip
[1] 0

$skip_empty_rows
[1] FALSE

$comment
[1] ""

$skip_quote
[1] TRUE

attr(,"class")
[1] "source_raw" "source"    
> 
> # Strings
> datasource(readr_example("mtcars.csv"))
[[1]]
[1] "/usr/local/lib/R/site-library/readr/extdata/mtcars.csv"

$skip
[1] 0

$skip_empty_rows
[1] FALSE

$comment
[1] ""

$skip_quote
[1] TRUE

attr(,"class")
[1] "source_file" "source"     
> datasource(readr_example("mtcars.csv.bz2"))
[[1]]
[1] "/tmp/Rtmp3LOKyL/file1ce754a1bb539"

$skip
[1] 0

$skip_empty_rows
[1] FALSE

$comment
[1] ""

$skip_quote
[1] TRUE

$env
<environment: 0x5580678f7800>

attr(,"class")
[1] "source_file" "source"     
> datasource(readr_example("mtcars.csv.zip"))
[[1]]
[1] "/tmp/Rtmp3LOKyL/file1ce75365c2f4"

$skip
[1] 0

$skip_empty_rows
[1] FALSE

$comment
[1] ""

$skip_quote
[1] TRUE

$env
<environment: 0x55806794a808>

attr(,"class")
[1] "source_file" "source"     
> ## Not run: 
> ##D datasource("https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv")
> ## End(Not run)
> 
> # Connection
> con <- rawConnection(charToRaw("abc\n123"))
> datasource(con)
[[1]]
[1] "/tmp/Rtmp3LOKyL/file1ce7563653bac"

$skip
[1] 0

$skip_empty_rows
[1] FALSE

$comment
[1] ""

$skip_quote
[1] TRUE

$env
<environment: 0x5580679555a8>

attr(,"class")
[1] "source_file" "source"     
> close(con)
> 
> 
> 
> cleanEx()
> nameEx("date_names")
> ### * date_names
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: date_names
> ### Title: Create or retrieve date names
> ### Aliases: date_names date_names_lang date_names_langs
> 
> ### ** Examples
> 
> date_names_lang("en")
<date_names>
Days:   Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday
        (Thu), Friday (Fri), Saturday (Sat)
Months: January (Jan), February (Feb), March (Mar), April (Apr), May (May),
        June (Jun), July (Jul), August (Aug), September (Sep), October
        (Oct), November (Nov), December (Dec)
AM/PM:  AM/PM
> date_names_lang("ko")
<date_names>
Days:   일요일 (일), 월요일 (월), 화요일 (화), 수요일 (수), 목요일 (목), 금요일
        (금), 토요일 (토)
Months: 1월, 2월, 3월, 4월, 5월, 6월, 7월, 8월, 9월, 10월, 11월, 12월
AM/PM:  오전/오후
> date_names_lang("fr")
<date_names>
Days:   dimanche (dim.), lundi (lun.), mardi (mar.), mercredi (mer.), jeudi
        (jeu.), vendredi (ven.), samedi (sam.)
Months: janvier (janv.), février (févr.), mars (mars), avril (avr.), mai (mai),
        juin (juin), juillet (juil.), août (août), septembre (sept.),
        octobre (oct.), novembre (nov.), décembre (déc.)
AM/PM:  AM/PM
> 
> 
> 
> cleanEx()
> nameEx("edition_get")
> ### * edition_get
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edition_get
> ### Title: Retrieve the currently active edition
> ### Aliases: edition_get
> 
> ### ** Examples
> 
> edition_get()
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("encoding")
> ### * encoding
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guess_encoding
> ### Title: Guess encoding of file
> ### Aliases: guess_encoding
> 
> ### ** Examples
> 
> guess_encoding(readr_example("mtcars.csv"))
# A tibble: 1 × 2
  encoding confidence
  <chr>         <dbl>
1 ASCII             1
> guess_encoding(read_lines_raw(readr_example("mtcars.csv")))
# A tibble: 1 × 2
  encoding confidence
  <chr>         <dbl>
1 ASCII             1
> guess_encoding(read_file_raw(readr_example("mtcars.csv")))
# A tibble: 1 × 2
  encoding confidence
  <chr>         <dbl>
1 ASCII             1
> 
> guess_encoding("a\n\u00b5\u00b5")
# A tibble: 1 × 2
  encoding confidence
  <chr>         <dbl>
1 UTF-8           0.8
> 
> 
> 
> cleanEx()
> nameEx("format_delim")
> ### * format_delim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format_delim
> ### Title: Convert a data frame to a delimited string
> ### Aliases: format_delim format_csv format_csv2 format_tsv
> 
> ### ** Examples
> 
> # format_()* functions are useful for testing and reprexes
> cat(format_csv(mtcars))
mpg,cyl,disp,hp,drat,wt,qsec,vs,am,gear,carb
21,6,160,110,3.9,2.62,16.46,0,1,4,4
21,6,160,110,3.9,2.875,17.02,0,1,4,4
22.8,4,108,93,3.85,2.32,18.61,1,1,4,1
21.4,6,258,110,3.08,3.215,19.44,1,0,3,1
18.7,8,360,175,3.15,3.44,17.02,0,0,3,2
18.1,6,225,105,2.76,3.46,20.22,1,0,3,1
14.3,8,360,245,3.21,3.57,15.84,0,0,3,4
24.4,4,146.7,62,3.69,3.19,20,1,0,4,2
22.8,4,140.8,95,3.92,3.15,22.9,1,0,4,2
19.2,6,167.6,123,3.92,3.44,18.3,1,0,4,4
17.8,6,167.6,123,3.92,3.44,18.9,1,0,4,4
16.4,8,275.8,180,3.07,4.07,17.4,0,0,3,3
17.3,8,275.8,180,3.07,3.73,17.6,0,0,3,3
15.2,8,275.8,180,3.07,3.78,18,0,0,3,3
10.4,8,472,205,2.93,5.25,17.98,0,0,3,4
10.4,8,460,215,3,5.424,17.82,0,0,3,4
14.7,8,440,230,3.23,5.345,17.42,0,0,3,4
32.4,4,78.7,66,4.08,2.2,19.47,1,1,4,1
30.4,4,75.7,52,4.93,1.615,18.52,1,1,4,2
33.9,4,71.1,65,4.22,1.835,19.9,1,1,4,1
21.5,4,120.1,97,3.7,2.465,20.01,1,0,3,1
15.5,8,318,150,2.76,3.52,16.87,0,0,3,2
15.2,8,304,150,3.15,3.435,17.3,0,0,3,2
13.3,8,350,245,3.73,3.84,15.41,0,0,3,4
19.2,8,400,175,3.08,3.845,17.05,0,0,3,2
27.3,4,79,66,4.08,1.935,18.9,1,1,4,1
26,4,120.3,91,4.43,2.14,16.7,0,1,5,2
30.4,4,95.1,113,3.77,1.513,16.9,1,1,5,2
15.8,8,351,264,4.22,3.17,14.5,0,1,5,4
19.7,6,145,175,3.62,2.77,15.5,0,1,5,6
15,8,301,335,3.54,3.57,14.6,0,1,5,8
21.4,4,121,109,4.11,2.78,18.6,1,1,4,2
> cat(format_tsv(mtcars))
mpg	cyl	disp	hp	drat	wt	qsec	vs	am	gear	carb
21	6	160	110	3.9	2.62	16.46	0	1	4	4
21	6	160	110	3.9	2.875	17.02	0	1	4	4
22.8	4	108	93	3.85	2.32	18.61	1	1	4	1
21.4	6	258	110	3.08	3.215	19.44	1	0	3	1
18.7	8	360	175	3.15	3.44	17.02	0	0	3	2
18.1	6	225	105	2.76	3.46	20.22	1	0	3	1
14.3	8	360	245	3.21	3.57	15.84	0	0	3	4
24.4	4	146.7	62	3.69	3.19	20	1	0	4	2
22.8	4	140.8	95	3.92	3.15	22.9	1	0	4	2
19.2	6	167.6	123	3.92	3.44	18.3	1	0	4	4
17.8	6	167.6	123	3.92	3.44	18.9	1	0	4	4
16.4	8	275.8	180	3.07	4.07	17.4	0	0	3	3
17.3	8	275.8	180	3.07	3.73	17.6	0	0	3	3
15.2	8	275.8	180	3.07	3.78	18	0	0	3	3
10.4	8	472	205	2.93	5.25	17.98	0	0	3	4
10.4	8	460	215	3	5.424	17.82	0	0	3	4
14.7	8	440	230	3.23	5.345	17.42	0	0	3	4
32.4	4	78.7	66	4.08	2.2	19.47	1	1	4	1
30.4	4	75.7	52	4.93	1.615	18.52	1	1	4	2
33.9	4	71.1	65	4.22	1.835	19.9	1	1	4	1
21.5	4	120.1	97	3.7	2.465	20.01	1	0	3	1
15.5	8	318	150	2.76	3.52	16.87	0	0	3	2
15.2	8	304	150	3.15	3.435	17.3	0	0	3	2
13.3	8	350	245	3.73	3.84	15.41	0	0	3	4
19.2	8	400	175	3.08	3.845	17.05	0	0	3	2
27.3	4	79	66	4.08	1.935	18.9	1	1	4	1
26	4	120.3	91	4.43	2.14	16.7	0	1	5	2
30.4	4	95.1	113	3.77	1.513	16.9	1	1	5	2
15.8	8	351	264	4.22	3.17	14.5	0	1	5	4
19.7	6	145	175	3.62	2.77	15.5	0	1	5	6
15	8	301	335	3.54	3.57	14.6	0	1	5	8
21.4	4	121	109	4.11	2.78	18.6	1	1	4	2
> cat(format_delim(mtcars, ";"))
mpg;cyl;disp;hp;drat;wt;qsec;vs;am;gear;carb
21;6;160;110;3.9;2.62;16.46;0;1;4;4
21;6;160;110;3.9;2.875;17.02;0;1;4;4
22.8;4;108;93;3.85;2.32;18.61;1;1;4;1
21.4;6;258;110;3.08;3.215;19.44;1;0;3;1
18.7;8;360;175;3.15;3.44;17.02;0;0;3;2
18.1;6;225;105;2.76;3.46;20.22;1;0;3;1
14.3;8;360;245;3.21;3.57;15.84;0;0;3;4
24.4;4;146.7;62;3.69;3.19;20;1;0;4;2
22.8;4;140.8;95;3.92;3.15;22.9;1;0;4;2
19.2;6;167.6;123;3.92;3.44;18.3;1;0;4;4
17.8;6;167.6;123;3.92;3.44;18.9;1;0;4;4
16.4;8;275.8;180;3.07;4.07;17.4;0;0;3;3
17.3;8;275.8;180;3.07;3.73;17.6;0;0;3;3
15.2;8;275.8;180;3.07;3.78;18;0;0;3;3
10.4;8;472;205;2.93;5.25;17.98;0;0;3;4
10.4;8;460;215;3;5.424;17.82;0;0;3;4
14.7;8;440;230;3.23;5.345;17.42;0;0;3;4
32.4;4;78.7;66;4.08;2.2;19.47;1;1;4;1
30.4;4;75.7;52;4.93;1.615;18.52;1;1;4;2
33.9;4;71.1;65;4.22;1.835;19.9;1;1;4;1
21.5;4;120.1;97;3.7;2.465;20.01;1;0;3;1
15.5;8;318;150;2.76;3.52;16.87;0;0;3;2
15.2;8;304;150;3.15;3.435;17.3;0;0;3;2
13.3;8;350;245;3.73;3.84;15.41;0;0;3;4
19.2;8;400;175;3.08;3.845;17.05;0;0;3;2
27.3;4;79;66;4.08;1.935;18.9;1;1;4;1
26;4;120.3;91;4.43;2.14;16.7;0;1;5;2
30.4;4;95.1;113;3.77;1.513;16.9;1;1;5;2
15.8;8;351;264;4.22;3.17;14.5;0;1;5;4
19.7;6;145;175;3.62;2.77;15.5;0;1;5;6
15;8;301;335;3.54;3.57;14.6;0;1;5;8
21.4;4;121;109;4.11;2.78;18.6;1;1;4;2
> 
> # Specifying missing values
> df <- data.frame(x = c(1, NA, 3))
> format_csv(df, na = "missing")
[1] "x\n1\nmissing\n3\n"
> 
> # Quotes are automatically added as needed
> df <- data.frame(x = c("a ", '"', ",", "\n"))
> cat(format_csv(df))
x
a 
""""
","
"
"
> 
> 
> 
> cleanEx()
> nameEx("locale")
> ### * locale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: locale
> ### Title: Create locales
> ### Aliases: locale default_locale
> 
> ### ** Examples
> 
> locale()
<locale>
Numbers:  123,456.78
Formats:  %AD / %AT
Timezone: UTC
Encoding: UTF-8
<date_names>
Days:   Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday
        (Thu), Friday (Fri), Saturday (Sat)
Months: January (Jan), February (Feb), March (Mar), April (Apr), May (May),
        June (Jun), July (Jul), August (Aug), September (Sep), October
        (Oct), November (Nov), December (Dec)
AM/PM:  AM/PM
> locale("fr")
<locale>
Numbers:  123,456.78
Formats:  %AD / %AT
Timezone: UTC
Encoding: UTF-8
<date_names>
Days:   dimanche (dim.), lundi (lun.), mardi (mar.), mercredi (mer.), jeudi
        (jeu.), vendredi (ven.), samedi (sam.)
Months: janvier (janv.), février (févr.), mars (mars), avril (avr.), mai (mai),
        juin (juin), juillet (juil.), août (août), septembre (sept.),
        octobre (oct.), novembre (nov.), décembre (déc.)
AM/PM:  AM/PM
> 
> # South American locale
> locale("es", decimal_mark = ",")
<locale>
Numbers:  123.456,78
Formats:  %AD / %AT
Timezone: UTC
Encoding: UTF-8
<date_names>
Days:   domingo (dom.), lunes (lun.), martes (mar.), miércoles (mié.), jueves
        (jue.), viernes (vie.), sábado (sáb.)
Months: enero (ene.), febrero (feb.), marzo (mar.), abril (abr.), mayo (may.),
        junio (jun.), julio (jul.), agosto (ago.), septiembre (sept.),
        octubre (oct.), noviembre (nov.), diciembre (dic.)
AM/PM:  a. m./p. m.
> 
> 
> 
> cleanEx()
> nameEx("melt_delim")
> ### * melt_delim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: melt_delim
> ### Title: Return melted data for each token in a delimited file (including
> ###   csv & tsv)
> ### Aliases: melt_delim melt_csv melt_csv2 melt_tsv
> 
> ### ** Examples
> 
> # Input sources -------------------------------------------------------------
> # Read from a path
> melt_csv(readr_example("mtcars.csv"))
Warning: `melt_csv()` was deprecated in readr 2.0.0.
ℹ Please use `meltr::melt_csv()` instead
# A tibble: 363 × 4
     row   col data_type value
   <dbl> <dbl> <chr>     <chr>
 1     1     1 character mpg  
 2     1     2 character cyl  
 3     1     3 character disp 
 4     1     4 character hp   
 5     1     5 character drat 
 6     1     6 character wt   
 7     1     7 character qsec 
 8     1     8 character vs   
 9     1     9 character am   
10     1    10 character gear 
# ℹ 353 more rows
> melt_csv(readr_example("mtcars.csv.zip"))
# A tibble: 363 × 4
     row   col data_type value
   <dbl> <dbl> <chr>     <chr>
 1     1     1 character mpg  
 2     1     2 character cyl  
 3     1     3 character disp 
 4     1     4 character hp   
 5     1     5 character drat 
 6     1     6 character wt   
 7     1     7 character qsec 
 8     1     8 character vs   
 9     1     9 character am   
10     1    10 character gear 
# ℹ 353 more rows
> melt_csv(readr_example("mtcars.csv.bz2"))
# A tibble: 363 × 4
     row   col data_type value
   <dbl> <dbl> <chr>     <chr>
 1     1     1 character mpg  
 2     1     2 character cyl  
 3     1     3 character disp 
 4     1     4 character hp   
 5     1     5 character drat 
 6     1     6 character wt   
 7     1     7 character qsec 
 8     1     8 character vs   
 9     1     9 character am   
10     1    10 character gear 
# ℹ 353 more rows
> ## Not run: 
> ##D melt_csv("https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv")
> ## End(Not run)
> 
> # Or directly from a string (must contain a newline)
> melt_csv("x,y\n1,2\n3,4")
# A tibble: 6 × 4
    row   col data_type value
  <dbl> <dbl> <chr>     <chr>
1     1     1 character x    
2     1     2 character y    
3     2     1 integer   1    
4     2     2 integer   2    
5     3     1 integer   3    
6     3     2 integer   4    
> 
> # To import empty cells as 'empty' rather than `NA`
> melt_csv("x,y\n,NA,\"\",''", na = "NA")
# A tibble: 6 × 4
    row   col data_type value
  <dbl> <dbl> <chr>     <chr>
1     1     1 character "x"  
2     1     2 character "y"  
3     2     1 empty     ""   
4     2     2 missing   <NA> 
5     2     3 empty     ""   
6     2     4 character "''" 
> 
> # File types ----------------------------------------------------------------
> melt_csv("a,b\n1.0,2.0")
# A tibble: 4 × 4
    row   col data_type value
  <dbl> <dbl> <chr>     <chr>
1     1     1 character a    
2     1     2 character b    
3     2     1 double    1.0  
4     2     2 double    2.0  
> melt_csv2("a;b\n1,0;2,0")
Warning: `melt_csv2()` was deprecated in readr 2.0.0.
ℹ Please use `meltr::melt_csv2()` instead
ℹ Using "','" as decimal and "'.'" as grouping mark. Use `read_delim()` for more control.
# A tibble: 4 × 4
    row   col data_type value
  <dbl> <dbl> <chr>     <chr>
1     1     1 character a    
2     1     2 character b    
3     2     1 double    1,0  
4     2     2 double    2,0  
> melt_tsv("a\tb\n1.0\t2.0")
Warning: `melt_tsv()` was deprecated in readr 2.0.0.
ℹ Please use `meltr::melt_tsv()` instead
# A tibble: 4 × 4
    row   col data_type value
  <dbl> <dbl> <chr>     <chr>
1     1     1 character a    
2     1     2 character b    
3     2     1 double    1.0  
4     2     2 double    2.0  
> melt_delim("a|b\n1.0|2.0", delim = "|")
Warning: `melt_delim()` was deprecated in readr 2.0.0.
ℹ Please use `meltr::melt_delim()` instead
# A tibble: 4 × 4
    row   col data_type value
  <dbl> <dbl> <chr>     <chr>
1     1     1 character a    
2     1     2 character b    
3     2     1 double    1.0  
4     2     2 double    2.0  
> 
> 
> 
> cleanEx()
> nameEx("melt_delim_chunked")
> ### * melt_delim_chunked
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: melt_delim_chunked
> ### Title: Melt a delimited file by chunks
> ### Aliases: melt_delim_chunked melt_csv_chunked melt_csv2_chunked
> ###   melt_tsv_chunked
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Cars with 3 gears
> f <- function(x, pos) subset(x, data_type == "integer")
> melt_csv_chunked(readr_example("mtcars.csv"), DataFrameCallback$new(f), chunk_size = 5)
# A tibble: 218 × 4
     row   col data_type value
   <dbl> <dbl> <chr>     <chr>
 1     2     1 integer   21   
 2     2     2 integer   6    
 3     2     3 integer   160  
 4     2     4 integer   110  
 5     2     8 integer   0    
 6     2     9 integer   1    
 7     2    10 integer   4    
 8     2    11 integer   4    
 9     3     1 integer   21   
10     3     2 integer   6    
# ℹ 208 more rows
> 
> 
> 
> cleanEx()
> nameEx("melt_fwf")
> ### * melt_fwf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: melt_fwf
> ### Title: Return melted data for each token in a fixed width file
> ### Aliases: melt_fwf
> 
> ### ** Examples
> 
> fwf_sample <- readr_example("fwf-sample.txt")
> cat(read_lines(fwf_sample))
John Smith          WA        418-Y11-4111 Mary Hartford       CA        319-Z19-4341 Evan Nolan          IL        219-532-c301> 
> # You can specify column positions in several ways:
> # 1. Guess based on position of empty columns
> melt_fwf(fwf_sample, fwf_empty(fwf_sample, col_names = c("first", "last", "state", "ssn")))
Warning: `melt_fwf()` was deprecated in readr 2.0.0.
ℹ Please use `meltr::melt_fwf()` instead
# A tibble: 12 × 4
     row   col data_type value       
   <dbl> <dbl> <chr>     <chr>       
 1     1     1 character John        
 2     1     2 character Smith       
 3     1     3 character WA          
 4     1     4 character 418-Y11-4111
 5     2     1 character Mary        
 6     2     2 character Hartford    
 7     2     3 character CA          
 8     2     4 character 319-Z19-4341
 9     3     1 character Evan        
10     3     2 character Nolan       
11     3     3 character IL          
12     3     4 character 219-532-c301
> # 2. A vector of field widths
> melt_fwf(fwf_sample, fwf_widths(c(20, 10, 12), c("name", "state", "ssn")))
# A tibble: 9 × 4
    row   col data_type value        
  <dbl> <dbl> <chr>     <chr>        
1     1     1 character John Smith   
2     1     2 character WA           
3     1     3 character 418-Y11-4111 
4     2     1 character Mary Hartford
5     2     2 character CA           
6     2     3 character 319-Z19-4341 
7     3     1 character Evan Nolan   
8     3     2 character IL           
9     3     3 character 219-532-c301 
> # 3. Paired vectors of start and end positions
> melt_fwf(fwf_sample, fwf_positions(c(1, 30), c(10, 42), c("name", "ssn")))
# A tibble: 6 × 4
    row   col data_type value       
  <dbl> <dbl> <chr>     <chr>       
1     1     1 character John Smith  
2     1     2 character 418-Y11-4111
3     2     1 character Mary Hartf  
4     2     2 character 319-Z19-4341
5     3     1 character Evan Nolan  
6     3     2 character 219-532-c301
> # 4. Named arguments with start and end positions
> melt_fwf(fwf_sample, fwf_cols(name = c(1, 10), ssn = c(30, 42)))
# A tibble: 6 × 4
    row   col data_type value       
  <dbl> <dbl> <chr>     <chr>       
1     1     1 character John Smith  
2     1     2 character 418-Y11-4111
3     2     1 character Mary Hartf  
4     2     2 character 319-Z19-4341
5     3     1 character Evan Nolan  
6     3     2 character 219-532-c301
> # 5. Named arguments with column widths
> melt_fwf(fwf_sample, fwf_cols(name = 20, state = 10, ssn = 12))
# A tibble: 9 × 4
    row   col data_type value        
  <dbl> <dbl> <chr>     <chr>        
1     1     1 character John Smith   
2     1     2 character WA           
3     1     3 character 418-Y11-4111 
4     2     1 character Mary Hartford
5     2     2 character CA           
6     2     3 character 319-Z19-4341 
7     3     1 character Evan Nolan   
8     3     2 character IL           
9     3     3 character 219-532-c301 
> 
> 
> 
> cleanEx()
> nameEx("melt_table")
> ### * melt_table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: melt_table
> ### Title: Return melted data for each token in a whitespace-separated file
> ### Aliases: melt_table melt_table2
> 
> ### ** Examples
> 
> fwf <- readr_example("fwf-sample.txt")
> writeLines(read_lines(fwf))
John Smith          WA        418-Y11-4111
Mary Hartford       CA        319-Z19-4341
Evan Nolan          IL        219-532-c301
> melt_table(fwf)
Warning: `melt_table()` was deprecated in readr 2.0.0.
ℹ Please use `meltr::melt_table()` instead
# A tibble: 12 × 4
     row   col data_type value       
   <dbl> <dbl> <chr>     <chr>       
 1     1     1 character John        
 2     1     2 character Smith       
 3     1     3 character WA          
 4     1     4 character 418-Y11-4111
 5     2     1 character Mary        
 6     2     2 character Hartford    
 7     2     3 character CA          
 8     2     4 character 319-Z19-4341
 9     3     1 character Evan        
10     3     2 character Nolan       
11     3     3 character IL          
12     3     4 character 219-532-c301
> 
> ws <- readr_example("whitespace-sample.txt")
> writeLines(read_lines(ws))
first last state phone
John Smith WA 418-Y11-4111
Mary Hartford CA 319-Z19-4341
Evan Nolan IL 219-532-c301
> melt_table2(ws)
Warning: `melt_table2()` was deprecated in readr 2.0.0.
ℹ Please use `meltr::melt_table2()` instead
# A tibble: 16 × 4
     row   col data_type value       
   <dbl> <dbl> <chr>     <chr>       
 1     1     1 character first       
 2     1     2 character last        
 3     1     3 character state       
 4     1     4 character phone       
 5     2     1 character John        
 6     2     2 character Smith       
 7     2     3 character WA          
 8     2     4 character 418-Y11-4111
 9     3     1 character Mary        
10     3     2 character Hartford    
11     3     3 character CA          
12     3     4 character 319-Z19-4341
13     4     1 character Evan        
14     4     2 character Nolan       
15     4     3 character IL          
16     4     4 character 219-532-c301
> 
> 
> 
> cleanEx()
> nameEx("output_column")
> ### * output_column
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: output_column
> ### Title: Preprocess column for output
> ### Aliases: output_column
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Most columns are not altered, but POSIXct are converted to ISO8601.
> x <- parse_datetime("2016-01-01")
> str(output_column(x))
 chr "2016-01-01T00:00:00Z"
> 
> 
> 
> cleanEx()
> nameEx("parse_atomic")
> ### * parse_atomic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_atomic
> ### Title: Parse logicals, integers, and reals
> ### Aliases: parse_logical parse_integer parse_double parse_character
> ###   col_logical col_integer col_double col_character
> 
> ### ** Examples
> 
> parse_integer(c("1", "2", "3"))
[1] 1 2 3
> parse_double(c("1", "2", "3.123"))
[1] 1.000 2.000 3.123
> parse_number("$1,123,456.00")
[1] 1123456
> 
> # Use locale to override default decimal and grouping marks
> es_MX <- locale("es", decimal_mark = ",")
> parse_number("$1.123.456,00", locale = es_MX)
[1] 1123456
> 
> # Invalid values are replaced with missing values with a warning.
> x <- c("1", "2", "3", "-")
> parse_double(x)
Warning: 1 parsing failure.
row col expected actual
  4  -- a double      -

[1]  1  2  3 NA
attr(,"problems")
# A tibble: 1 × 4
    row   col expected actual
  <int> <int> <chr>    <chr> 
1     4    NA a double -     
> # Or flag values as missing
> parse_double(x, na = "-")
[1]  1  2  3 NA
> 
> 
> 
> cleanEx()
> nameEx("parse_datetime")
> ### * parse_datetime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_datetime
> ### Title: Parse date/times
> ### Aliases: parse_datetime parse_date parse_time col_datetime col_date
> ###   col_time
> 
> ### ** Examples
> 
> # Format strings --------------------------------------------------------
> parse_datetime("01/02/2010", "%d/%m/%Y")
[1] "2010-02-01 UTC"
> parse_datetime("01/02/2010", "%m/%d/%Y")
[1] "2010-01-02 UTC"
> # Handle any separator
> parse_datetime("01/02/2010", "%m%.%d%.%Y")
[1] "2010-01-02 UTC"
> 
> # Dates look the same, but internally they use the number of days since
> # 1970-01-01 instead of the number of seconds. This avoids a whole lot
> # of troubles related to time zones, so use if you can.
> parse_date("01/02/2010", "%d/%m/%Y")
[1] "2010-02-01"
> parse_date("01/02/2010", "%m/%d/%Y")
[1] "2010-01-02"
> 
> # You can parse timezones from strings (as listed in OlsonNames())
> parse_datetime("2010/01/01 12:00 US/Central", "%Y/%m/%d %H:%M %Z")
[1] "2010-01-01 18:00:00 UTC"
> # Or from offsets
> parse_datetime("2010/01/01 12:00 -0600", "%Y/%m/%d %H:%M %z")
[1] "2010-01-01 18:00:00 UTC"
> 
> # Use the locale parameter to control the default time zone
> # (but note UTC is considerably faster than other options)
> parse_datetime("2010/01/01 12:00", "%Y/%m/%d %H:%M",
+   locale = locale(tz = "US/Central")
+ )
[1] "2010-01-01 12:00:00 CST"
> parse_datetime("2010/01/01 12:00", "%Y/%m/%d %H:%M",
+   locale = locale(tz = "US/Eastern")
+ )
[1] "2010-01-01 12:00:00 EST"
> 
> # Unlike strptime, the format specification must match the complete
> # string (ignoring leading and trailing whitespace). This avoids common
> # errors:
> strptime("01/02/2010", "%d/%m/%y")
[1] "2020-02-01 UTC"
> parse_datetime("01/02/2010", "%d/%m/%y")
Warning: 1 parsing failure.
row col           expected     actual
  1  -- date like %d/%m/%y 01/02/2010

[1] NA
> 
> # Failures -------------------------------------------------------------
> parse_datetime("01/01/2010", "%d/%m/%Y")
[1] "2010-01-01 UTC"
> parse_datetime(c("01/ab/2010", "32/01/2010"), "%d/%m/%Y")
Warning: 2 parsing failures.
row col           expected     actual
  1  -- date like %d/%m/%Y 01/ab/2010
  2  -- valid date         32/01/2010

[1] NA NA
> 
> # Locales --------------------------------------------------------------
> # By default, readr expects English date/times, but that's easy to change'
> parse_datetime("1 janvier 2015", "%d %B %Y", locale = locale("fr"))
[1] "2015-01-01 UTC"
> parse_datetime("1 enero 2015", "%d %B %Y", locale = locale("es"))
[1] "2015-01-01 UTC"
> 
> # ISO8601 --------------------------------------------------------------
> # With separators
> parse_datetime("1979-10-14")
[1] "1979-10-14 UTC"
> parse_datetime("1979-10-14T10")
[1] "1979-10-14 10:00:00 UTC"
> parse_datetime("1979-10-14T10:11")
[1] "1979-10-14 10:11:00 UTC"
> parse_datetime("1979-10-14T10:11:12")
[1] "1979-10-14 10:11:12 UTC"
> parse_datetime("1979-10-14T10:11:12.12345")
[1] "1979-10-14 10:11:12 UTC"
> 
> # Without separators
> parse_datetime("19791014")
[1] "1979-10-14 UTC"
> parse_datetime("19791014T101112")
[1] "1979-10-14 10:11:12 UTC"
> 
> # Time zones
> us_central <- locale(tz = "US/Central")
> parse_datetime("1979-10-14T1010", locale = us_central)
[1] "1979-10-14 10:10:00 CDT"
> parse_datetime("1979-10-14T1010-0500", locale = us_central)
[1] "1979-10-14 10:10:00 CDT"
> parse_datetime("1979-10-14T1010Z", locale = us_central)
[1] "1979-10-14 05:10:00 CDT"
> # Your current time zone
> parse_datetime("1979-10-14T1010", locale = locale(tz = ""))
[1] "1979-10-14 10:10:00 UTC"
> 
> 
> 
> cleanEx()
> nameEx("parse_factor")
> ### * parse_factor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_factor
> ### Title: Parse factors
> ### Aliases: parse_factor col_factor
> 
> ### ** Examples
> 
> # discover the levels from the data
> parse_factor(c("a", "b"))
[1] a b
Levels: a b
> parse_factor(c("a", "b", "-99"))
[1] a   b   -99
Levels: a b -99
> parse_factor(c("a", "b", "-99"), na = c("", "NA", "-99"))
[1] a    b    <NA>
Levels: a b <NA>
> parse_factor(c("a", "b", "-99"), na = c("", "NA", "-99"), include_na = FALSE)
[1] a    b    <NA>
Levels: a b
> 
> # provide the levels explicitly
> parse_factor(c("a", "b"), levels = letters[1:5])
[1] a b
Levels: a b c d e
> 
> x <- c("cat", "dog", "caw")
> animals <- c("cat", "dog", "cow")
> 
> # base::factor() silently converts elements that do not match any levels to
> # NA
> factor(x, levels = animals)
[1] cat  dog  <NA>
Levels: cat dog cow
> 
> # parse_factor() generates same factor as base::factor() but throws a warning
> # and reports problems
> parse_factor(x, levels = animals)
Warning: 1 parsing failure.
row col           expected actual
  3  -- value in level set    caw

[1] cat  dog  <NA>
attr(,"problems")
# A tibble: 1 × 4
    row   col expected           actual
  <int> <int> <chr>              <chr> 
1     3    NA value in level set caw   
Levels: cat dog cow
> 
> 
> 
> cleanEx()
> nameEx("parse_guess")
> ### * parse_guess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_guess
> ### Title: Parse using the "best" type
> ### Aliases: parse_guess col_guess guess_parser
> 
> ### ** Examples
> 
> # Logical vectors
> parse_guess(c("FALSE", "TRUE", "F", "T"))
[1] FALSE  TRUE FALSE  TRUE
> 
> # Integers and doubles
> parse_guess(c("1", "2", "3"))
[1] 1 2 3
> parse_guess(c("1.6", "2.6", "3.4"))
[1] 1.6 2.6 3.4
> 
> # Numbers containing grouping mark
> guess_parser("1,234,566")
[1] "number"
> parse_guess("1,234,566")
[1] 1234566
> 
> # ISO 8601 date times
> guess_parser(c("2010-10-10"))
[1] "date"
> parse_guess(c("2010-10-10"))
[1] "2010-10-10"
> 
> 
> 
> cleanEx()
> nameEx("parse_number")
> ### * parse_number
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_number
> ### Title: Parse numbers, flexibly
> ### Aliases: parse_number col_number
> 
> ### ** Examples
> 
> ## These all return 1000
> parse_number("$1,000") ## leading `$` and grouping character `,` ignored
[1] 1000
> parse_number("euro1,000") ## leading non-numeric euro ignored
[1] 1000
> parse_number("t1000t1000") ## only parses first number found
[1] 1000
> 
> parse_number("1,234.56")
[1] 1234.56
> ## explicit locale specifying European grouping and decimal marks
> parse_number("1.234,56", locale = locale(decimal_mark = ",", grouping_mark = "."))
[1] 1234.56
> ## SI/ISO 31-0 standard spaces for number grouping
> parse_number("1 234.56", locale = locale(decimal_mark = ".", grouping_mark = " "))
[1] 1234.56
> 
> ## Specifying strings for NAs
> parse_number(c("1", "2", "3", "NA"))
[1]  1  2  3 NA
> parse_number(c("1", "2", "3", "NA", "Nothing"), na = c("NA", "Nothing"))
[1]  1  2  3 NA NA
> 
> 
> 
> cleanEx()
> nameEx("parse_vector")
> ### * parse_vector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_vector
> ### Title: Parse a character vector.
> ### Aliases: parse_vector
> ### Keywords: internal
> 
> ### ** Examples
> 
> x <- c("1", "2", "3", "NA")
> parse_vector(x, col_integer())
[1]  1  2  3 NA
> parse_vector(x, col_double())
[1]  1  2  3 NA
> 
> 
> 
> cleanEx()
> nameEx("problems")
> ### * problems
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: problems
> ### Title: Retrieve parsing problems
> ### Aliases: problems stop_for_problems
> 
> ### ** Examples
> 
> x <- parse_integer(c("1X", "blah", "3"))
Warning: 2 parsing failures.
row col               expected actual
  1  -- no trailing characters   1X  
  2  -- no trailing characters   blah

> problems(x)
# A tibble: 2 × 4
    row   col expected               actual
  <int> <int> <chr>                  <chr> 
1     1    NA no trailing characters 1X    
2     2    NA no trailing characters blah  
> 
> y <- parse_integer(c("1", "2", "3"))
> problems(y)
> 
> 
> 
> cleanEx()
> nameEx("read_builtin")
> ### * read_builtin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_builtin
> ### Title: Read built-in object from package
> ### Aliases: read_builtin
> 
> ### ** Examples
> 
> read_builtin("mtcars", "datasets")
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> 
> 
> 
> cleanEx()
> nameEx("read_delim")
> ### * read_delim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_delim
> ### Title: Read a delimited file (including CSV and TSV) into a tibble
> ### Aliases: read_delim read_csv read_csv2 read_tsv
> 
> ### ** Examples
> 
> # Input sources -------------------------------------------------------------
> # Read from a path
> read_csv(readr_example("mtcars.csv"))
Rows: 32 Columns: 11
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 32 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> read_csv(readr_example("mtcars.csv.zip"))
Rows: 32 Columns: 11
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 32 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> read_csv(readr_example("mtcars.csv.bz2"))
Rows: 32 Columns: 11
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 32 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> ## Not run: 
> ##D # Including remote paths
> ##D read_csv("https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv")
> ## End(Not run)
> 
> # Read from multiple file paths at once
> continents <- c("africa", "americas", "asia", "europe", "oceania")
> filepaths <- vapply(
+   paste0("mini-gapminder-", continents, ".csv"),
+   FUN = readr_example,
+   FUN.VALUE = character(1)
+ )
> read_csv(filepaths, id = "file")
Rows: 26 Columns: 6
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (1): country
dbl (4): year, lifeExp, pop, gdpPercap

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 26 × 6
   file                                   country  year lifeExp    pop gdpPercap
   <chr>                                  <chr>   <dbl>   <dbl>  <dbl>     <dbl>
 1 /usr/local/lib/R/site-library/readr/e… Algeria  1952    43.1 9.28e6     2449.
 2 /usr/local/lib/R/site-library/readr/e… Angola   1952    30.0 4.23e6     3521.
 3 /usr/local/lib/R/site-library/readr/e… Benin    1952    38.2 1.74e6     1063.
 4 /usr/local/lib/R/site-library/readr/e… Botswa…  1952    47.6 4.42e5      851.
 5 /usr/local/lib/R/site-library/readr/e… Burkin…  1952    32.0 4.47e6      543.
 6 /usr/local/lib/R/site-library/readr/e… Burundi  1952    39.0 2.45e6      339.
 7 /usr/local/lib/R/site-library/readr/e… Argent…  1952    62.5 1.79e7     5911.
 8 /usr/local/lib/R/site-library/readr/e… Bolivia  1952    40.4 2.88e6     2677.
 9 /usr/local/lib/R/site-library/readr/e… Brazil   1952    50.9 5.66e7     2109.
10 /usr/local/lib/R/site-library/readr/e… Canada   1952    68.8 1.48e7    11367.
# ℹ 16 more rows
> 
> # Or directly from a string with `I()`
> read_csv(I("x,y\n1,2\n3,4"))
Rows: 2 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (2): x, y

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 2 × 2
      x     y
  <dbl> <dbl>
1     1     2
2     3     4
> 
> # Column selection-----------------------------------------------------------
> # Pass column names or indexes directly to select them
> read_csv(readr_example("chickens.csv"), col_select = c(chicken, eggs_laid))
Rows: 5 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (1): chicken
dbl (1): eggs_laid

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 5 × 2
  chicken                 eggs_laid
  <chr>                       <dbl>
1 Foghorn Leghorn                 0
2 Chicken Little                  3
3 Ginger                         12
4 Camilla the Chicken             7
5 Ernie The Giant Chicken         0
> read_csv(readr_example("chickens.csv"), col_select = c(1, 3:4))
Rows: 5 Columns: 3
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (2): chicken, motto
dbl (1): eggs_laid

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 5 × 3
  chicken                 eggs_laid motto                                       
  <chr>                       <dbl> <chr>                                       
1 Foghorn Leghorn                 0 That's a joke, ah say, that's a joke, son.  
2 Chicken Little                  3 The sky is falling!                         
3 Ginger                         12 Listen. We'll either die free chickens or w…
4 Camilla the Chicken             7 Bawk, buck, ba-gawk.                        
5 Ernie The Giant Chicken         0 Put Captain Solo in the cargo hold.         
> 
> # Or use the selection helpers
> read_csv(
+   readr_example("chickens.csv"),
+   col_select = c(starts_with("c"), last_col())
+ )
Rows: 5 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (2): chicken, motto

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 5 × 2
  chicken                 motto                                                 
  <chr>                   <chr>                                                 
1 Foghorn Leghorn         That's a joke, ah say, that's a joke, son.            
2 Chicken Little          The sky is falling!                                   
3 Ginger                  Listen. We'll either die free chickens or we die tryi…
4 Camilla the Chicken     Bawk, buck, ba-gawk.                                  
5 Ernie The Giant Chicken Put Captain Solo in the cargo hold.                   
> 
> # You can also rename specific columns
> read_csv(
+   readr_example("chickens.csv"),
+   col_select = c(egg_yield = eggs_laid, everything())
+ )
Rows: 5 Columns: 4
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (3): chicken, sex, motto
dbl (1): eggs_laid

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 5 × 4
  egg_yield chicken                 sex     motto                               
      <dbl> <chr>                   <chr>   <chr>                               
1         0 Foghorn Leghorn         rooster That's a joke, ah say, that's a jok…
2         3 Chicken Little          hen     The sky is falling!                 
3        12 Ginger                  hen     Listen. We'll either die free chick…
4         7 Camilla the Chicken     hen     Bawk, buck, ba-gawk.                
5         0 Ernie The Giant Chicken rooster Put Captain Solo in the cargo hold. 
> 
> # Column types --------------------------------------------------------------
> # By default, readr guesses the columns types, looking at `guess_max` rows.
> # You can override with a compact specification:
> read_csv(I("x,y\n1,2\n3,4"), col_types = "dc")
# A tibble: 2 × 2
      x y    
  <dbl> <chr>
1     1 2    
2     3 4    
> 
> # Or with a list of column types:
> read_csv(I("x,y\n1,2\n3,4"), col_types = list(col_double(), col_character()))
# A tibble: 2 × 2
      x y    
  <dbl> <chr>
1     1 2    
2     3 4    
> 
> # If there are parsing problems, you get a warning, and can extract
> # more details with problems()
> y <- read_csv(I("x\n1\n2\nb"), col_types = list(col_double()))
Warning: One or more parsing issues, call `problems()` on your data frame for details,
e.g.:
  dat <- vroom(...)
  problems(dat)
> y
# A tibble: 3 × 1
      x
  <dbl>
1     1
2     2
3    NA
> problems(y)
# A tibble: 1 × 5
    row   col expected actual file                             
  <int> <int> <chr>    <chr>  <chr>                            
1     4     1 a double b      /tmp/Rtmp3LOKyL/file1ce75696c9277
> 
> # Column names --------------------------------------------------------------
> # By default, readr duplicate name repair is noisy
> read_csv(I("x,x\n1,2\n3,4"))
New names:
• `x` -> `x...1`
• `x` -> `x...2`
Rows: 2 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (2): x...1, x...2

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 2 × 2
  x...1 x...2
  <dbl> <dbl>
1     1     2
2     3     4
> 
> # Same default repair strategy, but quiet
> read_csv(I("x,x\n1,2\n3,4"), name_repair = "unique_quiet")
Rows: 2 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (2): x...1, x...2

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 2 × 2
  x...1 x...2
  <dbl> <dbl>
1     1     2
2     3     4
> 
> # There's also a global option that controls verbosity of name repair
> withr::with_options(
+   list(rlib_name_repair_verbosity = "quiet"),
+   read_csv(I("x,x\n1,2\n3,4"))
+ )
Rows: 2 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (2): x...1, x...2

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 2 × 2
  x...1 x...2
  <dbl> <dbl>
1     1     2
2     3     4
> 
> # Or use "minimal" to turn off name repair
> read_csv(I("x,x\n1,2\n3,4"), name_repair = "minimal")
Rows: 2 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (2): x, x

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 2 × 2
      x     x
  <dbl> <dbl>
1     1     2
2     3     4
> 
> # File types ----------------------------------------------------------------
> read_csv(I("a,b\n1.0,2.0"))
Rows: 1 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (2): a, b

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 1 × 2
      a     b
  <dbl> <dbl>
1     1     2
> read_csv2(I("a;b\n1,0;2,0"))
ℹ Using "','" as decimal and "'.'" as grouping mark. Use `read_delim()` for more control.
Rows: 1 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ";"
dbl (2): a, b

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 1 × 2
      a     b
  <dbl> <dbl>
1     1     2
> read_tsv(I("a\tb\n1.0\t2.0"))
Rows: 1 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: "\t"
dbl (2): a, b

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 1 × 2
      a     b
  <dbl> <dbl>
1     1     2
> read_delim(I("a|b\n1.0|2.0"), delim = "|")
Rows: 1 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: "|"
dbl (2): a, b

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 1 × 2
      a     b
  <dbl> <dbl>
1     1     2
> 
> 
> 
> cleanEx()
> nameEx("read_delim_chunked")
> ### * read_delim_chunked
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_delim_chunked
> ### Title: Read a delimited file by chunks
> ### Aliases: read_delim_chunked read_csv_chunked read_csv2_chunked
> ###   read_tsv_chunked
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Cars with 3 gears
> f <- function(x, pos) subset(x, gear == 3)
> read_csv_chunked(readr_example("mtcars.csv"), DataFrameCallback$new(f), chunk_size = 5)

── Column specification ────────────────────────────────────────────────────────
cols(
  mpg = col_double(),
  cyl = col_double(),
  disp = col_double(),
  hp = col_double(),
  drat = col_double(),
  wt = col_double(),
  qsec = col_double(),
  vs = col_double(),
  am = col_double(),
  gear = col_double(),
  carb = col_double()
)

# A tibble: 15 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 2  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 3  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 4  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 5  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3
 6  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3
 7  15.2     8  276.   180  3.07  3.78  18       0     0     3     3
 8  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
 9  10.4     8  460    215  3     5.42  17.8     0     0     3     4
10  14.7     8  440    230  3.23  5.34  17.4     0     0     3     4
11  21.5     4  120.    97  3.7   2.46  20.0     1     0     3     1
12  15.5     8  318    150  2.76  3.52  16.9     0     0     3     2
13  15.2     8  304    150  3.15  3.44  17.3     0     0     3     2
14  13.3     8  350    245  3.73  3.84  15.4     0     0     3     4
15  19.2     8  400    175  3.08  3.84  17.0     0     0     3     2
> 
> 
> 
> cleanEx()
> nameEx("read_file")
> ### * read_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_file
> ### Title: Read/write a complete file
> ### Aliases: read_file read_file_raw write_file
> 
> ### ** Examples
> 
> read_file(file.path(R.home("doc"), "AUTHORS"))
[1] "Authors of R.\n\nR was initially written by Robert Gentleman and Ross Ihaka—also known as \"R & R\"\nof the Statistics Department of the University of Auckland.\n\nSince mid-1997 there has been a core group with write access to the R\nsource, currently consisting of\n\nDouglas Bates\nJohn Chambers\nPeter Dalgaard\nRobert Gentleman\nKurt Hornik\nRoss Ihaka\nTomas Kalibera\nMichael Lawrence\nFriedrich Leisch\nUwe Ligges\nThomas Lumley\nMartin Maechler\nSebastian Meyer\nPaul Murrell\nMartyn Plummer\nBrian Ripley\nDeepayan Sarkar\nDuncan Temple Lang\nLuke Tierney\nSimon Urbanek\n\nplus Heiner Schwarte up to October 1999, Guido Masarotto up to June 2003,\nStefano Iacus up to July 2014, Seth Falcon up to August 2015, Duncan Murdoch\nup to September 2017, and Martin Morgan up to June 2021.\n\n\nCurrent R-core members can be contacted via email to R-project.org\nwith name made up by replacing spaces by dots in the name listed above.\n\n(The authors of code from other projects included in the R distribution\nare listed in the COPYRIGHTS file.)\n"
> read_file_raw(file.path(R.home("doc"), "AUTHORS"))
   [1] 41 75 74 68 6f 72 73 20 6f 66 20 52 2e 0a 0a 52 20 77 61 73 20 69 6e 69
  [25] 74 69 61 6c 6c 79 20 77 72 69 74 74 65 6e 20 62 79 20 52 6f 62 65 72 74
  [49] 20 47 65 6e 74 6c 65 6d 61 6e 20 61 6e 64 20 52 6f 73 73 20 49 68 61 6b
  [73] 61 e2 80 94 61 6c 73 6f 20 6b 6e 6f 77 6e 20 61 73 20 22 52 20 26 20 52
  [97] 22 0a 6f 66 20 74 68 65 20 53 74 61 74 69 73 74 69 63 73 20 44 65 70 61
 [121] 72 74 6d 65 6e 74 20 6f 66 20 74 68 65 20 55 6e 69 76 65 72 73 69 74 79
 [145] 20 6f 66 20 41 75 63 6b 6c 61 6e 64 2e 0a 0a 53 69 6e 63 65 20 6d 69 64
 [169] 2d 31 39 39 37 20 74 68 65 72 65 20 68 61 73 20 62 65 65 6e 20 61 20 63
 [193] 6f 72 65 20 67 72 6f 75 70 20 77 69 74 68 20 77 72 69 74 65 20 61 63 63
 [217] 65 73 73 20 74 6f 20 74 68 65 20 52 0a 73 6f 75 72 63 65 2c 20 63 75 72
 [241] 72 65 6e 74 6c 79 20 63 6f 6e 73 69 73 74 69 6e 67 20 6f 66 0a 0a 44 6f
 [265] 75 67 6c 61 73 20 42 61 74 65 73 0a 4a 6f 68 6e 20 43 68 61 6d 62 65 72
 [289] 73 0a 50 65 74 65 72 20 44 61 6c 67 61 61 72 64 0a 52 6f 62 65 72 74 20
 [313] 47 65 6e 74 6c 65 6d 61 6e 0a 4b 75 72 74 20 48 6f 72 6e 69 6b 0a 52 6f
 [337] 73 73 20 49 68 61 6b 61 0a 54 6f 6d 61 73 20 4b 61 6c 69 62 65 72 61 0a
 [361] 4d 69 63 68 61 65 6c 20 4c 61 77 72 65 6e 63 65 0a 46 72 69 65 64 72 69
 [385] 63 68 20 4c 65 69 73 63 68 0a 55 77 65 20 4c 69 67 67 65 73 0a 54 68 6f
 [409] 6d 61 73 20 4c 75 6d 6c 65 79 0a 4d 61 72 74 69 6e 20 4d 61 65 63 68 6c
 [433] 65 72 0a 53 65 62 61 73 74 69 61 6e 20 4d 65 79 65 72 0a 50 61 75 6c 20
 [457] 4d 75 72 72 65 6c 6c 0a 4d 61 72 74 79 6e 20 50 6c 75 6d 6d 65 72 0a 42
 [481] 72 69 61 6e 20 52 69 70 6c 65 79 0a 44 65 65 70 61 79 61 6e 20 53 61 72
 [505] 6b 61 72 0a 44 75 6e 63 61 6e 20 54 65 6d 70 6c 65 20 4c 61 6e 67 0a 4c
 [529] 75 6b 65 20 54 69 65 72 6e 65 79 0a 53 69 6d 6f 6e 20 55 72 62 61 6e 65
 [553] 6b 0a 0a 70 6c 75 73 20 48 65 69 6e 65 72 20 53 63 68 77 61 72 74 65 20
 [577] 75 70 20 74 6f 20 4f 63 74 6f 62 65 72 20 31 39 39 39 2c 20 47 75 69 64
 [601] 6f 20 4d 61 73 61 72 6f 74 74 6f 20 75 70 20 74 6f 20 4a 75 6e 65 20 32
 [625] 30 30 33 2c 0a 53 74 65 66 61 6e 6f 20 49 61 63 75 73 20 75 70 20 74 6f
 [649] 20 4a 75 6c 79 20 32 30 31 34 2c 20 53 65 74 68 20 46 61 6c 63 6f 6e 20
 [673] 75 70 20 74 6f 20 41 75 67 75 73 74 20 32 30 31 35 2c 20 44 75 6e 63 61
 [697] 6e 20 4d 75 72 64 6f 63 68 0a 75 70 20 74 6f 20 53 65 70 74 65 6d 62 65
 [721] 72 20 32 30 31 37 2c 20 61 6e 64 20 4d 61 72 74 69 6e 20 4d 6f 72 67 61
 [745] 6e 20 75 70 20 74 6f 20 4a 75 6e 65 20 32 30 32 31 2e 0a 0a 0a 43 75 72
 [769] 72 65 6e 74 20 52 2d 63 6f 72 65 20 6d 65 6d 62 65 72 73 20 63 61 6e 20
 [793] 62 65 20 63 6f 6e 74 61 63 74 65 64 20 76 69 61 20 65 6d 61 69 6c 20 74
 [817] 6f 20 52 2d 70 72 6f 6a 65 63 74 2e 6f 72 67 0a 77 69 74 68 20 6e 61 6d
 [841] 65 20 6d 61 64 65 20 75 70 20 62 79 20 72 65 70 6c 61 63 69 6e 67 20 73
 [865] 70 61 63 65 73 20 62 79 20 64 6f 74 73 20 69 6e 20 74 68 65 20 6e 61 6d
 [889] 65 20 6c 69 73 74 65 64 20 61 62 6f 76 65 2e 0a 0a 28 54 68 65 20 61 75
 [913] 74 68 6f 72 73 20 6f 66 20 63 6f 64 65 20 66 72 6f 6d 20 6f 74 68 65 72
 [937] 20 70 72 6f 6a 65 63 74 73 20 69 6e 63 6c 75 64 65 64 20 69 6e 20 74 68
 [961] 65 20 52 20 64 69 73 74 72 69 62 75 74 69 6f 6e 0a 61 72 65 20 6c 69 73
 [985] 74 65 64 20 69 6e 20 74 68 65 20 43 4f 50 59 52 49 47 48 54 53 20 66 69
[1009] 6c 65 2e 29 0a
> 
> tmp <- tempfile()
> 
> x <- format_csv(mtcars[1:6, ])
> write_file(x, tmp)
> identical(x, read_file(tmp))
[1] TRUE
> 
> read_lines(I(x))
[1] "mpg,cyl,disp,hp,drat,wt,qsec,vs,am,gear,carb"
[2] "21,6,160,110,3.9,2.62,16.46,0,1,4,4"         
[3] "21,6,160,110,3.9,2.875,17.02,0,1,4,4"        
[4] "22.8,4,108,93,3.85,2.32,18.61,1,1,4,1"       
[5] "21.4,6,258,110,3.08,3.215,19.44,1,0,3,1"     
[6] "18.7,8,360,175,3.15,3.44,17.02,0,0,3,2"      
[7] "18.1,6,225,105,2.76,3.46,20.22,1,0,3,1"      
> 
> 
> 
> cleanEx()
> nameEx("read_fwf")
> ### * read_fwf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_fwf
> ### Title: Read a fixed width file into a tibble
> ### Aliases: read_fwf fwf_empty fwf_widths fwf_positions fwf_cols
> 
> ### ** Examples
> 
> fwf_sample <- readr_example("fwf-sample.txt")
> writeLines(read_lines(fwf_sample))
John Smith          WA        418-Y11-4111
Mary Hartford       CA        319-Z19-4341
Evan Nolan          IL        219-532-c301
> 
> # You can specify column positions in several ways:
> # 1. Guess based on position of empty columns
> read_fwf(fwf_sample, fwf_empty(fwf_sample, col_names = c("first", "last", "state", "ssn")))
Rows: 3 Columns: 4
── Column specification ────────────────────────────────────────────────────────

chr (4): first, last, state, ssn

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 3 × 4
  first last     state ssn         
  <chr> <chr>    <chr> <chr>       
1 John  Smith    WA    418-Y11-4111
2 Mary  Hartford CA    319-Z19-4341
3 Evan  Nolan    IL    219-532-c301
> # 2. A vector of field widths
> read_fwf(fwf_sample, fwf_widths(c(20, 10, 12), c("name", "state", "ssn")))
Rows: 3 Columns: 3
── Column specification ────────────────────────────────────────────────────────

chr (3): name, state, ssn

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 3 × 3
  name          state ssn         
  <chr>         <chr> <chr>       
1 John Smith    WA    418-Y11-4111
2 Mary Hartford CA    319-Z19-4341
3 Evan Nolan    IL    219-532-c301
> # 3. Paired vectors of start and end positions
> read_fwf(fwf_sample, fwf_positions(c(1, 30), c(20, 42), c("name", "ssn")))
Rows: 3 Columns: 2
── Column specification ────────────────────────────────────────────────────────

chr (2): name, ssn

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 3 × 2
  name          ssn         
  <chr>         <chr>       
1 John Smith    418-Y11-4111
2 Mary Hartford 319-Z19-4341
3 Evan Nolan    219-532-c301
> # 4. Named arguments with start and end positions
> read_fwf(fwf_sample, fwf_cols(name = c(1, 20), ssn = c(30, 42)))
Rows: 3 Columns: 2
── Column specification ────────────────────────────────────────────────────────

chr (2): name, ssn

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 3 × 2
  name          ssn         
  <chr>         <chr>       
1 John Smith    418-Y11-4111
2 Mary Hartford 319-Z19-4341
3 Evan Nolan    219-532-c301
> # 5. Named arguments with column widths
> read_fwf(fwf_sample, fwf_cols(name = 20, state = 10, ssn = 12))
Rows: 3 Columns: 3
── Column specification ────────────────────────────────────────────────────────

chr (3): name, state, ssn

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 3 × 3
  name          state ssn         
  <chr>         <chr> <chr>       
1 John Smith    WA    418-Y11-4111
2 Mary Hartford CA    319-Z19-4341
3 Evan Nolan    IL    219-532-c301
> 
> 
> 
> cleanEx()
> nameEx("read_lines")
> ### * read_lines
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_lines
> ### Title: Read/write lines to/from a file
> ### Aliases: read_lines read_lines_raw write_lines
> 
> ### ** Examples
> 
> read_lines(file.path(R.home("doc"), "AUTHORS"), n_max = 10)
 [1] "Authors of R."                                                                     
 [2] ""                                                                                  
 [3] "R was initially written by Robert Gentleman and Ross Ihaka—also known as \"R & R\""
 [4] "of the Statistics Department of the University of Auckland."                       
 [5] ""                                                                                  
 [6] "Since mid-1997 there has been a core group with write access to the R"             
 [7] "source, currently consisting of"                                                   
 [8] ""                                                                                  
 [9] "Douglas Bates"                                                                     
[10] "John Chambers"                                                                     
> read_lines_raw(file.path(R.home("doc"), "AUTHORS"), n_max = 10)
[[1]]
 [1] 41 75 74 68 6f 72 73 20 6f 66 20 52 2e

[[2]]
raw(0)

[[3]]
 [1] 52 20 77 61 73 20 69 6e 69 74 69 61 6c 6c 79 20 77 72 69 74 74 65 6e 20 62
[26] 79 20 52 6f 62 65 72 74 20 47 65 6e 74 6c 65 6d 61 6e 20 61 6e 64 20 52 6f
[51] 73 73 20 49 68 61 6b 61 e2 80 94 61 6c 73 6f 20 6b 6e 6f 77 6e 20 61 73 20
[76] 22 52 20 26 20 52 22

[[4]]
 [1] 6f 66 20 74 68 65 20 53 74 61 74 69 73 74 69 63 73 20 44 65 70 61 72 74 6d
[26] 65 6e 74 20 6f 66 20 74 68 65 20 55 6e 69 76 65 72 73 69 74 79 20 6f 66 20
[51] 41 75 63 6b 6c 61 6e 64 2e

[[5]]
raw(0)

[[6]]
 [1] 53 69 6e 63 65 20 6d 69 64 2d 31 39 39 37 20 74 68 65 72 65 20 68 61 73 20
[26] 62 65 65 6e 20 61 20 63 6f 72 65 20 67 72 6f 75 70 20 77 69 74 68 20 77 72
[51] 69 74 65 20 61 63 63 65 73 73 20 74 6f 20 74 68 65 20 52

[[7]]
 [1] 73 6f 75 72 63 65 2c 20 63 75 72 72 65 6e 74 6c 79 20 63 6f 6e 73 69 73 74
[26] 69 6e 67 20 6f 66

[[8]]
raw(0)

[[9]]
 [1] 44 6f 75 67 6c 61 73 20 42 61 74 65 73

[[10]]
 [1] 4a 6f 68 6e 20 43 68 61 6d 62 65 72 73

> 
> tmp <- tempfile()
> 
> write_lines(rownames(mtcars), tmp)
> read_lines(tmp, lazy = FALSE)
 [1] "Mazda RX4"           "Mazda RX4 Wag"       "Datsun 710"         
 [4] "Hornet 4 Drive"      "Hornet Sportabout"   "Valiant"            
 [7] "Duster 360"          "Merc 240D"           "Merc 230"           
[10] "Merc 280"            "Merc 280C"           "Merc 450SE"         
[13] "Merc 450SL"          "Merc 450SLC"         "Cadillac Fleetwood" 
[16] "Lincoln Continental" "Chrysler Imperial"   "Fiat 128"           
[19] "Honda Civic"         "Toyota Corolla"      "Toyota Corona"      
[22] "Dodge Challenger"    "AMC Javelin"         "Camaro Z28"         
[25] "Pontiac Firebird"    "Fiat X1-9"           "Porsche 914-2"      
[28] "Lotus Europa"        "Ford Pantera L"      "Ferrari Dino"       
[31] "Maserati Bora"       "Volvo 142E"         
> read_file(tmp) # note trailing \n
[1] "Mazda RX4\nMazda RX4 Wag\nDatsun 710\nHornet 4 Drive\nHornet Sportabout\nValiant\nDuster 360\nMerc 240D\nMerc 230\nMerc 280\nMerc 280C\nMerc 450SE\nMerc 450SL\nMerc 450SLC\nCadillac Fleetwood\nLincoln Continental\nChrysler Imperial\nFiat 128\nHonda Civic\nToyota Corolla\nToyota Corona\nDodge Challenger\nAMC Javelin\nCamaro Z28\nPontiac Firebird\nFiat X1-9\nPorsche 914-2\nLotus Europa\nFord Pantera L\nFerrari Dino\nMaserati Bora\nVolvo 142E\n"
> 
> write_lines(airquality$Ozone, tmp, na = "-1")
> read_lines(tmp)
  [1] "41"  "36"  "12"  "18"  "-1"  "28"  "23"  "19"  "8"   "-1"  "7"   "16" 
 [13] "11"  "14"  "18"  "14"  "34"  "6"   "30"  "11"  "1"   "11"  "4"   "32" 
 [25] "-1"  "-1"  "-1"  "23"  "45"  "115" "37"  "-1"  "-1"  "-1"  "-1"  "-1" 
 [37] "-1"  "29"  "-1"  "71"  "39"  "-1"  "-1"  "23"  "-1"  "-1"  "21"  "37" 
 [49] "20"  "12"  "13"  "-1"  "-1"  "-1"  "-1"  "-1"  "-1"  "-1"  "-1"  "-1" 
 [61] "-1"  "135" "49"  "32"  "-1"  "64"  "40"  "77"  "97"  "97"  "85"  "-1" 
 [73] "10"  "27"  "-1"  "7"   "48"  "35"  "61"  "79"  "63"  "16"  "-1"  "-1" 
 [85] "80"  "108" "20"  "52"  "82"  "50"  "64"  "59"  "39"  "9"   "16"  "78" 
 [97] "35"  "66"  "122" "89"  "110" "-1"  "-1"  "44"  "28"  "65"  "-1"  "22" 
[109] "59"  "23"  "31"  "44"  "21"  "9"   "-1"  "45"  "168" "73"  "-1"  "76" 
[121] "118" "84"  "85"  "96"  "78"  "73"  "91"  "47"  "32"  "20"  "23"  "21" 
[133] "24"  "44"  "21"  "28"  "9"   "13"  "46"  "18"  "13"  "24"  "16"  "13" 
[145] "23"  "36"  "7"   "14"  "30"  "-1"  "14"  "18"  "20" 
> 
> 
> 
> cleanEx()
> nameEx("read_log")
> ### * read_log
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_log
> ### Title: Read common/combined log file into a tibble
> ### Aliases: read_log
> 
> ### ** Examples
> 
> read_log(readr_example("example.log"))

── Column specification ────────────────────────────────────────────────────────
cols(
  X1 = col_character(),
  X2 = col_logical(),
  X3 = col_character(),
  X4 = col_character(),
  X5 = col_character(),
  X6 = col_double(),
  X7 = col_double()
)

# A tibble: 2 × 7
  X1           X2    X3                   X4                   X5       X6    X7
  <chr>        <lgl> <chr>                <chr>                <chr> <dbl> <dbl>
1 172.21.13.45 NA    "Microsoft\\JohnDoe" 08/Apr/2001:17:39:0… GET …   200  3401
2 127.0.0.1    NA    "frank"              10/Oct/2000:13:55:3… GET …   200  2326
> 
> 
> 
> cleanEx()
> nameEx("read_rds")
> ### * read_rds
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_rds
> ### Title: Read/write RDS files.
> ### Aliases: read_rds write_rds
> 
> ### ** Examples
> 
> temp <- tempfile()
> write_rds(mtcars, temp)
> read_rds(temp)
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> ## Not run: 
> ##D write_rds(mtcars, "compressed_mtc.rds", "xz", compression = 9L)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("read_table")
> ### * read_table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_table
> ### Title: Read whitespace-separated columns into a tibble
> ### Aliases: read_table
> 
> ### ** Examples
> 
> ws <- readr_example("whitespace-sample.txt")
> writeLines(read_lines(ws))
first last state phone
John Smith WA 418-Y11-4111
Mary Hartford CA 319-Z19-4341
Evan Nolan IL 219-532-c301
> read_table(ws)

── Column specification ────────────────────────────────────────────────────────
cols(
  first = col_character(),
  last = col_character(),
  state = col_character(),
  phone = col_character()
)

# A tibble: 3 × 4
  first last     state phone       
  <chr> <chr>    <chr> <chr>       
1 John  Smith    WA    418-Y11-4111
2 Mary  Hartford CA    319-Z19-4341
3 Evan  Nolan    IL    219-532-c301
> 
> 
> 
> cleanEx()
> nameEx("readr_example")
> ### * readr_example
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: readr_example
> ### Title: Get path to readr example
> ### Aliases: readr_example
> 
> ### ** Examples
> 
> readr_example()
 [1] "challenge.csv"               "chickens.csv"               
 [3] "epa78.txt"                   "example.log"                
 [5] "fwf-sample.txt"              "massey-rating.txt"          
 [7] "mini-gapminder-africa.csv"   "mini-gapminder-americas.csv"
 [9] "mini-gapminder-asia.csv"     "mini-gapminder-europe.csv"  
[11] "mini-gapminder-oceania.csv"  "mtcars.csv"                 
[13] "mtcars.csv.bz2"              "mtcars.csv.zip"             
[15] "whitespace-sample.txt"      
> readr_example("challenge.csv")
[1] "/usr/local/lib/R/site-library/readr/extdata/challenge.csv"
> 
> 
> 
> cleanEx()
> nameEx("spec")
> ### * spec
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cols_condense
> ### Title: Examine the column specifications for a data frame
> ### Aliases: cols_condense spec
> 
> ### ** Examples
> 
> df <- read_csv(readr_example("mtcars.csv"))
Rows: 32 Columns: 11
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
> s <- spec(df)
> s
cols(
  mpg = col_double(),
  cyl = col_double(),
  disp = col_double(),
  hp = col_double(),
  drat = col_double(),
  wt = col_double(),
  qsec = col_double(),
  vs = col_double(),
  am = col_double(),
  gear = col_double(),
  carb = col_double()
)
> 
> cols_condense(s)
cols(
  .default = col_double()
)
> 
> 
> 
> cleanEx()
> nameEx("spec_delim")
> ### * spec_delim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spec_delim
> ### Title: Generate a column specification
> ### Aliases: spec_delim spec_csv spec_csv2 spec_tsv spec_table
> 
> ### ** Examples
> 
> # Input sources -------------------------------------------------------------
> # Retrieve specs from a path
> spec_csv(system.file("extdata/mtcars.csv", package = "readr"))
cols(
  mpg = col_double(),
  cyl = col_double(),
  disp = col_double(),
  hp = col_double(),
  drat = col_double(),
  wt = col_double(),
  qsec = col_double(),
  vs = col_double(),
  am = col_double(),
  gear = col_double(),
  carb = col_double()
)
> spec_csv(system.file("extdata/mtcars.csv.zip", package = "readr"))
cols(
  mpg = col_double(),
  cyl = col_double(),
  disp = col_double(),
  hp = col_double(),
  drat = col_double(),
  wt = col_double(),
  qsec = col_double(),
  vs = col_double(),
  am = col_double(),
  gear = col_double(),
  carb = col_double()
)
> 
> # Or directly from a string (must contain a newline)
> spec_csv(I("x,y\n1,2\n3,4"))
cols(
  x = col_double(),
  y = col_double()
)
> 
> # Column types --------------------------------------------------------------
> # By default, readr guesses the columns types, looking at 1000 rows
> # throughout the file.
> # You can specify the number of rows used with guess_max.
> spec_csv(system.file("extdata/mtcars.csv", package = "readr"), guess_max = 20)
cols(
  mpg = col_double(),
  cyl = col_double(),
  disp = col_double(),
  hp = col_double(),
  drat = col_double(),
  wt = col_double(),
  qsec = col_double(),
  vs = col_double(),
  am = col_double(),
  gear = col_double(),
  carb = col_double()
)
> 
> 
> 
> cleanEx()
> nameEx("tokenize")
> ### * tokenize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tokenize
> ### Title: Tokenize a file/string.
> ### Aliases: tokenize
> ### Keywords: internal
> 
> ### ** Examples
> 
> tokenize("1,2\n3,4,5\n\n6")
[[1]]
[1] "1" "2"

[[2]]
[1] "3" "4" "5"

[[3]]
[1] "6"

> 
> # Only tokenize first two lines
> tokenize("1,2\n3,4,5\n\n6", n = 2)
[[1]]
[1] "1" "2"

[[2]]
[1] "3" "4" "5"

> 
> 
> 
> cleanEx()
> nameEx("type_convert")
> ### * type_convert
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: type_convert
> ### Title: Re-convert character columns in existing data frame
> ### Aliases: type_convert
> 
> ### ** Examples
> 
> df <- data.frame(
+   x = as.character(runif(10)),
+   y = as.character(sample(10)),
+   stringsAsFactors = FALSE
+ )
> str(df)
'data.frame':	10 obs. of  2 variables:
 $ x: chr  "0.2655086631421" "0.37212389963679" "0.572853363351896" "0.908207789994776" ...
 $ y: chr  "3" "1" "5" "8" ...
> str(type_convert(df))

── Column specification ────────────────────────────────────────────────────────
cols(
  x = col_double(),
  y = col_double()
)

'data.frame':	10 obs. of  2 variables:
 $ x: num  0.266 0.372 0.573 0.908 0.202 ...
 $ y: num  3 1 5 8 2 6 10 9 4 7
> 
> df <- data.frame(x = c("NA", "10"), stringsAsFactors = FALSE)
> str(type_convert(df))

── Column specification ────────────────────────────────────────────────────────
cols(
  x = col_double()
)

'data.frame':	2 obs. of  1 variable:
 $ x: num  NA 10
> 
> # Type convert can be used to infer types from an entire dataset
> 
> # first read the data as character
> data <- read_csv(readr_example("mtcars.csv"),
+   col_types = list(.default = col_character())
+ )
> str(data)
spc_tbl_ [32 × 11] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
 $ mpg : chr [1:32] "21" "21" "22.8" "21.4" ...
 $ cyl : chr [1:32] "6" "6" "4" "6" ...
 $ disp: chr [1:32] "160" "160" "108" "258" ...
 $ hp  : chr [1:32] "110" "110" "93" "110" ...
 $ drat: chr [1:32] "3.9" "3.9" "3.85" "3.08" ...
 $ wt  : chr [1:32] "2.62" "2.875" "2.32" "3.215" ...
 $ qsec: chr [1:32] "16.46" "17.02" "18.61" "19.44" ...
 $ vs  : chr [1:32] "0" "0" "1" "1" ...
 $ am  : chr [1:32] "1" "1" "1" "0" ...
 $ gear: chr [1:32] "4" "4" "4" "3" ...
 $ carb: chr [1:32] "4" "4" "1" "1" ...
 - attr(*, "spec")=
  .. cols(
  ..   .default = col_character(),
  ..   mpg = col_character(),
  ..   cyl = col_character(),
  ..   disp = col_character(),
  ..   hp = col_character(),
  ..   drat = col_character(),
  ..   wt = col_character(),
  ..   qsec = col_character(),
  ..   vs = col_character(),
  ..   am = col_character(),
  ..   gear = col_character(),
  ..   carb = col_character()
  .. )
 - attr(*, "problems")=<externalptr> 
> # Then convert it with type_convert
> type_convert(data)

── Column specification ────────────────────────────────────────────────────────
cols(
  mpg = col_double(),
  cyl = col_double(),
  disp = col_double(),
  hp = col_double(),
  drat = col_double(),
  wt = col_double(),
  qsec = col_double(),
  vs = col_double(),
  am = col_double(),
  gear = col_double(),
  carb = col_double()
)

# A tibble: 32 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> 
> 
> 
> cleanEx()
> nameEx("with_edition")
> ### * with_edition
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: with_edition
> ### Title: Temporarily change the active readr edition
> ### Aliases: with_edition local_edition
> 
> ### ** Examples
> 
> with_edition(1, edition_get())
[1] 1
> with_edition(2, edition_get())
[1] 2
> 
> # readr 1e and 2e behave differently when input rows have different number
> # number of fields
> with_edition(1, read_csv("1,2\n3,4,5", col_names = c("X", "Y", "Z")))
Warning: 1 parsing failure.
row col  expected    actual         file
  1  -- 3 columns 2 columns literal data

# A tibble: 2 × 3
      X     Y     Z
  <dbl> <dbl> <dbl>
1     1     2    NA
2     3     4     5
> with_edition(2, read_csv("1,2\n3,4,5", col_names = c("X", "Y", "Z")))
Warning: One or more parsing issues, call `problems()` on your data frame for details,
e.g.:
  dat <- vroom(...)
  problems(dat)
Rows: 2 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (1): X
num (1): Y

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 2 × 2
      X     Y
  <dbl> <dbl>
1     1     2
2     3    45
> 
> # local_edition() applies in a specific scope, for example, inside a function
> read_csv_1e <- function(...) {
+   local_edition(1)
+   read_csv(...)
+ }
> read_csv("1,2\n3,4,5", col_names = c("X", "Y", "Z"))      # 2e behaviour
Warning: One or more parsing issues, call `problems()` on your data frame for details,
e.g.:
  dat <- vroom(...)
  problems(dat)
Rows: 2 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (1): X
num (1): Y

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 2 × 2
      X     Y
  <dbl> <dbl>
1     1     2
2     3    45
> read_csv_1e("1,2\n3,4,5", col_names = c("X", "Y", "Z"))   # 1e behaviour
Warning: 1 parsing failure.
row col  expected    actual         file
  1  -- 3 columns 2 columns literal data

# A tibble: 2 × 3
      X     Y     Z
  <dbl> <dbl> <dbl>
1     1     2    NA
2     3     4     5
> read_csv("1,2\n3,4,5", col_names = c("X", "Y", "Z"))      # 2e behaviour
Warning: One or more parsing issues, call `problems()` on your data frame for details,
e.g.:
  dat <- vroom(...)
  problems(dat)
Rows: 2 Columns: 2
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (1): X
num (1): Y

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
# A tibble: 2 × 2
      X     Y
  <dbl> <dbl>
1     1     2
2     3    45
> 
> 
> 
> cleanEx()
> nameEx("write_delim")
> ### * write_delim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write_delim
> ### Title: Write a data frame to a delimited file
> ### Aliases: write_delim write_csv write_csv2 write_excel_csv
> ###   write_excel_csv2 write_tsv
> 
> ### ** Examples
> 
> ## Don't show: 
> .old_wd <- setwd(tempdir())
> ## End(Don't show)
> # If only a file name is specified, write_()* will write
> # the file to the current working directory.
> write_csv(mtcars, "mtcars.csv")
> write_tsv(mtcars, "mtcars.tsv")
> 
> # If you add an extension to the file name, write_()* will
> # automatically compress the output.
> write_tsv(mtcars, "mtcars.tsv.gz")
> write_tsv(mtcars, "mtcars.tsv.bz2")
> write_tsv(mtcars, "mtcars.tsv.xz")
> ## Don't show: 
> setwd(.old_wd)
> ## End(Don't show)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  2.207 0.163 2.372 0.006 0.001 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
