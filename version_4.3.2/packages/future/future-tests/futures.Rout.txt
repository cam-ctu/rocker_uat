
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:25:45.815] plan(): Setting new future strategy stack:
[10:25:45.816] List of future strategies:
[10:25:45.816] 1. sequential:
[10:25:45.816]    - args: function (..., envir = parent.frame())
[10:25:45.816]    - tweaked: FALSE
[10:25:45.816]    - call: future::plan("sequential")
[10:25:45.829] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[10:25:45.879] plan(): Setting new future strategy stack:
[10:25:45.880] List of future strategies:
[10:25:45.880] 1. sequential:
[10:25:45.880]    - args: function (..., envir = parent.frame())
[10:25:45.880]    - tweaked: FALSE
[10:25:45.880]    - call: plan(strategy)
[10:25:45.891] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[10:25:45.891] getGlobalsAndPackages() ...
[10:25:45.891] Searching for globals...
[10:25:45.894] 
[10:25:45.894] Searching for globals ... DONE
[10:25:45.894] - globals: [0] <none>
[10:25:45.894] getGlobalsAndPackages() ... DONE
[10:25:45.895] run() for ‘Future’ ...
[10:25:45.895] - state: ‘created’
[10:25:45.895] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:45.895] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:45.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:45.895]   - Field: ‘label’
[10:25:45.896]   - Field: ‘local’
[10:25:45.896]   - Field: ‘owner’
[10:25:45.896]   - Field: ‘envir’
[10:25:45.896]   - Field: ‘packages’
[10:25:45.896]   - Field: ‘gc’
[10:25:45.896]   - Field: ‘conditions’
[10:25:45.896]   - Field: ‘expr’
[10:25:45.896]   - Field: ‘uuid’
[10:25:45.896]   - Field: ‘seed’
[10:25:45.896]   - Field: ‘version’
[10:25:45.896]   - Field: ‘result’
[10:25:45.897]   - Field: ‘asynchronous’
[10:25:45.897]   - Field: ‘calls’
[10:25:45.897]   - Field: ‘globals’
[10:25:45.897]   - Field: ‘stdout’
[10:25:45.897]   - Field: ‘earlySignal’
[10:25:45.897]   - Field: ‘lazy’
[10:25:45.897]   - Field: ‘state’
[10:25:45.897] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:45.897] - Launch lazy future ...
[10:25:45.898] Packages needed by the future expression (n = 0): <none>
[10:25:45.898] Packages needed by future strategies (n = 0): <none>
[10:25:45.899] {
[10:25:45.899]     {
[10:25:45.899]         {
[10:25:45.899]             ...future.startTime <- base::Sys.time()
[10:25:45.899]             {
[10:25:45.899]                 {
[10:25:45.899]                   {
[10:25:45.899]                     base::local({
[10:25:45.899]                       has_future <- base::requireNamespace("future", 
[10:25:45.899]                         quietly = TRUE)
[10:25:45.899]                       if (has_future) {
[10:25:45.899]                         ns <- base::getNamespace("future")
[10:25:45.899]                         version <- ns[[".package"]][["version"]]
[10:25:45.899]                         if (is.null(version)) 
[10:25:45.899]                           version <- utils::packageVersion("future")
[10:25:45.899]                       }
[10:25:45.899]                       else {
[10:25:45.899]                         version <- NULL
[10:25:45.899]                       }
[10:25:45.899]                       if (!has_future || version < "1.8.0") {
[10:25:45.899]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:45.899]                           "", base::R.version$version.string), 
[10:25:45.899]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:45.899]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:45.899]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:45.899]                             "release", "version")], collapse = " "), 
[10:25:45.899]                           hostname = base::Sys.info()[["nodename"]])
[10:25:45.899]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:45.899]                           info)
[10:25:45.899]                         info <- base::paste(info, collapse = "; ")
[10:25:45.899]                         if (!has_future) {
[10:25:45.899]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:45.899]                             info)
[10:25:45.899]                         }
[10:25:45.899]                         else {
[10:25:45.899]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:45.899]                             info, version)
[10:25:45.899]                         }
[10:25:45.899]                         base::stop(msg)
[10:25:45.899]                       }
[10:25:45.899]                     })
[10:25:45.899]                   }
[10:25:45.899]                   options(future.plan = NULL)
[10:25:45.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:45.899]                 }
[10:25:45.899]                 ...future.workdir <- getwd()
[10:25:45.899]             }
[10:25:45.899]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:45.899]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:45.899]         }
[10:25:45.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:45.899]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:45.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:45.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:45.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:45.899]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:45.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:45.899]             base::names(...future.oldOptions))
[10:25:45.899]     }
[10:25:45.899]     if (FALSE) {
[10:25:45.899]     }
[10:25:45.899]     else {
[10:25:45.899]         if (TRUE) {
[10:25:45.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:45.899]                 open = "w")
[10:25:45.899]         }
[10:25:45.899]         else {
[10:25:45.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:45.899]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:45.899]         }
[10:25:45.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:45.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:45.899]             base::sink(type = "output", split = FALSE)
[10:25:45.899]             base::close(...future.stdout)
[10:25:45.899]         }, add = TRUE)
[10:25:45.899]     }
[10:25:45.899]     ...future.frame <- base::sys.nframe()
[10:25:45.899]     ...future.conditions <- base::list()
[10:25:45.899]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:45.899]     if (FALSE) {
[10:25:45.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:45.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:45.899]     }
[10:25:45.899]     ...future.result <- base::tryCatch({
[10:25:45.899]         base::withCallingHandlers({
[10:25:45.899]             ...future.value <- base::withVisible(base::local(2))
[10:25:45.899]             future::FutureResult(value = ...future.value$value, 
[10:25:45.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.899]                   ...future.rng), globalenv = if (FALSE) 
[10:25:45.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:45.899]                     ...future.globalenv.names))
[10:25:45.899]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:45.899]         }, condition = base::local({
[10:25:45.899]             c <- base::c
[10:25:45.899]             inherits <- base::inherits
[10:25:45.899]             invokeRestart <- base::invokeRestart
[10:25:45.899]             length <- base::length
[10:25:45.899]             list <- base::list
[10:25:45.899]             seq.int <- base::seq.int
[10:25:45.899]             signalCondition <- base::signalCondition
[10:25:45.899]             sys.calls <- base::sys.calls
[10:25:45.899]             `[[` <- base::`[[`
[10:25:45.899]             `+` <- base::`+`
[10:25:45.899]             `<<-` <- base::`<<-`
[10:25:45.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:45.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:45.899]                   3L)]
[10:25:45.899]             }
[10:25:45.899]             function(cond) {
[10:25:45.899]                 is_error <- inherits(cond, "error")
[10:25:45.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:45.899]                   NULL)
[10:25:45.899]                 if (is_error) {
[10:25:45.899]                   sessionInformation <- function() {
[10:25:45.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:45.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:45.899]                       search = base::search(), system = base::Sys.info())
[10:25:45.899]                   }
[10:25:45.899]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:45.899]                     cond$call), session = sessionInformation(), 
[10:25:45.899]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:45.899]                   signalCondition(cond)
[10:25:45.899]                 }
[10:25:45.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:45.899]                 "immediateCondition"))) {
[10:25:45.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:45.899]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:45.899]                   if (TRUE && !signal) {
[10:25:45.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.899]                     {
[10:25:45.899]                       inherits <- base::inherits
[10:25:45.899]                       invokeRestart <- base::invokeRestart
[10:25:45.899]                       is.null <- base::is.null
[10:25:45.899]                       muffled <- FALSE
[10:25:45.899]                       if (inherits(cond, "message")) {
[10:25:45.899]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.899]                         if (muffled) 
[10:25:45.899]                           invokeRestart("muffleMessage")
[10:25:45.899]                       }
[10:25:45.899]                       else if (inherits(cond, "warning")) {
[10:25:45.899]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.899]                         if (muffled) 
[10:25:45.899]                           invokeRestart("muffleWarning")
[10:25:45.899]                       }
[10:25:45.899]                       else if (inherits(cond, "condition")) {
[10:25:45.899]                         if (!is.null(pattern)) {
[10:25:45.899]                           computeRestarts <- base::computeRestarts
[10:25:45.899]                           grepl <- base::grepl
[10:25:45.899]                           restarts <- computeRestarts(cond)
[10:25:45.899]                           for (restart in restarts) {
[10:25:45.899]                             name <- restart$name
[10:25:45.899]                             if (is.null(name)) 
[10:25:45.899]                               next
[10:25:45.899]                             if (!grepl(pattern, name)) 
[10:25:45.899]                               next
[10:25:45.899]                             invokeRestart(restart)
[10:25:45.899]                             muffled <- TRUE
[10:25:45.899]                             break
[10:25:45.899]                           }
[10:25:45.899]                         }
[10:25:45.899]                       }
[10:25:45.899]                       invisible(muffled)
[10:25:45.899]                     }
[10:25:45.899]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.899]                   }
[10:25:45.899]                 }
[10:25:45.899]                 else {
[10:25:45.899]                   if (TRUE) {
[10:25:45.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.899]                     {
[10:25:45.899]                       inherits <- base::inherits
[10:25:45.899]                       invokeRestart <- base::invokeRestart
[10:25:45.899]                       is.null <- base::is.null
[10:25:45.899]                       muffled <- FALSE
[10:25:45.899]                       if (inherits(cond, "message")) {
[10:25:45.899]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.899]                         if (muffled) 
[10:25:45.899]                           invokeRestart("muffleMessage")
[10:25:45.899]                       }
[10:25:45.899]                       else if (inherits(cond, "warning")) {
[10:25:45.899]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.899]                         if (muffled) 
[10:25:45.899]                           invokeRestart("muffleWarning")
[10:25:45.899]                       }
[10:25:45.899]                       else if (inherits(cond, "condition")) {
[10:25:45.899]                         if (!is.null(pattern)) {
[10:25:45.899]                           computeRestarts <- base::computeRestarts
[10:25:45.899]                           grepl <- base::grepl
[10:25:45.899]                           restarts <- computeRestarts(cond)
[10:25:45.899]                           for (restart in restarts) {
[10:25:45.899]                             name <- restart$name
[10:25:45.899]                             if (is.null(name)) 
[10:25:45.899]                               next
[10:25:45.899]                             if (!grepl(pattern, name)) 
[10:25:45.899]                               next
[10:25:45.899]                             invokeRestart(restart)
[10:25:45.899]                             muffled <- TRUE
[10:25:45.899]                             break
[10:25:45.899]                           }
[10:25:45.899]                         }
[10:25:45.899]                       }
[10:25:45.899]                       invisible(muffled)
[10:25:45.899]                     }
[10:25:45.899]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.899]                   }
[10:25:45.899]                 }
[10:25:45.899]             }
[10:25:45.899]         }))
[10:25:45.899]     }, error = function(ex) {
[10:25:45.899]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:45.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.899]                 ...future.rng), started = ...future.startTime, 
[10:25:45.899]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:45.899]             version = "1.8"), class = "FutureResult")
[10:25:45.899]     }, finally = {
[10:25:45.899]         if (!identical(...future.workdir, getwd())) 
[10:25:45.899]             setwd(...future.workdir)
[10:25:45.899]         {
[10:25:45.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:45.899]                 ...future.oldOptions$nwarnings <- NULL
[10:25:45.899]             }
[10:25:45.899]             base::options(...future.oldOptions)
[10:25:45.899]             if (.Platform$OS.type == "windows") {
[10:25:45.899]                 old_names <- names(...future.oldEnvVars)
[10:25:45.899]                 envs <- base::Sys.getenv()
[10:25:45.899]                 names <- names(envs)
[10:25:45.899]                 common <- intersect(names, old_names)
[10:25:45.899]                 added <- setdiff(names, old_names)
[10:25:45.899]                 removed <- setdiff(old_names, names)
[10:25:45.899]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:45.899]                   envs[common]]
[10:25:45.899]                 NAMES <- toupper(changed)
[10:25:45.899]                 args <- list()
[10:25:45.899]                 for (kk in seq_along(NAMES)) {
[10:25:45.899]                   name <- changed[[kk]]
[10:25:45.899]                   NAME <- NAMES[[kk]]
[10:25:45.899]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.899]                     next
[10:25:45.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.899]                 }
[10:25:45.899]                 NAMES <- toupper(added)
[10:25:45.899]                 for (kk in seq_along(NAMES)) {
[10:25:45.899]                   name <- added[[kk]]
[10:25:45.899]                   NAME <- NAMES[[kk]]
[10:25:45.899]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.899]                     next
[10:25:45.899]                   args[[name]] <- ""
[10:25:45.899]                 }
[10:25:45.899]                 NAMES <- toupper(removed)
[10:25:45.899]                 for (kk in seq_along(NAMES)) {
[10:25:45.899]                   name <- removed[[kk]]
[10:25:45.899]                   NAME <- NAMES[[kk]]
[10:25:45.899]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.899]                     next
[10:25:45.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.899]                 }
[10:25:45.899]                 if (length(args) > 0) 
[10:25:45.899]                   base::do.call(base::Sys.setenv, args = args)
[10:25:45.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:45.899]             }
[10:25:45.899]             else {
[10:25:45.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:45.899]             }
[10:25:45.899]             {
[10:25:45.899]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:45.899]                   0L) {
[10:25:45.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:45.899]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:45.899]                   base::options(opts)
[10:25:45.899]                 }
[10:25:45.899]                 {
[10:25:45.899]                   {
[10:25:45.899]                     NULL
[10:25:45.899]                     RNGkind("Mersenne-Twister")
[10:25:45.899]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:45.899]                       inherits = FALSE)
[10:25:45.899]                   }
[10:25:45.899]                   options(future.plan = NULL)
[10:25:45.899]                   if (is.na(NA_character_)) 
[10:25:45.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:45.899]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:45.899]                   {
[10:25:45.899]                     future <- SequentialFuture(..., envir = envir)
[10:25:45.899]                     if (!future$lazy) 
[10:25:45.899]                       future <- run(future)
[10:25:45.899]                     invisible(future)
[10:25:45.899]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:45.899]                 }
[10:25:45.899]             }
[10:25:45.899]         }
[10:25:45.899]     })
[10:25:45.899]     if (TRUE) {
[10:25:45.899]         base::sink(type = "output", split = FALSE)
[10:25:45.899]         if (TRUE) {
[10:25:45.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:45.899]         }
[10:25:45.899]         else {
[10:25:45.899]             ...future.result["stdout"] <- base::list(NULL)
[10:25:45.899]         }
[10:25:45.899]         base::close(...future.stdout)
[10:25:45.899]         ...future.stdout <- NULL
[10:25:45.899]     }
[10:25:45.899]     ...future.result$conditions <- ...future.conditions
[10:25:45.899]     ...future.result$finished <- base::Sys.time()
[10:25:45.899]     ...future.result
[10:25:45.899] }
[10:25:45.901] plan(): Setting new future strategy stack:
[10:25:45.901] List of future strategies:
[10:25:45.901] 1. sequential:
[10:25:45.901]    - args: function (..., envir = parent.frame())
[10:25:45.901]    - tweaked: FALSE
[10:25:45.901]    - call: NULL
[10:25:45.901] plan(): nbrOfWorkers() = 1
[10:25:45.902] plan(): Setting new future strategy stack:
[10:25:45.902] List of future strategies:
[10:25:45.902] 1. sequential:
[10:25:45.902]    - args: function (..., envir = parent.frame())
[10:25:45.902]    - tweaked: FALSE
[10:25:45.902]    - call: plan(strategy)
[10:25:45.903] plan(): nbrOfWorkers() = 1
[10:25:45.903] SequentialFuture started (and completed)
[10:25:45.903] - Launch lazy future ... done
[10:25:45.904] run() for ‘SequentialFuture’ ... done
[10:25:45.904] getGlobalsAndPackages() ...
[10:25:45.904] Searching for globals...
[10:25:45.904] 
[10:25:45.904] Searching for globals ... DONE
[10:25:45.904] - globals: [0] <none>
[10:25:45.904] getGlobalsAndPackages() ... DONE
[10:25:45.904] run() for ‘Future’ ...
[10:25:45.905] - state: ‘created’
[10:25:45.905] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:45.905] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:45.905] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:45.905]   - Field: ‘label’
[10:25:45.905]   - Field: ‘local’
[10:25:45.905]   - Field: ‘owner’
[10:25:45.905]   - Field: ‘envir’
[10:25:45.906]   - Field: ‘packages’
[10:25:45.906]   - Field: ‘gc’
[10:25:45.906]   - Field: ‘conditions’
[10:25:45.906]   - Field: ‘expr’
[10:25:45.906]   - Field: ‘uuid’
[10:25:45.906]   - Field: ‘seed’
[10:25:45.906]   - Field: ‘version’
[10:25:45.906]   - Field: ‘result’
[10:25:45.906]   - Field: ‘asynchronous’
[10:25:45.906]   - Field: ‘calls’
[10:25:45.906]   - Field: ‘globals’
[10:25:45.907]   - Field: ‘stdout’
[10:25:45.907]   - Field: ‘earlySignal’
[10:25:45.907]   - Field: ‘lazy’
[10:25:45.907]   - Field: ‘state’
[10:25:45.907] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:45.907] - Launch lazy future ...
[10:25:45.907] Packages needed by the future expression (n = 0): <none>
[10:25:45.907] Packages needed by future strategies (n = 0): <none>
[10:25:45.908] {
[10:25:45.908]     {
[10:25:45.908]         {
[10:25:45.908]             ...future.startTime <- base::Sys.time()
[10:25:45.908]             {
[10:25:45.908]                 {
[10:25:45.908]                   {
[10:25:45.908]                     base::local({
[10:25:45.908]                       has_future <- base::requireNamespace("future", 
[10:25:45.908]                         quietly = TRUE)
[10:25:45.908]                       if (has_future) {
[10:25:45.908]                         ns <- base::getNamespace("future")
[10:25:45.908]                         version <- ns[[".package"]][["version"]]
[10:25:45.908]                         if (is.null(version)) 
[10:25:45.908]                           version <- utils::packageVersion("future")
[10:25:45.908]                       }
[10:25:45.908]                       else {
[10:25:45.908]                         version <- NULL
[10:25:45.908]                       }
[10:25:45.908]                       if (!has_future || version < "1.8.0") {
[10:25:45.908]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:45.908]                           "", base::R.version$version.string), 
[10:25:45.908]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:45.908]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:45.908]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:45.908]                             "release", "version")], collapse = " "), 
[10:25:45.908]                           hostname = base::Sys.info()[["nodename"]])
[10:25:45.908]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:45.908]                           info)
[10:25:45.908]                         info <- base::paste(info, collapse = "; ")
[10:25:45.908]                         if (!has_future) {
[10:25:45.908]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:45.908]                             info)
[10:25:45.908]                         }
[10:25:45.908]                         else {
[10:25:45.908]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:45.908]                             info, version)
[10:25:45.908]                         }
[10:25:45.908]                         base::stop(msg)
[10:25:45.908]                       }
[10:25:45.908]                     })
[10:25:45.908]                   }
[10:25:45.908]                   options(future.plan = NULL)
[10:25:45.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:45.908]                 }
[10:25:45.908]                 ...future.workdir <- getwd()
[10:25:45.908]             }
[10:25:45.908]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:45.908]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:45.908]         }
[10:25:45.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:45.908]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:45.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:45.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:45.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:45.908]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:45.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:45.908]             base::names(...future.oldOptions))
[10:25:45.908]     }
[10:25:45.908]     if (FALSE) {
[10:25:45.908]     }
[10:25:45.908]     else {
[10:25:45.908]         if (TRUE) {
[10:25:45.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:45.908]                 open = "w")
[10:25:45.908]         }
[10:25:45.908]         else {
[10:25:45.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:45.908]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:45.908]         }
[10:25:45.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:45.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:45.908]             base::sink(type = "output", split = FALSE)
[10:25:45.908]             base::close(...future.stdout)
[10:25:45.908]         }, add = TRUE)
[10:25:45.908]     }
[10:25:45.908]     ...future.frame <- base::sys.nframe()
[10:25:45.908]     ...future.conditions <- base::list()
[10:25:45.908]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:45.908]     if (FALSE) {
[10:25:45.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:45.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:45.908]     }
[10:25:45.908]     ...future.result <- base::tryCatch({
[10:25:45.908]         base::withCallingHandlers({
[10:25:45.908]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:45.908]             future::FutureResult(value = ...future.value$value, 
[10:25:45.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.908]                   ...future.rng), globalenv = if (FALSE) 
[10:25:45.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:45.908]                     ...future.globalenv.names))
[10:25:45.908]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:45.908]         }, condition = base::local({
[10:25:45.908]             c <- base::c
[10:25:45.908]             inherits <- base::inherits
[10:25:45.908]             invokeRestart <- base::invokeRestart
[10:25:45.908]             length <- base::length
[10:25:45.908]             list <- base::list
[10:25:45.908]             seq.int <- base::seq.int
[10:25:45.908]             signalCondition <- base::signalCondition
[10:25:45.908]             sys.calls <- base::sys.calls
[10:25:45.908]             `[[` <- base::`[[`
[10:25:45.908]             `+` <- base::`+`
[10:25:45.908]             `<<-` <- base::`<<-`
[10:25:45.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:45.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:45.908]                   3L)]
[10:25:45.908]             }
[10:25:45.908]             function(cond) {
[10:25:45.908]                 is_error <- inherits(cond, "error")
[10:25:45.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:45.908]                   NULL)
[10:25:45.908]                 if (is_error) {
[10:25:45.908]                   sessionInformation <- function() {
[10:25:45.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:45.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:45.908]                       search = base::search(), system = base::Sys.info())
[10:25:45.908]                   }
[10:25:45.908]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:45.908]                     cond$call), session = sessionInformation(), 
[10:25:45.908]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:45.908]                   signalCondition(cond)
[10:25:45.908]                 }
[10:25:45.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:45.908]                 "immediateCondition"))) {
[10:25:45.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:45.908]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:45.908]                   if (TRUE && !signal) {
[10:25:45.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.908]                     {
[10:25:45.908]                       inherits <- base::inherits
[10:25:45.908]                       invokeRestart <- base::invokeRestart
[10:25:45.908]                       is.null <- base::is.null
[10:25:45.908]                       muffled <- FALSE
[10:25:45.908]                       if (inherits(cond, "message")) {
[10:25:45.908]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.908]                         if (muffled) 
[10:25:45.908]                           invokeRestart("muffleMessage")
[10:25:45.908]                       }
[10:25:45.908]                       else if (inherits(cond, "warning")) {
[10:25:45.908]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.908]                         if (muffled) 
[10:25:45.908]                           invokeRestart("muffleWarning")
[10:25:45.908]                       }
[10:25:45.908]                       else if (inherits(cond, "condition")) {
[10:25:45.908]                         if (!is.null(pattern)) {
[10:25:45.908]                           computeRestarts <- base::computeRestarts
[10:25:45.908]                           grepl <- base::grepl
[10:25:45.908]                           restarts <- computeRestarts(cond)
[10:25:45.908]                           for (restart in restarts) {
[10:25:45.908]                             name <- restart$name
[10:25:45.908]                             if (is.null(name)) 
[10:25:45.908]                               next
[10:25:45.908]                             if (!grepl(pattern, name)) 
[10:25:45.908]                               next
[10:25:45.908]                             invokeRestart(restart)
[10:25:45.908]                             muffled <- TRUE
[10:25:45.908]                             break
[10:25:45.908]                           }
[10:25:45.908]                         }
[10:25:45.908]                       }
[10:25:45.908]                       invisible(muffled)
[10:25:45.908]                     }
[10:25:45.908]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.908]                   }
[10:25:45.908]                 }
[10:25:45.908]                 else {
[10:25:45.908]                   if (TRUE) {
[10:25:45.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.908]                     {
[10:25:45.908]                       inherits <- base::inherits
[10:25:45.908]                       invokeRestart <- base::invokeRestart
[10:25:45.908]                       is.null <- base::is.null
[10:25:45.908]                       muffled <- FALSE
[10:25:45.908]                       if (inherits(cond, "message")) {
[10:25:45.908]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.908]                         if (muffled) 
[10:25:45.908]                           invokeRestart("muffleMessage")
[10:25:45.908]                       }
[10:25:45.908]                       else if (inherits(cond, "warning")) {
[10:25:45.908]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.908]                         if (muffled) 
[10:25:45.908]                           invokeRestart("muffleWarning")
[10:25:45.908]                       }
[10:25:45.908]                       else if (inherits(cond, "condition")) {
[10:25:45.908]                         if (!is.null(pattern)) {
[10:25:45.908]                           computeRestarts <- base::computeRestarts
[10:25:45.908]                           grepl <- base::grepl
[10:25:45.908]                           restarts <- computeRestarts(cond)
[10:25:45.908]                           for (restart in restarts) {
[10:25:45.908]                             name <- restart$name
[10:25:45.908]                             if (is.null(name)) 
[10:25:45.908]                               next
[10:25:45.908]                             if (!grepl(pattern, name)) 
[10:25:45.908]                               next
[10:25:45.908]                             invokeRestart(restart)
[10:25:45.908]                             muffled <- TRUE
[10:25:45.908]                             break
[10:25:45.908]                           }
[10:25:45.908]                         }
[10:25:45.908]                       }
[10:25:45.908]                       invisible(muffled)
[10:25:45.908]                     }
[10:25:45.908]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.908]                   }
[10:25:45.908]                 }
[10:25:45.908]             }
[10:25:45.908]         }))
[10:25:45.908]     }, error = function(ex) {
[10:25:45.908]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:45.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.908]                 ...future.rng), started = ...future.startTime, 
[10:25:45.908]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:45.908]             version = "1.8"), class = "FutureResult")
[10:25:45.908]     }, finally = {
[10:25:45.908]         if (!identical(...future.workdir, getwd())) 
[10:25:45.908]             setwd(...future.workdir)
[10:25:45.908]         {
[10:25:45.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:45.908]                 ...future.oldOptions$nwarnings <- NULL
[10:25:45.908]             }
[10:25:45.908]             base::options(...future.oldOptions)
[10:25:45.908]             if (.Platform$OS.type == "windows") {
[10:25:45.908]                 old_names <- names(...future.oldEnvVars)
[10:25:45.908]                 envs <- base::Sys.getenv()
[10:25:45.908]                 names <- names(envs)
[10:25:45.908]                 common <- intersect(names, old_names)
[10:25:45.908]                 added <- setdiff(names, old_names)
[10:25:45.908]                 removed <- setdiff(old_names, names)
[10:25:45.908]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:45.908]                   envs[common]]
[10:25:45.908]                 NAMES <- toupper(changed)
[10:25:45.908]                 args <- list()
[10:25:45.908]                 for (kk in seq_along(NAMES)) {
[10:25:45.908]                   name <- changed[[kk]]
[10:25:45.908]                   NAME <- NAMES[[kk]]
[10:25:45.908]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.908]                     next
[10:25:45.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.908]                 }
[10:25:45.908]                 NAMES <- toupper(added)
[10:25:45.908]                 for (kk in seq_along(NAMES)) {
[10:25:45.908]                   name <- added[[kk]]
[10:25:45.908]                   NAME <- NAMES[[kk]]
[10:25:45.908]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.908]                     next
[10:25:45.908]                   args[[name]] <- ""
[10:25:45.908]                 }
[10:25:45.908]                 NAMES <- toupper(removed)
[10:25:45.908]                 for (kk in seq_along(NAMES)) {
[10:25:45.908]                   name <- removed[[kk]]
[10:25:45.908]                   NAME <- NAMES[[kk]]
[10:25:45.908]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.908]                     next
[10:25:45.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.908]                 }
[10:25:45.908]                 if (length(args) > 0) 
[10:25:45.908]                   base::do.call(base::Sys.setenv, args = args)
[10:25:45.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:45.908]             }
[10:25:45.908]             else {
[10:25:45.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:45.908]             }
[10:25:45.908]             {
[10:25:45.908]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:45.908]                   0L) {
[10:25:45.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:45.908]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:45.908]                   base::options(opts)
[10:25:45.908]                 }
[10:25:45.908]                 {
[10:25:45.908]                   {
[10:25:45.908]                     NULL
[10:25:45.908]                     RNGkind("Mersenne-Twister")
[10:25:45.908]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:45.908]                       inherits = FALSE)
[10:25:45.908]                   }
[10:25:45.908]                   options(future.plan = NULL)
[10:25:45.908]                   if (is.na(NA_character_)) 
[10:25:45.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:45.908]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:45.908]                   {
[10:25:45.908]                     future <- SequentialFuture(..., envir = envir)
[10:25:45.908]                     if (!future$lazy) 
[10:25:45.908]                       future <- run(future)
[10:25:45.908]                     invisible(future)
[10:25:45.908]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:45.908]                 }
[10:25:45.908]             }
[10:25:45.908]         }
[10:25:45.908]     })
[10:25:45.908]     if (TRUE) {
[10:25:45.908]         base::sink(type = "output", split = FALSE)
[10:25:45.908]         if (TRUE) {
[10:25:45.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:45.908]         }
[10:25:45.908]         else {
[10:25:45.908]             ...future.result["stdout"] <- base::list(NULL)
[10:25:45.908]         }
[10:25:45.908]         base::close(...future.stdout)
[10:25:45.908]         ...future.stdout <- NULL
[10:25:45.908]     }
[10:25:45.908]     ...future.result$conditions <- ...future.conditions
[10:25:45.908]     ...future.result$finished <- base::Sys.time()
[10:25:45.908]     ...future.result
[10:25:45.908] }
[10:25:45.909] plan(): Setting new future strategy stack:
[10:25:45.909] List of future strategies:
[10:25:45.909] 1. sequential:
[10:25:45.909]    - args: function (..., envir = parent.frame())
[10:25:45.909]    - tweaked: FALSE
[10:25:45.909]    - call: NULL
[10:25:45.910] plan(): nbrOfWorkers() = 1
[10:25:45.910] plan(): Setting new future strategy stack:
[10:25:45.911] List of future strategies:
[10:25:45.911] 1. sequential:
[10:25:45.911]    - args: function (..., envir = parent.frame())
[10:25:45.911]    - tweaked: FALSE
[10:25:45.911]    - call: plan(strategy)
[10:25:45.911] plan(): nbrOfWorkers() = 1
[10:25:45.911] SequentialFuture started (and completed)
[10:25:45.911] - Launch lazy future ... done
[10:25:45.911] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f4737c30> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f4eeced8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f4737c30> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f4eeced8> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:25:45.917] resolved() for ‘SequentialFuture’ ...
[10:25:45.918] - state: ‘finished’
[10:25:45.918] - run: TRUE
[10:25:45.918] - result: ‘FutureResult’
[10:25:45.918] resolved() for ‘SequentialFuture’ ... done
[10:25:45.918] resolved() for ‘SequentialFuture’ ...
[10:25:45.918] - state: ‘finished’
[10:25:45.918] - run: TRUE
[10:25:45.918] - result: ‘FutureResult’
[10:25:45.918] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:45.919] resolve() on list ...
[10:25:45.919]  recursive: 0
[10:25:45.920]  length: 6
[10:25:45.920]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:45.920] signalConditionsASAP(numeric, pos=1) ...
[10:25:45.920] - nx: 6
[10:25:45.920] - relay: TRUE
[10:25:45.920] - stdout: TRUE
[10:25:45.920] - signal: TRUE
[10:25:45.920] - resignal: FALSE
[10:25:45.920] - force: TRUE
[10:25:45.920] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.921] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.921]  - until=2
[10:25:45.921]  - relaying element #2
[10:25:45.921] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.921] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.921] signalConditionsASAP(NULL, pos=1) ... done
[10:25:45.921]  length: 5 (resolved future 1)
[10:25:45.921] resolved() for ‘SequentialFuture’ ...
[10:25:45.921] - state: ‘finished’
[10:25:45.921] - run: TRUE
[10:25:45.922] - result: ‘FutureResult’
[10:25:45.922] resolved() for ‘SequentialFuture’ ... done
[10:25:45.922] Future #2
[10:25:45.922] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:45.922] - nx: 6
[10:25:45.922] - relay: TRUE
[10:25:45.922] - stdout: TRUE
[10:25:45.922] - signal: TRUE
[10:25:45.923] - resignal: FALSE
[10:25:45.923] - force: TRUE
[10:25:45.923] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.923] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.923]  - until=2
[10:25:45.923]  - relaying element #2
[10:25:45.923] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.923] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.923] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:45.924]  length: 4 (resolved future 2)
[10:25:45.924] resolved() for ‘SequentialFuture’ ...
[10:25:45.926] - state: ‘finished’
[10:25:45.926] - run: TRUE
[10:25:45.926] - result: ‘FutureResult’
[10:25:45.926] resolved() for ‘SequentialFuture’ ... done
[10:25:45.926] Future #3
[10:25:45.926] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:45.926] - nx: 6
[10:25:45.926] - relay: TRUE
[10:25:45.926] - stdout: TRUE
[10:25:45.927] - signal: TRUE
[10:25:45.927] - resignal: FALSE
[10:25:45.927] - force: TRUE
[10:25:45.927] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.927] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.927]  - until=3
[10:25:45.927]  - relaying element #3
[10:25:45.927] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.927] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.927] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:45.928]  length: 3 (resolved future 3)
[10:25:45.928] signalConditionsASAP(NULL, pos=4) ...
[10:25:45.928] - nx: 6
[10:25:45.928] - relay: TRUE
[10:25:45.928] - stdout: TRUE
[10:25:45.928] - signal: TRUE
[10:25:45.928] - resignal: FALSE
[10:25:45.928] - force: TRUE
[10:25:45.928] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.928] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.928]  - until=5
[10:25:45.928]  - relaying element #5
[10:25:45.929] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:45.929] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.929] signalConditionsASAP(NULL, pos=4) ... done
[10:25:45.929]  length: 2 (resolved future 4)
[10:25:45.929] signalConditionsASAP(NULL, pos=5) ...
[10:25:45.929] - nx: 6
[10:25:45.929] - relay: TRUE
[10:25:45.929] - stdout: TRUE
[10:25:45.929] - signal: TRUE
[10:25:45.929] - resignal: FALSE
[10:25:45.929] - force: TRUE
[10:25:45.929] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:45.930] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.930]  - until=6
[10:25:45.930]  - relaying element #6
[10:25:45.930] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:45.930] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.930] signalConditionsASAP(NULL, pos=5) ... done
[10:25:45.930]  length: 1 (resolved future 5)
[10:25:45.930] signalConditionsASAP(numeric, pos=6) ...
[10:25:45.930] - nx: 6
[10:25:45.930] - relay: TRUE
[10:25:45.930] - stdout: TRUE
[10:25:45.931] - signal: TRUE
[10:25:45.931] - resignal: FALSE
[10:25:45.931] - force: TRUE
[10:25:45.931] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:45.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.931]  - until=6
[10:25:45.931] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:45.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.931] signalConditionsASAP(numeric, pos=6) ... done
[10:25:45.931]  length: 0 (resolved future 6)
[10:25:45.931] Relaying remaining futures
[10:25:45.931] signalConditionsASAP(NULL, pos=0) ...
[10:25:45.932] - nx: 6
[10:25:45.932] - relay: TRUE
[10:25:45.932] - stdout: TRUE
[10:25:45.932] - signal: TRUE
[10:25:45.932] - resignal: FALSE
[10:25:45.932] - force: TRUE
[10:25:45.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:45.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:45.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:45.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.932] signalConditionsASAP(NULL, pos=0) ... done
[10:25:45.932] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[10:25:45.935] getGlobalsAndPackages() ...
[10:25:45.935] Searching for globals...
[10:25:45.935] 
[10:25:45.935] Searching for globals ... DONE
[10:25:45.935] - globals: [0] <none>
[10:25:45.935] getGlobalsAndPackages() ... DONE
[10:25:45.935] run() for ‘Future’ ...
[10:25:45.935] - state: ‘created’
[10:25:45.936] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:45.936] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:45.936] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:45.936]   - Field: ‘label’
[10:25:45.936]   - Field: ‘local’
[10:25:45.936]   - Field: ‘owner’
[10:25:45.936]   - Field: ‘envir’
[10:25:45.936]   - Field: ‘packages’
[10:25:45.937]   - Field: ‘gc’
[10:25:45.937]   - Field: ‘conditions’
[10:25:45.937]   - Field: ‘expr’
[10:25:45.937]   - Field: ‘uuid’
[10:25:45.937]   - Field: ‘seed’
[10:25:45.937]   - Field: ‘version’
[10:25:45.937]   - Field: ‘result’
[10:25:45.937]   - Field: ‘asynchronous’
[10:25:45.937]   - Field: ‘calls’
[10:25:45.937]   - Field: ‘globals’
[10:25:45.937]   - Field: ‘stdout’
[10:25:45.938]   - Field: ‘earlySignal’
[10:25:45.938]   - Field: ‘lazy’
[10:25:45.938]   - Field: ‘state’
[10:25:45.938] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:45.938] - Launch lazy future ...
[10:25:45.938] Packages needed by the future expression (n = 0): <none>
[10:25:45.938] Packages needed by future strategies (n = 0): <none>
[10:25:45.939] {
[10:25:45.939]     {
[10:25:45.939]         {
[10:25:45.939]             ...future.startTime <- base::Sys.time()
[10:25:45.939]             {
[10:25:45.939]                 {
[10:25:45.939]                   {
[10:25:45.939]                     base::local({
[10:25:45.939]                       has_future <- base::requireNamespace("future", 
[10:25:45.939]                         quietly = TRUE)
[10:25:45.939]                       if (has_future) {
[10:25:45.939]                         ns <- base::getNamespace("future")
[10:25:45.939]                         version <- ns[[".package"]][["version"]]
[10:25:45.939]                         if (is.null(version)) 
[10:25:45.939]                           version <- utils::packageVersion("future")
[10:25:45.939]                       }
[10:25:45.939]                       else {
[10:25:45.939]                         version <- NULL
[10:25:45.939]                       }
[10:25:45.939]                       if (!has_future || version < "1.8.0") {
[10:25:45.939]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:45.939]                           "", base::R.version$version.string), 
[10:25:45.939]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:45.939]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:45.939]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:45.939]                             "release", "version")], collapse = " "), 
[10:25:45.939]                           hostname = base::Sys.info()[["nodename"]])
[10:25:45.939]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:45.939]                           info)
[10:25:45.939]                         info <- base::paste(info, collapse = "; ")
[10:25:45.939]                         if (!has_future) {
[10:25:45.939]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:45.939]                             info)
[10:25:45.939]                         }
[10:25:45.939]                         else {
[10:25:45.939]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:45.939]                             info, version)
[10:25:45.939]                         }
[10:25:45.939]                         base::stop(msg)
[10:25:45.939]                       }
[10:25:45.939]                     })
[10:25:45.939]                   }
[10:25:45.939]                   options(future.plan = NULL)
[10:25:45.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:45.939]                 }
[10:25:45.939]                 ...future.workdir <- getwd()
[10:25:45.939]             }
[10:25:45.939]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:45.939]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:45.939]         }
[10:25:45.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:45.939]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:45.939]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:45.939]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:45.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:45.939]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:45.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:45.939]             base::names(...future.oldOptions))
[10:25:45.939]     }
[10:25:45.939]     if (FALSE) {
[10:25:45.939]     }
[10:25:45.939]     else {
[10:25:45.939]         if (TRUE) {
[10:25:45.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:45.939]                 open = "w")
[10:25:45.939]         }
[10:25:45.939]         else {
[10:25:45.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:45.939]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:45.939]         }
[10:25:45.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:45.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:45.939]             base::sink(type = "output", split = FALSE)
[10:25:45.939]             base::close(...future.stdout)
[10:25:45.939]         }, add = TRUE)
[10:25:45.939]     }
[10:25:45.939]     ...future.frame <- base::sys.nframe()
[10:25:45.939]     ...future.conditions <- base::list()
[10:25:45.939]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:45.939]     if (FALSE) {
[10:25:45.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:45.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:45.939]     }
[10:25:45.939]     ...future.result <- base::tryCatch({
[10:25:45.939]         base::withCallingHandlers({
[10:25:45.939]             ...future.value <- base::withVisible(base::local(2))
[10:25:45.939]             future::FutureResult(value = ...future.value$value, 
[10:25:45.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.939]                   ...future.rng), globalenv = if (FALSE) 
[10:25:45.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:45.939]                     ...future.globalenv.names))
[10:25:45.939]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:45.939]         }, condition = base::local({
[10:25:45.939]             c <- base::c
[10:25:45.939]             inherits <- base::inherits
[10:25:45.939]             invokeRestart <- base::invokeRestart
[10:25:45.939]             length <- base::length
[10:25:45.939]             list <- base::list
[10:25:45.939]             seq.int <- base::seq.int
[10:25:45.939]             signalCondition <- base::signalCondition
[10:25:45.939]             sys.calls <- base::sys.calls
[10:25:45.939]             `[[` <- base::`[[`
[10:25:45.939]             `+` <- base::`+`
[10:25:45.939]             `<<-` <- base::`<<-`
[10:25:45.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:45.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:45.939]                   3L)]
[10:25:45.939]             }
[10:25:45.939]             function(cond) {
[10:25:45.939]                 is_error <- inherits(cond, "error")
[10:25:45.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:45.939]                   NULL)
[10:25:45.939]                 if (is_error) {
[10:25:45.939]                   sessionInformation <- function() {
[10:25:45.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:45.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:45.939]                       search = base::search(), system = base::Sys.info())
[10:25:45.939]                   }
[10:25:45.939]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:45.939]                     cond$call), session = sessionInformation(), 
[10:25:45.939]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:45.939]                   signalCondition(cond)
[10:25:45.939]                 }
[10:25:45.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:45.939]                 "immediateCondition"))) {
[10:25:45.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:45.939]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:45.939]                   if (TRUE && !signal) {
[10:25:45.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.939]                     {
[10:25:45.939]                       inherits <- base::inherits
[10:25:45.939]                       invokeRestart <- base::invokeRestart
[10:25:45.939]                       is.null <- base::is.null
[10:25:45.939]                       muffled <- FALSE
[10:25:45.939]                       if (inherits(cond, "message")) {
[10:25:45.939]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.939]                         if (muffled) 
[10:25:45.939]                           invokeRestart("muffleMessage")
[10:25:45.939]                       }
[10:25:45.939]                       else if (inherits(cond, "warning")) {
[10:25:45.939]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.939]                         if (muffled) 
[10:25:45.939]                           invokeRestart("muffleWarning")
[10:25:45.939]                       }
[10:25:45.939]                       else if (inherits(cond, "condition")) {
[10:25:45.939]                         if (!is.null(pattern)) {
[10:25:45.939]                           computeRestarts <- base::computeRestarts
[10:25:45.939]                           grepl <- base::grepl
[10:25:45.939]                           restarts <- computeRestarts(cond)
[10:25:45.939]                           for (restart in restarts) {
[10:25:45.939]                             name <- restart$name
[10:25:45.939]                             if (is.null(name)) 
[10:25:45.939]                               next
[10:25:45.939]                             if (!grepl(pattern, name)) 
[10:25:45.939]                               next
[10:25:45.939]                             invokeRestart(restart)
[10:25:45.939]                             muffled <- TRUE
[10:25:45.939]                             break
[10:25:45.939]                           }
[10:25:45.939]                         }
[10:25:45.939]                       }
[10:25:45.939]                       invisible(muffled)
[10:25:45.939]                     }
[10:25:45.939]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.939]                   }
[10:25:45.939]                 }
[10:25:45.939]                 else {
[10:25:45.939]                   if (TRUE) {
[10:25:45.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.939]                     {
[10:25:45.939]                       inherits <- base::inherits
[10:25:45.939]                       invokeRestart <- base::invokeRestart
[10:25:45.939]                       is.null <- base::is.null
[10:25:45.939]                       muffled <- FALSE
[10:25:45.939]                       if (inherits(cond, "message")) {
[10:25:45.939]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.939]                         if (muffled) 
[10:25:45.939]                           invokeRestart("muffleMessage")
[10:25:45.939]                       }
[10:25:45.939]                       else if (inherits(cond, "warning")) {
[10:25:45.939]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.939]                         if (muffled) 
[10:25:45.939]                           invokeRestart("muffleWarning")
[10:25:45.939]                       }
[10:25:45.939]                       else if (inherits(cond, "condition")) {
[10:25:45.939]                         if (!is.null(pattern)) {
[10:25:45.939]                           computeRestarts <- base::computeRestarts
[10:25:45.939]                           grepl <- base::grepl
[10:25:45.939]                           restarts <- computeRestarts(cond)
[10:25:45.939]                           for (restart in restarts) {
[10:25:45.939]                             name <- restart$name
[10:25:45.939]                             if (is.null(name)) 
[10:25:45.939]                               next
[10:25:45.939]                             if (!grepl(pattern, name)) 
[10:25:45.939]                               next
[10:25:45.939]                             invokeRestart(restart)
[10:25:45.939]                             muffled <- TRUE
[10:25:45.939]                             break
[10:25:45.939]                           }
[10:25:45.939]                         }
[10:25:45.939]                       }
[10:25:45.939]                       invisible(muffled)
[10:25:45.939]                     }
[10:25:45.939]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.939]                   }
[10:25:45.939]                 }
[10:25:45.939]             }
[10:25:45.939]         }))
[10:25:45.939]     }, error = function(ex) {
[10:25:45.939]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:45.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.939]                 ...future.rng), started = ...future.startTime, 
[10:25:45.939]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:45.939]             version = "1.8"), class = "FutureResult")
[10:25:45.939]     }, finally = {
[10:25:45.939]         if (!identical(...future.workdir, getwd())) 
[10:25:45.939]             setwd(...future.workdir)
[10:25:45.939]         {
[10:25:45.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:45.939]                 ...future.oldOptions$nwarnings <- NULL
[10:25:45.939]             }
[10:25:45.939]             base::options(...future.oldOptions)
[10:25:45.939]             if (.Platform$OS.type == "windows") {
[10:25:45.939]                 old_names <- names(...future.oldEnvVars)
[10:25:45.939]                 envs <- base::Sys.getenv()
[10:25:45.939]                 names <- names(envs)
[10:25:45.939]                 common <- intersect(names, old_names)
[10:25:45.939]                 added <- setdiff(names, old_names)
[10:25:45.939]                 removed <- setdiff(old_names, names)
[10:25:45.939]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:45.939]                   envs[common]]
[10:25:45.939]                 NAMES <- toupper(changed)
[10:25:45.939]                 args <- list()
[10:25:45.939]                 for (kk in seq_along(NAMES)) {
[10:25:45.939]                   name <- changed[[kk]]
[10:25:45.939]                   NAME <- NAMES[[kk]]
[10:25:45.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.939]                     next
[10:25:45.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.939]                 }
[10:25:45.939]                 NAMES <- toupper(added)
[10:25:45.939]                 for (kk in seq_along(NAMES)) {
[10:25:45.939]                   name <- added[[kk]]
[10:25:45.939]                   NAME <- NAMES[[kk]]
[10:25:45.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.939]                     next
[10:25:45.939]                   args[[name]] <- ""
[10:25:45.939]                 }
[10:25:45.939]                 NAMES <- toupper(removed)
[10:25:45.939]                 for (kk in seq_along(NAMES)) {
[10:25:45.939]                   name <- removed[[kk]]
[10:25:45.939]                   NAME <- NAMES[[kk]]
[10:25:45.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.939]                     next
[10:25:45.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.939]                 }
[10:25:45.939]                 if (length(args) > 0) 
[10:25:45.939]                   base::do.call(base::Sys.setenv, args = args)
[10:25:45.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:45.939]             }
[10:25:45.939]             else {
[10:25:45.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:45.939]             }
[10:25:45.939]             {
[10:25:45.939]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:45.939]                   0L) {
[10:25:45.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:45.939]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:45.939]                   base::options(opts)
[10:25:45.939]                 }
[10:25:45.939]                 {
[10:25:45.939]                   {
[10:25:45.939]                     NULL
[10:25:45.939]                     RNGkind("Mersenne-Twister")
[10:25:45.939]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:45.939]                       inherits = FALSE)
[10:25:45.939]                   }
[10:25:45.939]                   options(future.plan = NULL)
[10:25:45.939]                   if (is.na(NA_character_)) 
[10:25:45.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:45.939]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:45.939]                   {
[10:25:45.939]                     future <- SequentialFuture(..., envir = envir)
[10:25:45.939]                     if (!future$lazy) 
[10:25:45.939]                       future <- run(future)
[10:25:45.939]                     invisible(future)
[10:25:45.939]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:45.939]                 }
[10:25:45.939]             }
[10:25:45.939]         }
[10:25:45.939]     })
[10:25:45.939]     if (TRUE) {
[10:25:45.939]         base::sink(type = "output", split = FALSE)
[10:25:45.939]         if (TRUE) {
[10:25:45.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:45.939]         }
[10:25:45.939]         else {
[10:25:45.939]             ...future.result["stdout"] <- base::list(NULL)
[10:25:45.939]         }
[10:25:45.939]         base::close(...future.stdout)
[10:25:45.939]         ...future.stdout <- NULL
[10:25:45.939]     }
[10:25:45.939]     ...future.result$conditions <- ...future.conditions
[10:25:45.939]     ...future.result$finished <- base::Sys.time()
[10:25:45.939]     ...future.result
[10:25:45.939] }
[10:25:45.940] plan(): Setting new future strategy stack:
[10:25:45.940] List of future strategies:
[10:25:45.940] 1. sequential:
[10:25:45.940]    - args: function (..., envir = parent.frame())
[10:25:45.940]    - tweaked: FALSE
[10:25:45.940]    - call: NULL
[10:25:45.941] plan(): nbrOfWorkers() = 1
[10:25:45.941] plan(): Setting new future strategy stack:
[10:25:45.942] List of future strategies:
[10:25:45.942] 1. sequential:
[10:25:45.942]    - args: function (..., envir = parent.frame())
[10:25:45.942]    - tweaked: FALSE
[10:25:45.942]    - call: plan(strategy)
[10:25:45.942] plan(): nbrOfWorkers() = 1
[10:25:45.942] SequentialFuture started (and completed)
[10:25:45.942] - Launch lazy future ... done
[10:25:45.942] run() for ‘SequentialFuture’ ... done
[10:25:45.942] getGlobalsAndPackages() ...
[10:25:45.942] Searching for globals...
[10:25:45.943] 
[10:25:45.943] Searching for globals ... DONE
[10:25:45.943] - globals: [0] <none>
[10:25:45.943] getGlobalsAndPackages() ... DONE
[10:25:45.943] run() for ‘Future’ ...
[10:25:45.943] - state: ‘created’
[10:25:45.943] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:45.944] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:45.944] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:45.944]   - Field: ‘label’
[10:25:45.944]   - Field: ‘local’
[10:25:45.944]   - Field: ‘owner’
[10:25:45.944]   - Field: ‘envir’
[10:25:45.944]   - Field: ‘packages’
[10:25:45.944]   - Field: ‘gc’
[10:25:45.944]   - Field: ‘conditions’
[10:25:45.945]   - Field: ‘expr’
[10:25:45.945]   - Field: ‘uuid’
[10:25:45.945]   - Field: ‘seed’
[10:25:45.945]   - Field: ‘version’
[10:25:45.945]   - Field: ‘result’
[10:25:45.945]   - Field: ‘asynchronous’
[10:25:45.945]   - Field: ‘calls’
[10:25:45.945]   - Field: ‘globals’
[10:25:45.945]   - Field: ‘stdout’
[10:25:45.945]   - Field: ‘earlySignal’
[10:25:45.945]   - Field: ‘lazy’
[10:25:45.946]   - Field: ‘state’
[10:25:45.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:45.946] - Launch lazy future ...
[10:25:45.946] Packages needed by the future expression (n = 0): <none>
[10:25:45.946] Packages needed by future strategies (n = 0): <none>
[10:25:45.946] {
[10:25:45.946]     {
[10:25:45.946]         {
[10:25:45.946]             ...future.startTime <- base::Sys.time()
[10:25:45.946]             {
[10:25:45.946]                 {
[10:25:45.946]                   {
[10:25:45.946]                     base::local({
[10:25:45.946]                       has_future <- base::requireNamespace("future", 
[10:25:45.946]                         quietly = TRUE)
[10:25:45.946]                       if (has_future) {
[10:25:45.946]                         ns <- base::getNamespace("future")
[10:25:45.946]                         version <- ns[[".package"]][["version"]]
[10:25:45.946]                         if (is.null(version)) 
[10:25:45.946]                           version <- utils::packageVersion("future")
[10:25:45.946]                       }
[10:25:45.946]                       else {
[10:25:45.946]                         version <- NULL
[10:25:45.946]                       }
[10:25:45.946]                       if (!has_future || version < "1.8.0") {
[10:25:45.946]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:45.946]                           "", base::R.version$version.string), 
[10:25:45.946]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:45.946]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:45.946]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:45.946]                             "release", "version")], collapse = " "), 
[10:25:45.946]                           hostname = base::Sys.info()[["nodename"]])
[10:25:45.946]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:45.946]                           info)
[10:25:45.946]                         info <- base::paste(info, collapse = "; ")
[10:25:45.946]                         if (!has_future) {
[10:25:45.946]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:45.946]                             info)
[10:25:45.946]                         }
[10:25:45.946]                         else {
[10:25:45.946]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:45.946]                             info, version)
[10:25:45.946]                         }
[10:25:45.946]                         base::stop(msg)
[10:25:45.946]                       }
[10:25:45.946]                     })
[10:25:45.946]                   }
[10:25:45.946]                   options(future.plan = NULL)
[10:25:45.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:45.946]                 }
[10:25:45.946]                 ...future.workdir <- getwd()
[10:25:45.946]             }
[10:25:45.946]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:45.946]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:45.946]         }
[10:25:45.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:45.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:45.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:45.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:45.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:45.946]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:45.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:45.946]             base::names(...future.oldOptions))
[10:25:45.946]     }
[10:25:45.946]     if (FALSE) {
[10:25:45.946]     }
[10:25:45.946]     else {
[10:25:45.946]         if (TRUE) {
[10:25:45.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:45.946]                 open = "w")
[10:25:45.946]         }
[10:25:45.946]         else {
[10:25:45.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:45.946]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:45.946]         }
[10:25:45.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:45.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:45.946]             base::sink(type = "output", split = FALSE)
[10:25:45.946]             base::close(...future.stdout)
[10:25:45.946]         }, add = TRUE)
[10:25:45.946]     }
[10:25:45.946]     ...future.frame <- base::sys.nframe()
[10:25:45.946]     ...future.conditions <- base::list()
[10:25:45.946]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:45.946]     if (FALSE) {
[10:25:45.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:45.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:45.946]     }
[10:25:45.946]     ...future.result <- base::tryCatch({
[10:25:45.946]         base::withCallingHandlers({
[10:25:45.946]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:45.946]             future::FutureResult(value = ...future.value$value, 
[10:25:45.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.946]                   ...future.rng), globalenv = if (FALSE) 
[10:25:45.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:45.946]                     ...future.globalenv.names))
[10:25:45.946]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:45.946]         }, condition = base::local({
[10:25:45.946]             c <- base::c
[10:25:45.946]             inherits <- base::inherits
[10:25:45.946]             invokeRestart <- base::invokeRestart
[10:25:45.946]             length <- base::length
[10:25:45.946]             list <- base::list
[10:25:45.946]             seq.int <- base::seq.int
[10:25:45.946]             signalCondition <- base::signalCondition
[10:25:45.946]             sys.calls <- base::sys.calls
[10:25:45.946]             `[[` <- base::`[[`
[10:25:45.946]             `+` <- base::`+`
[10:25:45.946]             `<<-` <- base::`<<-`
[10:25:45.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:45.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:45.946]                   3L)]
[10:25:45.946]             }
[10:25:45.946]             function(cond) {
[10:25:45.946]                 is_error <- inherits(cond, "error")
[10:25:45.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:45.946]                   NULL)
[10:25:45.946]                 if (is_error) {
[10:25:45.946]                   sessionInformation <- function() {
[10:25:45.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:45.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:45.946]                       search = base::search(), system = base::Sys.info())
[10:25:45.946]                   }
[10:25:45.946]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:45.946]                     cond$call), session = sessionInformation(), 
[10:25:45.946]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:45.946]                   signalCondition(cond)
[10:25:45.946]                 }
[10:25:45.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:45.946]                 "immediateCondition"))) {
[10:25:45.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:45.946]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:45.946]                   if (TRUE && !signal) {
[10:25:45.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.946]                     {
[10:25:45.946]                       inherits <- base::inherits
[10:25:45.946]                       invokeRestart <- base::invokeRestart
[10:25:45.946]                       is.null <- base::is.null
[10:25:45.946]                       muffled <- FALSE
[10:25:45.946]                       if (inherits(cond, "message")) {
[10:25:45.946]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.946]                         if (muffled) 
[10:25:45.946]                           invokeRestart("muffleMessage")
[10:25:45.946]                       }
[10:25:45.946]                       else if (inherits(cond, "warning")) {
[10:25:45.946]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.946]                         if (muffled) 
[10:25:45.946]                           invokeRestart("muffleWarning")
[10:25:45.946]                       }
[10:25:45.946]                       else if (inherits(cond, "condition")) {
[10:25:45.946]                         if (!is.null(pattern)) {
[10:25:45.946]                           computeRestarts <- base::computeRestarts
[10:25:45.946]                           grepl <- base::grepl
[10:25:45.946]                           restarts <- computeRestarts(cond)
[10:25:45.946]                           for (restart in restarts) {
[10:25:45.946]                             name <- restart$name
[10:25:45.946]                             if (is.null(name)) 
[10:25:45.946]                               next
[10:25:45.946]                             if (!grepl(pattern, name)) 
[10:25:45.946]                               next
[10:25:45.946]                             invokeRestart(restart)
[10:25:45.946]                             muffled <- TRUE
[10:25:45.946]                             break
[10:25:45.946]                           }
[10:25:45.946]                         }
[10:25:45.946]                       }
[10:25:45.946]                       invisible(muffled)
[10:25:45.946]                     }
[10:25:45.946]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.946]                   }
[10:25:45.946]                 }
[10:25:45.946]                 else {
[10:25:45.946]                   if (TRUE) {
[10:25:45.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.946]                     {
[10:25:45.946]                       inherits <- base::inherits
[10:25:45.946]                       invokeRestart <- base::invokeRestart
[10:25:45.946]                       is.null <- base::is.null
[10:25:45.946]                       muffled <- FALSE
[10:25:45.946]                       if (inherits(cond, "message")) {
[10:25:45.946]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.946]                         if (muffled) 
[10:25:45.946]                           invokeRestart("muffleMessage")
[10:25:45.946]                       }
[10:25:45.946]                       else if (inherits(cond, "warning")) {
[10:25:45.946]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.946]                         if (muffled) 
[10:25:45.946]                           invokeRestart("muffleWarning")
[10:25:45.946]                       }
[10:25:45.946]                       else if (inherits(cond, "condition")) {
[10:25:45.946]                         if (!is.null(pattern)) {
[10:25:45.946]                           computeRestarts <- base::computeRestarts
[10:25:45.946]                           grepl <- base::grepl
[10:25:45.946]                           restarts <- computeRestarts(cond)
[10:25:45.946]                           for (restart in restarts) {
[10:25:45.946]                             name <- restart$name
[10:25:45.946]                             if (is.null(name)) 
[10:25:45.946]                               next
[10:25:45.946]                             if (!grepl(pattern, name)) 
[10:25:45.946]                               next
[10:25:45.946]                             invokeRestart(restart)
[10:25:45.946]                             muffled <- TRUE
[10:25:45.946]                             break
[10:25:45.946]                           }
[10:25:45.946]                         }
[10:25:45.946]                       }
[10:25:45.946]                       invisible(muffled)
[10:25:45.946]                     }
[10:25:45.946]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.946]                   }
[10:25:45.946]                 }
[10:25:45.946]             }
[10:25:45.946]         }))
[10:25:45.946]     }, error = function(ex) {
[10:25:45.946]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:45.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.946]                 ...future.rng), started = ...future.startTime, 
[10:25:45.946]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:45.946]             version = "1.8"), class = "FutureResult")
[10:25:45.946]     }, finally = {
[10:25:45.946]         if (!identical(...future.workdir, getwd())) 
[10:25:45.946]             setwd(...future.workdir)
[10:25:45.946]         {
[10:25:45.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:45.946]                 ...future.oldOptions$nwarnings <- NULL
[10:25:45.946]             }
[10:25:45.946]             base::options(...future.oldOptions)
[10:25:45.946]             if (.Platform$OS.type == "windows") {
[10:25:45.946]                 old_names <- names(...future.oldEnvVars)
[10:25:45.946]                 envs <- base::Sys.getenv()
[10:25:45.946]                 names <- names(envs)
[10:25:45.946]                 common <- intersect(names, old_names)
[10:25:45.946]                 added <- setdiff(names, old_names)
[10:25:45.946]                 removed <- setdiff(old_names, names)
[10:25:45.946]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:45.946]                   envs[common]]
[10:25:45.946]                 NAMES <- toupper(changed)
[10:25:45.946]                 args <- list()
[10:25:45.946]                 for (kk in seq_along(NAMES)) {
[10:25:45.946]                   name <- changed[[kk]]
[10:25:45.946]                   NAME <- NAMES[[kk]]
[10:25:45.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.946]                     next
[10:25:45.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.946]                 }
[10:25:45.946]                 NAMES <- toupper(added)
[10:25:45.946]                 for (kk in seq_along(NAMES)) {
[10:25:45.946]                   name <- added[[kk]]
[10:25:45.946]                   NAME <- NAMES[[kk]]
[10:25:45.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.946]                     next
[10:25:45.946]                   args[[name]] <- ""
[10:25:45.946]                 }
[10:25:45.946]                 NAMES <- toupper(removed)
[10:25:45.946]                 for (kk in seq_along(NAMES)) {
[10:25:45.946]                   name <- removed[[kk]]
[10:25:45.946]                   NAME <- NAMES[[kk]]
[10:25:45.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.946]                     next
[10:25:45.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.946]                 }
[10:25:45.946]                 if (length(args) > 0) 
[10:25:45.946]                   base::do.call(base::Sys.setenv, args = args)
[10:25:45.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:45.946]             }
[10:25:45.946]             else {
[10:25:45.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:45.946]             }
[10:25:45.946]             {
[10:25:45.946]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:45.946]                   0L) {
[10:25:45.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:45.946]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:45.946]                   base::options(opts)
[10:25:45.946]                 }
[10:25:45.946]                 {
[10:25:45.946]                   {
[10:25:45.946]                     NULL
[10:25:45.946]                     RNGkind("Mersenne-Twister")
[10:25:45.946]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:45.946]                       inherits = FALSE)
[10:25:45.946]                   }
[10:25:45.946]                   options(future.plan = NULL)
[10:25:45.946]                   if (is.na(NA_character_)) 
[10:25:45.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:45.946]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:45.946]                   {
[10:25:45.946]                     future <- SequentialFuture(..., envir = envir)
[10:25:45.946]                     if (!future$lazy) 
[10:25:45.946]                       future <- run(future)
[10:25:45.946]                     invisible(future)
[10:25:45.946]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:45.946]                 }
[10:25:45.946]             }
[10:25:45.946]         }
[10:25:45.946]     })
[10:25:45.946]     if (TRUE) {
[10:25:45.946]         base::sink(type = "output", split = FALSE)
[10:25:45.946]         if (TRUE) {
[10:25:45.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:45.946]         }
[10:25:45.946]         else {
[10:25:45.946]             ...future.result["stdout"] <- base::list(NULL)
[10:25:45.946]         }
[10:25:45.946]         base::close(...future.stdout)
[10:25:45.946]         ...future.stdout <- NULL
[10:25:45.946]     }
[10:25:45.946]     ...future.result$conditions <- ...future.conditions
[10:25:45.946]     ...future.result$finished <- base::Sys.time()
[10:25:45.946]     ...future.result
[10:25:45.946] }
[10:25:45.948] plan(): Setting new future strategy stack:
[10:25:45.948] List of future strategies:
[10:25:45.948] 1. sequential:
[10:25:45.948]    - args: function (..., envir = parent.frame())
[10:25:45.948]    - tweaked: FALSE
[10:25:45.948]    - call: NULL
[10:25:45.949] plan(): nbrOfWorkers() = 1
[10:25:45.949] plan(): Setting new future strategy stack:
[10:25:45.949] List of future strategies:
[10:25:45.949] 1. sequential:
[10:25:45.949]    - args: function (..., envir = parent.frame())
[10:25:45.949]    - tweaked: FALSE
[10:25:45.949]    - call: plan(strategy)
[10:25:45.950] plan(): nbrOfWorkers() = 1
[10:25:45.950] SequentialFuture started (and completed)
[10:25:45.950] - Launch lazy future ... done
[10:25:45.950] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f4e05a48> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f52a7a78> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f4e05a48> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f52a7a78> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:25:45.956] resolved() for ‘SequentialFuture’ ...
[10:25:45.956] - state: ‘finished’
[10:25:45.956] - run: TRUE
[10:25:45.957] - result: ‘FutureResult’
[10:25:45.957] resolved() for ‘SequentialFuture’ ... done
[10:25:45.957] resolved() for ‘SequentialFuture’ ...
[10:25:45.957] - state: ‘finished’
[10:25:45.957] - run: TRUE
[10:25:45.957] - result: ‘FutureResult’
[10:25:45.957] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:45.959] resolve() on list ...
[10:25:45.959]  recursive: 0
[10:25:45.959]  length: 6
[10:25:45.959]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:45.959] signalConditionsASAP(numeric, pos=1) ...
[10:25:45.959] - nx: 6
[10:25:45.960] - relay: TRUE
[10:25:45.960] - stdout: TRUE
[10:25:45.960] - signal: TRUE
[10:25:45.960] - resignal: FALSE
[10:25:45.960] - force: TRUE
[10:25:45.960] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.960] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.960]  - until=2
[10:25:45.960]  - relaying element #2
[10:25:45.960] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.960] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.961] signalConditionsASAP(NULL, pos=1) ... done
[10:25:45.961]  length: 5 (resolved future 1)
[10:25:45.961] resolved() for ‘SequentialFuture’ ...
[10:25:45.961] - state: ‘finished’
[10:25:45.961] - run: TRUE
[10:25:45.961] - result: ‘FutureResult’
[10:25:45.961] resolved() for ‘SequentialFuture’ ... done
[10:25:45.961] Future #2
[10:25:45.961] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:45.961] - nx: 6
[10:25:45.961] - relay: TRUE
[10:25:45.962] - stdout: TRUE
[10:25:45.962] - signal: TRUE
[10:25:45.962] - resignal: FALSE
[10:25:45.962] - force: TRUE
[10:25:45.962] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.962] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.962]  - until=2
[10:25:45.962]  - relaying element #2
[10:25:45.962] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.962] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.963] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:45.963]  length: 4 (resolved future 2)
[10:25:45.963] resolved() for ‘SequentialFuture’ ...
[10:25:45.963] - state: ‘finished’
[10:25:45.963] - run: TRUE
[10:25:45.963] - result: ‘FutureResult’
[10:25:45.963] resolved() for ‘SequentialFuture’ ... done
[10:25:45.963] Future #3
[10:25:45.963] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:45.963] - nx: 6
[10:25:45.963] - relay: TRUE
[10:25:45.964] - stdout: TRUE
[10:25:45.964] - signal: TRUE
[10:25:45.964] - resignal: FALSE
[10:25:45.964] - force: TRUE
[10:25:45.964] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.964] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.964]  - until=3
[10:25:45.964]  - relaying element #3
[10:25:45.964] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.964] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.964] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:45.965]  length: 3 (resolved future 3)
[10:25:45.965] signalConditionsASAP(NULL, pos=4) ...
[10:25:45.965] - nx: 6
[10:25:45.965] - relay: TRUE
[10:25:45.965] - stdout: TRUE
[10:25:45.965] - signal: TRUE
[10:25:45.965] - resignal: FALSE
[10:25:45.965] - force: TRUE
[10:25:45.965] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.965] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.965]  - until=5
[10:25:45.966]  - relaying element #5
[10:25:45.966] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:45.966] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.966] signalConditionsASAP(NULL, pos=4) ... done
[10:25:45.966]  length: 2 (resolved future 4)
[10:25:45.966] signalConditionsASAP(NULL, pos=5) ...
[10:25:45.966] - nx: 6
[10:25:45.966] - relay: TRUE
[10:25:45.966] - stdout: TRUE
[10:25:45.966] - signal: TRUE
[10:25:45.966] - resignal: FALSE
[10:25:45.966] - force: TRUE
[10:25:45.966] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:45.967] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.967]  - until=6
[10:25:45.967]  - relaying element #6
[10:25:45.967] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:45.967] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.967] signalConditionsASAP(NULL, pos=5) ... done
[10:25:45.967]  length: 1 (resolved future 5)
[10:25:45.967] signalConditionsASAP(numeric, pos=6) ...
[10:25:45.967] - nx: 6
[10:25:45.967] - relay: TRUE
[10:25:45.967] - stdout: TRUE
[10:25:45.967] - signal: TRUE
[10:25:45.968] - resignal: FALSE
[10:25:45.968] - force: TRUE
[10:25:45.968] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:45.968] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.968]  - until=6
[10:25:45.968] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:45.968] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.968] signalConditionsASAP(numeric, pos=6) ... done
[10:25:45.968]  length: 0 (resolved future 6)
[10:25:45.968] Relaying remaining futures
[10:25:45.968] signalConditionsASAP(NULL, pos=0) ...
[10:25:45.968] - nx: 6
[10:25:45.969] - relay: TRUE
[10:25:45.969] - stdout: TRUE
[10:25:45.969] - signal: TRUE
[10:25:45.969] - resignal: FALSE
[10:25:45.969] - force: TRUE
[10:25:45.969] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:45.969] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:45.969] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:45.969] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:45.969] signalConditionsASAP(NULL, pos=0) ... done
[10:25:45.969] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:25:45.972] getGlobalsAndPackages() ...
[10:25:45.973] Searching for globals...
[10:25:45.973] 
[10:25:45.973] Searching for globals ... DONE
[10:25:45.973] - globals: [0] <none>
[10:25:45.973] getGlobalsAndPackages() ... DONE
[10:25:45.973] run() for ‘Future’ ...
[10:25:45.973] - state: ‘created’
[10:25:45.974] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:45.974] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:45.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:45.974]   - Field: ‘label’
[10:25:45.974]   - Field: ‘local’
[10:25:45.974]   - Field: ‘owner’
[10:25:45.974]   - Field: ‘envir’
[10:25:45.974]   - Field: ‘packages’
[10:25:45.974]   - Field: ‘gc’
[10:25:45.975]   - Field: ‘conditions’
[10:25:45.975]   - Field: ‘expr’
[10:25:45.975]   - Field: ‘uuid’
[10:25:45.975]   - Field: ‘seed’
[10:25:45.975]   - Field: ‘version’
[10:25:45.975]   - Field: ‘result’
[10:25:45.975]   - Field: ‘asynchronous’
[10:25:45.975]   - Field: ‘calls’
[10:25:45.975]   - Field: ‘globals’
[10:25:45.975]   - Field: ‘stdout’
[10:25:45.975]   - Field: ‘earlySignal’
[10:25:45.975]   - Field: ‘lazy’
[10:25:45.976]   - Field: ‘state’
[10:25:45.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:45.976] - Launch lazy future ...
[10:25:45.976] Packages needed by the future expression (n = 0): <none>
[10:25:45.976] Packages needed by future strategies (n = 0): <none>
[10:25:45.976] {
[10:25:45.976]     {
[10:25:45.976]         {
[10:25:45.976]             ...future.startTime <- base::Sys.time()
[10:25:45.976]             {
[10:25:45.976]                 {
[10:25:45.976]                   {
[10:25:45.976]                     base::local({
[10:25:45.976]                       has_future <- base::requireNamespace("future", 
[10:25:45.976]                         quietly = TRUE)
[10:25:45.976]                       if (has_future) {
[10:25:45.976]                         ns <- base::getNamespace("future")
[10:25:45.976]                         version <- ns[[".package"]][["version"]]
[10:25:45.976]                         if (is.null(version)) 
[10:25:45.976]                           version <- utils::packageVersion("future")
[10:25:45.976]                       }
[10:25:45.976]                       else {
[10:25:45.976]                         version <- NULL
[10:25:45.976]                       }
[10:25:45.976]                       if (!has_future || version < "1.8.0") {
[10:25:45.976]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:45.976]                           "", base::R.version$version.string), 
[10:25:45.976]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:45.976]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:45.976]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:45.976]                             "release", "version")], collapse = " "), 
[10:25:45.976]                           hostname = base::Sys.info()[["nodename"]])
[10:25:45.976]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:45.976]                           info)
[10:25:45.976]                         info <- base::paste(info, collapse = "; ")
[10:25:45.976]                         if (!has_future) {
[10:25:45.976]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:45.976]                             info)
[10:25:45.976]                         }
[10:25:45.976]                         else {
[10:25:45.976]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:45.976]                             info, version)
[10:25:45.976]                         }
[10:25:45.976]                         base::stop(msg)
[10:25:45.976]                       }
[10:25:45.976]                     })
[10:25:45.976]                   }
[10:25:45.976]                   options(future.plan = NULL)
[10:25:45.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:45.976]                 }
[10:25:45.976]                 ...future.workdir <- getwd()
[10:25:45.976]             }
[10:25:45.976]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:45.976]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:45.976]         }
[10:25:45.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:45.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:45.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:45.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:45.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:45.976]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:45.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:45.976]             base::names(...future.oldOptions))
[10:25:45.976]     }
[10:25:45.976]     if (FALSE) {
[10:25:45.976]     }
[10:25:45.976]     else {
[10:25:45.976]         if (TRUE) {
[10:25:45.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:45.976]                 open = "w")
[10:25:45.976]         }
[10:25:45.976]         else {
[10:25:45.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:45.976]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:45.976]         }
[10:25:45.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:45.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:45.976]             base::sink(type = "output", split = FALSE)
[10:25:45.976]             base::close(...future.stdout)
[10:25:45.976]         }, add = TRUE)
[10:25:45.976]     }
[10:25:45.976]     ...future.frame <- base::sys.nframe()
[10:25:45.976]     ...future.conditions <- base::list()
[10:25:45.976]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:45.976]     if (FALSE) {
[10:25:45.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:45.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:45.976]     }
[10:25:45.976]     ...future.result <- base::tryCatch({
[10:25:45.976]         base::withCallingHandlers({
[10:25:45.976]             ...future.value <- base::withVisible(base::local(2))
[10:25:45.976]             future::FutureResult(value = ...future.value$value, 
[10:25:45.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.976]                   ...future.rng), globalenv = if (FALSE) 
[10:25:45.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:45.976]                     ...future.globalenv.names))
[10:25:45.976]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:45.976]         }, condition = base::local({
[10:25:45.976]             c <- base::c
[10:25:45.976]             inherits <- base::inherits
[10:25:45.976]             invokeRestart <- base::invokeRestart
[10:25:45.976]             length <- base::length
[10:25:45.976]             list <- base::list
[10:25:45.976]             seq.int <- base::seq.int
[10:25:45.976]             signalCondition <- base::signalCondition
[10:25:45.976]             sys.calls <- base::sys.calls
[10:25:45.976]             `[[` <- base::`[[`
[10:25:45.976]             `+` <- base::`+`
[10:25:45.976]             `<<-` <- base::`<<-`
[10:25:45.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:45.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:45.976]                   3L)]
[10:25:45.976]             }
[10:25:45.976]             function(cond) {
[10:25:45.976]                 is_error <- inherits(cond, "error")
[10:25:45.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:45.976]                   NULL)
[10:25:45.976]                 if (is_error) {
[10:25:45.976]                   sessionInformation <- function() {
[10:25:45.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:45.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:45.976]                       search = base::search(), system = base::Sys.info())
[10:25:45.976]                   }
[10:25:45.976]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:45.976]                     cond$call), session = sessionInformation(), 
[10:25:45.976]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:45.976]                   signalCondition(cond)
[10:25:45.976]                 }
[10:25:45.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:45.976]                 "immediateCondition"))) {
[10:25:45.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:45.976]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:45.976]                   if (TRUE && !signal) {
[10:25:45.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.976]                     {
[10:25:45.976]                       inherits <- base::inherits
[10:25:45.976]                       invokeRestart <- base::invokeRestart
[10:25:45.976]                       is.null <- base::is.null
[10:25:45.976]                       muffled <- FALSE
[10:25:45.976]                       if (inherits(cond, "message")) {
[10:25:45.976]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.976]                         if (muffled) 
[10:25:45.976]                           invokeRestart("muffleMessage")
[10:25:45.976]                       }
[10:25:45.976]                       else if (inherits(cond, "warning")) {
[10:25:45.976]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.976]                         if (muffled) 
[10:25:45.976]                           invokeRestart("muffleWarning")
[10:25:45.976]                       }
[10:25:45.976]                       else if (inherits(cond, "condition")) {
[10:25:45.976]                         if (!is.null(pattern)) {
[10:25:45.976]                           computeRestarts <- base::computeRestarts
[10:25:45.976]                           grepl <- base::grepl
[10:25:45.976]                           restarts <- computeRestarts(cond)
[10:25:45.976]                           for (restart in restarts) {
[10:25:45.976]                             name <- restart$name
[10:25:45.976]                             if (is.null(name)) 
[10:25:45.976]                               next
[10:25:45.976]                             if (!grepl(pattern, name)) 
[10:25:45.976]                               next
[10:25:45.976]                             invokeRestart(restart)
[10:25:45.976]                             muffled <- TRUE
[10:25:45.976]                             break
[10:25:45.976]                           }
[10:25:45.976]                         }
[10:25:45.976]                       }
[10:25:45.976]                       invisible(muffled)
[10:25:45.976]                     }
[10:25:45.976]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.976]                   }
[10:25:45.976]                 }
[10:25:45.976]                 else {
[10:25:45.976]                   if (TRUE) {
[10:25:45.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.976]                     {
[10:25:45.976]                       inherits <- base::inherits
[10:25:45.976]                       invokeRestart <- base::invokeRestart
[10:25:45.976]                       is.null <- base::is.null
[10:25:45.976]                       muffled <- FALSE
[10:25:45.976]                       if (inherits(cond, "message")) {
[10:25:45.976]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.976]                         if (muffled) 
[10:25:45.976]                           invokeRestart("muffleMessage")
[10:25:45.976]                       }
[10:25:45.976]                       else if (inherits(cond, "warning")) {
[10:25:45.976]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.976]                         if (muffled) 
[10:25:45.976]                           invokeRestart("muffleWarning")
[10:25:45.976]                       }
[10:25:45.976]                       else if (inherits(cond, "condition")) {
[10:25:45.976]                         if (!is.null(pattern)) {
[10:25:45.976]                           computeRestarts <- base::computeRestarts
[10:25:45.976]                           grepl <- base::grepl
[10:25:45.976]                           restarts <- computeRestarts(cond)
[10:25:45.976]                           for (restart in restarts) {
[10:25:45.976]                             name <- restart$name
[10:25:45.976]                             if (is.null(name)) 
[10:25:45.976]                               next
[10:25:45.976]                             if (!grepl(pattern, name)) 
[10:25:45.976]                               next
[10:25:45.976]                             invokeRestart(restart)
[10:25:45.976]                             muffled <- TRUE
[10:25:45.976]                             break
[10:25:45.976]                           }
[10:25:45.976]                         }
[10:25:45.976]                       }
[10:25:45.976]                       invisible(muffled)
[10:25:45.976]                     }
[10:25:45.976]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.976]                   }
[10:25:45.976]                 }
[10:25:45.976]             }
[10:25:45.976]         }))
[10:25:45.976]     }, error = function(ex) {
[10:25:45.976]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:45.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.976]                 ...future.rng), started = ...future.startTime, 
[10:25:45.976]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:45.976]             version = "1.8"), class = "FutureResult")
[10:25:45.976]     }, finally = {
[10:25:45.976]         if (!identical(...future.workdir, getwd())) 
[10:25:45.976]             setwd(...future.workdir)
[10:25:45.976]         {
[10:25:45.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:45.976]                 ...future.oldOptions$nwarnings <- NULL
[10:25:45.976]             }
[10:25:45.976]             base::options(...future.oldOptions)
[10:25:45.976]             if (.Platform$OS.type == "windows") {
[10:25:45.976]                 old_names <- names(...future.oldEnvVars)
[10:25:45.976]                 envs <- base::Sys.getenv()
[10:25:45.976]                 names <- names(envs)
[10:25:45.976]                 common <- intersect(names, old_names)
[10:25:45.976]                 added <- setdiff(names, old_names)
[10:25:45.976]                 removed <- setdiff(old_names, names)
[10:25:45.976]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:45.976]                   envs[common]]
[10:25:45.976]                 NAMES <- toupper(changed)
[10:25:45.976]                 args <- list()
[10:25:45.976]                 for (kk in seq_along(NAMES)) {
[10:25:45.976]                   name <- changed[[kk]]
[10:25:45.976]                   NAME <- NAMES[[kk]]
[10:25:45.976]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.976]                     next
[10:25:45.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.976]                 }
[10:25:45.976]                 NAMES <- toupper(added)
[10:25:45.976]                 for (kk in seq_along(NAMES)) {
[10:25:45.976]                   name <- added[[kk]]
[10:25:45.976]                   NAME <- NAMES[[kk]]
[10:25:45.976]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.976]                     next
[10:25:45.976]                   args[[name]] <- ""
[10:25:45.976]                 }
[10:25:45.976]                 NAMES <- toupper(removed)
[10:25:45.976]                 for (kk in seq_along(NAMES)) {
[10:25:45.976]                   name <- removed[[kk]]
[10:25:45.976]                   NAME <- NAMES[[kk]]
[10:25:45.976]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.976]                     next
[10:25:45.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.976]                 }
[10:25:45.976]                 if (length(args) > 0) 
[10:25:45.976]                   base::do.call(base::Sys.setenv, args = args)
[10:25:45.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:45.976]             }
[10:25:45.976]             else {
[10:25:45.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:45.976]             }
[10:25:45.976]             {
[10:25:45.976]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:45.976]                   0L) {
[10:25:45.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:45.976]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:45.976]                   base::options(opts)
[10:25:45.976]                 }
[10:25:45.976]                 {
[10:25:45.976]                   {
[10:25:45.976]                     NULL
[10:25:45.976]                     RNGkind("Mersenne-Twister")
[10:25:45.976]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:45.976]                       inherits = FALSE)
[10:25:45.976]                   }
[10:25:45.976]                   options(future.plan = NULL)
[10:25:45.976]                   if (is.na(NA_character_)) 
[10:25:45.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:45.976]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:45.976]                   {
[10:25:45.976]                     future <- SequentialFuture(..., envir = envir)
[10:25:45.976]                     if (!future$lazy) 
[10:25:45.976]                       future <- run(future)
[10:25:45.976]                     invisible(future)
[10:25:45.976]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:45.976]                 }
[10:25:45.976]             }
[10:25:45.976]         }
[10:25:45.976]     })
[10:25:45.976]     if (TRUE) {
[10:25:45.976]         base::sink(type = "output", split = FALSE)
[10:25:45.976]         if (TRUE) {
[10:25:45.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:45.976]         }
[10:25:45.976]         else {
[10:25:45.976]             ...future.result["stdout"] <- base::list(NULL)
[10:25:45.976]         }
[10:25:45.976]         base::close(...future.stdout)
[10:25:45.976]         ...future.stdout <- NULL
[10:25:45.976]     }
[10:25:45.976]     ...future.result$conditions <- ...future.conditions
[10:25:45.976]     ...future.result$finished <- base::Sys.time()
[10:25:45.976]     ...future.result
[10:25:45.976] }
[10:25:45.978] plan(): Setting new future strategy stack:
[10:25:45.978] List of future strategies:
[10:25:45.978] 1. sequential:
[10:25:45.978]    - args: function (..., envir = parent.frame())
[10:25:45.978]    - tweaked: FALSE
[10:25:45.978]    - call: NULL
[10:25:45.979] plan(): nbrOfWorkers() = 1
[10:25:45.979] plan(): Setting new future strategy stack:
[10:25:45.979] List of future strategies:
[10:25:45.979] 1. sequential:
[10:25:45.979]    - args: function (..., envir = parent.frame())
[10:25:45.979]    - tweaked: FALSE
[10:25:45.979]    - call: plan(strategy)
[10:25:45.980] plan(): nbrOfWorkers() = 1
[10:25:45.980] SequentialFuture started (and completed)
[10:25:45.980] - Launch lazy future ... done
[10:25:45.980] run() for ‘SequentialFuture’ ... done
[10:25:45.980] getGlobalsAndPackages() ...
[10:25:45.980] Searching for globals...
[10:25:45.981] 
[10:25:45.981] Searching for globals ... DONE
[10:25:45.981] - globals: [0] <none>
[10:25:45.982] getGlobalsAndPackages() ... DONE
[10:25:45.982] run() for ‘Future’ ...
[10:25:45.982] - state: ‘created’
[10:25:45.982] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:45.983] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:45.983] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:45.983]   - Field: ‘label’
[10:25:45.983]   - Field: ‘local’
[10:25:45.983]   - Field: ‘owner’
[10:25:45.983]   - Field: ‘envir’
[10:25:45.983]   - Field: ‘packages’
[10:25:45.983]   - Field: ‘gc’
[10:25:45.983]   - Field: ‘conditions’
[10:25:45.984]   - Field: ‘expr’
[10:25:45.984]   - Field: ‘uuid’
[10:25:45.984]   - Field: ‘seed’
[10:25:45.984]   - Field: ‘version’
[10:25:45.984]   - Field: ‘result’
[10:25:45.984]   - Field: ‘asynchronous’
[10:25:45.984]   - Field: ‘calls’
[10:25:45.984]   - Field: ‘globals’
[10:25:45.984]   - Field: ‘stdout’
[10:25:45.984]   - Field: ‘earlySignal’
[10:25:45.984]   - Field: ‘lazy’
[10:25:45.984]   - Field: ‘state’
[10:25:45.985] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:45.985] - Launch lazy future ...
[10:25:45.985] Packages needed by the future expression (n = 0): <none>
[10:25:45.985] Packages needed by future strategies (n = 0): <none>
[10:25:45.985] {
[10:25:45.985]     {
[10:25:45.985]         {
[10:25:45.985]             ...future.startTime <- base::Sys.time()
[10:25:45.985]             {
[10:25:45.985]                 {
[10:25:45.985]                   {
[10:25:45.985]                     base::local({
[10:25:45.985]                       has_future <- base::requireNamespace("future", 
[10:25:45.985]                         quietly = TRUE)
[10:25:45.985]                       if (has_future) {
[10:25:45.985]                         ns <- base::getNamespace("future")
[10:25:45.985]                         version <- ns[[".package"]][["version"]]
[10:25:45.985]                         if (is.null(version)) 
[10:25:45.985]                           version <- utils::packageVersion("future")
[10:25:45.985]                       }
[10:25:45.985]                       else {
[10:25:45.985]                         version <- NULL
[10:25:45.985]                       }
[10:25:45.985]                       if (!has_future || version < "1.8.0") {
[10:25:45.985]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:45.985]                           "", base::R.version$version.string), 
[10:25:45.985]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:45.985]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:45.985]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:45.985]                             "release", "version")], collapse = " "), 
[10:25:45.985]                           hostname = base::Sys.info()[["nodename"]])
[10:25:45.985]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:45.985]                           info)
[10:25:45.985]                         info <- base::paste(info, collapse = "; ")
[10:25:45.985]                         if (!has_future) {
[10:25:45.985]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:45.985]                             info)
[10:25:45.985]                         }
[10:25:45.985]                         else {
[10:25:45.985]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:45.985]                             info, version)
[10:25:45.985]                         }
[10:25:45.985]                         base::stop(msg)
[10:25:45.985]                       }
[10:25:45.985]                     })
[10:25:45.985]                   }
[10:25:45.985]                   options(future.plan = NULL)
[10:25:45.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:45.985]                 }
[10:25:45.985]                 ...future.workdir <- getwd()
[10:25:45.985]             }
[10:25:45.985]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:45.985]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:45.985]         }
[10:25:45.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:45.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:45.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:45.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:45.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:45.985]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:45.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:45.985]             base::names(...future.oldOptions))
[10:25:45.985]     }
[10:25:45.985]     if (FALSE) {
[10:25:45.985]     }
[10:25:45.985]     else {
[10:25:45.985]         if (TRUE) {
[10:25:45.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:45.985]                 open = "w")
[10:25:45.985]         }
[10:25:45.985]         else {
[10:25:45.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:45.985]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:45.985]         }
[10:25:45.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:45.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:45.985]             base::sink(type = "output", split = FALSE)
[10:25:45.985]             base::close(...future.stdout)
[10:25:45.985]         }, add = TRUE)
[10:25:45.985]     }
[10:25:45.985]     ...future.frame <- base::sys.nframe()
[10:25:45.985]     ...future.conditions <- base::list()
[10:25:45.985]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:45.985]     if (FALSE) {
[10:25:45.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:45.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:45.985]     }
[10:25:45.985]     ...future.result <- base::tryCatch({
[10:25:45.985]         base::withCallingHandlers({
[10:25:45.985]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:45.985]             future::FutureResult(value = ...future.value$value, 
[10:25:45.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.985]                   ...future.rng), globalenv = if (FALSE) 
[10:25:45.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:45.985]                     ...future.globalenv.names))
[10:25:45.985]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:45.985]         }, condition = base::local({
[10:25:45.985]             c <- base::c
[10:25:45.985]             inherits <- base::inherits
[10:25:45.985]             invokeRestart <- base::invokeRestart
[10:25:45.985]             length <- base::length
[10:25:45.985]             list <- base::list
[10:25:45.985]             seq.int <- base::seq.int
[10:25:45.985]             signalCondition <- base::signalCondition
[10:25:45.985]             sys.calls <- base::sys.calls
[10:25:45.985]             `[[` <- base::`[[`
[10:25:45.985]             `+` <- base::`+`
[10:25:45.985]             `<<-` <- base::`<<-`
[10:25:45.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:45.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:45.985]                   3L)]
[10:25:45.985]             }
[10:25:45.985]             function(cond) {
[10:25:45.985]                 is_error <- inherits(cond, "error")
[10:25:45.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:45.985]                   NULL)
[10:25:45.985]                 if (is_error) {
[10:25:45.985]                   sessionInformation <- function() {
[10:25:45.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:45.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:45.985]                       search = base::search(), system = base::Sys.info())
[10:25:45.985]                   }
[10:25:45.985]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:45.985]                     cond$call), session = sessionInformation(), 
[10:25:45.985]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:45.985]                   signalCondition(cond)
[10:25:45.985]                 }
[10:25:45.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:45.985]                 "immediateCondition"))) {
[10:25:45.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:45.985]                   ...future.conditions[[length(...future.conditions) + 
[10:25:45.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:45.985]                   if (TRUE && !signal) {
[10:25:45.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.985]                     {
[10:25:45.985]                       inherits <- base::inherits
[10:25:45.985]                       invokeRestart <- base::invokeRestart
[10:25:45.985]                       is.null <- base::is.null
[10:25:45.985]                       muffled <- FALSE
[10:25:45.985]                       if (inherits(cond, "message")) {
[10:25:45.985]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.985]                         if (muffled) 
[10:25:45.985]                           invokeRestart("muffleMessage")
[10:25:45.985]                       }
[10:25:45.985]                       else if (inherits(cond, "warning")) {
[10:25:45.985]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.985]                         if (muffled) 
[10:25:45.985]                           invokeRestart("muffleWarning")
[10:25:45.985]                       }
[10:25:45.985]                       else if (inherits(cond, "condition")) {
[10:25:45.985]                         if (!is.null(pattern)) {
[10:25:45.985]                           computeRestarts <- base::computeRestarts
[10:25:45.985]                           grepl <- base::grepl
[10:25:45.985]                           restarts <- computeRestarts(cond)
[10:25:45.985]                           for (restart in restarts) {
[10:25:45.985]                             name <- restart$name
[10:25:45.985]                             if (is.null(name)) 
[10:25:45.985]                               next
[10:25:45.985]                             if (!grepl(pattern, name)) 
[10:25:45.985]                               next
[10:25:45.985]                             invokeRestart(restart)
[10:25:45.985]                             muffled <- TRUE
[10:25:45.985]                             break
[10:25:45.985]                           }
[10:25:45.985]                         }
[10:25:45.985]                       }
[10:25:45.985]                       invisible(muffled)
[10:25:45.985]                     }
[10:25:45.985]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.985]                   }
[10:25:45.985]                 }
[10:25:45.985]                 else {
[10:25:45.985]                   if (TRUE) {
[10:25:45.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:45.985]                     {
[10:25:45.985]                       inherits <- base::inherits
[10:25:45.985]                       invokeRestart <- base::invokeRestart
[10:25:45.985]                       is.null <- base::is.null
[10:25:45.985]                       muffled <- FALSE
[10:25:45.985]                       if (inherits(cond, "message")) {
[10:25:45.985]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:45.985]                         if (muffled) 
[10:25:45.985]                           invokeRestart("muffleMessage")
[10:25:45.985]                       }
[10:25:45.985]                       else if (inherits(cond, "warning")) {
[10:25:45.985]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:45.985]                         if (muffled) 
[10:25:45.985]                           invokeRestart("muffleWarning")
[10:25:45.985]                       }
[10:25:45.985]                       else if (inherits(cond, "condition")) {
[10:25:45.985]                         if (!is.null(pattern)) {
[10:25:45.985]                           computeRestarts <- base::computeRestarts
[10:25:45.985]                           grepl <- base::grepl
[10:25:45.985]                           restarts <- computeRestarts(cond)
[10:25:45.985]                           for (restart in restarts) {
[10:25:45.985]                             name <- restart$name
[10:25:45.985]                             if (is.null(name)) 
[10:25:45.985]                               next
[10:25:45.985]                             if (!grepl(pattern, name)) 
[10:25:45.985]                               next
[10:25:45.985]                             invokeRestart(restart)
[10:25:45.985]                             muffled <- TRUE
[10:25:45.985]                             break
[10:25:45.985]                           }
[10:25:45.985]                         }
[10:25:45.985]                       }
[10:25:45.985]                       invisible(muffled)
[10:25:45.985]                     }
[10:25:45.985]                     muffleCondition(cond, pattern = "^muffle")
[10:25:45.985]                   }
[10:25:45.985]                 }
[10:25:45.985]             }
[10:25:45.985]         }))
[10:25:45.985]     }, error = function(ex) {
[10:25:45.985]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:45.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:45.985]                 ...future.rng), started = ...future.startTime, 
[10:25:45.985]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:45.985]             version = "1.8"), class = "FutureResult")
[10:25:45.985]     }, finally = {
[10:25:45.985]         if (!identical(...future.workdir, getwd())) 
[10:25:45.985]             setwd(...future.workdir)
[10:25:45.985]         {
[10:25:45.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:45.985]                 ...future.oldOptions$nwarnings <- NULL
[10:25:45.985]             }
[10:25:45.985]             base::options(...future.oldOptions)
[10:25:45.985]             if (.Platform$OS.type == "windows") {
[10:25:45.985]                 old_names <- names(...future.oldEnvVars)
[10:25:45.985]                 envs <- base::Sys.getenv()
[10:25:45.985]                 names <- names(envs)
[10:25:45.985]                 common <- intersect(names, old_names)
[10:25:45.985]                 added <- setdiff(names, old_names)
[10:25:45.985]                 removed <- setdiff(old_names, names)
[10:25:45.985]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:45.985]                   envs[common]]
[10:25:45.985]                 NAMES <- toupper(changed)
[10:25:45.985]                 args <- list()
[10:25:45.985]                 for (kk in seq_along(NAMES)) {
[10:25:45.985]                   name <- changed[[kk]]
[10:25:45.985]                   NAME <- NAMES[[kk]]
[10:25:45.985]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.985]                     next
[10:25:45.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.985]                 }
[10:25:45.985]                 NAMES <- toupper(added)
[10:25:45.985]                 for (kk in seq_along(NAMES)) {
[10:25:45.985]                   name <- added[[kk]]
[10:25:45.985]                   NAME <- NAMES[[kk]]
[10:25:45.985]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.985]                     next
[10:25:45.985]                   args[[name]] <- ""
[10:25:45.985]                 }
[10:25:45.985]                 NAMES <- toupper(removed)
[10:25:45.985]                 for (kk in seq_along(NAMES)) {
[10:25:45.985]                   name <- removed[[kk]]
[10:25:45.985]                   NAME <- NAMES[[kk]]
[10:25:45.985]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:45.985]                     next
[10:25:45.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:45.985]                 }
[10:25:45.985]                 if (length(args) > 0) 
[10:25:45.985]                   base::do.call(base::Sys.setenv, args = args)
[10:25:45.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:45.985]             }
[10:25:45.985]             else {
[10:25:45.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:45.985]             }
[10:25:45.985]             {
[10:25:45.985]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:45.985]                   0L) {
[10:25:45.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:45.985]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:45.985]                   base::options(opts)
[10:25:45.985]                 }
[10:25:45.985]                 {
[10:25:45.985]                   {
[10:25:45.985]                     NULL
[10:25:45.985]                     RNGkind("Mersenne-Twister")
[10:25:45.985]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:45.985]                       inherits = FALSE)
[10:25:45.985]                   }
[10:25:45.985]                   options(future.plan = NULL)
[10:25:45.985]                   if (is.na(NA_character_)) 
[10:25:45.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:45.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:45.985]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:45.985]                   {
[10:25:45.985]                     future <- SequentialFuture(..., envir = envir)
[10:25:45.985]                     if (!future$lazy) 
[10:25:45.985]                       future <- run(future)
[10:25:45.985]                     invisible(future)
[10:25:45.985]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:45.985]                 }
[10:25:45.985]             }
[10:25:45.985]         }
[10:25:45.985]     })
[10:25:45.985]     if (TRUE) {
[10:25:45.985]         base::sink(type = "output", split = FALSE)
[10:25:45.985]         if (TRUE) {
[10:25:45.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:45.985]         }
[10:25:45.985]         else {
[10:25:45.985]             ...future.result["stdout"] <- base::list(NULL)
[10:25:45.985]         }
[10:25:45.985]         base::close(...future.stdout)
[10:25:45.985]         ...future.stdout <- NULL
[10:25:45.985]     }
[10:25:45.985]     ...future.result$conditions <- ...future.conditions
[10:25:45.985]     ...future.result$finished <- base::Sys.time()
[10:25:45.985]     ...future.result
[10:25:45.985] }
[10:25:45.987] plan(): Setting new future strategy stack:
[10:25:45.987] List of future strategies:
[10:25:45.987] 1. sequential:
[10:25:45.987]    - args: function (..., envir = parent.frame())
[10:25:45.987]    - tweaked: FALSE
[10:25:45.987]    - call: NULL
[10:25:45.987] plan(): nbrOfWorkers() = 1
[10:25:45.988] plan(): Setting new future strategy stack:
[10:25:45.988] List of future strategies:
[10:25:45.988] 1. sequential:
[10:25:45.988]    - args: function (..., envir = parent.frame())
[10:25:45.988]    - tweaked: FALSE
[10:25:45.988]    - call: plan(strategy)
[10:25:45.989] plan(): nbrOfWorkers() = 1
[10:25:45.989] SequentialFuture started (and completed)
[10:25:45.989] - Launch lazy future ... done
[10:25:45.989] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f54324b8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f47affb8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f54324b8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f47affb8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:25:45.994] resolved() for ‘SequentialFuture’ ...
[10:25:45.994] - state: ‘finished’
[10:25:45.994] - run: TRUE
[10:25:45.994] - result: ‘FutureResult’
[10:25:45.994] resolved() for ‘SequentialFuture’ ... done
[10:25:45.994] resolved() for ‘SequentialFuture’ ...
[10:25:45.994] - state: ‘finished’
[10:25:45.994] - run: TRUE
[10:25:45.994] - result: ‘FutureResult’
[10:25:45.995] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:45.996] resolve() on list ...
[10:25:45.996]  recursive: 0
[10:25:45.996]  length: 6
[10:25:45.996]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:45.996] signalConditionsASAP(numeric, pos=1) ...
[10:25:45.996] - nx: 6
[10:25:45.997] - relay: TRUE
[10:25:45.997] - stdout: TRUE
[10:25:45.997] - signal: TRUE
[10:25:45.997] - resignal: FALSE
[10:25:45.997] - force: TRUE
[10:25:45.997] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.997] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.997]  - until=2
[10:25:45.997]  - relaying element #2
[10:25:45.997] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.997] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.997] signalConditionsASAP(NULL, pos=1) ... done
[10:25:45.998]  length: 5 (resolved future 1)
[10:25:45.998] resolved() for ‘SequentialFuture’ ...
[10:25:45.998] - state: ‘finished’
[10:25:45.998] - run: TRUE
[10:25:45.998] - result: ‘FutureResult’
[10:25:45.998] resolved() for ‘SequentialFuture’ ... done
[10:25:45.998] Future #2
[10:25:45.998] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:45.998] - nx: 6
[10:25:45.998] - relay: TRUE
[10:25:45.999] - stdout: TRUE
[10:25:45.999] - signal: TRUE
[10:25:45.999] - resignal: FALSE
[10:25:45.999] - force: TRUE
[10:25:45.999] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.999] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:45.999]  - until=2
[10:25:45.999]  - relaying element #2
[10:25:45.999] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.999] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:45.999] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.000]  length: 4 (resolved future 2)
[10:25:46.000] resolved() for ‘SequentialFuture’ ...
[10:25:46.000] - state: ‘finished’
[10:25:46.000] - run: TRUE
[10:25:46.000] - result: ‘FutureResult’
[10:25:46.000] resolved() for ‘SequentialFuture’ ... done
[10:25:46.000] Future #3
[10:25:46.000] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.000] - nx: 6
[10:25:46.000] - relay: TRUE
[10:25:46.000] - stdout: TRUE
[10:25:46.000] - signal: TRUE
[10:25:46.001] - resignal: FALSE
[10:25:46.001] - force: TRUE
[10:25:46.001] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.001] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.001]  - until=3
[10:25:46.001]  - relaying element #3
[10:25:46.001] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.001] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.001] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.001]  length: 3 (resolved future 3)
[10:25:46.002] signalConditionsASAP(NULL, pos=4) ...
[10:25:46.002] - nx: 6
[10:25:46.002] - relay: TRUE
[10:25:46.002] - stdout: TRUE
[10:25:46.002] - signal: TRUE
[10:25:46.002] - resignal: FALSE
[10:25:46.002] - force: TRUE
[10:25:46.002] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.002] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.002]  - until=5
[10:25:46.002]  - relaying element #5
[10:25:46.002] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.003] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.003] signalConditionsASAP(NULL, pos=4) ... done
[10:25:46.003]  length: 2 (resolved future 4)
[10:25:46.003] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.003] - nx: 6
[10:25:46.003] - relay: TRUE
[10:25:46.003] - stdout: TRUE
[10:25:46.003] - signal: TRUE
[10:25:46.003] - resignal: FALSE
[10:25:46.003] - force: TRUE
[10:25:46.003] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.003] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.004]  - until=6
[10:25:46.004]  - relaying element #6
[10:25:46.004] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.004] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.004] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.004]  length: 1 (resolved future 5)
[10:25:46.004] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.004] - nx: 6
[10:25:46.004] - relay: TRUE
[10:25:46.004] - stdout: TRUE
[10:25:46.004] - signal: TRUE
[10:25:46.004] - resignal: FALSE
[10:25:46.004] - force: TRUE
[10:25:46.005] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.005] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.005]  - until=6
[10:25:46.005] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.005] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.005] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.005]  length: 0 (resolved future 6)
[10:25:46.005] Relaying remaining futures
[10:25:46.005] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.005] - nx: 6
[10:25:46.005] - relay: TRUE
[10:25:46.005] - stdout: TRUE
[10:25:46.006] - signal: TRUE
[10:25:46.006] - resignal: FALSE
[10:25:46.006] - force: TRUE
[10:25:46.006] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.006] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:46.006] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.006] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.006] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.006] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:25:46.010] getGlobalsAndPackages() ...
[10:25:46.011] Searching for globals...
[10:25:46.011] 
[10:25:46.011] Searching for globals ... DONE
[10:25:46.011] - globals: [0] <none>
[10:25:46.011] getGlobalsAndPackages() ... DONE
[10:25:46.011] run() for ‘Future’ ...
[10:25:46.011] - state: ‘created’
[10:25:46.011] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.012] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.012]   - Field: ‘label’
[10:25:46.012]   - Field: ‘local’
[10:25:46.012]   - Field: ‘owner’
[10:25:46.012]   - Field: ‘envir’
[10:25:46.012]   - Field: ‘packages’
[10:25:46.012]   - Field: ‘gc’
[10:25:46.012]   - Field: ‘conditions’
[10:25:46.013]   - Field: ‘expr’
[10:25:46.013]   - Field: ‘uuid’
[10:25:46.013]   - Field: ‘seed’
[10:25:46.013]   - Field: ‘version’
[10:25:46.013]   - Field: ‘result’
[10:25:46.013]   - Field: ‘asynchronous’
[10:25:46.013]   - Field: ‘calls’
[10:25:46.013]   - Field: ‘globals’
[10:25:46.013]   - Field: ‘stdout’
[10:25:46.013]   - Field: ‘earlySignal’
[10:25:46.013]   - Field: ‘lazy’
[10:25:46.014]   - Field: ‘state’
[10:25:46.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.014] - Launch lazy future ...
[10:25:46.014] Packages needed by the future expression (n = 0): <none>
[10:25:46.014] Packages needed by future strategies (n = 0): <none>
[10:25:46.014] {
[10:25:46.014]     {
[10:25:46.014]         {
[10:25:46.014]             ...future.startTime <- base::Sys.time()
[10:25:46.014]             {
[10:25:46.014]                 {
[10:25:46.014]                   {
[10:25:46.014]                     base::local({
[10:25:46.014]                       has_future <- base::requireNamespace("future", 
[10:25:46.014]                         quietly = TRUE)
[10:25:46.014]                       if (has_future) {
[10:25:46.014]                         ns <- base::getNamespace("future")
[10:25:46.014]                         version <- ns[[".package"]][["version"]]
[10:25:46.014]                         if (is.null(version)) 
[10:25:46.014]                           version <- utils::packageVersion("future")
[10:25:46.014]                       }
[10:25:46.014]                       else {
[10:25:46.014]                         version <- NULL
[10:25:46.014]                       }
[10:25:46.014]                       if (!has_future || version < "1.8.0") {
[10:25:46.014]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.014]                           "", base::R.version$version.string), 
[10:25:46.014]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.014]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.014]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.014]                             "release", "version")], collapse = " "), 
[10:25:46.014]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.014]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.014]                           info)
[10:25:46.014]                         info <- base::paste(info, collapse = "; ")
[10:25:46.014]                         if (!has_future) {
[10:25:46.014]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.014]                             info)
[10:25:46.014]                         }
[10:25:46.014]                         else {
[10:25:46.014]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.014]                             info, version)
[10:25:46.014]                         }
[10:25:46.014]                         base::stop(msg)
[10:25:46.014]                       }
[10:25:46.014]                     })
[10:25:46.014]                   }
[10:25:46.014]                   options(future.plan = NULL)
[10:25:46.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.014]                 }
[10:25:46.014]                 ...future.workdir <- getwd()
[10:25:46.014]             }
[10:25:46.014]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.014]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.014]         }
[10:25:46.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.014]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.014]             base::names(...future.oldOptions))
[10:25:46.014]     }
[10:25:46.014]     if (FALSE) {
[10:25:46.014]     }
[10:25:46.014]     else {
[10:25:46.014]         if (TRUE) {
[10:25:46.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.014]                 open = "w")
[10:25:46.014]         }
[10:25:46.014]         else {
[10:25:46.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.014]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.014]         }
[10:25:46.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.014]             base::sink(type = "output", split = FALSE)
[10:25:46.014]             base::close(...future.stdout)
[10:25:46.014]         }, add = TRUE)
[10:25:46.014]     }
[10:25:46.014]     ...future.frame <- base::sys.nframe()
[10:25:46.014]     ...future.conditions <- base::list()
[10:25:46.014]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.014]     if (FALSE) {
[10:25:46.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.014]     }
[10:25:46.014]     ...future.result <- base::tryCatch({
[10:25:46.014]         base::withCallingHandlers({
[10:25:46.014]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.014]             future::FutureResult(value = ...future.value$value, 
[10:25:46.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.014]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.014]                     ...future.globalenv.names))
[10:25:46.014]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.014]         }, condition = base::local({
[10:25:46.014]             c <- base::c
[10:25:46.014]             inherits <- base::inherits
[10:25:46.014]             invokeRestart <- base::invokeRestart
[10:25:46.014]             length <- base::length
[10:25:46.014]             list <- base::list
[10:25:46.014]             seq.int <- base::seq.int
[10:25:46.014]             signalCondition <- base::signalCondition
[10:25:46.014]             sys.calls <- base::sys.calls
[10:25:46.014]             `[[` <- base::`[[`
[10:25:46.014]             `+` <- base::`+`
[10:25:46.014]             `<<-` <- base::`<<-`
[10:25:46.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.014]                   3L)]
[10:25:46.014]             }
[10:25:46.014]             function(cond) {
[10:25:46.014]                 is_error <- inherits(cond, "error")
[10:25:46.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.014]                   NULL)
[10:25:46.014]                 if (is_error) {
[10:25:46.014]                   sessionInformation <- function() {
[10:25:46.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.014]                       search = base::search(), system = base::Sys.info())
[10:25:46.014]                   }
[10:25:46.014]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.014]                     cond$call), session = sessionInformation(), 
[10:25:46.014]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.014]                   signalCondition(cond)
[10:25:46.014]                 }
[10:25:46.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.014]                 "immediateCondition"))) {
[10:25:46.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.014]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.014]                   if (TRUE && !signal) {
[10:25:46.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.014]                     {
[10:25:46.014]                       inherits <- base::inherits
[10:25:46.014]                       invokeRestart <- base::invokeRestart
[10:25:46.014]                       is.null <- base::is.null
[10:25:46.014]                       muffled <- FALSE
[10:25:46.014]                       if (inherits(cond, "message")) {
[10:25:46.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.014]                         if (muffled) 
[10:25:46.014]                           invokeRestart("muffleMessage")
[10:25:46.014]                       }
[10:25:46.014]                       else if (inherits(cond, "warning")) {
[10:25:46.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.014]                         if (muffled) 
[10:25:46.014]                           invokeRestart("muffleWarning")
[10:25:46.014]                       }
[10:25:46.014]                       else if (inherits(cond, "condition")) {
[10:25:46.014]                         if (!is.null(pattern)) {
[10:25:46.014]                           computeRestarts <- base::computeRestarts
[10:25:46.014]                           grepl <- base::grepl
[10:25:46.014]                           restarts <- computeRestarts(cond)
[10:25:46.014]                           for (restart in restarts) {
[10:25:46.014]                             name <- restart$name
[10:25:46.014]                             if (is.null(name)) 
[10:25:46.014]                               next
[10:25:46.014]                             if (!grepl(pattern, name)) 
[10:25:46.014]                               next
[10:25:46.014]                             invokeRestart(restart)
[10:25:46.014]                             muffled <- TRUE
[10:25:46.014]                             break
[10:25:46.014]                           }
[10:25:46.014]                         }
[10:25:46.014]                       }
[10:25:46.014]                       invisible(muffled)
[10:25:46.014]                     }
[10:25:46.014]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.014]                   }
[10:25:46.014]                 }
[10:25:46.014]                 else {
[10:25:46.014]                   if (TRUE) {
[10:25:46.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.014]                     {
[10:25:46.014]                       inherits <- base::inherits
[10:25:46.014]                       invokeRestart <- base::invokeRestart
[10:25:46.014]                       is.null <- base::is.null
[10:25:46.014]                       muffled <- FALSE
[10:25:46.014]                       if (inherits(cond, "message")) {
[10:25:46.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.014]                         if (muffled) 
[10:25:46.014]                           invokeRestart("muffleMessage")
[10:25:46.014]                       }
[10:25:46.014]                       else if (inherits(cond, "warning")) {
[10:25:46.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.014]                         if (muffled) 
[10:25:46.014]                           invokeRestart("muffleWarning")
[10:25:46.014]                       }
[10:25:46.014]                       else if (inherits(cond, "condition")) {
[10:25:46.014]                         if (!is.null(pattern)) {
[10:25:46.014]                           computeRestarts <- base::computeRestarts
[10:25:46.014]                           grepl <- base::grepl
[10:25:46.014]                           restarts <- computeRestarts(cond)
[10:25:46.014]                           for (restart in restarts) {
[10:25:46.014]                             name <- restart$name
[10:25:46.014]                             if (is.null(name)) 
[10:25:46.014]                               next
[10:25:46.014]                             if (!grepl(pattern, name)) 
[10:25:46.014]                               next
[10:25:46.014]                             invokeRestart(restart)
[10:25:46.014]                             muffled <- TRUE
[10:25:46.014]                             break
[10:25:46.014]                           }
[10:25:46.014]                         }
[10:25:46.014]                       }
[10:25:46.014]                       invisible(muffled)
[10:25:46.014]                     }
[10:25:46.014]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.014]                   }
[10:25:46.014]                 }
[10:25:46.014]             }
[10:25:46.014]         }))
[10:25:46.014]     }, error = function(ex) {
[10:25:46.014]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.014]                 ...future.rng), started = ...future.startTime, 
[10:25:46.014]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.014]             version = "1.8"), class = "FutureResult")
[10:25:46.014]     }, finally = {
[10:25:46.014]         if (!identical(...future.workdir, getwd())) 
[10:25:46.014]             setwd(...future.workdir)
[10:25:46.014]         {
[10:25:46.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.014]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.014]             }
[10:25:46.014]             base::options(...future.oldOptions)
[10:25:46.014]             if (.Platform$OS.type == "windows") {
[10:25:46.014]                 old_names <- names(...future.oldEnvVars)
[10:25:46.014]                 envs <- base::Sys.getenv()
[10:25:46.014]                 names <- names(envs)
[10:25:46.014]                 common <- intersect(names, old_names)
[10:25:46.014]                 added <- setdiff(names, old_names)
[10:25:46.014]                 removed <- setdiff(old_names, names)
[10:25:46.014]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.014]                   envs[common]]
[10:25:46.014]                 NAMES <- toupper(changed)
[10:25:46.014]                 args <- list()
[10:25:46.014]                 for (kk in seq_along(NAMES)) {
[10:25:46.014]                   name <- changed[[kk]]
[10:25:46.014]                   NAME <- NAMES[[kk]]
[10:25:46.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.014]                     next
[10:25:46.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.014]                 }
[10:25:46.014]                 NAMES <- toupper(added)
[10:25:46.014]                 for (kk in seq_along(NAMES)) {
[10:25:46.014]                   name <- added[[kk]]
[10:25:46.014]                   NAME <- NAMES[[kk]]
[10:25:46.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.014]                     next
[10:25:46.014]                   args[[name]] <- ""
[10:25:46.014]                 }
[10:25:46.014]                 NAMES <- toupper(removed)
[10:25:46.014]                 for (kk in seq_along(NAMES)) {
[10:25:46.014]                   name <- removed[[kk]]
[10:25:46.014]                   NAME <- NAMES[[kk]]
[10:25:46.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.014]                     next
[10:25:46.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.014]                 }
[10:25:46.014]                 if (length(args) > 0) 
[10:25:46.014]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.014]             }
[10:25:46.014]             else {
[10:25:46.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.014]             }
[10:25:46.014]             {
[10:25:46.014]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.014]                   0L) {
[10:25:46.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.014]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.014]                   base::options(opts)
[10:25:46.014]                 }
[10:25:46.014]                 {
[10:25:46.014]                   {
[10:25:46.014]                     NULL
[10:25:46.014]                     RNGkind("Mersenne-Twister")
[10:25:46.014]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.014]                       inherits = FALSE)
[10:25:46.014]                   }
[10:25:46.014]                   options(future.plan = NULL)
[10:25:46.014]                   if (is.na(NA_character_)) 
[10:25:46.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.014]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.014]                   {
[10:25:46.014]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.014]                     if (!future$lazy) 
[10:25:46.014]                       future <- run(future)
[10:25:46.014]                     invisible(future)
[10:25:46.014]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.014]                 }
[10:25:46.014]             }
[10:25:46.014]         }
[10:25:46.014]     })
[10:25:46.014]     if (TRUE) {
[10:25:46.014]         base::sink(type = "output", split = FALSE)
[10:25:46.014]         if (TRUE) {
[10:25:46.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.014]         }
[10:25:46.014]         else {
[10:25:46.014]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.014]         }
[10:25:46.014]         base::close(...future.stdout)
[10:25:46.014]         ...future.stdout <- NULL
[10:25:46.014]     }
[10:25:46.014]     ...future.result$conditions <- ...future.conditions
[10:25:46.014]     ...future.result$finished <- base::Sys.time()
[10:25:46.014]     ...future.result
[10:25:46.014] }
[10:25:46.016] plan(): Setting new future strategy stack:
[10:25:46.016] List of future strategies:
[10:25:46.016] 1. sequential:
[10:25:46.016]    - args: function (..., envir = parent.frame())
[10:25:46.016]    - tweaked: FALSE
[10:25:46.016]    - call: NULL
[10:25:46.016] plan(): nbrOfWorkers() = 1
[10:25:46.017] plan(): Setting new future strategy stack:
[10:25:46.017] List of future strategies:
[10:25:46.017] 1. sequential:
[10:25:46.017]    - args: function (..., envir = parent.frame())
[10:25:46.017]    - tweaked: FALSE
[10:25:46.017]    - call: plan(strategy)
[10:25:46.018] plan(): nbrOfWorkers() = 1
[10:25:46.018] SequentialFuture started (and completed)
[10:25:46.018] - Launch lazy future ... done
[10:25:46.018] run() for ‘SequentialFuture’ ... done
[10:25:46.018] getGlobalsAndPackages() ...
[10:25:46.018] Searching for globals...
[10:25:46.018] 
[10:25:46.019] Searching for globals ... DONE
[10:25:46.019] - globals: [0] <none>
[10:25:46.019] getGlobalsAndPackages() ... DONE
[10:25:46.019] run() for ‘Future’ ...
[10:25:46.019] - state: ‘created’
[10:25:46.019] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.019] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.019] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.020]   - Field: ‘label’
[10:25:46.020]   - Field: ‘local’
[10:25:46.020]   - Field: ‘owner’
[10:25:46.020]   - Field: ‘envir’
[10:25:46.020]   - Field: ‘packages’
[10:25:46.020]   - Field: ‘gc’
[10:25:46.020]   - Field: ‘conditions’
[10:25:46.020]   - Field: ‘expr’
[10:25:46.020]   - Field: ‘uuid’
[10:25:46.020]   - Field: ‘seed’
[10:25:46.020]   - Field: ‘version’
[10:25:46.020]   - Field: ‘result’
[10:25:46.021]   - Field: ‘asynchronous’
[10:25:46.021]   - Field: ‘calls’
[10:25:46.021]   - Field: ‘globals’
[10:25:46.021]   - Field: ‘stdout’
[10:25:46.021]   - Field: ‘earlySignal’
[10:25:46.021]   - Field: ‘lazy’
[10:25:46.021]   - Field: ‘state’
[10:25:46.021] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.021] - Launch lazy future ...
[10:25:46.021] Packages needed by the future expression (n = 0): <none>
[10:25:46.022] Packages needed by future strategies (n = 0): <none>
[10:25:46.022] {
[10:25:46.022]     {
[10:25:46.022]         {
[10:25:46.022]             ...future.startTime <- base::Sys.time()
[10:25:46.022]             {
[10:25:46.022]                 {
[10:25:46.022]                   {
[10:25:46.022]                     base::local({
[10:25:46.022]                       has_future <- base::requireNamespace("future", 
[10:25:46.022]                         quietly = TRUE)
[10:25:46.022]                       if (has_future) {
[10:25:46.022]                         ns <- base::getNamespace("future")
[10:25:46.022]                         version <- ns[[".package"]][["version"]]
[10:25:46.022]                         if (is.null(version)) 
[10:25:46.022]                           version <- utils::packageVersion("future")
[10:25:46.022]                       }
[10:25:46.022]                       else {
[10:25:46.022]                         version <- NULL
[10:25:46.022]                       }
[10:25:46.022]                       if (!has_future || version < "1.8.0") {
[10:25:46.022]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.022]                           "", base::R.version$version.string), 
[10:25:46.022]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.022]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.022]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.022]                             "release", "version")], collapse = " "), 
[10:25:46.022]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.022]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.022]                           info)
[10:25:46.022]                         info <- base::paste(info, collapse = "; ")
[10:25:46.022]                         if (!has_future) {
[10:25:46.022]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.022]                             info)
[10:25:46.022]                         }
[10:25:46.022]                         else {
[10:25:46.022]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.022]                             info, version)
[10:25:46.022]                         }
[10:25:46.022]                         base::stop(msg)
[10:25:46.022]                       }
[10:25:46.022]                     })
[10:25:46.022]                   }
[10:25:46.022]                   options(future.plan = NULL)
[10:25:46.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.022]                 }
[10:25:46.022]                 ...future.workdir <- getwd()
[10:25:46.022]             }
[10:25:46.022]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.022]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.022]         }
[10:25:46.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.022]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.022]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.022]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.022]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.022]             base::names(...future.oldOptions))
[10:25:46.022]     }
[10:25:46.022]     if (FALSE) {
[10:25:46.022]     }
[10:25:46.022]     else {
[10:25:46.022]         if (TRUE) {
[10:25:46.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.022]                 open = "w")
[10:25:46.022]         }
[10:25:46.022]         else {
[10:25:46.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.022]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.022]         }
[10:25:46.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.022]             base::sink(type = "output", split = FALSE)
[10:25:46.022]             base::close(...future.stdout)
[10:25:46.022]         }, add = TRUE)
[10:25:46.022]     }
[10:25:46.022]     ...future.frame <- base::sys.nframe()
[10:25:46.022]     ...future.conditions <- base::list()
[10:25:46.022]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.022]     if (FALSE) {
[10:25:46.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.022]     }
[10:25:46.022]     ...future.result <- base::tryCatch({
[10:25:46.022]         base::withCallingHandlers({
[10:25:46.022]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.022]             future::FutureResult(value = ...future.value$value, 
[10:25:46.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.022]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.022]                     ...future.globalenv.names))
[10:25:46.022]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.022]         }, condition = base::local({
[10:25:46.022]             c <- base::c
[10:25:46.022]             inherits <- base::inherits
[10:25:46.022]             invokeRestart <- base::invokeRestart
[10:25:46.022]             length <- base::length
[10:25:46.022]             list <- base::list
[10:25:46.022]             seq.int <- base::seq.int
[10:25:46.022]             signalCondition <- base::signalCondition
[10:25:46.022]             sys.calls <- base::sys.calls
[10:25:46.022]             `[[` <- base::`[[`
[10:25:46.022]             `+` <- base::`+`
[10:25:46.022]             `<<-` <- base::`<<-`
[10:25:46.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.022]                   3L)]
[10:25:46.022]             }
[10:25:46.022]             function(cond) {
[10:25:46.022]                 is_error <- inherits(cond, "error")
[10:25:46.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.022]                   NULL)
[10:25:46.022]                 if (is_error) {
[10:25:46.022]                   sessionInformation <- function() {
[10:25:46.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.022]                       search = base::search(), system = base::Sys.info())
[10:25:46.022]                   }
[10:25:46.022]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.022]                     cond$call), session = sessionInformation(), 
[10:25:46.022]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.022]                   signalCondition(cond)
[10:25:46.022]                 }
[10:25:46.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.022]                 "immediateCondition"))) {
[10:25:46.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.022]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.022]                   if (TRUE && !signal) {
[10:25:46.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.022]                     {
[10:25:46.022]                       inherits <- base::inherits
[10:25:46.022]                       invokeRestart <- base::invokeRestart
[10:25:46.022]                       is.null <- base::is.null
[10:25:46.022]                       muffled <- FALSE
[10:25:46.022]                       if (inherits(cond, "message")) {
[10:25:46.022]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.022]                         if (muffled) 
[10:25:46.022]                           invokeRestart("muffleMessage")
[10:25:46.022]                       }
[10:25:46.022]                       else if (inherits(cond, "warning")) {
[10:25:46.022]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.022]                         if (muffled) 
[10:25:46.022]                           invokeRestart("muffleWarning")
[10:25:46.022]                       }
[10:25:46.022]                       else if (inherits(cond, "condition")) {
[10:25:46.022]                         if (!is.null(pattern)) {
[10:25:46.022]                           computeRestarts <- base::computeRestarts
[10:25:46.022]                           grepl <- base::grepl
[10:25:46.022]                           restarts <- computeRestarts(cond)
[10:25:46.022]                           for (restart in restarts) {
[10:25:46.022]                             name <- restart$name
[10:25:46.022]                             if (is.null(name)) 
[10:25:46.022]                               next
[10:25:46.022]                             if (!grepl(pattern, name)) 
[10:25:46.022]                               next
[10:25:46.022]                             invokeRestart(restart)
[10:25:46.022]                             muffled <- TRUE
[10:25:46.022]                             break
[10:25:46.022]                           }
[10:25:46.022]                         }
[10:25:46.022]                       }
[10:25:46.022]                       invisible(muffled)
[10:25:46.022]                     }
[10:25:46.022]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.022]                   }
[10:25:46.022]                 }
[10:25:46.022]                 else {
[10:25:46.022]                   if (TRUE) {
[10:25:46.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.022]                     {
[10:25:46.022]                       inherits <- base::inherits
[10:25:46.022]                       invokeRestart <- base::invokeRestart
[10:25:46.022]                       is.null <- base::is.null
[10:25:46.022]                       muffled <- FALSE
[10:25:46.022]                       if (inherits(cond, "message")) {
[10:25:46.022]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.022]                         if (muffled) 
[10:25:46.022]                           invokeRestart("muffleMessage")
[10:25:46.022]                       }
[10:25:46.022]                       else if (inherits(cond, "warning")) {
[10:25:46.022]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.022]                         if (muffled) 
[10:25:46.022]                           invokeRestart("muffleWarning")
[10:25:46.022]                       }
[10:25:46.022]                       else if (inherits(cond, "condition")) {
[10:25:46.022]                         if (!is.null(pattern)) {
[10:25:46.022]                           computeRestarts <- base::computeRestarts
[10:25:46.022]                           grepl <- base::grepl
[10:25:46.022]                           restarts <- computeRestarts(cond)
[10:25:46.022]                           for (restart in restarts) {
[10:25:46.022]                             name <- restart$name
[10:25:46.022]                             if (is.null(name)) 
[10:25:46.022]                               next
[10:25:46.022]                             if (!grepl(pattern, name)) 
[10:25:46.022]                               next
[10:25:46.022]                             invokeRestart(restart)
[10:25:46.022]                             muffled <- TRUE
[10:25:46.022]                             break
[10:25:46.022]                           }
[10:25:46.022]                         }
[10:25:46.022]                       }
[10:25:46.022]                       invisible(muffled)
[10:25:46.022]                     }
[10:25:46.022]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.022]                   }
[10:25:46.022]                 }
[10:25:46.022]             }
[10:25:46.022]         }))
[10:25:46.022]     }, error = function(ex) {
[10:25:46.022]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.022]                 ...future.rng), started = ...future.startTime, 
[10:25:46.022]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.022]             version = "1.8"), class = "FutureResult")
[10:25:46.022]     }, finally = {
[10:25:46.022]         if (!identical(...future.workdir, getwd())) 
[10:25:46.022]             setwd(...future.workdir)
[10:25:46.022]         {
[10:25:46.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.022]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.022]             }
[10:25:46.022]             base::options(...future.oldOptions)
[10:25:46.022]             if (.Platform$OS.type == "windows") {
[10:25:46.022]                 old_names <- names(...future.oldEnvVars)
[10:25:46.022]                 envs <- base::Sys.getenv()
[10:25:46.022]                 names <- names(envs)
[10:25:46.022]                 common <- intersect(names, old_names)
[10:25:46.022]                 added <- setdiff(names, old_names)
[10:25:46.022]                 removed <- setdiff(old_names, names)
[10:25:46.022]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.022]                   envs[common]]
[10:25:46.022]                 NAMES <- toupper(changed)
[10:25:46.022]                 args <- list()
[10:25:46.022]                 for (kk in seq_along(NAMES)) {
[10:25:46.022]                   name <- changed[[kk]]
[10:25:46.022]                   NAME <- NAMES[[kk]]
[10:25:46.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.022]                     next
[10:25:46.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.022]                 }
[10:25:46.022]                 NAMES <- toupper(added)
[10:25:46.022]                 for (kk in seq_along(NAMES)) {
[10:25:46.022]                   name <- added[[kk]]
[10:25:46.022]                   NAME <- NAMES[[kk]]
[10:25:46.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.022]                     next
[10:25:46.022]                   args[[name]] <- ""
[10:25:46.022]                 }
[10:25:46.022]                 NAMES <- toupper(removed)
[10:25:46.022]                 for (kk in seq_along(NAMES)) {
[10:25:46.022]                   name <- removed[[kk]]
[10:25:46.022]                   NAME <- NAMES[[kk]]
[10:25:46.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.022]                     next
[10:25:46.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.022]                 }
[10:25:46.022]                 if (length(args) > 0) 
[10:25:46.022]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.022]             }
[10:25:46.022]             else {
[10:25:46.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.022]             }
[10:25:46.022]             {
[10:25:46.022]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.022]                   0L) {
[10:25:46.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.022]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.022]                   base::options(opts)
[10:25:46.022]                 }
[10:25:46.022]                 {
[10:25:46.022]                   {
[10:25:46.022]                     NULL
[10:25:46.022]                     RNGkind("Mersenne-Twister")
[10:25:46.022]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.022]                       inherits = FALSE)
[10:25:46.022]                   }
[10:25:46.022]                   options(future.plan = NULL)
[10:25:46.022]                   if (is.na(NA_character_)) 
[10:25:46.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.022]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.022]                   {
[10:25:46.022]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.022]                     if (!future$lazy) 
[10:25:46.022]                       future <- run(future)
[10:25:46.022]                     invisible(future)
[10:25:46.022]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.022]                 }
[10:25:46.022]             }
[10:25:46.022]         }
[10:25:46.022]     })
[10:25:46.022]     if (TRUE) {
[10:25:46.022]         base::sink(type = "output", split = FALSE)
[10:25:46.022]         if (TRUE) {
[10:25:46.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.022]         }
[10:25:46.022]         else {
[10:25:46.022]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.022]         }
[10:25:46.022]         base::close(...future.stdout)
[10:25:46.022]         ...future.stdout <- NULL
[10:25:46.022]     }
[10:25:46.022]     ...future.result$conditions <- ...future.conditions
[10:25:46.022]     ...future.result$finished <- base::Sys.time()
[10:25:46.022]     ...future.result
[10:25:46.022] }
[10:25:46.024] plan(): Setting new future strategy stack:
[10:25:46.024] List of future strategies:
[10:25:46.024] 1. sequential:
[10:25:46.024]    - args: function (..., envir = parent.frame())
[10:25:46.024]    - tweaked: FALSE
[10:25:46.024]    - call: NULL
[10:25:46.024] plan(): nbrOfWorkers() = 1
[10:25:46.025] plan(): Setting new future strategy stack:
[10:25:46.025] List of future strategies:
[10:25:46.025] 1. sequential:
[10:25:46.025]    - args: function (..., envir = parent.frame())
[10:25:46.025]    - tweaked: FALSE
[10:25:46.025]    - call: plan(strategy)
[10:25:46.025] plan(): nbrOfWorkers() = 1
[10:25:46.025] SequentialFuture started (and completed)
[10:25:46.025] - Launch lazy future ... done
[10:25:46.025] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f382a2d0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f4cc0e78> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f382a2d0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f4cc0e78> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:25:46.030] resolved() for ‘SequentialFuture’ ...
[10:25:46.030] - state: ‘finished’
[10:25:46.030] - run: TRUE
[10:25:46.031] - result: ‘FutureResult’
[10:25:46.031] resolved() for ‘SequentialFuture’ ... done
[10:25:46.031] resolved() for ‘SequentialFuture’ ...
[10:25:46.031] - state: ‘finished’
[10:25:46.031] - run: TRUE
[10:25:46.031] - result: ‘FutureResult’
[10:25:46.031] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:46.033] resolve() on list ...
[10:25:46.033]  recursive: 0
[10:25:46.033]  length: 6
[10:25:46.033]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:46.033] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.033] - nx: 6
[10:25:46.033] - relay: TRUE
[10:25:46.033] - stdout: TRUE
[10:25:46.034] - signal: TRUE
[10:25:46.034] - resignal: FALSE
[10:25:46.034] - force: TRUE
[10:25:46.034] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.034] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.034]  - until=2
[10:25:46.034]  - relaying element #2
[10:25:46.034] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.034] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.034] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.034]  length: 5 (resolved future 1)
[10:25:46.034] resolved() for ‘SequentialFuture’ ...
[10:25:46.035] - state: ‘finished’
[10:25:46.035] - run: TRUE
[10:25:46.035] - result: ‘FutureResult’
[10:25:46.035] resolved() for ‘SequentialFuture’ ... done
[10:25:46.035] Future #2
[10:25:46.036] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.036] - nx: 6
[10:25:46.036] - relay: TRUE
[10:25:46.036] - stdout: TRUE
[10:25:46.036] - signal: TRUE
[10:25:46.037] - resignal: FALSE
[10:25:46.037] - force: TRUE
[10:25:46.037] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.037] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.037]  - until=2
[10:25:46.037]  - relaying element #2
[10:25:46.037] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.037] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.037] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.037]  length: 4 (resolved future 2)
[10:25:46.038] resolved() for ‘SequentialFuture’ ...
[10:25:46.038] - state: ‘finished’
[10:25:46.038] - run: TRUE
[10:25:46.038] - result: ‘FutureResult’
[10:25:46.038] resolved() for ‘SequentialFuture’ ... done
[10:25:46.038] Future #3
[10:25:46.038] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.038] - nx: 6
[10:25:46.038] - relay: TRUE
[10:25:46.038] - stdout: TRUE
[10:25:46.038] - signal: TRUE
[10:25:46.039] - resignal: FALSE
[10:25:46.039] - force: TRUE
[10:25:46.039] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.039] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.039]  - until=3
[10:25:46.039]  - relaying element #3
[10:25:46.039] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.039] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.039]  length: 3 (resolved future 3)
[10:25:46.039] signalConditionsASAP(NULL, pos=4) ...
[10:25:46.040] - nx: 6
[10:25:46.040] - relay: TRUE
[10:25:46.040] - stdout: TRUE
[10:25:46.040] - signal: TRUE
[10:25:46.040] - resignal: FALSE
[10:25:46.040] - force: TRUE
[10:25:46.040] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.040] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.040]  - until=5
[10:25:46.040]  - relaying element #5
[10:25:46.040] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.040] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.040] signalConditionsASAP(NULL, pos=4) ... done
[10:25:46.041]  length: 2 (resolved future 4)
[10:25:46.041] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.041] - nx: 6
[10:25:46.041] - relay: TRUE
[10:25:46.041] - stdout: TRUE
[10:25:46.041] - signal: TRUE
[10:25:46.041] - resignal: FALSE
[10:25:46.041] - force: TRUE
[10:25:46.041] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.041] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.041]  - until=6
[10:25:46.042]  - relaying element #6
[10:25:46.042] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.042] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.042] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.042]  length: 1 (resolved future 5)
[10:25:46.042] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.042] - nx: 6
[10:25:46.042] - relay: TRUE
[10:25:46.042] - stdout: TRUE
[10:25:46.042] - signal: TRUE
[10:25:46.042] - resignal: FALSE
[10:25:46.042] - force: TRUE
[10:25:46.042] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.043] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.043]  - until=6
[10:25:46.043] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.043] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.043] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.043]  length: 0 (resolved future 6)
[10:25:46.043] Relaying remaining futures
[10:25:46.043] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.043] - nx: 6
[10:25:46.043] - relay: TRUE
[10:25:46.043] - stdout: TRUE
[10:25:46.043] - signal: TRUE
[10:25:46.043] - resignal: FALSE
[10:25:46.044] - force: TRUE
[10:25:46.044] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.044] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:46.044] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.044] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.044] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.044] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:25:46.047] getGlobalsAndPackages() ...
[10:25:46.047] Searching for globals...
[10:25:46.048] 
[10:25:46.048] Searching for globals ... DONE
[10:25:46.048] - globals: [0] <none>
[10:25:46.048] getGlobalsAndPackages() ... DONE
[10:25:46.048] run() for ‘Future’ ...
[10:25:46.048] - state: ‘created’
[10:25:46.048] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.049] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.049]   - Field: ‘label’
[10:25:46.049]   - Field: ‘local’
[10:25:46.049]   - Field: ‘owner’
[10:25:46.049]   - Field: ‘envir’
[10:25:46.049]   - Field: ‘packages’
[10:25:46.049]   - Field: ‘gc’
[10:25:46.049]   - Field: ‘conditions’
[10:25:46.050]   - Field: ‘expr’
[10:25:46.050]   - Field: ‘uuid’
[10:25:46.050]   - Field: ‘seed’
[10:25:46.050]   - Field: ‘version’
[10:25:46.050]   - Field: ‘result’
[10:25:46.050]   - Field: ‘asynchronous’
[10:25:46.050]   - Field: ‘calls’
[10:25:46.050]   - Field: ‘globals’
[10:25:46.050]   - Field: ‘stdout’
[10:25:46.050]   - Field: ‘earlySignal’
[10:25:46.050]   - Field: ‘lazy’
[10:25:46.050]   - Field: ‘state’
[10:25:46.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.051] - Launch lazy future ...
[10:25:46.051] Packages needed by the future expression (n = 0): <none>
[10:25:46.051] Packages needed by future strategies (n = 0): <none>
[10:25:46.051] {
[10:25:46.051]     {
[10:25:46.051]         {
[10:25:46.051]             ...future.startTime <- base::Sys.time()
[10:25:46.051]             {
[10:25:46.051]                 {
[10:25:46.051]                   {
[10:25:46.051]                     base::local({
[10:25:46.051]                       has_future <- base::requireNamespace("future", 
[10:25:46.051]                         quietly = TRUE)
[10:25:46.051]                       if (has_future) {
[10:25:46.051]                         ns <- base::getNamespace("future")
[10:25:46.051]                         version <- ns[[".package"]][["version"]]
[10:25:46.051]                         if (is.null(version)) 
[10:25:46.051]                           version <- utils::packageVersion("future")
[10:25:46.051]                       }
[10:25:46.051]                       else {
[10:25:46.051]                         version <- NULL
[10:25:46.051]                       }
[10:25:46.051]                       if (!has_future || version < "1.8.0") {
[10:25:46.051]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.051]                           "", base::R.version$version.string), 
[10:25:46.051]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.051]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.051]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.051]                             "release", "version")], collapse = " "), 
[10:25:46.051]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.051]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.051]                           info)
[10:25:46.051]                         info <- base::paste(info, collapse = "; ")
[10:25:46.051]                         if (!has_future) {
[10:25:46.051]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.051]                             info)
[10:25:46.051]                         }
[10:25:46.051]                         else {
[10:25:46.051]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.051]                             info, version)
[10:25:46.051]                         }
[10:25:46.051]                         base::stop(msg)
[10:25:46.051]                       }
[10:25:46.051]                     })
[10:25:46.051]                   }
[10:25:46.051]                   options(future.plan = NULL)
[10:25:46.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.051]                 }
[10:25:46.051]                 ...future.workdir <- getwd()
[10:25:46.051]             }
[10:25:46.051]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.051]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.051]         }
[10:25:46.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.051]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.051]             base::names(...future.oldOptions))
[10:25:46.051]     }
[10:25:46.051]     if (FALSE) {
[10:25:46.051]     }
[10:25:46.051]     else {
[10:25:46.051]         if (TRUE) {
[10:25:46.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.051]                 open = "w")
[10:25:46.051]         }
[10:25:46.051]         else {
[10:25:46.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.051]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.051]         }
[10:25:46.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.051]             base::sink(type = "output", split = FALSE)
[10:25:46.051]             base::close(...future.stdout)
[10:25:46.051]         }, add = TRUE)
[10:25:46.051]     }
[10:25:46.051]     ...future.frame <- base::sys.nframe()
[10:25:46.051]     ...future.conditions <- base::list()
[10:25:46.051]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.051]     if (FALSE) {
[10:25:46.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.051]     }
[10:25:46.051]     ...future.result <- base::tryCatch({
[10:25:46.051]         base::withCallingHandlers({
[10:25:46.051]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.051]             future::FutureResult(value = ...future.value$value, 
[10:25:46.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.051]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.051]                     ...future.globalenv.names))
[10:25:46.051]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.051]         }, condition = base::local({
[10:25:46.051]             c <- base::c
[10:25:46.051]             inherits <- base::inherits
[10:25:46.051]             invokeRestart <- base::invokeRestart
[10:25:46.051]             length <- base::length
[10:25:46.051]             list <- base::list
[10:25:46.051]             seq.int <- base::seq.int
[10:25:46.051]             signalCondition <- base::signalCondition
[10:25:46.051]             sys.calls <- base::sys.calls
[10:25:46.051]             `[[` <- base::`[[`
[10:25:46.051]             `+` <- base::`+`
[10:25:46.051]             `<<-` <- base::`<<-`
[10:25:46.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.051]                   3L)]
[10:25:46.051]             }
[10:25:46.051]             function(cond) {
[10:25:46.051]                 is_error <- inherits(cond, "error")
[10:25:46.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.051]                   NULL)
[10:25:46.051]                 if (is_error) {
[10:25:46.051]                   sessionInformation <- function() {
[10:25:46.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.051]                       search = base::search(), system = base::Sys.info())
[10:25:46.051]                   }
[10:25:46.051]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.051]                     cond$call), session = sessionInformation(), 
[10:25:46.051]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.051]                   signalCondition(cond)
[10:25:46.051]                 }
[10:25:46.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.051]                 "immediateCondition"))) {
[10:25:46.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.051]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.051]                   if (TRUE && !signal) {
[10:25:46.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.051]                     {
[10:25:46.051]                       inherits <- base::inherits
[10:25:46.051]                       invokeRestart <- base::invokeRestart
[10:25:46.051]                       is.null <- base::is.null
[10:25:46.051]                       muffled <- FALSE
[10:25:46.051]                       if (inherits(cond, "message")) {
[10:25:46.051]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.051]                         if (muffled) 
[10:25:46.051]                           invokeRestart("muffleMessage")
[10:25:46.051]                       }
[10:25:46.051]                       else if (inherits(cond, "warning")) {
[10:25:46.051]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.051]                         if (muffled) 
[10:25:46.051]                           invokeRestart("muffleWarning")
[10:25:46.051]                       }
[10:25:46.051]                       else if (inherits(cond, "condition")) {
[10:25:46.051]                         if (!is.null(pattern)) {
[10:25:46.051]                           computeRestarts <- base::computeRestarts
[10:25:46.051]                           grepl <- base::grepl
[10:25:46.051]                           restarts <- computeRestarts(cond)
[10:25:46.051]                           for (restart in restarts) {
[10:25:46.051]                             name <- restart$name
[10:25:46.051]                             if (is.null(name)) 
[10:25:46.051]                               next
[10:25:46.051]                             if (!grepl(pattern, name)) 
[10:25:46.051]                               next
[10:25:46.051]                             invokeRestart(restart)
[10:25:46.051]                             muffled <- TRUE
[10:25:46.051]                             break
[10:25:46.051]                           }
[10:25:46.051]                         }
[10:25:46.051]                       }
[10:25:46.051]                       invisible(muffled)
[10:25:46.051]                     }
[10:25:46.051]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.051]                   }
[10:25:46.051]                 }
[10:25:46.051]                 else {
[10:25:46.051]                   if (TRUE) {
[10:25:46.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.051]                     {
[10:25:46.051]                       inherits <- base::inherits
[10:25:46.051]                       invokeRestart <- base::invokeRestart
[10:25:46.051]                       is.null <- base::is.null
[10:25:46.051]                       muffled <- FALSE
[10:25:46.051]                       if (inherits(cond, "message")) {
[10:25:46.051]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.051]                         if (muffled) 
[10:25:46.051]                           invokeRestart("muffleMessage")
[10:25:46.051]                       }
[10:25:46.051]                       else if (inherits(cond, "warning")) {
[10:25:46.051]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.051]                         if (muffled) 
[10:25:46.051]                           invokeRestart("muffleWarning")
[10:25:46.051]                       }
[10:25:46.051]                       else if (inherits(cond, "condition")) {
[10:25:46.051]                         if (!is.null(pattern)) {
[10:25:46.051]                           computeRestarts <- base::computeRestarts
[10:25:46.051]                           grepl <- base::grepl
[10:25:46.051]                           restarts <- computeRestarts(cond)
[10:25:46.051]                           for (restart in restarts) {
[10:25:46.051]                             name <- restart$name
[10:25:46.051]                             if (is.null(name)) 
[10:25:46.051]                               next
[10:25:46.051]                             if (!grepl(pattern, name)) 
[10:25:46.051]                               next
[10:25:46.051]                             invokeRestart(restart)
[10:25:46.051]                             muffled <- TRUE
[10:25:46.051]                             break
[10:25:46.051]                           }
[10:25:46.051]                         }
[10:25:46.051]                       }
[10:25:46.051]                       invisible(muffled)
[10:25:46.051]                     }
[10:25:46.051]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.051]                   }
[10:25:46.051]                 }
[10:25:46.051]             }
[10:25:46.051]         }))
[10:25:46.051]     }, error = function(ex) {
[10:25:46.051]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.051]                 ...future.rng), started = ...future.startTime, 
[10:25:46.051]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.051]             version = "1.8"), class = "FutureResult")
[10:25:46.051]     }, finally = {
[10:25:46.051]         if (!identical(...future.workdir, getwd())) 
[10:25:46.051]             setwd(...future.workdir)
[10:25:46.051]         {
[10:25:46.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.051]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.051]             }
[10:25:46.051]             base::options(...future.oldOptions)
[10:25:46.051]             if (.Platform$OS.type == "windows") {
[10:25:46.051]                 old_names <- names(...future.oldEnvVars)
[10:25:46.051]                 envs <- base::Sys.getenv()
[10:25:46.051]                 names <- names(envs)
[10:25:46.051]                 common <- intersect(names, old_names)
[10:25:46.051]                 added <- setdiff(names, old_names)
[10:25:46.051]                 removed <- setdiff(old_names, names)
[10:25:46.051]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.051]                   envs[common]]
[10:25:46.051]                 NAMES <- toupper(changed)
[10:25:46.051]                 args <- list()
[10:25:46.051]                 for (kk in seq_along(NAMES)) {
[10:25:46.051]                   name <- changed[[kk]]
[10:25:46.051]                   NAME <- NAMES[[kk]]
[10:25:46.051]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.051]                     next
[10:25:46.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.051]                 }
[10:25:46.051]                 NAMES <- toupper(added)
[10:25:46.051]                 for (kk in seq_along(NAMES)) {
[10:25:46.051]                   name <- added[[kk]]
[10:25:46.051]                   NAME <- NAMES[[kk]]
[10:25:46.051]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.051]                     next
[10:25:46.051]                   args[[name]] <- ""
[10:25:46.051]                 }
[10:25:46.051]                 NAMES <- toupper(removed)
[10:25:46.051]                 for (kk in seq_along(NAMES)) {
[10:25:46.051]                   name <- removed[[kk]]
[10:25:46.051]                   NAME <- NAMES[[kk]]
[10:25:46.051]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.051]                     next
[10:25:46.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.051]                 }
[10:25:46.051]                 if (length(args) > 0) 
[10:25:46.051]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.051]             }
[10:25:46.051]             else {
[10:25:46.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.051]             }
[10:25:46.051]             {
[10:25:46.051]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.051]                   0L) {
[10:25:46.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.051]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.051]                   base::options(opts)
[10:25:46.051]                 }
[10:25:46.051]                 {
[10:25:46.051]                   {
[10:25:46.051]                     NULL
[10:25:46.051]                     RNGkind("Mersenne-Twister")
[10:25:46.051]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.051]                       inherits = FALSE)
[10:25:46.051]                   }
[10:25:46.051]                   options(future.plan = NULL)
[10:25:46.051]                   if (is.na(NA_character_)) 
[10:25:46.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.051]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.051]                   {
[10:25:46.051]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.051]                     if (!future$lazy) 
[10:25:46.051]                       future <- run(future)
[10:25:46.051]                     invisible(future)
[10:25:46.051]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.051]                 }
[10:25:46.051]             }
[10:25:46.051]         }
[10:25:46.051]     })
[10:25:46.051]     if (TRUE) {
[10:25:46.051]         base::sink(type = "output", split = FALSE)
[10:25:46.051]         if (TRUE) {
[10:25:46.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.051]         }
[10:25:46.051]         else {
[10:25:46.051]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.051]         }
[10:25:46.051]         base::close(...future.stdout)
[10:25:46.051]         ...future.stdout <- NULL
[10:25:46.051]     }
[10:25:46.051]     ...future.result$conditions <- ...future.conditions
[10:25:46.051]     ...future.result$finished <- base::Sys.time()
[10:25:46.051]     ...future.result
[10:25:46.051] }
[10:25:46.053] plan(): Setting new future strategy stack:
[10:25:46.053] List of future strategies:
[10:25:46.053] 1. sequential:
[10:25:46.053]    - args: function (..., envir = parent.frame())
[10:25:46.053]    - tweaked: FALSE
[10:25:46.053]    - call: NULL
[10:25:46.053] plan(): nbrOfWorkers() = 1
[10:25:46.054] plan(): Setting new future strategy stack:
[10:25:46.054] List of future strategies:
[10:25:46.054] 1. sequential:
[10:25:46.054]    - args: function (..., envir = parent.frame())
[10:25:46.054]    - tweaked: FALSE
[10:25:46.054]    - call: plan(strategy)
[10:25:46.055] plan(): nbrOfWorkers() = 1
[10:25:46.055] SequentialFuture started (and completed)
[10:25:46.055] - Launch lazy future ... done
[10:25:46.055] run() for ‘SequentialFuture’ ... done
[10:25:46.055] getGlobalsAndPackages() ...
[10:25:46.055] Searching for globals...
[10:25:46.055] 
[10:25:46.055] Searching for globals ... DONE
[10:25:46.056] - globals: [0] <none>
[10:25:46.056] getGlobalsAndPackages() ... DONE
[10:25:46.056] run() for ‘Future’ ...
[10:25:46.056] - state: ‘created’
[10:25:46.056] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.056] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.056]   - Field: ‘label’
[10:25:46.057]   - Field: ‘local’
[10:25:46.057]   - Field: ‘owner’
[10:25:46.057]   - Field: ‘envir’
[10:25:46.057]   - Field: ‘packages’
[10:25:46.057]   - Field: ‘gc’
[10:25:46.057]   - Field: ‘conditions’
[10:25:46.057]   - Field: ‘expr’
[10:25:46.057]   - Field: ‘uuid’
[10:25:46.057]   - Field: ‘seed’
[10:25:46.057]   - Field: ‘version’
[10:25:46.057]   - Field: ‘result’
[10:25:46.058]   - Field: ‘asynchronous’
[10:25:46.058]   - Field: ‘calls’
[10:25:46.058]   - Field: ‘globals’
[10:25:46.058]   - Field: ‘stdout’
[10:25:46.058]   - Field: ‘earlySignal’
[10:25:46.058]   - Field: ‘lazy’
[10:25:46.058]   - Field: ‘state’
[10:25:46.058] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.058] - Launch lazy future ...
[10:25:46.058] Packages needed by the future expression (n = 0): <none>
[10:25:46.058] Packages needed by future strategies (n = 0): <none>
[10:25:46.059] {
[10:25:46.059]     {
[10:25:46.059]         {
[10:25:46.059]             ...future.startTime <- base::Sys.time()
[10:25:46.059]             {
[10:25:46.059]                 {
[10:25:46.059]                   {
[10:25:46.059]                     base::local({
[10:25:46.059]                       has_future <- base::requireNamespace("future", 
[10:25:46.059]                         quietly = TRUE)
[10:25:46.059]                       if (has_future) {
[10:25:46.059]                         ns <- base::getNamespace("future")
[10:25:46.059]                         version <- ns[[".package"]][["version"]]
[10:25:46.059]                         if (is.null(version)) 
[10:25:46.059]                           version <- utils::packageVersion("future")
[10:25:46.059]                       }
[10:25:46.059]                       else {
[10:25:46.059]                         version <- NULL
[10:25:46.059]                       }
[10:25:46.059]                       if (!has_future || version < "1.8.0") {
[10:25:46.059]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.059]                           "", base::R.version$version.string), 
[10:25:46.059]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.059]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.059]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.059]                             "release", "version")], collapse = " "), 
[10:25:46.059]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.059]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.059]                           info)
[10:25:46.059]                         info <- base::paste(info, collapse = "; ")
[10:25:46.059]                         if (!has_future) {
[10:25:46.059]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.059]                             info)
[10:25:46.059]                         }
[10:25:46.059]                         else {
[10:25:46.059]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.059]                             info, version)
[10:25:46.059]                         }
[10:25:46.059]                         base::stop(msg)
[10:25:46.059]                       }
[10:25:46.059]                     })
[10:25:46.059]                   }
[10:25:46.059]                   options(future.plan = NULL)
[10:25:46.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.059]                 }
[10:25:46.059]                 ...future.workdir <- getwd()
[10:25:46.059]             }
[10:25:46.059]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.059]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.059]         }
[10:25:46.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.059]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.059]             base::names(...future.oldOptions))
[10:25:46.059]     }
[10:25:46.059]     if (FALSE) {
[10:25:46.059]     }
[10:25:46.059]     else {
[10:25:46.059]         if (TRUE) {
[10:25:46.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.059]                 open = "w")
[10:25:46.059]         }
[10:25:46.059]         else {
[10:25:46.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.059]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.059]         }
[10:25:46.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.059]             base::sink(type = "output", split = FALSE)
[10:25:46.059]             base::close(...future.stdout)
[10:25:46.059]         }, add = TRUE)
[10:25:46.059]     }
[10:25:46.059]     ...future.frame <- base::sys.nframe()
[10:25:46.059]     ...future.conditions <- base::list()
[10:25:46.059]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.059]     if (FALSE) {
[10:25:46.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.059]     }
[10:25:46.059]     ...future.result <- base::tryCatch({
[10:25:46.059]         base::withCallingHandlers({
[10:25:46.059]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.059]             future::FutureResult(value = ...future.value$value, 
[10:25:46.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.059]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.059]                     ...future.globalenv.names))
[10:25:46.059]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.059]         }, condition = base::local({
[10:25:46.059]             c <- base::c
[10:25:46.059]             inherits <- base::inherits
[10:25:46.059]             invokeRestart <- base::invokeRestart
[10:25:46.059]             length <- base::length
[10:25:46.059]             list <- base::list
[10:25:46.059]             seq.int <- base::seq.int
[10:25:46.059]             signalCondition <- base::signalCondition
[10:25:46.059]             sys.calls <- base::sys.calls
[10:25:46.059]             `[[` <- base::`[[`
[10:25:46.059]             `+` <- base::`+`
[10:25:46.059]             `<<-` <- base::`<<-`
[10:25:46.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.059]                   3L)]
[10:25:46.059]             }
[10:25:46.059]             function(cond) {
[10:25:46.059]                 is_error <- inherits(cond, "error")
[10:25:46.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.059]                   NULL)
[10:25:46.059]                 if (is_error) {
[10:25:46.059]                   sessionInformation <- function() {
[10:25:46.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.059]                       search = base::search(), system = base::Sys.info())
[10:25:46.059]                   }
[10:25:46.059]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.059]                     cond$call), session = sessionInformation(), 
[10:25:46.059]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.059]                   signalCondition(cond)
[10:25:46.059]                 }
[10:25:46.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.059]                 "immediateCondition"))) {
[10:25:46.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.059]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.059]                   if (TRUE && !signal) {
[10:25:46.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.059]                     {
[10:25:46.059]                       inherits <- base::inherits
[10:25:46.059]                       invokeRestart <- base::invokeRestart
[10:25:46.059]                       is.null <- base::is.null
[10:25:46.059]                       muffled <- FALSE
[10:25:46.059]                       if (inherits(cond, "message")) {
[10:25:46.059]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.059]                         if (muffled) 
[10:25:46.059]                           invokeRestart("muffleMessage")
[10:25:46.059]                       }
[10:25:46.059]                       else if (inherits(cond, "warning")) {
[10:25:46.059]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.059]                         if (muffled) 
[10:25:46.059]                           invokeRestart("muffleWarning")
[10:25:46.059]                       }
[10:25:46.059]                       else if (inherits(cond, "condition")) {
[10:25:46.059]                         if (!is.null(pattern)) {
[10:25:46.059]                           computeRestarts <- base::computeRestarts
[10:25:46.059]                           grepl <- base::grepl
[10:25:46.059]                           restarts <- computeRestarts(cond)
[10:25:46.059]                           for (restart in restarts) {
[10:25:46.059]                             name <- restart$name
[10:25:46.059]                             if (is.null(name)) 
[10:25:46.059]                               next
[10:25:46.059]                             if (!grepl(pattern, name)) 
[10:25:46.059]                               next
[10:25:46.059]                             invokeRestart(restart)
[10:25:46.059]                             muffled <- TRUE
[10:25:46.059]                             break
[10:25:46.059]                           }
[10:25:46.059]                         }
[10:25:46.059]                       }
[10:25:46.059]                       invisible(muffled)
[10:25:46.059]                     }
[10:25:46.059]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.059]                   }
[10:25:46.059]                 }
[10:25:46.059]                 else {
[10:25:46.059]                   if (TRUE) {
[10:25:46.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.059]                     {
[10:25:46.059]                       inherits <- base::inherits
[10:25:46.059]                       invokeRestart <- base::invokeRestart
[10:25:46.059]                       is.null <- base::is.null
[10:25:46.059]                       muffled <- FALSE
[10:25:46.059]                       if (inherits(cond, "message")) {
[10:25:46.059]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.059]                         if (muffled) 
[10:25:46.059]                           invokeRestart("muffleMessage")
[10:25:46.059]                       }
[10:25:46.059]                       else if (inherits(cond, "warning")) {
[10:25:46.059]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.059]                         if (muffled) 
[10:25:46.059]                           invokeRestart("muffleWarning")
[10:25:46.059]                       }
[10:25:46.059]                       else if (inherits(cond, "condition")) {
[10:25:46.059]                         if (!is.null(pattern)) {
[10:25:46.059]                           computeRestarts <- base::computeRestarts
[10:25:46.059]                           grepl <- base::grepl
[10:25:46.059]                           restarts <- computeRestarts(cond)
[10:25:46.059]                           for (restart in restarts) {
[10:25:46.059]                             name <- restart$name
[10:25:46.059]                             if (is.null(name)) 
[10:25:46.059]                               next
[10:25:46.059]                             if (!grepl(pattern, name)) 
[10:25:46.059]                               next
[10:25:46.059]                             invokeRestart(restart)
[10:25:46.059]                             muffled <- TRUE
[10:25:46.059]                             break
[10:25:46.059]                           }
[10:25:46.059]                         }
[10:25:46.059]                       }
[10:25:46.059]                       invisible(muffled)
[10:25:46.059]                     }
[10:25:46.059]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.059]                   }
[10:25:46.059]                 }
[10:25:46.059]             }
[10:25:46.059]         }))
[10:25:46.059]     }, error = function(ex) {
[10:25:46.059]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.059]                 ...future.rng), started = ...future.startTime, 
[10:25:46.059]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.059]             version = "1.8"), class = "FutureResult")
[10:25:46.059]     }, finally = {
[10:25:46.059]         if (!identical(...future.workdir, getwd())) 
[10:25:46.059]             setwd(...future.workdir)
[10:25:46.059]         {
[10:25:46.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.059]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.059]             }
[10:25:46.059]             base::options(...future.oldOptions)
[10:25:46.059]             if (.Platform$OS.type == "windows") {
[10:25:46.059]                 old_names <- names(...future.oldEnvVars)
[10:25:46.059]                 envs <- base::Sys.getenv()
[10:25:46.059]                 names <- names(envs)
[10:25:46.059]                 common <- intersect(names, old_names)
[10:25:46.059]                 added <- setdiff(names, old_names)
[10:25:46.059]                 removed <- setdiff(old_names, names)
[10:25:46.059]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.059]                   envs[common]]
[10:25:46.059]                 NAMES <- toupper(changed)
[10:25:46.059]                 args <- list()
[10:25:46.059]                 for (kk in seq_along(NAMES)) {
[10:25:46.059]                   name <- changed[[kk]]
[10:25:46.059]                   NAME <- NAMES[[kk]]
[10:25:46.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.059]                     next
[10:25:46.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.059]                 }
[10:25:46.059]                 NAMES <- toupper(added)
[10:25:46.059]                 for (kk in seq_along(NAMES)) {
[10:25:46.059]                   name <- added[[kk]]
[10:25:46.059]                   NAME <- NAMES[[kk]]
[10:25:46.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.059]                     next
[10:25:46.059]                   args[[name]] <- ""
[10:25:46.059]                 }
[10:25:46.059]                 NAMES <- toupper(removed)
[10:25:46.059]                 for (kk in seq_along(NAMES)) {
[10:25:46.059]                   name <- removed[[kk]]
[10:25:46.059]                   NAME <- NAMES[[kk]]
[10:25:46.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.059]                     next
[10:25:46.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.059]                 }
[10:25:46.059]                 if (length(args) > 0) 
[10:25:46.059]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.059]             }
[10:25:46.059]             else {
[10:25:46.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.059]             }
[10:25:46.059]             {
[10:25:46.059]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.059]                   0L) {
[10:25:46.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.059]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.059]                   base::options(opts)
[10:25:46.059]                 }
[10:25:46.059]                 {
[10:25:46.059]                   {
[10:25:46.059]                     NULL
[10:25:46.059]                     RNGkind("Mersenne-Twister")
[10:25:46.059]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.059]                       inherits = FALSE)
[10:25:46.059]                   }
[10:25:46.059]                   options(future.plan = NULL)
[10:25:46.059]                   if (is.na(NA_character_)) 
[10:25:46.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.059]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.059]                   {
[10:25:46.059]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.059]                     if (!future$lazy) 
[10:25:46.059]                       future <- run(future)
[10:25:46.059]                     invisible(future)
[10:25:46.059]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.059]                 }
[10:25:46.059]             }
[10:25:46.059]         }
[10:25:46.059]     })
[10:25:46.059]     if (TRUE) {
[10:25:46.059]         base::sink(type = "output", split = FALSE)
[10:25:46.059]         if (TRUE) {
[10:25:46.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.059]         }
[10:25:46.059]         else {
[10:25:46.059]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.059]         }
[10:25:46.059]         base::close(...future.stdout)
[10:25:46.059]         ...future.stdout <- NULL
[10:25:46.059]     }
[10:25:46.059]     ...future.result$conditions <- ...future.conditions
[10:25:46.059]     ...future.result$finished <- base::Sys.time()
[10:25:46.059]     ...future.result
[10:25:46.059] }
[10:25:46.061] plan(): Setting new future strategy stack:
[10:25:46.061] List of future strategies:
[10:25:46.061] 1. sequential:
[10:25:46.061]    - args: function (..., envir = parent.frame())
[10:25:46.061]    - tweaked: FALSE
[10:25:46.061]    - call: NULL
[10:25:46.061] plan(): nbrOfWorkers() = 1
[10:25:46.062] plan(): Setting new future strategy stack:
[10:25:46.062] List of future strategies:
[10:25:46.062] 1. sequential:
[10:25:46.062]    - args: function (..., envir = parent.frame())
[10:25:46.062]    - tweaked: FALSE
[10:25:46.062]    - call: plan(strategy)
[10:25:46.062] plan(): nbrOfWorkers() = 1
[10:25:46.064] SequentialFuture started (and completed)
[10:25:46.064] - Launch lazy future ... done
[10:25:46.064] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f5073c38> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f545b978> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f5073c38> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55c0f545b978> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:25:46.069] resolved() for ‘SequentialFuture’ ...
[10:25:46.069] - state: ‘finished’
[10:25:46.069] - run: TRUE
[10:25:46.069] - result: ‘FutureResult’
[10:25:46.069] resolved() for ‘SequentialFuture’ ... done
[10:25:46.070] resolved() for ‘SequentialFuture’ ...
[10:25:46.070] - state: ‘finished’
[10:25:46.070] - run: TRUE
[10:25:46.070] - result: ‘FutureResult’
[10:25:46.070] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:46.072] resolve() on list ...
[10:25:46.072]  recursive: 0
[10:25:46.072]  length: 6
[10:25:46.072]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:46.072] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.072] - nx: 6
[10:25:46.072] - relay: TRUE
[10:25:46.072] - stdout: TRUE
[10:25:46.073] - signal: TRUE
[10:25:46.073] - resignal: FALSE
[10:25:46.073] - force: TRUE
[10:25:46.073] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.073] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.073]  - until=2
[10:25:46.073]  - relaying element #2
[10:25:46.073] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.073] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.073] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.073]  length: 5 (resolved future 1)
[10:25:46.074] resolved() for ‘SequentialFuture’ ...
[10:25:46.074] - state: ‘finished’
[10:25:46.074] - run: TRUE
[10:25:46.074] - result: ‘FutureResult’
[10:25:46.074] resolved() for ‘SequentialFuture’ ... done
[10:25:46.074] Future #2
[10:25:46.074] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.074] - nx: 6
[10:25:46.074] - relay: TRUE
[10:25:46.074] - stdout: TRUE
[10:25:46.074] - signal: TRUE
[10:25:46.075] - resignal: FALSE
[10:25:46.075] - force: TRUE
[10:25:46.075] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.075] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.075]  - until=2
[10:25:46.075]  - relaying element #2
[10:25:46.075] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.075] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.075] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.075]  length: 4 (resolved future 2)
[10:25:46.075] resolved() for ‘SequentialFuture’ ...
[10:25:46.076] - state: ‘finished’
[10:25:46.076] - run: TRUE
[10:25:46.076] - result: ‘FutureResult’
[10:25:46.076] resolved() for ‘SequentialFuture’ ... done
[10:25:46.076] Future #3
[10:25:46.076] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.076] - nx: 6
[10:25:46.076] - relay: TRUE
[10:25:46.076] - stdout: TRUE
[10:25:46.076] - signal: TRUE
[10:25:46.076] - resignal: FALSE
[10:25:46.077] - force: TRUE
[10:25:46.077] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.077] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.077]  - until=3
[10:25:46.077]  - relaying element #3
[10:25:46.077] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.077] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.077] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.077]  length: 3 (resolved future 3)
[10:25:46.077] signalConditionsASAP(NULL, pos=4) ...
[10:25:46.078] - nx: 6
[10:25:46.078] - relay: TRUE
[10:25:46.078] - stdout: TRUE
[10:25:46.078] - signal: TRUE
[10:25:46.078] - resignal: FALSE
[10:25:46.078] - force: TRUE
[10:25:46.078] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.078] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.078]  - until=5
[10:25:46.078]  - relaying element #5
[10:25:46.078] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.078] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.079] signalConditionsASAP(NULL, pos=4) ... done
[10:25:46.079]  length: 2 (resolved future 4)
[10:25:46.079] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.079] - nx: 6
[10:25:46.079] - relay: TRUE
[10:25:46.079] - stdout: TRUE
[10:25:46.079] - signal: TRUE
[10:25:46.079] - resignal: FALSE
[10:25:46.079] - force: TRUE
[10:25:46.079] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.079] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.079]  - until=6
[10:25:46.080]  - relaying element #6
[10:25:46.080] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.080] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.080] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.080]  length: 1 (resolved future 5)
[10:25:46.080] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.080] - nx: 6
[10:25:46.080] - relay: TRUE
[10:25:46.080] - stdout: TRUE
[10:25:46.080] - signal: TRUE
[10:25:46.080] - resignal: FALSE
[10:25:46.080] - force: TRUE
[10:25:46.080] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.081] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.081]  - until=6
[10:25:46.081] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.081] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.081] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.081]  length: 0 (resolved future 6)
[10:25:46.081] Relaying remaining futures
[10:25:46.081] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.081] - nx: 6
[10:25:46.081] - relay: TRUE
[10:25:46.081] - stdout: TRUE
[10:25:46.081] - signal: TRUE
[10:25:46.082] - resignal: FALSE
[10:25:46.082] - force: TRUE
[10:25:46.082] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.082] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:46.082] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.082] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.082] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.082] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[10:25:46.092] plan(): Setting new future strategy stack:
[10:25:46.092] List of future strategies:
[10:25:46.092] 1. sequential:
[10:25:46.092]    - args: function (..., envir = parent.frame())
[10:25:46.092]    - tweaked: FALSE
[10:25:46.092]    - call: plan(strategy)
[10:25:46.093] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[10:25:46.093] getGlobalsAndPackages() ...
[10:25:46.093] Searching for globals...
[10:25:46.093] 
[10:25:46.093] Searching for globals ... DONE
[10:25:46.093] - globals: [0] <none>
[10:25:46.093] getGlobalsAndPackages() ... DONE
[10:25:46.094] run() for ‘Future’ ...
[10:25:46.094] - state: ‘created’
[10:25:46.094] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.094] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.094]   - Field: ‘label’
[10:25:46.094]   - Field: ‘local’
[10:25:46.095]   - Field: ‘owner’
[10:25:46.095]   - Field: ‘envir’
[10:25:46.095]   - Field: ‘packages’
[10:25:46.095]   - Field: ‘gc’
[10:25:46.095]   - Field: ‘conditions’
[10:25:46.095]   - Field: ‘expr’
[10:25:46.095]   - Field: ‘uuid’
[10:25:46.095]   - Field: ‘seed’
[10:25:46.095]   - Field: ‘version’
[10:25:46.095]   - Field: ‘result’
[10:25:46.095]   - Field: ‘asynchronous’
[10:25:46.096]   - Field: ‘calls’
[10:25:46.096]   - Field: ‘globals’
[10:25:46.096]   - Field: ‘stdout’
[10:25:46.096]   - Field: ‘earlySignal’
[10:25:46.096]   - Field: ‘lazy’
[10:25:46.096]   - Field: ‘state’
[10:25:46.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.096] - Launch lazy future ...
[10:25:46.096] Packages needed by the future expression (n = 0): <none>
[10:25:46.096] Packages needed by future strategies (n = 0): <none>
[10:25:46.097] {
[10:25:46.097]     {
[10:25:46.097]         {
[10:25:46.097]             ...future.startTime <- base::Sys.time()
[10:25:46.097]             {
[10:25:46.097]                 {
[10:25:46.097]                   {
[10:25:46.097]                     base::local({
[10:25:46.097]                       has_future <- base::requireNamespace("future", 
[10:25:46.097]                         quietly = TRUE)
[10:25:46.097]                       if (has_future) {
[10:25:46.097]                         ns <- base::getNamespace("future")
[10:25:46.097]                         version <- ns[[".package"]][["version"]]
[10:25:46.097]                         if (is.null(version)) 
[10:25:46.097]                           version <- utils::packageVersion("future")
[10:25:46.097]                       }
[10:25:46.097]                       else {
[10:25:46.097]                         version <- NULL
[10:25:46.097]                       }
[10:25:46.097]                       if (!has_future || version < "1.8.0") {
[10:25:46.097]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.097]                           "", base::R.version$version.string), 
[10:25:46.097]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.097]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.097]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.097]                             "release", "version")], collapse = " "), 
[10:25:46.097]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.097]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.097]                           info)
[10:25:46.097]                         info <- base::paste(info, collapse = "; ")
[10:25:46.097]                         if (!has_future) {
[10:25:46.097]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.097]                             info)
[10:25:46.097]                         }
[10:25:46.097]                         else {
[10:25:46.097]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.097]                             info, version)
[10:25:46.097]                         }
[10:25:46.097]                         base::stop(msg)
[10:25:46.097]                       }
[10:25:46.097]                     })
[10:25:46.097]                   }
[10:25:46.097]                   options(future.plan = NULL)
[10:25:46.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.097]                 }
[10:25:46.097]                 ...future.workdir <- getwd()
[10:25:46.097]             }
[10:25:46.097]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.097]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.097]         }
[10:25:46.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.097]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.097]             base::names(...future.oldOptions))
[10:25:46.097]     }
[10:25:46.097]     if (FALSE) {
[10:25:46.097]     }
[10:25:46.097]     else {
[10:25:46.097]         if (TRUE) {
[10:25:46.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.097]                 open = "w")
[10:25:46.097]         }
[10:25:46.097]         else {
[10:25:46.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.097]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.097]         }
[10:25:46.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.097]             base::sink(type = "output", split = FALSE)
[10:25:46.097]             base::close(...future.stdout)
[10:25:46.097]         }, add = TRUE)
[10:25:46.097]     }
[10:25:46.097]     ...future.frame <- base::sys.nframe()
[10:25:46.097]     ...future.conditions <- base::list()
[10:25:46.097]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.097]     if (FALSE) {
[10:25:46.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.097]     }
[10:25:46.097]     ...future.result <- base::tryCatch({
[10:25:46.097]         base::withCallingHandlers({
[10:25:46.097]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.097]             future::FutureResult(value = ...future.value$value, 
[10:25:46.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.097]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.097]                     ...future.globalenv.names))
[10:25:46.097]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.097]         }, condition = base::local({
[10:25:46.097]             c <- base::c
[10:25:46.097]             inherits <- base::inherits
[10:25:46.097]             invokeRestart <- base::invokeRestart
[10:25:46.097]             length <- base::length
[10:25:46.097]             list <- base::list
[10:25:46.097]             seq.int <- base::seq.int
[10:25:46.097]             signalCondition <- base::signalCondition
[10:25:46.097]             sys.calls <- base::sys.calls
[10:25:46.097]             `[[` <- base::`[[`
[10:25:46.097]             `+` <- base::`+`
[10:25:46.097]             `<<-` <- base::`<<-`
[10:25:46.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.097]                   3L)]
[10:25:46.097]             }
[10:25:46.097]             function(cond) {
[10:25:46.097]                 is_error <- inherits(cond, "error")
[10:25:46.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.097]                   NULL)
[10:25:46.097]                 if (is_error) {
[10:25:46.097]                   sessionInformation <- function() {
[10:25:46.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.097]                       search = base::search(), system = base::Sys.info())
[10:25:46.097]                   }
[10:25:46.097]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.097]                     cond$call), session = sessionInformation(), 
[10:25:46.097]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.097]                   signalCondition(cond)
[10:25:46.097]                 }
[10:25:46.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.097]                 "immediateCondition"))) {
[10:25:46.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.097]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.097]                   if (TRUE && !signal) {
[10:25:46.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.097]                     {
[10:25:46.097]                       inherits <- base::inherits
[10:25:46.097]                       invokeRestart <- base::invokeRestart
[10:25:46.097]                       is.null <- base::is.null
[10:25:46.097]                       muffled <- FALSE
[10:25:46.097]                       if (inherits(cond, "message")) {
[10:25:46.097]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.097]                         if (muffled) 
[10:25:46.097]                           invokeRestart("muffleMessage")
[10:25:46.097]                       }
[10:25:46.097]                       else if (inherits(cond, "warning")) {
[10:25:46.097]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.097]                         if (muffled) 
[10:25:46.097]                           invokeRestart("muffleWarning")
[10:25:46.097]                       }
[10:25:46.097]                       else if (inherits(cond, "condition")) {
[10:25:46.097]                         if (!is.null(pattern)) {
[10:25:46.097]                           computeRestarts <- base::computeRestarts
[10:25:46.097]                           grepl <- base::grepl
[10:25:46.097]                           restarts <- computeRestarts(cond)
[10:25:46.097]                           for (restart in restarts) {
[10:25:46.097]                             name <- restart$name
[10:25:46.097]                             if (is.null(name)) 
[10:25:46.097]                               next
[10:25:46.097]                             if (!grepl(pattern, name)) 
[10:25:46.097]                               next
[10:25:46.097]                             invokeRestart(restart)
[10:25:46.097]                             muffled <- TRUE
[10:25:46.097]                             break
[10:25:46.097]                           }
[10:25:46.097]                         }
[10:25:46.097]                       }
[10:25:46.097]                       invisible(muffled)
[10:25:46.097]                     }
[10:25:46.097]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.097]                   }
[10:25:46.097]                 }
[10:25:46.097]                 else {
[10:25:46.097]                   if (TRUE) {
[10:25:46.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.097]                     {
[10:25:46.097]                       inherits <- base::inherits
[10:25:46.097]                       invokeRestart <- base::invokeRestart
[10:25:46.097]                       is.null <- base::is.null
[10:25:46.097]                       muffled <- FALSE
[10:25:46.097]                       if (inherits(cond, "message")) {
[10:25:46.097]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.097]                         if (muffled) 
[10:25:46.097]                           invokeRestart("muffleMessage")
[10:25:46.097]                       }
[10:25:46.097]                       else if (inherits(cond, "warning")) {
[10:25:46.097]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.097]                         if (muffled) 
[10:25:46.097]                           invokeRestart("muffleWarning")
[10:25:46.097]                       }
[10:25:46.097]                       else if (inherits(cond, "condition")) {
[10:25:46.097]                         if (!is.null(pattern)) {
[10:25:46.097]                           computeRestarts <- base::computeRestarts
[10:25:46.097]                           grepl <- base::grepl
[10:25:46.097]                           restarts <- computeRestarts(cond)
[10:25:46.097]                           for (restart in restarts) {
[10:25:46.097]                             name <- restart$name
[10:25:46.097]                             if (is.null(name)) 
[10:25:46.097]                               next
[10:25:46.097]                             if (!grepl(pattern, name)) 
[10:25:46.097]                               next
[10:25:46.097]                             invokeRestart(restart)
[10:25:46.097]                             muffled <- TRUE
[10:25:46.097]                             break
[10:25:46.097]                           }
[10:25:46.097]                         }
[10:25:46.097]                       }
[10:25:46.097]                       invisible(muffled)
[10:25:46.097]                     }
[10:25:46.097]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.097]                   }
[10:25:46.097]                 }
[10:25:46.097]             }
[10:25:46.097]         }))
[10:25:46.097]     }, error = function(ex) {
[10:25:46.097]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.097]                 ...future.rng), started = ...future.startTime, 
[10:25:46.097]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.097]             version = "1.8"), class = "FutureResult")
[10:25:46.097]     }, finally = {
[10:25:46.097]         if (!identical(...future.workdir, getwd())) 
[10:25:46.097]             setwd(...future.workdir)
[10:25:46.097]         {
[10:25:46.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.097]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.097]             }
[10:25:46.097]             base::options(...future.oldOptions)
[10:25:46.097]             if (.Platform$OS.type == "windows") {
[10:25:46.097]                 old_names <- names(...future.oldEnvVars)
[10:25:46.097]                 envs <- base::Sys.getenv()
[10:25:46.097]                 names <- names(envs)
[10:25:46.097]                 common <- intersect(names, old_names)
[10:25:46.097]                 added <- setdiff(names, old_names)
[10:25:46.097]                 removed <- setdiff(old_names, names)
[10:25:46.097]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.097]                   envs[common]]
[10:25:46.097]                 NAMES <- toupper(changed)
[10:25:46.097]                 args <- list()
[10:25:46.097]                 for (kk in seq_along(NAMES)) {
[10:25:46.097]                   name <- changed[[kk]]
[10:25:46.097]                   NAME <- NAMES[[kk]]
[10:25:46.097]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.097]                     next
[10:25:46.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.097]                 }
[10:25:46.097]                 NAMES <- toupper(added)
[10:25:46.097]                 for (kk in seq_along(NAMES)) {
[10:25:46.097]                   name <- added[[kk]]
[10:25:46.097]                   NAME <- NAMES[[kk]]
[10:25:46.097]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.097]                     next
[10:25:46.097]                   args[[name]] <- ""
[10:25:46.097]                 }
[10:25:46.097]                 NAMES <- toupper(removed)
[10:25:46.097]                 for (kk in seq_along(NAMES)) {
[10:25:46.097]                   name <- removed[[kk]]
[10:25:46.097]                   NAME <- NAMES[[kk]]
[10:25:46.097]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.097]                     next
[10:25:46.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.097]                 }
[10:25:46.097]                 if (length(args) > 0) 
[10:25:46.097]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.097]             }
[10:25:46.097]             else {
[10:25:46.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.097]             }
[10:25:46.097]             {
[10:25:46.097]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.097]                   0L) {
[10:25:46.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.097]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.097]                   base::options(opts)
[10:25:46.097]                 }
[10:25:46.097]                 {
[10:25:46.097]                   {
[10:25:46.097]                     NULL
[10:25:46.097]                     RNGkind("Mersenne-Twister")
[10:25:46.097]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.097]                       inherits = FALSE)
[10:25:46.097]                   }
[10:25:46.097]                   options(future.plan = NULL)
[10:25:46.097]                   if (is.na(NA_character_)) 
[10:25:46.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.097]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.097]                   {
[10:25:46.097]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.097]                     if (!future$lazy) 
[10:25:46.097]                       future <- run(future)
[10:25:46.097]                     invisible(future)
[10:25:46.097]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.097]                 }
[10:25:46.097]             }
[10:25:46.097]         }
[10:25:46.097]     })
[10:25:46.097]     if (TRUE) {
[10:25:46.097]         base::sink(type = "output", split = FALSE)
[10:25:46.097]         if (TRUE) {
[10:25:46.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.097]         }
[10:25:46.097]         else {
[10:25:46.097]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.097]         }
[10:25:46.097]         base::close(...future.stdout)
[10:25:46.097]         ...future.stdout <- NULL
[10:25:46.097]     }
[10:25:46.097]     ...future.result$conditions <- ...future.conditions
[10:25:46.097]     ...future.result$finished <- base::Sys.time()
[10:25:46.097]     ...future.result
[10:25:46.097] }
[10:25:46.099] plan(): Setting new future strategy stack:
[10:25:46.099] List of future strategies:
[10:25:46.099] 1. sequential:
[10:25:46.099]    - args: function (..., envir = parent.frame())
[10:25:46.099]    - tweaked: FALSE
[10:25:46.099]    - call: NULL
[10:25:46.099] plan(): nbrOfWorkers() = 1
[10:25:46.100] plan(): Setting new future strategy stack:
[10:25:46.100] List of future strategies:
[10:25:46.100] 1. sequential:
[10:25:46.100]    - args: function (..., envir = parent.frame())
[10:25:46.100]    - tweaked: FALSE
[10:25:46.100]    - call: plan(strategy)
[10:25:46.100] plan(): nbrOfWorkers() = 1
[10:25:46.100] SequentialFuture started (and completed)
[10:25:46.101] - Launch lazy future ... done
[10:25:46.101] run() for ‘SequentialFuture’ ... done
[10:25:46.101] getGlobalsAndPackages() ...
[10:25:46.101] Searching for globals...
[10:25:46.101] 
[10:25:46.101] Searching for globals ... DONE
[10:25:46.101] - globals: [0] <none>
[10:25:46.101] getGlobalsAndPackages() ... DONE
[10:25:46.102] run() for ‘Future’ ...
[10:25:46.102] - state: ‘created’
[10:25:46.102] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.102] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.102]   - Field: ‘label’
[10:25:46.102]   - Field: ‘local’
[10:25:46.103]   - Field: ‘owner’
[10:25:46.103]   - Field: ‘envir’
[10:25:46.103]   - Field: ‘packages’
[10:25:46.103]   - Field: ‘gc’
[10:25:46.103]   - Field: ‘conditions’
[10:25:46.103]   - Field: ‘expr’
[10:25:46.103]   - Field: ‘uuid’
[10:25:46.103]   - Field: ‘seed’
[10:25:46.103]   - Field: ‘version’
[10:25:46.103]   - Field: ‘result’
[10:25:46.103]   - Field: ‘asynchronous’
[10:25:46.103]   - Field: ‘calls’
[10:25:46.104]   - Field: ‘globals’
[10:25:46.104]   - Field: ‘stdout’
[10:25:46.104]   - Field: ‘earlySignal’
[10:25:46.104]   - Field: ‘lazy’
[10:25:46.104]   - Field: ‘state’
[10:25:46.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.104] - Launch lazy future ...
[10:25:46.104] Packages needed by the future expression (n = 0): <none>
[10:25:46.104] Packages needed by future strategies (n = 0): <none>
[10:25:46.105] {
[10:25:46.105]     {
[10:25:46.105]         {
[10:25:46.105]             ...future.startTime <- base::Sys.time()
[10:25:46.105]             {
[10:25:46.105]                 {
[10:25:46.105]                   {
[10:25:46.105]                     base::local({
[10:25:46.105]                       has_future <- base::requireNamespace("future", 
[10:25:46.105]                         quietly = TRUE)
[10:25:46.105]                       if (has_future) {
[10:25:46.105]                         ns <- base::getNamespace("future")
[10:25:46.105]                         version <- ns[[".package"]][["version"]]
[10:25:46.105]                         if (is.null(version)) 
[10:25:46.105]                           version <- utils::packageVersion("future")
[10:25:46.105]                       }
[10:25:46.105]                       else {
[10:25:46.105]                         version <- NULL
[10:25:46.105]                       }
[10:25:46.105]                       if (!has_future || version < "1.8.0") {
[10:25:46.105]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.105]                           "", base::R.version$version.string), 
[10:25:46.105]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.105]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.105]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.105]                             "release", "version")], collapse = " "), 
[10:25:46.105]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.105]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.105]                           info)
[10:25:46.105]                         info <- base::paste(info, collapse = "; ")
[10:25:46.105]                         if (!has_future) {
[10:25:46.105]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.105]                             info)
[10:25:46.105]                         }
[10:25:46.105]                         else {
[10:25:46.105]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.105]                             info, version)
[10:25:46.105]                         }
[10:25:46.105]                         base::stop(msg)
[10:25:46.105]                       }
[10:25:46.105]                     })
[10:25:46.105]                   }
[10:25:46.105]                   options(future.plan = NULL)
[10:25:46.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.105]                 }
[10:25:46.105]                 ...future.workdir <- getwd()
[10:25:46.105]             }
[10:25:46.105]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.105]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.105]         }
[10:25:46.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.105]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.105]             base::names(...future.oldOptions))
[10:25:46.105]     }
[10:25:46.105]     if (FALSE) {
[10:25:46.105]     }
[10:25:46.105]     else {
[10:25:46.105]         if (TRUE) {
[10:25:46.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.105]                 open = "w")
[10:25:46.105]         }
[10:25:46.105]         else {
[10:25:46.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.105]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.105]         }
[10:25:46.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.105]             base::sink(type = "output", split = FALSE)
[10:25:46.105]             base::close(...future.stdout)
[10:25:46.105]         }, add = TRUE)
[10:25:46.105]     }
[10:25:46.105]     ...future.frame <- base::sys.nframe()
[10:25:46.105]     ...future.conditions <- base::list()
[10:25:46.105]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.105]     if (FALSE) {
[10:25:46.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.105]     }
[10:25:46.105]     ...future.result <- base::tryCatch({
[10:25:46.105]         base::withCallingHandlers({
[10:25:46.105]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.105]             future::FutureResult(value = ...future.value$value, 
[10:25:46.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.105]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.105]                     ...future.globalenv.names))
[10:25:46.105]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.105]         }, condition = base::local({
[10:25:46.105]             c <- base::c
[10:25:46.105]             inherits <- base::inherits
[10:25:46.105]             invokeRestart <- base::invokeRestart
[10:25:46.105]             length <- base::length
[10:25:46.105]             list <- base::list
[10:25:46.105]             seq.int <- base::seq.int
[10:25:46.105]             signalCondition <- base::signalCondition
[10:25:46.105]             sys.calls <- base::sys.calls
[10:25:46.105]             `[[` <- base::`[[`
[10:25:46.105]             `+` <- base::`+`
[10:25:46.105]             `<<-` <- base::`<<-`
[10:25:46.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.105]                   3L)]
[10:25:46.105]             }
[10:25:46.105]             function(cond) {
[10:25:46.105]                 is_error <- inherits(cond, "error")
[10:25:46.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.105]                   NULL)
[10:25:46.105]                 if (is_error) {
[10:25:46.105]                   sessionInformation <- function() {
[10:25:46.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.105]                       search = base::search(), system = base::Sys.info())
[10:25:46.105]                   }
[10:25:46.105]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.105]                     cond$call), session = sessionInformation(), 
[10:25:46.105]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.105]                   signalCondition(cond)
[10:25:46.105]                 }
[10:25:46.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.105]                 "immediateCondition"))) {
[10:25:46.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.105]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.105]                   if (TRUE && !signal) {
[10:25:46.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.105]                     {
[10:25:46.105]                       inherits <- base::inherits
[10:25:46.105]                       invokeRestart <- base::invokeRestart
[10:25:46.105]                       is.null <- base::is.null
[10:25:46.105]                       muffled <- FALSE
[10:25:46.105]                       if (inherits(cond, "message")) {
[10:25:46.105]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.105]                         if (muffled) 
[10:25:46.105]                           invokeRestart("muffleMessage")
[10:25:46.105]                       }
[10:25:46.105]                       else if (inherits(cond, "warning")) {
[10:25:46.105]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.105]                         if (muffled) 
[10:25:46.105]                           invokeRestart("muffleWarning")
[10:25:46.105]                       }
[10:25:46.105]                       else if (inherits(cond, "condition")) {
[10:25:46.105]                         if (!is.null(pattern)) {
[10:25:46.105]                           computeRestarts <- base::computeRestarts
[10:25:46.105]                           grepl <- base::grepl
[10:25:46.105]                           restarts <- computeRestarts(cond)
[10:25:46.105]                           for (restart in restarts) {
[10:25:46.105]                             name <- restart$name
[10:25:46.105]                             if (is.null(name)) 
[10:25:46.105]                               next
[10:25:46.105]                             if (!grepl(pattern, name)) 
[10:25:46.105]                               next
[10:25:46.105]                             invokeRestart(restart)
[10:25:46.105]                             muffled <- TRUE
[10:25:46.105]                             break
[10:25:46.105]                           }
[10:25:46.105]                         }
[10:25:46.105]                       }
[10:25:46.105]                       invisible(muffled)
[10:25:46.105]                     }
[10:25:46.105]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.105]                   }
[10:25:46.105]                 }
[10:25:46.105]                 else {
[10:25:46.105]                   if (TRUE) {
[10:25:46.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.105]                     {
[10:25:46.105]                       inherits <- base::inherits
[10:25:46.105]                       invokeRestart <- base::invokeRestart
[10:25:46.105]                       is.null <- base::is.null
[10:25:46.105]                       muffled <- FALSE
[10:25:46.105]                       if (inherits(cond, "message")) {
[10:25:46.105]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.105]                         if (muffled) 
[10:25:46.105]                           invokeRestart("muffleMessage")
[10:25:46.105]                       }
[10:25:46.105]                       else if (inherits(cond, "warning")) {
[10:25:46.105]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.105]                         if (muffled) 
[10:25:46.105]                           invokeRestart("muffleWarning")
[10:25:46.105]                       }
[10:25:46.105]                       else if (inherits(cond, "condition")) {
[10:25:46.105]                         if (!is.null(pattern)) {
[10:25:46.105]                           computeRestarts <- base::computeRestarts
[10:25:46.105]                           grepl <- base::grepl
[10:25:46.105]                           restarts <- computeRestarts(cond)
[10:25:46.105]                           for (restart in restarts) {
[10:25:46.105]                             name <- restart$name
[10:25:46.105]                             if (is.null(name)) 
[10:25:46.105]                               next
[10:25:46.105]                             if (!grepl(pattern, name)) 
[10:25:46.105]                               next
[10:25:46.105]                             invokeRestart(restart)
[10:25:46.105]                             muffled <- TRUE
[10:25:46.105]                             break
[10:25:46.105]                           }
[10:25:46.105]                         }
[10:25:46.105]                       }
[10:25:46.105]                       invisible(muffled)
[10:25:46.105]                     }
[10:25:46.105]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.105]                   }
[10:25:46.105]                 }
[10:25:46.105]             }
[10:25:46.105]         }))
[10:25:46.105]     }, error = function(ex) {
[10:25:46.105]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.105]                 ...future.rng), started = ...future.startTime, 
[10:25:46.105]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.105]             version = "1.8"), class = "FutureResult")
[10:25:46.105]     }, finally = {
[10:25:46.105]         if (!identical(...future.workdir, getwd())) 
[10:25:46.105]             setwd(...future.workdir)
[10:25:46.105]         {
[10:25:46.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.105]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.105]             }
[10:25:46.105]             base::options(...future.oldOptions)
[10:25:46.105]             if (.Platform$OS.type == "windows") {
[10:25:46.105]                 old_names <- names(...future.oldEnvVars)
[10:25:46.105]                 envs <- base::Sys.getenv()
[10:25:46.105]                 names <- names(envs)
[10:25:46.105]                 common <- intersect(names, old_names)
[10:25:46.105]                 added <- setdiff(names, old_names)
[10:25:46.105]                 removed <- setdiff(old_names, names)
[10:25:46.105]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.105]                   envs[common]]
[10:25:46.105]                 NAMES <- toupper(changed)
[10:25:46.105]                 args <- list()
[10:25:46.105]                 for (kk in seq_along(NAMES)) {
[10:25:46.105]                   name <- changed[[kk]]
[10:25:46.105]                   NAME <- NAMES[[kk]]
[10:25:46.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.105]                     next
[10:25:46.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.105]                 }
[10:25:46.105]                 NAMES <- toupper(added)
[10:25:46.105]                 for (kk in seq_along(NAMES)) {
[10:25:46.105]                   name <- added[[kk]]
[10:25:46.105]                   NAME <- NAMES[[kk]]
[10:25:46.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.105]                     next
[10:25:46.105]                   args[[name]] <- ""
[10:25:46.105]                 }
[10:25:46.105]                 NAMES <- toupper(removed)
[10:25:46.105]                 for (kk in seq_along(NAMES)) {
[10:25:46.105]                   name <- removed[[kk]]
[10:25:46.105]                   NAME <- NAMES[[kk]]
[10:25:46.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.105]                     next
[10:25:46.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.105]                 }
[10:25:46.105]                 if (length(args) > 0) 
[10:25:46.105]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.105]             }
[10:25:46.105]             else {
[10:25:46.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.105]             }
[10:25:46.105]             {
[10:25:46.105]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.105]                   0L) {
[10:25:46.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.105]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.105]                   base::options(opts)
[10:25:46.105]                 }
[10:25:46.105]                 {
[10:25:46.105]                   {
[10:25:46.105]                     NULL
[10:25:46.105]                     RNGkind("Mersenne-Twister")
[10:25:46.105]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.105]                       inherits = FALSE)
[10:25:46.105]                   }
[10:25:46.105]                   options(future.plan = NULL)
[10:25:46.105]                   if (is.na(NA_character_)) 
[10:25:46.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.105]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.105]                   {
[10:25:46.105]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.105]                     if (!future$lazy) 
[10:25:46.105]                       future <- run(future)
[10:25:46.105]                     invisible(future)
[10:25:46.105]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.105]                 }
[10:25:46.105]             }
[10:25:46.105]         }
[10:25:46.105]     })
[10:25:46.105]     if (TRUE) {
[10:25:46.105]         base::sink(type = "output", split = FALSE)
[10:25:46.105]         if (TRUE) {
[10:25:46.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.105]         }
[10:25:46.105]         else {
[10:25:46.105]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.105]         }
[10:25:46.105]         base::close(...future.stdout)
[10:25:46.105]         ...future.stdout <- NULL
[10:25:46.105]     }
[10:25:46.105]     ...future.result$conditions <- ...future.conditions
[10:25:46.105]     ...future.result$finished <- base::Sys.time()
[10:25:46.105]     ...future.result
[10:25:46.105] }
[10:25:46.107] plan(): Setting new future strategy stack:
[10:25:46.107] List of future strategies:
[10:25:46.107] 1. sequential:
[10:25:46.107]    - args: function (..., envir = parent.frame())
[10:25:46.107]    - tweaked: FALSE
[10:25:46.107]    - call: NULL
[10:25:46.107] plan(): nbrOfWorkers() = 1
[10:25:46.108] plan(): Setting new future strategy stack:
[10:25:46.108] List of future strategies:
[10:25:46.108] 1. sequential:
[10:25:46.108]    - args: function (..., envir = parent.frame())
[10:25:46.108]    - tweaked: FALSE
[10:25:46.108]    - call: plan(strategy)
[10:25:46.108] plan(): nbrOfWorkers() = 1
[10:25:46.108] SequentialFuture started (and completed)
[10:25:46.108] - Launch lazy future ... done
[10:25:46.108] run() for ‘SequentialFuture’ ... done
[10:25:46.110] getGlobalsAndPackages() ...
[10:25:46.110] Searching for globals...
[10:25:46.111] - globals found: [1] ‘{’
[10:25:46.111] Searching for globals ... DONE
[10:25:46.111] Resolving globals: FALSE
[10:25:46.112] 
[10:25:46.112] 
[10:25:46.112] getGlobalsAndPackages() ... DONE
[10:25:46.112] run() for ‘Future’ ...
[10:25:46.112] - state: ‘created’
[10:25:46.112] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.113] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.113]   - Field: ‘label’
[10:25:46.113]   - Field: ‘local’
[10:25:46.113]   - Field: ‘owner’
[10:25:46.113]   - Field: ‘envir’
[10:25:46.113]   - Field: ‘packages’
[10:25:46.113]   - Field: ‘gc’
[10:25:46.113]   - Field: ‘conditions’
[10:25:46.114]   - Field: ‘expr’
[10:25:46.114]   - Field: ‘uuid’
[10:25:46.114]   - Field: ‘seed’
[10:25:46.114]   - Field: ‘version’
[10:25:46.114]   - Field: ‘result’
[10:25:46.114]   - Field: ‘asynchronous’
[10:25:46.114]   - Field: ‘calls’
[10:25:46.114]   - Field: ‘globals’
[10:25:46.114]   - Field: ‘stdout’
[10:25:46.114]   - Field: ‘earlySignal’
[10:25:46.114]   - Field: ‘lazy’
[10:25:46.115]   - Field: ‘state’
[10:25:46.115] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.115] - Launch lazy future ...
[10:25:46.115] Packages needed by the future expression (n = 0): <none>
[10:25:46.115] Packages needed by future strategies (n = 0): <none>
[10:25:46.117] {
[10:25:46.117]     {
[10:25:46.117]         {
[10:25:46.117]             ...future.startTime <- base::Sys.time()
[10:25:46.117]             {
[10:25:46.117]                 {
[10:25:46.117]                   {
[10:25:46.117]                     base::local({
[10:25:46.117]                       has_future <- base::requireNamespace("future", 
[10:25:46.117]                         quietly = TRUE)
[10:25:46.117]                       if (has_future) {
[10:25:46.117]                         ns <- base::getNamespace("future")
[10:25:46.117]                         version <- ns[[".package"]][["version"]]
[10:25:46.117]                         if (is.null(version)) 
[10:25:46.117]                           version <- utils::packageVersion("future")
[10:25:46.117]                       }
[10:25:46.117]                       else {
[10:25:46.117]                         version <- NULL
[10:25:46.117]                       }
[10:25:46.117]                       if (!has_future || version < "1.8.0") {
[10:25:46.117]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.117]                           "", base::R.version$version.string), 
[10:25:46.117]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.117]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.117]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.117]                             "release", "version")], collapse = " "), 
[10:25:46.117]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.117]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.117]                           info)
[10:25:46.117]                         info <- base::paste(info, collapse = "; ")
[10:25:46.117]                         if (!has_future) {
[10:25:46.117]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.117]                             info)
[10:25:46.117]                         }
[10:25:46.117]                         else {
[10:25:46.117]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.117]                             info, version)
[10:25:46.117]                         }
[10:25:46.117]                         base::stop(msg)
[10:25:46.117]                       }
[10:25:46.117]                     })
[10:25:46.117]                   }
[10:25:46.117]                   options(future.plan = NULL)
[10:25:46.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.117]                 }
[10:25:46.117]                 ...future.workdir <- getwd()
[10:25:46.117]             }
[10:25:46.117]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.117]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.117]         }
[10:25:46.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.117]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.117]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.117]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.117]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.117]             base::names(...future.oldOptions))
[10:25:46.117]     }
[10:25:46.117]     if (FALSE) {
[10:25:46.117]     }
[10:25:46.117]     else {
[10:25:46.117]         if (TRUE) {
[10:25:46.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.117]                 open = "w")
[10:25:46.117]         }
[10:25:46.117]         else {
[10:25:46.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.117]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.117]         }
[10:25:46.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.117]             base::sink(type = "output", split = FALSE)
[10:25:46.117]             base::close(...future.stdout)
[10:25:46.117]         }, add = TRUE)
[10:25:46.117]     }
[10:25:46.117]     ...future.frame <- base::sys.nframe()
[10:25:46.117]     ...future.conditions <- base::list()
[10:25:46.117]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.117]     if (FALSE) {
[10:25:46.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.117]     }
[10:25:46.117]     ...future.result <- base::tryCatch({
[10:25:46.117]         base::withCallingHandlers({
[10:25:46.117]             ...future.value <- base::withVisible(base::local({
[10:25:46.117]                 4
[10:25:46.117]             }))
[10:25:46.117]             future::FutureResult(value = ...future.value$value, 
[10:25:46.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.117]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.117]                     ...future.globalenv.names))
[10:25:46.117]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.117]         }, condition = base::local({
[10:25:46.117]             c <- base::c
[10:25:46.117]             inherits <- base::inherits
[10:25:46.117]             invokeRestart <- base::invokeRestart
[10:25:46.117]             length <- base::length
[10:25:46.117]             list <- base::list
[10:25:46.117]             seq.int <- base::seq.int
[10:25:46.117]             signalCondition <- base::signalCondition
[10:25:46.117]             sys.calls <- base::sys.calls
[10:25:46.117]             `[[` <- base::`[[`
[10:25:46.117]             `+` <- base::`+`
[10:25:46.117]             `<<-` <- base::`<<-`
[10:25:46.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.117]                   3L)]
[10:25:46.117]             }
[10:25:46.117]             function(cond) {
[10:25:46.117]                 is_error <- inherits(cond, "error")
[10:25:46.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.117]                   NULL)
[10:25:46.117]                 if (is_error) {
[10:25:46.117]                   sessionInformation <- function() {
[10:25:46.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.117]                       search = base::search(), system = base::Sys.info())
[10:25:46.117]                   }
[10:25:46.117]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.117]                     cond$call), session = sessionInformation(), 
[10:25:46.117]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.117]                   signalCondition(cond)
[10:25:46.117]                 }
[10:25:46.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.117]                 "immediateCondition"))) {
[10:25:46.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.117]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.117]                   if (TRUE && !signal) {
[10:25:46.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.117]                     {
[10:25:46.117]                       inherits <- base::inherits
[10:25:46.117]                       invokeRestart <- base::invokeRestart
[10:25:46.117]                       is.null <- base::is.null
[10:25:46.117]                       muffled <- FALSE
[10:25:46.117]                       if (inherits(cond, "message")) {
[10:25:46.117]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.117]                         if (muffled) 
[10:25:46.117]                           invokeRestart("muffleMessage")
[10:25:46.117]                       }
[10:25:46.117]                       else if (inherits(cond, "warning")) {
[10:25:46.117]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.117]                         if (muffled) 
[10:25:46.117]                           invokeRestart("muffleWarning")
[10:25:46.117]                       }
[10:25:46.117]                       else if (inherits(cond, "condition")) {
[10:25:46.117]                         if (!is.null(pattern)) {
[10:25:46.117]                           computeRestarts <- base::computeRestarts
[10:25:46.117]                           grepl <- base::grepl
[10:25:46.117]                           restarts <- computeRestarts(cond)
[10:25:46.117]                           for (restart in restarts) {
[10:25:46.117]                             name <- restart$name
[10:25:46.117]                             if (is.null(name)) 
[10:25:46.117]                               next
[10:25:46.117]                             if (!grepl(pattern, name)) 
[10:25:46.117]                               next
[10:25:46.117]                             invokeRestart(restart)
[10:25:46.117]                             muffled <- TRUE
[10:25:46.117]                             break
[10:25:46.117]                           }
[10:25:46.117]                         }
[10:25:46.117]                       }
[10:25:46.117]                       invisible(muffled)
[10:25:46.117]                     }
[10:25:46.117]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.117]                   }
[10:25:46.117]                 }
[10:25:46.117]                 else {
[10:25:46.117]                   if (TRUE) {
[10:25:46.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.117]                     {
[10:25:46.117]                       inherits <- base::inherits
[10:25:46.117]                       invokeRestart <- base::invokeRestart
[10:25:46.117]                       is.null <- base::is.null
[10:25:46.117]                       muffled <- FALSE
[10:25:46.117]                       if (inherits(cond, "message")) {
[10:25:46.117]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.117]                         if (muffled) 
[10:25:46.117]                           invokeRestart("muffleMessage")
[10:25:46.117]                       }
[10:25:46.117]                       else if (inherits(cond, "warning")) {
[10:25:46.117]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.117]                         if (muffled) 
[10:25:46.117]                           invokeRestart("muffleWarning")
[10:25:46.117]                       }
[10:25:46.117]                       else if (inherits(cond, "condition")) {
[10:25:46.117]                         if (!is.null(pattern)) {
[10:25:46.117]                           computeRestarts <- base::computeRestarts
[10:25:46.117]                           grepl <- base::grepl
[10:25:46.117]                           restarts <- computeRestarts(cond)
[10:25:46.117]                           for (restart in restarts) {
[10:25:46.117]                             name <- restart$name
[10:25:46.117]                             if (is.null(name)) 
[10:25:46.117]                               next
[10:25:46.117]                             if (!grepl(pattern, name)) 
[10:25:46.117]                               next
[10:25:46.117]                             invokeRestart(restart)
[10:25:46.117]                             muffled <- TRUE
[10:25:46.117]                             break
[10:25:46.117]                           }
[10:25:46.117]                         }
[10:25:46.117]                       }
[10:25:46.117]                       invisible(muffled)
[10:25:46.117]                     }
[10:25:46.117]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.117]                   }
[10:25:46.117]                 }
[10:25:46.117]             }
[10:25:46.117]         }))
[10:25:46.117]     }, error = function(ex) {
[10:25:46.117]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.117]                 ...future.rng), started = ...future.startTime, 
[10:25:46.117]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.117]             version = "1.8"), class = "FutureResult")
[10:25:46.117]     }, finally = {
[10:25:46.117]         if (!identical(...future.workdir, getwd())) 
[10:25:46.117]             setwd(...future.workdir)
[10:25:46.117]         {
[10:25:46.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.117]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.117]             }
[10:25:46.117]             base::options(...future.oldOptions)
[10:25:46.117]             if (.Platform$OS.type == "windows") {
[10:25:46.117]                 old_names <- names(...future.oldEnvVars)
[10:25:46.117]                 envs <- base::Sys.getenv()
[10:25:46.117]                 names <- names(envs)
[10:25:46.117]                 common <- intersect(names, old_names)
[10:25:46.117]                 added <- setdiff(names, old_names)
[10:25:46.117]                 removed <- setdiff(old_names, names)
[10:25:46.117]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.117]                   envs[common]]
[10:25:46.117]                 NAMES <- toupper(changed)
[10:25:46.117]                 args <- list()
[10:25:46.117]                 for (kk in seq_along(NAMES)) {
[10:25:46.117]                   name <- changed[[kk]]
[10:25:46.117]                   NAME <- NAMES[[kk]]
[10:25:46.117]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.117]                     next
[10:25:46.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.117]                 }
[10:25:46.117]                 NAMES <- toupper(added)
[10:25:46.117]                 for (kk in seq_along(NAMES)) {
[10:25:46.117]                   name <- added[[kk]]
[10:25:46.117]                   NAME <- NAMES[[kk]]
[10:25:46.117]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.117]                     next
[10:25:46.117]                   args[[name]] <- ""
[10:25:46.117]                 }
[10:25:46.117]                 NAMES <- toupper(removed)
[10:25:46.117]                 for (kk in seq_along(NAMES)) {
[10:25:46.117]                   name <- removed[[kk]]
[10:25:46.117]                   NAME <- NAMES[[kk]]
[10:25:46.117]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.117]                     next
[10:25:46.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.117]                 }
[10:25:46.117]                 if (length(args) > 0) 
[10:25:46.117]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.117]             }
[10:25:46.117]             else {
[10:25:46.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.117]             }
[10:25:46.117]             {
[10:25:46.117]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.117]                   0L) {
[10:25:46.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.117]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.117]                   base::options(opts)
[10:25:46.117]                 }
[10:25:46.117]                 {
[10:25:46.117]                   {
[10:25:46.117]                     NULL
[10:25:46.117]                     RNGkind("Mersenne-Twister")
[10:25:46.117]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.117]                       inherits = FALSE)
[10:25:46.117]                   }
[10:25:46.117]                   options(future.plan = NULL)
[10:25:46.117]                   if (is.na(NA_character_)) 
[10:25:46.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.117]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.117]                   {
[10:25:46.117]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.117]                     if (!future$lazy) 
[10:25:46.117]                       future <- run(future)
[10:25:46.117]                     invisible(future)
[10:25:46.117]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.117]                 }
[10:25:46.117]             }
[10:25:46.117]         }
[10:25:46.117]     })
[10:25:46.117]     if (TRUE) {
[10:25:46.117]         base::sink(type = "output", split = FALSE)
[10:25:46.117]         if (TRUE) {
[10:25:46.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.117]         }
[10:25:46.117]         else {
[10:25:46.117]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.117]         }
[10:25:46.117]         base::close(...future.stdout)
[10:25:46.117]         ...future.stdout <- NULL
[10:25:46.117]     }
[10:25:46.117]     ...future.result$conditions <- ...future.conditions
[10:25:46.117]     ...future.result$finished <- base::Sys.time()
[10:25:46.117]     ...future.result
[10:25:46.117] }
[10:25:46.119] plan(): Setting new future strategy stack:
[10:25:46.119] List of future strategies:
[10:25:46.119] 1. sequential:
[10:25:46.119]    - args: function (..., envir = parent.frame())
[10:25:46.119]    - tweaked: FALSE
[10:25:46.119]    - call: NULL
[10:25:46.120] plan(): nbrOfWorkers() = 1
[10:25:46.120] plan(): Setting new future strategy stack:
[10:25:46.120] List of future strategies:
[10:25:46.120] 1. sequential:
[10:25:46.120]    - args: function (..., envir = parent.frame())
[10:25:46.120]    - tweaked: FALSE
[10:25:46.120]    - call: plan(strategy)
[10:25:46.121] plan(): nbrOfWorkers() = 1
[10:25:46.121] SequentialFuture started (and completed)
[10:25:46.121] - Launch lazy future ... done
[10:25:46.121] run() for ‘SequentialFuture’ ... done
<environment: 0x55c0f3cee418> 
<environment: 0x55c0f38d82b8> 
[10:25:46.123] resolved() for ‘SequentialFuture’ ...
[10:25:46.123] - state: ‘finished’
[10:25:46.123] - run: TRUE
[10:25:46.123] - result: ‘FutureResult’
[10:25:46.123] resolved() for ‘SequentialFuture’ ... done
[10:25:46.123] resolved() for ‘SequentialFuture’ ...
[10:25:46.123] - state: ‘finished’
[10:25:46.123] - run: TRUE
[10:25:46.123] - result: ‘FutureResult’
[10:25:46.123] resolved() for ‘SequentialFuture’ ... done
[10:25:46.124] resolved() for ‘SequentialFuture’ ...
[10:25:46.124] - state: ‘finished’
[10:25:46.124] - run: TRUE
[10:25:46.124] - result: ‘FutureResult’
[10:25:46.124] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:46.125] resolve() on environment ...
[10:25:46.125]  recursive: 0
[10:25:46.126]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:46.126] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.126] - nx: 4
[10:25:46.126] - relay: TRUE
[10:25:46.126] - stdout: TRUE
[10:25:46.126] - signal: TRUE
[10:25:46.126] - resignal: FALSE
[10:25:46.127] - force: TRUE
[10:25:46.127] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.127] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.127]  - until=2
[10:25:46.127]  - relaying element #2
[10:25:46.127] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.127] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.127] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.127]  length: 3 (resolved future 1)
[10:25:46.127] resolved() for ‘SequentialFuture’ ...
[10:25:46.127] - state: ‘finished’
[10:25:46.128] - run: TRUE
[10:25:46.128] - result: ‘FutureResult’
[10:25:46.128] resolved() for ‘SequentialFuture’ ... done
[10:25:46.128] Future #2
[10:25:46.128] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.128] - nx: 4
[10:25:46.128] - relay: TRUE
[10:25:46.128] - stdout: TRUE
[10:25:46.128] - signal: TRUE
[10:25:46.128] - resignal: FALSE
[10:25:46.128] - force: TRUE
[10:25:46.128] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.129] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.129]  - until=2
[10:25:46.129]  - relaying element #2
[10:25:46.129] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.129] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.129] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.129]  length: 2 (resolved future 2)
[10:25:46.129] resolved() for ‘SequentialFuture’ ...
[10:25:46.129] - state: ‘finished’
[10:25:46.130] - run: TRUE
[10:25:46.130] - result: ‘FutureResult’
[10:25:46.130] resolved() for ‘SequentialFuture’ ... done
[10:25:46.130] Future #3
[10:25:46.130] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.130] - nx: 4
[10:25:46.130] - relay: TRUE
[10:25:46.130] - stdout: TRUE
[10:25:46.130] - signal: TRUE
[10:25:46.130] - resignal: FALSE
[10:25:46.130] - force: TRUE
[10:25:46.131] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.131] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.131]  - until=3
[10:25:46.131]  - relaying element #3
[10:25:46.131] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.131] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.131] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.131]  length: 1 (resolved future 3)
[10:25:46.131] resolved() for ‘SequentialFuture’ ...
[10:25:46.131] - state: ‘finished’
[10:25:46.132] - run: TRUE
[10:25:46.132] - result: ‘FutureResult’
[10:25:46.132] resolved() for ‘SequentialFuture’ ... done
[10:25:46.132] Future #4
[10:25:46.132] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.132] - nx: 4
[10:25:46.132] - relay: TRUE
[10:25:46.132] - stdout: TRUE
[10:25:46.132] - signal: TRUE
[10:25:46.132] - resignal: FALSE
[10:25:46.132] - force: TRUE
[10:25:46.133] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.133] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.133]  - until=4
[10:25:46.133]  - relaying element #4
[10:25:46.133] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.133] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.133] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.133]  length: 0 (resolved future 4)
[10:25:46.133] Relaying remaining futures
[10:25:46.133] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.134] - nx: 4
[10:25:46.134] - relay: TRUE
[10:25:46.134] - stdout: TRUE
[10:25:46.134] - signal: TRUE
[10:25:46.134] - resignal: FALSE
[10:25:46.134] - force: TRUE
[10:25:46.134] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.134] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:46.134] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.134] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.134] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.135] resolve() on environment ... DONE
<environment: 0x55c0f3151158> 
Dimensions: c(1, 6)
[10:25:46.135] getGlobalsAndPackages() ...
[10:25:46.135] Searching for globals...
[10:25:46.135] 
[10:25:46.136] Searching for globals ... DONE
[10:25:46.136] - globals: [0] <none>
[10:25:46.136] getGlobalsAndPackages() ... DONE
[10:25:46.136] run() for ‘Future’ ...
[10:25:46.136] - state: ‘created’
[10:25:46.136] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.136] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.137]   - Field: ‘label’
[10:25:46.137]   - Field: ‘local’
[10:25:46.137]   - Field: ‘owner’
[10:25:46.137]   - Field: ‘envir’
[10:25:46.137]   - Field: ‘packages’
[10:25:46.137]   - Field: ‘gc’
[10:25:46.137]   - Field: ‘conditions’
[10:25:46.137]   - Field: ‘expr’
[10:25:46.137]   - Field: ‘uuid’
[10:25:46.137]   - Field: ‘seed’
[10:25:46.138]   - Field: ‘version’
[10:25:46.138]   - Field: ‘result’
[10:25:46.138]   - Field: ‘asynchronous’
[10:25:46.138]   - Field: ‘calls’
[10:25:46.138]   - Field: ‘globals’
[10:25:46.138]   - Field: ‘stdout’
[10:25:46.138]   - Field: ‘earlySignal’
[10:25:46.138]   - Field: ‘lazy’
[10:25:46.138]   - Field: ‘state’
[10:25:46.138] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.138] - Launch lazy future ...
[10:25:46.139] Packages needed by the future expression (n = 0): <none>
[10:25:46.139] Packages needed by future strategies (n = 0): <none>
[10:25:46.139] {
[10:25:46.139]     {
[10:25:46.139]         {
[10:25:46.139]             ...future.startTime <- base::Sys.time()
[10:25:46.139]             {
[10:25:46.139]                 {
[10:25:46.139]                   {
[10:25:46.139]                     base::local({
[10:25:46.139]                       has_future <- base::requireNamespace("future", 
[10:25:46.139]                         quietly = TRUE)
[10:25:46.139]                       if (has_future) {
[10:25:46.139]                         ns <- base::getNamespace("future")
[10:25:46.139]                         version <- ns[[".package"]][["version"]]
[10:25:46.139]                         if (is.null(version)) 
[10:25:46.139]                           version <- utils::packageVersion("future")
[10:25:46.139]                       }
[10:25:46.139]                       else {
[10:25:46.139]                         version <- NULL
[10:25:46.139]                       }
[10:25:46.139]                       if (!has_future || version < "1.8.0") {
[10:25:46.139]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.139]                           "", base::R.version$version.string), 
[10:25:46.139]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.139]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.139]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.139]                             "release", "version")], collapse = " "), 
[10:25:46.139]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.139]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.139]                           info)
[10:25:46.139]                         info <- base::paste(info, collapse = "; ")
[10:25:46.139]                         if (!has_future) {
[10:25:46.139]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.139]                             info)
[10:25:46.139]                         }
[10:25:46.139]                         else {
[10:25:46.139]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.139]                             info, version)
[10:25:46.139]                         }
[10:25:46.139]                         base::stop(msg)
[10:25:46.139]                       }
[10:25:46.139]                     })
[10:25:46.139]                   }
[10:25:46.139]                   options(future.plan = NULL)
[10:25:46.139]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.139]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.139]                 }
[10:25:46.139]                 ...future.workdir <- getwd()
[10:25:46.139]             }
[10:25:46.139]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.139]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.139]         }
[10:25:46.139]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.139]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.139]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.139]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.139]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.139]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.139]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.139]             base::names(...future.oldOptions))
[10:25:46.139]     }
[10:25:46.139]     if (FALSE) {
[10:25:46.139]     }
[10:25:46.139]     else {
[10:25:46.139]         if (TRUE) {
[10:25:46.139]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.139]                 open = "w")
[10:25:46.139]         }
[10:25:46.139]         else {
[10:25:46.139]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.139]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.139]         }
[10:25:46.139]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.139]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.139]             base::sink(type = "output", split = FALSE)
[10:25:46.139]             base::close(...future.stdout)
[10:25:46.139]         }, add = TRUE)
[10:25:46.139]     }
[10:25:46.139]     ...future.frame <- base::sys.nframe()
[10:25:46.139]     ...future.conditions <- base::list()
[10:25:46.139]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.139]     if (FALSE) {
[10:25:46.139]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.139]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.139]     }
[10:25:46.139]     ...future.result <- base::tryCatch({
[10:25:46.139]         base::withCallingHandlers({
[10:25:46.139]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.139]             future::FutureResult(value = ...future.value$value, 
[10:25:46.139]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.139]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.139]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.139]                     ...future.globalenv.names))
[10:25:46.139]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.139]         }, condition = base::local({
[10:25:46.139]             c <- base::c
[10:25:46.139]             inherits <- base::inherits
[10:25:46.139]             invokeRestart <- base::invokeRestart
[10:25:46.139]             length <- base::length
[10:25:46.139]             list <- base::list
[10:25:46.139]             seq.int <- base::seq.int
[10:25:46.139]             signalCondition <- base::signalCondition
[10:25:46.139]             sys.calls <- base::sys.calls
[10:25:46.139]             `[[` <- base::`[[`
[10:25:46.139]             `+` <- base::`+`
[10:25:46.139]             `<<-` <- base::`<<-`
[10:25:46.139]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.139]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.139]                   3L)]
[10:25:46.139]             }
[10:25:46.139]             function(cond) {
[10:25:46.139]                 is_error <- inherits(cond, "error")
[10:25:46.139]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.139]                   NULL)
[10:25:46.139]                 if (is_error) {
[10:25:46.139]                   sessionInformation <- function() {
[10:25:46.139]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.139]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.139]                       search = base::search(), system = base::Sys.info())
[10:25:46.139]                   }
[10:25:46.139]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.139]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.139]                     cond$call), session = sessionInformation(), 
[10:25:46.139]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.139]                   signalCondition(cond)
[10:25:46.139]                 }
[10:25:46.139]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.139]                 "immediateCondition"))) {
[10:25:46.139]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.139]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.139]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.139]                   if (TRUE && !signal) {
[10:25:46.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.139]                     {
[10:25:46.139]                       inherits <- base::inherits
[10:25:46.139]                       invokeRestart <- base::invokeRestart
[10:25:46.139]                       is.null <- base::is.null
[10:25:46.139]                       muffled <- FALSE
[10:25:46.139]                       if (inherits(cond, "message")) {
[10:25:46.139]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.139]                         if (muffled) 
[10:25:46.139]                           invokeRestart("muffleMessage")
[10:25:46.139]                       }
[10:25:46.139]                       else if (inherits(cond, "warning")) {
[10:25:46.139]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.139]                         if (muffled) 
[10:25:46.139]                           invokeRestart("muffleWarning")
[10:25:46.139]                       }
[10:25:46.139]                       else if (inherits(cond, "condition")) {
[10:25:46.139]                         if (!is.null(pattern)) {
[10:25:46.139]                           computeRestarts <- base::computeRestarts
[10:25:46.139]                           grepl <- base::grepl
[10:25:46.139]                           restarts <- computeRestarts(cond)
[10:25:46.139]                           for (restart in restarts) {
[10:25:46.139]                             name <- restart$name
[10:25:46.139]                             if (is.null(name)) 
[10:25:46.139]                               next
[10:25:46.139]                             if (!grepl(pattern, name)) 
[10:25:46.139]                               next
[10:25:46.139]                             invokeRestart(restart)
[10:25:46.139]                             muffled <- TRUE
[10:25:46.139]                             break
[10:25:46.139]                           }
[10:25:46.139]                         }
[10:25:46.139]                       }
[10:25:46.139]                       invisible(muffled)
[10:25:46.139]                     }
[10:25:46.139]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.139]                   }
[10:25:46.139]                 }
[10:25:46.139]                 else {
[10:25:46.139]                   if (TRUE) {
[10:25:46.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.139]                     {
[10:25:46.139]                       inherits <- base::inherits
[10:25:46.139]                       invokeRestart <- base::invokeRestart
[10:25:46.139]                       is.null <- base::is.null
[10:25:46.139]                       muffled <- FALSE
[10:25:46.139]                       if (inherits(cond, "message")) {
[10:25:46.139]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.139]                         if (muffled) 
[10:25:46.139]                           invokeRestart("muffleMessage")
[10:25:46.139]                       }
[10:25:46.139]                       else if (inherits(cond, "warning")) {
[10:25:46.139]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.139]                         if (muffled) 
[10:25:46.139]                           invokeRestart("muffleWarning")
[10:25:46.139]                       }
[10:25:46.139]                       else if (inherits(cond, "condition")) {
[10:25:46.139]                         if (!is.null(pattern)) {
[10:25:46.139]                           computeRestarts <- base::computeRestarts
[10:25:46.139]                           grepl <- base::grepl
[10:25:46.139]                           restarts <- computeRestarts(cond)
[10:25:46.139]                           for (restart in restarts) {
[10:25:46.139]                             name <- restart$name
[10:25:46.139]                             if (is.null(name)) 
[10:25:46.139]                               next
[10:25:46.139]                             if (!grepl(pattern, name)) 
[10:25:46.139]                               next
[10:25:46.139]                             invokeRestart(restart)
[10:25:46.139]                             muffled <- TRUE
[10:25:46.139]                             break
[10:25:46.139]                           }
[10:25:46.139]                         }
[10:25:46.139]                       }
[10:25:46.139]                       invisible(muffled)
[10:25:46.139]                     }
[10:25:46.139]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.139]                   }
[10:25:46.139]                 }
[10:25:46.139]             }
[10:25:46.139]         }))
[10:25:46.139]     }, error = function(ex) {
[10:25:46.139]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.139]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.139]                 ...future.rng), started = ...future.startTime, 
[10:25:46.139]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.139]             version = "1.8"), class = "FutureResult")
[10:25:46.139]     }, finally = {
[10:25:46.139]         if (!identical(...future.workdir, getwd())) 
[10:25:46.139]             setwd(...future.workdir)
[10:25:46.139]         {
[10:25:46.139]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.139]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.139]             }
[10:25:46.139]             base::options(...future.oldOptions)
[10:25:46.139]             if (.Platform$OS.type == "windows") {
[10:25:46.139]                 old_names <- names(...future.oldEnvVars)
[10:25:46.139]                 envs <- base::Sys.getenv()
[10:25:46.139]                 names <- names(envs)
[10:25:46.139]                 common <- intersect(names, old_names)
[10:25:46.139]                 added <- setdiff(names, old_names)
[10:25:46.139]                 removed <- setdiff(old_names, names)
[10:25:46.139]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.139]                   envs[common]]
[10:25:46.139]                 NAMES <- toupper(changed)
[10:25:46.139]                 args <- list()
[10:25:46.139]                 for (kk in seq_along(NAMES)) {
[10:25:46.139]                   name <- changed[[kk]]
[10:25:46.139]                   NAME <- NAMES[[kk]]
[10:25:46.139]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.139]                     next
[10:25:46.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.139]                 }
[10:25:46.139]                 NAMES <- toupper(added)
[10:25:46.139]                 for (kk in seq_along(NAMES)) {
[10:25:46.139]                   name <- added[[kk]]
[10:25:46.139]                   NAME <- NAMES[[kk]]
[10:25:46.139]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.139]                     next
[10:25:46.139]                   args[[name]] <- ""
[10:25:46.139]                 }
[10:25:46.139]                 NAMES <- toupper(removed)
[10:25:46.139]                 for (kk in seq_along(NAMES)) {
[10:25:46.139]                   name <- removed[[kk]]
[10:25:46.139]                   NAME <- NAMES[[kk]]
[10:25:46.139]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.139]                     next
[10:25:46.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.139]                 }
[10:25:46.139]                 if (length(args) > 0) 
[10:25:46.139]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.139]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.139]             }
[10:25:46.139]             else {
[10:25:46.139]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.139]             }
[10:25:46.139]             {
[10:25:46.139]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.139]                   0L) {
[10:25:46.139]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.139]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.139]                   base::options(opts)
[10:25:46.139]                 }
[10:25:46.139]                 {
[10:25:46.139]                   {
[10:25:46.139]                     NULL
[10:25:46.139]                     RNGkind("Mersenne-Twister")
[10:25:46.139]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.139]                       inherits = FALSE)
[10:25:46.139]                   }
[10:25:46.139]                   options(future.plan = NULL)
[10:25:46.139]                   if (is.na(NA_character_)) 
[10:25:46.139]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.139]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.139]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.139]                   {
[10:25:46.139]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.139]                     if (!future$lazy) 
[10:25:46.139]                       future <- run(future)
[10:25:46.139]                     invisible(future)
[10:25:46.139]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.139]                 }
[10:25:46.139]             }
[10:25:46.139]         }
[10:25:46.139]     })
[10:25:46.139]     if (TRUE) {
[10:25:46.139]         base::sink(type = "output", split = FALSE)
[10:25:46.139]         if (TRUE) {
[10:25:46.139]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.139]         }
[10:25:46.139]         else {
[10:25:46.139]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.139]         }
[10:25:46.139]         base::close(...future.stdout)
[10:25:46.139]         ...future.stdout <- NULL
[10:25:46.139]     }
[10:25:46.139]     ...future.result$conditions <- ...future.conditions
[10:25:46.139]     ...future.result$finished <- base::Sys.time()
[10:25:46.139]     ...future.result
[10:25:46.139] }
[10:25:46.141] plan(): Setting new future strategy stack:
[10:25:46.141] List of future strategies:
[10:25:46.141] 1. sequential:
[10:25:46.141]    - args: function (..., envir = parent.frame())
[10:25:46.141]    - tweaked: FALSE
[10:25:46.141]    - call: NULL
[10:25:46.141] plan(): nbrOfWorkers() = 1
[10:25:46.142] plan(): Setting new future strategy stack:
[10:25:46.142] List of future strategies:
[10:25:46.142] 1. sequential:
[10:25:46.142]    - args: function (..., envir = parent.frame())
[10:25:46.142]    - tweaked: FALSE
[10:25:46.142]    - call: plan(strategy)
[10:25:46.143] plan(): nbrOfWorkers() = 1
[10:25:46.143] SequentialFuture started (and completed)
[10:25:46.143] - Launch lazy future ... done
[10:25:46.143] run() for ‘SequentialFuture’ ... done
[10:25:46.143] getGlobalsAndPackages() ...
[10:25:46.143] Searching for globals...
[10:25:46.143] 
[10:25:46.143] Searching for globals ... DONE
[10:25:46.144] - globals: [0] <none>
[10:25:46.144] getGlobalsAndPackages() ... DONE
[10:25:46.144] run() for ‘Future’ ...
[10:25:46.146] - state: ‘created’
[10:25:46.146] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.146] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.146] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.146]   - Field: ‘label’
[10:25:46.146]   - Field: ‘local’
[10:25:46.147]   - Field: ‘owner’
[10:25:46.147]   - Field: ‘envir’
[10:25:46.147]   - Field: ‘packages’
[10:25:46.147]   - Field: ‘gc’
[10:25:46.147]   - Field: ‘conditions’
[10:25:46.147]   - Field: ‘expr’
[10:25:46.147]   - Field: ‘uuid’
[10:25:46.147]   - Field: ‘seed’
[10:25:46.147]   - Field: ‘version’
[10:25:46.147]   - Field: ‘result’
[10:25:46.148]   - Field: ‘asynchronous’
[10:25:46.148]   - Field: ‘calls’
[10:25:46.148]   - Field: ‘globals’
[10:25:46.148]   - Field: ‘stdout’
[10:25:46.148]   - Field: ‘earlySignal’
[10:25:46.148]   - Field: ‘lazy’
[10:25:46.148]   - Field: ‘state’
[10:25:46.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.148] - Launch lazy future ...
[10:25:46.148] Packages needed by the future expression (n = 0): <none>
[10:25:46.149] Packages needed by future strategies (n = 0): <none>
[10:25:46.149] {
[10:25:46.149]     {
[10:25:46.149]         {
[10:25:46.149]             ...future.startTime <- base::Sys.time()
[10:25:46.149]             {
[10:25:46.149]                 {
[10:25:46.149]                   {
[10:25:46.149]                     base::local({
[10:25:46.149]                       has_future <- base::requireNamespace("future", 
[10:25:46.149]                         quietly = TRUE)
[10:25:46.149]                       if (has_future) {
[10:25:46.149]                         ns <- base::getNamespace("future")
[10:25:46.149]                         version <- ns[[".package"]][["version"]]
[10:25:46.149]                         if (is.null(version)) 
[10:25:46.149]                           version <- utils::packageVersion("future")
[10:25:46.149]                       }
[10:25:46.149]                       else {
[10:25:46.149]                         version <- NULL
[10:25:46.149]                       }
[10:25:46.149]                       if (!has_future || version < "1.8.0") {
[10:25:46.149]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.149]                           "", base::R.version$version.string), 
[10:25:46.149]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.149]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.149]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.149]                             "release", "version")], collapse = " "), 
[10:25:46.149]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.149]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.149]                           info)
[10:25:46.149]                         info <- base::paste(info, collapse = "; ")
[10:25:46.149]                         if (!has_future) {
[10:25:46.149]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.149]                             info)
[10:25:46.149]                         }
[10:25:46.149]                         else {
[10:25:46.149]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.149]                             info, version)
[10:25:46.149]                         }
[10:25:46.149]                         base::stop(msg)
[10:25:46.149]                       }
[10:25:46.149]                     })
[10:25:46.149]                   }
[10:25:46.149]                   options(future.plan = NULL)
[10:25:46.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.149]                 }
[10:25:46.149]                 ...future.workdir <- getwd()
[10:25:46.149]             }
[10:25:46.149]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.149]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.149]         }
[10:25:46.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.149]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.149]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.149]             base::names(...future.oldOptions))
[10:25:46.149]     }
[10:25:46.149]     if (FALSE) {
[10:25:46.149]     }
[10:25:46.149]     else {
[10:25:46.149]         if (TRUE) {
[10:25:46.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.149]                 open = "w")
[10:25:46.149]         }
[10:25:46.149]         else {
[10:25:46.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.149]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.149]         }
[10:25:46.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.149]             base::sink(type = "output", split = FALSE)
[10:25:46.149]             base::close(...future.stdout)
[10:25:46.149]         }, add = TRUE)
[10:25:46.149]     }
[10:25:46.149]     ...future.frame <- base::sys.nframe()
[10:25:46.149]     ...future.conditions <- base::list()
[10:25:46.149]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.149]     if (FALSE) {
[10:25:46.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.149]     }
[10:25:46.149]     ...future.result <- base::tryCatch({
[10:25:46.149]         base::withCallingHandlers({
[10:25:46.149]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.149]             future::FutureResult(value = ...future.value$value, 
[10:25:46.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.149]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.149]                     ...future.globalenv.names))
[10:25:46.149]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.149]         }, condition = base::local({
[10:25:46.149]             c <- base::c
[10:25:46.149]             inherits <- base::inherits
[10:25:46.149]             invokeRestart <- base::invokeRestart
[10:25:46.149]             length <- base::length
[10:25:46.149]             list <- base::list
[10:25:46.149]             seq.int <- base::seq.int
[10:25:46.149]             signalCondition <- base::signalCondition
[10:25:46.149]             sys.calls <- base::sys.calls
[10:25:46.149]             `[[` <- base::`[[`
[10:25:46.149]             `+` <- base::`+`
[10:25:46.149]             `<<-` <- base::`<<-`
[10:25:46.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.149]                   3L)]
[10:25:46.149]             }
[10:25:46.149]             function(cond) {
[10:25:46.149]                 is_error <- inherits(cond, "error")
[10:25:46.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.149]                   NULL)
[10:25:46.149]                 if (is_error) {
[10:25:46.149]                   sessionInformation <- function() {
[10:25:46.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.149]                       search = base::search(), system = base::Sys.info())
[10:25:46.149]                   }
[10:25:46.149]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.149]                     cond$call), session = sessionInformation(), 
[10:25:46.149]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.149]                   signalCondition(cond)
[10:25:46.149]                 }
[10:25:46.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.149]                 "immediateCondition"))) {
[10:25:46.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.149]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.149]                   if (TRUE && !signal) {
[10:25:46.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.149]                     {
[10:25:46.149]                       inherits <- base::inherits
[10:25:46.149]                       invokeRestart <- base::invokeRestart
[10:25:46.149]                       is.null <- base::is.null
[10:25:46.149]                       muffled <- FALSE
[10:25:46.149]                       if (inherits(cond, "message")) {
[10:25:46.149]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.149]                         if (muffled) 
[10:25:46.149]                           invokeRestart("muffleMessage")
[10:25:46.149]                       }
[10:25:46.149]                       else if (inherits(cond, "warning")) {
[10:25:46.149]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.149]                         if (muffled) 
[10:25:46.149]                           invokeRestart("muffleWarning")
[10:25:46.149]                       }
[10:25:46.149]                       else if (inherits(cond, "condition")) {
[10:25:46.149]                         if (!is.null(pattern)) {
[10:25:46.149]                           computeRestarts <- base::computeRestarts
[10:25:46.149]                           grepl <- base::grepl
[10:25:46.149]                           restarts <- computeRestarts(cond)
[10:25:46.149]                           for (restart in restarts) {
[10:25:46.149]                             name <- restart$name
[10:25:46.149]                             if (is.null(name)) 
[10:25:46.149]                               next
[10:25:46.149]                             if (!grepl(pattern, name)) 
[10:25:46.149]                               next
[10:25:46.149]                             invokeRestart(restart)
[10:25:46.149]                             muffled <- TRUE
[10:25:46.149]                             break
[10:25:46.149]                           }
[10:25:46.149]                         }
[10:25:46.149]                       }
[10:25:46.149]                       invisible(muffled)
[10:25:46.149]                     }
[10:25:46.149]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.149]                   }
[10:25:46.149]                 }
[10:25:46.149]                 else {
[10:25:46.149]                   if (TRUE) {
[10:25:46.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.149]                     {
[10:25:46.149]                       inherits <- base::inherits
[10:25:46.149]                       invokeRestart <- base::invokeRestart
[10:25:46.149]                       is.null <- base::is.null
[10:25:46.149]                       muffled <- FALSE
[10:25:46.149]                       if (inherits(cond, "message")) {
[10:25:46.149]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.149]                         if (muffled) 
[10:25:46.149]                           invokeRestart("muffleMessage")
[10:25:46.149]                       }
[10:25:46.149]                       else if (inherits(cond, "warning")) {
[10:25:46.149]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.149]                         if (muffled) 
[10:25:46.149]                           invokeRestart("muffleWarning")
[10:25:46.149]                       }
[10:25:46.149]                       else if (inherits(cond, "condition")) {
[10:25:46.149]                         if (!is.null(pattern)) {
[10:25:46.149]                           computeRestarts <- base::computeRestarts
[10:25:46.149]                           grepl <- base::grepl
[10:25:46.149]                           restarts <- computeRestarts(cond)
[10:25:46.149]                           for (restart in restarts) {
[10:25:46.149]                             name <- restart$name
[10:25:46.149]                             if (is.null(name)) 
[10:25:46.149]                               next
[10:25:46.149]                             if (!grepl(pattern, name)) 
[10:25:46.149]                               next
[10:25:46.149]                             invokeRestart(restart)
[10:25:46.149]                             muffled <- TRUE
[10:25:46.149]                             break
[10:25:46.149]                           }
[10:25:46.149]                         }
[10:25:46.149]                       }
[10:25:46.149]                       invisible(muffled)
[10:25:46.149]                     }
[10:25:46.149]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.149]                   }
[10:25:46.149]                 }
[10:25:46.149]             }
[10:25:46.149]         }))
[10:25:46.149]     }, error = function(ex) {
[10:25:46.149]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.149]                 ...future.rng), started = ...future.startTime, 
[10:25:46.149]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.149]             version = "1.8"), class = "FutureResult")
[10:25:46.149]     }, finally = {
[10:25:46.149]         if (!identical(...future.workdir, getwd())) 
[10:25:46.149]             setwd(...future.workdir)
[10:25:46.149]         {
[10:25:46.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.149]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.149]             }
[10:25:46.149]             base::options(...future.oldOptions)
[10:25:46.149]             if (.Platform$OS.type == "windows") {
[10:25:46.149]                 old_names <- names(...future.oldEnvVars)
[10:25:46.149]                 envs <- base::Sys.getenv()
[10:25:46.149]                 names <- names(envs)
[10:25:46.149]                 common <- intersect(names, old_names)
[10:25:46.149]                 added <- setdiff(names, old_names)
[10:25:46.149]                 removed <- setdiff(old_names, names)
[10:25:46.149]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.149]                   envs[common]]
[10:25:46.149]                 NAMES <- toupper(changed)
[10:25:46.149]                 args <- list()
[10:25:46.149]                 for (kk in seq_along(NAMES)) {
[10:25:46.149]                   name <- changed[[kk]]
[10:25:46.149]                   NAME <- NAMES[[kk]]
[10:25:46.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.149]                     next
[10:25:46.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.149]                 }
[10:25:46.149]                 NAMES <- toupper(added)
[10:25:46.149]                 for (kk in seq_along(NAMES)) {
[10:25:46.149]                   name <- added[[kk]]
[10:25:46.149]                   NAME <- NAMES[[kk]]
[10:25:46.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.149]                     next
[10:25:46.149]                   args[[name]] <- ""
[10:25:46.149]                 }
[10:25:46.149]                 NAMES <- toupper(removed)
[10:25:46.149]                 for (kk in seq_along(NAMES)) {
[10:25:46.149]                   name <- removed[[kk]]
[10:25:46.149]                   NAME <- NAMES[[kk]]
[10:25:46.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.149]                     next
[10:25:46.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.149]                 }
[10:25:46.149]                 if (length(args) > 0) 
[10:25:46.149]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.149]             }
[10:25:46.149]             else {
[10:25:46.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.149]             }
[10:25:46.149]             {
[10:25:46.149]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.149]                   0L) {
[10:25:46.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.149]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.149]                   base::options(opts)
[10:25:46.149]                 }
[10:25:46.149]                 {
[10:25:46.149]                   {
[10:25:46.149]                     NULL
[10:25:46.149]                     RNGkind("Mersenne-Twister")
[10:25:46.149]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.149]                       inherits = FALSE)
[10:25:46.149]                   }
[10:25:46.149]                   options(future.plan = NULL)
[10:25:46.149]                   if (is.na(NA_character_)) 
[10:25:46.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.149]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.149]                   {
[10:25:46.149]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.149]                     if (!future$lazy) 
[10:25:46.149]                       future <- run(future)
[10:25:46.149]                     invisible(future)
[10:25:46.149]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.149]                 }
[10:25:46.149]             }
[10:25:46.149]         }
[10:25:46.149]     })
[10:25:46.149]     if (TRUE) {
[10:25:46.149]         base::sink(type = "output", split = FALSE)
[10:25:46.149]         if (TRUE) {
[10:25:46.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.149]         }
[10:25:46.149]         else {
[10:25:46.149]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.149]         }
[10:25:46.149]         base::close(...future.stdout)
[10:25:46.149]         ...future.stdout <- NULL
[10:25:46.149]     }
[10:25:46.149]     ...future.result$conditions <- ...future.conditions
[10:25:46.149]     ...future.result$finished <- base::Sys.time()
[10:25:46.149]     ...future.result
[10:25:46.149] }
[10:25:46.151] plan(): Setting new future strategy stack:
[10:25:46.151] List of future strategies:
[10:25:46.151] 1. sequential:
[10:25:46.151]    - args: function (..., envir = parent.frame())
[10:25:46.151]    - tweaked: FALSE
[10:25:46.151]    - call: NULL
[10:25:46.151] plan(): nbrOfWorkers() = 1
[10:25:46.152] plan(): Setting new future strategy stack:
[10:25:46.152] List of future strategies:
[10:25:46.152] 1. sequential:
[10:25:46.152]    - args: function (..., envir = parent.frame())
[10:25:46.152]    - tweaked: FALSE
[10:25:46.152]    - call: plan(strategy)
[10:25:46.152] plan(): nbrOfWorkers() = 1
[10:25:46.152] SequentialFuture started (and completed)
[10:25:46.153] - Launch lazy future ... done
[10:25:46.153] run() for ‘SequentialFuture’ ... done
[10:25:46.153] getGlobalsAndPackages() ...
[10:25:46.153] Searching for globals...
[10:25:46.154] - globals found: [1] ‘{’
[10:25:46.154] Searching for globals ... DONE
[10:25:46.154] Resolving globals: FALSE
[10:25:46.154] 
[10:25:46.154] 
[10:25:46.154] getGlobalsAndPackages() ... DONE
[10:25:46.154] run() for ‘Future’ ...
[10:25:46.155] - state: ‘created’
[10:25:46.155] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.155] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.155] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.155]   - Field: ‘label’
[10:25:46.155]   - Field: ‘local’
[10:25:46.156]   - Field: ‘owner’
[10:25:46.156]   - Field: ‘envir’
[10:25:46.156]   - Field: ‘packages’
[10:25:46.156]   - Field: ‘gc’
[10:25:46.156]   - Field: ‘conditions’
[10:25:46.156]   - Field: ‘expr’
[10:25:46.156]   - Field: ‘uuid’
[10:25:46.156]   - Field: ‘seed’
[10:25:46.156]   - Field: ‘version’
[10:25:46.156]   - Field: ‘result’
[10:25:46.156]   - Field: ‘asynchronous’
[10:25:46.156]   - Field: ‘calls’
[10:25:46.157]   - Field: ‘globals’
[10:25:46.157]   - Field: ‘stdout’
[10:25:46.157]   - Field: ‘earlySignal’
[10:25:46.157]   - Field: ‘lazy’
[10:25:46.157]   - Field: ‘state’
[10:25:46.157] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.157] - Launch lazy future ...
[10:25:46.157] Packages needed by the future expression (n = 0): <none>
[10:25:46.157] Packages needed by future strategies (n = 0): <none>
[10:25:46.158] {
[10:25:46.158]     {
[10:25:46.158]         {
[10:25:46.158]             ...future.startTime <- base::Sys.time()
[10:25:46.158]             {
[10:25:46.158]                 {
[10:25:46.158]                   {
[10:25:46.158]                     base::local({
[10:25:46.158]                       has_future <- base::requireNamespace("future", 
[10:25:46.158]                         quietly = TRUE)
[10:25:46.158]                       if (has_future) {
[10:25:46.158]                         ns <- base::getNamespace("future")
[10:25:46.158]                         version <- ns[[".package"]][["version"]]
[10:25:46.158]                         if (is.null(version)) 
[10:25:46.158]                           version <- utils::packageVersion("future")
[10:25:46.158]                       }
[10:25:46.158]                       else {
[10:25:46.158]                         version <- NULL
[10:25:46.158]                       }
[10:25:46.158]                       if (!has_future || version < "1.8.0") {
[10:25:46.158]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.158]                           "", base::R.version$version.string), 
[10:25:46.158]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.158]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.158]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.158]                             "release", "version")], collapse = " "), 
[10:25:46.158]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.158]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.158]                           info)
[10:25:46.158]                         info <- base::paste(info, collapse = "; ")
[10:25:46.158]                         if (!has_future) {
[10:25:46.158]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.158]                             info)
[10:25:46.158]                         }
[10:25:46.158]                         else {
[10:25:46.158]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.158]                             info, version)
[10:25:46.158]                         }
[10:25:46.158]                         base::stop(msg)
[10:25:46.158]                       }
[10:25:46.158]                     })
[10:25:46.158]                   }
[10:25:46.158]                   options(future.plan = NULL)
[10:25:46.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.158]                 }
[10:25:46.158]                 ...future.workdir <- getwd()
[10:25:46.158]             }
[10:25:46.158]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.158]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.158]         }
[10:25:46.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.158]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.158]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.158]             base::names(...future.oldOptions))
[10:25:46.158]     }
[10:25:46.158]     if (FALSE) {
[10:25:46.158]     }
[10:25:46.158]     else {
[10:25:46.158]         if (TRUE) {
[10:25:46.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.158]                 open = "w")
[10:25:46.158]         }
[10:25:46.158]         else {
[10:25:46.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.158]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.158]         }
[10:25:46.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.158]             base::sink(type = "output", split = FALSE)
[10:25:46.158]             base::close(...future.stdout)
[10:25:46.158]         }, add = TRUE)
[10:25:46.158]     }
[10:25:46.158]     ...future.frame <- base::sys.nframe()
[10:25:46.158]     ...future.conditions <- base::list()
[10:25:46.158]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.158]     if (FALSE) {
[10:25:46.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.158]     }
[10:25:46.158]     ...future.result <- base::tryCatch({
[10:25:46.158]         base::withCallingHandlers({
[10:25:46.158]             ...future.value <- base::withVisible(base::local({
[10:25:46.158]                 4
[10:25:46.158]             }))
[10:25:46.158]             future::FutureResult(value = ...future.value$value, 
[10:25:46.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.158]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.158]                     ...future.globalenv.names))
[10:25:46.158]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.158]         }, condition = base::local({
[10:25:46.158]             c <- base::c
[10:25:46.158]             inherits <- base::inherits
[10:25:46.158]             invokeRestart <- base::invokeRestart
[10:25:46.158]             length <- base::length
[10:25:46.158]             list <- base::list
[10:25:46.158]             seq.int <- base::seq.int
[10:25:46.158]             signalCondition <- base::signalCondition
[10:25:46.158]             sys.calls <- base::sys.calls
[10:25:46.158]             `[[` <- base::`[[`
[10:25:46.158]             `+` <- base::`+`
[10:25:46.158]             `<<-` <- base::`<<-`
[10:25:46.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.158]                   3L)]
[10:25:46.158]             }
[10:25:46.158]             function(cond) {
[10:25:46.158]                 is_error <- inherits(cond, "error")
[10:25:46.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.158]                   NULL)
[10:25:46.158]                 if (is_error) {
[10:25:46.158]                   sessionInformation <- function() {
[10:25:46.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.158]                       search = base::search(), system = base::Sys.info())
[10:25:46.158]                   }
[10:25:46.158]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.158]                     cond$call), session = sessionInformation(), 
[10:25:46.158]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.158]                   signalCondition(cond)
[10:25:46.158]                 }
[10:25:46.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.158]                 "immediateCondition"))) {
[10:25:46.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.158]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.158]                   if (TRUE && !signal) {
[10:25:46.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.158]                     {
[10:25:46.158]                       inherits <- base::inherits
[10:25:46.158]                       invokeRestart <- base::invokeRestart
[10:25:46.158]                       is.null <- base::is.null
[10:25:46.158]                       muffled <- FALSE
[10:25:46.158]                       if (inherits(cond, "message")) {
[10:25:46.158]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.158]                         if (muffled) 
[10:25:46.158]                           invokeRestart("muffleMessage")
[10:25:46.158]                       }
[10:25:46.158]                       else if (inherits(cond, "warning")) {
[10:25:46.158]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.158]                         if (muffled) 
[10:25:46.158]                           invokeRestart("muffleWarning")
[10:25:46.158]                       }
[10:25:46.158]                       else if (inherits(cond, "condition")) {
[10:25:46.158]                         if (!is.null(pattern)) {
[10:25:46.158]                           computeRestarts <- base::computeRestarts
[10:25:46.158]                           grepl <- base::grepl
[10:25:46.158]                           restarts <- computeRestarts(cond)
[10:25:46.158]                           for (restart in restarts) {
[10:25:46.158]                             name <- restart$name
[10:25:46.158]                             if (is.null(name)) 
[10:25:46.158]                               next
[10:25:46.158]                             if (!grepl(pattern, name)) 
[10:25:46.158]                               next
[10:25:46.158]                             invokeRestart(restart)
[10:25:46.158]                             muffled <- TRUE
[10:25:46.158]                             break
[10:25:46.158]                           }
[10:25:46.158]                         }
[10:25:46.158]                       }
[10:25:46.158]                       invisible(muffled)
[10:25:46.158]                     }
[10:25:46.158]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.158]                   }
[10:25:46.158]                 }
[10:25:46.158]                 else {
[10:25:46.158]                   if (TRUE) {
[10:25:46.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.158]                     {
[10:25:46.158]                       inherits <- base::inherits
[10:25:46.158]                       invokeRestart <- base::invokeRestart
[10:25:46.158]                       is.null <- base::is.null
[10:25:46.158]                       muffled <- FALSE
[10:25:46.158]                       if (inherits(cond, "message")) {
[10:25:46.158]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.158]                         if (muffled) 
[10:25:46.158]                           invokeRestart("muffleMessage")
[10:25:46.158]                       }
[10:25:46.158]                       else if (inherits(cond, "warning")) {
[10:25:46.158]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.158]                         if (muffled) 
[10:25:46.158]                           invokeRestart("muffleWarning")
[10:25:46.158]                       }
[10:25:46.158]                       else if (inherits(cond, "condition")) {
[10:25:46.158]                         if (!is.null(pattern)) {
[10:25:46.158]                           computeRestarts <- base::computeRestarts
[10:25:46.158]                           grepl <- base::grepl
[10:25:46.158]                           restarts <- computeRestarts(cond)
[10:25:46.158]                           for (restart in restarts) {
[10:25:46.158]                             name <- restart$name
[10:25:46.158]                             if (is.null(name)) 
[10:25:46.158]                               next
[10:25:46.158]                             if (!grepl(pattern, name)) 
[10:25:46.158]                               next
[10:25:46.158]                             invokeRestart(restart)
[10:25:46.158]                             muffled <- TRUE
[10:25:46.158]                             break
[10:25:46.158]                           }
[10:25:46.158]                         }
[10:25:46.158]                       }
[10:25:46.158]                       invisible(muffled)
[10:25:46.158]                     }
[10:25:46.158]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.158]                   }
[10:25:46.158]                 }
[10:25:46.158]             }
[10:25:46.158]         }))
[10:25:46.158]     }, error = function(ex) {
[10:25:46.158]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.158]                 ...future.rng), started = ...future.startTime, 
[10:25:46.158]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.158]             version = "1.8"), class = "FutureResult")
[10:25:46.158]     }, finally = {
[10:25:46.158]         if (!identical(...future.workdir, getwd())) 
[10:25:46.158]             setwd(...future.workdir)
[10:25:46.158]         {
[10:25:46.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.158]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.158]             }
[10:25:46.158]             base::options(...future.oldOptions)
[10:25:46.158]             if (.Platform$OS.type == "windows") {
[10:25:46.158]                 old_names <- names(...future.oldEnvVars)
[10:25:46.158]                 envs <- base::Sys.getenv()
[10:25:46.158]                 names <- names(envs)
[10:25:46.158]                 common <- intersect(names, old_names)
[10:25:46.158]                 added <- setdiff(names, old_names)
[10:25:46.158]                 removed <- setdiff(old_names, names)
[10:25:46.158]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.158]                   envs[common]]
[10:25:46.158]                 NAMES <- toupper(changed)
[10:25:46.158]                 args <- list()
[10:25:46.158]                 for (kk in seq_along(NAMES)) {
[10:25:46.158]                   name <- changed[[kk]]
[10:25:46.158]                   NAME <- NAMES[[kk]]
[10:25:46.158]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.158]                     next
[10:25:46.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.158]                 }
[10:25:46.158]                 NAMES <- toupper(added)
[10:25:46.158]                 for (kk in seq_along(NAMES)) {
[10:25:46.158]                   name <- added[[kk]]
[10:25:46.158]                   NAME <- NAMES[[kk]]
[10:25:46.158]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.158]                     next
[10:25:46.158]                   args[[name]] <- ""
[10:25:46.158]                 }
[10:25:46.158]                 NAMES <- toupper(removed)
[10:25:46.158]                 for (kk in seq_along(NAMES)) {
[10:25:46.158]                   name <- removed[[kk]]
[10:25:46.158]                   NAME <- NAMES[[kk]]
[10:25:46.158]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.158]                     next
[10:25:46.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.158]                 }
[10:25:46.158]                 if (length(args) > 0) 
[10:25:46.158]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.158]             }
[10:25:46.158]             else {
[10:25:46.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.158]             }
[10:25:46.158]             {
[10:25:46.158]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.158]                   0L) {
[10:25:46.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.158]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.158]                   base::options(opts)
[10:25:46.158]                 }
[10:25:46.158]                 {
[10:25:46.158]                   {
[10:25:46.158]                     NULL
[10:25:46.158]                     RNGkind("Mersenne-Twister")
[10:25:46.158]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.158]                       inherits = FALSE)
[10:25:46.158]                   }
[10:25:46.158]                   options(future.plan = NULL)
[10:25:46.158]                   if (is.na(NA_character_)) 
[10:25:46.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.158]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.158]                   {
[10:25:46.158]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.158]                     if (!future$lazy) 
[10:25:46.158]                       future <- run(future)
[10:25:46.158]                     invisible(future)
[10:25:46.158]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.158]                 }
[10:25:46.158]             }
[10:25:46.158]         }
[10:25:46.158]     })
[10:25:46.158]     if (TRUE) {
[10:25:46.158]         base::sink(type = "output", split = FALSE)
[10:25:46.158]         if (TRUE) {
[10:25:46.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.158]         }
[10:25:46.158]         else {
[10:25:46.158]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.158]         }
[10:25:46.158]         base::close(...future.stdout)
[10:25:46.158]         ...future.stdout <- NULL
[10:25:46.158]     }
[10:25:46.158]     ...future.result$conditions <- ...future.conditions
[10:25:46.158]     ...future.result$finished <- base::Sys.time()
[10:25:46.158]     ...future.result
[10:25:46.158] }
[10:25:46.160] plan(): Setting new future strategy stack:
[10:25:46.160] List of future strategies:
[10:25:46.160] 1. sequential:
[10:25:46.160]    - args: function (..., envir = parent.frame())
[10:25:46.160]    - tweaked: FALSE
[10:25:46.160]    - call: NULL
[10:25:46.160] plan(): nbrOfWorkers() = 1
[10:25:46.161] plan(): Setting new future strategy stack:
[10:25:46.161] List of future strategies:
[10:25:46.161] 1. sequential:
[10:25:46.161]    - args: function (..., envir = parent.frame())
[10:25:46.161]    - tweaked: FALSE
[10:25:46.161]    - call: plan(strategy)
[10:25:46.161] plan(): nbrOfWorkers() = 1
[10:25:46.161] SequentialFuture started (and completed)
[10:25:46.161] - Launch lazy future ... done
[10:25:46.162] run() for ‘SequentialFuture’ ... done
<environment: 0x55c0f528bc00> 
<environment: 0x55c0f505a148> 
[10:25:46.163] resolved() for ‘SequentialFuture’ ...
[10:25:46.163] - state: ‘finished’
[10:25:46.163] - run: TRUE
[10:25:46.163] - result: ‘FutureResult’
[10:25:46.163] resolved() for ‘SequentialFuture’ ... done
[10:25:46.163] resolved() for ‘SequentialFuture’ ...
[10:25:46.163] - state: ‘finished’
[10:25:46.163] - run: TRUE
[10:25:46.163] - result: ‘FutureResult’
[10:25:46.164] resolved() for ‘SequentialFuture’ ... done
[10:25:46.164] resolved() for ‘SequentialFuture’ ...
[10:25:46.164] - state: ‘finished’
[10:25:46.164] - run: TRUE
[10:25:46.164] - result: ‘FutureResult’
[10:25:46.164] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:46.165] resolve() on environment ...
[10:25:46.165]  recursive: 0
[10:25:46.166]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:46.166] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.166] - nx: 4
[10:25:46.166] - relay: TRUE
[10:25:46.166] - stdout: TRUE
[10:25:46.166] - signal: TRUE
[10:25:46.166] - resignal: FALSE
[10:25:46.166] - force: TRUE
[10:25:46.166] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.166] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.167]  - until=2
[10:25:46.167]  - relaying element #2
[10:25:46.167] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.167] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.167] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.167]  length: 3 (resolved future 1)
[10:25:46.167] resolved() for ‘SequentialFuture’ ...
[10:25:46.167] - state: ‘finished’
[10:25:46.167] - run: TRUE
[10:25:46.167] - result: ‘FutureResult’
[10:25:46.167] resolved() for ‘SequentialFuture’ ... done
[10:25:46.168] Future #2
[10:25:46.168] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.168] - nx: 4
[10:25:46.168] - relay: TRUE
[10:25:46.168] - stdout: TRUE
[10:25:46.168] - signal: TRUE
[10:25:46.168] - resignal: FALSE
[10:25:46.168] - force: TRUE
[10:25:46.168] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.168] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.168]  - until=2
[10:25:46.168]  - relaying element #2
[10:25:46.169] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.169] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.169] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.169]  length: 2 (resolved future 2)
[10:25:46.169] resolved() for ‘SequentialFuture’ ...
[10:25:46.169] - state: ‘finished’
[10:25:46.169] - run: TRUE
[10:25:46.169] - result: ‘FutureResult’
[10:25:46.169] resolved() for ‘SequentialFuture’ ... done
[10:25:46.170] Future #3
[10:25:46.170] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.170] - nx: 4
[10:25:46.170] - relay: TRUE
[10:25:46.170] - stdout: TRUE
[10:25:46.170] - signal: TRUE
[10:25:46.170] - resignal: FALSE
[10:25:46.170] - force: TRUE
[10:25:46.170] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.170] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.170]  - until=3
[10:25:46.170]  - relaying element #3
[10:25:46.171] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.171] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.171] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.171]  length: 1 (resolved future 3)
[10:25:46.171] resolved() for ‘SequentialFuture’ ...
[10:25:46.171] - state: ‘finished’
[10:25:46.171] - run: TRUE
[10:25:46.171] - result: ‘FutureResult’
[10:25:46.171] resolved() for ‘SequentialFuture’ ... done
[10:25:46.171] Future #4
[10:25:46.173] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.173] - nx: 4
[10:25:46.173] - relay: TRUE
[10:25:46.173] - stdout: TRUE
[10:25:46.174] - signal: TRUE
[10:25:46.174] - resignal: FALSE
[10:25:46.174] - force: TRUE
[10:25:46.174] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.174] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.174]  - until=4
[10:25:46.174]  - relaying element #4
[10:25:46.174] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.174] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.174] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.175]  length: 0 (resolved future 4)
[10:25:46.175] Relaying remaining futures
[10:25:46.175] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.175] - nx: 4
[10:25:46.175] - relay: TRUE
[10:25:46.175] - stdout: TRUE
[10:25:46.175] - signal: TRUE
[10:25:46.175] - resignal: FALSE
[10:25:46.175] - force: TRUE
[10:25:46.175] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.175] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:46.175] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.176] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.176] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.176] resolve() on environment ... DONE
<environment: 0x55c0f52879d0> 
Dimensions: c(2, 3)
[10:25:46.176] getGlobalsAndPackages() ...
[10:25:46.176] Searching for globals...
[10:25:46.177] 
[10:25:46.177] Searching for globals ... DONE
[10:25:46.177] - globals: [0] <none>
[10:25:46.177] getGlobalsAndPackages() ... DONE
[10:25:46.177] run() for ‘Future’ ...
[10:25:46.177] - state: ‘created’
[10:25:46.177] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.178] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.178]   - Field: ‘label’
[10:25:46.178]   - Field: ‘local’
[10:25:46.178]   - Field: ‘owner’
[10:25:46.178]   - Field: ‘envir’
[10:25:46.178]   - Field: ‘packages’
[10:25:46.178]   - Field: ‘gc’
[10:25:46.178]   - Field: ‘conditions’
[10:25:46.179]   - Field: ‘expr’
[10:25:46.179]   - Field: ‘uuid’
[10:25:46.179]   - Field: ‘seed’
[10:25:46.179]   - Field: ‘version’
[10:25:46.179]   - Field: ‘result’
[10:25:46.179]   - Field: ‘asynchronous’
[10:25:46.179]   - Field: ‘calls’
[10:25:46.179]   - Field: ‘globals’
[10:25:46.179]   - Field: ‘stdout’
[10:25:46.179]   - Field: ‘earlySignal’
[10:25:46.179]   - Field: ‘lazy’
[10:25:46.179]   - Field: ‘state’
[10:25:46.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.180] - Launch lazy future ...
[10:25:46.180] Packages needed by the future expression (n = 0): <none>
[10:25:46.180] Packages needed by future strategies (n = 0): <none>
[10:25:46.180] {
[10:25:46.180]     {
[10:25:46.180]         {
[10:25:46.180]             ...future.startTime <- base::Sys.time()
[10:25:46.180]             {
[10:25:46.180]                 {
[10:25:46.180]                   {
[10:25:46.180]                     base::local({
[10:25:46.180]                       has_future <- base::requireNamespace("future", 
[10:25:46.180]                         quietly = TRUE)
[10:25:46.180]                       if (has_future) {
[10:25:46.180]                         ns <- base::getNamespace("future")
[10:25:46.180]                         version <- ns[[".package"]][["version"]]
[10:25:46.180]                         if (is.null(version)) 
[10:25:46.180]                           version <- utils::packageVersion("future")
[10:25:46.180]                       }
[10:25:46.180]                       else {
[10:25:46.180]                         version <- NULL
[10:25:46.180]                       }
[10:25:46.180]                       if (!has_future || version < "1.8.0") {
[10:25:46.180]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.180]                           "", base::R.version$version.string), 
[10:25:46.180]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.180]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.180]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.180]                             "release", "version")], collapse = " "), 
[10:25:46.180]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.180]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.180]                           info)
[10:25:46.180]                         info <- base::paste(info, collapse = "; ")
[10:25:46.180]                         if (!has_future) {
[10:25:46.180]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.180]                             info)
[10:25:46.180]                         }
[10:25:46.180]                         else {
[10:25:46.180]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.180]                             info, version)
[10:25:46.180]                         }
[10:25:46.180]                         base::stop(msg)
[10:25:46.180]                       }
[10:25:46.180]                     })
[10:25:46.180]                   }
[10:25:46.180]                   options(future.plan = NULL)
[10:25:46.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.180]                 }
[10:25:46.180]                 ...future.workdir <- getwd()
[10:25:46.180]             }
[10:25:46.180]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.180]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.180]         }
[10:25:46.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.180]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.180]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.180]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.180]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.180]             base::names(...future.oldOptions))
[10:25:46.180]     }
[10:25:46.180]     if (FALSE) {
[10:25:46.180]     }
[10:25:46.180]     else {
[10:25:46.180]         if (TRUE) {
[10:25:46.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.180]                 open = "w")
[10:25:46.180]         }
[10:25:46.180]         else {
[10:25:46.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.180]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.180]         }
[10:25:46.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.180]             base::sink(type = "output", split = FALSE)
[10:25:46.180]             base::close(...future.stdout)
[10:25:46.180]         }, add = TRUE)
[10:25:46.180]     }
[10:25:46.180]     ...future.frame <- base::sys.nframe()
[10:25:46.180]     ...future.conditions <- base::list()
[10:25:46.180]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.180]     if (FALSE) {
[10:25:46.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.180]     }
[10:25:46.180]     ...future.result <- base::tryCatch({
[10:25:46.180]         base::withCallingHandlers({
[10:25:46.180]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.180]             future::FutureResult(value = ...future.value$value, 
[10:25:46.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.180]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.180]                     ...future.globalenv.names))
[10:25:46.180]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.180]         }, condition = base::local({
[10:25:46.180]             c <- base::c
[10:25:46.180]             inherits <- base::inherits
[10:25:46.180]             invokeRestart <- base::invokeRestart
[10:25:46.180]             length <- base::length
[10:25:46.180]             list <- base::list
[10:25:46.180]             seq.int <- base::seq.int
[10:25:46.180]             signalCondition <- base::signalCondition
[10:25:46.180]             sys.calls <- base::sys.calls
[10:25:46.180]             `[[` <- base::`[[`
[10:25:46.180]             `+` <- base::`+`
[10:25:46.180]             `<<-` <- base::`<<-`
[10:25:46.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.180]                   3L)]
[10:25:46.180]             }
[10:25:46.180]             function(cond) {
[10:25:46.180]                 is_error <- inherits(cond, "error")
[10:25:46.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.180]                   NULL)
[10:25:46.180]                 if (is_error) {
[10:25:46.180]                   sessionInformation <- function() {
[10:25:46.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.180]                       search = base::search(), system = base::Sys.info())
[10:25:46.180]                   }
[10:25:46.180]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.180]                     cond$call), session = sessionInformation(), 
[10:25:46.180]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.180]                   signalCondition(cond)
[10:25:46.180]                 }
[10:25:46.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.180]                 "immediateCondition"))) {
[10:25:46.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.180]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.180]                   if (TRUE && !signal) {
[10:25:46.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.180]                     {
[10:25:46.180]                       inherits <- base::inherits
[10:25:46.180]                       invokeRestart <- base::invokeRestart
[10:25:46.180]                       is.null <- base::is.null
[10:25:46.180]                       muffled <- FALSE
[10:25:46.180]                       if (inherits(cond, "message")) {
[10:25:46.180]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.180]                         if (muffled) 
[10:25:46.180]                           invokeRestart("muffleMessage")
[10:25:46.180]                       }
[10:25:46.180]                       else if (inherits(cond, "warning")) {
[10:25:46.180]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.180]                         if (muffled) 
[10:25:46.180]                           invokeRestart("muffleWarning")
[10:25:46.180]                       }
[10:25:46.180]                       else if (inherits(cond, "condition")) {
[10:25:46.180]                         if (!is.null(pattern)) {
[10:25:46.180]                           computeRestarts <- base::computeRestarts
[10:25:46.180]                           grepl <- base::grepl
[10:25:46.180]                           restarts <- computeRestarts(cond)
[10:25:46.180]                           for (restart in restarts) {
[10:25:46.180]                             name <- restart$name
[10:25:46.180]                             if (is.null(name)) 
[10:25:46.180]                               next
[10:25:46.180]                             if (!grepl(pattern, name)) 
[10:25:46.180]                               next
[10:25:46.180]                             invokeRestart(restart)
[10:25:46.180]                             muffled <- TRUE
[10:25:46.180]                             break
[10:25:46.180]                           }
[10:25:46.180]                         }
[10:25:46.180]                       }
[10:25:46.180]                       invisible(muffled)
[10:25:46.180]                     }
[10:25:46.180]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.180]                   }
[10:25:46.180]                 }
[10:25:46.180]                 else {
[10:25:46.180]                   if (TRUE) {
[10:25:46.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.180]                     {
[10:25:46.180]                       inherits <- base::inherits
[10:25:46.180]                       invokeRestart <- base::invokeRestart
[10:25:46.180]                       is.null <- base::is.null
[10:25:46.180]                       muffled <- FALSE
[10:25:46.180]                       if (inherits(cond, "message")) {
[10:25:46.180]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.180]                         if (muffled) 
[10:25:46.180]                           invokeRestart("muffleMessage")
[10:25:46.180]                       }
[10:25:46.180]                       else if (inherits(cond, "warning")) {
[10:25:46.180]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.180]                         if (muffled) 
[10:25:46.180]                           invokeRestart("muffleWarning")
[10:25:46.180]                       }
[10:25:46.180]                       else if (inherits(cond, "condition")) {
[10:25:46.180]                         if (!is.null(pattern)) {
[10:25:46.180]                           computeRestarts <- base::computeRestarts
[10:25:46.180]                           grepl <- base::grepl
[10:25:46.180]                           restarts <- computeRestarts(cond)
[10:25:46.180]                           for (restart in restarts) {
[10:25:46.180]                             name <- restart$name
[10:25:46.180]                             if (is.null(name)) 
[10:25:46.180]                               next
[10:25:46.180]                             if (!grepl(pattern, name)) 
[10:25:46.180]                               next
[10:25:46.180]                             invokeRestart(restart)
[10:25:46.180]                             muffled <- TRUE
[10:25:46.180]                             break
[10:25:46.180]                           }
[10:25:46.180]                         }
[10:25:46.180]                       }
[10:25:46.180]                       invisible(muffled)
[10:25:46.180]                     }
[10:25:46.180]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.180]                   }
[10:25:46.180]                 }
[10:25:46.180]             }
[10:25:46.180]         }))
[10:25:46.180]     }, error = function(ex) {
[10:25:46.180]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.180]                 ...future.rng), started = ...future.startTime, 
[10:25:46.180]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.180]             version = "1.8"), class = "FutureResult")
[10:25:46.180]     }, finally = {
[10:25:46.180]         if (!identical(...future.workdir, getwd())) 
[10:25:46.180]             setwd(...future.workdir)
[10:25:46.180]         {
[10:25:46.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.180]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.180]             }
[10:25:46.180]             base::options(...future.oldOptions)
[10:25:46.180]             if (.Platform$OS.type == "windows") {
[10:25:46.180]                 old_names <- names(...future.oldEnvVars)
[10:25:46.180]                 envs <- base::Sys.getenv()
[10:25:46.180]                 names <- names(envs)
[10:25:46.180]                 common <- intersect(names, old_names)
[10:25:46.180]                 added <- setdiff(names, old_names)
[10:25:46.180]                 removed <- setdiff(old_names, names)
[10:25:46.180]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.180]                   envs[common]]
[10:25:46.180]                 NAMES <- toupper(changed)
[10:25:46.180]                 args <- list()
[10:25:46.180]                 for (kk in seq_along(NAMES)) {
[10:25:46.180]                   name <- changed[[kk]]
[10:25:46.180]                   NAME <- NAMES[[kk]]
[10:25:46.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.180]                     next
[10:25:46.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.180]                 }
[10:25:46.180]                 NAMES <- toupper(added)
[10:25:46.180]                 for (kk in seq_along(NAMES)) {
[10:25:46.180]                   name <- added[[kk]]
[10:25:46.180]                   NAME <- NAMES[[kk]]
[10:25:46.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.180]                     next
[10:25:46.180]                   args[[name]] <- ""
[10:25:46.180]                 }
[10:25:46.180]                 NAMES <- toupper(removed)
[10:25:46.180]                 for (kk in seq_along(NAMES)) {
[10:25:46.180]                   name <- removed[[kk]]
[10:25:46.180]                   NAME <- NAMES[[kk]]
[10:25:46.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.180]                     next
[10:25:46.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.180]                 }
[10:25:46.180]                 if (length(args) > 0) 
[10:25:46.180]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.180]             }
[10:25:46.180]             else {
[10:25:46.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.180]             }
[10:25:46.180]             {
[10:25:46.180]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.180]                   0L) {
[10:25:46.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.180]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.180]                   base::options(opts)
[10:25:46.180]                 }
[10:25:46.180]                 {
[10:25:46.180]                   {
[10:25:46.180]                     NULL
[10:25:46.180]                     RNGkind("Mersenne-Twister")
[10:25:46.180]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.180]                       inherits = FALSE)
[10:25:46.180]                   }
[10:25:46.180]                   options(future.plan = NULL)
[10:25:46.180]                   if (is.na(NA_character_)) 
[10:25:46.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.180]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.180]                   {
[10:25:46.180]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.180]                     if (!future$lazy) 
[10:25:46.180]                       future <- run(future)
[10:25:46.180]                     invisible(future)
[10:25:46.180]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.180]                 }
[10:25:46.180]             }
[10:25:46.180]         }
[10:25:46.180]     })
[10:25:46.180]     if (TRUE) {
[10:25:46.180]         base::sink(type = "output", split = FALSE)
[10:25:46.180]         if (TRUE) {
[10:25:46.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.180]         }
[10:25:46.180]         else {
[10:25:46.180]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.180]         }
[10:25:46.180]         base::close(...future.stdout)
[10:25:46.180]         ...future.stdout <- NULL
[10:25:46.180]     }
[10:25:46.180]     ...future.result$conditions <- ...future.conditions
[10:25:46.180]     ...future.result$finished <- base::Sys.time()
[10:25:46.180]     ...future.result
[10:25:46.180] }
[10:25:46.182] plan(): Setting new future strategy stack:
[10:25:46.182] List of future strategies:
[10:25:46.182] 1. sequential:
[10:25:46.182]    - args: function (..., envir = parent.frame())
[10:25:46.182]    - tweaked: FALSE
[10:25:46.182]    - call: NULL
[10:25:46.183] plan(): nbrOfWorkers() = 1
[10:25:46.183] plan(): Setting new future strategy stack:
[10:25:46.183] List of future strategies:
[10:25:46.183] 1. sequential:
[10:25:46.183]    - args: function (..., envir = parent.frame())
[10:25:46.183]    - tweaked: FALSE
[10:25:46.183]    - call: plan(strategy)
[10:25:46.184] plan(): nbrOfWorkers() = 1
[10:25:46.184] SequentialFuture started (and completed)
[10:25:46.184] - Launch lazy future ... done
[10:25:46.184] run() for ‘SequentialFuture’ ... done
[10:25:46.184] getGlobalsAndPackages() ...
[10:25:46.184] Searching for globals...
[10:25:46.184] 
[10:25:46.185] Searching for globals ... DONE
[10:25:46.185] - globals: [0] <none>
[10:25:46.185] getGlobalsAndPackages() ... DONE
[10:25:46.185] run() for ‘Future’ ...
[10:25:46.185] - state: ‘created’
[10:25:46.185] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.185] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.185] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.186]   - Field: ‘label’
[10:25:46.186]   - Field: ‘local’
[10:25:46.186]   - Field: ‘owner’
[10:25:46.186]   - Field: ‘envir’
[10:25:46.186]   - Field: ‘packages’
[10:25:46.186]   - Field: ‘gc’
[10:25:46.186]   - Field: ‘conditions’
[10:25:46.186]   - Field: ‘expr’
[10:25:46.186]   - Field: ‘uuid’
[10:25:46.186]   - Field: ‘seed’
[10:25:46.186]   - Field: ‘version’
[10:25:46.187]   - Field: ‘result’
[10:25:46.187]   - Field: ‘asynchronous’
[10:25:46.187]   - Field: ‘calls’
[10:25:46.187]   - Field: ‘globals’
[10:25:46.187]   - Field: ‘stdout’
[10:25:46.187]   - Field: ‘earlySignal’
[10:25:46.187]   - Field: ‘lazy’
[10:25:46.187]   - Field: ‘state’
[10:25:46.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.187] - Launch lazy future ...
[10:25:46.188] Packages needed by the future expression (n = 0): <none>
[10:25:46.188] Packages needed by future strategies (n = 0): <none>
[10:25:46.188] {
[10:25:46.188]     {
[10:25:46.188]         {
[10:25:46.188]             ...future.startTime <- base::Sys.time()
[10:25:46.188]             {
[10:25:46.188]                 {
[10:25:46.188]                   {
[10:25:46.188]                     base::local({
[10:25:46.188]                       has_future <- base::requireNamespace("future", 
[10:25:46.188]                         quietly = TRUE)
[10:25:46.188]                       if (has_future) {
[10:25:46.188]                         ns <- base::getNamespace("future")
[10:25:46.188]                         version <- ns[[".package"]][["version"]]
[10:25:46.188]                         if (is.null(version)) 
[10:25:46.188]                           version <- utils::packageVersion("future")
[10:25:46.188]                       }
[10:25:46.188]                       else {
[10:25:46.188]                         version <- NULL
[10:25:46.188]                       }
[10:25:46.188]                       if (!has_future || version < "1.8.0") {
[10:25:46.188]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.188]                           "", base::R.version$version.string), 
[10:25:46.188]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.188]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.188]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.188]                             "release", "version")], collapse = " "), 
[10:25:46.188]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.188]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.188]                           info)
[10:25:46.188]                         info <- base::paste(info, collapse = "; ")
[10:25:46.188]                         if (!has_future) {
[10:25:46.188]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.188]                             info)
[10:25:46.188]                         }
[10:25:46.188]                         else {
[10:25:46.188]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.188]                             info, version)
[10:25:46.188]                         }
[10:25:46.188]                         base::stop(msg)
[10:25:46.188]                       }
[10:25:46.188]                     })
[10:25:46.188]                   }
[10:25:46.188]                   options(future.plan = NULL)
[10:25:46.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.188]                 }
[10:25:46.188]                 ...future.workdir <- getwd()
[10:25:46.188]             }
[10:25:46.188]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.188]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.188]         }
[10:25:46.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.188]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.188]             base::names(...future.oldOptions))
[10:25:46.188]     }
[10:25:46.188]     if (FALSE) {
[10:25:46.188]     }
[10:25:46.188]     else {
[10:25:46.188]         if (TRUE) {
[10:25:46.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.188]                 open = "w")
[10:25:46.188]         }
[10:25:46.188]         else {
[10:25:46.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.188]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.188]         }
[10:25:46.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.188]             base::sink(type = "output", split = FALSE)
[10:25:46.188]             base::close(...future.stdout)
[10:25:46.188]         }, add = TRUE)
[10:25:46.188]     }
[10:25:46.188]     ...future.frame <- base::sys.nframe()
[10:25:46.188]     ...future.conditions <- base::list()
[10:25:46.188]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.188]     if (FALSE) {
[10:25:46.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.188]     }
[10:25:46.188]     ...future.result <- base::tryCatch({
[10:25:46.188]         base::withCallingHandlers({
[10:25:46.188]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.188]             future::FutureResult(value = ...future.value$value, 
[10:25:46.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.188]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.188]                     ...future.globalenv.names))
[10:25:46.188]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.188]         }, condition = base::local({
[10:25:46.188]             c <- base::c
[10:25:46.188]             inherits <- base::inherits
[10:25:46.188]             invokeRestart <- base::invokeRestart
[10:25:46.188]             length <- base::length
[10:25:46.188]             list <- base::list
[10:25:46.188]             seq.int <- base::seq.int
[10:25:46.188]             signalCondition <- base::signalCondition
[10:25:46.188]             sys.calls <- base::sys.calls
[10:25:46.188]             `[[` <- base::`[[`
[10:25:46.188]             `+` <- base::`+`
[10:25:46.188]             `<<-` <- base::`<<-`
[10:25:46.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.188]                   3L)]
[10:25:46.188]             }
[10:25:46.188]             function(cond) {
[10:25:46.188]                 is_error <- inherits(cond, "error")
[10:25:46.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.188]                   NULL)
[10:25:46.188]                 if (is_error) {
[10:25:46.188]                   sessionInformation <- function() {
[10:25:46.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.188]                       search = base::search(), system = base::Sys.info())
[10:25:46.188]                   }
[10:25:46.188]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.188]                     cond$call), session = sessionInformation(), 
[10:25:46.188]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.188]                   signalCondition(cond)
[10:25:46.188]                 }
[10:25:46.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.188]                 "immediateCondition"))) {
[10:25:46.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.188]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.188]                   if (TRUE && !signal) {
[10:25:46.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.188]                     {
[10:25:46.188]                       inherits <- base::inherits
[10:25:46.188]                       invokeRestart <- base::invokeRestart
[10:25:46.188]                       is.null <- base::is.null
[10:25:46.188]                       muffled <- FALSE
[10:25:46.188]                       if (inherits(cond, "message")) {
[10:25:46.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.188]                         if (muffled) 
[10:25:46.188]                           invokeRestart("muffleMessage")
[10:25:46.188]                       }
[10:25:46.188]                       else if (inherits(cond, "warning")) {
[10:25:46.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.188]                         if (muffled) 
[10:25:46.188]                           invokeRestart("muffleWarning")
[10:25:46.188]                       }
[10:25:46.188]                       else if (inherits(cond, "condition")) {
[10:25:46.188]                         if (!is.null(pattern)) {
[10:25:46.188]                           computeRestarts <- base::computeRestarts
[10:25:46.188]                           grepl <- base::grepl
[10:25:46.188]                           restarts <- computeRestarts(cond)
[10:25:46.188]                           for (restart in restarts) {
[10:25:46.188]                             name <- restart$name
[10:25:46.188]                             if (is.null(name)) 
[10:25:46.188]                               next
[10:25:46.188]                             if (!grepl(pattern, name)) 
[10:25:46.188]                               next
[10:25:46.188]                             invokeRestart(restart)
[10:25:46.188]                             muffled <- TRUE
[10:25:46.188]                             break
[10:25:46.188]                           }
[10:25:46.188]                         }
[10:25:46.188]                       }
[10:25:46.188]                       invisible(muffled)
[10:25:46.188]                     }
[10:25:46.188]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.188]                   }
[10:25:46.188]                 }
[10:25:46.188]                 else {
[10:25:46.188]                   if (TRUE) {
[10:25:46.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.188]                     {
[10:25:46.188]                       inherits <- base::inherits
[10:25:46.188]                       invokeRestart <- base::invokeRestart
[10:25:46.188]                       is.null <- base::is.null
[10:25:46.188]                       muffled <- FALSE
[10:25:46.188]                       if (inherits(cond, "message")) {
[10:25:46.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.188]                         if (muffled) 
[10:25:46.188]                           invokeRestart("muffleMessage")
[10:25:46.188]                       }
[10:25:46.188]                       else if (inherits(cond, "warning")) {
[10:25:46.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.188]                         if (muffled) 
[10:25:46.188]                           invokeRestart("muffleWarning")
[10:25:46.188]                       }
[10:25:46.188]                       else if (inherits(cond, "condition")) {
[10:25:46.188]                         if (!is.null(pattern)) {
[10:25:46.188]                           computeRestarts <- base::computeRestarts
[10:25:46.188]                           grepl <- base::grepl
[10:25:46.188]                           restarts <- computeRestarts(cond)
[10:25:46.188]                           for (restart in restarts) {
[10:25:46.188]                             name <- restart$name
[10:25:46.188]                             if (is.null(name)) 
[10:25:46.188]                               next
[10:25:46.188]                             if (!grepl(pattern, name)) 
[10:25:46.188]                               next
[10:25:46.188]                             invokeRestart(restart)
[10:25:46.188]                             muffled <- TRUE
[10:25:46.188]                             break
[10:25:46.188]                           }
[10:25:46.188]                         }
[10:25:46.188]                       }
[10:25:46.188]                       invisible(muffled)
[10:25:46.188]                     }
[10:25:46.188]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.188]                   }
[10:25:46.188]                 }
[10:25:46.188]             }
[10:25:46.188]         }))
[10:25:46.188]     }, error = function(ex) {
[10:25:46.188]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.188]                 ...future.rng), started = ...future.startTime, 
[10:25:46.188]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.188]             version = "1.8"), class = "FutureResult")
[10:25:46.188]     }, finally = {
[10:25:46.188]         if (!identical(...future.workdir, getwd())) 
[10:25:46.188]             setwd(...future.workdir)
[10:25:46.188]         {
[10:25:46.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.188]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.188]             }
[10:25:46.188]             base::options(...future.oldOptions)
[10:25:46.188]             if (.Platform$OS.type == "windows") {
[10:25:46.188]                 old_names <- names(...future.oldEnvVars)
[10:25:46.188]                 envs <- base::Sys.getenv()
[10:25:46.188]                 names <- names(envs)
[10:25:46.188]                 common <- intersect(names, old_names)
[10:25:46.188]                 added <- setdiff(names, old_names)
[10:25:46.188]                 removed <- setdiff(old_names, names)
[10:25:46.188]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.188]                   envs[common]]
[10:25:46.188]                 NAMES <- toupper(changed)
[10:25:46.188]                 args <- list()
[10:25:46.188]                 for (kk in seq_along(NAMES)) {
[10:25:46.188]                   name <- changed[[kk]]
[10:25:46.188]                   NAME <- NAMES[[kk]]
[10:25:46.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.188]                     next
[10:25:46.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.188]                 }
[10:25:46.188]                 NAMES <- toupper(added)
[10:25:46.188]                 for (kk in seq_along(NAMES)) {
[10:25:46.188]                   name <- added[[kk]]
[10:25:46.188]                   NAME <- NAMES[[kk]]
[10:25:46.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.188]                     next
[10:25:46.188]                   args[[name]] <- ""
[10:25:46.188]                 }
[10:25:46.188]                 NAMES <- toupper(removed)
[10:25:46.188]                 for (kk in seq_along(NAMES)) {
[10:25:46.188]                   name <- removed[[kk]]
[10:25:46.188]                   NAME <- NAMES[[kk]]
[10:25:46.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.188]                     next
[10:25:46.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.188]                 }
[10:25:46.188]                 if (length(args) > 0) 
[10:25:46.188]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.188]             }
[10:25:46.188]             else {
[10:25:46.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.188]             }
[10:25:46.188]             {
[10:25:46.188]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.188]                   0L) {
[10:25:46.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.188]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.188]                   base::options(opts)
[10:25:46.188]                 }
[10:25:46.188]                 {
[10:25:46.188]                   {
[10:25:46.188]                     NULL
[10:25:46.188]                     RNGkind("Mersenne-Twister")
[10:25:46.188]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.188]                       inherits = FALSE)
[10:25:46.188]                   }
[10:25:46.188]                   options(future.plan = NULL)
[10:25:46.188]                   if (is.na(NA_character_)) 
[10:25:46.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.188]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.188]                   {
[10:25:46.188]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.188]                     if (!future$lazy) 
[10:25:46.188]                       future <- run(future)
[10:25:46.188]                     invisible(future)
[10:25:46.188]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.188]                 }
[10:25:46.188]             }
[10:25:46.188]         }
[10:25:46.188]     })
[10:25:46.188]     if (TRUE) {
[10:25:46.188]         base::sink(type = "output", split = FALSE)
[10:25:46.188]         if (TRUE) {
[10:25:46.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.188]         }
[10:25:46.188]         else {
[10:25:46.188]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.188]         }
[10:25:46.188]         base::close(...future.stdout)
[10:25:46.188]         ...future.stdout <- NULL
[10:25:46.188]     }
[10:25:46.188]     ...future.result$conditions <- ...future.conditions
[10:25:46.188]     ...future.result$finished <- base::Sys.time()
[10:25:46.188]     ...future.result
[10:25:46.188] }
[10:25:46.190] plan(): Setting new future strategy stack:
[10:25:46.190] List of future strategies:
[10:25:46.190] 1. sequential:
[10:25:46.190]    - args: function (..., envir = parent.frame())
[10:25:46.190]    - tweaked: FALSE
[10:25:46.190]    - call: NULL
[10:25:46.190] plan(): nbrOfWorkers() = 1
[10:25:46.191] plan(): Setting new future strategy stack:
[10:25:46.191] List of future strategies:
[10:25:46.191] 1. sequential:
[10:25:46.191]    - args: function (..., envir = parent.frame())
[10:25:46.191]    - tweaked: FALSE
[10:25:46.191]    - call: plan(strategy)
[10:25:46.191] plan(): nbrOfWorkers() = 1
[10:25:46.191] SequentialFuture started (and completed)
[10:25:46.192] - Launch lazy future ... done
[10:25:46.192] run() for ‘SequentialFuture’ ... done
[10:25:46.192] getGlobalsAndPackages() ...
[10:25:46.192] Searching for globals...
[10:25:46.193] - globals found: [1] ‘{’
[10:25:46.193] Searching for globals ... DONE
[10:25:46.193] Resolving globals: FALSE
[10:25:46.193] 
[10:25:46.193] 
[10:25:46.193] getGlobalsAndPackages() ... DONE
[10:25:46.193] run() for ‘Future’ ...
[10:25:46.194] - state: ‘created’
[10:25:46.194] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.194] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.194] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.194]   - Field: ‘label’
[10:25:46.194]   - Field: ‘local’
[10:25:46.194]   - Field: ‘owner’
[10:25:46.194]   - Field: ‘envir’
[10:25:46.194]   - Field: ‘packages’
[10:25:46.195]   - Field: ‘gc’
[10:25:46.195]   - Field: ‘conditions’
[10:25:46.195]   - Field: ‘expr’
[10:25:46.195]   - Field: ‘uuid’
[10:25:46.195]   - Field: ‘seed’
[10:25:46.195]   - Field: ‘version’
[10:25:46.195]   - Field: ‘result’
[10:25:46.195]   - Field: ‘asynchronous’
[10:25:46.195]   - Field: ‘calls’
[10:25:46.195]   - Field: ‘globals’
[10:25:46.195]   - Field: ‘stdout’
[10:25:46.195]   - Field: ‘earlySignal’
[10:25:46.196]   - Field: ‘lazy’
[10:25:46.196]   - Field: ‘state’
[10:25:46.196] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.196] - Launch lazy future ...
[10:25:46.196] Packages needed by the future expression (n = 0): <none>
[10:25:46.196] Packages needed by future strategies (n = 0): <none>
[10:25:46.197] {
[10:25:46.197]     {
[10:25:46.197]         {
[10:25:46.197]             ...future.startTime <- base::Sys.time()
[10:25:46.197]             {
[10:25:46.197]                 {
[10:25:46.197]                   {
[10:25:46.197]                     base::local({
[10:25:46.197]                       has_future <- base::requireNamespace("future", 
[10:25:46.197]                         quietly = TRUE)
[10:25:46.197]                       if (has_future) {
[10:25:46.197]                         ns <- base::getNamespace("future")
[10:25:46.197]                         version <- ns[[".package"]][["version"]]
[10:25:46.197]                         if (is.null(version)) 
[10:25:46.197]                           version <- utils::packageVersion("future")
[10:25:46.197]                       }
[10:25:46.197]                       else {
[10:25:46.197]                         version <- NULL
[10:25:46.197]                       }
[10:25:46.197]                       if (!has_future || version < "1.8.0") {
[10:25:46.197]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.197]                           "", base::R.version$version.string), 
[10:25:46.197]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.197]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.197]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.197]                             "release", "version")], collapse = " "), 
[10:25:46.197]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.197]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.197]                           info)
[10:25:46.197]                         info <- base::paste(info, collapse = "; ")
[10:25:46.197]                         if (!has_future) {
[10:25:46.197]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.197]                             info)
[10:25:46.197]                         }
[10:25:46.197]                         else {
[10:25:46.197]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.197]                             info, version)
[10:25:46.197]                         }
[10:25:46.197]                         base::stop(msg)
[10:25:46.197]                       }
[10:25:46.197]                     })
[10:25:46.197]                   }
[10:25:46.197]                   options(future.plan = NULL)
[10:25:46.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.197]                 }
[10:25:46.197]                 ...future.workdir <- getwd()
[10:25:46.197]             }
[10:25:46.197]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.197]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.197]         }
[10:25:46.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.197]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.197]             base::names(...future.oldOptions))
[10:25:46.197]     }
[10:25:46.197]     if (FALSE) {
[10:25:46.197]     }
[10:25:46.197]     else {
[10:25:46.197]         if (TRUE) {
[10:25:46.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.197]                 open = "w")
[10:25:46.197]         }
[10:25:46.197]         else {
[10:25:46.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.197]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.197]         }
[10:25:46.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.197]             base::sink(type = "output", split = FALSE)
[10:25:46.197]             base::close(...future.stdout)
[10:25:46.197]         }, add = TRUE)
[10:25:46.197]     }
[10:25:46.197]     ...future.frame <- base::sys.nframe()
[10:25:46.197]     ...future.conditions <- base::list()
[10:25:46.197]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.197]     if (FALSE) {
[10:25:46.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.197]     }
[10:25:46.197]     ...future.result <- base::tryCatch({
[10:25:46.197]         base::withCallingHandlers({
[10:25:46.197]             ...future.value <- base::withVisible(base::local({
[10:25:46.197]                 4
[10:25:46.197]             }))
[10:25:46.197]             future::FutureResult(value = ...future.value$value, 
[10:25:46.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.197]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.197]                     ...future.globalenv.names))
[10:25:46.197]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.197]         }, condition = base::local({
[10:25:46.197]             c <- base::c
[10:25:46.197]             inherits <- base::inherits
[10:25:46.197]             invokeRestart <- base::invokeRestart
[10:25:46.197]             length <- base::length
[10:25:46.197]             list <- base::list
[10:25:46.197]             seq.int <- base::seq.int
[10:25:46.197]             signalCondition <- base::signalCondition
[10:25:46.197]             sys.calls <- base::sys.calls
[10:25:46.197]             `[[` <- base::`[[`
[10:25:46.197]             `+` <- base::`+`
[10:25:46.197]             `<<-` <- base::`<<-`
[10:25:46.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.197]                   3L)]
[10:25:46.197]             }
[10:25:46.197]             function(cond) {
[10:25:46.197]                 is_error <- inherits(cond, "error")
[10:25:46.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.197]                   NULL)
[10:25:46.197]                 if (is_error) {
[10:25:46.197]                   sessionInformation <- function() {
[10:25:46.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.197]                       search = base::search(), system = base::Sys.info())
[10:25:46.197]                   }
[10:25:46.197]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.197]                     cond$call), session = sessionInformation(), 
[10:25:46.197]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.197]                   signalCondition(cond)
[10:25:46.197]                 }
[10:25:46.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.197]                 "immediateCondition"))) {
[10:25:46.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.197]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.197]                   if (TRUE && !signal) {
[10:25:46.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.197]                     {
[10:25:46.197]                       inherits <- base::inherits
[10:25:46.197]                       invokeRestart <- base::invokeRestart
[10:25:46.197]                       is.null <- base::is.null
[10:25:46.197]                       muffled <- FALSE
[10:25:46.197]                       if (inherits(cond, "message")) {
[10:25:46.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.197]                         if (muffled) 
[10:25:46.197]                           invokeRestart("muffleMessage")
[10:25:46.197]                       }
[10:25:46.197]                       else if (inherits(cond, "warning")) {
[10:25:46.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.197]                         if (muffled) 
[10:25:46.197]                           invokeRestart("muffleWarning")
[10:25:46.197]                       }
[10:25:46.197]                       else if (inherits(cond, "condition")) {
[10:25:46.197]                         if (!is.null(pattern)) {
[10:25:46.197]                           computeRestarts <- base::computeRestarts
[10:25:46.197]                           grepl <- base::grepl
[10:25:46.197]                           restarts <- computeRestarts(cond)
[10:25:46.197]                           for (restart in restarts) {
[10:25:46.197]                             name <- restart$name
[10:25:46.197]                             if (is.null(name)) 
[10:25:46.197]                               next
[10:25:46.197]                             if (!grepl(pattern, name)) 
[10:25:46.197]                               next
[10:25:46.197]                             invokeRestart(restart)
[10:25:46.197]                             muffled <- TRUE
[10:25:46.197]                             break
[10:25:46.197]                           }
[10:25:46.197]                         }
[10:25:46.197]                       }
[10:25:46.197]                       invisible(muffled)
[10:25:46.197]                     }
[10:25:46.197]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.197]                   }
[10:25:46.197]                 }
[10:25:46.197]                 else {
[10:25:46.197]                   if (TRUE) {
[10:25:46.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.197]                     {
[10:25:46.197]                       inherits <- base::inherits
[10:25:46.197]                       invokeRestart <- base::invokeRestart
[10:25:46.197]                       is.null <- base::is.null
[10:25:46.197]                       muffled <- FALSE
[10:25:46.197]                       if (inherits(cond, "message")) {
[10:25:46.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.197]                         if (muffled) 
[10:25:46.197]                           invokeRestart("muffleMessage")
[10:25:46.197]                       }
[10:25:46.197]                       else if (inherits(cond, "warning")) {
[10:25:46.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.197]                         if (muffled) 
[10:25:46.197]                           invokeRestart("muffleWarning")
[10:25:46.197]                       }
[10:25:46.197]                       else if (inherits(cond, "condition")) {
[10:25:46.197]                         if (!is.null(pattern)) {
[10:25:46.197]                           computeRestarts <- base::computeRestarts
[10:25:46.197]                           grepl <- base::grepl
[10:25:46.197]                           restarts <- computeRestarts(cond)
[10:25:46.197]                           for (restart in restarts) {
[10:25:46.197]                             name <- restart$name
[10:25:46.197]                             if (is.null(name)) 
[10:25:46.197]                               next
[10:25:46.197]                             if (!grepl(pattern, name)) 
[10:25:46.197]                               next
[10:25:46.197]                             invokeRestart(restart)
[10:25:46.197]                             muffled <- TRUE
[10:25:46.197]                             break
[10:25:46.197]                           }
[10:25:46.197]                         }
[10:25:46.197]                       }
[10:25:46.197]                       invisible(muffled)
[10:25:46.197]                     }
[10:25:46.197]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.197]                   }
[10:25:46.197]                 }
[10:25:46.197]             }
[10:25:46.197]         }))
[10:25:46.197]     }, error = function(ex) {
[10:25:46.197]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.197]                 ...future.rng), started = ...future.startTime, 
[10:25:46.197]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.197]             version = "1.8"), class = "FutureResult")
[10:25:46.197]     }, finally = {
[10:25:46.197]         if (!identical(...future.workdir, getwd())) 
[10:25:46.197]             setwd(...future.workdir)
[10:25:46.197]         {
[10:25:46.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.197]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.197]             }
[10:25:46.197]             base::options(...future.oldOptions)
[10:25:46.197]             if (.Platform$OS.type == "windows") {
[10:25:46.197]                 old_names <- names(...future.oldEnvVars)
[10:25:46.197]                 envs <- base::Sys.getenv()
[10:25:46.197]                 names <- names(envs)
[10:25:46.197]                 common <- intersect(names, old_names)
[10:25:46.197]                 added <- setdiff(names, old_names)
[10:25:46.197]                 removed <- setdiff(old_names, names)
[10:25:46.197]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.197]                   envs[common]]
[10:25:46.197]                 NAMES <- toupper(changed)
[10:25:46.197]                 args <- list()
[10:25:46.197]                 for (kk in seq_along(NAMES)) {
[10:25:46.197]                   name <- changed[[kk]]
[10:25:46.197]                   NAME <- NAMES[[kk]]
[10:25:46.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.197]                     next
[10:25:46.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.197]                 }
[10:25:46.197]                 NAMES <- toupper(added)
[10:25:46.197]                 for (kk in seq_along(NAMES)) {
[10:25:46.197]                   name <- added[[kk]]
[10:25:46.197]                   NAME <- NAMES[[kk]]
[10:25:46.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.197]                     next
[10:25:46.197]                   args[[name]] <- ""
[10:25:46.197]                 }
[10:25:46.197]                 NAMES <- toupper(removed)
[10:25:46.197]                 for (kk in seq_along(NAMES)) {
[10:25:46.197]                   name <- removed[[kk]]
[10:25:46.197]                   NAME <- NAMES[[kk]]
[10:25:46.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.197]                     next
[10:25:46.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.197]                 }
[10:25:46.197]                 if (length(args) > 0) 
[10:25:46.197]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.197]             }
[10:25:46.197]             else {
[10:25:46.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.197]             }
[10:25:46.197]             {
[10:25:46.197]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.197]                   0L) {
[10:25:46.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.197]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.197]                   base::options(opts)
[10:25:46.197]                 }
[10:25:46.197]                 {
[10:25:46.197]                   {
[10:25:46.197]                     NULL
[10:25:46.197]                     RNGkind("Mersenne-Twister")
[10:25:46.197]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.197]                       inherits = FALSE)
[10:25:46.197]                   }
[10:25:46.197]                   options(future.plan = NULL)
[10:25:46.197]                   if (is.na(NA_character_)) 
[10:25:46.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.197]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.197]                   {
[10:25:46.197]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.197]                     if (!future$lazy) 
[10:25:46.197]                       future <- run(future)
[10:25:46.197]                     invisible(future)
[10:25:46.197]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.197]                 }
[10:25:46.197]             }
[10:25:46.197]         }
[10:25:46.197]     })
[10:25:46.197]     if (TRUE) {
[10:25:46.197]         base::sink(type = "output", split = FALSE)
[10:25:46.197]         if (TRUE) {
[10:25:46.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.197]         }
[10:25:46.197]         else {
[10:25:46.197]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.197]         }
[10:25:46.197]         base::close(...future.stdout)
[10:25:46.197]         ...future.stdout <- NULL
[10:25:46.197]     }
[10:25:46.197]     ...future.result$conditions <- ...future.conditions
[10:25:46.197]     ...future.result$finished <- base::Sys.time()
[10:25:46.197]     ...future.result
[10:25:46.197] }
[10:25:46.198] plan(): Setting new future strategy stack:
[10:25:46.198] List of future strategies:
[10:25:46.198] 1. sequential:
[10:25:46.198]    - args: function (..., envir = parent.frame())
[10:25:46.198]    - tweaked: FALSE
[10:25:46.198]    - call: NULL
[10:25:46.199] plan(): nbrOfWorkers() = 1
[10:25:46.199] plan(): Setting new future strategy stack:
[10:25:46.199] List of future strategies:
[10:25:46.199] 1. sequential:
[10:25:46.199]    - args: function (..., envir = parent.frame())
[10:25:46.199]    - tweaked: FALSE
[10:25:46.199]    - call: plan(strategy)
[10:25:46.200] plan(): nbrOfWorkers() = 1
[10:25:46.200] SequentialFuture started (and completed)
[10:25:46.200] - Launch lazy future ... done
[10:25:46.202] run() for ‘SequentialFuture’ ... done
<environment: 0x55c0f35cc630> 
<environment: 0x55c0f46507b0> 
[10:25:46.203] resolved() for ‘SequentialFuture’ ...
[10:25:46.203] - state: ‘finished’
[10:25:46.203] - run: TRUE
[10:25:46.203] - result: ‘FutureResult’
[10:25:46.203] resolved() for ‘SequentialFuture’ ... done
[10:25:46.203] resolved() for ‘SequentialFuture’ ...
[10:25:46.204] - state: ‘finished’
[10:25:46.204] - run: TRUE
[10:25:46.204] - result: ‘FutureResult’
[10:25:46.204] resolved() for ‘SequentialFuture’ ... done
[10:25:46.204] resolved() for ‘SequentialFuture’ ...
[10:25:46.204] - state: ‘finished’
[10:25:46.204] - run: TRUE
[10:25:46.204] - result: ‘FutureResult’
[10:25:46.204] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:46.205] resolve() on environment ...
[10:25:46.205]  recursive: 0
[10:25:46.206]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:46.206] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.206] - nx: 4
[10:25:46.206] - relay: TRUE
[10:25:46.206] - stdout: TRUE
[10:25:46.206] - signal: TRUE
[10:25:46.206] - resignal: FALSE
[10:25:46.207] - force: TRUE
[10:25:46.207] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.207] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.207]  - until=2
[10:25:46.207]  - relaying element #2
[10:25:46.207] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.207] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.207] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.207]  length: 3 (resolved future 1)
[10:25:46.207] resolved() for ‘SequentialFuture’ ...
[10:25:46.207] - state: ‘finished’
[10:25:46.207] - run: TRUE
[10:25:46.208] - result: ‘FutureResult’
[10:25:46.208] resolved() for ‘SequentialFuture’ ... done
[10:25:46.208] Future #2
[10:25:46.208] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.208] - nx: 4
[10:25:46.208] - relay: TRUE
[10:25:46.208] - stdout: TRUE
[10:25:46.208] - signal: TRUE
[10:25:46.208] - resignal: FALSE
[10:25:46.208] - force: TRUE
[10:25:46.209] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.209] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.209]  - until=2
[10:25:46.209]  - relaying element #2
[10:25:46.209] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.209] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.209] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.209]  length: 2 (resolved future 2)
[10:25:46.209] resolved() for ‘SequentialFuture’ ...
[10:25:46.209] - state: ‘finished’
[10:25:46.210] - run: TRUE
[10:25:46.210] - result: ‘FutureResult’
[10:25:46.210] resolved() for ‘SequentialFuture’ ... done
[10:25:46.210] Future #3
[10:25:46.210] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.210] - nx: 4
[10:25:46.210] - relay: TRUE
[10:25:46.210] - stdout: TRUE
[10:25:46.210] - signal: TRUE
[10:25:46.210] - resignal: FALSE
[10:25:46.210] - force: TRUE
[10:25:46.211] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.211] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.211]  - until=3
[10:25:46.211]  - relaying element #3
[10:25:46.211] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.211] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.211] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.211]  length: 1 (resolved future 3)
[10:25:46.211] resolved() for ‘SequentialFuture’ ...
[10:25:46.211] - state: ‘finished’
[10:25:46.211] - run: TRUE
[10:25:46.212] - result: ‘FutureResult’
[10:25:46.212] resolved() for ‘SequentialFuture’ ... done
[10:25:46.212] Future #4
[10:25:46.212] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.212] - nx: 4
[10:25:46.212] - relay: TRUE
[10:25:46.212] - stdout: TRUE
[10:25:46.212] - signal: TRUE
[10:25:46.212] - resignal: FALSE
[10:25:46.212] - force: TRUE
[10:25:46.212] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.212] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.213]  - until=4
[10:25:46.213]  - relaying element #4
[10:25:46.213] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.213] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.213] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.213]  length: 0 (resolved future 4)
[10:25:46.213] Relaying remaining futures
[10:25:46.213] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.213] - nx: 4
[10:25:46.213] - relay: TRUE
[10:25:46.214] - stdout: TRUE
[10:25:46.214] - signal: TRUE
[10:25:46.214] - resignal: FALSE
[10:25:46.214] - force: TRUE
[10:25:46.214] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.214] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:46.214] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.214] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.214] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.214] resolve() on environment ... DONE
<environment: 0x55c0f31e3498> 
Dimensions: c(2, 3, 1)
[10:25:46.215] getGlobalsAndPackages() ...
[10:25:46.215] Searching for globals...
[10:25:46.215] 
[10:25:46.215] Searching for globals ... DONE
[10:25:46.215] - globals: [0] <none>
[10:25:46.215] getGlobalsAndPackages() ... DONE
[10:25:46.216] run() for ‘Future’ ...
[10:25:46.216] - state: ‘created’
[10:25:46.216] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.216] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.216]   - Field: ‘label’
[10:25:46.216]   - Field: ‘local’
[10:25:46.216]   - Field: ‘owner’
[10:25:46.217]   - Field: ‘envir’
[10:25:46.217]   - Field: ‘packages’
[10:25:46.217]   - Field: ‘gc’
[10:25:46.217]   - Field: ‘conditions’
[10:25:46.217]   - Field: ‘expr’
[10:25:46.217]   - Field: ‘uuid’
[10:25:46.217]   - Field: ‘seed’
[10:25:46.217]   - Field: ‘version’
[10:25:46.217]   - Field: ‘result’
[10:25:46.217]   - Field: ‘asynchronous’
[10:25:46.217]   - Field: ‘calls’
[10:25:46.218]   - Field: ‘globals’
[10:25:46.218]   - Field: ‘stdout’
[10:25:46.218]   - Field: ‘earlySignal’
[10:25:46.218]   - Field: ‘lazy’
[10:25:46.218]   - Field: ‘state’
[10:25:46.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.218] - Launch lazy future ...
[10:25:46.218] Packages needed by the future expression (n = 0): <none>
[10:25:46.218] Packages needed by future strategies (n = 0): <none>
[10:25:46.219] {
[10:25:46.219]     {
[10:25:46.219]         {
[10:25:46.219]             ...future.startTime <- base::Sys.time()
[10:25:46.219]             {
[10:25:46.219]                 {
[10:25:46.219]                   {
[10:25:46.219]                     base::local({
[10:25:46.219]                       has_future <- base::requireNamespace("future", 
[10:25:46.219]                         quietly = TRUE)
[10:25:46.219]                       if (has_future) {
[10:25:46.219]                         ns <- base::getNamespace("future")
[10:25:46.219]                         version <- ns[[".package"]][["version"]]
[10:25:46.219]                         if (is.null(version)) 
[10:25:46.219]                           version <- utils::packageVersion("future")
[10:25:46.219]                       }
[10:25:46.219]                       else {
[10:25:46.219]                         version <- NULL
[10:25:46.219]                       }
[10:25:46.219]                       if (!has_future || version < "1.8.0") {
[10:25:46.219]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.219]                           "", base::R.version$version.string), 
[10:25:46.219]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.219]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.219]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.219]                             "release", "version")], collapse = " "), 
[10:25:46.219]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.219]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.219]                           info)
[10:25:46.219]                         info <- base::paste(info, collapse = "; ")
[10:25:46.219]                         if (!has_future) {
[10:25:46.219]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.219]                             info)
[10:25:46.219]                         }
[10:25:46.219]                         else {
[10:25:46.219]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.219]                             info, version)
[10:25:46.219]                         }
[10:25:46.219]                         base::stop(msg)
[10:25:46.219]                       }
[10:25:46.219]                     })
[10:25:46.219]                   }
[10:25:46.219]                   options(future.plan = NULL)
[10:25:46.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.219]                 }
[10:25:46.219]                 ...future.workdir <- getwd()
[10:25:46.219]             }
[10:25:46.219]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.219]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.219]         }
[10:25:46.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.219]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.219]             base::names(...future.oldOptions))
[10:25:46.219]     }
[10:25:46.219]     if (FALSE) {
[10:25:46.219]     }
[10:25:46.219]     else {
[10:25:46.219]         if (TRUE) {
[10:25:46.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.219]                 open = "w")
[10:25:46.219]         }
[10:25:46.219]         else {
[10:25:46.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.219]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.219]         }
[10:25:46.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.219]             base::sink(type = "output", split = FALSE)
[10:25:46.219]             base::close(...future.stdout)
[10:25:46.219]         }, add = TRUE)
[10:25:46.219]     }
[10:25:46.219]     ...future.frame <- base::sys.nframe()
[10:25:46.219]     ...future.conditions <- base::list()
[10:25:46.219]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.219]     if (FALSE) {
[10:25:46.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.219]     }
[10:25:46.219]     ...future.result <- base::tryCatch({
[10:25:46.219]         base::withCallingHandlers({
[10:25:46.219]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.219]             future::FutureResult(value = ...future.value$value, 
[10:25:46.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.219]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.219]                     ...future.globalenv.names))
[10:25:46.219]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.219]         }, condition = base::local({
[10:25:46.219]             c <- base::c
[10:25:46.219]             inherits <- base::inherits
[10:25:46.219]             invokeRestart <- base::invokeRestart
[10:25:46.219]             length <- base::length
[10:25:46.219]             list <- base::list
[10:25:46.219]             seq.int <- base::seq.int
[10:25:46.219]             signalCondition <- base::signalCondition
[10:25:46.219]             sys.calls <- base::sys.calls
[10:25:46.219]             `[[` <- base::`[[`
[10:25:46.219]             `+` <- base::`+`
[10:25:46.219]             `<<-` <- base::`<<-`
[10:25:46.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.219]                   3L)]
[10:25:46.219]             }
[10:25:46.219]             function(cond) {
[10:25:46.219]                 is_error <- inherits(cond, "error")
[10:25:46.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.219]                   NULL)
[10:25:46.219]                 if (is_error) {
[10:25:46.219]                   sessionInformation <- function() {
[10:25:46.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.219]                       search = base::search(), system = base::Sys.info())
[10:25:46.219]                   }
[10:25:46.219]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.219]                     cond$call), session = sessionInformation(), 
[10:25:46.219]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.219]                   signalCondition(cond)
[10:25:46.219]                 }
[10:25:46.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.219]                 "immediateCondition"))) {
[10:25:46.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.219]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.219]                   if (TRUE && !signal) {
[10:25:46.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.219]                     {
[10:25:46.219]                       inherits <- base::inherits
[10:25:46.219]                       invokeRestart <- base::invokeRestart
[10:25:46.219]                       is.null <- base::is.null
[10:25:46.219]                       muffled <- FALSE
[10:25:46.219]                       if (inherits(cond, "message")) {
[10:25:46.219]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.219]                         if (muffled) 
[10:25:46.219]                           invokeRestart("muffleMessage")
[10:25:46.219]                       }
[10:25:46.219]                       else if (inherits(cond, "warning")) {
[10:25:46.219]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.219]                         if (muffled) 
[10:25:46.219]                           invokeRestart("muffleWarning")
[10:25:46.219]                       }
[10:25:46.219]                       else if (inherits(cond, "condition")) {
[10:25:46.219]                         if (!is.null(pattern)) {
[10:25:46.219]                           computeRestarts <- base::computeRestarts
[10:25:46.219]                           grepl <- base::grepl
[10:25:46.219]                           restarts <- computeRestarts(cond)
[10:25:46.219]                           for (restart in restarts) {
[10:25:46.219]                             name <- restart$name
[10:25:46.219]                             if (is.null(name)) 
[10:25:46.219]                               next
[10:25:46.219]                             if (!grepl(pattern, name)) 
[10:25:46.219]                               next
[10:25:46.219]                             invokeRestart(restart)
[10:25:46.219]                             muffled <- TRUE
[10:25:46.219]                             break
[10:25:46.219]                           }
[10:25:46.219]                         }
[10:25:46.219]                       }
[10:25:46.219]                       invisible(muffled)
[10:25:46.219]                     }
[10:25:46.219]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.219]                   }
[10:25:46.219]                 }
[10:25:46.219]                 else {
[10:25:46.219]                   if (TRUE) {
[10:25:46.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.219]                     {
[10:25:46.219]                       inherits <- base::inherits
[10:25:46.219]                       invokeRestart <- base::invokeRestart
[10:25:46.219]                       is.null <- base::is.null
[10:25:46.219]                       muffled <- FALSE
[10:25:46.219]                       if (inherits(cond, "message")) {
[10:25:46.219]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.219]                         if (muffled) 
[10:25:46.219]                           invokeRestart("muffleMessage")
[10:25:46.219]                       }
[10:25:46.219]                       else if (inherits(cond, "warning")) {
[10:25:46.219]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.219]                         if (muffled) 
[10:25:46.219]                           invokeRestart("muffleWarning")
[10:25:46.219]                       }
[10:25:46.219]                       else if (inherits(cond, "condition")) {
[10:25:46.219]                         if (!is.null(pattern)) {
[10:25:46.219]                           computeRestarts <- base::computeRestarts
[10:25:46.219]                           grepl <- base::grepl
[10:25:46.219]                           restarts <- computeRestarts(cond)
[10:25:46.219]                           for (restart in restarts) {
[10:25:46.219]                             name <- restart$name
[10:25:46.219]                             if (is.null(name)) 
[10:25:46.219]                               next
[10:25:46.219]                             if (!grepl(pattern, name)) 
[10:25:46.219]                               next
[10:25:46.219]                             invokeRestart(restart)
[10:25:46.219]                             muffled <- TRUE
[10:25:46.219]                             break
[10:25:46.219]                           }
[10:25:46.219]                         }
[10:25:46.219]                       }
[10:25:46.219]                       invisible(muffled)
[10:25:46.219]                     }
[10:25:46.219]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.219]                   }
[10:25:46.219]                 }
[10:25:46.219]             }
[10:25:46.219]         }))
[10:25:46.219]     }, error = function(ex) {
[10:25:46.219]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.219]                 ...future.rng), started = ...future.startTime, 
[10:25:46.219]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.219]             version = "1.8"), class = "FutureResult")
[10:25:46.219]     }, finally = {
[10:25:46.219]         if (!identical(...future.workdir, getwd())) 
[10:25:46.219]             setwd(...future.workdir)
[10:25:46.219]         {
[10:25:46.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.219]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.219]             }
[10:25:46.219]             base::options(...future.oldOptions)
[10:25:46.219]             if (.Platform$OS.type == "windows") {
[10:25:46.219]                 old_names <- names(...future.oldEnvVars)
[10:25:46.219]                 envs <- base::Sys.getenv()
[10:25:46.219]                 names <- names(envs)
[10:25:46.219]                 common <- intersect(names, old_names)
[10:25:46.219]                 added <- setdiff(names, old_names)
[10:25:46.219]                 removed <- setdiff(old_names, names)
[10:25:46.219]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.219]                   envs[common]]
[10:25:46.219]                 NAMES <- toupper(changed)
[10:25:46.219]                 args <- list()
[10:25:46.219]                 for (kk in seq_along(NAMES)) {
[10:25:46.219]                   name <- changed[[kk]]
[10:25:46.219]                   NAME <- NAMES[[kk]]
[10:25:46.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.219]                     next
[10:25:46.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.219]                 }
[10:25:46.219]                 NAMES <- toupper(added)
[10:25:46.219]                 for (kk in seq_along(NAMES)) {
[10:25:46.219]                   name <- added[[kk]]
[10:25:46.219]                   NAME <- NAMES[[kk]]
[10:25:46.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.219]                     next
[10:25:46.219]                   args[[name]] <- ""
[10:25:46.219]                 }
[10:25:46.219]                 NAMES <- toupper(removed)
[10:25:46.219]                 for (kk in seq_along(NAMES)) {
[10:25:46.219]                   name <- removed[[kk]]
[10:25:46.219]                   NAME <- NAMES[[kk]]
[10:25:46.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.219]                     next
[10:25:46.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.219]                 }
[10:25:46.219]                 if (length(args) > 0) 
[10:25:46.219]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.219]             }
[10:25:46.219]             else {
[10:25:46.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.219]             }
[10:25:46.219]             {
[10:25:46.219]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.219]                   0L) {
[10:25:46.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.219]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.219]                   base::options(opts)
[10:25:46.219]                 }
[10:25:46.219]                 {
[10:25:46.219]                   {
[10:25:46.219]                     NULL
[10:25:46.219]                     RNGkind("Mersenne-Twister")
[10:25:46.219]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.219]                       inherits = FALSE)
[10:25:46.219]                   }
[10:25:46.219]                   options(future.plan = NULL)
[10:25:46.219]                   if (is.na(NA_character_)) 
[10:25:46.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.219]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.219]                   {
[10:25:46.219]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.219]                     if (!future$lazy) 
[10:25:46.219]                       future <- run(future)
[10:25:46.219]                     invisible(future)
[10:25:46.219]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.219]                 }
[10:25:46.219]             }
[10:25:46.219]         }
[10:25:46.219]     })
[10:25:46.219]     if (TRUE) {
[10:25:46.219]         base::sink(type = "output", split = FALSE)
[10:25:46.219]         if (TRUE) {
[10:25:46.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.219]         }
[10:25:46.219]         else {
[10:25:46.219]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.219]         }
[10:25:46.219]         base::close(...future.stdout)
[10:25:46.219]         ...future.stdout <- NULL
[10:25:46.219]     }
[10:25:46.219]     ...future.result$conditions <- ...future.conditions
[10:25:46.219]     ...future.result$finished <- base::Sys.time()
[10:25:46.219]     ...future.result
[10:25:46.219] }
[10:25:46.220] plan(): Setting new future strategy stack:
[10:25:46.221] List of future strategies:
[10:25:46.221] 1. sequential:
[10:25:46.221]    - args: function (..., envir = parent.frame())
[10:25:46.221]    - tweaked: FALSE
[10:25:46.221]    - call: NULL
[10:25:46.221] plan(): nbrOfWorkers() = 1
[10:25:46.222] plan(): Setting new future strategy stack:
[10:25:46.222] List of future strategies:
[10:25:46.222] 1. sequential:
[10:25:46.222]    - args: function (..., envir = parent.frame())
[10:25:46.222]    - tweaked: FALSE
[10:25:46.222]    - call: plan(strategy)
[10:25:46.222] plan(): nbrOfWorkers() = 1
[10:25:46.222] SequentialFuture started (and completed)
[10:25:46.222] - Launch lazy future ... done
[10:25:46.222] run() for ‘SequentialFuture’ ... done
[10:25:46.222] getGlobalsAndPackages() ...
[10:25:46.223] Searching for globals...
[10:25:46.223] 
[10:25:46.223] Searching for globals ... DONE
[10:25:46.223] - globals: [0] <none>
[10:25:46.223] getGlobalsAndPackages() ... DONE
[10:25:46.223] run() for ‘Future’ ...
[10:25:46.223] - state: ‘created’
[10:25:46.223] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.224] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.224]   - Field: ‘label’
[10:25:46.224]   - Field: ‘local’
[10:25:46.224]   - Field: ‘owner’
[10:25:46.224]   - Field: ‘envir’
[10:25:46.224]   - Field: ‘packages’
[10:25:46.224]   - Field: ‘gc’
[10:25:46.224]   - Field: ‘conditions’
[10:25:46.224]   - Field: ‘expr’
[10:25:46.225]   - Field: ‘uuid’
[10:25:46.225]   - Field: ‘seed’
[10:25:46.225]   - Field: ‘version’
[10:25:46.226]   - Field: ‘result’
[10:25:46.226]   - Field: ‘asynchronous’
[10:25:46.226]   - Field: ‘calls’
[10:25:46.226]   - Field: ‘globals’
[10:25:46.227]   - Field: ‘stdout’
[10:25:46.227]   - Field: ‘earlySignal’
[10:25:46.227]   - Field: ‘lazy’
[10:25:46.227]   - Field: ‘state’
[10:25:46.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.227] - Launch lazy future ...
[10:25:46.227] Packages needed by the future expression (n = 0): <none>
[10:25:46.227] Packages needed by future strategies (n = 0): <none>
[10:25:46.228] {
[10:25:46.228]     {
[10:25:46.228]         {
[10:25:46.228]             ...future.startTime <- base::Sys.time()
[10:25:46.228]             {
[10:25:46.228]                 {
[10:25:46.228]                   {
[10:25:46.228]                     base::local({
[10:25:46.228]                       has_future <- base::requireNamespace("future", 
[10:25:46.228]                         quietly = TRUE)
[10:25:46.228]                       if (has_future) {
[10:25:46.228]                         ns <- base::getNamespace("future")
[10:25:46.228]                         version <- ns[[".package"]][["version"]]
[10:25:46.228]                         if (is.null(version)) 
[10:25:46.228]                           version <- utils::packageVersion("future")
[10:25:46.228]                       }
[10:25:46.228]                       else {
[10:25:46.228]                         version <- NULL
[10:25:46.228]                       }
[10:25:46.228]                       if (!has_future || version < "1.8.0") {
[10:25:46.228]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.228]                           "", base::R.version$version.string), 
[10:25:46.228]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.228]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.228]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.228]                             "release", "version")], collapse = " "), 
[10:25:46.228]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.228]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.228]                           info)
[10:25:46.228]                         info <- base::paste(info, collapse = "; ")
[10:25:46.228]                         if (!has_future) {
[10:25:46.228]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.228]                             info)
[10:25:46.228]                         }
[10:25:46.228]                         else {
[10:25:46.228]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.228]                             info, version)
[10:25:46.228]                         }
[10:25:46.228]                         base::stop(msg)
[10:25:46.228]                       }
[10:25:46.228]                     })
[10:25:46.228]                   }
[10:25:46.228]                   options(future.plan = NULL)
[10:25:46.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.228]                 }
[10:25:46.228]                 ...future.workdir <- getwd()
[10:25:46.228]             }
[10:25:46.228]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.228]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.228]         }
[10:25:46.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.228]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.228]             base::names(...future.oldOptions))
[10:25:46.228]     }
[10:25:46.228]     if (FALSE) {
[10:25:46.228]     }
[10:25:46.228]     else {
[10:25:46.228]         if (TRUE) {
[10:25:46.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.228]                 open = "w")
[10:25:46.228]         }
[10:25:46.228]         else {
[10:25:46.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.228]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.228]         }
[10:25:46.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.228]             base::sink(type = "output", split = FALSE)
[10:25:46.228]             base::close(...future.stdout)
[10:25:46.228]         }, add = TRUE)
[10:25:46.228]     }
[10:25:46.228]     ...future.frame <- base::sys.nframe()
[10:25:46.228]     ...future.conditions <- base::list()
[10:25:46.228]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.228]     if (FALSE) {
[10:25:46.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.228]     }
[10:25:46.228]     ...future.result <- base::tryCatch({
[10:25:46.228]         base::withCallingHandlers({
[10:25:46.228]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.228]             future::FutureResult(value = ...future.value$value, 
[10:25:46.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.228]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.228]                     ...future.globalenv.names))
[10:25:46.228]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.228]         }, condition = base::local({
[10:25:46.228]             c <- base::c
[10:25:46.228]             inherits <- base::inherits
[10:25:46.228]             invokeRestart <- base::invokeRestart
[10:25:46.228]             length <- base::length
[10:25:46.228]             list <- base::list
[10:25:46.228]             seq.int <- base::seq.int
[10:25:46.228]             signalCondition <- base::signalCondition
[10:25:46.228]             sys.calls <- base::sys.calls
[10:25:46.228]             `[[` <- base::`[[`
[10:25:46.228]             `+` <- base::`+`
[10:25:46.228]             `<<-` <- base::`<<-`
[10:25:46.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.228]                   3L)]
[10:25:46.228]             }
[10:25:46.228]             function(cond) {
[10:25:46.228]                 is_error <- inherits(cond, "error")
[10:25:46.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.228]                   NULL)
[10:25:46.228]                 if (is_error) {
[10:25:46.228]                   sessionInformation <- function() {
[10:25:46.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.228]                       search = base::search(), system = base::Sys.info())
[10:25:46.228]                   }
[10:25:46.228]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.228]                     cond$call), session = sessionInformation(), 
[10:25:46.228]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.228]                   signalCondition(cond)
[10:25:46.228]                 }
[10:25:46.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.228]                 "immediateCondition"))) {
[10:25:46.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.228]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.228]                   if (TRUE && !signal) {
[10:25:46.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.228]                     {
[10:25:46.228]                       inherits <- base::inherits
[10:25:46.228]                       invokeRestart <- base::invokeRestart
[10:25:46.228]                       is.null <- base::is.null
[10:25:46.228]                       muffled <- FALSE
[10:25:46.228]                       if (inherits(cond, "message")) {
[10:25:46.228]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.228]                         if (muffled) 
[10:25:46.228]                           invokeRestart("muffleMessage")
[10:25:46.228]                       }
[10:25:46.228]                       else if (inherits(cond, "warning")) {
[10:25:46.228]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.228]                         if (muffled) 
[10:25:46.228]                           invokeRestart("muffleWarning")
[10:25:46.228]                       }
[10:25:46.228]                       else if (inherits(cond, "condition")) {
[10:25:46.228]                         if (!is.null(pattern)) {
[10:25:46.228]                           computeRestarts <- base::computeRestarts
[10:25:46.228]                           grepl <- base::grepl
[10:25:46.228]                           restarts <- computeRestarts(cond)
[10:25:46.228]                           for (restart in restarts) {
[10:25:46.228]                             name <- restart$name
[10:25:46.228]                             if (is.null(name)) 
[10:25:46.228]                               next
[10:25:46.228]                             if (!grepl(pattern, name)) 
[10:25:46.228]                               next
[10:25:46.228]                             invokeRestart(restart)
[10:25:46.228]                             muffled <- TRUE
[10:25:46.228]                             break
[10:25:46.228]                           }
[10:25:46.228]                         }
[10:25:46.228]                       }
[10:25:46.228]                       invisible(muffled)
[10:25:46.228]                     }
[10:25:46.228]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.228]                   }
[10:25:46.228]                 }
[10:25:46.228]                 else {
[10:25:46.228]                   if (TRUE) {
[10:25:46.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.228]                     {
[10:25:46.228]                       inherits <- base::inherits
[10:25:46.228]                       invokeRestart <- base::invokeRestart
[10:25:46.228]                       is.null <- base::is.null
[10:25:46.228]                       muffled <- FALSE
[10:25:46.228]                       if (inherits(cond, "message")) {
[10:25:46.228]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.228]                         if (muffled) 
[10:25:46.228]                           invokeRestart("muffleMessage")
[10:25:46.228]                       }
[10:25:46.228]                       else if (inherits(cond, "warning")) {
[10:25:46.228]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.228]                         if (muffled) 
[10:25:46.228]                           invokeRestart("muffleWarning")
[10:25:46.228]                       }
[10:25:46.228]                       else if (inherits(cond, "condition")) {
[10:25:46.228]                         if (!is.null(pattern)) {
[10:25:46.228]                           computeRestarts <- base::computeRestarts
[10:25:46.228]                           grepl <- base::grepl
[10:25:46.228]                           restarts <- computeRestarts(cond)
[10:25:46.228]                           for (restart in restarts) {
[10:25:46.228]                             name <- restart$name
[10:25:46.228]                             if (is.null(name)) 
[10:25:46.228]                               next
[10:25:46.228]                             if (!grepl(pattern, name)) 
[10:25:46.228]                               next
[10:25:46.228]                             invokeRestart(restart)
[10:25:46.228]                             muffled <- TRUE
[10:25:46.228]                             break
[10:25:46.228]                           }
[10:25:46.228]                         }
[10:25:46.228]                       }
[10:25:46.228]                       invisible(muffled)
[10:25:46.228]                     }
[10:25:46.228]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.228]                   }
[10:25:46.228]                 }
[10:25:46.228]             }
[10:25:46.228]         }))
[10:25:46.228]     }, error = function(ex) {
[10:25:46.228]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.228]                 ...future.rng), started = ...future.startTime, 
[10:25:46.228]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.228]             version = "1.8"), class = "FutureResult")
[10:25:46.228]     }, finally = {
[10:25:46.228]         if (!identical(...future.workdir, getwd())) 
[10:25:46.228]             setwd(...future.workdir)
[10:25:46.228]         {
[10:25:46.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.228]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.228]             }
[10:25:46.228]             base::options(...future.oldOptions)
[10:25:46.228]             if (.Platform$OS.type == "windows") {
[10:25:46.228]                 old_names <- names(...future.oldEnvVars)
[10:25:46.228]                 envs <- base::Sys.getenv()
[10:25:46.228]                 names <- names(envs)
[10:25:46.228]                 common <- intersect(names, old_names)
[10:25:46.228]                 added <- setdiff(names, old_names)
[10:25:46.228]                 removed <- setdiff(old_names, names)
[10:25:46.228]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.228]                   envs[common]]
[10:25:46.228]                 NAMES <- toupper(changed)
[10:25:46.228]                 args <- list()
[10:25:46.228]                 for (kk in seq_along(NAMES)) {
[10:25:46.228]                   name <- changed[[kk]]
[10:25:46.228]                   NAME <- NAMES[[kk]]
[10:25:46.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.228]                     next
[10:25:46.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.228]                 }
[10:25:46.228]                 NAMES <- toupper(added)
[10:25:46.228]                 for (kk in seq_along(NAMES)) {
[10:25:46.228]                   name <- added[[kk]]
[10:25:46.228]                   NAME <- NAMES[[kk]]
[10:25:46.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.228]                     next
[10:25:46.228]                   args[[name]] <- ""
[10:25:46.228]                 }
[10:25:46.228]                 NAMES <- toupper(removed)
[10:25:46.228]                 for (kk in seq_along(NAMES)) {
[10:25:46.228]                   name <- removed[[kk]]
[10:25:46.228]                   NAME <- NAMES[[kk]]
[10:25:46.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.228]                     next
[10:25:46.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.228]                 }
[10:25:46.228]                 if (length(args) > 0) 
[10:25:46.228]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.228]             }
[10:25:46.228]             else {
[10:25:46.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.228]             }
[10:25:46.228]             {
[10:25:46.228]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.228]                   0L) {
[10:25:46.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.228]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.228]                   base::options(opts)
[10:25:46.228]                 }
[10:25:46.228]                 {
[10:25:46.228]                   {
[10:25:46.228]                     NULL
[10:25:46.228]                     RNGkind("Mersenne-Twister")
[10:25:46.228]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.228]                       inherits = FALSE)
[10:25:46.228]                   }
[10:25:46.228]                   options(future.plan = NULL)
[10:25:46.228]                   if (is.na(NA_character_)) 
[10:25:46.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.228]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.228]                   {
[10:25:46.228]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.228]                     if (!future$lazy) 
[10:25:46.228]                       future <- run(future)
[10:25:46.228]                     invisible(future)
[10:25:46.228]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.228]                 }
[10:25:46.228]             }
[10:25:46.228]         }
[10:25:46.228]     })
[10:25:46.228]     if (TRUE) {
[10:25:46.228]         base::sink(type = "output", split = FALSE)
[10:25:46.228]         if (TRUE) {
[10:25:46.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.228]         }
[10:25:46.228]         else {
[10:25:46.228]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.228]         }
[10:25:46.228]         base::close(...future.stdout)
[10:25:46.228]         ...future.stdout <- NULL
[10:25:46.228]     }
[10:25:46.228]     ...future.result$conditions <- ...future.conditions
[10:25:46.228]     ...future.result$finished <- base::Sys.time()
[10:25:46.228]     ...future.result
[10:25:46.228] }
[10:25:46.229] plan(): Setting new future strategy stack:
[10:25:46.230] List of future strategies:
[10:25:46.230] 1. sequential:
[10:25:46.230]    - args: function (..., envir = parent.frame())
[10:25:46.230]    - tweaked: FALSE
[10:25:46.230]    - call: NULL
[10:25:46.230] plan(): nbrOfWorkers() = 1
[10:25:46.231] plan(): Setting new future strategy stack:
[10:25:46.231] List of future strategies:
[10:25:46.231] 1. sequential:
[10:25:46.231]    - args: function (..., envir = parent.frame())
[10:25:46.231]    - tweaked: FALSE
[10:25:46.231]    - call: plan(strategy)
[10:25:46.231] plan(): nbrOfWorkers() = 1
[10:25:46.231] SequentialFuture started (and completed)
[10:25:46.231] - Launch lazy future ... done
[10:25:46.231] run() for ‘SequentialFuture’ ... done
[10:25:46.232] getGlobalsAndPackages() ...
[10:25:46.232] Searching for globals...
[10:25:46.232] - globals found: [1] ‘{’
[10:25:46.232] Searching for globals ... DONE
[10:25:46.232] Resolving globals: FALSE
[10:25:46.233] 
[10:25:46.233] 
[10:25:46.233] getGlobalsAndPackages() ... DONE
[10:25:46.233] run() for ‘Future’ ...
[10:25:46.233] - state: ‘created’
[10:25:46.233] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.234] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.234]   - Field: ‘label’
[10:25:46.234]   - Field: ‘local’
[10:25:46.234]   - Field: ‘owner’
[10:25:46.234]   - Field: ‘envir’
[10:25:46.234]   - Field: ‘packages’
[10:25:46.234]   - Field: ‘gc’
[10:25:46.234]   - Field: ‘conditions’
[10:25:46.234]   - Field: ‘expr’
[10:25:46.234]   - Field: ‘uuid’
[10:25:46.235]   - Field: ‘seed’
[10:25:46.235]   - Field: ‘version’
[10:25:46.235]   - Field: ‘result’
[10:25:46.235]   - Field: ‘asynchronous’
[10:25:46.235]   - Field: ‘calls’
[10:25:46.235]   - Field: ‘globals’
[10:25:46.235]   - Field: ‘stdout’
[10:25:46.235]   - Field: ‘earlySignal’
[10:25:46.235]   - Field: ‘lazy’
[10:25:46.235]   - Field: ‘state’
[10:25:46.235] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.235] - Launch lazy future ...
[10:25:46.236] Packages needed by the future expression (n = 0): <none>
[10:25:46.236] Packages needed by future strategies (n = 0): <none>
[10:25:46.236] {
[10:25:46.236]     {
[10:25:46.236]         {
[10:25:46.236]             ...future.startTime <- base::Sys.time()
[10:25:46.236]             {
[10:25:46.236]                 {
[10:25:46.236]                   {
[10:25:46.236]                     base::local({
[10:25:46.236]                       has_future <- base::requireNamespace("future", 
[10:25:46.236]                         quietly = TRUE)
[10:25:46.236]                       if (has_future) {
[10:25:46.236]                         ns <- base::getNamespace("future")
[10:25:46.236]                         version <- ns[[".package"]][["version"]]
[10:25:46.236]                         if (is.null(version)) 
[10:25:46.236]                           version <- utils::packageVersion("future")
[10:25:46.236]                       }
[10:25:46.236]                       else {
[10:25:46.236]                         version <- NULL
[10:25:46.236]                       }
[10:25:46.236]                       if (!has_future || version < "1.8.0") {
[10:25:46.236]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.236]                           "", base::R.version$version.string), 
[10:25:46.236]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.236]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.236]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.236]                             "release", "version")], collapse = " "), 
[10:25:46.236]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.236]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.236]                           info)
[10:25:46.236]                         info <- base::paste(info, collapse = "; ")
[10:25:46.236]                         if (!has_future) {
[10:25:46.236]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.236]                             info)
[10:25:46.236]                         }
[10:25:46.236]                         else {
[10:25:46.236]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.236]                             info, version)
[10:25:46.236]                         }
[10:25:46.236]                         base::stop(msg)
[10:25:46.236]                       }
[10:25:46.236]                     })
[10:25:46.236]                   }
[10:25:46.236]                   options(future.plan = NULL)
[10:25:46.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.236]                 }
[10:25:46.236]                 ...future.workdir <- getwd()
[10:25:46.236]             }
[10:25:46.236]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.236]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.236]         }
[10:25:46.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.236]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.236]             base::names(...future.oldOptions))
[10:25:46.236]     }
[10:25:46.236]     if (FALSE) {
[10:25:46.236]     }
[10:25:46.236]     else {
[10:25:46.236]         if (TRUE) {
[10:25:46.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.236]                 open = "w")
[10:25:46.236]         }
[10:25:46.236]         else {
[10:25:46.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.236]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.236]         }
[10:25:46.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.236]             base::sink(type = "output", split = FALSE)
[10:25:46.236]             base::close(...future.stdout)
[10:25:46.236]         }, add = TRUE)
[10:25:46.236]     }
[10:25:46.236]     ...future.frame <- base::sys.nframe()
[10:25:46.236]     ...future.conditions <- base::list()
[10:25:46.236]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.236]     if (FALSE) {
[10:25:46.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.236]     }
[10:25:46.236]     ...future.result <- base::tryCatch({
[10:25:46.236]         base::withCallingHandlers({
[10:25:46.236]             ...future.value <- base::withVisible(base::local({
[10:25:46.236]                 4
[10:25:46.236]             }))
[10:25:46.236]             future::FutureResult(value = ...future.value$value, 
[10:25:46.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.236]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.236]                     ...future.globalenv.names))
[10:25:46.236]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.236]         }, condition = base::local({
[10:25:46.236]             c <- base::c
[10:25:46.236]             inherits <- base::inherits
[10:25:46.236]             invokeRestart <- base::invokeRestart
[10:25:46.236]             length <- base::length
[10:25:46.236]             list <- base::list
[10:25:46.236]             seq.int <- base::seq.int
[10:25:46.236]             signalCondition <- base::signalCondition
[10:25:46.236]             sys.calls <- base::sys.calls
[10:25:46.236]             `[[` <- base::`[[`
[10:25:46.236]             `+` <- base::`+`
[10:25:46.236]             `<<-` <- base::`<<-`
[10:25:46.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.236]                   3L)]
[10:25:46.236]             }
[10:25:46.236]             function(cond) {
[10:25:46.236]                 is_error <- inherits(cond, "error")
[10:25:46.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.236]                   NULL)
[10:25:46.236]                 if (is_error) {
[10:25:46.236]                   sessionInformation <- function() {
[10:25:46.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.236]                       search = base::search(), system = base::Sys.info())
[10:25:46.236]                   }
[10:25:46.236]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.236]                     cond$call), session = sessionInformation(), 
[10:25:46.236]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.236]                   signalCondition(cond)
[10:25:46.236]                 }
[10:25:46.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.236]                 "immediateCondition"))) {
[10:25:46.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.236]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.236]                   if (TRUE && !signal) {
[10:25:46.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.236]                     {
[10:25:46.236]                       inherits <- base::inherits
[10:25:46.236]                       invokeRestart <- base::invokeRestart
[10:25:46.236]                       is.null <- base::is.null
[10:25:46.236]                       muffled <- FALSE
[10:25:46.236]                       if (inherits(cond, "message")) {
[10:25:46.236]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.236]                         if (muffled) 
[10:25:46.236]                           invokeRestart("muffleMessage")
[10:25:46.236]                       }
[10:25:46.236]                       else if (inherits(cond, "warning")) {
[10:25:46.236]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.236]                         if (muffled) 
[10:25:46.236]                           invokeRestart("muffleWarning")
[10:25:46.236]                       }
[10:25:46.236]                       else if (inherits(cond, "condition")) {
[10:25:46.236]                         if (!is.null(pattern)) {
[10:25:46.236]                           computeRestarts <- base::computeRestarts
[10:25:46.236]                           grepl <- base::grepl
[10:25:46.236]                           restarts <- computeRestarts(cond)
[10:25:46.236]                           for (restart in restarts) {
[10:25:46.236]                             name <- restart$name
[10:25:46.236]                             if (is.null(name)) 
[10:25:46.236]                               next
[10:25:46.236]                             if (!grepl(pattern, name)) 
[10:25:46.236]                               next
[10:25:46.236]                             invokeRestart(restart)
[10:25:46.236]                             muffled <- TRUE
[10:25:46.236]                             break
[10:25:46.236]                           }
[10:25:46.236]                         }
[10:25:46.236]                       }
[10:25:46.236]                       invisible(muffled)
[10:25:46.236]                     }
[10:25:46.236]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.236]                   }
[10:25:46.236]                 }
[10:25:46.236]                 else {
[10:25:46.236]                   if (TRUE) {
[10:25:46.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.236]                     {
[10:25:46.236]                       inherits <- base::inherits
[10:25:46.236]                       invokeRestart <- base::invokeRestart
[10:25:46.236]                       is.null <- base::is.null
[10:25:46.236]                       muffled <- FALSE
[10:25:46.236]                       if (inherits(cond, "message")) {
[10:25:46.236]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.236]                         if (muffled) 
[10:25:46.236]                           invokeRestart("muffleMessage")
[10:25:46.236]                       }
[10:25:46.236]                       else if (inherits(cond, "warning")) {
[10:25:46.236]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.236]                         if (muffled) 
[10:25:46.236]                           invokeRestart("muffleWarning")
[10:25:46.236]                       }
[10:25:46.236]                       else if (inherits(cond, "condition")) {
[10:25:46.236]                         if (!is.null(pattern)) {
[10:25:46.236]                           computeRestarts <- base::computeRestarts
[10:25:46.236]                           grepl <- base::grepl
[10:25:46.236]                           restarts <- computeRestarts(cond)
[10:25:46.236]                           for (restart in restarts) {
[10:25:46.236]                             name <- restart$name
[10:25:46.236]                             if (is.null(name)) 
[10:25:46.236]                               next
[10:25:46.236]                             if (!grepl(pattern, name)) 
[10:25:46.236]                               next
[10:25:46.236]                             invokeRestart(restart)
[10:25:46.236]                             muffled <- TRUE
[10:25:46.236]                             break
[10:25:46.236]                           }
[10:25:46.236]                         }
[10:25:46.236]                       }
[10:25:46.236]                       invisible(muffled)
[10:25:46.236]                     }
[10:25:46.236]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.236]                   }
[10:25:46.236]                 }
[10:25:46.236]             }
[10:25:46.236]         }))
[10:25:46.236]     }, error = function(ex) {
[10:25:46.236]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.236]                 ...future.rng), started = ...future.startTime, 
[10:25:46.236]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.236]             version = "1.8"), class = "FutureResult")
[10:25:46.236]     }, finally = {
[10:25:46.236]         if (!identical(...future.workdir, getwd())) 
[10:25:46.236]             setwd(...future.workdir)
[10:25:46.236]         {
[10:25:46.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.236]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.236]             }
[10:25:46.236]             base::options(...future.oldOptions)
[10:25:46.236]             if (.Platform$OS.type == "windows") {
[10:25:46.236]                 old_names <- names(...future.oldEnvVars)
[10:25:46.236]                 envs <- base::Sys.getenv()
[10:25:46.236]                 names <- names(envs)
[10:25:46.236]                 common <- intersect(names, old_names)
[10:25:46.236]                 added <- setdiff(names, old_names)
[10:25:46.236]                 removed <- setdiff(old_names, names)
[10:25:46.236]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.236]                   envs[common]]
[10:25:46.236]                 NAMES <- toupper(changed)
[10:25:46.236]                 args <- list()
[10:25:46.236]                 for (kk in seq_along(NAMES)) {
[10:25:46.236]                   name <- changed[[kk]]
[10:25:46.236]                   NAME <- NAMES[[kk]]
[10:25:46.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.236]                     next
[10:25:46.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.236]                 }
[10:25:46.236]                 NAMES <- toupper(added)
[10:25:46.236]                 for (kk in seq_along(NAMES)) {
[10:25:46.236]                   name <- added[[kk]]
[10:25:46.236]                   NAME <- NAMES[[kk]]
[10:25:46.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.236]                     next
[10:25:46.236]                   args[[name]] <- ""
[10:25:46.236]                 }
[10:25:46.236]                 NAMES <- toupper(removed)
[10:25:46.236]                 for (kk in seq_along(NAMES)) {
[10:25:46.236]                   name <- removed[[kk]]
[10:25:46.236]                   NAME <- NAMES[[kk]]
[10:25:46.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.236]                     next
[10:25:46.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.236]                 }
[10:25:46.236]                 if (length(args) > 0) 
[10:25:46.236]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.236]             }
[10:25:46.236]             else {
[10:25:46.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.236]             }
[10:25:46.236]             {
[10:25:46.236]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.236]                   0L) {
[10:25:46.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.236]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.236]                   base::options(opts)
[10:25:46.236]                 }
[10:25:46.236]                 {
[10:25:46.236]                   {
[10:25:46.236]                     NULL
[10:25:46.236]                     RNGkind("Mersenne-Twister")
[10:25:46.236]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.236]                       inherits = FALSE)
[10:25:46.236]                   }
[10:25:46.236]                   options(future.plan = NULL)
[10:25:46.236]                   if (is.na(NA_character_)) 
[10:25:46.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.236]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.236]                   {
[10:25:46.236]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.236]                     if (!future$lazy) 
[10:25:46.236]                       future <- run(future)
[10:25:46.236]                     invisible(future)
[10:25:46.236]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.236]                 }
[10:25:46.236]             }
[10:25:46.236]         }
[10:25:46.236]     })
[10:25:46.236]     if (TRUE) {
[10:25:46.236]         base::sink(type = "output", split = FALSE)
[10:25:46.236]         if (TRUE) {
[10:25:46.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.236]         }
[10:25:46.236]         else {
[10:25:46.236]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.236]         }
[10:25:46.236]         base::close(...future.stdout)
[10:25:46.236]         ...future.stdout <- NULL
[10:25:46.236]     }
[10:25:46.236]     ...future.result$conditions <- ...future.conditions
[10:25:46.236]     ...future.result$finished <- base::Sys.time()
[10:25:46.236]     ...future.result
[10:25:46.236] }
[10:25:46.238] plan(): Setting new future strategy stack:
[10:25:46.238] List of future strategies:
[10:25:46.238] 1. sequential:
[10:25:46.238]    - args: function (..., envir = parent.frame())
[10:25:46.238]    - tweaked: FALSE
[10:25:46.238]    - call: NULL
[10:25:46.238] plan(): nbrOfWorkers() = 1
[10:25:46.239] plan(): Setting new future strategy stack:
[10:25:46.239] List of future strategies:
[10:25:46.239] 1. sequential:
[10:25:46.239]    - args: function (..., envir = parent.frame())
[10:25:46.239]    - tweaked: FALSE
[10:25:46.239]    - call: plan(strategy)
[10:25:46.239] plan(): nbrOfWorkers() = 1
[10:25:46.240] SequentialFuture started (and completed)
[10:25:46.240] - Launch lazy future ... done
[10:25:46.240] run() for ‘SequentialFuture’ ... done
<environment: 0x55c0f50db720> 
<environment: 0x55c0f4f5ea08> 
[10:25:46.241] resolved() for ‘SequentialFuture’ ...
[10:25:46.241] - state: ‘finished’
[10:25:46.241] - run: TRUE
[10:25:46.241] - result: ‘FutureResult’
[10:25:46.241] resolved() for ‘SequentialFuture’ ... done
[10:25:46.241] resolved() for ‘SequentialFuture’ ...
[10:25:46.241] - state: ‘finished’
[10:25:46.242] - run: TRUE
[10:25:46.242] - result: ‘FutureResult’
[10:25:46.242] resolved() for ‘SequentialFuture’ ... done
[10:25:46.242] resolved() for ‘SequentialFuture’ ...
[10:25:46.242] - state: ‘finished’
[10:25:46.242] - run: TRUE
[10:25:46.242] - result: ‘FutureResult’
[10:25:46.242] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:46.243] resolve() on environment ...
[10:25:46.243]  recursive: 0
[10:25:46.244]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:46.244] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.244] - nx: 4
[10:25:46.244] - relay: TRUE
[10:25:46.244] - stdout: TRUE
[10:25:46.244] - signal: TRUE
[10:25:46.244] - resignal: FALSE
[10:25:46.245] - force: TRUE
[10:25:46.245] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.245] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.245]  - until=2
[10:25:46.245]  - relaying element #2
[10:25:46.245] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.245] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.245] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.245]  length: 3 (resolved future 1)
[10:25:46.245] resolved() for ‘SequentialFuture’ ...
[10:25:46.245] - state: ‘finished’
[10:25:46.246] - run: TRUE
[10:25:46.246] - result: ‘FutureResult’
[10:25:46.246] resolved() for ‘SequentialFuture’ ... done
[10:25:46.246] Future #2
[10:25:46.246] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.246] - nx: 4
[10:25:46.246] - relay: TRUE
[10:25:46.246] - stdout: TRUE
[10:25:46.246] - signal: TRUE
[10:25:46.246] - resignal: FALSE
[10:25:46.246] - force: TRUE
[10:25:46.247] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.247] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.247]  - until=2
[10:25:46.247]  - relaying element #2
[10:25:46.247] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.247] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.247] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.247]  length: 2 (resolved future 2)
[10:25:46.247] resolved() for ‘SequentialFuture’ ...
[10:25:46.247] - state: ‘finished’
[10:25:46.248] - run: TRUE
[10:25:46.248] - result: ‘FutureResult’
[10:25:46.248] resolved() for ‘SequentialFuture’ ... done
[10:25:46.248] Future #3
[10:25:46.248] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.248] - nx: 4
[10:25:46.248] - relay: TRUE
[10:25:46.248] - stdout: TRUE
[10:25:46.248] - signal: TRUE
[10:25:46.248] - resignal: FALSE
[10:25:46.248] - force: TRUE
[10:25:46.248] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.249] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.249]  - until=3
[10:25:46.249]  - relaying element #3
[10:25:46.249] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.249] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.249] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.249]  length: 1 (resolved future 3)
[10:25:46.249] resolved() for ‘SequentialFuture’ ...
[10:25:46.249] - state: ‘finished’
[10:25:46.249] - run: TRUE
[10:25:46.250] - result: ‘FutureResult’
[10:25:46.250] resolved() for ‘SequentialFuture’ ... done
[10:25:46.250] Future #4
[10:25:46.250] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.250] - nx: 4
[10:25:46.250] - relay: TRUE
[10:25:46.250] - stdout: TRUE
[10:25:46.250] - signal: TRUE
[10:25:46.250] - resignal: FALSE
[10:25:46.250] - force: TRUE
[10:25:46.250] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.250] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.251]  - until=4
[10:25:46.251]  - relaying element #4
[10:25:46.252] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.252] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.252] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.253]  length: 0 (resolved future 4)
[10:25:46.253] Relaying remaining futures
[10:25:46.253] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.253] - nx: 4
[10:25:46.253] - relay: TRUE
[10:25:46.253] - stdout: TRUE
[10:25:46.253] - signal: TRUE
[10:25:46.253] - resignal: FALSE
[10:25:46.253] - force: TRUE
[10:25:46.253] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.253] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:46.254] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.254] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.254] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.254] resolve() on environment ... DONE
<environment: 0x55c0f50feb38> 
Dimensions: c(2, 1, 3, 1)
[10:25:46.254] getGlobalsAndPackages() ...
[10:25:46.254] Searching for globals...
[10:25:46.255] 
[10:25:46.255] Searching for globals ... DONE
[10:25:46.255] - globals: [0] <none>
[10:25:46.255] getGlobalsAndPackages() ... DONE
[10:25:46.255] run() for ‘Future’ ...
[10:25:46.255] - state: ‘created’
[10:25:46.255] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.256] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.256]   - Field: ‘label’
[10:25:46.256]   - Field: ‘local’
[10:25:46.256]   - Field: ‘owner’
[10:25:46.256]   - Field: ‘envir’
[10:25:46.256]   - Field: ‘packages’
[10:25:46.256]   - Field: ‘gc’
[10:25:46.256]   - Field: ‘conditions’
[10:25:46.256]   - Field: ‘expr’
[10:25:46.257]   - Field: ‘uuid’
[10:25:46.257]   - Field: ‘seed’
[10:25:46.257]   - Field: ‘version’
[10:25:46.257]   - Field: ‘result’
[10:25:46.257]   - Field: ‘asynchronous’
[10:25:46.257]   - Field: ‘calls’
[10:25:46.257]   - Field: ‘globals’
[10:25:46.257]   - Field: ‘stdout’
[10:25:46.257]   - Field: ‘earlySignal’
[10:25:46.257]   - Field: ‘lazy’
[10:25:46.257]   - Field: ‘state’
[10:25:46.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.258] - Launch lazy future ...
[10:25:46.258] Packages needed by the future expression (n = 0): <none>
[10:25:46.258] Packages needed by future strategies (n = 0): <none>
[10:25:46.258] {
[10:25:46.258]     {
[10:25:46.258]         {
[10:25:46.258]             ...future.startTime <- base::Sys.time()
[10:25:46.258]             {
[10:25:46.258]                 {
[10:25:46.258]                   {
[10:25:46.258]                     base::local({
[10:25:46.258]                       has_future <- base::requireNamespace("future", 
[10:25:46.258]                         quietly = TRUE)
[10:25:46.258]                       if (has_future) {
[10:25:46.258]                         ns <- base::getNamespace("future")
[10:25:46.258]                         version <- ns[[".package"]][["version"]]
[10:25:46.258]                         if (is.null(version)) 
[10:25:46.258]                           version <- utils::packageVersion("future")
[10:25:46.258]                       }
[10:25:46.258]                       else {
[10:25:46.258]                         version <- NULL
[10:25:46.258]                       }
[10:25:46.258]                       if (!has_future || version < "1.8.0") {
[10:25:46.258]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.258]                           "", base::R.version$version.string), 
[10:25:46.258]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.258]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.258]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.258]                             "release", "version")], collapse = " "), 
[10:25:46.258]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.258]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.258]                           info)
[10:25:46.258]                         info <- base::paste(info, collapse = "; ")
[10:25:46.258]                         if (!has_future) {
[10:25:46.258]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.258]                             info)
[10:25:46.258]                         }
[10:25:46.258]                         else {
[10:25:46.258]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.258]                             info, version)
[10:25:46.258]                         }
[10:25:46.258]                         base::stop(msg)
[10:25:46.258]                       }
[10:25:46.258]                     })
[10:25:46.258]                   }
[10:25:46.258]                   options(future.plan = NULL)
[10:25:46.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.258]                 }
[10:25:46.258]                 ...future.workdir <- getwd()
[10:25:46.258]             }
[10:25:46.258]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.258]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.258]         }
[10:25:46.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.258]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.258]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.258]             base::names(...future.oldOptions))
[10:25:46.258]     }
[10:25:46.258]     if (FALSE) {
[10:25:46.258]     }
[10:25:46.258]     else {
[10:25:46.258]         if (TRUE) {
[10:25:46.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.258]                 open = "w")
[10:25:46.258]         }
[10:25:46.258]         else {
[10:25:46.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.258]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.258]         }
[10:25:46.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.258]             base::sink(type = "output", split = FALSE)
[10:25:46.258]             base::close(...future.stdout)
[10:25:46.258]         }, add = TRUE)
[10:25:46.258]     }
[10:25:46.258]     ...future.frame <- base::sys.nframe()
[10:25:46.258]     ...future.conditions <- base::list()
[10:25:46.258]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.258]     if (FALSE) {
[10:25:46.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.258]     }
[10:25:46.258]     ...future.result <- base::tryCatch({
[10:25:46.258]         base::withCallingHandlers({
[10:25:46.258]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.258]             future::FutureResult(value = ...future.value$value, 
[10:25:46.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.258]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.258]                     ...future.globalenv.names))
[10:25:46.258]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.258]         }, condition = base::local({
[10:25:46.258]             c <- base::c
[10:25:46.258]             inherits <- base::inherits
[10:25:46.258]             invokeRestart <- base::invokeRestart
[10:25:46.258]             length <- base::length
[10:25:46.258]             list <- base::list
[10:25:46.258]             seq.int <- base::seq.int
[10:25:46.258]             signalCondition <- base::signalCondition
[10:25:46.258]             sys.calls <- base::sys.calls
[10:25:46.258]             `[[` <- base::`[[`
[10:25:46.258]             `+` <- base::`+`
[10:25:46.258]             `<<-` <- base::`<<-`
[10:25:46.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.258]                   3L)]
[10:25:46.258]             }
[10:25:46.258]             function(cond) {
[10:25:46.258]                 is_error <- inherits(cond, "error")
[10:25:46.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.258]                   NULL)
[10:25:46.258]                 if (is_error) {
[10:25:46.258]                   sessionInformation <- function() {
[10:25:46.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.258]                       search = base::search(), system = base::Sys.info())
[10:25:46.258]                   }
[10:25:46.258]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.258]                     cond$call), session = sessionInformation(), 
[10:25:46.258]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.258]                   signalCondition(cond)
[10:25:46.258]                 }
[10:25:46.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.258]                 "immediateCondition"))) {
[10:25:46.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.258]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.258]                   if (TRUE && !signal) {
[10:25:46.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.258]                     {
[10:25:46.258]                       inherits <- base::inherits
[10:25:46.258]                       invokeRestart <- base::invokeRestart
[10:25:46.258]                       is.null <- base::is.null
[10:25:46.258]                       muffled <- FALSE
[10:25:46.258]                       if (inherits(cond, "message")) {
[10:25:46.258]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.258]                         if (muffled) 
[10:25:46.258]                           invokeRestart("muffleMessage")
[10:25:46.258]                       }
[10:25:46.258]                       else if (inherits(cond, "warning")) {
[10:25:46.258]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.258]                         if (muffled) 
[10:25:46.258]                           invokeRestart("muffleWarning")
[10:25:46.258]                       }
[10:25:46.258]                       else if (inherits(cond, "condition")) {
[10:25:46.258]                         if (!is.null(pattern)) {
[10:25:46.258]                           computeRestarts <- base::computeRestarts
[10:25:46.258]                           grepl <- base::grepl
[10:25:46.258]                           restarts <- computeRestarts(cond)
[10:25:46.258]                           for (restart in restarts) {
[10:25:46.258]                             name <- restart$name
[10:25:46.258]                             if (is.null(name)) 
[10:25:46.258]                               next
[10:25:46.258]                             if (!grepl(pattern, name)) 
[10:25:46.258]                               next
[10:25:46.258]                             invokeRestart(restart)
[10:25:46.258]                             muffled <- TRUE
[10:25:46.258]                             break
[10:25:46.258]                           }
[10:25:46.258]                         }
[10:25:46.258]                       }
[10:25:46.258]                       invisible(muffled)
[10:25:46.258]                     }
[10:25:46.258]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.258]                   }
[10:25:46.258]                 }
[10:25:46.258]                 else {
[10:25:46.258]                   if (TRUE) {
[10:25:46.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.258]                     {
[10:25:46.258]                       inherits <- base::inherits
[10:25:46.258]                       invokeRestart <- base::invokeRestart
[10:25:46.258]                       is.null <- base::is.null
[10:25:46.258]                       muffled <- FALSE
[10:25:46.258]                       if (inherits(cond, "message")) {
[10:25:46.258]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.258]                         if (muffled) 
[10:25:46.258]                           invokeRestart("muffleMessage")
[10:25:46.258]                       }
[10:25:46.258]                       else if (inherits(cond, "warning")) {
[10:25:46.258]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.258]                         if (muffled) 
[10:25:46.258]                           invokeRestart("muffleWarning")
[10:25:46.258]                       }
[10:25:46.258]                       else if (inherits(cond, "condition")) {
[10:25:46.258]                         if (!is.null(pattern)) {
[10:25:46.258]                           computeRestarts <- base::computeRestarts
[10:25:46.258]                           grepl <- base::grepl
[10:25:46.258]                           restarts <- computeRestarts(cond)
[10:25:46.258]                           for (restart in restarts) {
[10:25:46.258]                             name <- restart$name
[10:25:46.258]                             if (is.null(name)) 
[10:25:46.258]                               next
[10:25:46.258]                             if (!grepl(pattern, name)) 
[10:25:46.258]                               next
[10:25:46.258]                             invokeRestart(restart)
[10:25:46.258]                             muffled <- TRUE
[10:25:46.258]                             break
[10:25:46.258]                           }
[10:25:46.258]                         }
[10:25:46.258]                       }
[10:25:46.258]                       invisible(muffled)
[10:25:46.258]                     }
[10:25:46.258]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.258]                   }
[10:25:46.258]                 }
[10:25:46.258]             }
[10:25:46.258]         }))
[10:25:46.258]     }, error = function(ex) {
[10:25:46.258]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.258]                 ...future.rng), started = ...future.startTime, 
[10:25:46.258]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.258]             version = "1.8"), class = "FutureResult")
[10:25:46.258]     }, finally = {
[10:25:46.258]         if (!identical(...future.workdir, getwd())) 
[10:25:46.258]             setwd(...future.workdir)
[10:25:46.258]         {
[10:25:46.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.258]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.258]             }
[10:25:46.258]             base::options(...future.oldOptions)
[10:25:46.258]             if (.Platform$OS.type == "windows") {
[10:25:46.258]                 old_names <- names(...future.oldEnvVars)
[10:25:46.258]                 envs <- base::Sys.getenv()
[10:25:46.258]                 names <- names(envs)
[10:25:46.258]                 common <- intersect(names, old_names)
[10:25:46.258]                 added <- setdiff(names, old_names)
[10:25:46.258]                 removed <- setdiff(old_names, names)
[10:25:46.258]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.258]                   envs[common]]
[10:25:46.258]                 NAMES <- toupper(changed)
[10:25:46.258]                 args <- list()
[10:25:46.258]                 for (kk in seq_along(NAMES)) {
[10:25:46.258]                   name <- changed[[kk]]
[10:25:46.258]                   NAME <- NAMES[[kk]]
[10:25:46.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.258]                     next
[10:25:46.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.258]                 }
[10:25:46.258]                 NAMES <- toupper(added)
[10:25:46.258]                 for (kk in seq_along(NAMES)) {
[10:25:46.258]                   name <- added[[kk]]
[10:25:46.258]                   NAME <- NAMES[[kk]]
[10:25:46.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.258]                     next
[10:25:46.258]                   args[[name]] <- ""
[10:25:46.258]                 }
[10:25:46.258]                 NAMES <- toupper(removed)
[10:25:46.258]                 for (kk in seq_along(NAMES)) {
[10:25:46.258]                   name <- removed[[kk]]
[10:25:46.258]                   NAME <- NAMES[[kk]]
[10:25:46.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.258]                     next
[10:25:46.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.258]                 }
[10:25:46.258]                 if (length(args) > 0) 
[10:25:46.258]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.258]             }
[10:25:46.258]             else {
[10:25:46.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.258]             }
[10:25:46.258]             {
[10:25:46.258]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.258]                   0L) {
[10:25:46.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.258]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.258]                   base::options(opts)
[10:25:46.258]                 }
[10:25:46.258]                 {
[10:25:46.258]                   {
[10:25:46.258]                     NULL
[10:25:46.258]                     RNGkind("Mersenne-Twister")
[10:25:46.258]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.258]                       inherits = FALSE)
[10:25:46.258]                   }
[10:25:46.258]                   options(future.plan = NULL)
[10:25:46.258]                   if (is.na(NA_character_)) 
[10:25:46.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.258]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.258]                   {
[10:25:46.258]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.258]                     if (!future$lazy) 
[10:25:46.258]                       future <- run(future)
[10:25:46.258]                     invisible(future)
[10:25:46.258]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.258]                 }
[10:25:46.258]             }
[10:25:46.258]         }
[10:25:46.258]     })
[10:25:46.258]     if (TRUE) {
[10:25:46.258]         base::sink(type = "output", split = FALSE)
[10:25:46.258]         if (TRUE) {
[10:25:46.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.258]         }
[10:25:46.258]         else {
[10:25:46.258]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.258]         }
[10:25:46.258]         base::close(...future.stdout)
[10:25:46.258]         ...future.stdout <- NULL
[10:25:46.258]     }
[10:25:46.258]     ...future.result$conditions <- ...future.conditions
[10:25:46.258]     ...future.result$finished <- base::Sys.time()
[10:25:46.258]     ...future.result
[10:25:46.258] }
[10:25:46.260] plan(): Setting new future strategy stack:
[10:25:46.260] List of future strategies:
[10:25:46.260] 1. sequential:
[10:25:46.260]    - args: function (..., envir = parent.frame())
[10:25:46.260]    - tweaked: FALSE
[10:25:46.260]    - call: NULL
[10:25:46.260] plan(): nbrOfWorkers() = 1
[10:25:46.261] plan(): Setting new future strategy stack:
[10:25:46.261] List of future strategies:
[10:25:46.261] 1. sequential:
[10:25:46.261]    - args: function (..., envir = parent.frame())
[10:25:46.261]    - tweaked: FALSE
[10:25:46.261]    - call: plan(strategy)
[10:25:46.262] plan(): nbrOfWorkers() = 1
[10:25:46.262] SequentialFuture started (and completed)
[10:25:46.262] - Launch lazy future ... done
[10:25:46.262] run() for ‘SequentialFuture’ ... done
[10:25:46.262] getGlobalsAndPackages() ...
[10:25:46.262] Searching for globals...
[10:25:46.262] 
[10:25:46.263] Searching for globals ... DONE
[10:25:46.263] - globals: [0] <none>
[10:25:46.263] getGlobalsAndPackages() ... DONE
[10:25:46.263] run() for ‘Future’ ...
[10:25:46.263] - state: ‘created’
[10:25:46.263] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.263] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.264]   - Field: ‘label’
[10:25:46.264]   - Field: ‘local’
[10:25:46.264]   - Field: ‘owner’
[10:25:46.264]   - Field: ‘envir’
[10:25:46.264]   - Field: ‘packages’
[10:25:46.264]   - Field: ‘gc’
[10:25:46.264]   - Field: ‘conditions’
[10:25:46.264]   - Field: ‘expr’
[10:25:46.264]   - Field: ‘uuid’
[10:25:46.264]   - Field: ‘seed’
[10:25:46.264]   - Field: ‘version’
[10:25:46.264]   - Field: ‘result’
[10:25:46.265]   - Field: ‘asynchronous’
[10:25:46.265]   - Field: ‘calls’
[10:25:46.265]   - Field: ‘globals’
[10:25:46.265]   - Field: ‘stdout’
[10:25:46.265]   - Field: ‘earlySignal’
[10:25:46.265]   - Field: ‘lazy’
[10:25:46.265]   - Field: ‘state’
[10:25:46.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.265] - Launch lazy future ...
[10:25:46.265] Packages needed by the future expression (n = 0): <none>
[10:25:46.266] Packages needed by future strategies (n = 0): <none>
[10:25:46.266] {
[10:25:46.266]     {
[10:25:46.266]         {
[10:25:46.266]             ...future.startTime <- base::Sys.time()
[10:25:46.266]             {
[10:25:46.266]                 {
[10:25:46.266]                   {
[10:25:46.266]                     base::local({
[10:25:46.266]                       has_future <- base::requireNamespace("future", 
[10:25:46.266]                         quietly = TRUE)
[10:25:46.266]                       if (has_future) {
[10:25:46.266]                         ns <- base::getNamespace("future")
[10:25:46.266]                         version <- ns[[".package"]][["version"]]
[10:25:46.266]                         if (is.null(version)) 
[10:25:46.266]                           version <- utils::packageVersion("future")
[10:25:46.266]                       }
[10:25:46.266]                       else {
[10:25:46.266]                         version <- NULL
[10:25:46.266]                       }
[10:25:46.266]                       if (!has_future || version < "1.8.0") {
[10:25:46.266]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.266]                           "", base::R.version$version.string), 
[10:25:46.266]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.266]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.266]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.266]                             "release", "version")], collapse = " "), 
[10:25:46.266]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.266]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.266]                           info)
[10:25:46.266]                         info <- base::paste(info, collapse = "; ")
[10:25:46.266]                         if (!has_future) {
[10:25:46.266]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.266]                             info)
[10:25:46.266]                         }
[10:25:46.266]                         else {
[10:25:46.266]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.266]                             info, version)
[10:25:46.266]                         }
[10:25:46.266]                         base::stop(msg)
[10:25:46.266]                       }
[10:25:46.266]                     })
[10:25:46.266]                   }
[10:25:46.266]                   options(future.plan = NULL)
[10:25:46.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.266]                 }
[10:25:46.266]                 ...future.workdir <- getwd()
[10:25:46.266]             }
[10:25:46.266]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.266]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.266]         }
[10:25:46.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.266]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.266]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.266]             base::names(...future.oldOptions))
[10:25:46.266]     }
[10:25:46.266]     if (FALSE) {
[10:25:46.266]     }
[10:25:46.266]     else {
[10:25:46.266]         if (TRUE) {
[10:25:46.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.266]                 open = "w")
[10:25:46.266]         }
[10:25:46.266]         else {
[10:25:46.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.266]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.266]         }
[10:25:46.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.266]             base::sink(type = "output", split = FALSE)
[10:25:46.266]             base::close(...future.stdout)
[10:25:46.266]         }, add = TRUE)
[10:25:46.266]     }
[10:25:46.266]     ...future.frame <- base::sys.nframe()
[10:25:46.266]     ...future.conditions <- base::list()
[10:25:46.266]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.266]     if (FALSE) {
[10:25:46.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.266]     }
[10:25:46.266]     ...future.result <- base::tryCatch({
[10:25:46.266]         base::withCallingHandlers({
[10:25:46.266]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.266]             future::FutureResult(value = ...future.value$value, 
[10:25:46.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.266]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.266]                     ...future.globalenv.names))
[10:25:46.266]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.266]         }, condition = base::local({
[10:25:46.266]             c <- base::c
[10:25:46.266]             inherits <- base::inherits
[10:25:46.266]             invokeRestart <- base::invokeRestart
[10:25:46.266]             length <- base::length
[10:25:46.266]             list <- base::list
[10:25:46.266]             seq.int <- base::seq.int
[10:25:46.266]             signalCondition <- base::signalCondition
[10:25:46.266]             sys.calls <- base::sys.calls
[10:25:46.266]             `[[` <- base::`[[`
[10:25:46.266]             `+` <- base::`+`
[10:25:46.266]             `<<-` <- base::`<<-`
[10:25:46.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.266]                   3L)]
[10:25:46.266]             }
[10:25:46.266]             function(cond) {
[10:25:46.266]                 is_error <- inherits(cond, "error")
[10:25:46.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.266]                   NULL)
[10:25:46.266]                 if (is_error) {
[10:25:46.266]                   sessionInformation <- function() {
[10:25:46.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.266]                       search = base::search(), system = base::Sys.info())
[10:25:46.266]                   }
[10:25:46.266]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.266]                     cond$call), session = sessionInformation(), 
[10:25:46.266]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.266]                   signalCondition(cond)
[10:25:46.266]                 }
[10:25:46.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.266]                 "immediateCondition"))) {
[10:25:46.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.266]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.266]                   if (TRUE && !signal) {
[10:25:46.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.266]                     {
[10:25:46.266]                       inherits <- base::inherits
[10:25:46.266]                       invokeRestart <- base::invokeRestart
[10:25:46.266]                       is.null <- base::is.null
[10:25:46.266]                       muffled <- FALSE
[10:25:46.266]                       if (inherits(cond, "message")) {
[10:25:46.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.266]                         if (muffled) 
[10:25:46.266]                           invokeRestart("muffleMessage")
[10:25:46.266]                       }
[10:25:46.266]                       else if (inherits(cond, "warning")) {
[10:25:46.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.266]                         if (muffled) 
[10:25:46.266]                           invokeRestart("muffleWarning")
[10:25:46.266]                       }
[10:25:46.266]                       else if (inherits(cond, "condition")) {
[10:25:46.266]                         if (!is.null(pattern)) {
[10:25:46.266]                           computeRestarts <- base::computeRestarts
[10:25:46.266]                           grepl <- base::grepl
[10:25:46.266]                           restarts <- computeRestarts(cond)
[10:25:46.266]                           for (restart in restarts) {
[10:25:46.266]                             name <- restart$name
[10:25:46.266]                             if (is.null(name)) 
[10:25:46.266]                               next
[10:25:46.266]                             if (!grepl(pattern, name)) 
[10:25:46.266]                               next
[10:25:46.266]                             invokeRestart(restart)
[10:25:46.266]                             muffled <- TRUE
[10:25:46.266]                             break
[10:25:46.266]                           }
[10:25:46.266]                         }
[10:25:46.266]                       }
[10:25:46.266]                       invisible(muffled)
[10:25:46.266]                     }
[10:25:46.266]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.266]                   }
[10:25:46.266]                 }
[10:25:46.266]                 else {
[10:25:46.266]                   if (TRUE) {
[10:25:46.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.266]                     {
[10:25:46.266]                       inherits <- base::inherits
[10:25:46.266]                       invokeRestart <- base::invokeRestart
[10:25:46.266]                       is.null <- base::is.null
[10:25:46.266]                       muffled <- FALSE
[10:25:46.266]                       if (inherits(cond, "message")) {
[10:25:46.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.266]                         if (muffled) 
[10:25:46.266]                           invokeRestart("muffleMessage")
[10:25:46.266]                       }
[10:25:46.266]                       else if (inherits(cond, "warning")) {
[10:25:46.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.266]                         if (muffled) 
[10:25:46.266]                           invokeRestart("muffleWarning")
[10:25:46.266]                       }
[10:25:46.266]                       else if (inherits(cond, "condition")) {
[10:25:46.266]                         if (!is.null(pattern)) {
[10:25:46.266]                           computeRestarts <- base::computeRestarts
[10:25:46.266]                           grepl <- base::grepl
[10:25:46.266]                           restarts <- computeRestarts(cond)
[10:25:46.266]                           for (restart in restarts) {
[10:25:46.266]                             name <- restart$name
[10:25:46.266]                             if (is.null(name)) 
[10:25:46.266]                               next
[10:25:46.266]                             if (!grepl(pattern, name)) 
[10:25:46.266]                               next
[10:25:46.266]                             invokeRestart(restart)
[10:25:46.266]                             muffled <- TRUE
[10:25:46.266]                             break
[10:25:46.266]                           }
[10:25:46.266]                         }
[10:25:46.266]                       }
[10:25:46.266]                       invisible(muffled)
[10:25:46.266]                     }
[10:25:46.266]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.266]                   }
[10:25:46.266]                 }
[10:25:46.266]             }
[10:25:46.266]         }))
[10:25:46.266]     }, error = function(ex) {
[10:25:46.266]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.266]                 ...future.rng), started = ...future.startTime, 
[10:25:46.266]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.266]             version = "1.8"), class = "FutureResult")
[10:25:46.266]     }, finally = {
[10:25:46.266]         if (!identical(...future.workdir, getwd())) 
[10:25:46.266]             setwd(...future.workdir)
[10:25:46.266]         {
[10:25:46.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.266]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.266]             }
[10:25:46.266]             base::options(...future.oldOptions)
[10:25:46.266]             if (.Platform$OS.type == "windows") {
[10:25:46.266]                 old_names <- names(...future.oldEnvVars)
[10:25:46.266]                 envs <- base::Sys.getenv()
[10:25:46.266]                 names <- names(envs)
[10:25:46.266]                 common <- intersect(names, old_names)
[10:25:46.266]                 added <- setdiff(names, old_names)
[10:25:46.266]                 removed <- setdiff(old_names, names)
[10:25:46.266]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.266]                   envs[common]]
[10:25:46.266]                 NAMES <- toupper(changed)
[10:25:46.266]                 args <- list()
[10:25:46.266]                 for (kk in seq_along(NAMES)) {
[10:25:46.266]                   name <- changed[[kk]]
[10:25:46.266]                   NAME <- NAMES[[kk]]
[10:25:46.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.266]                     next
[10:25:46.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.266]                 }
[10:25:46.266]                 NAMES <- toupper(added)
[10:25:46.266]                 for (kk in seq_along(NAMES)) {
[10:25:46.266]                   name <- added[[kk]]
[10:25:46.266]                   NAME <- NAMES[[kk]]
[10:25:46.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.266]                     next
[10:25:46.266]                   args[[name]] <- ""
[10:25:46.266]                 }
[10:25:46.266]                 NAMES <- toupper(removed)
[10:25:46.266]                 for (kk in seq_along(NAMES)) {
[10:25:46.266]                   name <- removed[[kk]]
[10:25:46.266]                   NAME <- NAMES[[kk]]
[10:25:46.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.266]                     next
[10:25:46.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.266]                 }
[10:25:46.266]                 if (length(args) > 0) 
[10:25:46.266]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.266]             }
[10:25:46.266]             else {
[10:25:46.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.266]             }
[10:25:46.266]             {
[10:25:46.266]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.266]                   0L) {
[10:25:46.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.266]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.266]                   base::options(opts)
[10:25:46.266]                 }
[10:25:46.266]                 {
[10:25:46.266]                   {
[10:25:46.266]                     NULL
[10:25:46.266]                     RNGkind("Mersenne-Twister")
[10:25:46.266]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.266]                       inherits = FALSE)
[10:25:46.266]                   }
[10:25:46.266]                   options(future.plan = NULL)
[10:25:46.266]                   if (is.na(NA_character_)) 
[10:25:46.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.266]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.266]                   {
[10:25:46.266]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.266]                     if (!future$lazy) 
[10:25:46.266]                       future <- run(future)
[10:25:46.266]                     invisible(future)
[10:25:46.266]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.266]                 }
[10:25:46.266]             }
[10:25:46.266]         }
[10:25:46.266]     })
[10:25:46.266]     if (TRUE) {
[10:25:46.266]         base::sink(type = "output", split = FALSE)
[10:25:46.266]         if (TRUE) {
[10:25:46.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.266]         }
[10:25:46.266]         else {
[10:25:46.266]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.266]         }
[10:25:46.266]         base::close(...future.stdout)
[10:25:46.266]         ...future.stdout <- NULL
[10:25:46.266]     }
[10:25:46.266]     ...future.result$conditions <- ...future.conditions
[10:25:46.266]     ...future.result$finished <- base::Sys.time()
[10:25:46.266]     ...future.result
[10:25:46.266] }
[10:25:46.268] plan(): Setting new future strategy stack:
[10:25:46.268] List of future strategies:
[10:25:46.268] 1. sequential:
[10:25:46.268]    - args: function (..., envir = parent.frame())
[10:25:46.268]    - tweaked: FALSE
[10:25:46.268]    - call: NULL
[10:25:46.268] plan(): nbrOfWorkers() = 1
[10:25:46.269] plan(): Setting new future strategy stack:
[10:25:46.269] List of future strategies:
[10:25:46.269] 1. sequential:
[10:25:46.269]    - args: function (..., envir = parent.frame())
[10:25:46.269]    - tweaked: FALSE
[10:25:46.269]    - call: plan(strategy)
[10:25:46.269] plan(): nbrOfWorkers() = 1
[10:25:46.269] SequentialFuture started (and completed)
[10:25:46.269] - Launch lazy future ... done
[10:25:46.270] run() for ‘SequentialFuture’ ... done
[10:25:46.270] getGlobalsAndPackages() ...
[10:25:46.270] Searching for globals...
[10:25:46.270] - globals found: [1] ‘{’
[10:25:46.271] Searching for globals ... DONE
[10:25:46.271] Resolving globals: FALSE
[10:25:46.271] 
[10:25:46.271] 
[10:25:46.271] getGlobalsAndPackages() ... DONE
[10:25:46.271] run() for ‘Future’ ...
[10:25:46.271] - state: ‘created’
[10:25:46.271] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.272] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.272] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.272]   - Field: ‘label’
[10:25:46.272]   - Field: ‘local’
[10:25:46.272]   - Field: ‘owner’
[10:25:46.272]   - Field: ‘envir’
[10:25:46.272]   - Field: ‘packages’
[10:25:46.272]   - Field: ‘gc’
[10:25:46.272]   - Field: ‘conditions’
[10:25:46.273]   - Field: ‘expr’
[10:25:46.273]   - Field: ‘uuid’
[10:25:46.273]   - Field: ‘seed’
[10:25:46.273]   - Field: ‘version’
[10:25:46.273]   - Field: ‘result’
[10:25:46.273]   - Field: ‘asynchronous’
[10:25:46.273]   - Field: ‘calls’
[10:25:46.273]   - Field: ‘globals’
[10:25:46.273]   - Field: ‘stdout’
[10:25:46.273]   - Field: ‘earlySignal’
[10:25:46.273]   - Field: ‘lazy’
[10:25:46.273]   - Field: ‘state’
[10:25:46.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.274] - Launch lazy future ...
[10:25:46.274] Packages needed by the future expression (n = 0): <none>
[10:25:46.274] Packages needed by future strategies (n = 0): <none>
[10:25:46.274] {
[10:25:46.274]     {
[10:25:46.274]         {
[10:25:46.274]             ...future.startTime <- base::Sys.time()
[10:25:46.274]             {
[10:25:46.274]                 {
[10:25:46.274]                   {
[10:25:46.274]                     base::local({
[10:25:46.274]                       has_future <- base::requireNamespace("future", 
[10:25:46.274]                         quietly = TRUE)
[10:25:46.274]                       if (has_future) {
[10:25:46.274]                         ns <- base::getNamespace("future")
[10:25:46.274]                         version <- ns[[".package"]][["version"]]
[10:25:46.274]                         if (is.null(version)) 
[10:25:46.274]                           version <- utils::packageVersion("future")
[10:25:46.274]                       }
[10:25:46.274]                       else {
[10:25:46.274]                         version <- NULL
[10:25:46.274]                       }
[10:25:46.274]                       if (!has_future || version < "1.8.0") {
[10:25:46.274]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.274]                           "", base::R.version$version.string), 
[10:25:46.274]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.274]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.274]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.274]                             "release", "version")], collapse = " "), 
[10:25:46.274]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.274]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.274]                           info)
[10:25:46.274]                         info <- base::paste(info, collapse = "; ")
[10:25:46.274]                         if (!has_future) {
[10:25:46.274]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.274]                             info)
[10:25:46.274]                         }
[10:25:46.274]                         else {
[10:25:46.274]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.274]                             info, version)
[10:25:46.274]                         }
[10:25:46.274]                         base::stop(msg)
[10:25:46.274]                       }
[10:25:46.274]                     })
[10:25:46.274]                   }
[10:25:46.274]                   options(future.plan = NULL)
[10:25:46.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.274]                 }
[10:25:46.274]                 ...future.workdir <- getwd()
[10:25:46.274]             }
[10:25:46.274]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.274]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.274]         }
[10:25:46.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.274]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.274]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.274]             base::names(...future.oldOptions))
[10:25:46.274]     }
[10:25:46.274]     if (FALSE) {
[10:25:46.274]     }
[10:25:46.274]     else {
[10:25:46.274]         if (TRUE) {
[10:25:46.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.274]                 open = "w")
[10:25:46.274]         }
[10:25:46.274]         else {
[10:25:46.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.274]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.274]         }
[10:25:46.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.274]             base::sink(type = "output", split = FALSE)
[10:25:46.274]             base::close(...future.stdout)
[10:25:46.274]         }, add = TRUE)
[10:25:46.274]     }
[10:25:46.274]     ...future.frame <- base::sys.nframe()
[10:25:46.274]     ...future.conditions <- base::list()
[10:25:46.274]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.274]     if (FALSE) {
[10:25:46.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.274]     }
[10:25:46.274]     ...future.result <- base::tryCatch({
[10:25:46.274]         base::withCallingHandlers({
[10:25:46.274]             ...future.value <- base::withVisible(base::local({
[10:25:46.274]                 4
[10:25:46.274]             }))
[10:25:46.274]             future::FutureResult(value = ...future.value$value, 
[10:25:46.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.274]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.274]                     ...future.globalenv.names))
[10:25:46.274]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.274]         }, condition = base::local({
[10:25:46.274]             c <- base::c
[10:25:46.274]             inherits <- base::inherits
[10:25:46.274]             invokeRestart <- base::invokeRestart
[10:25:46.274]             length <- base::length
[10:25:46.274]             list <- base::list
[10:25:46.274]             seq.int <- base::seq.int
[10:25:46.274]             signalCondition <- base::signalCondition
[10:25:46.274]             sys.calls <- base::sys.calls
[10:25:46.274]             `[[` <- base::`[[`
[10:25:46.274]             `+` <- base::`+`
[10:25:46.274]             `<<-` <- base::`<<-`
[10:25:46.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.274]                   3L)]
[10:25:46.274]             }
[10:25:46.274]             function(cond) {
[10:25:46.274]                 is_error <- inherits(cond, "error")
[10:25:46.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.274]                   NULL)
[10:25:46.274]                 if (is_error) {
[10:25:46.274]                   sessionInformation <- function() {
[10:25:46.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.274]                       search = base::search(), system = base::Sys.info())
[10:25:46.274]                   }
[10:25:46.274]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.274]                     cond$call), session = sessionInformation(), 
[10:25:46.274]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.274]                   signalCondition(cond)
[10:25:46.274]                 }
[10:25:46.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.274]                 "immediateCondition"))) {
[10:25:46.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.274]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.274]                   if (TRUE && !signal) {
[10:25:46.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.274]                     {
[10:25:46.274]                       inherits <- base::inherits
[10:25:46.274]                       invokeRestart <- base::invokeRestart
[10:25:46.274]                       is.null <- base::is.null
[10:25:46.274]                       muffled <- FALSE
[10:25:46.274]                       if (inherits(cond, "message")) {
[10:25:46.274]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.274]                         if (muffled) 
[10:25:46.274]                           invokeRestart("muffleMessage")
[10:25:46.274]                       }
[10:25:46.274]                       else if (inherits(cond, "warning")) {
[10:25:46.274]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.274]                         if (muffled) 
[10:25:46.274]                           invokeRestart("muffleWarning")
[10:25:46.274]                       }
[10:25:46.274]                       else if (inherits(cond, "condition")) {
[10:25:46.274]                         if (!is.null(pattern)) {
[10:25:46.274]                           computeRestarts <- base::computeRestarts
[10:25:46.274]                           grepl <- base::grepl
[10:25:46.274]                           restarts <- computeRestarts(cond)
[10:25:46.274]                           for (restart in restarts) {
[10:25:46.274]                             name <- restart$name
[10:25:46.274]                             if (is.null(name)) 
[10:25:46.274]                               next
[10:25:46.274]                             if (!grepl(pattern, name)) 
[10:25:46.274]                               next
[10:25:46.274]                             invokeRestart(restart)
[10:25:46.274]                             muffled <- TRUE
[10:25:46.274]                             break
[10:25:46.274]                           }
[10:25:46.274]                         }
[10:25:46.274]                       }
[10:25:46.274]                       invisible(muffled)
[10:25:46.274]                     }
[10:25:46.274]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.274]                   }
[10:25:46.274]                 }
[10:25:46.274]                 else {
[10:25:46.274]                   if (TRUE) {
[10:25:46.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.274]                     {
[10:25:46.274]                       inherits <- base::inherits
[10:25:46.274]                       invokeRestart <- base::invokeRestart
[10:25:46.274]                       is.null <- base::is.null
[10:25:46.274]                       muffled <- FALSE
[10:25:46.274]                       if (inherits(cond, "message")) {
[10:25:46.274]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.274]                         if (muffled) 
[10:25:46.274]                           invokeRestart("muffleMessage")
[10:25:46.274]                       }
[10:25:46.274]                       else if (inherits(cond, "warning")) {
[10:25:46.274]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.274]                         if (muffled) 
[10:25:46.274]                           invokeRestart("muffleWarning")
[10:25:46.274]                       }
[10:25:46.274]                       else if (inherits(cond, "condition")) {
[10:25:46.274]                         if (!is.null(pattern)) {
[10:25:46.274]                           computeRestarts <- base::computeRestarts
[10:25:46.274]                           grepl <- base::grepl
[10:25:46.274]                           restarts <- computeRestarts(cond)
[10:25:46.274]                           for (restart in restarts) {
[10:25:46.274]                             name <- restart$name
[10:25:46.274]                             if (is.null(name)) 
[10:25:46.274]                               next
[10:25:46.274]                             if (!grepl(pattern, name)) 
[10:25:46.274]                               next
[10:25:46.274]                             invokeRestart(restart)
[10:25:46.274]                             muffled <- TRUE
[10:25:46.274]                             break
[10:25:46.274]                           }
[10:25:46.274]                         }
[10:25:46.274]                       }
[10:25:46.274]                       invisible(muffled)
[10:25:46.274]                     }
[10:25:46.274]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.274]                   }
[10:25:46.274]                 }
[10:25:46.274]             }
[10:25:46.274]         }))
[10:25:46.274]     }, error = function(ex) {
[10:25:46.274]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.274]                 ...future.rng), started = ...future.startTime, 
[10:25:46.274]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.274]             version = "1.8"), class = "FutureResult")
[10:25:46.274]     }, finally = {
[10:25:46.274]         if (!identical(...future.workdir, getwd())) 
[10:25:46.274]             setwd(...future.workdir)
[10:25:46.274]         {
[10:25:46.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.274]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.274]             }
[10:25:46.274]             base::options(...future.oldOptions)
[10:25:46.274]             if (.Platform$OS.type == "windows") {
[10:25:46.274]                 old_names <- names(...future.oldEnvVars)
[10:25:46.274]                 envs <- base::Sys.getenv()
[10:25:46.274]                 names <- names(envs)
[10:25:46.274]                 common <- intersect(names, old_names)
[10:25:46.274]                 added <- setdiff(names, old_names)
[10:25:46.274]                 removed <- setdiff(old_names, names)
[10:25:46.274]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.274]                   envs[common]]
[10:25:46.274]                 NAMES <- toupper(changed)
[10:25:46.274]                 args <- list()
[10:25:46.274]                 for (kk in seq_along(NAMES)) {
[10:25:46.274]                   name <- changed[[kk]]
[10:25:46.274]                   NAME <- NAMES[[kk]]
[10:25:46.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.274]                     next
[10:25:46.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.274]                 }
[10:25:46.274]                 NAMES <- toupper(added)
[10:25:46.274]                 for (kk in seq_along(NAMES)) {
[10:25:46.274]                   name <- added[[kk]]
[10:25:46.274]                   NAME <- NAMES[[kk]]
[10:25:46.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.274]                     next
[10:25:46.274]                   args[[name]] <- ""
[10:25:46.274]                 }
[10:25:46.274]                 NAMES <- toupper(removed)
[10:25:46.274]                 for (kk in seq_along(NAMES)) {
[10:25:46.274]                   name <- removed[[kk]]
[10:25:46.274]                   NAME <- NAMES[[kk]]
[10:25:46.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.274]                     next
[10:25:46.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.274]                 }
[10:25:46.274]                 if (length(args) > 0) 
[10:25:46.274]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.274]             }
[10:25:46.274]             else {
[10:25:46.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.274]             }
[10:25:46.274]             {
[10:25:46.274]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.274]                   0L) {
[10:25:46.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.274]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.274]                   base::options(opts)
[10:25:46.274]                 }
[10:25:46.274]                 {
[10:25:46.274]                   {
[10:25:46.274]                     NULL
[10:25:46.274]                     RNGkind("Mersenne-Twister")
[10:25:46.274]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.274]                       inherits = FALSE)
[10:25:46.274]                   }
[10:25:46.274]                   options(future.plan = NULL)
[10:25:46.274]                   if (is.na(NA_character_)) 
[10:25:46.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.274]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.274]                   {
[10:25:46.274]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.274]                     if (!future$lazy) 
[10:25:46.274]                       future <- run(future)
[10:25:46.274]                     invisible(future)
[10:25:46.274]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.274]                 }
[10:25:46.274]             }
[10:25:46.274]         }
[10:25:46.274]     })
[10:25:46.274]     if (TRUE) {
[10:25:46.274]         base::sink(type = "output", split = FALSE)
[10:25:46.274]         if (TRUE) {
[10:25:46.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.274]         }
[10:25:46.274]         else {
[10:25:46.274]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.274]         }
[10:25:46.274]         base::close(...future.stdout)
[10:25:46.274]         ...future.stdout <- NULL
[10:25:46.274]     }
[10:25:46.274]     ...future.result$conditions <- ...future.conditions
[10:25:46.274]     ...future.result$finished <- base::Sys.time()
[10:25:46.274]     ...future.result
[10:25:46.274] }
[10:25:46.276] plan(): Setting new future strategy stack:
[10:25:46.276] List of future strategies:
[10:25:46.276] 1. sequential:
[10:25:46.276]    - args: function (..., envir = parent.frame())
[10:25:46.276]    - tweaked: FALSE
[10:25:46.276]    - call: NULL
[10:25:46.276] plan(): nbrOfWorkers() = 1
[10:25:46.277] plan(): Setting new future strategy stack:
[10:25:46.277] List of future strategies:
[10:25:46.277] 1. sequential:
[10:25:46.277]    - args: function (..., envir = parent.frame())
[10:25:46.277]    - tweaked: FALSE
[10:25:46.277]    - call: plan(strategy)
[10:25:46.278] plan(): nbrOfWorkers() = 1
[10:25:46.278] SequentialFuture started (and completed)
[10:25:46.278] - Launch lazy future ... done
[10:25:46.278] run() for ‘SequentialFuture’ ... done
<environment: 0x55c0f3a97650> 
<environment: 0x55c0f57698d0> 
[10:25:46.280] resolved() for ‘SequentialFuture’ ...
[10:25:46.281] - state: ‘finished’
[10:25:46.281] - run: TRUE
[10:25:46.281] - result: ‘FutureResult’
[10:25:46.281] resolved() for ‘SequentialFuture’ ... done
[10:25:46.281] resolved() for ‘SequentialFuture’ ...
[10:25:46.281] - state: ‘finished’
[10:25:46.281] - run: TRUE
[10:25:46.281] - result: ‘FutureResult’
[10:25:46.281] resolved() for ‘SequentialFuture’ ... done
[10:25:46.281] resolved() for ‘SequentialFuture’ ...
[10:25:46.282] - state: ‘finished’
[10:25:46.282] - run: TRUE
[10:25:46.282] - result: ‘FutureResult’
[10:25:46.282] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:46.283] resolve() on environment ...
[10:25:46.283]  recursive: 0
[10:25:46.283]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:46.284] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.284] - nx: 4
[10:25:46.284] - relay: TRUE
[10:25:46.284] - stdout: TRUE
[10:25:46.284] - signal: TRUE
[10:25:46.284] - resignal: FALSE
[10:25:46.284] - force: TRUE
[10:25:46.284] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.284] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.284]  - until=2
[10:25:46.284]  - relaying element #2
[10:25:46.284] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.284] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.285] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.285]  length: 3 (resolved future 1)
[10:25:46.285] resolved() for ‘SequentialFuture’ ...
[10:25:46.285] - state: ‘finished’
[10:25:46.285] - run: TRUE
[10:25:46.285] - result: ‘FutureResult’
[10:25:46.285] resolved() for ‘SequentialFuture’ ... done
[10:25:46.285] Future #2
[10:25:46.285] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.285] - nx: 4
[10:25:46.286] - relay: TRUE
[10:25:46.286] - stdout: TRUE
[10:25:46.286] - signal: TRUE
[10:25:46.286] - resignal: FALSE
[10:25:46.286] - force: TRUE
[10:25:46.286] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:46.286] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:46.286]  - until=2
[10:25:46.286]  - relaying element #2
[10:25:46.286] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.286] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.286] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.287]  length: 2 (resolved future 2)
[10:25:46.287] resolved() for ‘SequentialFuture’ ...
[10:25:46.287] - state: ‘finished’
[10:25:46.287] - run: TRUE
[10:25:46.287] - result: ‘FutureResult’
[10:25:46.287] resolved() for ‘SequentialFuture’ ... done
[10:25:46.287] Future #3
[10:25:46.287] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.287] - nx: 4
[10:25:46.287] - relay: TRUE
[10:25:46.287] - stdout: TRUE
[10:25:46.288] - signal: TRUE
[10:25:46.288] - resignal: FALSE
[10:25:46.288] - force: TRUE
[10:25:46.288] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:46.288] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:46.288]  - until=3
[10:25:46.288]  - relaying element #3
[10:25:46.288] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.288] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.288] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.288]  length: 1 (resolved future 3)
[10:25:46.289] resolved() for ‘SequentialFuture’ ...
[10:25:46.289] - state: ‘finished’
[10:25:46.289] - run: TRUE
[10:25:46.289] - result: ‘FutureResult’
[10:25:46.289] resolved() for ‘SequentialFuture’ ... done
[10:25:46.289] Future #4
[10:25:46.289] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.289] - nx: 4
[10:25:46.289] - relay: TRUE
[10:25:46.289] - stdout: TRUE
[10:25:46.289] - signal: TRUE
[10:25:46.290] - resignal: FALSE
[10:25:46.290] - force: TRUE
[10:25:46.290] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:46.290] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:46.290]  - until=4
[10:25:46.290]  - relaying element #4
[10:25:46.290] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.290] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.290] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.290]  length: 0 (resolved future 4)
[10:25:46.290] Relaying remaining futures
[10:25:46.291] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.291] - nx: 4
[10:25:46.291] - relay: TRUE
[10:25:46.291] - stdout: TRUE
[10:25:46.291] - signal: TRUE
[10:25:46.291] - resignal: FALSE
[10:25:46.291] - force: TRUE
[10:25:46.291] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.291] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:46.291] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:46.291] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:46.291] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.292] resolve() on environment ... DONE
<environment: 0x55c0f38705e0> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[10:25:46.292] plan(): Setting new future strategy stack:
[10:25:46.292] List of future strategies:
[10:25:46.292] 1. sequential:
[10:25:46.292]    - args: function (..., envir = parent.frame())
[10:25:46.292]    - tweaked: FALSE
[10:25:46.292]    - call: plan(strategy)
[10:25:46.293] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[10:25:46.293] getGlobalsAndPackages() ...
[10:25:46.293] Searching for globals...
[10:25:46.293] 
[10:25:46.294] Searching for globals ... DONE
[10:25:46.294] - globals: [0] <none>
[10:25:46.294] getGlobalsAndPackages() ... DONE
[10:25:46.294] run() for ‘Future’ ...
[10:25:46.294] - state: ‘created’
[10:25:46.294] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.294] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.295] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.295]   - Field: ‘label’
[10:25:46.295]   - Field: ‘local’
[10:25:46.295]   - Field: ‘owner’
[10:25:46.295]   - Field: ‘envir’
[10:25:46.295]   - Field: ‘packages’
[10:25:46.295]   - Field: ‘gc’
[10:25:46.295]   - Field: ‘conditions’
[10:25:46.295]   - Field: ‘expr’
[10:25:46.295]   - Field: ‘uuid’
[10:25:46.295]   - Field: ‘seed’
[10:25:46.295]   - Field: ‘version’
[10:25:46.296]   - Field: ‘result’
[10:25:46.296]   - Field: ‘asynchronous’
[10:25:46.296]   - Field: ‘calls’
[10:25:46.296]   - Field: ‘globals’
[10:25:46.296]   - Field: ‘stdout’
[10:25:46.296]   - Field: ‘earlySignal’
[10:25:46.296]   - Field: ‘lazy’
[10:25:46.296]   - Field: ‘state’
[10:25:46.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.296] - Launch lazy future ...
[10:25:46.297] Packages needed by the future expression (n = 0): <none>
[10:25:46.297] Packages needed by future strategies (n = 0): <none>
[10:25:46.297] {
[10:25:46.297]     {
[10:25:46.297]         {
[10:25:46.297]             ...future.startTime <- base::Sys.time()
[10:25:46.297]             {
[10:25:46.297]                 {
[10:25:46.297]                   {
[10:25:46.297]                     base::local({
[10:25:46.297]                       has_future <- base::requireNamespace("future", 
[10:25:46.297]                         quietly = TRUE)
[10:25:46.297]                       if (has_future) {
[10:25:46.297]                         ns <- base::getNamespace("future")
[10:25:46.297]                         version <- ns[[".package"]][["version"]]
[10:25:46.297]                         if (is.null(version)) 
[10:25:46.297]                           version <- utils::packageVersion("future")
[10:25:46.297]                       }
[10:25:46.297]                       else {
[10:25:46.297]                         version <- NULL
[10:25:46.297]                       }
[10:25:46.297]                       if (!has_future || version < "1.8.0") {
[10:25:46.297]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.297]                           "", base::R.version$version.string), 
[10:25:46.297]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.297]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.297]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.297]                             "release", "version")], collapse = " "), 
[10:25:46.297]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.297]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.297]                           info)
[10:25:46.297]                         info <- base::paste(info, collapse = "; ")
[10:25:46.297]                         if (!has_future) {
[10:25:46.297]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.297]                             info)
[10:25:46.297]                         }
[10:25:46.297]                         else {
[10:25:46.297]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.297]                             info, version)
[10:25:46.297]                         }
[10:25:46.297]                         base::stop(msg)
[10:25:46.297]                       }
[10:25:46.297]                     })
[10:25:46.297]                   }
[10:25:46.297]                   options(future.plan = NULL)
[10:25:46.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.297]                 }
[10:25:46.297]                 ...future.workdir <- getwd()
[10:25:46.297]             }
[10:25:46.297]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.297]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.297]         }
[10:25:46.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.297]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.297]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.297]             base::names(...future.oldOptions))
[10:25:46.297]     }
[10:25:46.297]     if (FALSE) {
[10:25:46.297]     }
[10:25:46.297]     else {
[10:25:46.297]         if (TRUE) {
[10:25:46.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.297]                 open = "w")
[10:25:46.297]         }
[10:25:46.297]         else {
[10:25:46.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.297]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.297]         }
[10:25:46.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.297]             base::sink(type = "output", split = FALSE)
[10:25:46.297]             base::close(...future.stdout)
[10:25:46.297]         }, add = TRUE)
[10:25:46.297]     }
[10:25:46.297]     ...future.frame <- base::sys.nframe()
[10:25:46.297]     ...future.conditions <- base::list()
[10:25:46.297]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.297]     if (FALSE) {
[10:25:46.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.297]     }
[10:25:46.297]     ...future.result <- base::tryCatch({
[10:25:46.297]         base::withCallingHandlers({
[10:25:46.297]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.297]             future::FutureResult(value = ...future.value$value, 
[10:25:46.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.297]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.297]                     ...future.globalenv.names))
[10:25:46.297]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.297]         }, condition = base::local({
[10:25:46.297]             c <- base::c
[10:25:46.297]             inherits <- base::inherits
[10:25:46.297]             invokeRestart <- base::invokeRestart
[10:25:46.297]             length <- base::length
[10:25:46.297]             list <- base::list
[10:25:46.297]             seq.int <- base::seq.int
[10:25:46.297]             signalCondition <- base::signalCondition
[10:25:46.297]             sys.calls <- base::sys.calls
[10:25:46.297]             `[[` <- base::`[[`
[10:25:46.297]             `+` <- base::`+`
[10:25:46.297]             `<<-` <- base::`<<-`
[10:25:46.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.297]                   3L)]
[10:25:46.297]             }
[10:25:46.297]             function(cond) {
[10:25:46.297]                 is_error <- inherits(cond, "error")
[10:25:46.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.297]                   NULL)
[10:25:46.297]                 if (is_error) {
[10:25:46.297]                   sessionInformation <- function() {
[10:25:46.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.297]                       search = base::search(), system = base::Sys.info())
[10:25:46.297]                   }
[10:25:46.297]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.297]                     cond$call), session = sessionInformation(), 
[10:25:46.297]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.297]                   signalCondition(cond)
[10:25:46.297]                 }
[10:25:46.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.297]                 "immediateCondition"))) {
[10:25:46.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.297]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.297]                   if (TRUE && !signal) {
[10:25:46.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.297]                     {
[10:25:46.297]                       inherits <- base::inherits
[10:25:46.297]                       invokeRestart <- base::invokeRestart
[10:25:46.297]                       is.null <- base::is.null
[10:25:46.297]                       muffled <- FALSE
[10:25:46.297]                       if (inherits(cond, "message")) {
[10:25:46.297]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.297]                         if (muffled) 
[10:25:46.297]                           invokeRestart("muffleMessage")
[10:25:46.297]                       }
[10:25:46.297]                       else if (inherits(cond, "warning")) {
[10:25:46.297]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.297]                         if (muffled) 
[10:25:46.297]                           invokeRestart("muffleWarning")
[10:25:46.297]                       }
[10:25:46.297]                       else if (inherits(cond, "condition")) {
[10:25:46.297]                         if (!is.null(pattern)) {
[10:25:46.297]                           computeRestarts <- base::computeRestarts
[10:25:46.297]                           grepl <- base::grepl
[10:25:46.297]                           restarts <- computeRestarts(cond)
[10:25:46.297]                           for (restart in restarts) {
[10:25:46.297]                             name <- restart$name
[10:25:46.297]                             if (is.null(name)) 
[10:25:46.297]                               next
[10:25:46.297]                             if (!grepl(pattern, name)) 
[10:25:46.297]                               next
[10:25:46.297]                             invokeRestart(restart)
[10:25:46.297]                             muffled <- TRUE
[10:25:46.297]                             break
[10:25:46.297]                           }
[10:25:46.297]                         }
[10:25:46.297]                       }
[10:25:46.297]                       invisible(muffled)
[10:25:46.297]                     }
[10:25:46.297]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.297]                   }
[10:25:46.297]                 }
[10:25:46.297]                 else {
[10:25:46.297]                   if (TRUE) {
[10:25:46.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.297]                     {
[10:25:46.297]                       inherits <- base::inherits
[10:25:46.297]                       invokeRestart <- base::invokeRestart
[10:25:46.297]                       is.null <- base::is.null
[10:25:46.297]                       muffled <- FALSE
[10:25:46.297]                       if (inherits(cond, "message")) {
[10:25:46.297]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.297]                         if (muffled) 
[10:25:46.297]                           invokeRestart("muffleMessage")
[10:25:46.297]                       }
[10:25:46.297]                       else if (inherits(cond, "warning")) {
[10:25:46.297]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.297]                         if (muffled) 
[10:25:46.297]                           invokeRestart("muffleWarning")
[10:25:46.297]                       }
[10:25:46.297]                       else if (inherits(cond, "condition")) {
[10:25:46.297]                         if (!is.null(pattern)) {
[10:25:46.297]                           computeRestarts <- base::computeRestarts
[10:25:46.297]                           grepl <- base::grepl
[10:25:46.297]                           restarts <- computeRestarts(cond)
[10:25:46.297]                           for (restart in restarts) {
[10:25:46.297]                             name <- restart$name
[10:25:46.297]                             if (is.null(name)) 
[10:25:46.297]                               next
[10:25:46.297]                             if (!grepl(pattern, name)) 
[10:25:46.297]                               next
[10:25:46.297]                             invokeRestart(restart)
[10:25:46.297]                             muffled <- TRUE
[10:25:46.297]                             break
[10:25:46.297]                           }
[10:25:46.297]                         }
[10:25:46.297]                       }
[10:25:46.297]                       invisible(muffled)
[10:25:46.297]                     }
[10:25:46.297]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.297]                   }
[10:25:46.297]                 }
[10:25:46.297]             }
[10:25:46.297]         }))
[10:25:46.297]     }, error = function(ex) {
[10:25:46.297]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.297]                 ...future.rng), started = ...future.startTime, 
[10:25:46.297]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.297]             version = "1.8"), class = "FutureResult")
[10:25:46.297]     }, finally = {
[10:25:46.297]         if (!identical(...future.workdir, getwd())) 
[10:25:46.297]             setwd(...future.workdir)
[10:25:46.297]         {
[10:25:46.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.297]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.297]             }
[10:25:46.297]             base::options(...future.oldOptions)
[10:25:46.297]             if (.Platform$OS.type == "windows") {
[10:25:46.297]                 old_names <- names(...future.oldEnvVars)
[10:25:46.297]                 envs <- base::Sys.getenv()
[10:25:46.297]                 names <- names(envs)
[10:25:46.297]                 common <- intersect(names, old_names)
[10:25:46.297]                 added <- setdiff(names, old_names)
[10:25:46.297]                 removed <- setdiff(old_names, names)
[10:25:46.297]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.297]                   envs[common]]
[10:25:46.297]                 NAMES <- toupper(changed)
[10:25:46.297]                 args <- list()
[10:25:46.297]                 for (kk in seq_along(NAMES)) {
[10:25:46.297]                   name <- changed[[kk]]
[10:25:46.297]                   NAME <- NAMES[[kk]]
[10:25:46.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.297]                     next
[10:25:46.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.297]                 }
[10:25:46.297]                 NAMES <- toupper(added)
[10:25:46.297]                 for (kk in seq_along(NAMES)) {
[10:25:46.297]                   name <- added[[kk]]
[10:25:46.297]                   NAME <- NAMES[[kk]]
[10:25:46.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.297]                     next
[10:25:46.297]                   args[[name]] <- ""
[10:25:46.297]                 }
[10:25:46.297]                 NAMES <- toupper(removed)
[10:25:46.297]                 for (kk in seq_along(NAMES)) {
[10:25:46.297]                   name <- removed[[kk]]
[10:25:46.297]                   NAME <- NAMES[[kk]]
[10:25:46.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.297]                     next
[10:25:46.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.297]                 }
[10:25:46.297]                 if (length(args) > 0) 
[10:25:46.297]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.297]             }
[10:25:46.297]             else {
[10:25:46.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.297]             }
[10:25:46.297]             {
[10:25:46.297]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.297]                   0L) {
[10:25:46.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.297]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.297]                   base::options(opts)
[10:25:46.297]                 }
[10:25:46.297]                 {
[10:25:46.297]                   {
[10:25:46.297]                     NULL
[10:25:46.297]                     RNGkind("Mersenne-Twister")
[10:25:46.297]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.297]                       inherits = FALSE)
[10:25:46.297]                   }
[10:25:46.297]                   options(future.plan = NULL)
[10:25:46.297]                   if (is.na(NA_character_)) 
[10:25:46.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.297]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.297]                   {
[10:25:46.297]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.297]                     if (!future$lazy) 
[10:25:46.297]                       future <- run(future)
[10:25:46.297]                     invisible(future)
[10:25:46.297]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.297]                 }
[10:25:46.297]             }
[10:25:46.297]         }
[10:25:46.297]     })
[10:25:46.297]     if (TRUE) {
[10:25:46.297]         base::sink(type = "output", split = FALSE)
[10:25:46.297]         if (TRUE) {
[10:25:46.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.297]         }
[10:25:46.297]         else {
[10:25:46.297]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.297]         }
[10:25:46.297]         base::close(...future.stdout)
[10:25:46.297]         ...future.stdout <- NULL
[10:25:46.297]     }
[10:25:46.297]     ...future.result$conditions <- ...future.conditions
[10:25:46.297]     ...future.result$finished <- base::Sys.time()
[10:25:46.297]     ...future.result
[10:25:46.297] }
[10:25:46.299] plan(): Setting new future strategy stack:
[10:25:46.299] List of future strategies:
[10:25:46.299] 1. sequential:
[10:25:46.299]    - args: function (..., envir = parent.frame())
[10:25:46.299]    - tweaked: FALSE
[10:25:46.299]    - call: NULL
[10:25:46.299] plan(): nbrOfWorkers() = 1
[10:25:46.300] plan(): Setting new future strategy stack:
[10:25:46.300] List of future strategies:
[10:25:46.300] 1. sequential:
[10:25:46.300]    - args: function (..., envir = parent.frame())
[10:25:46.300]    - tweaked: FALSE
[10:25:46.300]    - call: plan(strategy)
[10:25:46.300] plan(): nbrOfWorkers() = 1
[10:25:46.300] SequentialFuture started (and completed)
[10:25:46.300] - Launch lazy future ... done
[10:25:46.301] run() for ‘SequentialFuture’ ... done
[10:25:46.301] getGlobalsAndPackages() ...
[10:25:46.301] Searching for globals...
[10:25:46.301] 
[10:25:46.301] Searching for globals ... DONE
[10:25:46.301] - globals: [0] <none>
[10:25:46.301] getGlobalsAndPackages() ... DONE
[10:25:46.302] run() for ‘Future’ ...
[10:25:46.302] - state: ‘created’
[10:25:46.302] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.302] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.302]   - Field: ‘label’
[10:25:46.302]   - Field: ‘local’
[10:25:46.302]   - Field: ‘owner’
[10:25:46.304]   - Field: ‘envir’
[10:25:46.304]   - Field: ‘packages’
[10:25:46.304]   - Field: ‘gc’
[10:25:46.304]   - Field: ‘conditions’
[10:25:46.304]   - Field: ‘expr’
[10:25:46.304]   - Field: ‘uuid’
[10:25:46.304]   - Field: ‘seed’
[10:25:46.304]   - Field: ‘version’
[10:25:46.304]   - Field: ‘result’
[10:25:46.305]   - Field: ‘asynchronous’
[10:25:46.305]   - Field: ‘calls’
[10:25:46.305]   - Field: ‘globals’
[10:25:46.305]   - Field: ‘stdout’
[10:25:46.305]   - Field: ‘earlySignal’
[10:25:46.305]   - Field: ‘lazy’
[10:25:46.305]   - Field: ‘state’
[10:25:46.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.305] - Launch lazy future ...
[10:25:46.305] Packages needed by the future expression (n = 0): <none>
[10:25:46.305] Packages needed by future strategies (n = 0): <none>
[10:25:46.306] {
[10:25:46.306]     {
[10:25:46.306]         {
[10:25:46.306]             ...future.startTime <- base::Sys.time()
[10:25:46.306]             {
[10:25:46.306]                 {
[10:25:46.306]                   {
[10:25:46.306]                     base::local({
[10:25:46.306]                       has_future <- base::requireNamespace("future", 
[10:25:46.306]                         quietly = TRUE)
[10:25:46.306]                       if (has_future) {
[10:25:46.306]                         ns <- base::getNamespace("future")
[10:25:46.306]                         version <- ns[[".package"]][["version"]]
[10:25:46.306]                         if (is.null(version)) 
[10:25:46.306]                           version <- utils::packageVersion("future")
[10:25:46.306]                       }
[10:25:46.306]                       else {
[10:25:46.306]                         version <- NULL
[10:25:46.306]                       }
[10:25:46.306]                       if (!has_future || version < "1.8.0") {
[10:25:46.306]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.306]                           "", base::R.version$version.string), 
[10:25:46.306]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.306]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.306]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.306]                             "release", "version")], collapse = " "), 
[10:25:46.306]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.306]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.306]                           info)
[10:25:46.306]                         info <- base::paste(info, collapse = "; ")
[10:25:46.306]                         if (!has_future) {
[10:25:46.306]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.306]                             info)
[10:25:46.306]                         }
[10:25:46.306]                         else {
[10:25:46.306]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.306]                             info, version)
[10:25:46.306]                         }
[10:25:46.306]                         base::stop(msg)
[10:25:46.306]                       }
[10:25:46.306]                     })
[10:25:46.306]                   }
[10:25:46.306]                   options(future.plan = NULL)
[10:25:46.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.306]                 }
[10:25:46.306]                 ...future.workdir <- getwd()
[10:25:46.306]             }
[10:25:46.306]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.306]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.306]         }
[10:25:46.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.306]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.306]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.306]             base::names(...future.oldOptions))
[10:25:46.306]     }
[10:25:46.306]     if (FALSE) {
[10:25:46.306]     }
[10:25:46.306]     else {
[10:25:46.306]         if (TRUE) {
[10:25:46.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.306]                 open = "w")
[10:25:46.306]         }
[10:25:46.306]         else {
[10:25:46.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.306]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.306]         }
[10:25:46.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.306]             base::sink(type = "output", split = FALSE)
[10:25:46.306]             base::close(...future.stdout)
[10:25:46.306]         }, add = TRUE)
[10:25:46.306]     }
[10:25:46.306]     ...future.frame <- base::sys.nframe()
[10:25:46.306]     ...future.conditions <- base::list()
[10:25:46.306]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.306]     if (FALSE) {
[10:25:46.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.306]     }
[10:25:46.306]     ...future.result <- base::tryCatch({
[10:25:46.306]         base::withCallingHandlers({
[10:25:46.306]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.306]             future::FutureResult(value = ...future.value$value, 
[10:25:46.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.306]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.306]                     ...future.globalenv.names))
[10:25:46.306]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.306]         }, condition = base::local({
[10:25:46.306]             c <- base::c
[10:25:46.306]             inherits <- base::inherits
[10:25:46.306]             invokeRestart <- base::invokeRestart
[10:25:46.306]             length <- base::length
[10:25:46.306]             list <- base::list
[10:25:46.306]             seq.int <- base::seq.int
[10:25:46.306]             signalCondition <- base::signalCondition
[10:25:46.306]             sys.calls <- base::sys.calls
[10:25:46.306]             `[[` <- base::`[[`
[10:25:46.306]             `+` <- base::`+`
[10:25:46.306]             `<<-` <- base::`<<-`
[10:25:46.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.306]                   3L)]
[10:25:46.306]             }
[10:25:46.306]             function(cond) {
[10:25:46.306]                 is_error <- inherits(cond, "error")
[10:25:46.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.306]                   NULL)
[10:25:46.306]                 if (is_error) {
[10:25:46.306]                   sessionInformation <- function() {
[10:25:46.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.306]                       search = base::search(), system = base::Sys.info())
[10:25:46.306]                   }
[10:25:46.306]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.306]                     cond$call), session = sessionInformation(), 
[10:25:46.306]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.306]                   signalCondition(cond)
[10:25:46.306]                 }
[10:25:46.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.306]                 "immediateCondition"))) {
[10:25:46.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.306]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.306]                   if (TRUE && !signal) {
[10:25:46.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.306]                     {
[10:25:46.306]                       inherits <- base::inherits
[10:25:46.306]                       invokeRestart <- base::invokeRestart
[10:25:46.306]                       is.null <- base::is.null
[10:25:46.306]                       muffled <- FALSE
[10:25:46.306]                       if (inherits(cond, "message")) {
[10:25:46.306]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.306]                         if (muffled) 
[10:25:46.306]                           invokeRestart("muffleMessage")
[10:25:46.306]                       }
[10:25:46.306]                       else if (inherits(cond, "warning")) {
[10:25:46.306]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.306]                         if (muffled) 
[10:25:46.306]                           invokeRestart("muffleWarning")
[10:25:46.306]                       }
[10:25:46.306]                       else if (inherits(cond, "condition")) {
[10:25:46.306]                         if (!is.null(pattern)) {
[10:25:46.306]                           computeRestarts <- base::computeRestarts
[10:25:46.306]                           grepl <- base::grepl
[10:25:46.306]                           restarts <- computeRestarts(cond)
[10:25:46.306]                           for (restart in restarts) {
[10:25:46.306]                             name <- restart$name
[10:25:46.306]                             if (is.null(name)) 
[10:25:46.306]                               next
[10:25:46.306]                             if (!grepl(pattern, name)) 
[10:25:46.306]                               next
[10:25:46.306]                             invokeRestart(restart)
[10:25:46.306]                             muffled <- TRUE
[10:25:46.306]                             break
[10:25:46.306]                           }
[10:25:46.306]                         }
[10:25:46.306]                       }
[10:25:46.306]                       invisible(muffled)
[10:25:46.306]                     }
[10:25:46.306]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.306]                   }
[10:25:46.306]                 }
[10:25:46.306]                 else {
[10:25:46.306]                   if (TRUE) {
[10:25:46.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.306]                     {
[10:25:46.306]                       inherits <- base::inherits
[10:25:46.306]                       invokeRestart <- base::invokeRestart
[10:25:46.306]                       is.null <- base::is.null
[10:25:46.306]                       muffled <- FALSE
[10:25:46.306]                       if (inherits(cond, "message")) {
[10:25:46.306]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.306]                         if (muffled) 
[10:25:46.306]                           invokeRestart("muffleMessage")
[10:25:46.306]                       }
[10:25:46.306]                       else if (inherits(cond, "warning")) {
[10:25:46.306]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.306]                         if (muffled) 
[10:25:46.306]                           invokeRestart("muffleWarning")
[10:25:46.306]                       }
[10:25:46.306]                       else if (inherits(cond, "condition")) {
[10:25:46.306]                         if (!is.null(pattern)) {
[10:25:46.306]                           computeRestarts <- base::computeRestarts
[10:25:46.306]                           grepl <- base::grepl
[10:25:46.306]                           restarts <- computeRestarts(cond)
[10:25:46.306]                           for (restart in restarts) {
[10:25:46.306]                             name <- restart$name
[10:25:46.306]                             if (is.null(name)) 
[10:25:46.306]                               next
[10:25:46.306]                             if (!grepl(pattern, name)) 
[10:25:46.306]                               next
[10:25:46.306]                             invokeRestart(restart)
[10:25:46.306]                             muffled <- TRUE
[10:25:46.306]                             break
[10:25:46.306]                           }
[10:25:46.306]                         }
[10:25:46.306]                       }
[10:25:46.306]                       invisible(muffled)
[10:25:46.306]                     }
[10:25:46.306]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.306]                   }
[10:25:46.306]                 }
[10:25:46.306]             }
[10:25:46.306]         }))
[10:25:46.306]     }, error = function(ex) {
[10:25:46.306]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.306]                 ...future.rng), started = ...future.startTime, 
[10:25:46.306]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.306]             version = "1.8"), class = "FutureResult")
[10:25:46.306]     }, finally = {
[10:25:46.306]         if (!identical(...future.workdir, getwd())) 
[10:25:46.306]             setwd(...future.workdir)
[10:25:46.306]         {
[10:25:46.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.306]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.306]             }
[10:25:46.306]             base::options(...future.oldOptions)
[10:25:46.306]             if (.Platform$OS.type == "windows") {
[10:25:46.306]                 old_names <- names(...future.oldEnvVars)
[10:25:46.306]                 envs <- base::Sys.getenv()
[10:25:46.306]                 names <- names(envs)
[10:25:46.306]                 common <- intersect(names, old_names)
[10:25:46.306]                 added <- setdiff(names, old_names)
[10:25:46.306]                 removed <- setdiff(old_names, names)
[10:25:46.306]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.306]                   envs[common]]
[10:25:46.306]                 NAMES <- toupper(changed)
[10:25:46.306]                 args <- list()
[10:25:46.306]                 for (kk in seq_along(NAMES)) {
[10:25:46.306]                   name <- changed[[kk]]
[10:25:46.306]                   NAME <- NAMES[[kk]]
[10:25:46.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.306]                     next
[10:25:46.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.306]                 }
[10:25:46.306]                 NAMES <- toupper(added)
[10:25:46.306]                 for (kk in seq_along(NAMES)) {
[10:25:46.306]                   name <- added[[kk]]
[10:25:46.306]                   NAME <- NAMES[[kk]]
[10:25:46.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.306]                     next
[10:25:46.306]                   args[[name]] <- ""
[10:25:46.306]                 }
[10:25:46.306]                 NAMES <- toupper(removed)
[10:25:46.306]                 for (kk in seq_along(NAMES)) {
[10:25:46.306]                   name <- removed[[kk]]
[10:25:46.306]                   NAME <- NAMES[[kk]]
[10:25:46.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.306]                     next
[10:25:46.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.306]                 }
[10:25:46.306]                 if (length(args) > 0) 
[10:25:46.306]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.306]             }
[10:25:46.306]             else {
[10:25:46.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.306]             }
[10:25:46.306]             {
[10:25:46.306]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.306]                   0L) {
[10:25:46.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.306]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.306]                   base::options(opts)
[10:25:46.306]                 }
[10:25:46.306]                 {
[10:25:46.306]                   {
[10:25:46.306]                     NULL
[10:25:46.306]                     RNGkind("Mersenne-Twister")
[10:25:46.306]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.306]                       inherits = FALSE)
[10:25:46.306]                   }
[10:25:46.306]                   options(future.plan = NULL)
[10:25:46.306]                   if (is.na(NA_character_)) 
[10:25:46.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.306]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.306]                   {
[10:25:46.306]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.306]                     if (!future$lazy) 
[10:25:46.306]                       future <- run(future)
[10:25:46.306]                     invisible(future)
[10:25:46.306]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.306]                 }
[10:25:46.306]             }
[10:25:46.306]         }
[10:25:46.306]     })
[10:25:46.306]     if (TRUE) {
[10:25:46.306]         base::sink(type = "output", split = FALSE)
[10:25:46.306]         if (TRUE) {
[10:25:46.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.306]         }
[10:25:46.306]         else {
[10:25:46.306]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.306]         }
[10:25:46.306]         base::close(...future.stdout)
[10:25:46.306]         ...future.stdout <- NULL
[10:25:46.306]     }
[10:25:46.306]     ...future.result$conditions <- ...future.conditions
[10:25:46.306]     ...future.result$finished <- base::Sys.time()
[10:25:46.306]     ...future.result
[10:25:46.306] }
[10:25:46.308] plan(): Setting new future strategy stack:
[10:25:46.308] List of future strategies:
[10:25:46.308] 1. sequential:
[10:25:46.308]    - args: function (..., envir = parent.frame())
[10:25:46.308]    - tweaked: FALSE
[10:25:46.308]    - call: NULL
[10:25:46.308] plan(): nbrOfWorkers() = 1
[10:25:46.309] plan(): Setting new future strategy stack:
[10:25:46.309] List of future strategies:
[10:25:46.309] 1. sequential:
[10:25:46.309]    - args: function (..., envir = parent.frame())
[10:25:46.309]    - tweaked: FALSE
[10:25:46.309]    - call: plan(strategy)
[10:25:46.309] plan(): nbrOfWorkers() = 1
[10:25:46.309] SequentialFuture started (and completed)
[10:25:46.309] - Launch lazy future ... done
[10:25:46.309] run() for ‘SequentialFuture’ ... done
[10:25:46.310] getGlobalsAndPackages() ...
[10:25:46.310] Searching for globals...
[10:25:46.311] - globals found: [1] ‘{’
[10:25:46.311] Searching for globals ... DONE
[10:25:46.311] Resolving globals: FALSE
[10:25:46.311] 
[10:25:46.311] 
[10:25:46.311] getGlobalsAndPackages() ... DONE
[10:25:46.311] run() for ‘Future’ ...
[10:25:46.312] - state: ‘created’
[10:25:46.312] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.312] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.312] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.312]   - Field: ‘label’
[10:25:46.312]   - Field: ‘local’
[10:25:46.312]   - Field: ‘owner’
[10:25:46.312]   - Field: ‘envir’
[10:25:46.312]   - Field: ‘packages’
[10:25:46.313]   - Field: ‘gc’
[10:25:46.313]   - Field: ‘conditions’
[10:25:46.313]   - Field: ‘expr’
[10:25:46.313]   - Field: ‘uuid’
[10:25:46.313]   - Field: ‘seed’
[10:25:46.313]   - Field: ‘version’
[10:25:46.313]   - Field: ‘result’
[10:25:46.313]   - Field: ‘asynchronous’
[10:25:46.313]   - Field: ‘calls’
[10:25:46.313]   - Field: ‘globals’
[10:25:46.313]   - Field: ‘stdout’
[10:25:46.313]   - Field: ‘earlySignal’
[10:25:46.314]   - Field: ‘lazy’
[10:25:46.314]   - Field: ‘state’
[10:25:46.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.314] - Launch lazy future ...
[10:25:46.314] Packages needed by the future expression (n = 0): <none>
[10:25:46.314] Packages needed by future strategies (n = 0): <none>
[10:25:46.314] {
[10:25:46.314]     {
[10:25:46.314]         {
[10:25:46.314]             ...future.startTime <- base::Sys.time()
[10:25:46.314]             {
[10:25:46.314]                 {
[10:25:46.314]                   {
[10:25:46.314]                     base::local({
[10:25:46.314]                       has_future <- base::requireNamespace("future", 
[10:25:46.314]                         quietly = TRUE)
[10:25:46.314]                       if (has_future) {
[10:25:46.314]                         ns <- base::getNamespace("future")
[10:25:46.314]                         version <- ns[[".package"]][["version"]]
[10:25:46.314]                         if (is.null(version)) 
[10:25:46.314]                           version <- utils::packageVersion("future")
[10:25:46.314]                       }
[10:25:46.314]                       else {
[10:25:46.314]                         version <- NULL
[10:25:46.314]                       }
[10:25:46.314]                       if (!has_future || version < "1.8.0") {
[10:25:46.314]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.314]                           "", base::R.version$version.string), 
[10:25:46.314]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.314]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.314]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.314]                             "release", "version")], collapse = " "), 
[10:25:46.314]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.314]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.314]                           info)
[10:25:46.314]                         info <- base::paste(info, collapse = "; ")
[10:25:46.314]                         if (!has_future) {
[10:25:46.314]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.314]                             info)
[10:25:46.314]                         }
[10:25:46.314]                         else {
[10:25:46.314]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.314]                             info, version)
[10:25:46.314]                         }
[10:25:46.314]                         base::stop(msg)
[10:25:46.314]                       }
[10:25:46.314]                     })
[10:25:46.314]                   }
[10:25:46.314]                   options(future.plan = NULL)
[10:25:46.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.314]                 }
[10:25:46.314]                 ...future.workdir <- getwd()
[10:25:46.314]             }
[10:25:46.314]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.314]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.314]         }
[10:25:46.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.314]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.314]             base::names(...future.oldOptions))
[10:25:46.314]     }
[10:25:46.314]     if (FALSE) {
[10:25:46.314]     }
[10:25:46.314]     else {
[10:25:46.314]         if (TRUE) {
[10:25:46.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.314]                 open = "w")
[10:25:46.314]         }
[10:25:46.314]         else {
[10:25:46.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.314]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.314]         }
[10:25:46.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.314]             base::sink(type = "output", split = FALSE)
[10:25:46.314]             base::close(...future.stdout)
[10:25:46.314]         }, add = TRUE)
[10:25:46.314]     }
[10:25:46.314]     ...future.frame <- base::sys.nframe()
[10:25:46.314]     ...future.conditions <- base::list()
[10:25:46.314]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.314]     if (FALSE) {
[10:25:46.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.314]     }
[10:25:46.314]     ...future.result <- base::tryCatch({
[10:25:46.314]         base::withCallingHandlers({
[10:25:46.314]             ...future.value <- base::withVisible(base::local({
[10:25:46.314]                 4
[10:25:46.314]             }))
[10:25:46.314]             future::FutureResult(value = ...future.value$value, 
[10:25:46.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.314]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.314]                     ...future.globalenv.names))
[10:25:46.314]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.314]         }, condition = base::local({
[10:25:46.314]             c <- base::c
[10:25:46.314]             inherits <- base::inherits
[10:25:46.314]             invokeRestart <- base::invokeRestart
[10:25:46.314]             length <- base::length
[10:25:46.314]             list <- base::list
[10:25:46.314]             seq.int <- base::seq.int
[10:25:46.314]             signalCondition <- base::signalCondition
[10:25:46.314]             sys.calls <- base::sys.calls
[10:25:46.314]             `[[` <- base::`[[`
[10:25:46.314]             `+` <- base::`+`
[10:25:46.314]             `<<-` <- base::`<<-`
[10:25:46.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.314]                   3L)]
[10:25:46.314]             }
[10:25:46.314]             function(cond) {
[10:25:46.314]                 is_error <- inherits(cond, "error")
[10:25:46.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.314]                   NULL)
[10:25:46.314]                 if (is_error) {
[10:25:46.314]                   sessionInformation <- function() {
[10:25:46.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.314]                       search = base::search(), system = base::Sys.info())
[10:25:46.314]                   }
[10:25:46.314]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.314]                     cond$call), session = sessionInformation(), 
[10:25:46.314]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.314]                   signalCondition(cond)
[10:25:46.314]                 }
[10:25:46.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.314]                 "immediateCondition"))) {
[10:25:46.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.314]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.314]                   if (TRUE && !signal) {
[10:25:46.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.314]                     {
[10:25:46.314]                       inherits <- base::inherits
[10:25:46.314]                       invokeRestart <- base::invokeRestart
[10:25:46.314]                       is.null <- base::is.null
[10:25:46.314]                       muffled <- FALSE
[10:25:46.314]                       if (inherits(cond, "message")) {
[10:25:46.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.314]                         if (muffled) 
[10:25:46.314]                           invokeRestart("muffleMessage")
[10:25:46.314]                       }
[10:25:46.314]                       else if (inherits(cond, "warning")) {
[10:25:46.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.314]                         if (muffled) 
[10:25:46.314]                           invokeRestart("muffleWarning")
[10:25:46.314]                       }
[10:25:46.314]                       else if (inherits(cond, "condition")) {
[10:25:46.314]                         if (!is.null(pattern)) {
[10:25:46.314]                           computeRestarts <- base::computeRestarts
[10:25:46.314]                           grepl <- base::grepl
[10:25:46.314]                           restarts <- computeRestarts(cond)
[10:25:46.314]                           for (restart in restarts) {
[10:25:46.314]                             name <- restart$name
[10:25:46.314]                             if (is.null(name)) 
[10:25:46.314]                               next
[10:25:46.314]                             if (!grepl(pattern, name)) 
[10:25:46.314]                               next
[10:25:46.314]                             invokeRestart(restart)
[10:25:46.314]                             muffled <- TRUE
[10:25:46.314]                             break
[10:25:46.314]                           }
[10:25:46.314]                         }
[10:25:46.314]                       }
[10:25:46.314]                       invisible(muffled)
[10:25:46.314]                     }
[10:25:46.314]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.314]                   }
[10:25:46.314]                 }
[10:25:46.314]                 else {
[10:25:46.314]                   if (TRUE) {
[10:25:46.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.314]                     {
[10:25:46.314]                       inherits <- base::inherits
[10:25:46.314]                       invokeRestart <- base::invokeRestart
[10:25:46.314]                       is.null <- base::is.null
[10:25:46.314]                       muffled <- FALSE
[10:25:46.314]                       if (inherits(cond, "message")) {
[10:25:46.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.314]                         if (muffled) 
[10:25:46.314]                           invokeRestart("muffleMessage")
[10:25:46.314]                       }
[10:25:46.314]                       else if (inherits(cond, "warning")) {
[10:25:46.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.314]                         if (muffled) 
[10:25:46.314]                           invokeRestart("muffleWarning")
[10:25:46.314]                       }
[10:25:46.314]                       else if (inherits(cond, "condition")) {
[10:25:46.314]                         if (!is.null(pattern)) {
[10:25:46.314]                           computeRestarts <- base::computeRestarts
[10:25:46.314]                           grepl <- base::grepl
[10:25:46.314]                           restarts <- computeRestarts(cond)
[10:25:46.314]                           for (restart in restarts) {
[10:25:46.314]                             name <- restart$name
[10:25:46.314]                             if (is.null(name)) 
[10:25:46.314]                               next
[10:25:46.314]                             if (!grepl(pattern, name)) 
[10:25:46.314]                               next
[10:25:46.314]                             invokeRestart(restart)
[10:25:46.314]                             muffled <- TRUE
[10:25:46.314]                             break
[10:25:46.314]                           }
[10:25:46.314]                         }
[10:25:46.314]                       }
[10:25:46.314]                       invisible(muffled)
[10:25:46.314]                     }
[10:25:46.314]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.314]                   }
[10:25:46.314]                 }
[10:25:46.314]             }
[10:25:46.314]         }))
[10:25:46.314]     }, error = function(ex) {
[10:25:46.314]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.314]                 ...future.rng), started = ...future.startTime, 
[10:25:46.314]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.314]             version = "1.8"), class = "FutureResult")
[10:25:46.314]     }, finally = {
[10:25:46.314]         if (!identical(...future.workdir, getwd())) 
[10:25:46.314]             setwd(...future.workdir)
[10:25:46.314]         {
[10:25:46.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.314]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.314]             }
[10:25:46.314]             base::options(...future.oldOptions)
[10:25:46.314]             if (.Platform$OS.type == "windows") {
[10:25:46.314]                 old_names <- names(...future.oldEnvVars)
[10:25:46.314]                 envs <- base::Sys.getenv()
[10:25:46.314]                 names <- names(envs)
[10:25:46.314]                 common <- intersect(names, old_names)
[10:25:46.314]                 added <- setdiff(names, old_names)
[10:25:46.314]                 removed <- setdiff(old_names, names)
[10:25:46.314]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.314]                   envs[common]]
[10:25:46.314]                 NAMES <- toupper(changed)
[10:25:46.314]                 args <- list()
[10:25:46.314]                 for (kk in seq_along(NAMES)) {
[10:25:46.314]                   name <- changed[[kk]]
[10:25:46.314]                   NAME <- NAMES[[kk]]
[10:25:46.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.314]                     next
[10:25:46.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.314]                 }
[10:25:46.314]                 NAMES <- toupper(added)
[10:25:46.314]                 for (kk in seq_along(NAMES)) {
[10:25:46.314]                   name <- added[[kk]]
[10:25:46.314]                   NAME <- NAMES[[kk]]
[10:25:46.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.314]                     next
[10:25:46.314]                   args[[name]] <- ""
[10:25:46.314]                 }
[10:25:46.314]                 NAMES <- toupper(removed)
[10:25:46.314]                 for (kk in seq_along(NAMES)) {
[10:25:46.314]                   name <- removed[[kk]]
[10:25:46.314]                   NAME <- NAMES[[kk]]
[10:25:46.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.314]                     next
[10:25:46.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.314]                 }
[10:25:46.314]                 if (length(args) > 0) 
[10:25:46.314]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.314]             }
[10:25:46.314]             else {
[10:25:46.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.314]             }
[10:25:46.314]             {
[10:25:46.314]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.314]                   0L) {
[10:25:46.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.314]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.314]                   base::options(opts)
[10:25:46.314]                 }
[10:25:46.314]                 {
[10:25:46.314]                   {
[10:25:46.314]                     NULL
[10:25:46.314]                     RNGkind("Mersenne-Twister")
[10:25:46.314]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.314]                       inherits = FALSE)
[10:25:46.314]                   }
[10:25:46.314]                   options(future.plan = NULL)
[10:25:46.314]                   if (is.na(NA_character_)) 
[10:25:46.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.314]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.314]                   {
[10:25:46.314]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.314]                     if (!future$lazy) 
[10:25:46.314]                       future <- run(future)
[10:25:46.314]                     invisible(future)
[10:25:46.314]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.314]                 }
[10:25:46.314]             }
[10:25:46.314]         }
[10:25:46.314]     })
[10:25:46.314]     if (TRUE) {
[10:25:46.314]         base::sink(type = "output", split = FALSE)
[10:25:46.314]         if (TRUE) {
[10:25:46.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.314]         }
[10:25:46.314]         else {
[10:25:46.314]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.314]         }
[10:25:46.314]         base::close(...future.stdout)
[10:25:46.314]         ...future.stdout <- NULL
[10:25:46.314]     }
[10:25:46.314]     ...future.result$conditions <- ...future.conditions
[10:25:46.314]     ...future.result$finished <- base::Sys.time()
[10:25:46.314]     ...future.result
[10:25:46.314] }
[10:25:46.316] plan(): Setting new future strategy stack:
[10:25:46.316] List of future strategies:
[10:25:46.316] 1. sequential:
[10:25:46.316]    - args: function (..., envir = parent.frame())
[10:25:46.316]    - tweaked: FALSE
[10:25:46.316]    - call: NULL
[10:25:46.317] plan(): nbrOfWorkers() = 1
[10:25:46.317] plan(): Setting new future strategy stack:
[10:25:46.317] List of future strategies:
[10:25:46.317] 1. sequential:
[10:25:46.317]    - args: function (..., envir = parent.frame())
[10:25:46.317]    - tweaked: FALSE
[10:25:46.317]    - call: plan(strategy)
[10:25:46.318] plan(): nbrOfWorkers() = 1
[10:25:46.318] SequentialFuture started (and completed)
[10:25:46.318] - Launch lazy future ... done
[10:25:46.318] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f50f20d0> 
Classes 'listenv', 'environment' <environment: 0x55c0f5042900> 
[10:25:46.321] resolved() for ‘SequentialFuture’ ...
[10:25:46.321] - state: ‘finished’
[10:25:46.321] - run: TRUE
[10:25:46.321] - result: ‘FutureResult’
[10:25:46.321] resolved() for ‘SequentialFuture’ ... done
[10:25:46.322] resolved() for ‘SequentialFuture’ ...
[10:25:46.322] - state: ‘finished’
[10:25:46.322] - run: TRUE
[10:25:46.322] - result: ‘FutureResult’
[10:25:46.322] resolved() for ‘SequentialFuture’ ... done
[10:25:46.322] resolved() for ‘SequentialFuture’ ...
[10:25:46.322] - state: ‘finished’
[10:25:46.322] - run: TRUE
[10:25:46.322] - result: ‘FutureResult’
[10:25:46.322] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:46.324] resolve() on list environment ...
[10:25:46.324]  recursive: 0
[10:25:46.325]  length: 6
[10:25:46.325]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:46.325] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.325] - nx: 6
[10:25:46.325] - relay: TRUE
[10:25:46.325] - stdout: TRUE
[10:25:46.326] - signal: TRUE
[10:25:46.326] - resignal: FALSE
[10:25:46.326] - force: TRUE
[10:25:46.326] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.326] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.326]  - until=2
[10:25:46.326]  - relaying element #2
[10:25:46.326] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.326] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.326] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.326]  length: 5 (resolved future 1)
[10:25:46.326] resolved() for ‘SequentialFuture’ ...
[10:25:46.327] - state: ‘finished’
[10:25:46.327] - run: TRUE
[10:25:46.327] - result: ‘FutureResult’
[10:25:46.327] resolved() for ‘SequentialFuture’ ... done
[10:25:46.327] Future #2
[10:25:46.327] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.327] - nx: 6
[10:25:46.327] - relay: TRUE
[10:25:46.327] - stdout: TRUE
[10:25:46.327] - signal: TRUE
[10:25:46.327] - resignal: FALSE
[10:25:46.328] - force: TRUE
[10:25:46.328] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.329] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.329]  - until=2
[10:25:46.329]  - relaying element #2
[10:25:46.329] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.329] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.330] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.330]  length: 4 (resolved future 2)
[10:25:46.330] resolved() for ‘SequentialFuture’ ...
[10:25:46.330] - state: ‘finished’
[10:25:46.330] - run: TRUE
[10:25:46.330] - result: ‘FutureResult’
[10:25:46.330] resolved() for ‘SequentialFuture’ ... done
[10:25:46.330] Future #3
[10:25:46.330] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.330] - nx: 6
[10:25:46.331] - relay: TRUE
[10:25:46.331] - stdout: TRUE
[10:25:46.331] - signal: TRUE
[10:25:46.331] - resignal: FALSE
[10:25:46.331] - force: TRUE
[10:25:46.331] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.331] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.331]  - until=3
[10:25:46.331]  - relaying element #3
[10:25:46.331] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.331] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.332] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.332]  length: 3 (resolved future 3)
[10:25:46.332] resolved() for ‘SequentialFuture’ ...
[10:25:46.332] - state: ‘finished’
[10:25:46.332] - run: TRUE
[10:25:46.332] - result: ‘FutureResult’
[10:25:46.332] resolved() for ‘SequentialFuture’ ... done
[10:25:46.332] Future #4
[10:25:46.332] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.332] - nx: 6
[10:25:46.332] - relay: TRUE
[10:25:46.333] - stdout: TRUE
[10:25:46.333] - signal: TRUE
[10:25:46.333] - resignal: FALSE
[10:25:46.333] - force: TRUE
[10:25:46.333] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.333] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.333]  - until=4
[10:25:46.333]  - relaying element #4
[10:25:46.333] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.333] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.333] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.334]  length: 2 (resolved future 4)
[10:25:46.334] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.334] - nx: 6
[10:25:46.334] - relay: TRUE
[10:25:46.334] - stdout: TRUE
[10:25:46.334] - signal: TRUE
[10:25:46.334] - resignal: FALSE
[10:25:46.334] - force: TRUE
[10:25:46.334] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.334] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.334]  - until=6
[10:25:46.334]  - relaying element #6
[10:25:46.335] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.335] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.335] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.335]  length: 1 (resolved future 5)
[10:25:46.335] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.335] - nx: 6
[10:25:46.335] - relay: TRUE
[10:25:46.335] - stdout: TRUE
[10:25:46.335] - signal: TRUE
[10:25:46.335] - resignal: FALSE
[10:25:46.335] - force: TRUE
[10:25:46.335] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.336] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.336]  - until=6
[10:25:46.336] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.336] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.336] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.336]  length: 0 (resolved future 6)
[10:25:46.336] Relaying remaining futures
[10:25:46.336] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.336] - nx: 6
[10:25:46.336] - relay: TRUE
[10:25:46.336] - stdout: TRUE
[10:25:46.336] - signal: TRUE
[10:25:46.336] - resignal: FALSE
[10:25:46.337] - force: TRUE
[10:25:46.337] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.337] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:46.337] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.337] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.337] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.337] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c0f5385590> 
Dimensions: c(1, 6)
[10:25:46.338] getGlobalsAndPackages() ...
[10:25:46.338] Searching for globals...
[10:25:46.338] 
[10:25:46.338] Searching for globals ... DONE
[10:25:46.338] - globals: [0] <none>
[10:25:46.338] getGlobalsAndPackages() ... DONE
[10:25:46.339] run() for ‘Future’ ...
[10:25:46.339] - state: ‘created’
[10:25:46.339] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.339] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.339] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.339]   - Field: ‘label’
[10:25:46.339]   - Field: ‘local’
[10:25:46.340]   - Field: ‘owner’
[10:25:46.340]   - Field: ‘envir’
[10:25:46.340]   - Field: ‘packages’
[10:25:46.340]   - Field: ‘gc’
[10:25:46.340]   - Field: ‘conditions’
[10:25:46.340]   - Field: ‘expr’
[10:25:46.340]   - Field: ‘uuid’
[10:25:46.340]   - Field: ‘seed’
[10:25:46.340]   - Field: ‘version’
[10:25:46.340]   - Field: ‘result’
[10:25:46.340]   - Field: ‘asynchronous’
[10:25:46.340]   - Field: ‘calls’
[10:25:46.341]   - Field: ‘globals’
[10:25:46.341]   - Field: ‘stdout’
[10:25:46.341]   - Field: ‘earlySignal’
[10:25:46.341]   - Field: ‘lazy’
[10:25:46.341]   - Field: ‘state’
[10:25:46.341] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.341] - Launch lazy future ...
[10:25:46.341] Packages needed by the future expression (n = 0): <none>
[10:25:46.341] Packages needed by future strategies (n = 0): <none>
[10:25:46.342] {
[10:25:46.342]     {
[10:25:46.342]         {
[10:25:46.342]             ...future.startTime <- base::Sys.time()
[10:25:46.342]             {
[10:25:46.342]                 {
[10:25:46.342]                   {
[10:25:46.342]                     base::local({
[10:25:46.342]                       has_future <- base::requireNamespace("future", 
[10:25:46.342]                         quietly = TRUE)
[10:25:46.342]                       if (has_future) {
[10:25:46.342]                         ns <- base::getNamespace("future")
[10:25:46.342]                         version <- ns[[".package"]][["version"]]
[10:25:46.342]                         if (is.null(version)) 
[10:25:46.342]                           version <- utils::packageVersion("future")
[10:25:46.342]                       }
[10:25:46.342]                       else {
[10:25:46.342]                         version <- NULL
[10:25:46.342]                       }
[10:25:46.342]                       if (!has_future || version < "1.8.0") {
[10:25:46.342]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.342]                           "", base::R.version$version.string), 
[10:25:46.342]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.342]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.342]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.342]                             "release", "version")], collapse = " "), 
[10:25:46.342]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.342]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.342]                           info)
[10:25:46.342]                         info <- base::paste(info, collapse = "; ")
[10:25:46.342]                         if (!has_future) {
[10:25:46.342]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.342]                             info)
[10:25:46.342]                         }
[10:25:46.342]                         else {
[10:25:46.342]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.342]                             info, version)
[10:25:46.342]                         }
[10:25:46.342]                         base::stop(msg)
[10:25:46.342]                       }
[10:25:46.342]                     })
[10:25:46.342]                   }
[10:25:46.342]                   options(future.plan = NULL)
[10:25:46.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.342]                 }
[10:25:46.342]                 ...future.workdir <- getwd()
[10:25:46.342]             }
[10:25:46.342]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.342]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.342]         }
[10:25:46.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.342]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.342]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.342]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.342]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.342]             base::names(...future.oldOptions))
[10:25:46.342]     }
[10:25:46.342]     if (FALSE) {
[10:25:46.342]     }
[10:25:46.342]     else {
[10:25:46.342]         if (TRUE) {
[10:25:46.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.342]                 open = "w")
[10:25:46.342]         }
[10:25:46.342]         else {
[10:25:46.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.342]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.342]         }
[10:25:46.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.342]             base::sink(type = "output", split = FALSE)
[10:25:46.342]             base::close(...future.stdout)
[10:25:46.342]         }, add = TRUE)
[10:25:46.342]     }
[10:25:46.342]     ...future.frame <- base::sys.nframe()
[10:25:46.342]     ...future.conditions <- base::list()
[10:25:46.342]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.342]     if (FALSE) {
[10:25:46.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.342]     }
[10:25:46.342]     ...future.result <- base::tryCatch({
[10:25:46.342]         base::withCallingHandlers({
[10:25:46.342]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.342]             future::FutureResult(value = ...future.value$value, 
[10:25:46.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.342]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.342]                     ...future.globalenv.names))
[10:25:46.342]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.342]         }, condition = base::local({
[10:25:46.342]             c <- base::c
[10:25:46.342]             inherits <- base::inherits
[10:25:46.342]             invokeRestart <- base::invokeRestart
[10:25:46.342]             length <- base::length
[10:25:46.342]             list <- base::list
[10:25:46.342]             seq.int <- base::seq.int
[10:25:46.342]             signalCondition <- base::signalCondition
[10:25:46.342]             sys.calls <- base::sys.calls
[10:25:46.342]             `[[` <- base::`[[`
[10:25:46.342]             `+` <- base::`+`
[10:25:46.342]             `<<-` <- base::`<<-`
[10:25:46.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.342]                   3L)]
[10:25:46.342]             }
[10:25:46.342]             function(cond) {
[10:25:46.342]                 is_error <- inherits(cond, "error")
[10:25:46.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.342]                   NULL)
[10:25:46.342]                 if (is_error) {
[10:25:46.342]                   sessionInformation <- function() {
[10:25:46.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.342]                       search = base::search(), system = base::Sys.info())
[10:25:46.342]                   }
[10:25:46.342]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.342]                     cond$call), session = sessionInformation(), 
[10:25:46.342]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.342]                   signalCondition(cond)
[10:25:46.342]                 }
[10:25:46.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.342]                 "immediateCondition"))) {
[10:25:46.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.342]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.342]                   if (TRUE && !signal) {
[10:25:46.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.342]                     {
[10:25:46.342]                       inherits <- base::inherits
[10:25:46.342]                       invokeRestart <- base::invokeRestart
[10:25:46.342]                       is.null <- base::is.null
[10:25:46.342]                       muffled <- FALSE
[10:25:46.342]                       if (inherits(cond, "message")) {
[10:25:46.342]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.342]                         if (muffled) 
[10:25:46.342]                           invokeRestart("muffleMessage")
[10:25:46.342]                       }
[10:25:46.342]                       else if (inherits(cond, "warning")) {
[10:25:46.342]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.342]                         if (muffled) 
[10:25:46.342]                           invokeRestart("muffleWarning")
[10:25:46.342]                       }
[10:25:46.342]                       else if (inherits(cond, "condition")) {
[10:25:46.342]                         if (!is.null(pattern)) {
[10:25:46.342]                           computeRestarts <- base::computeRestarts
[10:25:46.342]                           grepl <- base::grepl
[10:25:46.342]                           restarts <- computeRestarts(cond)
[10:25:46.342]                           for (restart in restarts) {
[10:25:46.342]                             name <- restart$name
[10:25:46.342]                             if (is.null(name)) 
[10:25:46.342]                               next
[10:25:46.342]                             if (!grepl(pattern, name)) 
[10:25:46.342]                               next
[10:25:46.342]                             invokeRestart(restart)
[10:25:46.342]                             muffled <- TRUE
[10:25:46.342]                             break
[10:25:46.342]                           }
[10:25:46.342]                         }
[10:25:46.342]                       }
[10:25:46.342]                       invisible(muffled)
[10:25:46.342]                     }
[10:25:46.342]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.342]                   }
[10:25:46.342]                 }
[10:25:46.342]                 else {
[10:25:46.342]                   if (TRUE) {
[10:25:46.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.342]                     {
[10:25:46.342]                       inherits <- base::inherits
[10:25:46.342]                       invokeRestart <- base::invokeRestart
[10:25:46.342]                       is.null <- base::is.null
[10:25:46.342]                       muffled <- FALSE
[10:25:46.342]                       if (inherits(cond, "message")) {
[10:25:46.342]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.342]                         if (muffled) 
[10:25:46.342]                           invokeRestart("muffleMessage")
[10:25:46.342]                       }
[10:25:46.342]                       else if (inherits(cond, "warning")) {
[10:25:46.342]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.342]                         if (muffled) 
[10:25:46.342]                           invokeRestart("muffleWarning")
[10:25:46.342]                       }
[10:25:46.342]                       else if (inherits(cond, "condition")) {
[10:25:46.342]                         if (!is.null(pattern)) {
[10:25:46.342]                           computeRestarts <- base::computeRestarts
[10:25:46.342]                           grepl <- base::grepl
[10:25:46.342]                           restarts <- computeRestarts(cond)
[10:25:46.342]                           for (restart in restarts) {
[10:25:46.342]                             name <- restart$name
[10:25:46.342]                             if (is.null(name)) 
[10:25:46.342]                               next
[10:25:46.342]                             if (!grepl(pattern, name)) 
[10:25:46.342]                               next
[10:25:46.342]                             invokeRestart(restart)
[10:25:46.342]                             muffled <- TRUE
[10:25:46.342]                             break
[10:25:46.342]                           }
[10:25:46.342]                         }
[10:25:46.342]                       }
[10:25:46.342]                       invisible(muffled)
[10:25:46.342]                     }
[10:25:46.342]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.342]                   }
[10:25:46.342]                 }
[10:25:46.342]             }
[10:25:46.342]         }))
[10:25:46.342]     }, error = function(ex) {
[10:25:46.342]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.342]                 ...future.rng), started = ...future.startTime, 
[10:25:46.342]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.342]             version = "1.8"), class = "FutureResult")
[10:25:46.342]     }, finally = {
[10:25:46.342]         if (!identical(...future.workdir, getwd())) 
[10:25:46.342]             setwd(...future.workdir)
[10:25:46.342]         {
[10:25:46.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.342]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.342]             }
[10:25:46.342]             base::options(...future.oldOptions)
[10:25:46.342]             if (.Platform$OS.type == "windows") {
[10:25:46.342]                 old_names <- names(...future.oldEnvVars)
[10:25:46.342]                 envs <- base::Sys.getenv()
[10:25:46.342]                 names <- names(envs)
[10:25:46.342]                 common <- intersect(names, old_names)
[10:25:46.342]                 added <- setdiff(names, old_names)
[10:25:46.342]                 removed <- setdiff(old_names, names)
[10:25:46.342]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.342]                   envs[common]]
[10:25:46.342]                 NAMES <- toupper(changed)
[10:25:46.342]                 args <- list()
[10:25:46.342]                 for (kk in seq_along(NAMES)) {
[10:25:46.342]                   name <- changed[[kk]]
[10:25:46.342]                   NAME <- NAMES[[kk]]
[10:25:46.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.342]                     next
[10:25:46.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.342]                 }
[10:25:46.342]                 NAMES <- toupper(added)
[10:25:46.342]                 for (kk in seq_along(NAMES)) {
[10:25:46.342]                   name <- added[[kk]]
[10:25:46.342]                   NAME <- NAMES[[kk]]
[10:25:46.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.342]                     next
[10:25:46.342]                   args[[name]] <- ""
[10:25:46.342]                 }
[10:25:46.342]                 NAMES <- toupper(removed)
[10:25:46.342]                 for (kk in seq_along(NAMES)) {
[10:25:46.342]                   name <- removed[[kk]]
[10:25:46.342]                   NAME <- NAMES[[kk]]
[10:25:46.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.342]                     next
[10:25:46.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.342]                 }
[10:25:46.342]                 if (length(args) > 0) 
[10:25:46.342]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.342]             }
[10:25:46.342]             else {
[10:25:46.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.342]             }
[10:25:46.342]             {
[10:25:46.342]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.342]                   0L) {
[10:25:46.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.342]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.342]                   base::options(opts)
[10:25:46.342]                 }
[10:25:46.342]                 {
[10:25:46.342]                   {
[10:25:46.342]                     NULL
[10:25:46.342]                     RNGkind("Mersenne-Twister")
[10:25:46.342]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.342]                       inherits = FALSE)
[10:25:46.342]                   }
[10:25:46.342]                   options(future.plan = NULL)
[10:25:46.342]                   if (is.na(NA_character_)) 
[10:25:46.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.342]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.342]                   {
[10:25:46.342]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.342]                     if (!future$lazy) 
[10:25:46.342]                       future <- run(future)
[10:25:46.342]                     invisible(future)
[10:25:46.342]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.342]                 }
[10:25:46.342]             }
[10:25:46.342]         }
[10:25:46.342]     })
[10:25:46.342]     if (TRUE) {
[10:25:46.342]         base::sink(type = "output", split = FALSE)
[10:25:46.342]         if (TRUE) {
[10:25:46.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.342]         }
[10:25:46.342]         else {
[10:25:46.342]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.342]         }
[10:25:46.342]         base::close(...future.stdout)
[10:25:46.342]         ...future.stdout <- NULL
[10:25:46.342]     }
[10:25:46.342]     ...future.result$conditions <- ...future.conditions
[10:25:46.342]     ...future.result$finished <- base::Sys.time()
[10:25:46.342]     ...future.result
[10:25:46.342] }
[10:25:46.343] plan(): Setting new future strategy stack:
[10:25:46.343] List of future strategies:
[10:25:46.343] 1. sequential:
[10:25:46.343]    - args: function (..., envir = parent.frame())
[10:25:46.343]    - tweaked: FALSE
[10:25:46.343]    - call: NULL
[10:25:46.344] plan(): nbrOfWorkers() = 1
[10:25:46.344] plan(): Setting new future strategy stack:
[10:25:46.345] List of future strategies:
[10:25:46.345] 1. sequential:
[10:25:46.345]    - args: function (..., envir = parent.frame())
[10:25:46.345]    - tweaked: FALSE
[10:25:46.345]    - call: plan(strategy)
[10:25:46.345] plan(): nbrOfWorkers() = 1
[10:25:46.345] SequentialFuture started (and completed)
[10:25:46.345] - Launch lazy future ... done
[10:25:46.345] run() for ‘SequentialFuture’ ... done
[10:25:46.345] getGlobalsAndPackages() ...
[10:25:46.345] Searching for globals...
[10:25:46.346] 
[10:25:46.346] Searching for globals ... DONE
[10:25:46.346] - globals: [0] <none>
[10:25:46.346] getGlobalsAndPackages() ... DONE
[10:25:46.346] run() for ‘Future’ ...
[10:25:46.346] - state: ‘created’
[10:25:46.346] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.347] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.347] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.347]   - Field: ‘label’
[10:25:46.347]   - Field: ‘local’
[10:25:46.347]   - Field: ‘owner’
[10:25:46.347]   - Field: ‘envir’
[10:25:46.347]   - Field: ‘packages’
[10:25:46.347]   - Field: ‘gc’
[10:25:46.347]   - Field: ‘conditions’
[10:25:46.347]   - Field: ‘expr’
[10:25:46.348]   - Field: ‘uuid’
[10:25:46.348]   - Field: ‘seed’
[10:25:46.348]   - Field: ‘version’
[10:25:46.348]   - Field: ‘result’
[10:25:46.348]   - Field: ‘asynchronous’
[10:25:46.348]   - Field: ‘calls’
[10:25:46.348]   - Field: ‘globals’
[10:25:46.348]   - Field: ‘stdout’
[10:25:46.348]   - Field: ‘earlySignal’
[10:25:46.348]   - Field: ‘lazy’
[10:25:46.348]   - Field: ‘state’
[10:25:46.348] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.349] - Launch lazy future ...
[10:25:46.349] Packages needed by the future expression (n = 0): <none>
[10:25:46.349] Packages needed by future strategies (n = 0): <none>
[10:25:46.349] {
[10:25:46.349]     {
[10:25:46.349]         {
[10:25:46.349]             ...future.startTime <- base::Sys.time()
[10:25:46.349]             {
[10:25:46.349]                 {
[10:25:46.349]                   {
[10:25:46.349]                     base::local({
[10:25:46.349]                       has_future <- base::requireNamespace("future", 
[10:25:46.349]                         quietly = TRUE)
[10:25:46.349]                       if (has_future) {
[10:25:46.349]                         ns <- base::getNamespace("future")
[10:25:46.349]                         version <- ns[[".package"]][["version"]]
[10:25:46.349]                         if (is.null(version)) 
[10:25:46.349]                           version <- utils::packageVersion("future")
[10:25:46.349]                       }
[10:25:46.349]                       else {
[10:25:46.349]                         version <- NULL
[10:25:46.349]                       }
[10:25:46.349]                       if (!has_future || version < "1.8.0") {
[10:25:46.349]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.349]                           "", base::R.version$version.string), 
[10:25:46.349]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.349]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.349]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.349]                             "release", "version")], collapse = " "), 
[10:25:46.349]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.349]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.349]                           info)
[10:25:46.349]                         info <- base::paste(info, collapse = "; ")
[10:25:46.349]                         if (!has_future) {
[10:25:46.349]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.349]                             info)
[10:25:46.349]                         }
[10:25:46.349]                         else {
[10:25:46.349]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.349]                             info, version)
[10:25:46.349]                         }
[10:25:46.349]                         base::stop(msg)
[10:25:46.349]                       }
[10:25:46.349]                     })
[10:25:46.349]                   }
[10:25:46.349]                   options(future.plan = NULL)
[10:25:46.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.349]                 }
[10:25:46.349]                 ...future.workdir <- getwd()
[10:25:46.349]             }
[10:25:46.349]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.349]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.349]         }
[10:25:46.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.349]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.349]             base::names(...future.oldOptions))
[10:25:46.349]     }
[10:25:46.349]     if (FALSE) {
[10:25:46.349]     }
[10:25:46.349]     else {
[10:25:46.349]         if (TRUE) {
[10:25:46.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.349]                 open = "w")
[10:25:46.349]         }
[10:25:46.349]         else {
[10:25:46.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.349]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.349]         }
[10:25:46.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.349]             base::sink(type = "output", split = FALSE)
[10:25:46.349]             base::close(...future.stdout)
[10:25:46.349]         }, add = TRUE)
[10:25:46.349]     }
[10:25:46.349]     ...future.frame <- base::sys.nframe()
[10:25:46.349]     ...future.conditions <- base::list()
[10:25:46.349]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.349]     if (FALSE) {
[10:25:46.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.349]     }
[10:25:46.349]     ...future.result <- base::tryCatch({
[10:25:46.349]         base::withCallingHandlers({
[10:25:46.349]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.349]             future::FutureResult(value = ...future.value$value, 
[10:25:46.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.349]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.349]                     ...future.globalenv.names))
[10:25:46.349]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.349]         }, condition = base::local({
[10:25:46.349]             c <- base::c
[10:25:46.349]             inherits <- base::inherits
[10:25:46.349]             invokeRestart <- base::invokeRestart
[10:25:46.349]             length <- base::length
[10:25:46.349]             list <- base::list
[10:25:46.349]             seq.int <- base::seq.int
[10:25:46.349]             signalCondition <- base::signalCondition
[10:25:46.349]             sys.calls <- base::sys.calls
[10:25:46.349]             `[[` <- base::`[[`
[10:25:46.349]             `+` <- base::`+`
[10:25:46.349]             `<<-` <- base::`<<-`
[10:25:46.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.349]                   3L)]
[10:25:46.349]             }
[10:25:46.349]             function(cond) {
[10:25:46.349]                 is_error <- inherits(cond, "error")
[10:25:46.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.349]                   NULL)
[10:25:46.349]                 if (is_error) {
[10:25:46.349]                   sessionInformation <- function() {
[10:25:46.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.349]                       search = base::search(), system = base::Sys.info())
[10:25:46.349]                   }
[10:25:46.349]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.349]                     cond$call), session = sessionInformation(), 
[10:25:46.349]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.349]                   signalCondition(cond)
[10:25:46.349]                 }
[10:25:46.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.349]                 "immediateCondition"))) {
[10:25:46.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.349]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.349]                   if (TRUE && !signal) {
[10:25:46.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.349]                     {
[10:25:46.349]                       inherits <- base::inherits
[10:25:46.349]                       invokeRestart <- base::invokeRestart
[10:25:46.349]                       is.null <- base::is.null
[10:25:46.349]                       muffled <- FALSE
[10:25:46.349]                       if (inherits(cond, "message")) {
[10:25:46.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.349]                         if (muffled) 
[10:25:46.349]                           invokeRestart("muffleMessage")
[10:25:46.349]                       }
[10:25:46.349]                       else if (inherits(cond, "warning")) {
[10:25:46.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.349]                         if (muffled) 
[10:25:46.349]                           invokeRestart("muffleWarning")
[10:25:46.349]                       }
[10:25:46.349]                       else if (inherits(cond, "condition")) {
[10:25:46.349]                         if (!is.null(pattern)) {
[10:25:46.349]                           computeRestarts <- base::computeRestarts
[10:25:46.349]                           grepl <- base::grepl
[10:25:46.349]                           restarts <- computeRestarts(cond)
[10:25:46.349]                           for (restart in restarts) {
[10:25:46.349]                             name <- restart$name
[10:25:46.349]                             if (is.null(name)) 
[10:25:46.349]                               next
[10:25:46.349]                             if (!grepl(pattern, name)) 
[10:25:46.349]                               next
[10:25:46.349]                             invokeRestart(restart)
[10:25:46.349]                             muffled <- TRUE
[10:25:46.349]                             break
[10:25:46.349]                           }
[10:25:46.349]                         }
[10:25:46.349]                       }
[10:25:46.349]                       invisible(muffled)
[10:25:46.349]                     }
[10:25:46.349]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.349]                   }
[10:25:46.349]                 }
[10:25:46.349]                 else {
[10:25:46.349]                   if (TRUE) {
[10:25:46.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.349]                     {
[10:25:46.349]                       inherits <- base::inherits
[10:25:46.349]                       invokeRestart <- base::invokeRestart
[10:25:46.349]                       is.null <- base::is.null
[10:25:46.349]                       muffled <- FALSE
[10:25:46.349]                       if (inherits(cond, "message")) {
[10:25:46.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.349]                         if (muffled) 
[10:25:46.349]                           invokeRestart("muffleMessage")
[10:25:46.349]                       }
[10:25:46.349]                       else if (inherits(cond, "warning")) {
[10:25:46.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.349]                         if (muffled) 
[10:25:46.349]                           invokeRestart("muffleWarning")
[10:25:46.349]                       }
[10:25:46.349]                       else if (inherits(cond, "condition")) {
[10:25:46.349]                         if (!is.null(pattern)) {
[10:25:46.349]                           computeRestarts <- base::computeRestarts
[10:25:46.349]                           grepl <- base::grepl
[10:25:46.349]                           restarts <- computeRestarts(cond)
[10:25:46.349]                           for (restart in restarts) {
[10:25:46.349]                             name <- restart$name
[10:25:46.349]                             if (is.null(name)) 
[10:25:46.349]                               next
[10:25:46.349]                             if (!grepl(pattern, name)) 
[10:25:46.349]                               next
[10:25:46.349]                             invokeRestart(restart)
[10:25:46.349]                             muffled <- TRUE
[10:25:46.349]                             break
[10:25:46.349]                           }
[10:25:46.349]                         }
[10:25:46.349]                       }
[10:25:46.349]                       invisible(muffled)
[10:25:46.349]                     }
[10:25:46.349]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.349]                   }
[10:25:46.349]                 }
[10:25:46.349]             }
[10:25:46.349]         }))
[10:25:46.349]     }, error = function(ex) {
[10:25:46.349]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.349]                 ...future.rng), started = ...future.startTime, 
[10:25:46.349]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.349]             version = "1.8"), class = "FutureResult")
[10:25:46.349]     }, finally = {
[10:25:46.349]         if (!identical(...future.workdir, getwd())) 
[10:25:46.349]             setwd(...future.workdir)
[10:25:46.349]         {
[10:25:46.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.349]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.349]             }
[10:25:46.349]             base::options(...future.oldOptions)
[10:25:46.349]             if (.Platform$OS.type == "windows") {
[10:25:46.349]                 old_names <- names(...future.oldEnvVars)
[10:25:46.349]                 envs <- base::Sys.getenv()
[10:25:46.349]                 names <- names(envs)
[10:25:46.349]                 common <- intersect(names, old_names)
[10:25:46.349]                 added <- setdiff(names, old_names)
[10:25:46.349]                 removed <- setdiff(old_names, names)
[10:25:46.349]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.349]                   envs[common]]
[10:25:46.349]                 NAMES <- toupper(changed)
[10:25:46.349]                 args <- list()
[10:25:46.349]                 for (kk in seq_along(NAMES)) {
[10:25:46.349]                   name <- changed[[kk]]
[10:25:46.349]                   NAME <- NAMES[[kk]]
[10:25:46.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.349]                     next
[10:25:46.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.349]                 }
[10:25:46.349]                 NAMES <- toupper(added)
[10:25:46.349]                 for (kk in seq_along(NAMES)) {
[10:25:46.349]                   name <- added[[kk]]
[10:25:46.349]                   NAME <- NAMES[[kk]]
[10:25:46.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.349]                     next
[10:25:46.349]                   args[[name]] <- ""
[10:25:46.349]                 }
[10:25:46.349]                 NAMES <- toupper(removed)
[10:25:46.349]                 for (kk in seq_along(NAMES)) {
[10:25:46.349]                   name <- removed[[kk]]
[10:25:46.349]                   NAME <- NAMES[[kk]]
[10:25:46.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.349]                     next
[10:25:46.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.349]                 }
[10:25:46.349]                 if (length(args) > 0) 
[10:25:46.349]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.349]             }
[10:25:46.349]             else {
[10:25:46.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.349]             }
[10:25:46.349]             {
[10:25:46.349]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.349]                   0L) {
[10:25:46.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.349]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.349]                   base::options(opts)
[10:25:46.349]                 }
[10:25:46.349]                 {
[10:25:46.349]                   {
[10:25:46.349]                     NULL
[10:25:46.349]                     RNGkind("Mersenne-Twister")
[10:25:46.349]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.349]                       inherits = FALSE)
[10:25:46.349]                   }
[10:25:46.349]                   options(future.plan = NULL)
[10:25:46.349]                   if (is.na(NA_character_)) 
[10:25:46.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.349]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.349]                   {
[10:25:46.349]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.349]                     if (!future$lazy) 
[10:25:46.349]                       future <- run(future)
[10:25:46.349]                     invisible(future)
[10:25:46.349]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.349]                 }
[10:25:46.349]             }
[10:25:46.349]         }
[10:25:46.349]     })
[10:25:46.349]     if (TRUE) {
[10:25:46.349]         base::sink(type = "output", split = FALSE)
[10:25:46.349]         if (TRUE) {
[10:25:46.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.349]         }
[10:25:46.349]         else {
[10:25:46.349]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.349]         }
[10:25:46.349]         base::close(...future.stdout)
[10:25:46.349]         ...future.stdout <- NULL
[10:25:46.349]     }
[10:25:46.349]     ...future.result$conditions <- ...future.conditions
[10:25:46.349]     ...future.result$finished <- base::Sys.time()
[10:25:46.349]     ...future.result
[10:25:46.349] }
[10:25:46.351] plan(): Setting new future strategy stack:
[10:25:46.351] List of future strategies:
[10:25:46.351] 1. sequential:
[10:25:46.351]    - args: function (..., envir = parent.frame())
[10:25:46.351]    - tweaked: FALSE
[10:25:46.351]    - call: NULL
[10:25:46.351] plan(): nbrOfWorkers() = 1
[10:25:46.375] plan(): Setting new future strategy stack:
[10:25:46.375] List of future strategies:
[10:25:46.375] 1. sequential:
[10:25:46.375]    - args: function (..., envir = parent.frame())
[10:25:46.375]    - tweaked: FALSE
[10:25:46.375]    - call: plan(strategy)
[10:25:46.375] plan(): nbrOfWorkers() = 1
[10:25:46.375] SequentialFuture started (and completed)
[10:25:46.375] - Launch lazy future ... done
[10:25:46.376] run() for ‘SequentialFuture’ ... done
[10:25:46.376] getGlobalsAndPackages() ...
[10:25:46.376] Searching for globals...
[10:25:46.377] - globals found: [1] ‘{’
[10:25:46.377] Searching for globals ... DONE
[10:25:46.377] Resolving globals: FALSE
[10:25:46.377] 
[10:25:46.377] 
[10:25:46.377] getGlobalsAndPackages() ... DONE
[10:25:46.377] run() for ‘Future’ ...
[10:25:46.378] - state: ‘created’
[10:25:46.378] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.378] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.378] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.378]   - Field: ‘label’
[10:25:46.378]   - Field: ‘local’
[10:25:46.378]   - Field: ‘owner’
[10:25:46.378]   - Field: ‘envir’
[10:25:46.379]   - Field: ‘packages’
[10:25:46.379]   - Field: ‘gc’
[10:25:46.379]   - Field: ‘conditions’
[10:25:46.379]   - Field: ‘expr’
[10:25:46.379]   - Field: ‘uuid’
[10:25:46.379]   - Field: ‘seed’
[10:25:46.379]   - Field: ‘version’
[10:25:46.379]   - Field: ‘result’
[10:25:46.379]   - Field: ‘asynchronous’
[10:25:46.379]   - Field: ‘calls’
[10:25:46.379]   - Field: ‘globals’
[10:25:46.379]   - Field: ‘stdout’
[10:25:46.380]   - Field: ‘earlySignal’
[10:25:46.380]   - Field: ‘lazy’
[10:25:46.380]   - Field: ‘state’
[10:25:46.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.380] - Launch lazy future ...
[10:25:46.380] Packages needed by the future expression (n = 0): <none>
[10:25:46.380] Packages needed by future strategies (n = 0): <none>
[10:25:46.381] {
[10:25:46.381]     {
[10:25:46.381]         {
[10:25:46.381]             ...future.startTime <- base::Sys.time()
[10:25:46.381]             {
[10:25:46.381]                 {
[10:25:46.381]                   {
[10:25:46.381]                     base::local({
[10:25:46.381]                       has_future <- base::requireNamespace("future", 
[10:25:46.381]                         quietly = TRUE)
[10:25:46.381]                       if (has_future) {
[10:25:46.381]                         ns <- base::getNamespace("future")
[10:25:46.381]                         version <- ns[[".package"]][["version"]]
[10:25:46.381]                         if (is.null(version)) 
[10:25:46.381]                           version <- utils::packageVersion("future")
[10:25:46.381]                       }
[10:25:46.381]                       else {
[10:25:46.381]                         version <- NULL
[10:25:46.381]                       }
[10:25:46.381]                       if (!has_future || version < "1.8.0") {
[10:25:46.381]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.381]                           "", base::R.version$version.string), 
[10:25:46.381]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.381]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.381]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.381]                             "release", "version")], collapse = " "), 
[10:25:46.381]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.381]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.381]                           info)
[10:25:46.381]                         info <- base::paste(info, collapse = "; ")
[10:25:46.381]                         if (!has_future) {
[10:25:46.381]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.381]                             info)
[10:25:46.381]                         }
[10:25:46.381]                         else {
[10:25:46.381]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.381]                             info, version)
[10:25:46.381]                         }
[10:25:46.381]                         base::stop(msg)
[10:25:46.381]                       }
[10:25:46.381]                     })
[10:25:46.381]                   }
[10:25:46.381]                   options(future.plan = NULL)
[10:25:46.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.381]                 }
[10:25:46.381]                 ...future.workdir <- getwd()
[10:25:46.381]             }
[10:25:46.381]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.381]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.381]         }
[10:25:46.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.381]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.381]             base::names(...future.oldOptions))
[10:25:46.381]     }
[10:25:46.381]     if (FALSE) {
[10:25:46.381]     }
[10:25:46.381]     else {
[10:25:46.381]         if (TRUE) {
[10:25:46.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.381]                 open = "w")
[10:25:46.381]         }
[10:25:46.381]         else {
[10:25:46.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.381]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.381]         }
[10:25:46.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.381]             base::sink(type = "output", split = FALSE)
[10:25:46.381]             base::close(...future.stdout)
[10:25:46.381]         }, add = TRUE)
[10:25:46.381]     }
[10:25:46.381]     ...future.frame <- base::sys.nframe()
[10:25:46.381]     ...future.conditions <- base::list()
[10:25:46.381]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.381]     if (FALSE) {
[10:25:46.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.381]     }
[10:25:46.381]     ...future.result <- base::tryCatch({
[10:25:46.381]         base::withCallingHandlers({
[10:25:46.381]             ...future.value <- base::withVisible(base::local({
[10:25:46.381]                 4
[10:25:46.381]             }))
[10:25:46.381]             future::FutureResult(value = ...future.value$value, 
[10:25:46.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.381]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.381]                     ...future.globalenv.names))
[10:25:46.381]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.381]         }, condition = base::local({
[10:25:46.381]             c <- base::c
[10:25:46.381]             inherits <- base::inherits
[10:25:46.381]             invokeRestart <- base::invokeRestart
[10:25:46.381]             length <- base::length
[10:25:46.381]             list <- base::list
[10:25:46.381]             seq.int <- base::seq.int
[10:25:46.381]             signalCondition <- base::signalCondition
[10:25:46.381]             sys.calls <- base::sys.calls
[10:25:46.381]             `[[` <- base::`[[`
[10:25:46.381]             `+` <- base::`+`
[10:25:46.381]             `<<-` <- base::`<<-`
[10:25:46.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.381]                   3L)]
[10:25:46.381]             }
[10:25:46.381]             function(cond) {
[10:25:46.381]                 is_error <- inherits(cond, "error")
[10:25:46.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.381]                   NULL)
[10:25:46.381]                 if (is_error) {
[10:25:46.381]                   sessionInformation <- function() {
[10:25:46.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.381]                       search = base::search(), system = base::Sys.info())
[10:25:46.381]                   }
[10:25:46.381]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.381]                     cond$call), session = sessionInformation(), 
[10:25:46.381]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.381]                   signalCondition(cond)
[10:25:46.381]                 }
[10:25:46.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.381]                 "immediateCondition"))) {
[10:25:46.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.381]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.381]                   if (TRUE && !signal) {
[10:25:46.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.381]                     {
[10:25:46.381]                       inherits <- base::inherits
[10:25:46.381]                       invokeRestart <- base::invokeRestart
[10:25:46.381]                       is.null <- base::is.null
[10:25:46.381]                       muffled <- FALSE
[10:25:46.381]                       if (inherits(cond, "message")) {
[10:25:46.381]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.381]                         if (muffled) 
[10:25:46.381]                           invokeRestart("muffleMessage")
[10:25:46.381]                       }
[10:25:46.381]                       else if (inherits(cond, "warning")) {
[10:25:46.381]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.381]                         if (muffled) 
[10:25:46.381]                           invokeRestart("muffleWarning")
[10:25:46.381]                       }
[10:25:46.381]                       else if (inherits(cond, "condition")) {
[10:25:46.381]                         if (!is.null(pattern)) {
[10:25:46.381]                           computeRestarts <- base::computeRestarts
[10:25:46.381]                           grepl <- base::grepl
[10:25:46.381]                           restarts <- computeRestarts(cond)
[10:25:46.381]                           for (restart in restarts) {
[10:25:46.381]                             name <- restart$name
[10:25:46.381]                             if (is.null(name)) 
[10:25:46.381]                               next
[10:25:46.381]                             if (!grepl(pattern, name)) 
[10:25:46.381]                               next
[10:25:46.381]                             invokeRestart(restart)
[10:25:46.381]                             muffled <- TRUE
[10:25:46.381]                             break
[10:25:46.381]                           }
[10:25:46.381]                         }
[10:25:46.381]                       }
[10:25:46.381]                       invisible(muffled)
[10:25:46.381]                     }
[10:25:46.381]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.381]                   }
[10:25:46.381]                 }
[10:25:46.381]                 else {
[10:25:46.381]                   if (TRUE) {
[10:25:46.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.381]                     {
[10:25:46.381]                       inherits <- base::inherits
[10:25:46.381]                       invokeRestart <- base::invokeRestart
[10:25:46.381]                       is.null <- base::is.null
[10:25:46.381]                       muffled <- FALSE
[10:25:46.381]                       if (inherits(cond, "message")) {
[10:25:46.381]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.381]                         if (muffled) 
[10:25:46.381]                           invokeRestart("muffleMessage")
[10:25:46.381]                       }
[10:25:46.381]                       else if (inherits(cond, "warning")) {
[10:25:46.381]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.381]                         if (muffled) 
[10:25:46.381]                           invokeRestart("muffleWarning")
[10:25:46.381]                       }
[10:25:46.381]                       else if (inherits(cond, "condition")) {
[10:25:46.381]                         if (!is.null(pattern)) {
[10:25:46.381]                           computeRestarts <- base::computeRestarts
[10:25:46.381]                           grepl <- base::grepl
[10:25:46.381]                           restarts <- computeRestarts(cond)
[10:25:46.381]                           for (restart in restarts) {
[10:25:46.381]                             name <- restart$name
[10:25:46.381]                             if (is.null(name)) 
[10:25:46.381]                               next
[10:25:46.381]                             if (!grepl(pattern, name)) 
[10:25:46.381]                               next
[10:25:46.381]                             invokeRestart(restart)
[10:25:46.381]                             muffled <- TRUE
[10:25:46.381]                             break
[10:25:46.381]                           }
[10:25:46.381]                         }
[10:25:46.381]                       }
[10:25:46.381]                       invisible(muffled)
[10:25:46.381]                     }
[10:25:46.381]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.381]                   }
[10:25:46.381]                 }
[10:25:46.381]             }
[10:25:46.381]         }))
[10:25:46.381]     }, error = function(ex) {
[10:25:46.381]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.381]                 ...future.rng), started = ...future.startTime, 
[10:25:46.381]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.381]             version = "1.8"), class = "FutureResult")
[10:25:46.381]     }, finally = {
[10:25:46.381]         if (!identical(...future.workdir, getwd())) 
[10:25:46.381]             setwd(...future.workdir)
[10:25:46.381]         {
[10:25:46.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.381]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.381]             }
[10:25:46.381]             base::options(...future.oldOptions)
[10:25:46.381]             if (.Platform$OS.type == "windows") {
[10:25:46.381]                 old_names <- names(...future.oldEnvVars)
[10:25:46.381]                 envs <- base::Sys.getenv()
[10:25:46.381]                 names <- names(envs)
[10:25:46.381]                 common <- intersect(names, old_names)
[10:25:46.381]                 added <- setdiff(names, old_names)
[10:25:46.381]                 removed <- setdiff(old_names, names)
[10:25:46.381]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.381]                   envs[common]]
[10:25:46.381]                 NAMES <- toupper(changed)
[10:25:46.381]                 args <- list()
[10:25:46.381]                 for (kk in seq_along(NAMES)) {
[10:25:46.381]                   name <- changed[[kk]]
[10:25:46.381]                   NAME <- NAMES[[kk]]
[10:25:46.381]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.381]                     next
[10:25:46.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.381]                 }
[10:25:46.381]                 NAMES <- toupper(added)
[10:25:46.381]                 for (kk in seq_along(NAMES)) {
[10:25:46.381]                   name <- added[[kk]]
[10:25:46.381]                   NAME <- NAMES[[kk]]
[10:25:46.381]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.381]                     next
[10:25:46.381]                   args[[name]] <- ""
[10:25:46.381]                 }
[10:25:46.381]                 NAMES <- toupper(removed)
[10:25:46.381]                 for (kk in seq_along(NAMES)) {
[10:25:46.381]                   name <- removed[[kk]]
[10:25:46.381]                   NAME <- NAMES[[kk]]
[10:25:46.381]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.381]                     next
[10:25:46.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.381]                 }
[10:25:46.381]                 if (length(args) > 0) 
[10:25:46.381]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.381]             }
[10:25:46.381]             else {
[10:25:46.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.381]             }
[10:25:46.381]             {
[10:25:46.381]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.381]                   0L) {
[10:25:46.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.381]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.381]                   base::options(opts)
[10:25:46.381]                 }
[10:25:46.381]                 {
[10:25:46.381]                   {
[10:25:46.381]                     NULL
[10:25:46.381]                     RNGkind("Mersenne-Twister")
[10:25:46.381]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.381]                       inherits = FALSE)
[10:25:46.381]                   }
[10:25:46.381]                   options(future.plan = NULL)
[10:25:46.381]                   if (is.na(NA_character_)) 
[10:25:46.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.381]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.381]                   {
[10:25:46.381]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.381]                     if (!future$lazy) 
[10:25:46.381]                       future <- run(future)
[10:25:46.381]                     invisible(future)
[10:25:46.381]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.381]                 }
[10:25:46.381]             }
[10:25:46.381]         }
[10:25:46.381]     })
[10:25:46.381]     if (TRUE) {
[10:25:46.381]         base::sink(type = "output", split = FALSE)
[10:25:46.381]         if (TRUE) {
[10:25:46.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.381]         }
[10:25:46.381]         else {
[10:25:46.381]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.381]         }
[10:25:46.381]         base::close(...future.stdout)
[10:25:46.381]         ...future.stdout <- NULL
[10:25:46.381]     }
[10:25:46.381]     ...future.result$conditions <- ...future.conditions
[10:25:46.381]     ...future.result$finished <- base::Sys.time()
[10:25:46.381]     ...future.result
[10:25:46.381] }
[10:25:46.382] plan(): Setting new future strategy stack:
[10:25:46.382] List of future strategies:
[10:25:46.382] 1. sequential:
[10:25:46.382]    - args: function (..., envir = parent.frame())
[10:25:46.382]    - tweaked: FALSE
[10:25:46.382]    - call: NULL
[10:25:46.383] plan(): nbrOfWorkers() = 1
[10:25:46.383] plan(): Setting new future strategy stack:
[10:25:46.384] List of future strategies:
[10:25:46.384] 1. sequential:
[10:25:46.384]    - args: function (..., envir = parent.frame())
[10:25:46.384]    - tweaked: FALSE
[10:25:46.384]    - call: plan(strategy)
[10:25:46.384] plan(): nbrOfWorkers() = 1
[10:25:46.384] SequentialFuture started (and completed)
[10:25:46.384] - Launch lazy future ... done
[10:25:46.384] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f4e4d328> 
Classes 'listenv', 'environment' <environment: 0x55c0f4bf4df8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:25:46.388] resolved() for ‘SequentialFuture’ ...
[10:25:46.388] - state: ‘finished’
[10:25:46.388] - run: TRUE
[10:25:46.388] - result: ‘FutureResult’
[10:25:46.388] resolved() for ‘SequentialFuture’ ... done
[10:25:46.388] resolved() for ‘SequentialFuture’ ...
[10:25:46.388] - state: ‘finished’
[10:25:46.389] - run: TRUE
[10:25:46.389] - result: ‘FutureResult’
[10:25:46.389] resolved() for ‘SequentialFuture’ ... done
[10:25:46.389] resolved() for ‘SequentialFuture’ ...
[10:25:46.389] - state: ‘finished’
[10:25:46.389] - run: TRUE
[10:25:46.389] - result: ‘FutureResult’
[10:25:46.389] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:46.391] resolve() on list environment ...
[10:25:46.391]  recursive: 0
[10:25:46.392]  length: 6
[10:25:46.392]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:46.393] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.393] - nx: 6
[10:25:46.393] - relay: TRUE
[10:25:46.393] - stdout: TRUE
[10:25:46.393] - signal: TRUE
[10:25:46.393] - resignal: FALSE
[10:25:46.393] - force: TRUE
[10:25:46.393] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.393] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.393]  - until=2
[10:25:46.393]  - relaying element #2
[10:25:46.393] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.394] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.394] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.394]  length: 5 (resolved future 1)
[10:25:46.394] resolved() for ‘SequentialFuture’ ...
[10:25:46.394] - state: ‘finished’
[10:25:46.394] - run: TRUE
[10:25:46.394] - result: ‘FutureResult’
[10:25:46.394] resolved() for ‘SequentialFuture’ ... done
[10:25:46.394] Future #2
[10:25:46.394] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.395] - nx: 6
[10:25:46.395] - relay: TRUE
[10:25:46.395] - stdout: TRUE
[10:25:46.395] - signal: TRUE
[10:25:46.395] - resignal: FALSE
[10:25:46.395] - force: TRUE
[10:25:46.395] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.395] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.395]  - until=2
[10:25:46.395]  - relaying element #2
[10:25:46.395] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.396] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.396] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.396]  length: 4 (resolved future 2)
[10:25:46.396] resolved() for ‘SequentialFuture’ ...
[10:25:46.396] - state: ‘finished’
[10:25:46.396] - run: TRUE
[10:25:46.396] - result: ‘FutureResult’
[10:25:46.396] resolved() for ‘SequentialFuture’ ... done
[10:25:46.396] Future #3
[10:25:46.396] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.397] - nx: 6
[10:25:46.397] - relay: TRUE
[10:25:46.397] - stdout: TRUE
[10:25:46.397] - signal: TRUE
[10:25:46.397] - resignal: FALSE
[10:25:46.397] - force: TRUE
[10:25:46.397] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.397] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.397]  - until=3
[10:25:46.397]  - relaying element #3
[10:25:46.397] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.398] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.398] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.398]  length: 3 (resolved future 3)
[10:25:46.398] resolved() for ‘SequentialFuture’ ...
[10:25:46.398] - state: ‘finished’
[10:25:46.398] - run: TRUE
[10:25:46.398] - result: ‘FutureResult’
[10:25:46.398] resolved() for ‘SequentialFuture’ ... done
[10:25:46.398] Future #4
[10:25:46.398] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.399] - nx: 6
[10:25:46.399] - relay: TRUE
[10:25:46.399] - stdout: TRUE
[10:25:46.399] - signal: TRUE
[10:25:46.399] - resignal: FALSE
[10:25:46.399] - force: TRUE
[10:25:46.399] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.399] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.399]  - until=4
[10:25:46.400]  - relaying element #4
[10:25:46.400] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.400] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.401] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.401]  length: 2 (resolved future 4)
[10:25:46.401] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.401] - nx: 6
[10:25:46.401] - relay: TRUE
[10:25:46.401] - stdout: TRUE
[10:25:46.401] - signal: TRUE
[10:25:46.401] - resignal: FALSE
[10:25:46.401] - force: TRUE
[10:25:46.401] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.401] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.402]  - until=6
[10:25:46.402]  - relaying element #6
[10:25:46.402] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.402] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.402] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.402]  length: 1 (resolved future 5)
[10:25:46.402] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.402] - nx: 6
[10:25:46.402] - relay: TRUE
[10:25:46.402] - stdout: TRUE
[10:25:46.402] - signal: TRUE
[10:25:46.402] - resignal: FALSE
[10:25:46.403] - force: TRUE
[10:25:46.403] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.403] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.403]  - until=6
[10:25:46.403] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.403] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.403] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.403]  length: 0 (resolved future 6)
[10:25:46.403] Relaying remaining futures
[10:25:46.403] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.403] - nx: 6
[10:25:46.403] - relay: TRUE
[10:25:46.404] - stdout: TRUE
[10:25:46.404] - signal: TRUE
[10:25:46.404] - resignal: FALSE
[10:25:46.404] - force: TRUE
[10:25:46.404] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.404] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:46.404] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.404] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.404] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.404] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c0f511d130> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:25:46.406] getGlobalsAndPackages() ...
[10:25:46.406] Searching for globals...
[10:25:46.407] 
[10:25:46.407] Searching for globals ... DONE
[10:25:46.407] - globals: [0] <none>
[10:25:46.407] getGlobalsAndPackages() ... DONE
[10:25:46.407] run() for ‘Future’ ...
[10:25:46.407] - state: ‘created’
[10:25:46.407] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.408]   - Field: ‘label’
[10:25:46.408]   - Field: ‘local’
[10:25:46.408]   - Field: ‘owner’
[10:25:46.408]   - Field: ‘envir’
[10:25:46.408]   - Field: ‘packages’
[10:25:46.408]   - Field: ‘gc’
[10:25:46.408]   - Field: ‘conditions’
[10:25:46.408]   - Field: ‘expr’
[10:25:46.408]   - Field: ‘uuid’
[10:25:46.409]   - Field: ‘seed’
[10:25:46.409]   - Field: ‘version’
[10:25:46.409]   - Field: ‘result’
[10:25:46.409]   - Field: ‘asynchronous’
[10:25:46.409]   - Field: ‘calls’
[10:25:46.409]   - Field: ‘globals’
[10:25:46.409]   - Field: ‘stdout’
[10:25:46.409]   - Field: ‘earlySignal’
[10:25:46.409]   - Field: ‘lazy’
[10:25:46.409]   - Field: ‘state’
[10:25:46.409] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.409] - Launch lazy future ...
[10:25:46.410] Packages needed by the future expression (n = 0): <none>
[10:25:46.410] Packages needed by future strategies (n = 0): <none>
[10:25:46.410] {
[10:25:46.410]     {
[10:25:46.410]         {
[10:25:46.410]             ...future.startTime <- base::Sys.time()
[10:25:46.410]             {
[10:25:46.410]                 {
[10:25:46.410]                   {
[10:25:46.410]                     base::local({
[10:25:46.410]                       has_future <- base::requireNamespace("future", 
[10:25:46.410]                         quietly = TRUE)
[10:25:46.410]                       if (has_future) {
[10:25:46.410]                         ns <- base::getNamespace("future")
[10:25:46.410]                         version <- ns[[".package"]][["version"]]
[10:25:46.410]                         if (is.null(version)) 
[10:25:46.410]                           version <- utils::packageVersion("future")
[10:25:46.410]                       }
[10:25:46.410]                       else {
[10:25:46.410]                         version <- NULL
[10:25:46.410]                       }
[10:25:46.410]                       if (!has_future || version < "1.8.0") {
[10:25:46.410]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.410]                           "", base::R.version$version.string), 
[10:25:46.410]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.410]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.410]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.410]                             "release", "version")], collapse = " "), 
[10:25:46.410]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.410]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.410]                           info)
[10:25:46.410]                         info <- base::paste(info, collapse = "; ")
[10:25:46.410]                         if (!has_future) {
[10:25:46.410]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.410]                             info)
[10:25:46.410]                         }
[10:25:46.410]                         else {
[10:25:46.410]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.410]                             info, version)
[10:25:46.410]                         }
[10:25:46.410]                         base::stop(msg)
[10:25:46.410]                       }
[10:25:46.410]                     })
[10:25:46.410]                   }
[10:25:46.410]                   options(future.plan = NULL)
[10:25:46.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.410]                 }
[10:25:46.410]                 ...future.workdir <- getwd()
[10:25:46.410]             }
[10:25:46.410]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.410]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.410]         }
[10:25:46.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.410]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.410]             base::names(...future.oldOptions))
[10:25:46.410]     }
[10:25:46.410]     if (FALSE) {
[10:25:46.410]     }
[10:25:46.410]     else {
[10:25:46.410]         if (TRUE) {
[10:25:46.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.410]                 open = "w")
[10:25:46.410]         }
[10:25:46.410]         else {
[10:25:46.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.410]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.410]         }
[10:25:46.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.410]             base::sink(type = "output", split = FALSE)
[10:25:46.410]             base::close(...future.stdout)
[10:25:46.410]         }, add = TRUE)
[10:25:46.410]     }
[10:25:46.410]     ...future.frame <- base::sys.nframe()
[10:25:46.410]     ...future.conditions <- base::list()
[10:25:46.410]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.410]     if (FALSE) {
[10:25:46.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.410]     }
[10:25:46.410]     ...future.result <- base::tryCatch({
[10:25:46.410]         base::withCallingHandlers({
[10:25:46.410]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.410]             future::FutureResult(value = ...future.value$value, 
[10:25:46.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.410]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.410]                     ...future.globalenv.names))
[10:25:46.410]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.410]         }, condition = base::local({
[10:25:46.410]             c <- base::c
[10:25:46.410]             inherits <- base::inherits
[10:25:46.410]             invokeRestart <- base::invokeRestart
[10:25:46.410]             length <- base::length
[10:25:46.410]             list <- base::list
[10:25:46.410]             seq.int <- base::seq.int
[10:25:46.410]             signalCondition <- base::signalCondition
[10:25:46.410]             sys.calls <- base::sys.calls
[10:25:46.410]             `[[` <- base::`[[`
[10:25:46.410]             `+` <- base::`+`
[10:25:46.410]             `<<-` <- base::`<<-`
[10:25:46.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.410]                   3L)]
[10:25:46.410]             }
[10:25:46.410]             function(cond) {
[10:25:46.410]                 is_error <- inherits(cond, "error")
[10:25:46.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.410]                   NULL)
[10:25:46.410]                 if (is_error) {
[10:25:46.410]                   sessionInformation <- function() {
[10:25:46.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.410]                       search = base::search(), system = base::Sys.info())
[10:25:46.410]                   }
[10:25:46.410]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.410]                     cond$call), session = sessionInformation(), 
[10:25:46.410]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.410]                   signalCondition(cond)
[10:25:46.410]                 }
[10:25:46.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.410]                 "immediateCondition"))) {
[10:25:46.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.410]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.410]                   if (TRUE && !signal) {
[10:25:46.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.410]                     {
[10:25:46.410]                       inherits <- base::inherits
[10:25:46.410]                       invokeRestart <- base::invokeRestart
[10:25:46.410]                       is.null <- base::is.null
[10:25:46.410]                       muffled <- FALSE
[10:25:46.410]                       if (inherits(cond, "message")) {
[10:25:46.410]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.410]                         if (muffled) 
[10:25:46.410]                           invokeRestart("muffleMessage")
[10:25:46.410]                       }
[10:25:46.410]                       else if (inherits(cond, "warning")) {
[10:25:46.410]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.410]                         if (muffled) 
[10:25:46.410]                           invokeRestart("muffleWarning")
[10:25:46.410]                       }
[10:25:46.410]                       else if (inherits(cond, "condition")) {
[10:25:46.410]                         if (!is.null(pattern)) {
[10:25:46.410]                           computeRestarts <- base::computeRestarts
[10:25:46.410]                           grepl <- base::grepl
[10:25:46.410]                           restarts <- computeRestarts(cond)
[10:25:46.410]                           for (restart in restarts) {
[10:25:46.410]                             name <- restart$name
[10:25:46.410]                             if (is.null(name)) 
[10:25:46.410]                               next
[10:25:46.410]                             if (!grepl(pattern, name)) 
[10:25:46.410]                               next
[10:25:46.410]                             invokeRestart(restart)
[10:25:46.410]                             muffled <- TRUE
[10:25:46.410]                             break
[10:25:46.410]                           }
[10:25:46.410]                         }
[10:25:46.410]                       }
[10:25:46.410]                       invisible(muffled)
[10:25:46.410]                     }
[10:25:46.410]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.410]                   }
[10:25:46.410]                 }
[10:25:46.410]                 else {
[10:25:46.410]                   if (TRUE) {
[10:25:46.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.410]                     {
[10:25:46.410]                       inherits <- base::inherits
[10:25:46.410]                       invokeRestart <- base::invokeRestart
[10:25:46.410]                       is.null <- base::is.null
[10:25:46.410]                       muffled <- FALSE
[10:25:46.410]                       if (inherits(cond, "message")) {
[10:25:46.410]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.410]                         if (muffled) 
[10:25:46.410]                           invokeRestart("muffleMessage")
[10:25:46.410]                       }
[10:25:46.410]                       else if (inherits(cond, "warning")) {
[10:25:46.410]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.410]                         if (muffled) 
[10:25:46.410]                           invokeRestart("muffleWarning")
[10:25:46.410]                       }
[10:25:46.410]                       else if (inherits(cond, "condition")) {
[10:25:46.410]                         if (!is.null(pattern)) {
[10:25:46.410]                           computeRestarts <- base::computeRestarts
[10:25:46.410]                           grepl <- base::grepl
[10:25:46.410]                           restarts <- computeRestarts(cond)
[10:25:46.410]                           for (restart in restarts) {
[10:25:46.410]                             name <- restart$name
[10:25:46.410]                             if (is.null(name)) 
[10:25:46.410]                               next
[10:25:46.410]                             if (!grepl(pattern, name)) 
[10:25:46.410]                               next
[10:25:46.410]                             invokeRestart(restart)
[10:25:46.410]                             muffled <- TRUE
[10:25:46.410]                             break
[10:25:46.410]                           }
[10:25:46.410]                         }
[10:25:46.410]                       }
[10:25:46.410]                       invisible(muffled)
[10:25:46.410]                     }
[10:25:46.410]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.410]                   }
[10:25:46.410]                 }
[10:25:46.410]             }
[10:25:46.410]         }))
[10:25:46.410]     }, error = function(ex) {
[10:25:46.410]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.410]                 ...future.rng), started = ...future.startTime, 
[10:25:46.410]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.410]             version = "1.8"), class = "FutureResult")
[10:25:46.410]     }, finally = {
[10:25:46.410]         if (!identical(...future.workdir, getwd())) 
[10:25:46.410]             setwd(...future.workdir)
[10:25:46.410]         {
[10:25:46.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.410]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.410]             }
[10:25:46.410]             base::options(...future.oldOptions)
[10:25:46.410]             if (.Platform$OS.type == "windows") {
[10:25:46.410]                 old_names <- names(...future.oldEnvVars)
[10:25:46.410]                 envs <- base::Sys.getenv()
[10:25:46.410]                 names <- names(envs)
[10:25:46.410]                 common <- intersect(names, old_names)
[10:25:46.410]                 added <- setdiff(names, old_names)
[10:25:46.410]                 removed <- setdiff(old_names, names)
[10:25:46.410]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.410]                   envs[common]]
[10:25:46.410]                 NAMES <- toupper(changed)
[10:25:46.410]                 args <- list()
[10:25:46.410]                 for (kk in seq_along(NAMES)) {
[10:25:46.410]                   name <- changed[[kk]]
[10:25:46.410]                   NAME <- NAMES[[kk]]
[10:25:46.410]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.410]                     next
[10:25:46.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.410]                 }
[10:25:46.410]                 NAMES <- toupper(added)
[10:25:46.410]                 for (kk in seq_along(NAMES)) {
[10:25:46.410]                   name <- added[[kk]]
[10:25:46.410]                   NAME <- NAMES[[kk]]
[10:25:46.410]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.410]                     next
[10:25:46.410]                   args[[name]] <- ""
[10:25:46.410]                 }
[10:25:46.410]                 NAMES <- toupper(removed)
[10:25:46.410]                 for (kk in seq_along(NAMES)) {
[10:25:46.410]                   name <- removed[[kk]]
[10:25:46.410]                   NAME <- NAMES[[kk]]
[10:25:46.410]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.410]                     next
[10:25:46.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.410]                 }
[10:25:46.410]                 if (length(args) > 0) 
[10:25:46.410]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.410]             }
[10:25:46.410]             else {
[10:25:46.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.410]             }
[10:25:46.410]             {
[10:25:46.410]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.410]                   0L) {
[10:25:46.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.410]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.410]                   base::options(opts)
[10:25:46.410]                 }
[10:25:46.410]                 {
[10:25:46.410]                   {
[10:25:46.410]                     NULL
[10:25:46.410]                     RNGkind("Mersenne-Twister")
[10:25:46.410]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.410]                       inherits = FALSE)
[10:25:46.410]                   }
[10:25:46.410]                   options(future.plan = NULL)
[10:25:46.410]                   if (is.na(NA_character_)) 
[10:25:46.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.410]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.410]                   {
[10:25:46.410]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.410]                     if (!future$lazy) 
[10:25:46.410]                       future <- run(future)
[10:25:46.410]                     invisible(future)
[10:25:46.410]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.410]                 }
[10:25:46.410]             }
[10:25:46.410]         }
[10:25:46.410]     })
[10:25:46.410]     if (TRUE) {
[10:25:46.410]         base::sink(type = "output", split = FALSE)
[10:25:46.410]         if (TRUE) {
[10:25:46.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.410]         }
[10:25:46.410]         else {
[10:25:46.410]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.410]         }
[10:25:46.410]         base::close(...future.stdout)
[10:25:46.410]         ...future.stdout <- NULL
[10:25:46.410]     }
[10:25:46.410]     ...future.result$conditions <- ...future.conditions
[10:25:46.410]     ...future.result$finished <- base::Sys.time()
[10:25:46.410]     ...future.result
[10:25:46.410] }
[10:25:46.412] plan(): Setting new future strategy stack:
[10:25:46.412] List of future strategies:
[10:25:46.412] 1. sequential:
[10:25:46.412]    - args: function (..., envir = parent.frame())
[10:25:46.412]    - tweaked: FALSE
[10:25:46.412]    - call: NULL
[10:25:46.412] plan(): nbrOfWorkers() = 1
[10:25:46.413] plan(): Setting new future strategy stack:
[10:25:46.413] List of future strategies:
[10:25:46.413] 1. sequential:
[10:25:46.413]    - args: function (..., envir = parent.frame())
[10:25:46.413]    - tweaked: FALSE
[10:25:46.413]    - call: plan(strategy)
[10:25:46.413] plan(): nbrOfWorkers() = 1
[10:25:46.414] SequentialFuture started (and completed)
[10:25:46.414] - Launch lazy future ... done
[10:25:46.414] run() for ‘SequentialFuture’ ... done
[10:25:46.414] getGlobalsAndPackages() ...
[10:25:46.414] Searching for globals...
[10:25:46.414] 
[10:25:46.414] Searching for globals ... DONE
[10:25:46.414] - globals: [0] <none>
[10:25:46.415] getGlobalsAndPackages() ... DONE
[10:25:46.415] run() for ‘Future’ ...
[10:25:46.415] - state: ‘created’
[10:25:46.415] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.415] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.415] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.415]   - Field: ‘label’
[10:25:46.415]   - Field: ‘local’
[10:25:46.416]   - Field: ‘owner’
[10:25:46.416]   - Field: ‘envir’
[10:25:46.416]   - Field: ‘packages’
[10:25:46.416]   - Field: ‘gc’
[10:25:46.416]   - Field: ‘conditions’
[10:25:46.416]   - Field: ‘expr’
[10:25:46.416]   - Field: ‘uuid’
[10:25:46.416]   - Field: ‘seed’
[10:25:46.416]   - Field: ‘version’
[10:25:46.416]   - Field: ‘result’
[10:25:46.416]   - Field: ‘asynchronous’
[10:25:46.417]   - Field: ‘calls’
[10:25:46.417]   - Field: ‘globals’
[10:25:46.417]   - Field: ‘stdout’
[10:25:46.417]   - Field: ‘earlySignal’
[10:25:46.417]   - Field: ‘lazy’
[10:25:46.417]   - Field: ‘state’
[10:25:46.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.417] - Launch lazy future ...
[10:25:46.417] Packages needed by the future expression (n = 0): <none>
[10:25:46.417] Packages needed by future strategies (n = 0): <none>
[10:25:46.418] {
[10:25:46.418]     {
[10:25:46.418]         {
[10:25:46.418]             ...future.startTime <- base::Sys.time()
[10:25:46.418]             {
[10:25:46.418]                 {
[10:25:46.418]                   {
[10:25:46.418]                     base::local({
[10:25:46.418]                       has_future <- base::requireNamespace("future", 
[10:25:46.418]                         quietly = TRUE)
[10:25:46.418]                       if (has_future) {
[10:25:46.418]                         ns <- base::getNamespace("future")
[10:25:46.418]                         version <- ns[[".package"]][["version"]]
[10:25:46.418]                         if (is.null(version)) 
[10:25:46.418]                           version <- utils::packageVersion("future")
[10:25:46.418]                       }
[10:25:46.418]                       else {
[10:25:46.418]                         version <- NULL
[10:25:46.418]                       }
[10:25:46.418]                       if (!has_future || version < "1.8.0") {
[10:25:46.418]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.418]                           "", base::R.version$version.string), 
[10:25:46.418]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.418]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.418]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.418]                             "release", "version")], collapse = " "), 
[10:25:46.418]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.418]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.418]                           info)
[10:25:46.418]                         info <- base::paste(info, collapse = "; ")
[10:25:46.418]                         if (!has_future) {
[10:25:46.418]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.418]                             info)
[10:25:46.418]                         }
[10:25:46.418]                         else {
[10:25:46.418]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.418]                             info, version)
[10:25:46.418]                         }
[10:25:46.418]                         base::stop(msg)
[10:25:46.418]                       }
[10:25:46.418]                     })
[10:25:46.418]                   }
[10:25:46.418]                   options(future.plan = NULL)
[10:25:46.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.418]                 }
[10:25:46.418]                 ...future.workdir <- getwd()
[10:25:46.418]             }
[10:25:46.418]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.418]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.418]         }
[10:25:46.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.418]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.418]             base::names(...future.oldOptions))
[10:25:46.418]     }
[10:25:46.418]     if (FALSE) {
[10:25:46.418]     }
[10:25:46.418]     else {
[10:25:46.418]         if (TRUE) {
[10:25:46.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.418]                 open = "w")
[10:25:46.418]         }
[10:25:46.418]         else {
[10:25:46.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.418]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.418]         }
[10:25:46.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.418]             base::sink(type = "output", split = FALSE)
[10:25:46.418]             base::close(...future.stdout)
[10:25:46.418]         }, add = TRUE)
[10:25:46.418]     }
[10:25:46.418]     ...future.frame <- base::sys.nframe()
[10:25:46.418]     ...future.conditions <- base::list()
[10:25:46.418]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.418]     if (FALSE) {
[10:25:46.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.418]     }
[10:25:46.418]     ...future.result <- base::tryCatch({
[10:25:46.418]         base::withCallingHandlers({
[10:25:46.418]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.418]             future::FutureResult(value = ...future.value$value, 
[10:25:46.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.418]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.418]                     ...future.globalenv.names))
[10:25:46.418]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.418]         }, condition = base::local({
[10:25:46.418]             c <- base::c
[10:25:46.418]             inherits <- base::inherits
[10:25:46.418]             invokeRestart <- base::invokeRestart
[10:25:46.418]             length <- base::length
[10:25:46.418]             list <- base::list
[10:25:46.418]             seq.int <- base::seq.int
[10:25:46.418]             signalCondition <- base::signalCondition
[10:25:46.418]             sys.calls <- base::sys.calls
[10:25:46.418]             `[[` <- base::`[[`
[10:25:46.418]             `+` <- base::`+`
[10:25:46.418]             `<<-` <- base::`<<-`
[10:25:46.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.418]                   3L)]
[10:25:46.418]             }
[10:25:46.418]             function(cond) {
[10:25:46.418]                 is_error <- inherits(cond, "error")
[10:25:46.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.418]                   NULL)
[10:25:46.418]                 if (is_error) {
[10:25:46.418]                   sessionInformation <- function() {
[10:25:46.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.418]                       search = base::search(), system = base::Sys.info())
[10:25:46.418]                   }
[10:25:46.418]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.418]                     cond$call), session = sessionInformation(), 
[10:25:46.418]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.418]                   signalCondition(cond)
[10:25:46.418]                 }
[10:25:46.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.418]                 "immediateCondition"))) {
[10:25:46.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.418]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.418]                   if (TRUE && !signal) {
[10:25:46.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.418]                     {
[10:25:46.418]                       inherits <- base::inherits
[10:25:46.418]                       invokeRestart <- base::invokeRestart
[10:25:46.418]                       is.null <- base::is.null
[10:25:46.418]                       muffled <- FALSE
[10:25:46.418]                       if (inherits(cond, "message")) {
[10:25:46.418]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.418]                         if (muffled) 
[10:25:46.418]                           invokeRestart("muffleMessage")
[10:25:46.418]                       }
[10:25:46.418]                       else if (inherits(cond, "warning")) {
[10:25:46.418]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.418]                         if (muffled) 
[10:25:46.418]                           invokeRestart("muffleWarning")
[10:25:46.418]                       }
[10:25:46.418]                       else if (inherits(cond, "condition")) {
[10:25:46.418]                         if (!is.null(pattern)) {
[10:25:46.418]                           computeRestarts <- base::computeRestarts
[10:25:46.418]                           grepl <- base::grepl
[10:25:46.418]                           restarts <- computeRestarts(cond)
[10:25:46.418]                           for (restart in restarts) {
[10:25:46.418]                             name <- restart$name
[10:25:46.418]                             if (is.null(name)) 
[10:25:46.418]                               next
[10:25:46.418]                             if (!grepl(pattern, name)) 
[10:25:46.418]                               next
[10:25:46.418]                             invokeRestart(restart)
[10:25:46.418]                             muffled <- TRUE
[10:25:46.418]                             break
[10:25:46.418]                           }
[10:25:46.418]                         }
[10:25:46.418]                       }
[10:25:46.418]                       invisible(muffled)
[10:25:46.418]                     }
[10:25:46.418]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.418]                   }
[10:25:46.418]                 }
[10:25:46.418]                 else {
[10:25:46.418]                   if (TRUE) {
[10:25:46.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.418]                     {
[10:25:46.418]                       inherits <- base::inherits
[10:25:46.418]                       invokeRestart <- base::invokeRestart
[10:25:46.418]                       is.null <- base::is.null
[10:25:46.418]                       muffled <- FALSE
[10:25:46.418]                       if (inherits(cond, "message")) {
[10:25:46.418]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.418]                         if (muffled) 
[10:25:46.418]                           invokeRestart("muffleMessage")
[10:25:46.418]                       }
[10:25:46.418]                       else if (inherits(cond, "warning")) {
[10:25:46.418]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.418]                         if (muffled) 
[10:25:46.418]                           invokeRestart("muffleWarning")
[10:25:46.418]                       }
[10:25:46.418]                       else if (inherits(cond, "condition")) {
[10:25:46.418]                         if (!is.null(pattern)) {
[10:25:46.418]                           computeRestarts <- base::computeRestarts
[10:25:46.418]                           grepl <- base::grepl
[10:25:46.418]                           restarts <- computeRestarts(cond)
[10:25:46.418]                           for (restart in restarts) {
[10:25:46.418]                             name <- restart$name
[10:25:46.418]                             if (is.null(name)) 
[10:25:46.418]                               next
[10:25:46.418]                             if (!grepl(pattern, name)) 
[10:25:46.418]                               next
[10:25:46.418]                             invokeRestart(restart)
[10:25:46.418]                             muffled <- TRUE
[10:25:46.418]                             break
[10:25:46.418]                           }
[10:25:46.418]                         }
[10:25:46.418]                       }
[10:25:46.418]                       invisible(muffled)
[10:25:46.418]                     }
[10:25:46.418]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.418]                   }
[10:25:46.418]                 }
[10:25:46.418]             }
[10:25:46.418]         }))
[10:25:46.418]     }, error = function(ex) {
[10:25:46.418]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.418]                 ...future.rng), started = ...future.startTime, 
[10:25:46.418]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.418]             version = "1.8"), class = "FutureResult")
[10:25:46.418]     }, finally = {
[10:25:46.418]         if (!identical(...future.workdir, getwd())) 
[10:25:46.418]             setwd(...future.workdir)
[10:25:46.418]         {
[10:25:46.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.418]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.418]             }
[10:25:46.418]             base::options(...future.oldOptions)
[10:25:46.418]             if (.Platform$OS.type == "windows") {
[10:25:46.418]                 old_names <- names(...future.oldEnvVars)
[10:25:46.418]                 envs <- base::Sys.getenv()
[10:25:46.418]                 names <- names(envs)
[10:25:46.418]                 common <- intersect(names, old_names)
[10:25:46.418]                 added <- setdiff(names, old_names)
[10:25:46.418]                 removed <- setdiff(old_names, names)
[10:25:46.418]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.418]                   envs[common]]
[10:25:46.418]                 NAMES <- toupper(changed)
[10:25:46.418]                 args <- list()
[10:25:46.418]                 for (kk in seq_along(NAMES)) {
[10:25:46.418]                   name <- changed[[kk]]
[10:25:46.418]                   NAME <- NAMES[[kk]]
[10:25:46.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.418]                     next
[10:25:46.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.418]                 }
[10:25:46.418]                 NAMES <- toupper(added)
[10:25:46.418]                 for (kk in seq_along(NAMES)) {
[10:25:46.418]                   name <- added[[kk]]
[10:25:46.418]                   NAME <- NAMES[[kk]]
[10:25:46.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.418]                     next
[10:25:46.418]                   args[[name]] <- ""
[10:25:46.418]                 }
[10:25:46.418]                 NAMES <- toupper(removed)
[10:25:46.418]                 for (kk in seq_along(NAMES)) {
[10:25:46.418]                   name <- removed[[kk]]
[10:25:46.418]                   NAME <- NAMES[[kk]]
[10:25:46.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.418]                     next
[10:25:46.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.418]                 }
[10:25:46.418]                 if (length(args) > 0) 
[10:25:46.418]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.418]             }
[10:25:46.418]             else {
[10:25:46.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.418]             }
[10:25:46.418]             {
[10:25:46.418]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.418]                   0L) {
[10:25:46.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.418]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.418]                   base::options(opts)
[10:25:46.418]                 }
[10:25:46.418]                 {
[10:25:46.418]                   {
[10:25:46.418]                     NULL
[10:25:46.418]                     RNGkind("Mersenne-Twister")
[10:25:46.418]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.418]                       inherits = FALSE)
[10:25:46.418]                   }
[10:25:46.418]                   options(future.plan = NULL)
[10:25:46.418]                   if (is.na(NA_character_)) 
[10:25:46.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.418]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.418]                   {
[10:25:46.418]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.418]                     if (!future$lazy) 
[10:25:46.418]                       future <- run(future)
[10:25:46.418]                     invisible(future)
[10:25:46.418]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.418]                 }
[10:25:46.418]             }
[10:25:46.418]         }
[10:25:46.418]     })
[10:25:46.418]     if (TRUE) {
[10:25:46.418]         base::sink(type = "output", split = FALSE)
[10:25:46.418]         if (TRUE) {
[10:25:46.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.418]         }
[10:25:46.418]         else {
[10:25:46.418]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.418]         }
[10:25:46.418]         base::close(...future.stdout)
[10:25:46.418]         ...future.stdout <- NULL
[10:25:46.418]     }
[10:25:46.418]     ...future.result$conditions <- ...future.conditions
[10:25:46.418]     ...future.result$finished <- base::Sys.time()
[10:25:46.418]     ...future.result
[10:25:46.418] }
[10:25:46.419] plan(): Setting new future strategy stack:
[10:25:46.420] List of future strategies:
[10:25:46.420] 1. sequential:
[10:25:46.420]    - args: function (..., envir = parent.frame())
[10:25:46.420]    - tweaked: FALSE
[10:25:46.420]    - call: NULL
[10:25:46.420] plan(): nbrOfWorkers() = 1
[10:25:46.421] plan(): Setting new future strategy stack:
[10:25:46.421] List of future strategies:
[10:25:46.421] 1. sequential:
[10:25:46.421]    - args: function (..., envir = parent.frame())
[10:25:46.421]    - tweaked: FALSE
[10:25:46.421]    - call: plan(strategy)
[10:25:46.421] plan(): nbrOfWorkers() = 1
[10:25:46.421] SequentialFuture started (and completed)
[10:25:46.421] - Launch lazy future ... done
[10:25:46.421] run() for ‘SequentialFuture’ ... done
[10:25:46.422] getGlobalsAndPackages() ...
[10:25:46.422] Searching for globals...
[10:25:46.422] - globals found: [1] ‘{’
[10:25:46.422] Searching for globals ... DONE
[10:25:46.423] Resolving globals: FALSE
[10:25:46.423] 
[10:25:46.423] 
[10:25:46.423] getGlobalsAndPackages() ... DONE
[10:25:46.423] run() for ‘Future’ ...
[10:25:46.423] - state: ‘created’
[10:25:46.423] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.424] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.424] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.424]   - Field: ‘label’
[10:25:46.424]   - Field: ‘local’
[10:25:46.424]   - Field: ‘owner’
[10:25:46.424]   - Field: ‘envir’
[10:25:46.424]   - Field: ‘packages’
[10:25:46.424]   - Field: ‘gc’
[10:25:46.424]   - Field: ‘conditions’
[10:25:46.424]   - Field: ‘expr’
[10:25:46.425]   - Field: ‘uuid’
[10:25:46.425]   - Field: ‘seed’
[10:25:46.425]   - Field: ‘version’
[10:25:46.425]   - Field: ‘result’
[10:25:46.425]   - Field: ‘asynchronous’
[10:25:46.425]   - Field: ‘calls’
[10:25:46.425]   - Field: ‘globals’
[10:25:46.425]   - Field: ‘stdout’
[10:25:46.425]   - Field: ‘earlySignal’
[10:25:46.425]   - Field: ‘lazy’
[10:25:46.425]   - Field: ‘state’
[10:25:46.426] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.426] - Launch lazy future ...
[10:25:46.426] Packages needed by the future expression (n = 0): <none>
[10:25:46.426] Packages needed by future strategies (n = 0): <none>
[10:25:46.426] {
[10:25:46.426]     {
[10:25:46.426]         {
[10:25:46.426]             ...future.startTime <- base::Sys.time()
[10:25:46.426]             {
[10:25:46.426]                 {
[10:25:46.426]                   {
[10:25:46.426]                     base::local({
[10:25:46.426]                       has_future <- base::requireNamespace("future", 
[10:25:46.426]                         quietly = TRUE)
[10:25:46.426]                       if (has_future) {
[10:25:46.426]                         ns <- base::getNamespace("future")
[10:25:46.426]                         version <- ns[[".package"]][["version"]]
[10:25:46.426]                         if (is.null(version)) 
[10:25:46.426]                           version <- utils::packageVersion("future")
[10:25:46.426]                       }
[10:25:46.426]                       else {
[10:25:46.426]                         version <- NULL
[10:25:46.426]                       }
[10:25:46.426]                       if (!has_future || version < "1.8.0") {
[10:25:46.426]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.426]                           "", base::R.version$version.string), 
[10:25:46.426]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.426]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.426]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.426]                             "release", "version")], collapse = " "), 
[10:25:46.426]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.426]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.426]                           info)
[10:25:46.426]                         info <- base::paste(info, collapse = "; ")
[10:25:46.426]                         if (!has_future) {
[10:25:46.426]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.426]                             info)
[10:25:46.426]                         }
[10:25:46.426]                         else {
[10:25:46.426]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.426]                             info, version)
[10:25:46.426]                         }
[10:25:46.426]                         base::stop(msg)
[10:25:46.426]                       }
[10:25:46.426]                     })
[10:25:46.426]                   }
[10:25:46.426]                   options(future.plan = NULL)
[10:25:46.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.426]                 }
[10:25:46.426]                 ...future.workdir <- getwd()
[10:25:46.426]             }
[10:25:46.426]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.426]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.426]         }
[10:25:46.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.426]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.426]             base::names(...future.oldOptions))
[10:25:46.426]     }
[10:25:46.426]     if (FALSE) {
[10:25:46.426]     }
[10:25:46.426]     else {
[10:25:46.426]         if (TRUE) {
[10:25:46.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.426]                 open = "w")
[10:25:46.426]         }
[10:25:46.426]         else {
[10:25:46.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.426]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.426]         }
[10:25:46.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.426]             base::sink(type = "output", split = FALSE)
[10:25:46.426]             base::close(...future.stdout)
[10:25:46.426]         }, add = TRUE)
[10:25:46.426]     }
[10:25:46.426]     ...future.frame <- base::sys.nframe()
[10:25:46.426]     ...future.conditions <- base::list()
[10:25:46.426]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.426]     if (FALSE) {
[10:25:46.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.426]     }
[10:25:46.426]     ...future.result <- base::tryCatch({
[10:25:46.426]         base::withCallingHandlers({
[10:25:46.426]             ...future.value <- base::withVisible(base::local({
[10:25:46.426]                 4
[10:25:46.426]             }))
[10:25:46.426]             future::FutureResult(value = ...future.value$value, 
[10:25:46.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.426]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.426]                     ...future.globalenv.names))
[10:25:46.426]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.426]         }, condition = base::local({
[10:25:46.426]             c <- base::c
[10:25:46.426]             inherits <- base::inherits
[10:25:46.426]             invokeRestart <- base::invokeRestart
[10:25:46.426]             length <- base::length
[10:25:46.426]             list <- base::list
[10:25:46.426]             seq.int <- base::seq.int
[10:25:46.426]             signalCondition <- base::signalCondition
[10:25:46.426]             sys.calls <- base::sys.calls
[10:25:46.426]             `[[` <- base::`[[`
[10:25:46.426]             `+` <- base::`+`
[10:25:46.426]             `<<-` <- base::`<<-`
[10:25:46.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.426]                   3L)]
[10:25:46.426]             }
[10:25:46.426]             function(cond) {
[10:25:46.426]                 is_error <- inherits(cond, "error")
[10:25:46.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.426]                   NULL)
[10:25:46.426]                 if (is_error) {
[10:25:46.426]                   sessionInformation <- function() {
[10:25:46.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.426]                       search = base::search(), system = base::Sys.info())
[10:25:46.426]                   }
[10:25:46.426]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.426]                     cond$call), session = sessionInformation(), 
[10:25:46.426]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.426]                   signalCondition(cond)
[10:25:46.426]                 }
[10:25:46.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.426]                 "immediateCondition"))) {
[10:25:46.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.426]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.426]                   if (TRUE && !signal) {
[10:25:46.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.426]                     {
[10:25:46.426]                       inherits <- base::inherits
[10:25:46.426]                       invokeRestart <- base::invokeRestart
[10:25:46.426]                       is.null <- base::is.null
[10:25:46.426]                       muffled <- FALSE
[10:25:46.426]                       if (inherits(cond, "message")) {
[10:25:46.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.426]                         if (muffled) 
[10:25:46.426]                           invokeRestart("muffleMessage")
[10:25:46.426]                       }
[10:25:46.426]                       else if (inherits(cond, "warning")) {
[10:25:46.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.426]                         if (muffled) 
[10:25:46.426]                           invokeRestart("muffleWarning")
[10:25:46.426]                       }
[10:25:46.426]                       else if (inherits(cond, "condition")) {
[10:25:46.426]                         if (!is.null(pattern)) {
[10:25:46.426]                           computeRestarts <- base::computeRestarts
[10:25:46.426]                           grepl <- base::grepl
[10:25:46.426]                           restarts <- computeRestarts(cond)
[10:25:46.426]                           for (restart in restarts) {
[10:25:46.426]                             name <- restart$name
[10:25:46.426]                             if (is.null(name)) 
[10:25:46.426]                               next
[10:25:46.426]                             if (!grepl(pattern, name)) 
[10:25:46.426]                               next
[10:25:46.426]                             invokeRestart(restart)
[10:25:46.426]                             muffled <- TRUE
[10:25:46.426]                             break
[10:25:46.426]                           }
[10:25:46.426]                         }
[10:25:46.426]                       }
[10:25:46.426]                       invisible(muffled)
[10:25:46.426]                     }
[10:25:46.426]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.426]                   }
[10:25:46.426]                 }
[10:25:46.426]                 else {
[10:25:46.426]                   if (TRUE) {
[10:25:46.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.426]                     {
[10:25:46.426]                       inherits <- base::inherits
[10:25:46.426]                       invokeRestart <- base::invokeRestart
[10:25:46.426]                       is.null <- base::is.null
[10:25:46.426]                       muffled <- FALSE
[10:25:46.426]                       if (inherits(cond, "message")) {
[10:25:46.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.426]                         if (muffled) 
[10:25:46.426]                           invokeRestart("muffleMessage")
[10:25:46.426]                       }
[10:25:46.426]                       else if (inherits(cond, "warning")) {
[10:25:46.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.426]                         if (muffled) 
[10:25:46.426]                           invokeRestart("muffleWarning")
[10:25:46.426]                       }
[10:25:46.426]                       else if (inherits(cond, "condition")) {
[10:25:46.426]                         if (!is.null(pattern)) {
[10:25:46.426]                           computeRestarts <- base::computeRestarts
[10:25:46.426]                           grepl <- base::grepl
[10:25:46.426]                           restarts <- computeRestarts(cond)
[10:25:46.426]                           for (restart in restarts) {
[10:25:46.426]                             name <- restart$name
[10:25:46.426]                             if (is.null(name)) 
[10:25:46.426]                               next
[10:25:46.426]                             if (!grepl(pattern, name)) 
[10:25:46.426]                               next
[10:25:46.426]                             invokeRestart(restart)
[10:25:46.426]                             muffled <- TRUE
[10:25:46.426]                             break
[10:25:46.426]                           }
[10:25:46.426]                         }
[10:25:46.426]                       }
[10:25:46.426]                       invisible(muffled)
[10:25:46.426]                     }
[10:25:46.426]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.426]                   }
[10:25:46.426]                 }
[10:25:46.426]             }
[10:25:46.426]         }))
[10:25:46.426]     }, error = function(ex) {
[10:25:46.426]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.426]                 ...future.rng), started = ...future.startTime, 
[10:25:46.426]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.426]             version = "1.8"), class = "FutureResult")
[10:25:46.426]     }, finally = {
[10:25:46.426]         if (!identical(...future.workdir, getwd())) 
[10:25:46.426]             setwd(...future.workdir)
[10:25:46.426]         {
[10:25:46.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.426]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.426]             }
[10:25:46.426]             base::options(...future.oldOptions)
[10:25:46.426]             if (.Platform$OS.type == "windows") {
[10:25:46.426]                 old_names <- names(...future.oldEnvVars)
[10:25:46.426]                 envs <- base::Sys.getenv()
[10:25:46.426]                 names <- names(envs)
[10:25:46.426]                 common <- intersect(names, old_names)
[10:25:46.426]                 added <- setdiff(names, old_names)
[10:25:46.426]                 removed <- setdiff(old_names, names)
[10:25:46.426]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.426]                   envs[common]]
[10:25:46.426]                 NAMES <- toupper(changed)
[10:25:46.426]                 args <- list()
[10:25:46.426]                 for (kk in seq_along(NAMES)) {
[10:25:46.426]                   name <- changed[[kk]]
[10:25:46.426]                   NAME <- NAMES[[kk]]
[10:25:46.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.426]                     next
[10:25:46.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.426]                 }
[10:25:46.426]                 NAMES <- toupper(added)
[10:25:46.426]                 for (kk in seq_along(NAMES)) {
[10:25:46.426]                   name <- added[[kk]]
[10:25:46.426]                   NAME <- NAMES[[kk]]
[10:25:46.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.426]                     next
[10:25:46.426]                   args[[name]] <- ""
[10:25:46.426]                 }
[10:25:46.426]                 NAMES <- toupper(removed)
[10:25:46.426]                 for (kk in seq_along(NAMES)) {
[10:25:46.426]                   name <- removed[[kk]]
[10:25:46.426]                   NAME <- NAMES[[kk]]
[10:25:46.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.426]                     next
[10:25:46.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.426]                 }
[10:25:46.426]                 if (length(args) > 0) 
[10:25:46.426]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.426]             }
[10:25:46.426]             else {
[10:25:46.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.426]             }
[10:25:46.426]             {
[10:25:46.426]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.426]                   0L) {
[10:25:46.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.426]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.426]                   base::options(opts)
[10:25:46.426]                 }
[10:25:46.426]                 {
[10:25:46.426]                   {
[10:25:46.426]                     NULL
[10:25:46.426]                     RNGkind("Mersenne-Twister")
[10:25:46.426]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.426]                       inherits = FALSE)
[10:25:46.426]                   }
[10:25:46.426]                   options(future.plan = NULL)
[10:25:46.426]                   if (is.na(NA_character_)) 
[10:25:46.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.426]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.426]                   {
[10:25:46.426]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.426]                     if (!future$lazy) 
[10:25:46.426]                       future <- run(future)
[10:25:46.426]                     invisible(future)
[10:25:46.426]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.426]                 }
[10:25:46.426]             }
[10:25:46.426]         }
[10:25:46.426]     })
[10:25:46.426]     if (TRUE) {
[10:25:46.426]         base::sink(type = "output", split = FALSE)
[10:25:46.426]         if (TRUE) {
[10:25:46.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.426]         }
[10:25:46.426]         else {
[10:25:46.426]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.426]         }
[10:25:46.426]         base::close(...future.stdout)
[10:25:46.426]         ...future.stdout <- NULL
[10:25:46.426]     }
[10:25:46.426]     ...future.result$conditions <- ...future.conditions
[10:25:46.426]     ...future.result$finished <- base::Sys.time()
[10:25:46.426]     ...future.result
[10:25:46.426] }
[10:25:46.429] plan(): Setting new future strategy stack:
[10:25:46.429] List of future strategies:
[10:25:46.429] 1. sequential:
[10:25:46.429]    - args: function (..., envir = parent.frame())
[10:25:46.429]    - tweaked: FALSE
[10:25:46.429]    - call: NULL
[10:25:46.429] plan(): nbrOfWorkers() = 1
[10:25:46.430] plan(): Setting new future strategy stack:
[10:25:46.430] List of future strategies:
[10:25:46.430] 1. sequential:
[10:25:46.430]    - args: function (..., envir = parent.frame())
[10:25:46.430]    - tweaked: FALSE
[10:25:46.430]    - call: plan(strategy)
[10:25:46.431] plan(): nbrOfWorkers() = 1
[10:25:46.431] SequentialFuture started (and completed)
[10:25:46.431] - Launch lazy future ... done
[10:25:46.431] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f4623ec8> 
Classes 'listenv', 'environment' <environment: 0x55c0f3dc1c08> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:25:46.434] resolved() for ‘SequentialFuture’ ...
[10:25:46.434] - state: ‘finished’
[10:25:46.435] - run: TRUE
[10:25:46.435] - result: ‘FutureResult’
[10:25:46.435] resolved() for ‘SequentialFuture’ ... done
[10:25:46.435] resolved() for ‘SequentialFuture’ ...
[10:25:46.435] - state: ‘finished’
[10:25:46.435] - run: TRUE
[10:25:46.435] - result: ‘FutureResult’
[10:25:46.435] resolved() for ‘SequentialFuture’ ... done
[10:25:46.435] resolved() for ‘SequentialFuture’ ...
[10:25:46.435] - state: ‘finished’
[10:25:46.435] - run: TRUE
[10:25:46.436] - result: ‘FutureResult’
[10:25:46.436] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:46.438] resolve() on list environment ...
[10:25:46.438]  recursive: 0
[10:25:46.439]  length: 6
[10:25:46.439]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:46.439] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.439] - nx: 6
[10:25:46.439] - relay: TRUE
[10:25:46.439] - stdout: TRUE
[10:25:46.439] - signal: TRUE
[10:25:46.439] - resignal: FALSE
[10:25:46.440] - force: TRUE
[10:25:46.440] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.440] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.440]  - until=2
[10:25:46.440]  - relaying element #2
[10:25:46.440] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.440] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.440] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.440]  length: 5 (resolved future 1)
[10:25:46.440] resolved() for ‘SequentialFuture’ ...
[10:25:46.440] - state: ‘finished’
[10:25:46.440] - run: TRUE
[10:25:46.441] - result: ‘FutureResult’
[10:25:46.441] resolved() for ‘SequentialFuture’ ... done
[10:25:46.441] Future #2
[10:25:46.441] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.441] - nx: 6
[10:25:46.441] - relay: TRUE
[10:25:46.441] - stdout: TRUE
[10:25:46.441] - signal: TRUE
[10:25:46.441] - resignal: FALSE
[10:25:46.441] - force: TRUE
[10:25:46.441] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.442] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.442]  - until=2
[10:25:46.442]  - relaying element #2
[10:25:46.442] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.442] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.442] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.442]  length: 4 (resolved future 2)
[10:25:46.442] resolved() for ‘SequentialFuture’ ...
[10:25:46.442] - state: ‘finished’
[10:25:46.443] - run: TRUE
[10:25:46.443] - result: ‘FutureResult’
[10:25:46.443] resolved() for ‘SequentialFuture’ ... done
[10:25:46.443] Future #3
[10:25:46.443] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.443] - nx: 6
[10:25:46.443] - relay: TRUE
[10:25:46.443] - stdout: TRUE
[10:25:46.443] - signal: TRUE
[10:25:46.443] - resignal: FALSE
[10:25:46.443] - force: TRUE
[10:25:46.443] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.444] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.444]  - until=3
[10:25:46.444]  - relaying element #3
[10:25:46.444] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.444] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.444] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.444]  length: 3 (resolved future 3)
[10:25:46.444] resolved() for ‘SequentialFuture’ ...
[10:25:46.444] - state: ‘finished’
[10:25:46.444] - run: TRUE
[10:25:46.445] - result: ‘FutureResult’
[10:25:46.445] resolved() for ‘SequentialFuture’ ... done
[10:25:46.445] Future #4
[10:25:46.445] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.445] - nx: 6
[10:25:46.445] - relay: TRUE
[10:25:46.445] - stdout: TRUE
[10:25:46.445] - signal: TRUE
[10:25:46.445] - resignal: FALSE
[10:25:46.445] - force: TRUE
[10:25:46.445] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.445] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.446]  - until=4
[10:25:46.446]  - relaying element #4
[10:25:46.446] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.446] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.446] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.446]  length: 2 (resolved future 4)
[10:25:46.446] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.446] - nx: 6
[10:25:46.446] - relay: TRUE
[10:25:46.446] - stdout: TRUE
[10:25:46.447] - signal: TRUE
[10:25:46.447] - resignal: FALSE
[10:25:46.447] - force: TRUE
[10:25:46.447] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.447] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.447]  - until=6
[10:25:46.447]  - relaying element #6
[10:25:46.447] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.447] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.447] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.447]  length: 1 (resolved future 5)
[10:25:46.447] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.448] - nx: 6
[10:25:46.448] - relay: TRUE
[10:25:46.448] - stdout: TRUE
[10:25:46.448] - signal: TRUE
[10:25:46.448] - resignal: FALSE
[10:25:46.448] - force: TRUE
[10:25:46.448] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.448] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.448]  - until=6
[10:25:46.448] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.448] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.448] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.448]  length: 0 (resolved future 6)
[10:25:46.449] Relaying remaining futures
[10:25:46.449] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.449] - nx: 6
[10:25:46.449] - relay: TRUE
[10:25:46.449] - stdout: TRUE
[10:25:46.449] - signal: TRUE
[10:25:46.449] - resignal: FALSE
[10:25:46.449] - force: TRUE
[10:25:46.449] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.449] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:46.449] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.450] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.450] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.450] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c0f4bfd380> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:25:46.452] getGlobalsAndPackages() ...
[10:25:46.452] Searching for globals...
[10:25:46.453] 
[10:25:46.453] Searching for globals ... DONE
[10:25:46.453] - globals: [0] <none>
[10:25:46.453] getGlobalsAndPackages() ... DONE
[10:25:46.453] run() for ‘Future’ ...
[10:25:46.453] - state: ‘created’
[10:25:46.453] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.454] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.454]   - Field: ‘label’
[10:25:46.454]   - Field: ‘local’
[10:25:46.454]   - Field: ‘owner’
[10:25:46.454]   - Field: ‘envir’
[10:25:46.454]   - Field: ‘packages’
[10:25:46.454]   - Field: ‘gc’
[10:25:46.454]   - Field: ‘conditions’
[10:25:46.455]   - Field: ‘expr’
[10:25:46.455]   - Field: ‘uuid’
[10:25:46.455]   - Field: ‘seed’
[10:25:46.455]   - Field: ‘version’
[10:25:46.455]   - Field: ‘result’
[10:25:46.455]   - Field: ‘asynchronous’
[10:25:46.455]   - Field: ‘calls’
[10:25:46.455]   - Field: ‘globals’
[10:25:46.455]   - Field: ‘stdout’
[10:25:46.455]   - Field: ‘earlySignal’
[10:25:46.455]   - Field: ‘lazy’
[10:25:46.456]   - Field: ‘state’
[10:25:46.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.456] - Launch lazy future ...
[10:25:46.456] Packages needed by the future expression (n = 0): <none>
[10:25:46.456] Packages needed by future strategies (n = 0): <none>
[10:25:46.456] {
[10:25:46.456]     {
[10:25:46.456]         {
[10:25:46.456]             ...future.startTime <- base::Sys.time()
[10:25:46.456]             {
[10:25:46.456]                 {
[10:25:46.456]                   {
[10:25:46.456]                     base::local({
[10:25:46.456]                       has_future <- base::requireNamespace("future", 
[10:25:46.456]                         quietly = TRUE)
[10:25:46.456]                       if (has_future) {
[10:25:46.456]                         ns <- base::getNamespace("future")
[10:25:46.456]                         version <- ns[[".package"]][["version"]]
[10:25:46.456]                         if (is.null(version)) 
[10:25:46.456]                           version <- utils::packageVersion("future")
[10:25:46.456]                       }
[10:25:46.456]                       else {
[10:25:46.456]                         version <- NULL
[10:25:46.456]                       }
[10:25:46.456]                       if (!has_future || version < "1.8.0") {
[10:25:46.456]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.456]                           "", base::R.version$version.string), 
[10:25:46.456]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.456]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.456]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.456]                             "release", "version")], collapse = " "), 
[10:25:46.456]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.456]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.456]                           info)
[10:25:46.456]                         info <- base::paste(info, collapse = "; ")
[10:25:46.456]                         if (!has_future) {
[10:25:46.456]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.456]                             info)
[10:25:46.456]                         }
[10:25:46.456]                         else {
[10:25:46.456]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.456]                             info, version)
[10:25:46.456]                         }
[10:25:46.456]                         base::stop(msg)
[10:25:46.456]                       }
[10:25:46.456]                     })
[10:25:46.456]                   }
[10:25:46.456]                   options(future.plan = NULL)
[10:25:46.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.456]                 }
[10:25:46.456]                 ...future.workdir <- getwd()
[10:25:46.456]             }
[10:25:46.456]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.456]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.456]         }
[10:25:46.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.456]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.456]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.456]             base::names(...future.oldOptions))
[10:25:46.456]     }
[10:25:46.456]     if (FALSE) {
[10:25:46.456]     }
[10:25:46.456]     else {
[10:25:46.456]         if (TRUE) {
[10:25:46.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.456]                 open = "w")
[10:25:46.456]         }
[10:25:46.456]         else {
[10:25:46.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.456]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.456]         }
[10:25:46.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.456]             base::sink(type = "output", split = FALSE)
[10:25:46.456]             base::close(...future.stdout)
[10:25:46.456]         }, add = TRUE)
[10:25:46.456]     }
[10:25:46.456]     ...future.frame <- base::sys.nframe()
[10:25:46.456]     ...future.conditions <- base::list()
[10:25:46.456]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.456]     if (FALSE) {
[10:25:46.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.456]     }
[10:25:46.456]     ...future.result <- base::tryCatch({
[10:25:46.456]         base::withCallingHandlers({
[10:25:46.456]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.456]             future::FutureResult(value = ...future.value$value, 
[10:25:46.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.456]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.456]                     ...future.globalenv.names))
[10:25:46.456]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.456]         }, condition = base::local({
[10:25:46.456]             c <- base::c
[10:25:46.456]             inherits <- base::inherits
[10:25:46.456]             invokeRestart <- base::invokeRestart
[10:25:46.456]             length <- base::length
[10:25:46.456]             list <- base::list
[10:25:46.456]             seq.int <- base::seq.int
[10:25:46.456]             signalCondition <- base::signalCondition
[10:25:46.456]             sys.calls <- base::sys.calls
[10:25:46.456]             `[[` <- base::`[[`
[10:25:46.456]             `+` <- base::`+`
[10:25:46.456]             `<<-` <- base::`<<-`
[10:25:46.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.456]                   3L)]
[10:25:46.456]             }
[10:25:46.456]             function(cond) {
[10:25:46.456]                 is_error <- inherits(cond, "error")
[10:25:46.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.456]                   NULL)
[10:25:46.456]                 if (is_error) {
[10:25:46.456]                   sessionInformation <- function() {
[10:25:46.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.456]                       search = base::search(), system = base::Sys.info())
[10:25:46.456]                   }
[10:25:46.456]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.456]                     cond$call), session = sessionInformation(), 
[10:25:46.456]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.456]                   signalCondition(cond)
[10:25:46.456]                 }
[10:25:46.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.456]                 "immediateCondition"))) {
[10:25:46.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.456]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.456]                   if (TRUE && !signal) {
[10:25:46.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.456]                     {
[10:25:46.456]                       inherits <- base::inherits
[10:25:46.456]                       invokeRestart <- base::invokeRestart
[10:25:46.456]                       is.null <- base::is.null
[10:25:46.456]                       muffled <- FALSE
[10:25:46.456]                       if (inherits(cond, "message")) {
[10:25:46.456]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.456]                         if (muffled) 
[10:25:46.456]                           invokeRestart("muffleMessage")
[10:25:46.456]                       }
[10:25:46.456]                       else if (inherits(cond, "warning")) {
[10:25:46.456]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.456]                         if (muffled) 
[10:25:46.456]                           invokeRestart("muffleWarning")
[10:25:46.456]                       }
[10:25:46.456]                       else if (inherits(cond, "condition")) {
[10:25:46.456]                         if (!is.null(pattern)) {
[10:25:46.456]                           computeRestarts <- base::computeRestarts
[10:25:46.456]                           grepl <- base::grepl
[10:25:46.456]                           restarts <- computeRestarts(cond)
[10:25:46.456]                           for (restart in restarts) {
[10:25:46.456]                             name <- restart$name
[10:25:46.456]                             if (is.null(name)) 
[10:25:46.456]                               next
[10:25:46.456]                             if (!grepl(pattern, name)) 
[10:25:46.456]                               next
[10:25:46.456]                             invokeRestart(restart)
[10:25:46.456]                             muffled <- TRUE
[10:25:46.456]                             break
[10:25:46.456]                           }
[10:25:46.456]                         }
[10:25:46.456]                       }
[10:25:46.456]                       invisible(muffled)
[10:25:46.456]                     }
[10:25:46.456]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.456]                   }
[10:25:46.456]                 }
[10:25:46.456]                 else {
[10:25:46.456]                   if (TRUE) {
[10:25:46.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.456]                     {
[10:25:46.456]                       inherits <- base::inherits
[10:25:46.456]                       invokeRestart <- base::invokeRestart
[10:25:46.456]                       is.null <- base::is.null
[10:25:46.456]                       muffled <- FALSE
[10:25:46.456]                       if (inherits(cond, "message")) {
[10:25:46.456]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.456]                         if (muffled) 
[10:25:46.456]                           invokeRestart("muffleMessage")
[10:25:46.456]                       }
[10:25:46.456]                       else if (inherits(cond, "warning")) {
[10:25:46.456]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.456]                         if (muffled) 
[10:25:46.456]                           invokeRestart("muffleWarning")
[10:25:46.456]                       }
[10:25:46.456]                       else if (inherits(cond, "condition")) {
[10:25:46.456]                         if (!is.null(pattern)) {
[10:25:46.456]                           computeRestarts <- base::computeRestarts
[10:25:46.456]                           grepl <- base::grepl
[10:25:46.456]                           restarts <- computeRestarts(cond)
[10:25:46.456]                           for (restart in restarts) {
[10:25:46.456]                             name <- restart$name
[10:25:46.456]                             if (is.null(name)) 
[10:25:46.456]                               next
[10:25:46.456]                             if (!grepl(pattern, name)) 
[10:25:46.456]                               next
[10:25:46.456]                             invokeRestart(restart)
[10:25:46.456]                             muffled <- TRUE
[10:25:46.456]                             break
[10:25:46.456]                           }
[10:25:46.456]                         }
[10:25:46.456]                       }
[10:25:46.456]                       invisible(muffled)
[10:25:46.456]                     }
[10:25:46.456]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.456]                   }
[10:25:46.456]                 }
[10:25:46.456]             }
[10:25:46.456]         }))
[10:25:46.456]     }, error = function(ex) {
[10:25:46.456]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.456]                 ...future.rng), started = ...future.startTime, 
[10:25:46.456]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.456]             version = "1.8"), class = "FutureResult")
[10:25:46.456]     }, finally = {
[10:25:46.456]         if (!identical(...future.workdir, getwd())) 
[10:25:46.456]             setwd(...future.workdir)
[10:25:46.456]         {
[10:25:46.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.456]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.456]             }
[10:25:46.456]             base::options(...future.oldOptions)
[10:25:46.456]             if (.Platform$OS.type == "windows") {
[10:25:46.456]                 old_names <- names(...future.oldEnvVars)
[10:25:46.456]                 envs <- base::Sys.getenv()
[10:25:46.456]                 names <- names(envs)
[10:25:46.456]                 common <- intersect(names, old_names)
[10:25:46.456]                 added <- setdiff(names, old_names)
[10:25:46.456]                 removed <- setdiff(old_names, names)
[10:25:46.456]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.456]                   envs[common]]
[10:25:46.456]                 NAMES <- toupper(changed)
[10:25:46.456]                 args <- list()
[10:25:46.456]                 for (kk in seq_along(NAMES)) {
[10:25:46.456]                   name <- changed[[kk]]
[10:25:46.456]                   NAME <- NAMES[[kk]]
[10:25:46.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.456]                     next
[10:25:46.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.456]                 }
[10:25:46.456]                 NAMES <- toupper(added)
[10:25:46.456]                 for (kk in seq_along(NAMES)) {
[10:25:46.456]                   name <- added[[kk]]
[10:25:46.456]                   NAME <- NAMES[[kk]]
[10:25:46.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.456]                     next
[10:25:46.456]                   args[[name]] <- ""
[10:25:46.456]                 }
[10:25:46.456]                 NAMES <- toupper(removed)
[10:25:46.456]                 for (kk in seq_along(NAMES)) {
[10:25:46.456]                   name <- removed[[kk]]
[10:25:46.456]                   NAME <- NAMES[[kk]]
[10:25:46.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.456]                     next
[10:25:46.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.456]                 }
[10:25:46.456]                 if (length(args) > 0) 
[10:25:46.456]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.456]             }
[10:25:46.456]             else {
[10:25:46.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.456]             }
[10:25:46.456]             {
[10:25:46.456]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.456]                   0L) {
[10:25:46.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.456]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.456]                   base::options(opts)
[10:25:46.456]                 }
[10:25:46.456]                 {
[10:25:46.456]                   {
[10:25:46.456]                     NULL
[10:25:46.456]                     RNGkind("Mersenne-Twister")
[10:25:46.456]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.456]                       inherits = FALSE)
[10:25:46.456]                   }
[10:25:46.456]                   options(future.plan = NULL)
[10:25:46.456]                   if (is.na(NA_character_)) 
[10:25:46.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.456]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.456]                   {
[10:25:46.456]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.456]                     if (!future$lazy) 
[10:25:46.456]                       future <- run(future)
[10:25:46.456]                     invisible(future)
[10:25:46.456]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.456]                 }
[10:25:46.456]             }
[10:25:46.456]         }
[10:25:46.456]     })
[10:25:46.456]     if (TRUE) {
[10:25:46.456]         base::sink(type = "output", split = FALSE)
[10:25:46.456]         if (TRUE) {
[10:25:46.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.456]         }
[10:25:46.456]         else {
[10:25:46.456]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.456]         }
[10:25:46.456]         base::close(...future.stdout)
[10:25:46.456]         ...future.stdout <- NULL
[10:25:46.456]     }
[10:25:46.456]     ...future.result$conditions <- ...future.conditions
[10:25:46.456]     ...future.result$finished <- base::Sys.time()
[10:25:46.456]     ...future.result
[10:25:46.456] }
[10:25:46.458] plan(): Setting new future strategy stack:
[10:25:46.458] List of future strategies:
[10:25:46.458] 1. sequential:
[10:25:46.458]    - args: function (..., envir = parent.frame())
[10:25:46.458]    - tweaked: FALSE
[10:25:46.458]    - call: NULL
[10:25:46.459] plan(): nbrOfWorkers() = 1
[10:25:46.459] plan(): Setting new future strategy stack:
[10:25:46.459] List of future strategies:
[10:25:46.459] 1. sequential:
[10:25:46.459]    - args: function (..., envir = parent.frame())
[10:25:46.459]    - tweaked: FALSE
[10:25:46.459]    - call: plan(strategy)
[10:25:46.460] plan(): nbrOfWorkers() = 1
[10:25:46.460] SequentialFuture started (and completed)
[10:25:46.460] - Launch lazy future ... done
[10:25:46.460] run() for ‘SequentialFuture’ ... done
[10:25:46.460] getGlobalsAndPackages() ...
[10:25:46.460] Searching for globals...
[10:25:46.460] 
[10:25:46.461] Searching for globals ... DONE
[10:25:46.461] - globals: [0] <none>
[10:25:46.461] getGlobalsAndPackages() ... DONE
[10:25:46.461] run() for ‘Future’ ...
[10:25:46.461] - state: ‘created’
[10:25:46.461] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.461] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.461] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.462]   - Field: ‘label’
[10:25:46.462]   - Field: ‘local’
[10:25:46.462]   - Field: ‘owner’
[10:25:46.462]   - Field: ‘envir’
[10:25:46.462]   - Field: ‘packages’
[10:25:46.462]   - Field: ‘gc’
[10:25:46.462]   - Field: ‘conditions’
[10:25:46.462]   - Field: ‘expr’
[10:25:46.462]   - Field: ‘uuid’
[10:25:46.462]   - Field: ‘seed’
[10:25:46.463]   - Field: ‘version’
[10:25:46.463]   - Field: ‘result’
[10:25:46.463]   - Field: ‘asynchronous’
[10:25:46.463]   - Field: ‘calls’
[10:25:46.463]   - Field: ‘globals’
[10:25:46.463]   - Field: ‘stdout’
[10:25:46.463]   - Field: ‘earlySignal’
[10:25:46.463]   - Field: ‘lazy’
[10:25:46.463]   - Field: ‘state’
[10:25:46.463] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.463] - Launch lazy future ...
[10:25:46.464] Packages needed by the future expression (n = 0): <none>
[10:25:46.464] Packages needed by future strategies (n = 0): <none>
[10:25:46.464] {
[10:25:46.464]     {
[10:25:46.464]         {
[10:25:46.464]             ...future.startTime <- base::Sys.time()
[10:25:46.464]             {
[10:25:46.464]                 {
[10:25:46.464]                   {
[10:25:46.464]                     base::local({
[10:25:46.464]                       has_future <- base::requireNamespace("future", 
[10:25:46.464]                         quietly = TRUE)
[10:25:46.464]                       if (has_future) {
[10:25:46.464]                         ns <- base::getNamespace("future")
[10:25:46.464]                         version <- ns[[".package"]][["version"]]
[10:25:46.464]                         if (is.null(version)) 
[10:25:46.464]                           version <- utils::packageVersion("future")
[10:25:46.464]                       }
[10:25:46.464]                       else {
[10:25:46.464]                         version <- NULL
[10:25:46.464]                       }
[10:25:46.464]                       if (!has_future || version < "1.8.0") {
[10:25:46.464]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.464]                           "", base::R.version$version.string), 
[10:25:46.464]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.464]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.464]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.464]                             "release", "version")], collapse = " "), 
[10:25:46.464]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.464]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.464]                           info)
[10:25:46.464]                         info <- base::paste(info, collapse = "; ")
[10:25:46.464]                         if (!has_future) {
[10:25:46.464]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.464]                             info)
[10:25:46.464]                         }
[10:25:46.464]                         else {
[10:25:46.464]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.464]                             info, version)
[10:25:46.464]                         }
[10:25:46.464]                         base::stop(msg)
[10:25:46.464]                       }
[10:25:46.464]                     })
[10:25:46.464]                   }
[10:25:46.464]                   options(future.plan = NULL)
[10:25:46.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.464]                 }
[10:25:46.464]                 ...future.workdir <- getwd()
[10:25:46.464]             }
[10:25:46.464]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.464]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.464]         }
[10:25:46.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.464]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.464]             base::names(...future.oldOptions))
[10:25:46.464]     }
[10:25:46.464]     if (FALSE) {
[10:25:46.464]     }
[10:25:46.464]     else {
[10:25:46.464]         if (TRUE) {
[10:25:46.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.464]                 open = "w")
[10:25:46.464]         }
[10:25:46.464]         else {
[10:25:46.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.464]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.464]         }
[10:25:46.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.464]             base::sink(type = "output", split = FALSE)
[10:25:46.464]             base::close(...future.stdout)
[10:25:46.464]         }, add = TRUE)
[10:25:46.464]     }
[10:25:46.464]     ...future.frame <- base::sys.nframe()
[10:25:46.464]     ...future.conditions <- base::list()
[10:25:46.464]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.464]     if (FALSE) {
[10:25:46.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.464]     }
[10:25:46.464]     ...future.result <- base::tryCatch({
[10:25:46.464]         base::withCallingHandlers({
[10:25:46.464]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.464]             future::FutureResult(value = ...future.value$value, 
[10:25:46.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.464]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.464]                     ...future.globalenv.names))
[10:25:46.464]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.464]         }, condition = base::local({
[10:25:46.464]             c <- base::c
[10:25:46.464]             inherits <- base::inherits
[10:25:46.464]             invokeRestart <- base::invokeRestart
[10:25:46.464]             length <- base::length
[10:25:46.464]             list <- base::list
[10:25:46.464]             seq.int <- base::seq.int
[10:25:46.464]             signalCondition <- base::signalCondition
[10:25:46.464]             sys.calls <- base::sys.calls
[10:25:46.464]             `[[` <- base::`[[`
[10:25:46.464]             `+` <- base::`+`
[10:25:46.464]             `<<-` <- base::`<<-`
[10:25:46.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.464]                   3L)]
[10:25:46.464]             }
[10:25:46.464]             function(cond) {
[10:25:46.464]                 is_error <- inherits(cond, "error")
[10:25:46.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.464]                   NULL)
[10:25:46.464]                 if (is_error) {
[10:25:46.464]                   sessionInformation <- function() {
[10:25:46.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.464]                       search = base::search(), system = base::Sys.info())
[10:25:46.464]                   }
[10:25:46.464]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.464]                     cond$call), session = sessionInformation(), 
[10:25:46.464]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.464]                   signalCondition(cond)
[10:25:46.464]                 }
[10:25:46.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.464]                 "immediateCondition"))) {
[10:25:46.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.464]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.464]                   if (TRUE && !signal) {
[10:25:46.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.464]                     {
[10:25:46.464]                       inherits <- base::inherits
[10:25:46.464]                       invokeRestart <- base::invokeRestart
[10:25:46.464]                       is.null <- base::is.null
[10:25:46.464]                       muffled <- FALSE
[10:25:46.464]                       if (inherits(cond, "message")) {
[10:25:46.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.464]                         if (muffled) 
[10:25:46.464]                           invokeRestart("muffleMessage")
[10:25:46.464]                       }
[10:25:46.464]                       else if (inherits(cond, "warning")) {
[10:25:46.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.464]                         if (muffled) 
[10:25:46.464]                           invokeRestart("muffleWarning")
[10:25:46.464]                       }
[10:25:46.464]                       else if (inherits(cond, "condition")) {
[10:25:46.464]                         if (!is.null(pattern)) {
[10:25:46.464]                           computeRestarts <- base::computeRestarts
[10:25:46.464]                           grepl <- base::grepl
[10:25:46.464]                           restarts <- computeRestarts(cond)
[10:25:46.464]                           for (restart in restarts) {
[10:25:46.464]                             name <- restart$name
[10:25:46.464]                             if (is.null(name)) 
[10:25:46.464]                               next
[10:25:46.464]                             if (!grepl(pattern, name)) 
[10:25:46.464]                               next
[10:25:46.464]                             invokeRestart(restart)
[10:25:46.464]                             muffled <- TRUE
[10:25:46.464]                             break
[10:25:46.464]                           }
[10:25:46.464]                         }
[10:25:46.464]                       }
[10:25:46.464]                       invisible(muffled)
[10:25:46.464]                     }
[10:25:46.464]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.464]                   }
[10:25:46.464]                 }
[10:25:46.464]                 else {
[10:25:46.464]                   if (TRUE) {
[10:25:46.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.464]                     {
[10:25:46.464]                       inherits <- base::inherits
[10:25:46.464]                       invokeRestart <- base::invokeRestart
[10:25:46.464]                       is.null <- base::is.null
[10:25:46.464]                       muffled <- FALSE
[10:25:46.464]                       if (inherits(cond, "message")) {
[10:25:46.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.464]                         if (muffled) 
[10:25:46.464]                           invokeRestart("muffleMessage")
[10:25:46.464]                       }
[10:25:46.464]                       else if (inherits(cond, "warning")) {
[10:25:46.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.464]                         if (muffled) 
[10:25:46.464]                           invokeRestart("muffleWarning")
[10:25:46.464]                       }
[10:25:46.464]                       else if (inherits(cond, "condition")) {
[10:25:46.464]                         if (!is.null(pattern)) {
[10:25:46.464]                           computeRestarts <- base::computeRestarts
[10:25:46.464]                           grepl <- base::grepl
[10:25:46.464]                           restarts <- computeRestarts(cond)
[10:25:46.464]                           for (restart in restarts) {
[10:25:46.464]                             name <- restart$name
[10:25:46.464]                             if (is.null(name)) 
[10:25:46.464]                               next
[10:25:46.464]                             if (!grepl(pattern, name)) 
[10:25:46.464]                               next
[10:25:46.464]                             invokeRestart(restart)
[10:25:46.464]                             muffled <- TRUE
[10:25:46.464]                             break
[10:25:46.464]                           }
[10:25:46.464]                         }
[10:25:46.464]                       }
[10:25:46.464]                       invisible(muffled)
[10:25:46.464]                     }
[10:25:46.464]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.464]                   }
[10:25:46.464]                 }
[10:25:46.464]             }
[10:25:46.464]         }))
[10:25:46.464]     }, error = function(ex) {
[10:25:46.464]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.464]                 ...future.rng), started = ...future.startTime, 
[10:25:46.464]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.464]             version = "1.8"), class = "FutureResult")
[10:25:46.464]     }, finally = {
[10:25:46.464]         if (!identical(...future.workdir, getwd())) 
[10:25:46.464]             setwd(...future.workdir)
[10:25:46.464]         {
[10:25:46.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.464]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.464]             }
[10:25:46.464]             base::options(...future.oldOptions)
[10:25:46.464]             if (.Platform$OS.type == "windows") {
[10:25:46.464]                 old_names <- names(...future.oldEnvVars)
[10:25:46.464]                 envs <- base::Sys.getenv()
[10:25:46.464]                 names <- names(envs)
[10:25:46.464]                 common <- intersect(names, old_names)
[10:25:46.464]                 added <- setdiff(names, old_names)
[10:25:46.464]                 removed <- setdiff(old_names, names)
[10:25:46.464]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.464]                   envs[common]]
[10:25:46.464]                 NAMES <- toupper(changed)
[10:25:46.464]                 args <- list()
[10:25:46.464]                 for (kk in seq_along(NAMES)) {
[10:25:46.464]                   name <- changed[[kk]]
[10:25:46.464]                   NAME <- NAMES[[kk]]
[10:25:46.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.464]                     next
[10:25:46.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.464]                 }
[10:25:46.464]                 NAMES <- toupper(added)
[10:25:46.464]                 for (kk in seq_along(NAMES)) {
[10:25:46.464]                   name <- added[[kk]]
[10:25:46.464]                   NAME <- NAMES[[kk]]
[10:25:46.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.464]                     next
[10:25:46.464]                   args[[name]] <- ""
[10:25:46.464]                 }
[10:25:46.464]                 NAMES <- toupper(removed)
[10:25:46.464]                 for (kk in seq_along(NAMES)) {
[10:25:46.464]                   name <- removed[[kk]]
[10:25:46.464]                   NAME <- NAMES[[kk]]
[10:25:46.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.464]                     next
[10:25:46.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.464]                 }
[10:25:46.464]                 if (length(args) > 0) 
[10:25:46.464]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.464]             }
[10:25:46.464]             else {
[10:25:46.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.464]             }
[10:25:46.464]             {
[10:25:46.464]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.464]                   0L) {
[10:25:46.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.464]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.464]                   base::options(opts)
[10:25:46.464]                 }
[10:25:46.464]                 {
[10:25:46.464]                   {
[10:25:46.464]                     NULL
[10:25:46.464]                     RNGkind("Mersenne-Twister")
[10:25:46.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.464]                       inherits = FALSE)
[10:25:46.464]                   }
[10:25:46.464]                   options(future.plan = NULL)
[10:25:46.464]                   if (is.na(NA_character_)) 
[10:25:46.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.464]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.464]                   {
[10:25:46.464]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.464]                     if (!future$lazy) 
[10:25:46.464]                       future <- run(future)
[10:25:46.464]                     invisible(future)
[10:25:46.464]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.464]                 }
[10:25:46.464]             }
[10:25:46.464]         }
[10:25:46.464]     })
[10:25:46.464]     if (TRUE) {
[10:25:46.464]         base::sink(type = "output", split = FALSE)
[10:25:46.464]         if (TRUE) {
[10:25:46.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.464]         }
[10:25:46.464]         else {
[10:25:46.464]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.464]         }
[10:25:46.464]         base::close(...future.stdout)
[10:25:46.464]         ...future.stdout <- NULL
[10:25:46.464]     }
[10:25:46.464]     ...future.result$conditions <- ...future.conditions
[10:25:46.464]     ...future.result$finished <- base::Sys.time()
[10:25:46.464]     ...future.result
[10:25:46.464] }
[10:25:46.466] plan(): Setting new future strategy stack:
[10:25:46.466] List of future strategies:
[10:25:46.466] 1. sequential:
[10:25:46.466]    - args: function (..., envir = parent.frame())
[10:25:46.466]    - tweaked: FALSE
[10:25:46.466]    - call: NULL
[10:25:46.466] plan(): nbrOfWorkers() = 1
[10:25:46.467] plan(): Setting new future strategy stack:
[10:25:46.467] List of future strategies:
[10:25:46.467] 1. sequential:
[10:25:46.467]    - args: function (..., envir = parent.frame())
[10:25:46.467]    - tweaked: FALSE
[10:25:46.467]    - call: plan(strategy)
[10:25:46.467] plan(): nbrOfWorkers() = 1
[10:25:46.467] SequentialFuture started (and completed)
[10:25:46.468] - Launch lazy future ... done
[10:25:46.468] run() for ‘SequentialFuture’ ... done
[10:25:46.468] getGlobalsAndPackages() ...
[10:25:46.468] Searching for globals...
[10:25:46.469] - globals found: [1] ‘{’
[10:25:46.469] Searching for globals ... DONE
[10:25:46.469] Resolving globals: FALSE
[10:25:46.469] 
[10:25:46.469] 
[10:25:46.469] getGlobalsAndPackages() ... DONE
[10:25:46.469] run() for ‘Future’ ...
[10:25:46.469] - state: ‘created’
[10:25:46.470] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.470] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.470] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.470]   - Field: ‘label’
[10:25:46.470]   - Field: ‘local’
[10:25:46.470]   - Field: ‘owner’
[10:25:46.470]   - Field: ‘envir’
[10:25:46.470]   - Field: ‘packages’
[10:25:46.470]   - Field: ‘gc’
[10:25:46.471]   - Field: ‘conditions’
[10:25:46.471]   - Field: ‘expr’
[10:25:46.471]   - Field: ‘uuid’
[10:25:46.471]   - Field: ‘seed’
[10:25:46.471]   - Field: ‘version’
[10:25:46.471]   - Field: ‘result’
[10:25:46.471]   - Field: ‘asynchronous’
[10:25:46.471]   - Field: ‘calls’
[10:25:46.471]   - Field: ‘globals’
[10:25:46.471]   - Field: ‘stdout’
[10:25:46.471]   - Field: ‘earlySignal’
[10:25:46.471]   - Field: ‘lazy’
[10:25:46.472]   - Field: ‘state’
[10:25:46.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.472] - Launch lazy future ...
[10:25:46.472] Packages needed by the future expression (n = 0): <none>
[10:25:46.472] Packages needed by future strategies (n = 0): <none>
[10:25:46.472] {
[10:25:46.472]     {
[10:25:46.472]         {
[10:25:46.472]             ...future.startTime <- base::Sys.time()
[10:25:46.472]             {
[10:25:46.472]                 {
[10:25:46.472]                   {
[10:25:46.472]                     base::local({
[10:25:46.472]                       has_future <- base::requireNamespace("future", 
[10:25:46.472]                         quietly = TRUE)
[10:25:46.472]                       if (has_future) {
[10:25:46.472]                         ns <- base::getNamespace("future")
[10:25:46.472]                         version <- ns[[".package"]][["version"]]
[10:25:46.472]                         if (is.null(version)) 
[10:25:46.472]                           version <- utils::packageVersion("future")
[10:25:46.472]                       }
[10:25:46.472]                       else {
[10:25:46.472]                         version <- NULL
[10:25:46.472]                       }
[10:25:46.472]                       if (!has_future || version < "1.8.0") {
[10:25:46.472]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.472]                           "", base::R.version$version.string), 
[10:25:46.472]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.472]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.472]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.472]                             "release", "version")], collapse = " "), 
[10:25:46.472]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.472]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.472]                           info)
[10:25:46.472]                         info <- base::paste(info, collapse = "; ")
[10:25:46.472]                         if (!has_future) {
[10:25:46.472]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.472]                             info)
[10:25:46.472]                         }
[10:25:46.472]                         else {
[10:25:46.472]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.472]                             info, version)
[10:25:46.472]                         }
[10:25:46.472]                         base::stop(msg)
[10:25:46.472]                       }
[10:25:46.472]                     })
[10:25:46.472]                   }
[10:25:46.472]                   options(future.plan = NULL)
[10:25:46.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.472]                 }
[10:25:46.472]                 ...future.workdir <- getwd()
[10:25:46.472]             }
[10:25:46.472]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.472]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.472]         }
[10:25:46.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.472]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.472]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.472]             base::names(...future.oldOptions))
[10:25:46.472]     }
[10:25:46.472]     if (FALSE) {
[10:25:46.472]     }
[10:25:46.472]     else {
[10:25:46.472]         if (TRUE) {
[10:25:46.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.472]                 open = "w")
[10:25:46.472]         }
[10:25:46.472]         else {
[10:25:46.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.472]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.472]         }
[10:25:46.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.472]             base::sink(type = "output", split = FALSE)
[10:25:46.472]             base::close(...future.stdout)
[10:25:46.472]         }, add = TRUE)
[10:25:46.472]     }
[10:25:46.472]     ...future.frame <- base::sys.nframe()
[10:25:46.472]     ...future.conditions <- base::list()
[10:25:46.472]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.472]     if (FALSE) {
[10:25:46.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.472]     }
[10:25:46.472]     ...future.result <- base::tryCatch({
[10:25:46.472]         base::withCallingHandlers({
[10:25:46.472]             ...future.value <- base::withVisible(base::local({
[10:25:46.472]                 4
[10:25:46.472]             }))
[10:25:46.472]             future::FutureResult(value = ...future.value$value, 
[10:25:46.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.472]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.472]                     ...future.globalenv.names))
[10:25:46.472]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.472]         }, condition = base::local({
[10:25:46.472]             c <- base::c
[10:25:46.472]             inherits <- base::inherits
[10:25:46.472]             invokeRestart <- base::invokeRestart
[10:25:46.472]             length <- base::length
[10:25:46.472]             list <- base::list
[10:25:46.472]             seq.int <- base::seq.int
[10:25:46.472]             signalCondition <- base::signalCondition
[10:25:46.472]             sys.calls <- base::sys.calls
[10:25:46.472]             `[[` <- base::`[[`
[10:25:46.472]             `+` <- base::`+`
[10:25:46.472]             `<<-` <- base::`<<-`
[10:25:46.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.472]                   3L)]
[10:25:46.472]             }
[10:25:46.472]             function(cond) {
[10:25:46.472]                 is_error <- inherits(cond, "error")
[10:25:46.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.472]                   NULL)
[10:25:46.472]                 if (is_error) {
[10:25:46.472]                   sessionInformation <- function() {
[10:25:46.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.472]                       search = base::search(), system = base::Sys.info())
[10:25:46.472]                   }
[10:25:46.472]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.472]                     cond$call), session = sessionInformation(), 
[10:25:46.472]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.472]                   signalCondition(cond)
[10:25:46.472]                 }
[10:25:46.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.472]                 "immediateCondition"))) {
[10:25:46.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.472]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.472]                   if (TRUE && !signal) {
[10:25:46.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.472]                     {
[10:25:46.472]                       inherits <- base::inherits
[10:25:46.472]                       invokeRestart <- base::invokeRestart
[10:25:46.472]                       is.null <- base::is.null
[10:25:46.472]                       muffled <- FALSE
[10:25:46.472]                       if (inherits(cond, "message")) {
[10:25:46.472]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.472]                         if (muffled) 
[10:25:46.472]                           invokeRestart("muffleMessage")
[10:25:46.472]                       }
[10:25:46.472]                       else if (inherits(cond, "warning")) {
[10:25:46.472]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.472]                         if (muffled) 
[10:25:46.472]                           invokeRestart("muffleWarning")
[10:25:46.472]                       }
[10:25:46.472]                       else if (inherits(cond, "condition")) {
[10:25:46.472]                         if (!is.null(pattern)) {
[10:25:46.472]                           computeRestarts <- base::computeRestarts
[10:25:46.472]                           grepl <- base::grepl
[10:25:46.472]                           restarts <- computeRestarts(cond)
[10:25:46.472]                           for (restart in restarts) {
[10:25:46.472]                             name <- restart$name
[10:25:46.472]                             if (is.null(name)) 
[10:25:46.472]                               next
[10:25:46.472]                             if (!grepl(pattern, name)) 
[10:25:46.472]                               next
[10:25:46.472]                             invokeRestart(restart)
[10:25:46.472]                             muffled <- TRUE
[10:25:46.472]                             break
[10:25:46.472]                           }
[10:25:46.472]                         }
[10:25:46.472]                       }
[10:25:46.472]                       invisible(muffled)
[10:25:46.472]                     }
[10:25:46.472]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.472]                   }
[10:25:46.472]                 }
[10:25:46.472]                 else {
[10:25:46.472]                   if (TRUE) {
[10:25:46.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.472]                     {
[10:25:46.472]                       inherits <- base::inherits
[10:25:46.472]                       invokeRestart <- base::invokeRestart
[10:25:46.472]                       is.null <- base::is.null
[10:25:46.472]                       muffled <- FALSE
[10:25:46.472]                       if (inherits(cond, "message")) {
[10:25:46.472]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.472]                         if (muffled) 
[10:25:46.472]                           invokeRestart("muffleMessage")
[10:25:46.472]                       }
[10:25:46.472]                       else if (inherits(cond, "warning")) {
[10:25:46.472]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.472]                         if (muffled) 
[10:25:46.472]                           invokeRestart("muffleWarning")
[10:25:46.472]                       }
[10:25:46.472]                       else if (inherits(cond, "condition")) {
[10:25:46.472]                         if (!is.null(pattern)) {
[10:25:46.472]                           computeRestarts <- base::computeRestarts
[10:25:46.472]                           grepl <- base::grepl
[10:25:46.472]                           restarts <- computeRestarts(cond)
[10:25:46.472]                           for (restart in restarts) {
[10:25:46.472]                             name <- restart$name
[10:25:46.472]                             if (is.null(name)) 
[10:25:46.472]                               next
[10:25:46.472]                             if (!grepl(pattern, name)) 
[10:25:46.472]                               next
[10:25:46.472]                             invokeRestart(restart)
[10:25:46.472]                             muffled <- TRUE
[10:25:46.472]                             break
[10:25:46.472]                           }
[10:25:46.472]                         }
[10:25:46.472]                       }
[10:25:46.472]                       invisible(muffled)
[10:25:46.472]                     }
[10:25:46.472]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.472]                   }
[10:25:46.472]                 }
[10:25:46.472]             }
[10:25:46.472]         }))
[10:25:46.472]     }, error = function(ex) {
[10:25:46.472]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.472]                 ...future.rng), started = ...future.startTime, 
[10:25:46.472]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.472]             version = "1.8"), class = "FutureResult")
[10:25:46.472]     }, finally = {
[10:25:46.472]         if (!identical(...future.workdir, getwd())) 
[10:25:46.472]             setwd(...future.workdir)
[10:25:46.472]         {
[10:25:46.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.472]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.472]             }
[10:25:46.472]             base::options(...future.oldOptions)
[10:25:46.472]             if (.Platform$OS.type == "windows") {
[10:25:46.472]                 old_names <- names(...future.oldEnvVars)
[10:25:46.472]                 envs <- base::Sys.getenv()
[10:25:46.472]                 names <- names(envs)
[10:25:46.472]                 common <- intersect(names, old_names)
[10:25:46.472]                 added <- setdiff(names, old_names)
[10:25:46.472]                 removed <- setdiff(old_names, names)
[10:25:46.472]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.472]                   envs[common]]
[10:25:46.472]                 NAMES <- toupper(changed)
[10:25:46.472]                 args <- list()
[10:25:46.472]                 for (kk in seq_along(NAMES)) {
[10:25:46.472]                   name <- changed[[kk]]
[10:25:46.472]                   NAME <- NAMES[[kk]]
[10:25:46.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.472]                     next
[10:25:46.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.472]                 }
[10:25:46.472]                 NAMES <- toupper(added)
[10:25:46.472]                 for (kk in seq_along(NAMES)) {
[10:25:46.472]                   name <- added[[kk]]
[10:25:46.472]                   NAME <- NAMES[[kk]]
[10:25:46.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.472]                     next
[10:25:46.472]                   args[[name]] <- ""
[10:25:46.472]                 }
[10:25:46.472]                 NAMES <- toupper(removed)
[10:25:46.472]                 for (kk in seq_along(NAMES)) {
[10:25:46.472]                   name <- removed[[kk]]
[10:25:46.472]                   NAME <- NAMES[[kk]]
[10:25:46.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.472]                     next
[10:25:46.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.472]                 }
[10:25:46.472]                 if (length(args) > 0) 
[10:25:46.472]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.472]             }
[10:25:46.472]             else {
[10:25:46.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.472]             }
[10:25:46.472]             {
[10:25:46.472]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.472]                   0L) {
[10:25:46.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.472]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.472]                   base::options(opts)
[10:25:46.472]                 }
[10:25:46.472]                 {
[10:25:46.472]                   {
[10:25:46.472]                     NULL
[10:25:46.472]                     RNGkind("Mersenne-Twister")
[10:25:46.472]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.472]                       inherits = FALSE)
[10:25:46.472]                   }
[10:25:46.472]                   options(future.plan = NULL)
[10:25:46.472]                   if (is.na(NA_character_)) 
[10:25:46.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.472]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.472]                   {
[10:25:46.472]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.472]                     if (!future$lazy) 
[10:25:46.472]                       future <- run(future)
[10:25:46.472]                     invisible(future)
[10:25:46.472]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.472]                 }
[10:25:46.472]             }
[10:25:46.472]         }
[10:25:46.472]     })
[10:25:46.472]     if (TRUE) {
[10:25:46.472]         base::sink(type = "output", split = FALSE)
[10:25:46.472]         if (TRUE) {
[10:25:46.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.472]         }
[10:25:46.472]         else {
[10:25:46.472]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.472]         }
[10:25:46.472]         base::close(...future.stdout)
[10:25:46.472]         ...future.stdout <- NULL
[10:25:46.472]     }
[10:25:46.472]     ...future.result$conditions <- ...future.conditions
[10:25:46.472]     ...future.result$finished <- base::Sys.time()
[10:25:46.472]     ...future.result
[10:25:46.472] }
[10:25:46.474] plan(): Setting new future strategy stack:
[10:25:46.474] List of future strategies:
[10:25:46.474] 1. sequential:
[10:25:46.474]    - args: function (..., envir = parent.frame())
[10:25:46.474]    - tweaked: FALSE
[10:25:46.474]    - call: NULL
[10:25:46.475] plan(): nbrOfWorkers() = 1
[10:25:46.475] plan(): Setting new future strategy stack:
[10:25:46.475] List of future strategies:
[10:25:46.475] 1. sequential:
[10:25:46.475]    - args: function (..., envir = parent.frame())
[10:25:46.475]    - tweaked: FALSE
[10:25:46.475]    - call: plan(strategy)
[10:25:46.476] plan(): nbrOfWorkers() = 1
[10:25:46.476] SequentialFuture started (and completed)
[10:25:46.476] - Launch lazy future ... done
[10:25:46.476] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f5756938> 
Classes 'listenv', 'environment' <environment: 0x55c0f55af9f8> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:25:46.480] resolved() for ‘SequentialFuture’ ...
[10:25:46.481] - state: ‘finished’
[10:25:46.481] - run: TRUE
[10:25:46.481] - result: ‘FutureResult’
[10:25:46.481] resolved() for ‘SequentialFuture’ ... done
[10:25:46.481] resolved() for ‘SequentialFuture’ ...
[10:25:46.481] - state: ‘finished’
[10:25:46.481] - run: TRUE
[10:25:46.481] - result: ‘FutureResult’
[10:25:46.481] resolved() for ‘SequentialFuture’ ... done
[10:25:46.481] resolved() for ‘SequentialFuture’ ...
[10:25:46.481] - state: ‘finished’
[10:25:46.482] - run: TRUE
[10:25:46.482] - result: ‘FutureResult’
[10:25:46.482] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:46.484] resolve() on list environment ...
[10:25:46.484]  recursive: 0
[10:25:46.485]  length: 6
[10:25:46.485]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:46.485] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.485] - nx: 6
[10:25:46.486] - relay: TRUE
[10:25:46.486] - stdout: TRUE
[10:25:46.486] - signal: TRUE
[10:25:46.486] - resignal: FALSE
[10:25:46.486] - force: TRUE
[10:25:46.486] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.486] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.486]  - until=2
[10:25:46.486]  - relaying element #2
[10:25:46.486] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.486] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.486] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.487]  length: 5 (resolved future 1)
[10:25:46.487] resolved() for ‘SequentialFuture’ ...
[10:25:46.487] - state: ‘finished’
[10:25:46.487] - run: TRUE
[10:25:46.487] - result: ‘FutureResult’
[10:25:46.487] resolved() for ‘SequentialFuture’ ... done
[10:25:46.487] Future #2
[10:25:46.487] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.487] - nx: 6
[10:25:46.487] - relay: TRUE
[10:25:46.487] - stdout: TRUE
[10:25:46.488] - signal: TRUE
[10:25:46.488] - resignal: FALSE
[10:25:46.488] - force: TRUE
[10:25:46.488] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.488] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.488]  - until=2
[10:25:46.488]  - relaying element #2
[10:25:46.488] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.488] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.488] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.488]  length: 4 (resolved future 2)
[10:25:46.489] resolved() for ‘SequentialFuture’ ...
[10:25:46.489] - state: ‘finished’
[10:25:46.489] - run: TRUE
[10:25:46.489] - result: ‘FutureResult’
[10:25:46.489] resolved() for ‘SequentialFuture’ ... done
[10:25:46.489] Future #3
[10:25:46.489] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.489] - nx: 6
[10:25:46.489] - relay: TRUE
[10:25:46.489] - stdout: TRUE
[10:25:46.490] - signal: TRUE
[10:25:46.490] - resignal: FALSE
[10:25:46.490] - force: TRUE
[10:25:46.490] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.490] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.490]  - until=3
[10:25:46.490]  - relaying element #3
[10:25:46.490] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.490] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.490] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.490]  length: 3 (resolved future 3)
[10:25:46.491] resolved() for ‘SequentialFuture’ ...
[10:25:46.491] - state: ‘finished’
[10:25:46.491] - run: TRUE
[10:25:46.491] - result: ‘FutureResult’
[10:25:46.491] resolved() for ‘SequentialFuture’ ... done
[10:25:46.491] Future #4
[10:25:46.491] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.491] - nx: 6
[10:25:46.491] - relay: TRUE
[10:25:46.491] - stdout: TRUE
[10:25:46.491] - signal: TRUE
[10:25:46.491] - resignal: FALSE
[10:25:46.492] - force: TRUE
[10:25:46.492] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.492] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.492]  - until=4
[10:25:46.492]  - relaying element #4
[10:25:46.492] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.492] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.492] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.492]  length: 2 (resolved future 4)
[10:25:46.492] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.493] - nx: 6
[10:25:46.493] - relay: TRUE
[10:25:46.493] - stdout: TRUE
[10:25:46.493] - signal: TRUE
[10:25:46.493] - resignal: FALSE
[10:25:46.493] - force: TRUE
[10:25:46.493] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.493] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.493]  - until=6
[10:25:46.493]  - relaying element #6
[10:25:46.493] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.493] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.493] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.494]  length: 1 (resolved future 5)
[10:25:46.494] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.494] - nx: 6
[10:25:46.494] - relay: TRUE
[10:25:46.494] - stdout: TRUE
[10:25:46.494] - signal: TRUE
[10:25:46.494] - resignal: FALSE
[10:25:46.494] - force: TRUE
[10:25:46.494] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.494] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.494]  - until=6
[10:25:46.494] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.495] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.495] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.495]  length: 0 (resolved future 6)
[10:25:46.495] Relaying remaining futures
[10:25:46.495] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.495] - nx: 6
[10:25:46.495] - relay: TRUE
[10:25:46.495] - stdout: TRUE
[10:25:46.495] - signal: TRUE
[10:25:46.495] - resignal: FALSE
[10:25:46.495] - force: TRUE
[10:25:46.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.495] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:46.496] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.496] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.496] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.496] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c0f3989b00> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:25:46.498] getGlobalsAndPackages() ...
[10:25:46.498] Searching for globals...
[10:25:46.498] 
[10:25:46.499] Searching for globals ... DONE
[10:25:46.499] - globals: [0] <none>
[10:25:46.499] getGlobalsAndPackages() ... DONE
[10:25:46.499] run() for ‘Future’ ...
[10:25:46.499] - state: ‘created’
[10:25:46.499] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.500] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.500]   - Field: ‘label’
[10:25:46.500]   - Field: ‘local’
[10:25:46.500]   - Field: ‘owner’
[10:25:46.501]   - Field: ‘envir’
[10:25:46.501]   - Field: ‘packages’
[10:25:46.501]   - Field: ‘gc’
[10:25:46.501]   - Field: ‘conditions’
[10:25:46.501]   - Field: ‘expr’
[10:25:46.501]   - Field: ‘uuid’
[10:25:46.501]   - Field: ‘seed’
[10:25:46.501]   - Field: ‘version’
[10:25:46.502]   - Field: ‘result’
[10:25:46.502]   - Field: ‘asynchronous’
[10:25:46.502]   - Field: ‘calls’
[10:25:46.502]   - Field: ‘globals’
[10:25:46.502]   - Field: ‘stdout’
[10:25:46.502]   - Field: ‘earlySignal’
[10:25:46.502]   - Field: ‘lazy’
[10:25:46.502]   - Field: ‘state’
[10:25:46.502] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.502] - Launch lazy future ...
[10:25:46.503] Packages needed by the future expression (n = 0): <none>
[10:25:46.503] Packages needed by future strategies (n = 0): <none>
[10:25:46.504] {
[10:25:46.504]     {
[10:25:46.504]         {
[10:25:46.504]             ...future.startTime <- base::Sys.time()
[10:25:46.504]             {
[10:25:46.504]                 {
[10:25:46.504]                   {
[10:25:46.504]                     base::local({
[10:25:46.504]                       has_future <- base::requireNamespace("future", 
[10:25:46.504]                         quietly = TRUE)
[10:25:46.504]                       if (has_future) {
[10:25:46.504]                         ns <- base::getNamespace("future")
[10:25:46.504]                         version <- ns[[".package"]][["version"]]
[10:25:46.504]                         if (is.null(version)) 
[10:25:46.504]                           version <- utils::packageVersion("future")
[10:25:46.504]                       }
[10:25:46.504]                       else {
[10:25:46.504]                         version <- NULL
[10:25:46.504]                       }
[10:25:46.504]                       if (!has_future || version < "1.8.0") {
[10:25:46.504]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.504]                           "", base::R.version$version.string), 
[10:25:46.504]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.504]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.504]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.504]                             "release", "version")], collapse = " "), 
[10:25:46.504]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.504]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.504]                           info)
[10:25:46.504]                         info <- base::paste(info, collapse = "; ")
[10:25:46.504]                         if (!has_future) {
[10:25:46.504]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.504]                             info)
[10:25:46.504]                         }
[10:25:46.504]                         else {
[10:25:46.504]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.504]                             info, version)
[10:25:46.504]                         }
[10:25:46.504]                         base::stop(msg)
[10:25:46.504]                       }
[10:25:46.504]                     })
[10:25:46.504]                   }
[10:25:46.504]                   options(future.plan = NULL)
[10:25:46.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.504]                 }
[10:25:46.504]                 ...future.workdir <- getwd()
[10:25:46.504]             }
[10:25:46.504]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.504]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.504]         }
[10:25:46.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.504]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.504]             base::names(...future.oldOptions))
[10:25:46.504]     }
[10:25:46.504]     if (FALSE) {
[10:25:46.504]     }
[10:25:46.504]     else {
[10:25:46.504]         if (TRUE) {
[10:25:46.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.504]                 open = "w")
[10:25:46.504]         }
[10:25:46.504]         else {
[10:25:46.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.504]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.504]         }
[10:25:46.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.504]             base::sink(type = "output", split = FALSE)
[10:25:46.504]             base::close(...future.stdout)
[10:25:46.504]         }, add = TRUE)
[10:25:46.504]     }
[10:25:46.504]     ...future.frame <- base::sys.nframe()
[10:25:46.504]     ...future.conditions <- base::list()
[10:25:46.504]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.504]     if (FALSE) {
[10:25:46.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.504]     }
[10:25:46.504]     ...future.result <- base::tryCatch({
[10:25:46.504]         base::withCallingHandlers({
[10:25:46.504]             ...future.value <- base::withVisible(base::local(2))
[10:25:46.504]             future::FutureResult(value = ...future.value$value, 
[10:25:46.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.504]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.504]                     ...future.globalenv.names))
[10:25:46.504]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.504]         }, condition = base::local({
[10:25:46.504]             c <- base::c
[10:25:46.504]             inherits <- base::inherits
[10:25:46.504]             invokeRestart <- base::invokeRestart
[10:25:46.504]             length <- base::length
[10:25:46.504]             list <- base::list
[10:25:46.504]             seq.int <- base::seq.int
[10:25:46.504]             signalCondition <- base::signalCondition
[10:25:46.504]             sys.calls <- base::sys.calls
[10:25:46.504]             `[[` <- base::`[[`
[10:25:46.504]             `+` <- base::`+`
[10:25:46.504]             `<<-` <- base::`<<-`
[10:25:46.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.504]                   3L)]
[10:25:46.504]             }
[10:25:46.504]             function(cond) {
[10:25:46.504]                 is_error <- inherits(cond, "error")
[10:25:46.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.504]                   NULL)
[10:25:46.504]                 if (is_error) {
[10:25:46.504]                   sessionInformation <- function() {
[10:25:46.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.504]                       search = base::search(), system = base::Sys.info())
[10:25:46.504]                   }
[10:25:46.504]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.504]                     cond$call), session = sessionInformation(), 
[10:25:46.504]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.504]                   signalCondition(cond)
[10:25:46.504]                 }
[10:25:46.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.504]                 "immediateCondition"))) {
[10:25:46.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.504]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.504]                   if (TRUE && !signal) {
[10:25:46.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.504]                     {
[10:25:46.504]                       inherits <- base::inherits
[10:25:46.504]                       invokeRestart <- base::invokeRestart
[10:25:46.504]                       is.null <- base::is.null
[10:25:46.504]                       muffled <- FALSE
[10:25:46.504]                       if (inherits(cond, "message")) {
[10:25:46.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.504]                         if (muffled) 
[10:25:46.504]                           invokeRestart("muffleMessage")
[10:25:46.504]                       }
[10:25:46.504]                       else if (inherits(cond, "warning")) {
[10:25:46.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.504]                         if (muffled) 
[10:25:46.504]                           invokeRestart("muffleWarning")
[10:25:46.504]                       }
[10:25:46.504]                       else if (inherits(cond, "condition")) {
[10:25:46.504]                         if (!is.null(pattern)) {
[10:25:46.504]                           computeRestarts <- base::computeRestarts
[10:25:46.504]                           grepl <- base::grepl
[10:25:46.504]                           restarts <- computeRestarts(cond)
[10:25:46.504]                           for (restart in restarts) {
[10:25:46.504]                             name <- restart$name
[10:25:46.504]                             if (is.null(name)) 
[10:25:46.504]                               next
[10:25:46.504]                             if (!grepl(pattern, name)) 
[10:25:46.504]                               next
[10:25:46.504]                             invokeRestart(restart)
[10:25:46.504]                             muffled <- TRUE
[10:25:46.504]                             break
[10:25:46.504]                           }
[10:25:46.504]                         }
[10:25:46.504]                       }
[10:25:46.504]                       invisible(muffled)
[10:25:46.504]                     }
[10:25:46.504]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.504]                   }
[10:25:46.504]                 }
[10:25:46.504]                 else {
[10:25:46.504]                   if (TRUE) {
[10:25:46.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.504]                     {
[10:25:46.504]                       inherits <- base::inherits
[10:25:46.504]                       invokeRestart <- base::invokeRestart
[10:25:46.504]                       is.null <- base::is.null
[10:25:46.504]                       muffled <- FALSE
[10:25:46.504]                       if (inherits(cond, "message")) {
[10:25:46.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.504]                         if (muffled) 
[10:25:46.504]                           invokeRestart("muffleMessage")
[10:25:46.504]                       }
[10:25:46.504]                       else if (inherits(cond, "warning")) {
[10:25:46.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.504]                         if (muffled) 
[10:25:46.504]                           invokeRestart("muffleWarning")
[10:25:46.504]                       }
[10:25:46.504]                       else if (inherits(cond, "condition")) {
[10:25:46.504]                         if (!is.null(pattern)) {
[10:25:46.504]                           computeRestarts <- base::computeRestarts
[10:25:46.504]                           grepl <- base::grepl
[10:25:46.504]                           restarts <- computeRestarts(cond)
[10:25:46.504]                           for (restart in restarts) {
[10:25:46.504]                             name <- restart$name
[10:25:46.504]                             if (is.null(name)) 
[10:25:46.504]                               next
[10:25:46.504]                             if (!grepl(pattern, name)) 
[10:25:46.504]                               next
[10:25:46.504]                             invokeRestart(restart)
[10:25:46.504]                             muffled <- TRUE
[10:25:46.504]                             break
[10:25:46.504]                           }
[10:25:46.504]                         }
[10:25:46.504]                       }
[10:25:46.504]                       invisible(muffled)
[10:25:46.504]                     }
[10:25:46.504]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.504]                   }
[10:25:46.504]                 }
[10:25:46.504]             }
[10:25:46.504]         }))
[10:25:46.504]     }, error = function(ex) {
[10:25:46.504]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.504]                 ...future.rng), started = ...future.startTime, 
[10:25:46.504]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.504]             version = "1.8"), class = "FutureResult")
[10:25:46.504]     }, finally = {
[10:25:46.504]         if (!identical(...future.workdir, getwd())) 
[10:25:46.504]             setwd(...future.workdir)
[10:25:46.504]         {
[10:25:46.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.504]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.504]             }
[10:25:46.504]             base::options(...future.oldOptions)
[10:25:46.504]             if (.Platform$OS.type == "windows") {
[10:25:46.504]                 old_names <- names(...future.oldEnvVars)
[10:25:46.504]                 envs <- base::Sys.getenv()
[10:25:46.504]                 names <- names(envs)
[10:25:46.504]                 common <- intersect(names, old_names)
[10:25:46.504]                 added <- setdiff(names, old_names)
[10:25:46.504]                 removed <- setdiff(old_names, names)
[10:25:46.504]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.504]                   envs[common]]
[10:25:46.504]                 NAMES <- toupper(changed)
[10:25:46.504]                 args <- list()
[10:25:46.504]                 for (kk in seq_along(NAMES)) {
[10:25:46.504]                   name <- changed[[kk]]
[10:25:46.504]                   NAME <- NAMES[[kk]]
[10:25:46.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.504]                     next
[10:25:46.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.504]                 }
[10:25:46.504]                 NAMES <- toupper(added)
[10:25:46.504]                 for (kk in seq_along(NAMES)) {
[10:25:46.504]                   name <- added[[kk]]
[10:25:46.504]                   NAME <- NAMES[[kk]]
[10:25:46.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.504]                     next
[10:25:46.504]                   args[[name]] <- ""
[10:25:46.504]                 }
[10:25:46.504]                 NAMES <- toupper(removed)
[10:25:46.504]                 for (kk in seq_along(NAMES)) {
[10:25:46.504]                   name <- removed[[kk]]
[10:25:46.504]                   NAME <- NAMES[[kk]]
[10:25:46.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.504]                     next
[10:25:46.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.504]                 }
[10:25:46.504]                 if (length(args) > 0) 
[10:25:46.504]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.504]             }
[10:25:46.504]             else {
[10:25:46.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.504]             }
[10:25:46.504]             {
[10:25:46.504]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.504]                   0L) {
[10:25:46.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.504]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.504]                   base::options(opts)
[10:25:46.504]                 }
[10:25:46.504]                 {
[10:25:46.504]                   {
[10:25:46.504]                     NULL
[10:25:46.504]                     RNGkind("Mersenne-Twister")
[10:25:46.504]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.504]                       inherits = FALSE)
[10:25:46.504]                   }
[10:25:46.504]                   options(future.plan = NULL)
[10:25:46.504]                   if (is.na(NA_character_)) 
[10:25:46.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.504]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.504]                   {
[10:25:46.504]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.504]                     if (!future$lazy) 
[10:25:46.504]                       future <- run(future)
[10:25:46.504]                     invisible(future)
[10:25:46.504]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.504]                 }
[10:25:46.504]             }
[10:25:46.504]         }
[10:25:46.504]     })
[10:25:46.504]     if (TRUE) {
[10:25:46.504]         base::sink(type = "output", split = FALSE)
[10:25:46.504]         if (TRUE) {
[10:25:46.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.504]         }
[10:25:46.504]         else {
[10:25:46.504]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.504]         }
[10:25:46.504]         base::close(...future.stdout)
[10:25:46.504]         ...future.stdout <- NULL
[10:25:46.504]     }
[10:25:46.504]     ...future.result$conditions <- ...future.conditions
[10:25:46.504]     ...future.result$finished <- base::Sys.time()
[10:25:46.504]     ...future.result
[10:25:46.504] }
[10:25:46.506] plan(): Setting new future strategy stack:
[10:25:46.506] List of future strategies:
[10:25:46.506] 1. sequential:
[10:25:46.506]    - args: function (..., envir = parent.frame())
[10:25:46.506]    - tweaked: FALSE
[10:25:46.506]    - call: NULL
[10:25:46.506] plan(): nbrOfWorkers() = 1
[10:25:46.507] plan(): Setting new future strategy stack:
[10:25:46.507] List of future strategies:
[10:25:46.507] 1. sequential:
[10:25:46.507]    - args: function (..., envir = parent.frame())
[10:25:46.507]    - tweaked: FALSE
[10:25:46.507]    - call: plan(strategy)
[10:25:46.507] plan(): nbrOfWorkers() = 1
[10:25:46.508] SequentialFuture started (and completed)
[10:25:46.508] - Launch lazy future ... done
[10:25:46.508] run() for ‘SequentialFuture’ ... done
[10:25:46.508] getGlobalsAndPackages() ...
[10:25:46.508] Searching for globals...
[10:25:46.508] 
[10:25:46.508] Searching for globals ... DONE
[10:25:46.508] - globals: [0] <none>
[10:25:46.508] getGlobalsAndPackages() ... DONE
[10:25:46.509] run() for ‘Future’ ...
[10:25:46.509] - state: ‘created’
[10:25:46.509] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.509] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.509]   - Field: ‘label’
[10:25:46.509]   - Field: ‘local’
[10:25:46.510]   - Field: ‘owner’
[10:25:46.510]   - Field: ‘envir’
[10:25:46.510]   - Field: ‘packages’
[10:25:46.510]   - Field: ‘gc’
[10:25:46.510]   - Field: ‘conditions’
[10:25:46.510]   - Field: ‘expr’
[10:25:46.510]   - Field: ‘uuid’
[10:25:46.510]   - Field: ‘seed’
[10:25:46.510]   - Field: ‘version’
[10:25:46.510]   - Field: ‘result’
[10:25:46.510]   - Field: ‘asynchronous’
[10:25:46.511]   - Field: ‘calls’
[10:25:46.511]   - Field: ‘globals’
[10:25:46.511]   - Field: ‘stdout’
[10:25:46.511]   - Field: ‘earlySignal’
[10:25:46.511]   - Field: ‘lazy’
[10:25:46.511]   - Field: ‘state’
[10:25:46.511] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.511] - Launch lazy future ...
[10:25:46.511] Packages needed by the future expression (n = 0): <none>
[10:25:46.511] Packages needed by future strategies (n = 0): <none>
[10:25:46.512] {
[10:25:46.512]     {
[10:25:46.512]         {
[10:25:46.512]             ...future.startTime <- base::Sys.time()
[10:25:46.512]             {
[10:25:46.512]                 {
[10:25:46.512]                   {
[10:25:46.512]                     base::local({
[10:25:46.512]                       has_future <- base::requireNamespace("future", 
[10:25:46.512]                         quietly = TRUE)
[10:25:46.512]                       if (has_future) {
[10:25:46.512]                         ns <- base::getNamespace("future")
[10:25:46.512]                         version <- ns[[".package"]][["version"]]
[10:25:46.512]                         if (is.null(version)) 
[10:25:46.512]                           version <- utils::packageVersion("future")
[10:25:46.512]                       }
[10:25:46.512]                       else {
[10:25:46.512]                         version <- NULL
[10:25:46.512]                       }
[10:25:46.512]                       if (!has_future || version < "1.8.0") {
[10:25:46.512]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.512]                           "", base::R.version$version.string), 
[10:25:46.512]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.512]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.512]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.512]                             "release", "version")], collapse = " "), 
[10:25:46.512]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.512]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.512]                           info)
[10:25:46.512]                         info <- base::paste(info, collapse = "; ")
[10:25:46.512]                         if (!has_future) {
[10:25:46.512]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.512]                             info)
[10:25:46.512]                         }
[10:25:46.512]                         else {
[10:25:46.512]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.512]                             info, version)
[10:25:46.512]                         }
[10:25:46.512]                         base::stop(msg)
[10:25:46.512]                       }
[10:25:46.512]                     })
[10:25:46.512]                   }
[10:25:46.512]                   options(future.plan = NULL)
[10:25:46.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.512]                 }
[10:25:46.512]                 ...future.workdir <- getwd()
[10:25:46.512]             }
[10:25:46.512]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.512]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.512]         }
[10:25:46.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.512]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.512]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.512]             base::names(...future.oldOptions))
[10:25:46.512]     }
[10:25:46.512]     if (FALSE) {
[10:25:46.512]     }
[10:25:46.512]     else {
[10:25:46.512]         if (TRUE) {
[10:25:46.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.512]                 open = "w")
[10:25:46.512]         }
[10:25:46.512]         else {
[10:25:46.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.512]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.512]         }
[10:25:46.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.512]             base::sink(type = "output", split = FALSE)
[10:25:46.512]             base::close(...future.stdout)
[10:25:46.512]         }, add = TRUE)
[10:25:46.512]     }
[10:25:46.512]     ...future.frame <- base::sys.nframe()
[10:25:46.512]     ...future.conditions <- base::list()
[10:25:46.512]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.512]     if (FALSE) {
[10:25:46.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.512]     }
[10:25:46.512]     ...future.result <- base::tryCatch({
[10:25:46.512]         base::withCallingHandlers({
[10:25:46.512]             ...future.value <- base::withVisible(base::local(NULL))
[10:25:46.512]             future::FutureResult(value = ...future.value$value, 
[10:25:46.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.512]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.512]                     ...future.globalenv.names))
[10:25:46.512]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.512]         }, condition = base::local({
[10:25:46.512]             c <- base::c
[10:25:46.512]             inherits <- base::inherits
[10:25:46.512]             invokeRestart <- base::invokeRestart
[10:25:46.512]             length <- base::length
[10:25:46.512]             list <- base::list
[10:25:46.512]             seq.int <- base::seq.int
[10:25:46.512]             signalCondition <- base::signalCondition
[10:25:46.512]             sys.calls <- base::sys.calls
[10:25:46.512]             `[[` <- base::`[[`
[10:25:46.512]             `+` <- base::`+`
[10:25:46.512]             `<<-` <- base::`<<-`
[10:25:46.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.512]                   3L)]
[10:25:46.512]             }
[10:25:46.512]             function(cond) {
[10:25:46.512]                 is_error <- inherits(cond, "error")
[10:25:46.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.512]                   NULL)
[10:25:46.512]                 if (is_error) {
[10:25:46.512]                   sessionInformation <- function() {
[10:25:46.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.512]                       search = base::search(), system = base::Sys.info())
[10:25:46.512]                   }
[10:25:46.512]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.512]                     cond$call), session = sessionInformation(), 
[10:25:46.512]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.512]                   signalCondition(cond)
[10:25:46.512]                 }
[10:25:46.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.512]                 "immediateCondition"))) {
[10:25:46.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.512]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.512]                   if (TRUE && !signal) {
[10:25:46.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.512]                     {
[10:25:46.512]                       inherits <- base::inherits
[10:25:46.512]                       invokeRestart <- base::invokeRestart
[10:25:46.512]                       is.null <- base::is.null
[10:25:46.512]                       muffled <- FALSE
[10:25:46.512]                       if (inherits(cond, "message")) {
[10:25:46.512]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.512]                         if (muffled) 
[10:25:46.512]                           invokeRestart("muffleMessage")
[10:25:46.512]                       }
[10:25:46.512]                       else if (inherits(cond, "warning")) {
[10:25:46.512]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.512]                         if (muffled) 
[10:25:46.512]                           invokeRestart("muffleWarning")
[10:25:46.512]                       }
[10:25:46.512]                       else if (inherits(cond, "condition")) {
[10:25:46.512]                         if (!is.null(pattern)) {
[10:25:46.512]                           computeRestarts <- base::computeRestarts
[10:25:46.512]                           grepl <- base::grepl
[10:25:46.512]                           restarts <- computeRestarts(cond)
[10:25:46.512]                           for (restart in restarts) {
[10:25:46.512]                             name <- restart$name
[10:25:46.512]                             if (is.null(name)) 
[10:25:46.512]                               next
[10:25:46.512]                             if (!grepl(pattern, name)) 
[10:25:46.512]                               next
[10:25:46.512]                             invokeRestart(restart)
[10:25:46.512]                             muffled <- TRUE
[10:25:46.512]                             break
[10:25:46.512]                           }
[10:25:46.512]                         }
[10:25:46.512]                       }
[10:25:46.512]                       invisible(muffled)
[10:25:46.512]                     }
[10:25:46.512]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.512]                   }
[10:25:46.512]                 }
[10:25:46.512]                 else {
[10:25:46.512]                   if (TRUE) {
[10:25:46.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.512]                     {
[10:25:46.512]                       inherits <- base::inherits
[10:25:46.512]                       invokeRestart <- base::invokeRestart
[10:25:46.512]                       is.null <- base::is.null
[10:25:46.512]                       muffled <- FALSE
[10:25:46.512]                       if (inherits(cond, "message")) {
[10:25:46.512]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.512]                         if (muffled) 
[10:25:46.512]                           invokeRestart("muffleMessage")
[10:25:46.512]                       }
[10:25:46.512]                       else if (inherits(cond, "warning")) {
[10:25:46.512]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.512]                         if (muffled) 
[10:25:46.512]                           invokeRestart("muffleWarning")
[10:25:46.512]                       }
[10:25:46.512]                       else if (inherits(cond, "condition")) {
[10:25:46.512]                         if (!is.null(pattern)) {
[10:25:46.512]                           computeRestarts <- base::computeRestarts
[10:25:46.512]                           grepl <- base::grepl
[10:25:46.512]                           restarts <- computeRestarts(cond)
[10:25:46.512]                           for (restart in restarts) {
[10:25:46.512]                             name <- restart$name
[10:25:46.512]                             if (is.null(name)) 
[10:25:46.512]                               next
[10:25:46.512]                             if (!grepl(pattern, name)) 
[10:25:46.512]                               next
[10:25:46.512]                             invokeRestart(restart)
[10:25:46.512]                             muffled <- TRUE
[10:25:46.512]                             break
[10:25:46.512]                           }
[10:25:46.512]                         }
[10:25:46.512]                       }
[10:25:46.512]                       invisible(muffled)
[10:25:46.512]                     }
[10:25:46.512]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.512]                   }
[10:25:46.512]                 }
[10:25:46.512]             }
[10:25:46.512]         }))
[10:25:46.512]     }, error = function(ex) {
[10:25:46.512]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.512]                 ...future.rng), started = ...future.startTime, 
[10:25:46.512]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.512]             version = "1.8"), class = "FutureResult")
[10:25:46.512]     }, finally = {
[10:25:46.512]         if (!identical(...future.workdir, getwd())) 
[10:25:46.512]             setwd(...future.workdir)
[10:25:46.512]         {
[10:25:46.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.512]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.512]             }
[10:25:46.512]             base::options(...future.oldOptions)
[10:25:46.512]             if (.Platform$OS.type == "windows") {
[10:25:46.512]                 old_names <- names(...future.oldEnvVars)
[10:25:46.512]                 envs <- base::Sys.getenv()
[10:25:46.512]                 names <- names(envs)
[10:25:46.512]                 common <- intersect(names, old_names)
[10:25:46.512]                 added <- setdiff(names, old_names)
[10:25:46.512]                 removed <- setdiff(old_names, names)
[10:25:46.512]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.512]                   envs[common]]
[10:25:46.512]                 NAMES <- toupper(changed)
[10:25:46.512]                 args <- list()
[10:25:46.512]                 for (kk in seq_along(NAMES)) {
[10:25:46.512]                   name <- changed[[kk]]
[10:25:46.512]                   NAME <- NAMES[[kk]]
[10:25:46.512]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.512]                     next
[10:25:46.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.512]                 }
[10:25:46.512]                 NAMES <- toupper(added)
[10:25:46.512]                 for (kk in seq_along(NAMES)) {
[10:25:46.512]                   name <- added[[kk]]
[10:25:46.512]                   NAME <- NAMES[[kk]]
[10:25:46.512]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.512]                     next
[10:25:46.512]                   args[[name]] <- ""
[10:25:46.512]                 }
[10:25:46.512]                 NAMES <- toupper(removed)
[10:25:46.512]                 for (kk in seq_along(NAMES)) {
[10:25:46.512]                   name <- removed[[kk]]
[10:25:46.512]                   NAME <- NAMES[[kk]]
[10:25:46.512]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.512]                     next
[10:25:46.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.512]                 }
[10:25:46.512]                 if (length(args) > 0) 
[10:25:46.512]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.512]             }
[10:25:46.512]             else {
[10:25:46.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.512]             }
[10:25:46.512]             {
[10:25:46.512]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.512]                   0L) {
[10:25:46.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.512]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.512]                   base::options(opts)
[10:25:46.512]                 }
[10:25:46.512]                 {
[10:25:46.512]                   {
[10:25:46.512]                     NULL
[10:25:46.512]                     RNGkind("Mersenne-Twister")
[10:25:46.512]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.512]                       inherits = FALSE)
[10:25:46.512]                   }
[10:25:46.512]                   options(future.plan = NULL)
[10:25:46.512]                   if (is.na(NA_character_)) 
[10:25:46.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.512]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.512]                   {
[10:25:46.512]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.512]                     if (!future$lazy) 
[10:25:46.512]                       future <- run(future)
[10:25:46.512]                     invisible(future)
[10:25:46.512]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.512]                 }
[10:25:46.512]             }
[10:25:46.512]         }
[10:25:46.512]     })
[10:25:46.512]     if (TRUE) {
[10:25:46.512]         base::sink(type = "output", split = FALSE)
[10:25:46.512]         if (TRUE) {
[10:25:46.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.512]         }
[10:25:46.512]         else {
[10:25:46.512]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.512]         }
[10:25:46.512]         base::close(...future.stdout)
[10:25:46.512]         ...future.stdout <- NULL
[10:25:46.512]     }
[10:25:46.512]     ...future.result$conditions <- ...future.conditions
[10:25:46.512]     ...future.result$finished <- base::Sys.time()
[10:25:46.512]     ...future.result
[10:25:46.512] }
[10:25:46.513] plan(): Setting new future strategy stack:
[10:25:46.514] List of future strategies:
[10:25:46.514] 1. sequential:
[10:25:46.514]    - args: function (..., envir = parent.frame())
[10:25:46.514]    - tweaked: FALSE
[10:25:46.514]    - call: NULL
[10:25:46.514] plan(): nbrOfWorkers() = 1
[10:25:46.515] plan(): Setting new future strategy stack:
[10:25:46.515] List of future strategies:
[10:25:46.515] 1. sequential:
[10:25:46.515]    - args: function (..., envir = parent.frame())
[10:25:46.515]    - tweaked: FALSE
[10:25:46.515]    - call: plan(strategy)
[10:25:46.515] plan(): nbrOfWorkers() = 1
[10:25:46.515] SequentialFuture started (and completed)
[10:25:46.515] - Launch lazy future ... done
[10:25:46.515] run() for ‘SequentialFuture’ ... done
[10:25:46.516] getGlobalsAndPackages() ...
[10:25:46.516] Searching for globals...
[10:25:46.516] - globals found: [1] ‘{’
[10:25:46.516] Searching for globals ... DONE
[10:25:46.516] Resolving globals: FALSE
[10:25:46.517] 
[10:25:46.517] 
[10:25:46.517] getGlobalsAndPackages() ... DONE
[10:25:46.517] run() for ‘Future’ ...
[10:25:46.517] - state: ‘created’
[10:25:46.517] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:46.518] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:46.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:46.518]   - Field: ‘label’
[10:25:46.518]   - Field: ‘local’
[10:25:46.518]   - Field: ‘owner’
[10:25:46.518]   - Field: ‘envir’
[10:25:46.518]   - Field: ‘packages’
[10:25:46.518]   - Field: ‘gc’
[10:25:46.518]   - Field: ‘conditions’
[10:25:46.518]   - Field: ‘expr’
[10:25:46.518]   - Field: ‘uuid’
[10:25:46.519]   - Field: ‘seed’
[10:25:46.519]   - Field: ‘version’
[10:25:46.519]   - Field: ‘result’
[10:25:46.519]   - Field: ‘asynchronous’
[10:25:46.519]   - Field: ‘calls’
[10:25:46.519]   - Field: ‘globals’
[10:25:46.519]   - Field: ‘stdout’
[10:25:46.519]   - Field: ‘earlySignal’
[10:25:46.519]   - Field: ‘lazy’
[10:25:46.519]   - Field: ‘state’
[10:25:46.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:46.520] - Launch lazy future ...
[10:25:46.520] Packages needed by the future expression (n = 0): <none>
[10:25:46.520] Packages needed by future strategies (n = 0): <none>
[10:25:46.520] {
[10:25:46.520]     {
[10:25:46.520]         {
[10:25:46.520]             ...future.startTime <- base::Sys.time()
[10:25:46.520]             {
[10:25:46.520]                 {
[10:25:46.520]                   {
[10:25:46.520]                     base::local({
[10:25:46.520]                       has_future <- base::requireNamespace("future", 
[10:25:46.520]                         quietly = TRUE)
[10:25:46.520]                       if (has_future) {
[10:25:46.520]                         ns <- base::getNamespace("future")
[10:25:46.520]                         version <- ns[[".package"]][["version"]]
[10:25:46.520]                         if (is.null(version)) 
[10:25:46.520]                           version <- utils::packageVersion("future")
[10:25:46.520]                       }
[10:25:46.520]                       else {
[10:25:46.520]                         version <- NULL
[10:25:46.520]                       }
[10:25:46.520]                       if (!has_future || version < "1.8.0") {
[10:25:46.520]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.520]                           "", base::R.version$version.string), 
[10:25:46.520]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:46.520]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.520]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.520]                             "release", "version")], collapse = " "), 
[10:25:46.520]                           hostname = base::Sys.info()[["nodename"]])
[10:25:46.520]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.520]                           info)
[10:25:46.520]                         info <- base::paste(info, collapse = "; ")
[10:25:46.520]                         if (!has_future) {
[10:25:46.520]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.520]                             info)
[10:25:46.520]                         }
[10:25:46.520]                         else {
[10:25:46.520]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.520]                             info, version)
[10:25:46.520]                         }
[10:25:46.520]                         base::stop(msg)
[10:25:46.520]                       }
[10:25:46.520]                     })
[10:25:46.520]                   }
[10:25:46.520]                   options(future.plan = NULL)
[10:25:46.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.520]                 }
[10:25:46.520]                 ...future.workdir <- getwd()
[10:25:46.520]             }
[10:25:46.520]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.520]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.520]         }
[10:25:46.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.520]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.520]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.520]             base::names(...future.oldOptions))
[10:25:46.520]     }
[10:25:46.520]     if (FALSE) {
[10:25:46.520]     }
[10:25:46.520]     else {
[10:25:46.520]         if (TRUE) {
[10:25:46.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.520]                 open = "w")
[10:25:46.520]         }
[10:25:46.520]         else {
[10:25:46.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.520]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.520]         }
[10:25:46.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.520]             base::sink(type = "output", split = FALSE)
[10:25:46.520]             base::close(...future.stdout)
[10:25:46.520]         }, add = TRUE)
[10:25:46.520]     }
[10:25:46.520]     ...future.frame <- base::sys.nframe()
[10:25:46.520]     ...future.conditions <- base::list()
[10:25:46.520]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.520]     if (FALSE) {
[10:25:46.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.520]     }
[10:25:46.520]     ...future.result <- base::tryCatch({
[10:25:46.520]         base::withCallingHandlers({
[10:25:46.520]             ...future.value <- base::withVisible(base::local({
[10:25:46.520]                 4
[10:25:46.520]             }))
[10:25:46.520]             future::FutureResult(value = ...future.value$value, 
[10:25:46.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.520]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.520]                     ...future.globalenv.names))
[10:25:46.520]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.520]         }, condition = base::local({
[10:25:46.520]             c <- base::c
[10:25:46.520]             inherits <- base::inherits
[10:25:46.520]             invokeRestart <- base::invokeRestart
[10:25:46.520]             length <- base::length
[10:25:46.520]             list <- base::list
[10:25:46.520]             seq.int <- base::seq.int
[10:25:46.520]             signalCondition <- base::signalCondition
[10:25:46.520]             sys.calls <- base::sys.calls
[10:25:46.520]             `[[` <- base::`[[`
[10:25:46.520]             `+` <- base::`+`
[10:25:46.520]             `<<-` <- base::`<<-`
[10:25:46.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.520]                   3L)]
[10:25:46.520]             }
[10:25:46.520]             function(cond) {
[10:25:46.520]                 is_error <- inherits(cond, "error")
[10:25:46.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.520]                   NULL)
[10:25:46.520]                 if (is_error) {
[10:25:46.520]                   sessionInformation <- function() {
[10:25:46.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.520]                       search = base::search(), system = base::Sys.info())
[10:25:46.520]                   }
[10:25:46.520]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.520]                     cond$call), session = sessionInformation(), 
[10:25:46.520]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.520]                   signalCondition(cond)
[10:25:46.520]                 }
[10:25:46.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.520]                 "immediateCondition"))) {
[10:25:46.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.520]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.520]                   if (TRUE && !signal) {
[10:25:46.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.520]                     {
[10:25:46.520]                       inherits <- base::inherits
[10:25:46.520]                       invokeRestart <- base::invokeRestart
[10:25:46.520]                       is.null <- base::is.null
[10:25:46.520]                       muffled <- FALSE
[10:25:46.520]                       if (inherits(cond, "message")) {
[10:25:46.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.520]                         if (muffled) 
[10:25:46.520]                           invokeRestart("muffleMessage")
[10:25:46.520]                       }
[10:25:46.520]                       else if (inherits(cond, "warning")) {
[10:25:46.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.520]                         if (muffled) 
[10:25:46.520]                           invokeRestart("muffleWarning")
[10:25:46.520]                       }
[10:25:46.520]                       else if (inherits(cond, "condition")) {
[10:25:46.520]                         if (!is.null(pattern)) {
[10:25:46.520]                           computeRestarts <- base::computeRestarts
[10:25:46.520]                           grepl <- base::grepl
[10:25:46.520]                           restarts <- computeRestarts(cond)
[10:25:46.520]                           for (restart in restarts) {
[10:25:46.520]                             name <- restart$name
[10:25:46.520]                             if (is.null(name)) 
[10:25:46.520]                               next
[10:25:46.520]                             if (!grepl(pattern, name)) 
[10:25:46.520]                               next
[10:25:46.520]                             invokeRestart(restart)
[10:25:46.520]                             muffled <- TRUE
[10:25:46.520]                             break
[10:25:46.520]                           }
[10:25:46.520]                         }
[10:25:46.520]                       }
[10:25:46.520]                       invisible(muffled)
[10:25:46.520]                     }
[10:25:46.520]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.520]                   }
[10:25:46.520]                 }
[10:25:46.520]                 else {
[10:25:46.520]                   if (TRUE) {
[10:25:46.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.520]                     {
[10:25:46.520]                       inherits <- base::inherits
[10:25:46.520]                       invokeRestart <- base::invokeRestart
[10:25:46.520]                       is.null <- base::is.null
[10:25:46.520]                       muffled <- FALSE
[10:25:46.520]                       if (inherits(cond, "message")) {
[10:25:46.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.520]                         if (muffled) 
[10:25:46.520]                           invokeRestart("muffleMessage")
[10:25:46.520]                       }
[10:25:46.520]                       else if (inherits(cond, "warning")) {
[10:25:46.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.520]                         if (muffled) 
[10:25:46.520]                           invokeRestart("muffleWarning")
[10:25:46.520]                       }
[10:25:46.520]                       else if (inherits(cond, "condition")) {
[10:25:46.520]                         if (!is.null(pattern)) {
[10:25:46.520]                           computeRestarts <- base::computeRestarts
[10:25:46.520]                           grepl <- base::grepl
[10:25:46.520]                           restarts <- computeRestarts(cond)
[10:25:46.520]                           for (restart in restarts) {
[10:25:46.520]                             name <- restart$name
[10:25:46.520]                             if (is.null(name)) 
[10:25:46.520]                               next
[10:25:46.520]                             if (!grepl(pattern, name)) 
[10:25:46.520]                               next
[10:25:46.520]                             invokeRestart(restart)
[10:25:46.520]                             muffled <- TRUE
[10:25:46.520]                             break
[10:25:46.520]                           }
[10:25:46.520]                         }
[10:25:46.520]                       }
[10:25:46.520]                       invisible(muffled)
[10:25:46.520]                     }
[10:25:46.520]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.520]                   }
[10:25:46.520]                 }
[10:25:46.520]             }
[10:25:46.520]         }))
[10:25:46.520]     }, error = function(ex) {
[10:25:46.520]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.520]                 ...future.rng), started = ...future.startTime, 
[10:25:46.520]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.520]             version = "1.8"), class = "FutureResult")
[10:25:46.520]     }, finally = {
[10:25:46.520]         if (!identical(...future.workdir, getwd())) 
[10:25:46.520]             setwd(...future.workdir)
[10:25:46.520]         {
[10:25:46.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.520]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.520]             }
[10:25:46.520]             base::options(...future.oldOptions)
[10:25:46.520]             if (.Platform$OS.type == "windows") {
[10:25:46.520]                 old_names <- names(...future.oldEnvVars)
[10:25:46.520]                 envs <- base::Sys.getenv()
[10:25:46.520]                 names <- names(envs)
[10:25:46.520]                 common <- intersect(names, old_names)
[10:25:46.520]                 added <- setdiff(names, old_names)
[10:25:46.520]                 removed <- setdiff(old_names, names)
[10:25:46.520]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.520]                   envs[common]]
[10:25:46.520]                 NAMES <- toupper(changed)
[10:25:46.520]                 args <- list()
[10:25:46.520]                 for (kk in seq_along(NAMES)) {
[10:25:46.520]                   name <- changed[[kk]]
[10:25:46.520]                   NAME <- NAMES[[kk]]
[10:25:46.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.520]                     next
[10:25:46.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.520]                 }
[10:25:46.520]                 NAMES <- toupper(added)
[10:25:46.520]                 for (kk in seq_along(NAMES)) {
[10:25:46.520]                   name <- added[[kk]]
[10:25:46.520]                   NAME <- NAMES[[kk]]
[10:25:46.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.520]                     next
[10:25:46.520]                   args[[name]] <- ""
[10:25:46.520]                 }
[10:25:46.520]                 NAMES <- toupper(removed)
[10:25:46.520]                 for (kk in seq_along(NAMES)) {
[10:25:46.520]                   name <- removed[[kk]]
[10:25:46.520]                   NAME <- NAMES[[kk]]
[10:25:46.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.520]                     next
[10:25:46.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.520]                 }
[10:25:46.520]                 if (length(args) > 0) 
[10:25:46.520]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.520]             }
[10:25:46.520]             else {
[10:25:46.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.520]             }
[10:25:46.520]             {
[10:25:46.520]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.520]                   0L) {
[10:25:46.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.520]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.520]                   base::options(opts)
[10:25:46.520]                 }
[10:25:46.520]                 {
[10:25:46.520]                   {
[10:25:46.520]                     NULL
[10:25:46.520]                     RNGkind("Mersenne-Twister")
[10:25:46.520]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:46.520]                       inherits = FALSE)
[10:25:46.520]                   }
[10:25:46.520]                   options(future.plan = NULL)
[10:25:46.520]                   if (is.na(NA_character_)) 
[10:25:46.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.520]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:46.520]                   {
[10:25:46.520]                     future <- SequentialFuture(..., envir = envir)
[10:25:46.520]                     if (!future$lazy) 
[10:25:46.520]                       future <- run(future)
[10:25:46.520]                     invisible(future)
[10:25:46.520]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.520]                 }
[10:25:46.520]             }
[10:25:46.520]         }
[10:25:46.520]     })
[10:25:46.520]     if (TRUE) {
[10:25:46.520]         base::sink(type = "output", split = FALSE)
[10:25:46.520]         if (TRUE) {
[10:25:46.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.520]         }
[10:25:46.520]         else {
[10:25:46.520]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.520]         }
[10:25:46.520]         base::close(...future.stdout)
[10:25:46.520]         ...future.stdout <- NULL
[10:25:46.520]     }
[10:25:46.520]     ...future.result$conditions <- ...future.conditions
[10:25:46.520]     ...future.result$finished <- base::Sys.time()
[10:25:46.520]     ...future.result
[10:25:46.520] }
[10:25:46.522] plan(): Setting new future strategy stack:
[10:25:46.522] List of future strategies:
[10:25:46.522] 1. sequential:
[10:25:46.522]    - args: function (..., envir = parent.frame())
[10:25:46.522]    - tweaked: FALSE
[10:25:46.522]    - call: NULL
[10:25:46.522] plan(): nbrOfWorkers() = 1
[10:25:46.523] plan(): Setting new future strategy stack:
[10:25:46.523] List of future strategies:
[10:25:46.523] 1. sequential:
[10:25:46.523]    - args: function (..., envir = parent.frame())
[10:25:46.523]    - tweaked: FALSE
[10:25:46.523]    - call: plan(strategy)
[10:25:46.523] plan(): nbrOfWorkers() = 1
[10:25:46.524] SequentialFuture started (and completed)
[10:25:46.524] - Launch lazy future ... done
[10:25:46.524] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f54eb418> 
Classes 'listenv', 'environment' <environment: 0x55c0f51cf708> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:25:46.528] resolved() for ‘SequentialFuture’ ...
[10:25:46.528] - state: ‘finished’
[10:25:46.528] - run: TRUE
[10:25:46.528] - result: ‘FutureResult’
[10:25:46.528] resolved() for ‘SequentialFuture’ ... done
[10:25:46.528] resolved() for ‘SequentialFuture’ ...
[10:25:46.528] - state: ‘finished’
[10:25:46.528] - run: TRUE
[10:25:46.528] - result: ‘FutureResult’
[10:25:46.529] resolved() for ‘SequentialFuture’ ... done
[10:25:46.529] resolved() for ‘SequentialFuture’ ...
[10:25:46.529] - state: ‘finished’
[10:25:46.529] - run: TRUE
[10:25:46.529] - result: ‘FutureResult’
[10:25:46.529] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:46.533] resolve() on list environment ...
[10:25:46.533]  recursive: 0
[10:25:46.534]  length: 6
[10:25:46.534]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:46.534] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.534] - nx: 6
[10:25:46.534] - relay: TRUE
[10:25:46.534] - stdout: TRUE
[10:25:46.534] - signal: TRUE
[10:25:46.534] - resignal: FALSE
[10:25:46.534] - force: TRUE
[10:25:46.534] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.535] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.535]  - until=2
[10:25:46.535]  - relaying element #2
[10:25:46.535] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.535] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.535] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.535]  length: 5 (resolved future 1)
[10:25:46.535] resolved() for ‘SequentialFuture’ ...
[10:25:46.535] - state: ‘finished’
[10:25:46.535] - run: TRUE
[10:25:46.535] - result: ‘FutureResult’
[10:25:46.536] resolved() for ‘SequentialFuture’ ... done
[10:25:46.536] Future #2
[10:25:46.536] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:25:46.536] - nx: 6
[10:25:46.536] - relay: TRUE
[10:25:46.536] - stdout: TRUE
[10:25:46.536] - signal: TRUE
[10:25:46.536] - resignal: FALSE
[10:25:46.536] - force: TRUE
[10:25:46.536] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.536] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.537]  - until=2
[10:25:46.537]  - relaying element #2
[10:25:46.537] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.537] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.537] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:25:46.537]  length: 4 (resolved future 2)
[10:25:46.537] resolved() for ‘SequentialFuture’ ...
[10:25:46.537] - state: ‘finished’
[10:25:46.537] - run: TRUE
[10:25:46.537] - result: ‘FutureResult’
[10:25:46.538] resolved() for ‘SequentialFuture’ ... done
[10:25:46.538] Future #3
[10:25:46.538] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:25:46.538] - nx: 6
[10:25:46.538] - relay: TRUE
[10:25:46.538] - stdout: TRUE
[10:25:46.538] - signal: TRUE
[10:25:46.538] - resignal: FALSE
[10:25:46.538] - force: TRUE
[10:25:46.538] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.538] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.538]  - until=3
[10:25:46.539]  - relaying element #3
[10:25:46.539] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.539] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.539] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:25:46.539]  length: 3 (resolved future 3)
[10:25:46.539] resolved() for ‘SequentialFuture’ ...
[10:25:46.539] - state: ‘finished’
[10:25:46.539] - run: TRUE
[10:25:46.539] - result: ‘FutureResult’
[10:25:46.539] resolved() for ‘SequentialFuture’ ... done
[10:25:46.540] Future #4
[10:25:46.540] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:25:46.540] - nx: 6
[10:25:46.540] - relay: TRUE
[10:25:46.540] - stdout: TRUE
[10:25:46.540] - signal: TRUE
[10:25:46.540] - resignal: FALSE
[10:25:46.540] - force: TRUE
[10:25:46.540] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.540] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.540]  - until=4
[10:25:46.540]  - relaying element #4
[10:25:46.541] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.541] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.541] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:25:46.541]  length: 2 (resolved future 4)
[10:25:46.541] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.541] - nx: 6
[10:25:46.541] - relay: TRUE
[10:25:46.541] - stdout: TRUE
[10:25:46.541] - signal: TRUE
[10:25:46.541] - resignal: FALSE
[10:25:46.541] - force: TRUE
[10:25:46.542] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.542] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.542]  - until=6
[10:25:46.542]  - relaying element #6
[10:25:46.542] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.542] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.542] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.542]  length: 1 (resolved future 5)
[10:25:46.542] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.542] - nx: 6
[10:25:46.542] - relay: TRUE
[10:25:46.542] - stdout: TRUE
[10:25:46.543] - signal: TRUE
[10:25:46.543] - resignal: FALSE
[10:25:46.543] - force: TRUE
[10:25:46.543] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.543] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.543]  - until=6
[10:25:46.543] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.543] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.543] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.543]  length: 0 (resolved future 6)
[10:25:46.543] Relaying remaining futures
[10:25:46.543] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.544] - nx: 6
[10:25:46.544] - relay: TRUE
[10:25:46.544] - stdout: TRUE
[10:25:46.544] - signal: TRUE
[10:25:46.544] - resignal: FALSE
[10:25:46.544] - force: TRUE
[10:25:46.544] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.544] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:46.544] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.544] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.544] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.544] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55c0f5900e38> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[10:25:46.547] plan(): Setting new future strategy stack:
[10:25:46.547] List of future strategies:
[10:25:46.547] 1. multicore:
[10:25:46.547]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.547]    - tweaked: FALSE
[10:25:46.547]    - call: plan(strategy)
[10:25:46.551] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:25:46.551] getGlobalsAndPackages() ...
[10:25:46.551] Searching for globals...
[10:25:46.552] 
[10:25:46.552] Searching for globals ... DONE
[10:25:46.552] - globals: [0] <none>
[10:25:46.552] getGlobalsAndPackages() ... DONE
[10:25:46.552] run() for ‘Future’ ...
[10:25:46.552] - state: ‘created’
[10:25:46.552] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.556] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.556]   - Field: ‘label’
[10:25:46.556]   - Field: ‘local’
[10:25:46.556]   - Field: ‘owner’
[10:25:46.556]   - Field: ‘envir’
[10:25:46.556]   - Field: ‘workers’
[10:25:46.557]   - Field: ‘packages’
[10:25:46.557]   - Field: ‘gc’
[10:25:46.557]   - Field: ‘job’
[10:25:46.557]   - Field: ‘conditions’
[10:25:46.557]   - Field: ‘expr’
[10:25:46.557]   - Field: ‘uuid’
[10:25:46.557]   - Field: ‘seed’
[10:25:46.557]   - Field: ‘version’
[10:25:46.557]   - Field: ‘result’
[10:25:46.557]   - Field: ‘asynchronous’
[10:25:46.557]   - Field: ‘calls’
[10:25:46.558]   - Field: ‘globals’
[10:25:46.558]   - Field: ‘stdout’
[10:25:46.558]   - Field: ‘earlySignal’
[10:25:46.558]   - Field: ‘lazy’
[10:25:46.558]   - Field: ‘state’
[10:25:46.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.558] - Launch lazy future ...
[10:25:46.559] Packages needed by the future expression (n = 0): <none>
[10:25:46.559] Packages needed by future strategies (n = 0): <none>
[10:25:46.561] {
[10:25:46.561]     {
[10:25:46.561]         {
[10:25:46.561]             ...future.startTime <- base::Sys.time()
[10:25:46.561]             {
[10:25:46.561]                 {
[10:25:46.561]                   {
[10:25:46.561]                     {
[10:25:46.561]                       base::local({
[10:25:46.561]                         has_future <- base::requireNamespace("future", 
[10:25:46.561]                           quietly = TRUE)
[10:25:46.561]                         if (has_future) {
[10:25:46.561]                           ns <- base::getNamespace("future")
[10:25:46.561]                           version <- ns[[".package"]][["version"]]
[10:25:46.561]                           if (is.null(version)) 
[10:25:46.561]                             version <- utils::packageVersion("future")
[10:25:46.561]                         }
[10:25:46.561]                         else {
[10:25:46.561]                           version <- NULL
[10:25:46.561]                         }
[10:25:46.561]                         if (!has_future || version < "1.8.0") {
[10:25:46.561]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.561]                             "", base::R.version$version.string), 
[10:25:46.561]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.561]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.561]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.561]                               "release", "version")], collapse = " "), 
[10:25:46.561]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.561]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.561]                             info)
[10:25:46.561]                           info <- base::paste(info, collapse = "; ")
[10:25:46.561]                           if (!has_future) {
[10:25:46.561]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.561]                               info)
[10:25:46.561]                           }
[10:25:46.561]                           else {
[10:25:46.561]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.561]                               info, version)
[10:25:46.561]                           }
[10:25:46.561]                           base::stop(msg)
[10:25:46.561]                         }
[10:25:46.561]                       })
[10:25:46.561]                     }
[10:25:46.561]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.561]                     base::options(mc.cores = 1L)
[10:25:46.561]                   }
[10:25:46.561]                   options(future.plan = NULL)
[10:25:46.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.561]                 }
[10:25:46.561]                 ...future.workdir <- getwd()
[10:25:46.561]             }
[10:25:46.561]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.561]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.561]         }
[10:25:46.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.561]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.561]             base::names(...future.oldOptions))
[10:25:46.561]     }
[10:25:46.561]     if (FALSE) {
[10:25:46.561]     }
[10:25:46.561]     else {
[10:25:46.561]         if (TRUE) {
[10:25:46.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.561]                 open = "w")
[10:25:46.561]         }
[10:25:46.561]         else {
[10:25:46.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.561]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.561]         }
[10:25:46.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.561]             base::sink(type = "output", split = FALSE)
[10:25:46.561]             base::close(...future.stdout)
[10:25:46.561]         }, add = TRUE)
[10:25:46.561]     }
[10:25:46.561]     ...future.frame <- base::sys.nframe()
[10:25:46.561]     ...future.conditions <- base::list()
[10:25:46.561]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.561]     if (FALSE) {
[10:25:46.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.561]     }
[10:25:46.561]     ...future.result <- base::tryCatch({
[10:25:46.561]         base::withCallingHandlers({
[10:25:46.561]             ...future.value <- base::withVisible(base::local({
[10:25:46.561]                 withCallingHandlers({
[10:25:46.561]                   2
[10:25:46.561]                 }, immediateCondition = function(cond) {
[10:25:46.561]                   save_rds <- function (object, pathname, ...) 
[10:25:46.561]                   {
[10:25:46.561]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.561]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.561]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.561]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.561]                         fi_tmp[["mtime"]])
[10:25:46.561]                     }
[10:25:46.561]                     tryCatch({
[10:25:46.561]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.561]                     }, error = function(ex) {
[10:25:46.561]                       msg <- conditionMessage(ex)
[10:25:46.561]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.561]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.561]                         fi_tmp[["mtime"]], msg)
[10:25:46.561]                       ex$message <- msg
[10:25:46.561]                       stop(ex)
[10:25:46.561]                     })
[10:25:46.561]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.561]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.561]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.561]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.561]                       fi <- file.info(pathname)
[10:25:46.561]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.561]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.561]                         fi[["size"]], fi[["mtime"]])
[10:25:46.561]                       stop(msg)
[10:25:46.561]                     }
[10:25:46.561]                     invisible(pathname)
[10:25:46.561]                   }
[10:25:46.561]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.561]                     rootPath = tempdir()) 
[10:25:46.561]                   {
[10:25:46.561]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.561]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.561]                       tmpdir = path, fileext = ".rds")
[10:25:46.561]                     save_rds(obj, file)
[10:25:46.561]                   }
[10:25:46.561]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.561]                   {
[10:25:46.561]                     inherits <- base::inherits
[10:25:46.561]                     invokeRestart <- base::invokeRestart
[10:25:46.561]                     is.null <- base::is.null
[10:25:46.561]                     muffled <- FALSE
[10:25:46.561]                     if (inherits(cond, "message")) {
[10:25:46.561]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.561]                       if (muffled) 
[10:25:46.561]                         invokeRestart("muffleMessage")
[10:25:46.561]                     }
[10:25:46.561]                     else if (inherits(cond, "warning")) {
[10:25:46.561]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.561]                       if (muffled) 
[10:25:46.561]                         invokeRestart("muffleWarning")
[10:25:46.561]                     }
[10:25:46.561]                     else if (inherits(cond, "condition")) {
[10:25:46.561]                       if (!is.null(pattern)) {
[10:25:46.561]                         computeRestarts <- base::computeRestarts
[10:25:46.561]                         grepl <- base::grepl
[10:25:46.561]                         restarts <- computeRestarts(cond)
[10:25:46.561]                         for (restart in restarts) {
[10:25:46.561]                           name <- restart$name
[10:25:46.561]                           if (is.null(name)) 
[10:25:46.561]                             next
[10:25:46.561]                           if (!grepl(pattern, name)) 
[10:25:46.561]                             next
[10:25:46.561]                           invokeRestart(restart)
[10:25:46.561]                           muffled <- TRUE
[10:25:46.561]                           break
[10:25:46.561]                         }
[10:25:46.561]                       }
[10:25:46.561]                     }
[10:25:46.561]                     invisible(muffled)
[10:25:46.561]                   }
[10:25:46.561]                   muffleCondition(cond)
[10:25:46.561]                 })
[10:25:46.561]             }))
[10:25:46.561]             future::FutureResult(value = ...future.value$value, 
[10:25:46.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.561]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.561]                     ...future.globalenv.names))
[10:25:46.561]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.561]         }, condition = base::local({
[10:25:46.561]             c <- base::c
[10:25:46.561]             inherits <- base::inherits
[10:25:46.561]             invokeRestart <- base::invokeRestart
[10:25:46.561]             length <- base::length
[10:25:46.561]             list <- base::list
[10:25:46.561]             seq.int <- base::seq.int
[10:25:46.561]             signalCondition <- base::signalCondition
[10:25:46.561]             sys.calls <- base::sys.calls
[10:25:46.561]             `[[` <- base::`[[`
[10:25:46.561]             `+` <- base::`+`
[10:25:46.561]             `<<-` <- base::`<<-`
[10:25:46.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.561]                   3L)]
[10:25:46.561]             }
[10:25:46.561]             function(cond) {
[10:25:46.561]                 is_error <- inherits(cond, "error")
[10:25:46.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.561]                   NULL)
[10:25:46.561]                 if (is_error) {
[10:25:46.561]                   sessionInformation <- function() {
[10:25:46.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.561]                       search = base::search(), system = base::Sys.info())
[10:25:46.561]                   }
[10:25:46.561]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.561]                     cond$call), session = sessionInformation(), 
[10:25:46.561]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.561]                   signalCondition(cond)
[10:25:46.561]                 }
[10:25:46.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.561]                 "immediateCondition"))) {
[10:25:46.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.561]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.561]                   if (TRUE && !signal) {
[10:25:46.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.561]                     {
[10:25:46.561]                       inherits <- base::inherits
[10:25:46.561]                       invokeRestart <- base::invokeRestart
[10:25:46.561]                       is.null <- base::is.null
[10:25:46.561]                       muffled <- FALSE
[10:25:46.561]                       if (inherits(cond, "message")) {
[10:25:46.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.561]                         if (muffled) 
[10:25:46.561]                           invokeRestart("muffleMessage")
[10:25:46.561]                       }
[10:25:46.561]                       else if (inherits(cond, "warning")) {
[10:25:46.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.561]                         if (muffled) 
[10:25:46.561]                           invokeRestart("muffleWarning")
[10:25:46.561]                       }
[10:25:46.561]                       else if (inherits(cond, "condition")) {
[10:25:46.561]                         if (!is.null(pattern)) {
[10:25:46.561]                           computeRestarts <- base::computeRestarts
[10:25:46.561]                           grepl <- base::grepl
[10:25:46.561]                           restarts <- computeRestarts(cond)
[10:25:46.561]                           for (restart in restarts) {
[10:25:46.561]                             name <- restart$name
[10:25:46.561]                             if (is.null(name)) 
[10:25:46.561]                               next
[10:25:46.561]                             if (!grepl(pattern, name)) 
[10:25:46.561]                               next
[10:25:46.561]                             invokeRestart(restart)
[10:25:46.561]                             muffled <- TRUE
[10:25:46.561]                             break
[10:25:46.561]                           }
[10:25:46.561]                         }
[10:25:46.561]                       }
[10:25:46.561]                       invisible(muffled)
[10:25:46.561]                     }
[10:25:46.561]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.561]                   }
[10:25:46.561]                 }
[10:25:46.561]                 else {
[10:25:46.561]                   if (TRUE) {
[10:25:46.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.561]                     {
[10:25:46.561]                       inherits <- base::inherits
[10:25:46.561]                       invokeRestart <- base::invokeRestart
[10:25:46.561]                       is.null <- base::is.null
[10:25:46.561]                       muffled <- FALSE
[10:25:46.561]                       if (inherits(cond, "message")) {
[10:25:46.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.561]                         if (muffled) 
[10:25:46.561]                           invokeRestart("muffleMessage")
[10:25:46.561]                       }
[10:25:46.561]                       else if (inherits(cond, "warning")) {
[10:25:46.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.561]                         if (muffled) 
[10:25:46.561]                           invokeRestart("muffleWarning")
[10:25:46.561]                       }
[10:25:46.561]                       else if (inherits(cond, "condition")) {
[10:25:46.561]                         if (!is.null(pattern)) {
[10:25:46.561]                           computeRestarts <- base::computeRestarts
[10:25:46.561]                           grepl <- base::grepl
[10:25:46.561]                           restarts <- computeRestarts(cond)
[10:25:46.561]                           for (restart in restarts) {
[10:25:46.561]                             name <- restart$name
[10:25:46.561]                             if (is.null(name)) 
[10:25:46.561]                               next
[10:25:46.561]                             if (!grepl(pattern, name)) 
[10:25:46.561]                               next
[10:25:46.561]                             invokeRestart(restart)
[10:25:46.561]                             muffled <- TRUE
[10:25:46.561]                             break
[10:25:46.561]                           }
[10:25:46.561]                         }
[10:25:46.561]                       }
[10:25:46.561]                       invisible(muffled)
[10:25:46.561]                     }
[10:25:46.561]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.561]                   }
[10:25:46.561]                 }
[10:25:46.561]             }
[10:25:46.561]         }))
[10:25:46.561]     }, error = function(ex) {
[10:25:46.561]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.561]                 ...future.rng), started = ...future.startTime, 
[10:25:46.561]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.561]             version = "1.8"), class = "FutureResult")
[10:25:46.561]     }, finally = {
[10:25:46.561]         if (!identical(...future.workdir, getwd())) 
[10:25:46.561]             setwd(...future.workdir)
[10:25:46.561]         {
[10:25:46.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.561]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.561]             }
[10:25:46.561]             base::options(...future.oldOptions)
[10:25:46.561]             if (.Platform$OS.type == "windows") {
[10:25:46.561]                 old_names <- names(...future.oldEnvVars)
[10:25:46.561]                 envs <- base::Sys.getenv()
[10:25:46.561]                 names <- names(envs)
[10:25:46.561]                 common <- intersect(names, old_names)
[10:25:46.561]                 added <- setdiff(names, old_names)
[10:25:46.561]                 removed <- setdiff(old_names, names)
[10:25:46.561]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.561]                   envs[common]]
[10:25:46.561]                 NAMES <- toupper(changed)
[10:25:46.561]                 args <- list()
[10:25:46.561]                 for (kk in seq_along(NAMES)) {
[10:25:46.561]                   name <- changed[[kk]]
[10:25:46.561]                   NAME <- NAMES[[kk]]
[10:25:46.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.561]                     next
[10:25:46.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.561]                 }
[10:25:46.561]                 NAMES <- toupper(added)
[10:25:46.561]                 for (kk in seq_along(NAMES)) {
[10:25:46.561]                   name <- added[[kk]]
[10:25:46.561]                   NAME <- NAMES[[kk]]
[10:25:46.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.561]                     next
[10:25:46.561]                   args[[name]] <- ""
[10:25:46.561]                 }
[10:25:46.561]                 NAMES <- toupper(removed)
[10:25:46.561]                 for (kk in seq_along(NAMES)) {
[10:25:46.561]                   name <- removed[[kk]]
[10:25:46.561]                   NAME <- NAMES[[kk]]
[10:25:46.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.561]                     next
[10:25:46.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.561]                 }
[10:25:46.561]                 if (length(args) > 0) 
[10:25:46.561]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.561]             }
[10:25:46.561]             else {
[10:25:46.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.561]             }
[10:25:46.561]             {
[10:25:46.561]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.561]                   0L) {
[10:25:46.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.561]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.561]                   base::options(opts)
[10:25:46.561]                 }
[10:25:46.561]                 {
[10:25:46.561]                   {
[10:25:46.561]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.561]                     NULL
[10:25:46.561]                   }
[10:25:46.561]                   options(future.plan = NULL)
[10:25:46.561]                   if (is.na(NA_character_)) 
[10:25:46.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.561]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.561]                     envir = parent.frame()) 
[10:25:46.561]                   {
[10:25:46.561]                     default_workers <- missing(workers)
[10:25:46.561]                     if (is.function(workers)) 
[10:25:46.561]                       workers <- workers()
[10:25:46.561]                     workers <- structure(as.integer(workers), 
[10:25:46.561]                       class = class(workers))
[10:25:46.561]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.561]                       1L)
[10:25:46.561]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.561]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.561]                       if (default_workers) 
[10:25:46.561]                         supportsMulticore(warn = TRUE)
[10:25:46.561]                       return(sequential(..., envir = envir))
[10:25:46.561]                     }
[10:25:46.561]                     oopts <- options(mc.cores = workers)
[10:25:46.561]                     on.exit(options(oopts))
[10:25:46.561]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.561]                       envir = envir)
[10:25:46.561]                     if (!future$lazy) 
[10:25:46.561]                       future <- run(future)
[10:25:46.561]                     invisible(future)
[10:25:46.561]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.561]                 }
[10:25:46.561]             }
[10:25:46.561]         }
[10:25:46.561]     })
[10:25:46.561]     if (TRUE) {
[10:25:46.561]         base::sink(type = "output", split = FALSE)
[10:25:46.561]         if (TRUE) {
[10:25:46.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.561]         }
[10:25:46.561]         else {
[10:25:46.561]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.561]         }
[10:25:46.561]         base::close(...future.stdout)
[10:25:46.561]         ...future.stdout <- NULL
[10:25:46.561]     }
[10:25:46.561]     ...future.result$conditions <- ...future.conditions
[10:25:46.561]     ...future.result$finished <- base::Sys.time()
[10:25:46.561]     ...future.result
[10:25:46.561] }
[10:25:46.563] requestCore(): workers = 2
[10:25:46.566] MulticoreFuture started
[10:25:46.567] - Launch lazy future ... done
[10:25:46.567] plan(): Setting new future strategy stack:
[10:25:46.567] run() for ‘MulticoreFuture’ ... done
[10:25:46.568] getGlobalsAndPackages() ...
[10:25:46.568] List of future strategies:
[10:25:46.568] 1. sequential:
[10:25:46.568]    - args: function (..., envir = parent.frame())
[10:25:46.568]    - tweaked: FALSE
[10:25:46.568]    - call: NULL
[10:25:46.569] Searching for globals...
[10:25:46.569] plan(): nbrOfWorkers() = 1
[10:25:46.570] 
[10:25:46.571] Searching for globals ... DONE
[10:25:46.571] - globals: [0] <none>
[10:25:46.571] getGlobalsAndPackages() ... DONE
[10:25:46.572] plan(): Setting new future strategy stack:
[10:25:46.572] run() for ‘Future’ ...
[10:25:46.572] - state: ‘created’
[10:25:46.572] List of future strategies:
[10:25:46.572] 1. multicore:
[10:25:46.572]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.572]    - tweaked: FALSE
[10:25:46.572]    - call: plan(strategy)
[10:25:46.572] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.577] plan(): nbrOfWorkers() = 2
[10:25:46.578] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.578]   - Field: ‘label’
[10:25:46.579]   - Field: ‘local’
[10:25:46.579]   - Field: ‘owner’
[10:25:46.579]   - Field: ‘envir’
[10:25:46.579]   - Field: ‘workers’
[10:25:46.579]   - Field: ‘packages’
[10:25:46.579]   - Field: ‘gc’
[10:25:46.580]   - Field: ‘job’
[10:25:46.580]   - Field: ‘conditions’
[10:25:46.580]   - Field: ‘expr’
[10:25:46.580]   - Field: ‘uuid’
[10:25:46.580]   - Field: ‘seed’
[10:25:46.581]   - Field: ‘version’
[10:25:46.581]   - Field: ‘result’
[10:25:46.581]   - Field: ‘asynchronous’
[10:25:46.581]   - Field: ‘calls’
[10:25:46.581]   - Field: ‘globals’
[10:25:46.581]   - Field: ‘stdout’
[10:25:46.582]   - Field: ‘earlySignal’
[10:25:46.582]   - Field: ‘lazy’
[10:25:46.582]   - Field: ‘state’
[10:25:46.582] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.582] - Launch lazy future ...
[10:25:46.583] Packages needed by the future expression (n = 0): <none>
[10:25:46.583] Packages needed by future strategies (n = 0): <none>
[10:25:46.583] {
[10:25:46.583]     {
[10:25:46.583]         {
[10:25:46.583]             ...future.startTime <- base::Sys.time()
[10:25:46.583]             {
[10:25:46.583]                 {
[10:25:46.583]                   {
[10:25:46.583]                     {
[10:25:46.583]                       base::local({
[10:25:46.583]                         has_future <- base::requireNamespace("future", 
[10:25:46.583]                           quietly = TRUE)
[10:25:46.583]                         if (has_future) {
[10:25:46.583]                           ns <- base::getNamespace("future")
[10:25:46.583]                           version <- ns[[".package"]][["version"]]
[10:25:46.583]                           if (is.null(version)) 
[10:25:46.583]                             version <- utils::packageVersion("future")
[10:25:46.583]                         }
[10:25:46.583]                         else {
[10:25:46.583]                           version <- NULL
[10:25:46.583]                         }
[10:25:46.583]                         if (!has_future || version < "1.8.0") {
[10:25:46.583]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.583]                             "", base::R.version$version.string), 
[10:25:46.583]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.583]                               "release", "version")], collapse = " "), 
[10:25:46.583]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.583]                             info)
[10:25:46.583]                           info <- base::paste(info, collapse = "; ")
[10:25:46.583]                           if (!has_future) {
[10:25:46.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.583]                               info)
[10:25:46.583]                           }
[10:25:46.583]                           else {
[10:25:46.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.583]                               info, version)
[10:25:46.583]                           }
[10:25:46.583]                           base::stop(msg)
[10:25:46.583]                         }
[10:25:46.583]                       })
[10:25:46.583]                     }
[10:25:46.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.583]                     base::options(mc.cores = 1L)
[10:25:46.583]                   }
[10:25:46.583]                   options(future.plan = NULL)
[10:25:46.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.583]                 }
[10:25:46.583]                 ...future.workdir <- getwd()
[10:25:46.583]             }
[10:25:46.583]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.583]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.583]         }
[10:25:46.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.583]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.583]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.583]             base::names(...future.oldOptions))
[10:25:46.583]     }
[10:25:46.583]     if (FALSE) {
[10:25:46.583]     }
[10:25:46.583]     else {
[10:25:46.583]         if (TRUE) {
[10:25:46.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.583]                 open = "w")
[10:25:46.583]         }
[10:25:46.583]         else {
[10:25:46.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.583]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.583]         }
[10:25:46.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.583]             base::sink(type = "output", split = FALSE)
[10:25:46.583]             base::close(...future.stdout)
[10:25:46.583]         }, add = TRUE)
[10:25:46.583]     }
[10:25:46.583]     ...future.frame <- base::sys.nframe()
[10:25:46.583]     ...future.conditions <- base::list()
[10:25:46.583]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.583]     if (FALSE) {
[10:25:46.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.583]     }
[10:25:46.583]     ...future.result <- base::tryCatch({
[10:25:46.583]         base::withCallingHandlers({
[10:25:46.583]             ...future.value <- base::withVisible(base::local({
[10:25:46.583]                 withCallingHandlers({
[10:25:46.583]                   NULL
[10:25:46.583]                 }, immediateCondition = function(cond) {
[10:25:46.583]                   save_rds <- function (object, pathname, ...) 
[10:25:46.583]                   {
[10:25:46.583]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.583]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.583]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.583]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.583]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.583]                         fi_tmp[["mtime"]])
[10:25:46.583]                     }
[10:25:46.583]                     tryCatch({
[10:25:46.583]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.583]                     }, error = function(ex) {
[10:25:46.583]                       msg <- conditionMessage(ex)
[10:25:46.583]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.583]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.583]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.583]                         fi_tmp[["mtime"]], msg)
[10:25:46.583]                       ex$message <- msg
[10:25:46.583]                       stop(ex)
[10:25:46.583]                     })
[10:25:46.583]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.583]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.583]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.583]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.583]                       fi <- file.info(pathname)
[10:25:46.583]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.583]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.583]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.583]                         fi[["size"]], fi[["mtime"]])
[10:25:46.583]                       stop(msg)
[10:25:46.583]                     }
[10:25:46.583]                     invisible(pathname)
[10:25:46.583]                   }
[10:25:46.583]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.583]                     rootPath = tempdir()) 
[10:25:46.583]                   {
[10:25:46.583]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.583]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.583]                       tmpdir = path, fileext = ".rds")
[10:25:46.583]                     save_rds(obj, file)
[10:25:46.583]                   }
[10:25:46.583]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.583]                   {
[10:25:46.583]                     inherits <- base::inherits
[10:25:46.583]                     invokeRestart <- base::invokeRestart
[10:25:46.583]                     is.null <- base::is.null
[10:25:46.583]                     muffled <- FALSE
[10:25:46.583]                     if (inherits(cond, "message")) {
[10:25:46.583]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.583]                       if (muffled) 
[10:25:46.583]                         invokeRestart("muffleMessage")
[10:25:46.583]                     }
[10:25:46.583]                     else if (inherits(cond, "warning")) {
[10:25:46.583]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.583]                       if (muffled) 
[10:25:46.583]                         invokeRestart("muffleWarning")
[10:25:46.583]                     }
[10:25:46.583]                     else if (inherits(cond, "condition")) {
[10:25:46.583]                       if (!is.null(pattern)) {
[10:25:46.583]                         computeRestarts <- base::computeRestarts
[10:25:46.583]                         grepl <- base::grepl
[10:25:46.583]                         restarts <- computeRestarts(cond)
[10:25:46.583]                         for (restart in restarts) {
[10:25:46.583]                           name <- restart$name
[10:25:46.583]                           if (is.null(name)) 
[10:25:46.583]                             next
[10:25:46.583]                           if (!grepl(pattern, name)) 
[10:25:46.583]                             next
[10:25:46.583]                           invokeRestart(restart)
[10:25:46.583]                           muffled <- TRUE
[10:25:46.583]                           break
[10:25:46.583]                         }
[10:25:46.583]                       }
[10:25:46.583]                     }
[10:25:46.583]                     invisible(muffled)
[10:25:46.583]                   }
[10:25:46.583]                   muffleCondition(cond)
[10:25:46.583]                 })
[10:25:46.583]             }))
[10:25:46.583]             future::FutureResult(value = ...future.value$value, 
[10:25:46.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.583]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.583]                     ...future.globalenv.names))
[10:25:46.583]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.583]         }, condition = base::local({
[10:25:46.583]             c <- base::c
[10:25:46.583]             inherits <- base::inherits
[10:25:46.583]             invokeRestart <- base::invokeRestart
[10:25:46.583]             length <- base::length
[10:25:46.583]             list <- base::list
[10:25:46.583]             seq.int <- base::seq.int
[10:25:46.583]             signalCondition <- base::signalCondition
[10:25:46.583]             sys.calls <- base::sys.calls
[10:25:46.583]             `[[` <- base::`[[`
[10:25:46.583]             `+` <- base::`+`
[10:25:46.583]             `<<-` <- base::`<<-`
[10:25:46.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.583]                   3L)]
[10:25:46.583]             }
[10:25:46.583]             function(cond) {
[10:25:46.583]                 is_error <- inherits(cond, "error")
[10:25:46.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.583]                   NULL)
[10:25:46.583]                 if (is_error) {
[10:25:46.583]                   sessionInformation <- function() {
[10:25:46.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.583]                       search = base::search(), system = base::Sys.info())
[10:25:46.583]                   }
[10:25:46.583]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.583]                     cond$call), session = sessionInformation(), 
[10:25:46.583]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.583]                   signalCondition(cond)
[10:25:46.583]                 }
[10:25:46.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.583]                 "immediateCondition"))) {
[10:25:46.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.583]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.583]                   if (TRUE && !signal) {
[10:25:46.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.583]                     {
[10:25:46.583]                       inherits <- base::inherits
[10:25:46.583]                       invokeRestart <- base::invokeRestart
[10:25:46.583]                       is.null <- base::is.null
[10:25:46.583]                       muffled <- FALSE
[10:25:46.583]                       if (inherits(cond, "message")) {
[10:25:46.583]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.583]                         if (muffled) 
[10:25:46.583]                           invokeRestart("muffleMessage")
[10:25:46.583]                       }
[10:25:46.583]                       else if (inherits(cond, "warning")) {
[10:25:46.583]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.583]                         if (muffled) 
[10:25:46.583]                           invokeRestart("muffleWarning")
[10:25:46.583]                       }
[10:25:46.583]                       else if (inherits(cond, "condition")) {
[10:25:46.583]                         if (!is.null(pattern)) {
[10:25:46.583]                           computeRestarts <- base::computeRestarts
[10:25:46.583]                           grepl <- base::grepl
[10:25:46.583]                           restarts <- computeRestarts(cond)
[10:25:46.583]                           for (restart in restarts) {
[10:25:46.583]                             name <- restart$name
[10:25:46.583]                             if (is.null(name)) 
[10:25:46.583]                               next
[10:25:46.583]                             if (!grepl(pattern, name)) 
[10:25:46.583]                               next
[10:25:46.583]                             invokeRestart(restart)
[10:25:46.583]                             muffled <- TRUE
[10:25:46.583]                             break
[10:25:46.583]                           }
[10:25:46.583]                         }
[10:25:46.583]                       }
[10:25:46.583]                       invisible(muffled)
[10:25:46.583]                     }
[10:25:46.583]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.583]                   }
[10:25:46.583]                 }
[10:25:46.583]                 else {
[10:25:46.583]                   if (TRUE) {
[10:25:46.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.583]                     {
[10:25:46.583]                       inherits <- base::inherits
[10:25:46.583]                       invokeRestart <- base::invokeRestart
[10:25:46.583]                       is.null <- base::is.null
[10:25:46.583]                       muffled <- FALSE
[10:25:46.583]                       if (inherits(cond, "message")) {
[10:25:46.583]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.583]                         if (muffled) 
[10:25:46.583]                           invokeRestart("muffleMessage")
[10:25:46.583]                       }
[10:25:46.583]                       else if (inherits(cond, "warning")) {
[10:25:46.583]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.583]                         if (muffled) 
[10:25:46.583]                           invokeRestart("muffleWarning")
[10:25:46.583]                       }
[10:25:46.583]                       else if (inherits(cond, "condition")) {
[10:25:46.583]                         if (!is.null(pattern)) {
[10:25:46.583]                           computeRestarts <- base::computeRestarts
[10:25:46.583]                           grepl <- base::grepl
[10:25:46.583]                           restarts <- computeRestarts(cond)
[10:25:46.583]                           for (restart in restarts) {
[10:25:46.583]                             name <- restart$name
[10:25:46.583]                             if (is.null(name)) 
[10:25:46.583]                               next
[10:25:46.583]                             if (!grepl(pattern, name)) 
[10:25:46.583]                               next
[10:25:46.583]                             invokeRestart(restart)
[10:25:46.583]                             muffled <- TRUE
[10:25:46.583]                             break
[10:25:46.583]                           }
[10:25:46.583]                         }
[10:25:46.583]                       }
[10:25:46.583]                       invisible(muffled)
[10:25:46.583]                     }
[10:25:46.583]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.583]                   }
[10:25:46.583]                 }
[10:25:46.583]             }
[10:25:46.583]         }))
[10:25:46.583]     }, error = function(ex) {
[10:25:46.583]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.583]                 ...future.rng), started = ...future.startTime, 
[10:25:46.583]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.583]             version = "1.8"), class = "FutureResult")
[10:25:46.583]     }, finally = {
[10:25:46.583]         if (!identical(...future.workdir, getwd())) 
[10:25:46.583]             setwd(...future.workdir)
[10:25:46.583]         {
[10:25:46.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.583]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.583]             }
[10:25:46.583]             base::options(...future.oldOptions)
[10:25:46.583]             if (.Platform$OS.type == "windows") {
[10:25:46.583]                 old_names <- names(...future.oldEnvVars)
[10:25:46.583]                 envs <- base::Sys.getenv()
[10:25:46.583]                 names <- names(envs)
[10:25:46.583]                 common <- intersect(names, old_names)
[10:25:46.583]                 added <- setdiff(names, old_names)
[10:25:46.583]                 removed <- setdiff(old_names, names)
[10:25:46.583]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.583]                   envs[common]]
[10:25:46.583]                 NAMES <- toupper(changed)
[10:25:46.583]                 args <- list()
[10:25:46.583]                 for (kk in seq_along(NAMES)) {
[10:25:46.583]                   name <- changed[[kk]]
[10:25:46.583]                   NAME <- NAMES[[kk]]
[10:25:46.583]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.583]                     next
[10:25:46.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.583]                 }
[10:25:46.583]                 NAMES <- toupper(added)
[10:25:46.583]                 for (kk in seq_along(NAMES)) {
[10:25:46.583]                   name <- added[[kk]]
[10:25:46.583]                   NAME <- NAMES[[kk]]
[10:25:46.583]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.583]                     next
[10:25:46.583]                   args[[name]] <- ""
[10:25:46.583]                 }
[10:25:46.583]                 NAMES <- toupper(removed)
[10:25:46.583]                 for (kk in seq_along(NAMES)) {
[10:25:46.583]                   name <- removed[[kk]]
[10:25:46.583]                   NAME <- NAMES[[kk]]
[10:25:46.583]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.583]                     next
[10:25:46.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.583]                 }
[10:25:46.583]                 if (length(args) > 0) 
[10:25:46.583]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.583]             }
[10:25:46.583]             else {
[10:25:46.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.583]             }
[10:25:46.583]             {
[10:25:46.583]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.583]                   0L) {
[10:25:46.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.583]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.583]                   base::options(opts)
[10:25:46.583]                 }
[10:25:46.583]                 {
[10:25:46.583]                   {
[10:25:46.583]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.583]                     NULL
[10:25:46.583]                   }
[10:25:46.583]                   options(future.plan = NULL)
[10:25:46.583]                   if (is.na(NA_character_)) 
[10:25:46.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.583]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.583]                     envir = parent.frame()) 
[10:25:46.583]                   {
[10:25:46.583]                     default_workers <- missing(workers)
[10:25:46.583]                     if (is.function(workers)) 
[10:25:46.583]                       workers <- workers()
[10:25:46.583]                     workers <- structure(as.integer(workers), 
[10:25:46.583]                       class = class(workers))
[10:25:46.583]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.583]                       1L)
[10:25:46.583]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.583]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.583]                       if (default_workers) 
[10:25:46.583]                         supportsMulticore(warn = TRUE)
[10:25:46.583]                       return(sequential(..., envir = envir))
[10:25:46.583]                     }
[10:25:46.583]                     oopts <- options(mc.cores = workers)
[10:25:46.583]                     on.exit(options(oopts))
[10:25:46.583]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.583]                       envir = envir)
[10:25:46.583]                     if (!future$lazy) 
[10:25:46.583]                       future <- run(future)
[10:25:46.583]                     invisible(future)
[10:25:46.583]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.583]                 }
[10:25:46.583]             }
[10:25:46.583]         }
[10:25:46.583]     })
[10:25:46.583]     if (TRUE) {
[10:25:46.583]         base::sink(type = "output", split = FALSE)
[10:25:46.583]         if (TRUE) {
[10:25:46.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.583]         }
[10:25:46.583]         else {
[10:25:46.583]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.583]         }
[10:25:46.583]         base::close(...future.stdout)
[10:25:46.583]         ...future.stdout <- NULL
[10:25:46.583]     }
[10:25:46.583]     ...future.result$conditions <- ...future.conditions
[10:25:46.583]     ...future.result$finished <- base::Sys.time()
[10:25:46.583]     ...future.result
[10:25:46.583] }
[10:25:46.587] requestCore(): workers = 2
[10:25:46.593] MulticoreFuture started
[10:25:46.593] - Launch lazy future ... done
[10:25:46.594] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[10:25:46.594] plan(): Setting new future strategy stack:
[10:25:46.594] List of future strategies:
[10:25:46.594] 1. sequential:
[10:25:46.594]    - args: function (..., envir = parent.frame())
[10:25:46.594]    - tweaked: FALSE
[10:25:46.594]    - call: NULL
 num 1
 $ b:[10:25:46.595] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f5429db8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f472b8b0> 
 $  : NULL
 $  : NULL
 $  :[10:25:46.597] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[10:25:46.598] List of future strategies:
[10:25:46.598] 1. multicore:
[10:25:46.598]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.598]    - tweaked: FALSE
[10:25:46.598]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f5429db8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f472b8b0> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:25:46.602] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:46.604] resolve() on list ...
[10:25:46.604]  recursive: 0
[10:25:46.604]  length: 6
[10:25:46.604]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:46.604] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.605] - nx: 6
[10:25:46.605] - relay: TRUE
[10:25:46.605] - stdout: TRUE
[10:25:46.605] - signal: TRUE
[10:25:46.605] - resignal: FALSE
[10:25:46.605] - force: TRUE
[10:25:46.605] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.605] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.606]  - until=2
[10:25:46.606]  - relaying element #2
[10:25:46.606] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.606] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.606] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.606]  length: 5 (resolved future 1)
[10:25:46.607] Future #2
[10:25:46.607] result() for MulticoreFuture ...
[10:25:46.609] result() for MulticoreFuture ...
[10:25:46.609] result() for MulticoreFuture ... done
[10:25:46.609] result() for MulticoreFuture ... done
[10:25:46.609] result() for MulticoreFuture ...
[10:25:46.609] result() for MulticoreFuture ... done
[10:25:46.610] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:46.610] - nx: 6
[10:25:46.610] - relay: TRUE
[10:25:46.610] - stdout: TRUE
[10:25:46.610] - signal: TRUE
[10:25:46.610] - resignal: FALSE
[10:25:46.610] - force: TRUE
[10:25:46.610] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.611] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.611]  - until=2
[10:25:46.611]  - relaying element #2
[10:25:46.611] result() for MulticoreFuture ...
[10:25:46.611] result() for MulticoreFuture ... done
[10:25:46.611] result() for MulticoreFuture ...
[10:25:46.611] result() for MulticoreFuture ... done
[10:25:46.612] result() for MulticoreFuture ...
[10:25:46.612] result() for MulticoreFuture ... done
[10:25:46.612] result() for MulticoreFuture ...
[10:25:46.612] result() for MulticoreFuture ... done
[10:25:46.612] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.612] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.613] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:46.613]  length: 4 (resolved future 2)
[10:25:46.613] Future #3
[10:25:46.613] result() for MulticoreFuture ...
[10:25:46.614] result() for MulticoreFuture ...
[10:25:46.614] result() for MulticoreFuture ... done
[10:25:46.614] result() for MulticoreFuture ... done
[10:25:46.614] result() for MulticoreFuture ...
[10:25:46.614] result() for MulticoreFuture ... done
[10:25:46.615] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:46.615] - nx: 6
[10:25:46.615] - relay: TRUE
[10:25:46.615] - stdout: TRUE
[10:25:46.615] - signal: TRUE
[10:25:46.615] - resignal: FALSE
[10:25:46.615] - force: TRUE
[10:25:46.615] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.615] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.616]  - until=3
[10:25:46.616]  - relaying element #3
[10:25:46.616] result() for MulticoreFuture ...
[10:25:46.616] result() for MulticoreFuture ... done
[10:25:46.616] result() for MulticoreFuture ...
[10:25:46.616] result() for MulticoreFuture ... done
[10:25:46.616] result() for MulticoreFuture ...
[10:25:46.616] result() for MulticoreFuture ... done
[10:25:46.617] result() for MulticoreFuture ...
[10:25:46.617] result() for MulticoreFuture ... done
[10:25:46.617] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.617] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.617] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:46.620]  length: 3 (resolved future 3)
[10:25:46.620] signalConditionsASAP(NULL, pos=4) ...
[10:25:46.620] - nx: 6
[10:25:46.620] - relay: TRUE
[10:25:46.620] - stdout: TRUE
[10:25:46.620] - signal: TRUE
[10:25:46.620] - resignal: FALSE
[10:25:46.621] - force: TRUE
[10:25:46.621] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.621] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.621]  - until=5
[10:25:46.621]  - relaying element #5
[10:25:46.621] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.622] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.622] signalConditionsASAP(NULL, pos=4) ... done
[10:25:46.622]  length: 2 (resolved future 4)
[10:25:46.622] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.622] - nx: 6
[10:25:46.622] - relay: TRUE
[10:25:46.622] - stdout: TRUE
[10:25:46.622] - signal: TRUE
[10:25:46.622] - resignal: FALSE
[10:25:46.623] - force: TRUE
[10:25:46.623] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.623] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.623]  - until=6
[10:25:46.623]  - relaying element #6
[10:25:46.623] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.623] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.623] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.623]  length: 1 (resolved future 5)
[10:25:46.623] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.624] - nx: 6
[10:25:46.624] - relay: TRUE
[10:25:46.624] - stdout: TRUE
[10:25:46.624] - signal: TRUE
[10:25:46.624] - resignal: FALSE
[10:25:46.624] - force: TRUE
[10:25:46.624] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.624] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.625]  - until=6
[10:25:46.625] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.625] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.625] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.625]  length: 0 (resolved future 6)
[10:25:46.625] Relaying remaining futures
[10:25:46.625] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.625] - nx: 6
[10:25:46.625] - relay: TRUE
[10:25:46.626] - stdout: TRUE
[10:25:46.626] - signal: TRUE
[10:25:46.626] - resignal: FALSE
[10:25:46.626] - force: TRUE
[10:25:46.626] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.626] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:46.626] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.626] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.627] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.627] resolve() on list ... DONE
[10:25:46.627] result() for MulticoreFuture ...
[10:25:46.627] result() for MulticoreFuture ... done
[10:25:46.627] result() for MulticoreFuture ...
[10:25:46.627] result() for MulticoreFuture ... done
[10:25:46.627] result() for MulticoreFuture ...
[10:25:46.627] result() for MulticoreFuture ... done
[10:25:46.627] result() for MulticoreFuture ...
[10:25:46.627] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[10:25:46.630] getGlobalsAndPackages() ...
[10:25:46.630] Searching for globals...
[10:25:46.630] 
[10:25:46.630] Searching for globals ... DONE
[10:25:46.631] - globals: [0] <none>
[10:25:46.631] getGlobalsAndPackages() ... DONE
[10:25:46.631] run() for ‘Future’ ...
[10:25:46.631] - state: ‘created’
[10:25:46.631] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.635] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.635]   - Field: ‘label’
[10:25:46.635]   - Field: ‘local’
[10:25:46.635]   - Field: ‘owner’
[10:25:46.635]   - Field: ‘envir’
[10:25:46.636]   - Field: ‘workers’
[10:25:46.636]   - Field: ‘packages’
[10:25:46.636]   - Field: ‘gc’
[10:25:46.636]   - Field: ‘job’
[10:25:46.636]   - Field: ‘conditions’
[10:25:46.636]   - Field: ‘expr’
[10:25:46.636]   - Field: ‘uuid’
[10:25:46.636]   - Field: ‘seed’
[10:25:46.636]   - Field: ‘version’
[10:25:46.636]   - Field: ‘result’
[10:25:46.636]   - Field: ‘asynchronous’
[10:25:46.637]   - Field: ‘calls’
[10:25:46.637]   - Field: ‘globals’
[10:25:46.637]   - Field: ‘stdout’
[10:25:46.637]   - Field: ‘earlySignal’
[10:25:46.637]   - Field: ‘lazy’
[10:25:46.637]   - Field: ‘state’
[10:25:46.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.637] - Launch lazy future ...
[10:25:46.637] Packages needed by the future expression (n = 0): <none>
[10:25:46.638] Packages needed by future strategies (n = 0): <none>
[10:25:46.638] {
[10:25:46.638]     {
[10:25:46.638]         {
[10:25:46.638]             ...future.startTime <- base::Sys.time()
[10:25:46.638]             {
[10:25:46.638]                 {
[10:25:46.638]                   {
[10:25:46.638]                     {
[10:25:46.638]                       base::local({
[10:25:46.638]                         has_future <- base::requireNamespace("future", 
[10:25:46.638]                           quietly = TRUE)
[10:25:46.638]                         if (has_future) {
[10:25:46.638]                           ns <- base::getNamespace("future")
[10:25:46.638]                           version <- ns[[".package"]][["version"]]
[10:25:46.638]                           if (is.null(version)) 
[10:25:46.638]                             version <- utils::packageVersion("future")
[10:25:46.638]                         }
[10:25:46.638]                         else {
[10:25:46.638]                           version <- NULL
[10:25:46.638]                         }
[10:25:46.638]                         if (!has_future || version < "1.8.0") {
[10:25:46.638]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.638]                             "", base::R.version$version.string), 
[10:25:46.638]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.638]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.638]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.638]                               "release", "version")], collapse = " "), 
[10:25:46.638]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.638]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.638]                             info)
[10:25:46.638]                           info <- base::paste(info, collapse = "; ")
[10:25:46.638]                           if (!has_future) {
[10:25:46.638]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.638]                               info)
[10:25:46.638]                           }
[10:25:46.638]                           else {
[10:25:46.638]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.638]                               info, version)
[10:25:46.638]                           }
[10:25:46.638]                           base::stop(msg)
[10:25:46.638]                         }
[10:25:46.638]                       })
[10:25:46.638]                     }
[10:25:46.638]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.638]                     base::options(mc.cores = 1L)
[10:25:46.638]                   }
[10:25:46.638]                   options(future.plan = NULL)
[10:25:46.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.638]                 }
[10:25:46.638]                 ...future.workdir <- getwd()
[10:25:46.638]             }
[10:25:46.638]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.638]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.638]         }
[10:25:46.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.638]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.638]             base::names(...future.oldOptions))
[10:25:46.638]     }
[10:25:46.638]     if (FALSE) {
[10:25:46.638]     }
[10:25:46.638]     else {
[10:25:46.638]         if (TRUE) {
[10:25:46.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.638]                 open = "w")
[10:25:46.638]         }
[10:25:46.638]         else {
[10:25:46.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.638]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.638]         }
[10:25:46.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.638]             base::sink(type = "output", split = FALSE)
[10:25:46.638]             base::close(...future.stdout)
[10:25:46.638]         }, add = TRUE)
[10:25:46.638]     }
[10:25:46.638]     ...future.frame <- base::sys.nframe()
[10:25:46.638]     ...future.conditions <- base::list()
[10:25:46.638]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.638]     if (FALSE) {
[10:25:46.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.638]     }
[10:25:46.638]     ...future.result <- base::tryCatch({
[10:25:46.638]         base::withCallingHandlers({
[10:25:46.638]             ...future.value <- base::withVisible(base::local({
[10:25:46.638]                 withCallingHandlers({
[10:25:46.638]                   2
[10:25:46.638]                 }, immediateCondition = function(cond) {
[10:25:46.638]                   save_rds <- function (object, pathname, ...) 
[10:25:46.638]                   {
[10:25:46.638]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.638]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.638]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.638]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.638]                         fi_tmp[["mtime"]])
[10:25:46.638]                     }
[10:25:46.638]                     tryCatch({
[10:25:46.638]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.638]                     }, error = function(ex) {
[10:25:46.638]                       msg <- conditionMessage(ex)
[10:25:46.638]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.638]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.638]                         fi_tmp[["mtime"]], msg)
[10:25:46.638]                       ex$message <- msg
[10:25:46.638]                       stop(ex)
[10:25:46.638]                     })
[10:25:46.638]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.638]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.638]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.638]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.638]                       fi <- file.info(pathname)
[10:25:46.638]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.638]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.638]                         fi[["size"]], fi[["mtime"]])
[10:25:46.638]                       stop(msg)
[10:25:46.638]                     }
[10:25:46.638]                     invisible(pathname)
[10:25:46.638]                   }
[10:25:46.638]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.638]                     rootPath = tempdir()) 
[10:25:46.638]                   {
[10:25:46.638]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.638]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.638]                       tmpdir = path, fileext = ".rds")
[10:25:46.638]                     save_rds(obj, file)
[10:25:46.638]                   }
[10:25:46.638]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.638]                   {
[10:25:46.638]                     inherits <- base::inherits
[10:25:46.638]                     invokeRestart <- base::invokeRestart
[10:25:46.638]                     is.null <- base::is.null
[10:25:46.638]                     muffled <- FALSE
[10:25:46.638]                     if (inherits(cond, "message")) {
[10:25:46.638]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.638]                       if (muffled) 
[10:25:46.638]                         invokeRestart("muffleMessage")
[10:25:46.638]                     }
[10:25:46.638]                     else if (inherits(cond, "warning")) {
[10:25:46.638]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.638]                       if (muffled) 
[10:25:46.638]                         invokeRestart("muffleWarning")
[10:25:46.638]                     }
[10:25:46.638]                     else if (inherits(cond, "condition")) {
[10:25:46.638]                       if (!is.null(pattern)) {
[10:25:46.638]                         computeRestarts <- base::computeRestarts
[10:25:46.638]                         grepl <- base::grepl
[10:25:46.638]                         restarts <- computeRestarts(cond)
[10:25:46.638]                         for (restart in restarts) {
[10:25:46.638]                           name <- restart$name
[10:25:46.638]                           if (is.null(name)) 
[10:25:46.638]                             next
[10:25:46.638]                           if (!grepl(pattern, name)) 
[10:25:46.638]                             next
[10:25:46.638]                           invokeRestart(restart)
[10:25:46.638]                           muffled <- TRUE
[10:25:46.638]                           break
[10:25:46.638]                         }
[10:25:46.638]                       }
[10:25:46.638]                     }
[10:25:46.638]                     invisible(muffled)
[10:25:46.638]                   }
[10:25:46.638]                   muffleCondition(cond)
[10:25:46.638]                 })
[10:25:46.638]             }))
[10:25:46.638]             future::FutureResult(value = ...future.value$value, 
[10:25:46.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.638]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.638]                     ...future.globalenv.names))
[10:25:46.638]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.638]         }, condition = base::local({
[10:25:46.638]             c <- base::c
[10:25:46.638]             inherits <- base::inherits
[10:25:46.638]             invokeRestart <- base::invokeRestart
[10:25:46.638]             length <- base::length
[10:25:46.638]             list <- base::list
[10:25:46.638]             seq.int <- base::seq.int
[10:25:46.638]             signalCondition <- base::signalCondition
[10:25:46.638]             sys.calls <- base::sys.calls
[10:25:46.638]             `[[` <- base::`[[`
[10:25:46.638]             `+` <- base::`+`
[10:25:46.638]             `<<-` <- base::`<<-`
[10:25:46.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.638]                   3L)]
[10:25:46.638]             }
[10:25:46.638]             function(cond) {
[10:25:46.638]                 is_error <- inherits(cond, "error")
[10:25:46.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.638]                   NULL)
[10:25:46.638]                 if (is_error) {
[10:25:46.638]                   sessionInformation <- function() {
[10:25:46.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.638]                       search = base::search(), system = base::Sys.info())
[10:25:46.638]                   }
[10:25:46.638]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.638]                     cond$call), session = sessionInformation(), 
[10:25:46.638]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.638]                   signalCondition(cond)
[10:25:46.638]                 }
[10:25:46.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.638]                 "immediateCondition"))) {
[10:25:46.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.638]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.638]                   if (TRUE && !signal) {
[10:25:46.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.638]                     {
[10:25:46.638]                       inherits <- base::inherits
[10:25:46.638]                       invokeRestart <- base::invokeRestart
[10:25:46.638]                       is.null <- base::is.null
[10:25:46.638]                       muffled <- FALSE
[10:25:46.638]                       if (inherits(cond, "message")) {
[10:25:46.638]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.638]                         if (muffled) 
[10:25:46.638]                           invokeRestart("muffleMessage")
[10:25:46.638]                       }
[10:25:46.638]                       else if (inherits(cond, "warning")) {
[10:25:46.638]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.638]                         if (muffled) 
[10:25:46.638]                           invokeRestart("muffleWarning")
[10:25:46.638]                       }
[10:25:46.638]                       else if (inherits(cond, "condition")) {
[10:25:46.638]                         if (!is.null(pattern)) {
[10:25:46.638]                           computeRestarts <- base::computeRestarts
[10:25:46.638]                           grepl <- base::grepl
[10:25:46.638]                           restarts <- computeRestarts(cond)
[10:25:46.638]                           for (restart in restarts) {
[10:25:46.638]                             name <- restart$name
[10:25:46.638]                             if (is.null(name)) 
[10:25:46.638]                               next
[10:25:46.638]                             if (!grepl(pattern, name)) 
[10:25:46.638]                               next
[10:25:46.638]                             invokeRestart(restart)
[10:25:46.638]                             muffled <- TRUE
[10:25:46.638]                             break
[10:25:46.638]                           }
[10:25:46.638]                         }
[10:25:46.638]                       }
[10:25:46.638]                       invisible(muffled)
[10:25:46.638]                     }
[10:25:46.638]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.638]                   }
[10:25:46.638]                 }
[10:25:46.638]                 else {
[10:25:46.638]                   if (TRUE) {
[10:25:46.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.638]                     {
[10:25:46.638]                       inherits <- base::inherits
[10:25:46.638]                       invokeRestart <- base::invokeRestart
[10:25:46.638]                       is.null <- base::is.null
[10:25:46.638]                       muffled <- FALSE
[10:25:46.638]                       if (inherits(cond, "message")) {
[10:25:46.638]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.638]                         if (muffled) 
[10:25:46.638]                           invokeRestart("muffleMessage")
[10:25:46.638]                       }
[10:25:46.638]                       else if (inherits(cond, "warning")) {
[10:25:46.638]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.638]                         if (muffled) 
[10:25:46.638]                           invokeRestart("muffleWarning")
[10:25:46.638]                       }
[10:25:46.638]                       else if (inherits(cond, "condition")) {
[10:25:46.638]                         if (!is.null(pattern)) {
[10:25:46.638]                           computeRestarts <- base::computeRestarts
[10:25:46.638]                           grepl <- base::grepl
[10:25:46.638]                           restarts <- computeRestarts(cond)
[10:25:46.638]                           for (restart in restarts) {
[10:25:46.638]                             name <- restart$name
[10:25:46.638]                             if (is.null(name)) 
[10:25:46.638]                               next
[10:25:46.638]                             if (!grepl(pattern, name)) 
[10:25:46.638]                               next
[10:25:46.638]                             invokeRestart(restart)
[10:25:46.638]                             muffled <- TRUE
[10:25:46.638]                             break
[10:25:46.638]                           }
[10:25:46.638]                         }
[10:25:46.638]                       }
[10:25:46.638]                       invisible(muffled)
[10:25:46.638]                     }
[10:25:46.638]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.638]                   }
[10:25:46.638]                 }
[10:25:46.638]             }
[10:25:46.638]         }))
[10:25:46.638]     }, error = function(ex) {
[10:25:46.638]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.638]                 ...future.rng), started = ...future.startTime, 
[10:25:46.638]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.638]             version = "1.8"), class = "FutureResult")
[10:25:46.638]     }, finally = {
[10:25:46.638]         if (!identical(...future.workdir, getwd())) 
[10:25:46.638]             setwd(...future.workdir)
[10:25:46.638]         {
[10:25:46.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.638]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.638]             }
[10:25:46.638]             base::options(...future.oldOptions)
[10:25:46.638]             if (.Platform$OS.type == "windows") {
[10:25:46.638]                 old_names <- names(...future.oldEnvVars)
[10:25:46.638]                 envs <- base::Sys.getenv()
[10:25:46.638]                 names <- names(envs)
[10:25:46.638]                 common <- intersect(names, old_names)
[10:25:46.638]                 added <- setdiff(names, old_names)
[10:25:46.638]                 removed <- setdiff(old_names, names)
[10:25:46.638]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.638]                   envs[common]]
[10:25:46.638]                 NAMES <- toupper(changed)
[10:25:46.638]                 args <- list()
[10:25:46.638]                 for (kk in seq_along(NAMES)) {
[10:25:46.638]                   name <- changed[[kk]]
[10:25:46.638]                   NAME <- NAMES[[kk]]
[10:25:46.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.638]                     next
[10:25:46.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.638]                 }
[10:25:46.638]                 NAMES <- toupper(added)
[10:25:46.638]                 for (kk in seq_along(NAMES)) {
[10:25:46.638]                   name <- added[[kk]]
[10:25:46.638]                   NAME <- NAMES[[kk]]
[10:25:46.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.638]                     next
[10:25:46.638]                   args[[name]] <- ""
[10:25:46.638]                 }
[10:25:46.638]                 NAMES <- toupper(removed)
[10:25:46.638]                 for (kk in seq_along(NAMES)) {
[10:25:46.638]                   name <- removed[[kk]]
[10:25:46.638]                   NAME <- NAMES[[kk]]
[10:25:46.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.638]                     next
[10:25:46.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.638]                 }
[10:25:46.638]                 if (length(args) > 0) 
[10:25:46.638]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.638]             }
[10:25:46.638]             else {
[10:25:46.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.638]             }
[10:25:46.638]             {
[10:25:46.638]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.638]                   0L) {
[10:25:46.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.638]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.638]                   base::options(opts)
[10:25:46.638]                 }
[10:25:46.638]                 {
[10:25:46.638]                   {
[10:25:46.638]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.638]                     NULL
[10:25:46.638]                   }
[10:25:46.638]                   options(future.plan = NULL)
[10:25:46.638]                   if (is.na(NA_character_)) 
[10:25:46.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.638]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.638]                     envir = parent.frame()) 
[10:25:46.638]                   {
[10:25:46.638]                     default_workers <- missing(workers)
[10:25:46.638]                     if (is.function(workers)) 
[10:25:46.638]                       workers <- workers()
[10:25:46.638]                     workers <- structure(as.integer(workers), 
[10:25:46.638]                       class = class(workers))
[10:25:46.638]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.638]                       1L)
[10:25:46.638]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.638]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.638]                       if (default_workers) 
[10:25:46.638]                         supportsMulticore(warn = TRUE)
[10:25:46.638]                       return(sequential(..., envir = envir))
[10:25:46.638]                     }
[10:25:46.638]                     oopts <- options(mc.cores = workers)
[10:25:46.638]                     on.exit(options(oopts))
[10:25:46.638]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.638]                       envir = envir)
[10:25:46.638]                     if (!future$lazy) 
[10:25:46.638]                       future <- run(future)
[10:25:46.638]                     invisible(future)
[10:25:46.638]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.638]                 }
[10:25:46.638]             }
[10:25:46.638]         }
[10:25:46.638]     })
[10:25:46.638]     if (TRUE) {
[10:25:46.638]         base::sink(type = "output", split = FALSE)
[10:25:46.638]         if (TRUE) {
[10:25:46.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.638]         }
[10:25:46.638]         else {
[10:25:46.638]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.638]         }
[10:25:46.638]         base::close(...future.stdout)
[10:25:46.638]         ...future.stdout <- NULL
[10:25:46.638]     }
[10:25:46.638]     ...future.result$conditions <- ...future.conditions
[10:25:46.638]     ...future.result$finished <- base::Sys.time()
[10:25:46.638]     ...future.result
[10:25:46.638] }
[10:25:46.640] requestCore(): workers = 2
[10:25:46.642] MulticoreFuture started
[10:25:46.643] - Launch lazy future ... done
[10:25:46.643] run() for ‘MulticoreFuture’ ... done
[10:25:46.643] getGlobalsAndPackages() ...
[10:25:46.643] Searching for globals...
[10:25:46.643] plan(): Setting new future strategy stack:
[10:25:46.644] 
[10:25:46.644] Searching for globals ... DONE
[10:25:46.644] List of future strategies:
[10:25:46.644] 1. sequential:
[10:25:46.644]    - args: function (..., envir = parent.frame())
[10:25:46.644]    - tweaked: FALSE
[10:25:46.644]    - call: NULL
[10:25:46.644] - globals: [0] <none>
[10:25:46.645] plan(): nbrOfWorkers() = 1
[10:25:46.645] getGlobalsAndPackages() ... DONE
[10:25:46.645] run() for ‘Future’ ...
[10:25:46.645] - state: ‘created’
[10:25:46.646] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.646] plan(): Setting new future strategy stack:
[10:25:46.647] List of future strategies:
[10:25:46.647] 1. multicore:
[10:25:46.647]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.647]    - tweaked: FALSE
[10:25:46.647]    - call: plan(strategy)
[10:25:46.651] plan(): nbrOfWorkers() = 2
[10:25:46.651] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.651]   - Field: ‘label’
[10:25:46.651]   - Field: ‘local’
[10:25:46.651]   - Field: ‘owner’
[10:25:46.652]   - Field: ‘envir’
[10:25:46.652]   - Field: ‘workers’
[10:25:46.652]   - Field: ‘packages’
[10:25:46.652]   - Field: ‘gc’
[10:25:46.652]   - Field: ‘job’
[10:25:46.652]   - Field: ‘conditions’
[10:25:46.653]   - Field: ‘expr’
[10:25:46.653]   - Field: ‘uuid’
[10:25:46.653]   - Field: ‘seed’
[10:25:46.653]   - Field: ‘version’
[10:25:46.653]   - Field: ‘result’
[10:25:46.653]   - Field: ‘asynchronous’
[10:25:46.654]   - Field: ‘calls’
[10:25:46.654]   - Field: ‘globals’
[10:25:46.654]   - Field: ‘stdout’
[10:25:46.654]   - Field: ‘earlySignal’
[10:25:46.654]   - Field: ‘lazy’
[10:25:46.655]   - Field: ‘state’
[10:25:46.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.655] - Launch lazy future ...
[10:25:46.656] Packages needed by the future expression (n = 0): <none>
[10:25:46.656] Packages needed by future strategies (n = 0): <none>
[10:25:46.657] {
[10:25:46.657]     {
[10:25:46.657]         {
[10:25:46.657]             ...future.startTime <- base::Sys.time()
[10:25:46.657]             {
[10:25:46.657]                 {
[10:25:46.657]                   {
[10:25:46.657]                     {
[10:25:46.657]                       base::local({
[10:25:46.657]                         has_future <- base::requireNamespace("future", 
[10:25:46.657]                           quietly = TRUE)
[10:25:46.657]                         if (has_future) {
[10:25:46.657]                           ns <- base::getNamespace("future")
[10:25:46.657]                           version <- ns[[".package"]][["version"]]
[10:25:46.657]                           if (is.null(version)) 
[10:25:46.657]                             version <- utils::packageVersion("future")
[10:25:46.657]                         }
[10:25:46.657]                         else {
[10:25:46.657]                           version <- NULL
[10:25:46.657]                         }
[10:25:46.657]                         if (!has_future || version < "1.8.0") {
[10:25:46.657]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.657]                             "", base::R.version$version.string), 
[10:25:46.657]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.657]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.657]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.657]                               "release", "version")], collapse = " "), 
[10:25:46.657]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.657]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.657]                             info)
[10:25:46.657]                           info <- base::paste(info, collapse = "; ")
[10:25:46.657]                           if (!has_future) {
[10:25:46.657]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.657]                               info)
[10:25:46.657]                           }
[10:25:46.657]                           else {
[10:25:46.657]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.657]                               info, version)
[10:25:46.657]                           }
[10:25:46.657]                           base::stop(msg)
[10:25:46.657]                         }
[10:25:46.657]                       })
[10:25:46.657]                     }
[10:25:46.657]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.657]                     base::options(mc.cores = 1L)
[10:25:46.657]                   }
[10:25:46.657]                   options(future.plan = NULL)
[10:25:46.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.657]                 }
[10:25:46.657]                 ...future.workdir <- getwd()
[10:25:46.657]             }
[10:25:46.657]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.657]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.657]         }
[10:25:46.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.657]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.657]             base::names(...future.oldOptions))
[10:25:46.657]     }
[10:25:46.657]     if (FALSE) {
[10:25:46.657]     }
[10:25:46.657]     else {
[10:25:46.657]         if (TRUE) {
[10:25:46.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.657]                 open = "w")
[10:25:46.657]         }
[10:25:46.657]         else {
[10:25:46.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.657]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.657]         }
[10:25:46.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.657]             base::sink(type = "output", split = FALSE)
[10:25:46.657]             base::close(...future.stdout)
[10:25:46.657]         }, add = TRUE)
[10:25:46.657]     }
[10:25:46.657]     ...future.frame <- base::sys.nframe()
[10:25:46.657]     ...future.conditions <- base::list()
[10:25:46.657]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.657]     if (FALSE) {
[10:25:46.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.657]     }
[10:25:46.657]     ...future.result <- base::tryCatch({
[10:25:46.657]         base::withCallingHandlers({
[10:25:46.657]             ...future.value <- base::withVisible(base::local({
[10:25:46.657]                 withCallingHandlers({
[10:25:46.657]                   NULL
[10:25:46.657]                 }, immediateCondition = function(cond) {
[10:25:46.657]                   save_rds <- function (object, pathname, ...) 
[10:25:46.657]                   {
[10:25:46.657]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.657]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.657]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.657]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.657]                         fi_tmp[["mtime"]])
[10:25:46.657]                     }
[10:25:46.657]                     tryCatch({
[10:25:46.657]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.657]                     }, error = function(ex) {
[10:25:46.657]                       msg <- conditionMessage(ex)
[10:25:46.657]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.657]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.657]                         fi_tmp[["mtime"]], msg)
[10:25:46.657]                       ex$message <- msg
[10:25:46.657]                       stop(ex)
[10:25:46.657]                     })
[10:25:46.657]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.657]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.657]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.657]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.657]                       fi <- file.info(pathname)
[10:25:46.657]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.657]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.657]                         fi[["size"]], fi[["mtime"]])
[10:25:46.657]                       stop(msg)
[10:25:46.657]                     }
[10:25:46.657]                     invisible(pathname)
[10:25:46.657]                   }
[10:25:46.657]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.657]                     rootPath = tempdir()) 
[10:25:46.657]                   {
[10:25:46.657]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.657]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.657]                       tmpdir = path, fileext = ".rds")
[10:25:46.657]                     save_rds(obj, file)
[10:25:46.657]                   }
[10:25:46.657]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.657]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.657]                   {
[10:25:46.657]                     inherits <- base::inherits
[10:25:46.657]                     invokeRestart <- base::invokeRestart
[10:25:46.657]                     is.null <- base::is.null
[10:25:46.657]                     muffled <- FALSE
[10:25:46.657]                     if (inherits(cond, "message")) {
[10:25:46.657]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.657]                       if (muffled) 
[10:25:46.657]                         invokeRestart("muffleMessage")
[10:25:46.657]                     }
[10:25:46.657]                     else if (inherits(cond, "warning")) {
[10:25:46.657]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.657]                       if (muffled) 
[10:25:46.657]                         invokeRestart("muffleWarning")
[10:25:46.657]                     }
[10:25:46.657]                     else if (inherits(cond, "condition")) {
[10:25:46.657]                       if (!is.null(pattern)) {
[10:25:46.657]                         computeRestarts <- base::computeRestarts
[10:25:46.657]                         grepl <- base::grepl
[10:25:46.657]                         restarts <- computeRestarts(cond)
[10:25:46.657]                         for (restart in restarts) {
[10:25:46.657]                           name <- restart$name
[10:25:46.657]                           if (is.null(name)) 
[10:25:46.657]                             next
[10:25:46.657]                           if (!grepl(pattern, name)) 
[10:25:46.657]                             next
[10:25:46.657]                           invokeRestart(restart)
[10:25:46.657]                           muffled <- TRUE
[10:25:46.657]                           break
[10:25:46.657]                         }
[10:25:46.657]                       }
[10:25:46.657]                     }
[10:25:46.657]                     invisible(muffled)
[10:25:46.657]                   }
[10:25:46.657]                   muffleCondition(cond)
[10:25:46.657]                 })
[10:25:46.657]             }))
[10:25:46.657]             future::FutureResult(value = ...future.value$value, 
[10:25:46.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.657]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.657]                     ...future.globalenv.names))
[10:25:46.657]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.657]         }, condition = base::local({
[10:25:46.657]             c <- base::c
[10:25:46.657]             inherits <- base::inherits
[10:25:46.657]             invokeRestart <- base::invokeRestart
[10:25:46.657]             length <- base::length
[10:25:46.657]             list <- base::list
[10:25:46.657]             seq.int <- base::seq.int
[10:25:46.657]             signalCondition <- base::signalCondition
[10:25:46.657]             sys.calls <- base::sys.calls
[10:25:46.657]             `[[` <- base::`[[`
[10:25:46.657]             `+` <- base::`+`
[10:25:46.657]             `<<-` <- base::`<<-`
[10:25:46.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.657]                   3L)]
[10:25:46.657]             }
[10:25:46.657]             function(cond) {
[10:25:46.657]                 is_error <- inherits(cond, "error")
[10:25:46.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.657]                   NULL)
[10:25:46.657]                 if (is_error) {
[10:25:46.657]                   sessionInformation <- function() {
[10:25:46.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.657]                       search = base::search(), system = base::Sys.info())
[10:25:46.657]                   }
[10:25:46.657]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.657]                     cond$call), session = sessionInformation(), 
[10:25:46.657]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.657]                   signalCondition(cond)
[10:25:46.657]                 }
[10:25:46.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.657]                 "immediateCondition"))) {
[10:25:46.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.657]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.657]                   if (TRUE && !signal) {
[10:25:46.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.657]                     {
[10:25:46.657]                       inherits <- base::inherits
[10:25:46.657]                       invokeRestart <- base::invokeRestart
[10:25:46.657]                       is.null <- base::is.null
[10:25:46.657]                       muffled <- FALSE
[10:25:46.657]                       if (inherits(cond, "message")) {
[10:25:46.657]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.657]                         if (muffled) 
[10:25:46.657]                           invokeRestart("muffleMessage")
[10:25:46.657]                       }
[10:25:46.657]                       else if (inherits(cond, "warning")) {
[10:25:46.657]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.657]                         if (muffled) 
[10:25:46.657]                           invokeRestart("muffleWarning")
[10:25:46.657]                       }
[10:25:46.657]                       else if (inherits(cond, "condition")) {
[10:25:46.657]                         if (!is.null(pattern)) {
[10:25:46.657]                           computeRestarts <- base::computeRestarts
[10:25:46.657]                           grepl <- base::grepl
[10:25:46.657]                           restarts <- computeRestarts(cond)
[10:25:46.657]                           for (restart in restarts) {
[10:25:46.657]                             name <- restart$name
[10:25:46.657]                             if (is.null(name)) 
[10:25:46.657]                               next
[10:25:46.657]                             if (!grepl(pattern, name)) 
[10:25:46.657]                               next
[10:25:46.657]                             invokeRestart(restart)
[10:25:46.657]                             muffled <- TRUE
[10:25:46.657]                             break
[10:25:46.657]                           }
[10:25:46.657]                         }
[10:25:46.657]                       }
[10:25:46.657]                       invisible(muffled)
[10:25:46.657]                     }
[10:25:46.657]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.657]                   }
[10:25:46.657]                 }
[10:25:46.657]                 else {
[10:25:46.657]                   if (TRUE) {
[10:25:46.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.657]                     {
[10:25:46.657]                       inherits <- base::inherits
[10:25:46.657]                       invokeRestart <- base::invokeRestart
[10:25:46.657]                       is.null <- base::is.null
[10:25:46.657]                       muffled <- FALSE
[10:25:46.657]                       if (inherits(cond, "message")) {
[10:25:46.657]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.657]                         if (muffled) 
[10:25:46.657]                           invokeRestart("muffleMessage")
[10:25:46.657]                       }
[10:25:46.657]                       else if (inherits(cond, "warning")) {
[10:25:46.657]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.657]                         if (muffled) 
[10:25:46.657]                           invokeRestart("muffleWarning")
[10:25:46.657]                       }
[10:25:46.657]                       else if (inherits(cond, "condition")) {
[10:25:46.657]                         if (!is.null(pattern)) {
[10:25:46.657]                           computeRestarts <- base::computeRestarts
[10:25:46.657]                           grepl <- base::grepl
[10:25:46.657]                           restarts <- computeRestarts(cond)
[10:25:46.657]                           for (restart in restarts) {
[10:25:46.657]                             name <- restart$name
[10:25:46.657]                             if (is.null(name)) 
[10:25:46.657]                               next
[10:25:46.657]                             if (!grepl(pattern, name)) 
[10:25:46.657]                               next
[10:25:46.657]                             invokeRestart(restart)
[10:25:46.657]                             muffled <- TRUE
[10:25:46.657]                             break
[10:25:46.657]                           }
[10:25:46.657]                         }
[10:25:46.657]                       }
[10:25:46.657]                       invisible(muffled)
[10:25:46.657]                     }
[10:25:46.657]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.657]                   }
[10:25:46.657]                 }
[10:25:46.657]             }
[10:25:46.657]         }))
[10:25:46.657]     }, error = function(ex) {
[10:25:46.657]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.657]                 ...future.rng), started = ...future.startTime, 
[10:25:46.657]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.657]             version = "1.8"), class = "FutureResult")
[10:25:46.657]     }, finally = {
[10:25:46.657]         if (!identical(...future.workdir, getwd())) 
[10:25:46.657]             setwd(...future.workdir)
[10:25:46.657]         {
[10:25:46.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.657]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.657]             }
[10:25:46.657]             base::options(...future.oldOptions)
[10:25:46.657]             if (.Platform$OS.type == "windows") {
[10:25:46.657]                 old_names <- names(...future.oldEnvVars)
[10:25:46.657]                 envs <- base::Sys.getenv()
[10:25:46.657]                 names <- names(envs)
[10:25:46.657]                 common <- intersect(names, old_names)
[10:25:46.657]                 added <- setdiff(names, old_names)
[10:25:46.657]                 removed <- setdiff(old_names, names)
[10:25:46.657]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.657]                   envs[common]]
[10:25:46.657]                 NAMES <- toupper(changed)
[10:25:46.657]                 args <- list()
[10:25:46.657]                 for (kk in seq_along(NAMES)) {
[10:25:46.657]                   name <- changed[[kk]]
[10:25:46.657]                   NAME <- NAMES[[kk]]
[10:25:46.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.657]                     next
[10:25:46.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.657]                 }
[10:25:46.657]                 NAMES <- toupper(added)
[10:25:46.657]                 for (kk in seq_along(NAMES)) {
[10:25:46.657]                   name <- added[[kk]]
[10:25:46.657]                   NAME <- NAMES[[kk]]
[10:25:46.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.657]                     next
[10:25:46.657]                   args[[name]] <- ""
[10:25:46.657]                 }
[10:25:46.657]                 NAMES <- toupper(removed)
[10:25:46.657]                 for (kk in seq_along(NAMES)) {
[10:25:46.657]                   name <- removed[[kk]]
[10:25:46.657]                   NAME <- NAMES[[kk]]
[10:25:46.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.657]                     next
[10:25:46.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.657]                 }
[10:25:46.657]                 if (length(args) > 0) 
[10:25:46.657]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.657]             }
[10:25:46.657]             else {
[10:25:46.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.657]             }
[10:25:46.657]             {
[10:25:46.657]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.657]                   0L) {
[10:25:46.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.657]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.657]                   base::options(opts)
[10:25:46.657]                 }
[10:25:46.657]                 {
[10:25:46.657]                   {
[10:25:46.657]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.657]                     NULL
[10:25:46.657]                   }
[10:25:46.657]                   options(future.plan = NULL)
[10:25:46.657]                   if (is.na(NA_character_)) 
[10:25:46.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.657]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.657]                     envir = parent.frame()) 
[10:25:46.657]                   {
[10:25:46.657]                     default_workers <- missing(workers)
[10:25:46.657]                     if (is.function(workers)) 
[10:25:46.657]                       workers <- workers()
[10:25:46.657]                     workers <- structure(as.integer(workers), 
[10:25:46.657]                       class = class(workers))
[10:25:46.657]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.657]                       1L)
[10:25:46.657]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.657]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.657]                       if (default_workers) 
[10:25:46.657]                         supportsMulticore(warn = TRUE)
[10:25:46.657]                       return(sequential(..., envir = envir))
[10:25:46.657]                     }
[10:25:46.657]                     oopts <- options(mc.cores = workers)
[10:25:46.657]                     on.exit(options(oopts))
[10:25:46.657]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.657]                       envir = envir)
[10:25:46.657]                     if (!future$lazy) 
[10:25:46.657]                       future <- run(future)
[10:25:46.657]                     invisible(future)
[10:25:46.657]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.657]                 }
[10:25:46.657]             }
[10:25:46.657]         }
[10:25:46.657]     })
[10:25:46.657]     if (TRUE) {
[10:25:46.657]         base::sink(type = "output", split = FALSE)
[10:25:46.657]         if (TRUE) {
[10:25:46.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.657]         }
[10:25:46.657]         else {
[10:25:46.657]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.657]         }
[10:25:46.657]         base::close(...future.stdout)
[10:25:46.657]         ...future.stdout <- NULL
[10:25:46.657]     }
[10:25:46.657]     ...future.result$conditions <- ...future.conditions
[10:25:46.657]     ...future.result$finished <- base::Sys.time()
[10:25:46.657]     ...future.result
[10:25:46.657] }
[10:25:46.661] requestCore(): workers = 2
[10:25:46.663] MulticoreFuture started
[10:25:46.663] - Launch lazy future ... done
[10:25:46.663] run() for ‘MulticoreFuture’ ... done
List of 6
[10:25:46.664] plan(): Setting new future strategy stack:
 $ a:[10:25:46.664] List of future strategies:
[10:25:46.664] 1. sequential:
[10:25:46.664]    - args: function (..., envir = parent.frame())
[10:25:46.664]    - tweaked: FALSE
[10:25:46.664]    - call: NULL
 num 1
 $ b:[10:25:46.665] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f4c0eac0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f5132ec8> 
 $  : NULL
 $  : NULL
 $  :[10:25:46.667] plan(): Setting new future strategy stack:
[10:25:46.667] List of future strategies:
[10:25:46.667] 1. multicore:
[10:25:46.667]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.667]    - tweaked: FALSE
[10:25:46.667]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f4c0eac0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f5132ec8> 
 $  : NULL
 $ [10:25:46.676] plan(): nbrOfWorkers() = 2
 : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:46.682] resolve() on list ...
[10:25:46.682]  recursive: 0
[10:25:46.683]  length: 6
[10:25:46.683]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:46.683] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.683] - nx: 6
[10:25:46.683] - relay: TRUE
[10:25:46.683] - stdout: TRUE
[10:25:46.684] - signal: TRUE
[10:25:46.684] - resignal: FALSE
[10:25:46.684] - force: TRUE
[10:25:46.684] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.684] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.684]  - until=2
[10:25:46.684]  - relaying element #2
[10:25:46.685] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.685] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.685] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.685]  length: 5 (resolved future 1)
[10:25:46.685] Future #2
[10:25:46.685] result() for MulticoreFuture ...
[10:25:46.686] result() for MulticoreFuture ...
[10:25:46.686] result() for MulticoreFuture ... done
[10:25:46.687] result() for MulticoreFuture ... done
[10:25:46.687] result() for MulticoreFuture ...
[10:25:46.687] result() for MulticoreFuture ... done
[10:25:46.687] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:46.687] - nx: 6
[10:25:46.687] - relay: TRUE
[10:25:46.687] - stdout: TRUE
[10:25:46.688] - signal: TRUE
[10:25:46.688] - resignal: FALSE
[10:25:46.688] - force: TRUE
[10:25:46.688] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.688] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.688]  - until=2
[10:25:46.688]  - relaying element #2
[10:25:46.688] result() for MulticoreFuture ...
[10:25:46.689] result() for MulticoreFuture ... done
[10:25:46.689] result() for MulticoreFuture ...
[10:25:46.689] result() for MulticoreFuture ... done
[10:25:46.689] result() for MulticoreFuture ...
[10:25:46.689] result() for MulticoreFuture ... done
[10:25:46.689] result() for MulticoreFuture ...
[10:25:46.690] result() for MulticoreFuture ... done
[10:25:46.690] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.690] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.690] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:46.690]  length: 4 (resolved future 2)
[10:25:46.690] Future #3
[10:25:46.691] result() for MulticoreFuture ...
[10:25:46.691] result() for MulticoreFuture ...
[10:25:46.691] result() for MulticoreFuture ... done
[10:25:46.691] result() for MulticoreFuture ... done
[10:25:46.691] result() for MulticoreFuture ...
[10:25:46.692] result() for MulticoreFuture ... done
[10:25:46.692] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:46.692] - nx: 6
[10:25:46.692] - relay: TRUE
[10:25:46.692] - stdout: TRUE
[10:25:46.692] - signal: TRUE
[10:25:46.692] - resignal: FALSE
[10:25:46.692] - force: TRUE
[10:25:46.692] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.693] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.693]  - until=3
[10:25:46.693]  - relaying element #3
[10:25:46.693] result() for MulticoreFuture ...
[10:25:46.693] result() for MulticoreFuture ... done
[10:25:46.693] result() for MulticoreFuture ...
[10:25:46.693] result() for MulticoreFuture ... done
[10:25:46.693] result() for MulticoreFuture ...
[10:25:46.694] result() for MulticoreFuture ... done
[10:25:46.694] result() for MulticoreFuture ...
[10:25:46.694] result() for MulticoreFuture ... done
[10:25:46.694] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.694] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.694] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:46.694]  length: 3 (resolved future 3)
[10:25:46.694] signalConditionsASAP(NULL, pos=4) ...
[10:25:46.694] - nx: 6
[10:25:46.694] - relay: TRUE
[10:25:46.695] - stdout: TRUE
[10:25:46.695] - signal: TRUE
[10:25:46.695] - resignal: FALSE
[10:25:46.695] - force: TRUE
[10:25:46.695] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.695] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.695]  - until=5
[10:25:46.695]  - relaying element #5
[10:25:46.695] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.695] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.696] signalConditionsASAP(NULL, pos=4) ... done
[10:25:46.696]  length: 2 (resolved future 4)
[10:25:46.696] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.696] - nx: 6
[10:25:46.696] - relay: TRUE
[10:25:46.696] - stdout: TRUE
[10:25:46.696] - signal: TRUE
[10:25:46.696] - resignal: FALSE
[10:25:46.696] - force: TRUE
[10:25:46.696] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.696] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.697]  - until=6
[10:25:46.697]  - relaying element #6
[10:25:46.697] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.697] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.697] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.697]  length: 1 (resolved future 5)
[10:25:46.697] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.697] - nx: 6
[10:25:46.697] - relay: TRUE
[10:25:46.698] - stdout: TRUE
[10:25:46.698] - signal: TRUE
[10:25:46.698] - resignal: FALSE
[10:25:46.698] - force: TRUE
[10:25:46.698] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.698] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.698]  - until=6
[10:25:46.698] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.698] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.698] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.698]  length: 0 (resolved future 6)
[10:25:46.699] Relaying remaining futures
[10:25:46.699] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.699] - nx: 6
[10:25:46.699] - relay: TRUE
[10:25:46.699] - stdout: TRUE
[10:25:46.699] - signal: TRUE
[10:25:46.699] - resignal: FALSE
[10:25:46.699] - force: TRUE
[10:25:46.699] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.699] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:46.700] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.700] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.700] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.700] resolve() on list ... DONE
[10:25:46.700] result() for MulticoreFuture ...
[10:25:46.700] result() for MulticoreFuture ... done
[10:25:46.700] result() for MulticoreFuture ...
[10:25:46.700] result() for MulticoreFuture ... done
[10:25:46.700] result() for MulticoreFuture ...
[10:25:46.701] result() for MulticoreFuture ... done
[10:25:46.701] result() for MulticoreFuture ...
[10:25:46.701] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:25:46.704] getGlobalsAndPackages() ...
[10:25:46.704] Searching for globals...
[10:25:46.706] 
[10:25:46.706] Searching for globals ... DONE
[10:25:46.706] - globals: [0] <none>
[10:25:46.707] getGlobalsAndPackages() ... DONE
[10:25:46.707] run() for ‘Future’ ...
[10:25:46.707] - state: ‘created’
[10:25:46.707] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.712] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.712]   - Field: ‘label’
[10:25:46.712]   - Field: ‘local’
[10:25:46.712]   - Field: ‘owner’
[10:25:46.713]   - Field: ‘envir’
[10:25:46.713]   - Field: ‘workers’
[10:25:46.713]   - Field: ‘packages’
[10:25:46.713]   - Field: ‘gc’
[10:25:46.713]   - Field: ‘job’
[10:25:46.713]   - Field: ‘conditions’
[10:25:46.713]   - Field: ‘expr’
[10:25:46.713]   - Field: ‘uuid’
[10:25:46.713]   - Field: ‘seed’
[10:25:46.714]   - Field: ‘version’
[10:25:46.714]   - Field: ‘result’
[10:25:46.714]   - Field: ‘asynchronous’
[10:25:46.714]   - Field: ‘calls’
[10:25:46.714]   - Field: ‘globals’
[10:25:46.714]   - Field: ‘stdout’
[10:25:46.714]   - Field: ‘earlySignal’
[10:25:46.714]   - Field: ‘lazy’
[10:25:46.714]   - Field: ‘state’
[10:25:46.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.714] - Launch lazy future ...
[10:25:46.715] Packages needed by the future expression (n = 0): <none>
[10:25:46.715] Packages needed by future strategies (n = 0): <none>
[10:25:46.715] {
[10:25:46.715]     {
[10:25:46.715]         {
[10:25:46.715]             ...future.startTime <- base::Sys.time()
[10:25:46.715]             {
[10:25:46.715]                 {
[10:25:46.715]                   {
[10:25:46.715]                     {
[10:25:46.715]                       base::local({
[10:25:46.715]                         has_future <- base::requireNamespace("future", 
[10:25:46.715]                           quietly = TRUE)
[10:25:46.715]                         if (has_future) {
[10:25:46.715]                           ns <- base::getNamespace("future")
[10:25:46.715]                           version <- ns[[".package"]][["version"]]
[10:25:46.715]                           if (is.null(version)) 
[10:25:46.715]                             version <- utils::packageVersion("future")
[10:25:46.715]                         }
[10:25:46.715]                         else {
[10:25:46.715]                           version <- NULL
[10:25:46.715]                         }
[10:25:46.715]                         if (!has_future || version < "1.8.0") {
[10:25:46.715]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.715]                             "", base::R.version$version.string), 
[10:25:46.715]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.715]                               "release", "version")], collapse = " "), 
[10:25:46.715]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.715]                             info)
[10:25:46.715]                           info <- base::paste(info, collapse = "; ")
[10:25:46.715]                           if (!has_future) {
[10:25:46.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.715]                               info)
[10:25:46.715]                           }
[10:25:46.715]                           else {
[10:25:46.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.715]                               info, version)
[10:25:46.715]                           }
[10:25:46.715]                           base::stop(msg)
[10:25:46.715]                         }
[10:25:46.715]                       })
[10:25:46.715]                     }
[10:25:46.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.715]                     base::options(mc.cores = 1L)
[10:25:46.715]                   }
[10:25:46.715]                   options(future.plan = NULL)
[10:25:46.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.715]                 }
[10:25:46.715]                 ...future.workdir <- getwd()
[10:25:46.715]             }
[10:25:46.715]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.715]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.715]         }
[10:25:46.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.715]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.715]             base::names(...future.oldOptions))
[10:25:46.715]     }
[10:25:46.715]     if (FALSE) {
[10:25:46.715]     }
[10:25:46.715]     else {
[10:25:46.715]         if (TRUE) {
[10:25:46.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.715]                 open = "w")
[10:25:46.715]         }
[10:25:46.715]         else {
[10:25:46.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.715]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.715]         }
[10:25:46.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.715]             base::sink(type = "output", split = FALSE)
[10:25:46.715]             base::close(...future.stdout)
[10:25:46.715]         }, add = TRUE)
[10:25:46.715]     }
[10:25:46.715]     ...future.frame <- base::sys.nframe()
[10:25:46.715]     ...future.conditions <- base::list()
[10:25:46.715]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.715]     if (FALSE) {
[10:25:46.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.715]     }
[10:25:46.715]     ...future.result <- base::tryCatch({
[10:25:46.715]         base::withCallingHandlers({
[10:25:46.715]             ...future.value <- base::withVisible(base::local({
[10:25:46.715]                 withCallingHandlers({
[10:25:46.715]                   2
[10:25:46.715]                 }, immediateCondition = function(cond) {
[10:25:46.715]                   save_rds <- function (object, pathname, ...) 
[10:25:46.715]                   {
[10:25:46.715]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.715]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.715]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.715]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.715]                         fi_tmp[["mtime"]])
[10:25:46.715]                     }
[10:25:46.715]                     tryCatch({
[10:25:46.715]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.715]                     }, error = function(ex) {
[10:25:46.715]                       msg <- conditionMessage(ex)
[10:25:46.715]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.715]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.715]                         fi_tmp[["mtime"]], msg)
[10:25:46.715]                       ex$message <- msg
[10:25:46.715]                       stop(ex)
[10:25:46.715]                     })
[10:25:46.715]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.715]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.715]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.715]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.715]                       fi <- file.info(pathname)
[10:25:46.715]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.715]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.715]                         fi[["size"]], fi[["mtime"]])
[10:25:46.715]                       stop(msg)
[10:25:46.715]                     }
[10:25:46.715]                     invisible(pathname)
[10:25:46.715]                   }
[10:25:46.715]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.715]                     rootPath = tempdir()) 
[10:25:46.715]                   {
[10:25:46.715]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.715]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.715]                       tmpdir = path, fileext = ".rds")
[10:25:46.715]                     save_rds(obj, file)
[10:25:46.715]                   }
[10:25:46.715]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.715]                   {
[10:25:46.715]                     inherits <- base::inherits
[10:25:46.715]                     invokeRestart <- base::invokeRestart
[10:25:46.715]                     is.null <- base::is.null
[10:25:46.715]                     muffled <- FALSE
[10:25:46.715]                     if (inherits(cond, "message")) {
[10:25:46.715]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.715]                       if (muffled) 
[10:25:46.715]                         invokeRestart("muffleMessage")
[10:25:46.715]                     }
[10:25:46.715]                     else if (inherits(cond, "warning")) {
[10:25:46.715]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.715]                       if (muffled) 
[10:25:46.715]                         invokeRestart("muffleWarning")
[10:25:46.715]                     }
[10:25:46.715]                     else if (inherits(cond, "condition")) {
[10:25:46.715]                       if (!is.null(pattern)) {
[10:25:46.715]                         computeRestarts <- base::computeRestarts
[10:25:46.715]                         grepl <- base::grepl
[10:25:46.715]                         restarts <- computeRestarts(cond)
[10:25:46.715]                         for (restart in restarts) {
[10:25:46.715]                           name <- restart$name
[10:25:46.715]                           if (is.null(name)) 
[10:25:46.715]                             next
[10:25:46.715]                           if (!grepl(pattern, name)) 
[10:25:46.715]                             next
[10:25:46.715]                           invokeRestart(restart)
[10:25:46.715]                           muffled <- TRUE
[10:25:46.715]                           break
[10:25:46.715]                         }
[10:25:46.715]                       }
[10:25:46.715]                     }
[10:25:46.715]                     invisible(muffled)
[10:25:46.715]                   }
[10:25:46.715]                   muffleCondition(cond)
[10:25:46.715]                 })
[10:25:46.715]             }))
[10:25:46.715]             future::FutureResult(value = ...future.value$value, 
[10:25:46.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.715]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.715]                     ...future.globalenv.names))
[10:25:46.715]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.715]         }, condition = base::local({
[10:25:46.715]             c <- base::c
[10:25:46.715]             inherits <- base::inherits
[10:25:46.715]             invokeRestart <- base::invokeRestart
[10:25:46.715]             length <- base::length
[10:25:46.715]             list <- base::list
[10:25:46.715]             seq.int <- base::seq.int
[10:25:46.715]             signalCondition <- base::signalCondition
[10:25:46.715]             sys.calls <- base::sys.calls
[10:25:46.715]             `[[` <- base::`[[`
[10:25:46.715]             `+` <- base::`+`
[10:25:46.715]             `<<-` <- base::`<<-`
[10:25:46.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.715]                   3L)]
[10:25:46.715]             }
[10:25:46.715]             function(cond) {
[10:25:46.715]                 is_error <- inherits(cond, "error")
[10:25:46.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.715]                   NULL)
[10:25:46.715]                 if (is_error) {
[10:25:46.715]                   sessionInformation <- function() {
[10:25:46.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.715]                       search = base::search(), system = base::Sys.info())
[10:25:46.715]                   }
[10:25:46.715]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.715]                     cond$call), session = sessionInformation(), 
[10:25:46.715]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.715]                   signalCondition(cond)
[10:25:46.715]                 }
[10:25:46.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.715]                 "immediateCondition"))) {
[10:25:46.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.715]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.715]                   if (TRUE && !signal) {
[10:25:46.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.715]                     {
[10:25:46.715]                       inherits <- base::inherits
[10:25:46.715]                       invokeRestart <- base::invokeRestart
[10:25:46.715]                       is.null <- base::is.null
[10:25:46.715]                       muffled <- FALSE
[10:25:46.715]                       if (inherits(cond, "message")) {
[10:25:46.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.715]                         if (muffled) 
[10:25:46.715]                           invokeRestart("muffleMessage")
[10:25:46.715]                       }
[10:25:46.715]                       else if (inherits(cond, "warning")) {
[10:25:46.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.715]                         if (muffled) 
[10:25:46.715]                           invokeRestart("muffleWarning")
[10:25:46.715]                       }
[10:25:46.715]                       else if (inherits(cond, "condition")) {
[10:25:46.715]                         if (!is.null(pattern)) {
[10:25:46.715]                           computeRestarts <- base::computeRestarts
[10:25:46.715]                           grepl <- base::grepl
[10:25:46.715]                           restarts <- computeRestarts(cond)
[10:25:46.715]                           for (restart in restarts) {
[10:25:46.715]                             name <- restart$name
[10:25:46.715]                             if (is.null(name)) 
[10:25:46.715]                               next
[10:25:46.715]                             if (!grepl(pattern, name)) 
[10:25:46.715]                               next
[10:25:46.715]                             invokeRestart(restart)
[10:25:46.715]                             muffled <- TRUE
[10:25:46.715]                             break
[10:25:46.715]                           }
[10:25:46.715]                         }
[10:25:46.715]                       }
[10:25:46.715]                       invisible(muffled)
[10:25:46.715]                     }
[10:25:46.715]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.715]                   }
[10:25:46.715]                 }
[10:25:46.715]                 else {
[10:25:46.715]                   if (TRUE) {
[10:25:46.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.715]                     {
[10:25:46.715]                       inherits <- base::inherits
[10:25:46.715]                       invokeRestart <- base::invokeRestart
[10:25:46.715]                       is.null <- base::is.null
[10:25:46.715]                       muffled <- FALSE
[10:25:46.715]                       if (inherits(cond, "message")) {
[10:25:46.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.715]                         if (muffled) 
[10:25:46.715]                           invokeRestart("muffleMessage")
[10:25:46.715]                       }
[10:25:46.715]                       else if (inherits(cond, "warning")) {
[10:25:46.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.715]                         if (muffled) 
[10:25:46.715]                           invokeRestart("muffleWarning")
[10:25:46.715]                       }
[10:25:46.715]                       else if (inherits(cond, "condition")) {
[10:25:46.715]                         if (!is.null(pattern)) {
[10:25:46.715]                           computeRestarts <- base::computeRestarts
[10:25:46.715]                           grepl <- base::grepl
[10:25:46.715]                           restarts <- computeRestarts(cond)
[10:25:46.715]                           for (restart in restarts) {
[10:25:46.715]                             name <- restart$name
[10:25:46.715]                             if (is.null(name)) 
[10:25:46.715]                               next
[10:25:46.715]                             if (!grepl(pattern, name)) 
[10:25:46.715]                               next
[10:25:46.715]                             invokeRestart(restart)
[10:25:46.715]                             muffled <- TRUE
[10:25:46.715]                             break
[10:25:46.715]                           }
[10:25:46.715]                         }
[10:25:46.715]                       }
[10:25:46.715]                       invisible(muffled)
[10:25:46.715]                     }
[10:25:46.715]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.715]                   }
[10:25:46.715]                 }
[10:25:46.715]             }
[10:25:46.715]         }))
[10:25:46.715]     }, error = function(ex) {
[10:25:46.715]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.715]                 ...future.rng), started = ...future.startTime, 
[10:25:46.715]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.715]             version = "1.8"), class = "FutureResult")
[10:25:46.715]     }, finally = {
[10:25:46.715]         if (!identical(...future.workdir, getwd())) 
[10:25:46.715]             setwd(...future.workdir)
[10:25:46.715]         {
[10:25:46.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.715]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.715]             }
[10:25:46.715]             base::options(...future.oldOptions)
[10:25:46.715]             if (.Platform$OS.type == "windows") {
[10:25:46.715]                 old_names <- names(...future.oldEnvVars)
[10:25:46.715]                 envs <- base::Sys.getenv()
[10:25:46.715]                 names <- names(envs)
[10:25:46.715]                 common <- intersect(names, old_names)
[10:25:46.715]                 added <- setdiff(names, old_names)
[10:25:46.715]                 removed <- setdiff(old_names, names)
[10:25:46.715]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.715]                   envs[common]]
[10:25:46.715]                 NAMES <- toupper(changed)
[10:25:46.715]                 args <- list()
[10:25:46.715]                 for (kk in seq_along(NAMES)) {
[10:25:46.715]                   name <- changed[[kk]]
[10:25:46.715]                   NAME <- NAMES[[kk]]
[10:25:46.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.715]                     next
[10:25:46.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.715]                 }
[10:25:46.715]                 NAMES <- toupper(added)
[10:25:46.715]                 for (kk in seq_along(NAMES)) {
[10:25:46.715]                   name <- added[[kk]]
[10:25:46.715]                   NAME <- NAMES[[kk]]
[10:25:46.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.715]                     next
[10:25:46.715]                   args[[name]] <- ""
[10:25:46.715]                 }
[10:25:46.715]                 NAMES <- toupper(removed)
[10:25:46.715]                 for (kk in seq_along(NAMES)) {
[10:25:46.715]                   name <- removed[[kk]]
[10:25:46.715]                   NAME <- NAMES[[kk]]
[10:25:46.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.715]                     next
[10:25:46.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.715]                 }
[10:25:46.715]                 if (length(args) > 0) 
[10:25:46.715]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.715]             }
[10:25:46.715]             else {
[10:25:46.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.715]             }
[10:25:46.715]             {
[10:25:46.715]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.715]                   0L) {
[10:25:46.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.715]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.715]                   base::options(opts)
[10:25:46.715]                 }
[10:25:46.715]                 {
[10:25:46.715]                   {
[10:25:46.715]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.715]                     NULL
[10:25:46.715]                   }
[10:25:46.715]                   options(future.plan = NULL)
[10:25:46.715]                   if (is.na(NA_character_)) 
[10:25:46.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.715]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.715]                     envir = parent.frame()) 
[10:25:46.715]                   {
[10:25:46.715]                     default_workers <- missing(workers)
[10:25:46.715]                     if (is.function(workers)) 
[10:25:46.715]                       workers <- workers()
[10:25:46.715]                     workers <- structure(as.integer(workers), 
[10:25:46.715]                       class = class(workers))
[10:25:46.715]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.715]                       1L)
[10:25:46.715]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.715]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.715]                       if (default_workers) 
[10:25:46.715]                         supportsMulticore(warn = TRUE)
[10:25:46.715]                       return(sequential(..., envir = envir))
[10:25:46.715]                     }
[10:25:46.715]                     oopts <- options(mc.cores = workers)
[10:25:46.715]                     on.exit(options(oopts))
[10:25:46.715]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.715]                       envir = envir)
[10:25:46.715]                     if (!future$lazy) 
[10:25:46.715]                       future <- run(future)
[10:25:46.715]                     invisible(future)
[10:25:46.715]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.715]                 }
[10:25:46.715]             }
[10:25:46.715]         }
[10:25:46.715]     })
[10:25:46.715]     if (TRUE) {
[10:25:46.715]         base::sink(type = "output", split = FALSE)
[10:25:46.715]         if (TRUE) {
[10:25:46.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.715]         }
[10:25:46.715]         else {
[10:25:46.715]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.715]         }
[10:25:46.715]         base::close(...future.stdout)
[10:25:46.715]         ...future.stdout <- NULL
[10:25:46.715]     }
[10:25:46.715]     ...future.result$conditions <- ...future.conditions
[10:25:46.715]     ...future.result$finished <- base::Sys.time()
[10:25:46.715]     ...future.result
[10:25:46.715] }
[10:25:46.718] requestCore(): workers = 2
[10:25:46.720] MulticoreFuture started
[10:25:46.720] - Launch lazy future ... done
[10:25:46.721] run() for ‘MulticoreFuture’ ... done
[10:25:46.721] getGlobalsAndPackages() ...
[10:25:46.721] Searching for globals...
[10:25:46.721] plan(): Setting new future strategy stack:
[10:25:46.722] List of future strategies:
[10:25:46.722] 1. sequential:
[10:25:46.722]    - args: function (..., envir = parent.frame())
[10:25:46.722]    - tweaked: FALSE
[10:25:46.722]    - call: NULL
[10:25:46.722] 
[10:25:46.722] Searching for globals ... DONE
[10:25:46.722] plan(): nbrOfWorkers() = 1
[10:25:46.723] - globals: [0] <none>
[10:25:46.723] getGlobalsAndPackages() ... DONE
[10:25:46.723] run() for ‘Future’ ...
[10:25:46.724] - state: ‘created’
[10:25:46.724] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.724] plan(): Setting new future strategy stack:
[10:25:46.725] List of future strategies:
[10:25:46.725] 1. multicore:
[10:25:46.725]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.725]    - tweaked: FALSE
[10:25:46.725]    - call: plan(strategy)
[10:25:46.729] plan(): nbrOfWorkers() = 2
[10:25:46.729] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.730]   - Field: ‘label’
[10:25:46.730]   - Field: ‘local’
[10:25:46.730]   - Field: ‘owner’
[10:25:46.731]   - Field: ‘envir’
[10:25:46.731]   - Field: ‘workers’
[10:25:46.731]   - Field: ‘packages’
[10:25:46.731]   - Field: ‘gc’
[10:25:46.731]   - Field: ‘job’
[10:25:46.731]   - Field: ‘conditions’
[10:25:46.732]   - Field: ‘expr’
[10:25:46.732]   - Field: ‘uuid’
[10:25:46.732]   - Field: ‘seed’
[10:25:46.732]   - Field: ‘version’
[10:25:46.732]   - Field: ‘result’
[10:25:46.732]   - Field: ‘asynchronous’
[10:25:46.733]   - Field: ‘calls’
[10:25:46.733]   - Field: ‘globals’
[10:25:46.733]   - Field: ‘stdout’
[10:25:46.733]   - Field: ‘earlySignal’
[10:25:46.733]   - Field: ‘lazy’
[10:25:46.733]   - Field: ‘state’
[10:25:46.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.734] - Launch lazy future ...
[10:25:46.734] Packages needed by the future expression (n = 0): <none>
[10:25:46.734] Packages needed by future strategies (n = 0): <none>
[10:25:46.735] {
[10:25:46.735]     {
[10:25:46.735]         {
[10:25:46.735]             ...future.startTime <- base::Sys.time()
[10:25:46.735]             {
[10:25:46.735]                 {
[10:25:46.735]                   {
[10:25:46.735]                     {
[10:25:46.735]                       base::local({
[10:25:46.735]                         has_future <- base::requireNamespace("future", 
[10:25:46.735]                           quietly = TRUE)
[10:25:46.735]                         if (has_future) {
[10:25:46.735]                           ns <- base::getNamespace("future")
[10:25:46.735]                           version <- ns[[".package"]][["version"]]
[10:25:46.735]                           if (is.null(version)) 
[10:25:46.735]                             version <- utils::packageVersion("future")
[10:25:46.735]                         }
[10:25:46.735]                         else {
[10:25:46.735]                           version <- NULL
[10:25:46.735]                         }
[10:25:46.735]                         if (!has_future || version < "1.8.0") {
[10:25:46.735]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.735]                             "", base::R.version$version.string), 
[10:25:46.735]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.735]                               "release", "version")], collapse = " "), 
[10:25:46.735]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.735]                             info)
[10:25:46.735]                           info <- base::paste(info, collapse = "; ")
[10:25:46.735]                           if (!has_future) {
[10:25:46.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.735]                               info)
[10:25:46.735]                           }
[10:25:46.735]                           else {
[10:25:46.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.735]                               info, version)
[10:25:46.735]                           }
[10:25:46.735]                           base::stop(msg)
[10:25:46.735]                         }
[10:25:46.735]                       })
[10:25:46.735]                     }
[10:25:46.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.735]                     base::options(mc.cores = 1L)
[10:25:46.735]                   }
[10:25:46.735]                   options(future.plan = NULL)
[10:25:46.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.735]                 }
[10:25:46.735]                 ...future.workdir <- getwd()
[10:25:46.735]             }
[10:25:46.735]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.735]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.735]         }
[10:25:46.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.735]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.735]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.735]             base::names(...future.oldOptions))
[10:25:46.735]     }
[10:25:46.735]     if (FALSE) {
[10:25:46.735]     }
[10:25:46.735]     else {
[10:25:46.735]         if (TRUE) {
[10:25:46.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.735]                 open = "w")
[10:25:46.735]         }
[10:25:46.735]         else {
[10:25:46.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.735]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.735]         }
[10:25:46.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.735]             base::sink(type = "output", split = FALSE)
[10:25:46.735]             base::close(...future.stdout)
[10:25:46.735]         }, add = TRUE)
[10:25:46.735]     }
[10:25:46.735]     ...future.frame <- base::sys.nframe()
[10:25:46.735]     ...future.conditions <- base::list()
[10:25:46.735]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.735]     if (FALSE) {
[10:25:46.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.735]     }
[10:25:46.735]     ...future.result <- base::tryCatch({
[10:25:46.735]         base::withCallingHandlers({
[10:25:46.735]             ...future.value <- base::withVisible(base::local({
[10:25:46.735]                 withCallingHandlers({
[10:25:46.735]                   NULL
[10:25:46.735]                 }, immediateCondition = function(cond) {
[10:25:46.735]                   save_rds <- function (object, pathname, ...) 
[10:25:46.735]                   {
[10:25:46.735]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.735]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.735]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.735]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.735]                         fi_tmp[["mtime"]])
[10:25:46.735]                     }
[10:25:46.735]                     tryCatch({
[10:25:46.735]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.735]                     }, error = function(ex) {
[10:25:46.735]                       msg <- conditionMessage(ex)
[10:25:46.735]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.735]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.735]                         fi_tmp[["mtime"]], msg)
[10:25:46.735]                       ex$message <- msg
[10:25:46.735]                       stop(ex)
[10:25:46.735]                     })
[10:25:46.735]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.735]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.735]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.735]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.735]                       fi <- file.info(pathname)
[10:25:46.735]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.735]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.735]                         fi[["size"]], fi[["mtime"]])
[10:25:46.735]                       stop(msg)
[10:25:46.735]                     }
[10:25:46.735]                     invisible(pathname)
[10:25:46.735]                   }
[10:25:46.735]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.735]                     rootPath = tempdir()) 
[10:25:46.735]                   {
[10:25:46.735]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.735]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.735]                       tmpdir = path, fileext = ".rds")
[10:25:46.735]                     save_rds(obj, file)
[10:25:46.735]                   }
[10:25:46.735]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.735]                   {
[10:25:46.735]                     inherits <- base::inherits
[10:25:46.735]                     invokeRestart <- base::invokeRestart
[10:25:46.735]                     is.null <- base::is.null
[10:25:46.735]                     muffled <- FALSE
[10:25:46.735]                     if (inherits(cond, "message")) {
[10:25:46.735]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.735]                       if (muffled) 
[10:25:46.735]                         invokeRestart("muffleMessage")
[10:25:46.735]                     }
[10:25:46.735]                     else if (inherits(cond, "warning")) {
[10:25:46.735]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.735]                       if (muffled) 
[10:25:46.735]                         invokeRestart("muffleWarning")
[10:25:46.735]                     }
[10:25:46.735]                     else if (inherits(cond, "condition")) {
[10:25:46.735]                       if (!is.null(pattern)) {
[10:25:46.735]                         computeRestarts <- base::computeRestarts
[10:25:46.735]                         grepl <- base::grepl
[10:25:46.735]                         restarts <- computeRestarts(cond)
[10:25:46.735]                         for (restart in restarts) {
[10:25:46.735]                           name <- restart$name
[10:25:46.735]                           if (is.null(name)) 
[10:25:46.735]                             next
[10:25:46.735]                           if (!grepl(pattern, name)) 
[10:25:46.735]                             next
[10:25:46.735]                           invokeRestart(restart)
[10:25:46.735]                           muffled <- TRUE
[10:25:46.735]                           break
[10:25:46.735]                         }
[10:25:46.735]                       }
[10:25:46.735]                     }
[10:25:46.735]                     invisible(muffled)
[10:25:46.735]                   }
[10:25:46.735]                   muffleCondition(cond)
[10:25:46.735]                 })
[10:25:46.735]             }))
[10:25:46.735]             future::FutureResult(value = ...future.value$value, 
[10:25:46.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.735]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.735]                     ...future.globalenv.names))
[10:25:46.735]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.735]         }, condition = base::local({
[10:25:46.735]             c <- base::c
[10:25:46.735]             inherits <- base::inherits
[10:25:46.735]             invokeRestart <- base::invokeRestart
[10:25:46.735]             length <- base::length
[10:25:46.735]             list <- base::list
[10:25:46.735]             seq.int <- base::seq.int
[10:25:46.735]             signalCondition <- base::signalCondition
[10:25:46.735]             sys.calls <- base::sys.calls
[10:25:46.735]             `[[` <- base::`[[`
[10:25:46.735]             `+` <- base::`+`
[10:25:46.735]             `<<-` <- base::`<<-`
[10:25:46.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.735]                   3L)]
[10:25:46.735]             }
[10:25:46.735]             function(cond) {
[10:25:46.735]                 is_error <- inherits(cond, "error")
[10:25:46.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.735]                   NULL)
[10:25:46.735]                 if (is_error) {
[10:25:46.735]                   sessionInformation <- function() {
[10:25:46.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.735]                       search = base::search(), system = base::Sys.info())
[10:25:46.735]                   }
[10:25:46.735]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.735]                     cond$call), session = sessionInformation(), 
[10:25:46.735]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.735]                   signalCondition(cond)
[10:25:46.735]                 }
[10:25:46.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.735]                 "immediateCondition"))) {
[10:25:46.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.735]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.735]                   if (TRUE && !signal) {
[10:25:46.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.735]                     {
[10:25:46.735]                       inherits <- base::inherits
[10:25:46.735]                       invokeRestart <- base::invokeRestart
[10:25:46.735]                       is.null <- base::is.null
[10:25:46.735]                       muffled <- FALSE
[10:25:46.735]                       if (inherits(cond, "message")) {
[10:25:46.735]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.735]                         if (muffled) 
[10:25:46.735]                           invokeRestart("muffleMessage")
[10:25:46.735]                       }
[10:25:46.735]                       else if (inherits(cond, "warning")) {
[10:25:46.735]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.735]                         if (muffled) 
[10:25:46.735]                           invokeRestart("muffleWarning")
[10:25:46.735]                       }
[10:25:46.735]                       else if (inherits(cond, "condition")) {
[10:25:46.735]                         if (!is.null(pattern)) {
[10:25:46.735]                           computeRestarts <- base::computeRestarts
[10:25:46.735]                           grepl <- base::grepl
[10:25:46.735]                           restarts <- computeRestarts(cond)
[10:25:46.735]                           for (restart in restarts) {
[10:25:46.735]                             name <- restart$name
[10:25:46.735]                             if (is.null(name)) 
[10:25:46.735]                               next
[10:25:46.735]                             if (!grepl(pattern, name)) 
[10:25:46.735]                               next
[10:25:46.735]                             invokeRestart(restart)
[10:25:46.735]                             muffled <- TRUE
[10:25:46.735]                             break
[10:25:46.735]                           }
[10:25:46.735]                         }
[10:25:46.735]                       }
[10:25:46.735]                       invisible(muffled)
[10:25:46.735]                     }
[10:25:46.735]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.735]                   }
[10:25:46.735]                 }
[10:25:46.735]                 else {
[10:25:46.735]                   if (TRUE) {
[10:25:46.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.735]                     {
[10:25:46.735]                       inherits <- base::inherits
[10:25:46.735]                       invokeRestart <- base::invokeRestart
[10:25:46.735]                       is.null <- base::is.null
[10:25:46.735]                       muffled <- FALSE
[10:25:46.735]                       if (inherits(cond, "message")) {
[10:25:46.735]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.735]                         if (muffled) 
[10:25:46.735]                           invokeRestart("muffleMessage")
[10:25:46.735]                       }
[10:25:46.735]                       else if (inherits(cond, "warning")) {
[10:25:46.735]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.735]                         if (muffled) 
[10:25:46.735]                           invokeRestart("muffleWarning")
[10:25:46.735]                       }
[10:25:46.735]                       else if (inherits(cond, "condition")) {
[10:25:46.735]                         if (!is.null(pattern)) {
[10:25:46.735]                           computeRestarts <- base::computeRestarts
[10:25:46.735]                           grepl <- base::grepl
[10:25:46.735]                           restarts <- computeRestarts(cond)
[10:25:46.735]                           for (restart in restarts) {
[10:25:46.735]                             name <- restart$name
[10:25:46.735]                             if (is.null(name)) 
[10:25:46.735]                               next
[10:25:46.735]                             if (!grepl(pattern, name)) 
[10:25:46.735]                               next
[10:25:46.735]                             invokeRestart(restart)
[10:25:46.735]                             muffled <- TRUE
[10:25:46.735]                             break
[10:25:46.735]                           }
[10:25:46.735]                         }
[10:25:46.735]                       }
[10:25:46.735]                       invisible(muffled)
[10:25:46.735]                     }
[10:25:46.735]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.735]                   }
[10:25:46.735]                 }
[10:25:46.735]             }
[10:25:46.735]         }))
[10:25:46.735]     }, error = function(ex) {
[10:25:46.735]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.735]                 ...future.rng), started = ...future.startTime, 
[10:25:46.735]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.735]             version = "1.8"), class = "FutureResult")
[10:25:46.735]     }, finally = {
[10:25:46.735]         if (!identical(...future.workdir, getwd())) 
[10:25:46.735]             setwd(...future.workdir)
[10:25:46.735]         {
[10:25:46.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.735]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.735]             }
[10:25:46.735]             base::options(...future.oldOptions)
[10:25:46.735]             if (.Platform$OS.type == "windows") {
[10:25:46.735]                 old_names <- names(...future.oldEnvVars)
[10:25:46.735]                 envs <- base::Sys.getenv()
[10:25:46.735]                 names <- names(envs)
[10:25:46.735]                 common <- intersect(names, old_names)
[10:25:46.735]                 added <- setdiff(names, old_names)
[10:25:46.735]                 removed <- setdiff(old_names, names)
[10:25:46.735]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.735]                   envs[common]]
[10:25:46.735]                 NAMES <- toupper(changed)
[10:25:46.735]                 args <- list()
[10:25:46.735]                 for (kk in seq_along(NAMES)) {
[10:25:46.735]                   name <- changed[[kk]]
[10:25:46.735]                   NAME <- NAMES[[kk]]
[10:25:46.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.735]                     next
[10:25:46.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.735]                 }
[10:25:46.735]                 NAMES <- toupper(added)
[10:25:46.735]                 for (kk in seq_along(NAMES)) {
[10:25:46.735]                   name <- added[[kk]]
[10:25:46.735]                   NAME <- NAMES[[kk]]
[10:25:46.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.735]                     next
[10:25:46.735]                   args[[name]] <- ""
[10:25:46.735]                 }
[10:25:46.735]                 NAMES <- toupper(removed)
[10:25:46.735]                 for (kk in seq_along(NAMES)) {
[10:25:46.735]                   name <- removed[[kk]]
[10:25:46.735]                   NAME <- NAMES[[kk]]
[10:25:46.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.735]                     next
[10:25:46.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.735]                 }
[10:25:46.735]                 if (length(args) > 0) 
[10:25:46.735]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.735]             }
[10:25:46.735]             else {
[10:25:46.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.735]             }
[10:25:46.735]             {
[10:25:46.735]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.735]                   0L) {
[10:25:46.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.735]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.735]                   base::options(opts)
[10:25:46.735]                 }
[10:25:46.735]                 {
[10:25:46.735]                   {
[10:25:46.735]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.735]                     NULL
[10:25:46.735]                   }
[10:25:46.735]                   options(future.plan = NULL)
[10:25:46.735]                   if (is.na(NA_character_)) 
[10:25:46.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.735]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.735]                     envir = parent.frame()) 
[10:25:46.735]                   {
[10:25:46.735]                     default_workers <- missing(workers)
[10:25:46.735]                     if (is.function(workers)) 
[10:25:46.735]                       workers <- workers()
[10:25:46.735]                     workers <- structure(as.integer(workers), 
[10:25:46.735]                       class = class(workers))
[10:25:46.735]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.735]                       1L)
[10:25:46.735]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.735]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.735]                       if (default_workers) 
[10:25:46.735]                         supportsMulticore(warn = TRUE)
[10:25:46.735]                       return(sequential(..., envir = envir))
[10:25:46.735]                     }
[10:25:46.735]                     oopts <- options(mc.cores = workers)
[10:25:46.735]                     on.exit(options(oopts))
[10:25:46.735]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.735]                       envir = envir)
[10:25:46.735]                     if (!future$lazy) 
[10:25:46.735]                       future <- run(future)
[10:25:46.735]                     invisible(future)
[10:25:46.735]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.735]                 }
[10:25:46.735]             }
[10:25:46.735]         }
[10:25:46.735]     })
[10:25:46.735]     if (TRUE) {
[10:25:46.735]         base::sink(type = "output", split = FALSE)
[10:25:46.735]         if (TRUE) {
[10:25:46.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.735]         }
[10:25:46.735]         else {
[10:25:46.735]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.735]         }
[10:25:46.735]         base::close(...future.stdout)
[10:25:46.735]         ...future.stdout <- NULL
[10:25:46.735]     }
[10:25:46.735]     ...future.result$conditions <- ...future.conditions
[10:25:46.735]     ...future.result$finished <- base::Sys.time()
[10:25:46.735]     ...future.result
[10:25:46.735] }
[10:25:46.739] requestCore(): workers = 2
[10:25:46.741] MulticoreFuture started
[10:25:46.742] - Launch lazy future ... done
[10:25:46.742] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[10:25:46.743] plan(): Setting new future strategy stack:
[10:25:46.743] List of future strategies:
[10:25:46.743] 1. sequential:
[10:25:46.743]    - args: function (..., envir = parent.frame())
[10:25:46.743]    - tweaked: FALSE
[10:25:46.743]    - call: NULL
 num 1
 $ b:[10:25:46.744] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f526f790> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f3c4b088> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:25:46.746] plan(): Setting new future strategy stack:
List of 6
 $ a:[10:25:46.746] List of future strategies:
[10:25:46.746] 1. multicore:
[10:25:46.746]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.746]    - tweaked: FALSE
[10:25:46.746]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f526f790> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f3c4b088> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:25:46.751] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:46.753] resolve() on list ...
[10:25:46.754]  recursive: 0
[10:25:46.754]  length: 6
[10:25:46.754]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:46.754] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.754] - nx: 6
[10:25:46.754] - relay: TRUE
[10:25:46.755] - stdout: TRUE
[10:25:46.755] - signal: TRUE
[10:25:46.755] - resignal: FALSE
[10:25:46.755] - force: TRUE
[10:25:46.755] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.755] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.755]  - until=2
[10:25:46.756]  - relaying element #2
[10:25:46.756] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.756] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.756] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.756]  length: 5 (resolved future 1)
[10:25:46.756] Future #2
[10:25:46.757] result() for MulticoreFuture ...
[10:25:46.758] result() for MulticoreFuture ...
[10:25:46.758] result() for MulticoreFuture ... done
[10:25:46.758] result() for MulticoreFuture ... done
[10:25:46.758] result() for MulticoreFuture ...
[10:25:46.758] result() for MulticoreFuture ... done
[10:25:46.758] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:46.758] - nx: 6
[10:25:46.759] - relay: TRUE
[10:25:46.759] - stdout: TRUE
[10:25:46.759] - signal: TRUE
[10:25:46.759] - resignal: FALSE
[10:25:46.759] - force: TRUE
[10:25:46.759] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.759] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.759]  - until=2
[10:25:46.760]  - relaying element #2
[10:25:46.760] result() for MulticoreFuture ...
[10:25:46.764] result() for MulticoreFuture ... done
[10:25:46.764] result() for MulticoreFuture ...
[10:25:46.764] result() for MulticoreFuture ... done
[10:25:46.764] result() for MulticoreFuture ...
[10:25:46.765] result() for MulticoreFuture ... done
[10:25:46.765] result() for MulticoreFuture ...
[10:25:46.765] result() for MulticoreFuture ... done
[10:25:46.765] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.766] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.766] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:46.766]  length: 4 (resolved future 2)
[10:25:46.767] Future #3
[10:25:46.767] result() for MulticoreFuture ...
[10:25:46.768] result() for MulticoreFuture ...
[10:25:46.768] result() for MulticoreFuture ... done
[10:25:46.768] result() for MulticoreFuture ... done
[10:25:46.768] result() for MulticoreFuture ...
[10:25:46.768] result() for MulticoreFuture ... done
[10:25:46.768] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:46.769] - nx: 6
[10:25:46.769] - relay: TRUE
[10:25:46.769] - stdout: TRUE
[10:25:46.769] - signal: TRUE
[10:25:46.769] - resignal: FALSE
[10:25:46.769] - force: TRUE
[10:25:46.769] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.769] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.770]  - until=3
[10:25:46.770]  - relaying element #3
[10:25:46.770] result() for MulticoreFuture ...
[10:25:46.770] result() for MulticoreFuture ... done
[10:25:46.770] result() for MulticoreFuture ...
[10:25:46.770] result() for MulticoreFuture ... done
[10:25:46.770] result() for MulticoreFuture ...
[10:25:46.771] result() for MulticoreFuture ... done
[10:25:46.771] result() for MulticoreFuture ...
[10:25:46.771] result() for MulticoreFuture ... done
[10:25:46.771] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.771] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.771] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:46.771]  length: 3 (resolved future 3)
[10:25:46.771] signalConditionsASAP(NULL, pos=4) ...
[10:25:46.771] - nx: 6
[10:25:46.772] - relay: TRUE
[10:25:46.772] - stdout: TRUE
[10:25:46.772] - signal: TRUE
[10:25:46.772] - resignal: FALSE
[10:25:46.772] - force: TRUE
[10:25:46.772] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.772] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.772]  - until=5
[10:25:46.772]  - relaying element #5
[10:25:46.773] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.773] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.773] signalConditionsASAP(NULL, pos=4) ... done
[10:25:46.773]  length: 2 (resolved future 4)
[10:25:46.773] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.773] - nx: 6
[10:25:46.773] - relay: TRUE
[10:25:46.773] - stdout: TRUE
[10:25:46.773] - signal: TRUE
[10:25:46.774] - resignal: FALSE
[10:25:46.774] - force: TRUE
[10:25:46.774] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.774] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.774]  - until=6
[10:25:46.774]  - relaying element #6
[10:25:46.774] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.774] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.774] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.774]  length: 1 (resolved future 5)
[10:25:46.775] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.775] - nx: 6
[10:25:46.775] - relay: TRUE
[10:25:46.775] - stdout: TRUE
[10:25:46.775] - signal: TRUE
[10:25:46.775] - resignal: FALSE
[10:25:46.775] - force: TRUE
[10:25:46.775] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.775] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.775]  - until=6
[10:25:46.775] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.776] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.776] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.776]  length: 0 (resolved future 6)
[10:25:46.776] Relaying remaining futures
[10:25:46.776] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.776] - nx: 6
[10:25:46.776] - relay: TRUE
[10:25:46.776] - stdout: TRUE
[10:25:46.776] - signal: TRUE
[10:25:46.776] - resignal: FALSE
[10:25:46.777] - force: TRUE
[10:25:46.777] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.777] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:46.777] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.777] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.777] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.777] resolve() on list ... DONE
[10:25:46.777] result() for MulticoreFuture ...
[10:25:46.777] result() for MulticoreFuture ... done
[10:25:46.778] result() for MulticoreFuture ...
[10:25:46.778] result() for MulticoreFuture ... done
[10:25:46.778] result() for MulticoreFuture ...
[10:25:46.778] result() for MulticoreFuture ... done
[10:25:46.778] result() for MulticoreFuture ...
[10:25:46.778] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:25:46.781] getGlobalsAndPackages() ...
[10:25:46.781] Searching for globals...
[10:25:46.782] 
[10:25:46.782] Searching for globals ... DONE
[10:25:46.782] - globals: [0] <none>
[10:25:46.782] getGlobalsAndPackages() ... DONE
[10:25:46.782] run() for ‘Future’ ...
[10:25:46.782] - state: ‘created’
[10:25:46.783] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.786] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.786]   - Field: ‘label’
[10:25:46.787]   - Field: ‘local’
[10:25:46.787]   - Field: ‘owner’
[10:25:46.787]   - Field: ‘envir’
[10:25:46.787]   - Field: ‘workers’
[10:25:46.787]   - Field: ‘packages’
[10:25:46.787]   - Field: ‘gc’
[10:25:46.787]   - Field: ‘job’
[10:25:46.787]   - Field: ‘conditions’
[10:25:46.787]   - Field: ‘expr’
[10:25:46.787]   - Field: ‘uuid’
[10:25:46.787]   - Field: ‘seed’
[10:25:46.788]   - Field: ‘version’
[10:25:46.788]   - Field: ‘result’
[10:25:46.788]   - Field: ‘asynchronous’
[10:25:46.788]   - Field: ‘calls’
[10:25:46.788]   - Field: ‘globals’
[10:25:46.788]   - Field: ‘stdout’
[10:25:46.788]   - Field: ‘earlySignal’
[10:25:46.788]   - Field: ‘lazy’
[10:25:46.788]   - Field: ‘state’
[10:25:46.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.788] - Launch lazy future ...
[10:25:46.789] Packages needed by the future expression (n = 0): <none>
[10:25:46.789] Packages needed by future strategies (n = 0): <none>
[10:25:46.789] {
[10:25:46.789]     {
[10:25:46.789]         {
[10:25:46.789]             ...future.startTime <- base::Sys.time()
[10:25:46.789]             {
[10:25:46.789]                 {
[10:25:46.789]                   {
[10:25:46.789]                     {
[10:25:46.789]                       base::local({
[10:25:46.789]                         has_future <- base::requireNamespace("future", 
[10:25:46.789]                           quietly = TRUE)
[10:25:46.789]                         if (has_future) {
[10:25:46.789]                           ns <- base::getNamespace("future")
[10:25:46.789]                           version <- ns[[".package"]][["version"]]
[10:25:46.789]                           if (is.null(version)) 
[10:25:46.789]                             version <- utils::packageVersion("future")
[10:25:46.789]                         }
[10:25:46.789]                         else {
[10:25:46.789]                           version <- NULL
[10:25:46.789]                         }
[10:25:46.789]                         if (!has_future || version < "1.8.0") {
[10:25:46.789]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.789]                             "", base::R.version$version.string), 
[10:25:46.789]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.789]                               "release", "version")], collapse = " "), 
[10:25:46.789]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.789]                             info)
[10:25:46.789]                           info <- base::paste(info, collapse = "; ")
[10:25:46.789]                           if (!has_future) {
[10:25:46.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.789]                               info)
[10:25:46.789]                           }
[10:25:46.789]                           else {
[10:25:46.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.789]                               info, version)
[10:25:46.789]                           }
[10:25:46.789]                           base::stop(msg)
[10:25:46.789]                         }
[10:25:46.789]                       })
[10:25:46.789]                     }
[10:25:46.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.789]                     base::options(mc.cores = 1L)
[10:25:46.789]                   }
[10:25:46.789]                   options(future.plan = NULL)
[10:25:46.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.789]                 }
[10:25:46.789]                 ...future.workdir <- getwd()
[10:25:46.789]             }
[10:25:46.789]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.789]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.789]         }
[10:25:46.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.789]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.789]             base::names(...future.oldOptions))
[10:25:46.789]     }
[10:25:46.789]     if (FALSE) {
[10:25:46.789]     }
[10:25:46.789]     else {
[10:25:46.789]         if (TRUE) {
[10:25:46.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.789]                 open = "w")
[10:25:46.789]         }
[10:25:46.789]         else {
[10:25:46.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.789]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.789]         }
[10:25:46.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.789]             base::sink(type = "output", split = FALSE)
[10:25:46.789]             base::close(...future.stdout)
[10:25:46.789]         }, add = TRUE)
[10:25:46.789]     }
[10:25:46.789]     ...future.frame <- base::sys.nframe()
[10:25:46.789]     ...future.conditions <- base::list()
[10:25:46.789]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.789]     if (FALSE) {
[10:25:46.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.789]     }
[10:25:46.789]     ...future.result <- base::tryCatch({
[10:25:46.789]         base::withCallingHandlers({
[10:25:46.789]             ...future.value <- base::withVisible(base::local({
[10:25:46.789]                 withCallingHandlers({
[10:25:46.789]                   2
[10:25:46.789]                 }, immediateCondition = function(cond) {
[10:25:46.789]                   save_rds <- function (object, pathname, ...) 
[10:25:46.789]                   {
[10:25:46.789]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.789]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.789]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.789]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.789]                         fi_tmp[["mtime"]])
[10:25:46.789]                     }
[10:25:46.789]                     tryCatch({
[10:25:46.789]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.789]                     }, error = function(ex) {
[10:25:46.789]                       msg <- conditionMessage(ex)
[10:25:46.789]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.789]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.789]                         fi_tmp[["mtime"]], msg)
[10:25:46.789]                       ex$message <- msg
[10:25:46.789]                       stop(ex)
[10:25:46.789]                     })
[10:25:46.789]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.789]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.789]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.789]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.789]                       fi <- file.info(pathname)
[10:25:46.789]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.789]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.789]                         fi[["size"]], fi[["mtime"]])
[10:25:46.789]                       stop(msg)
[10:25:46.789]                     }
[10:25:46.789]                     invisible(pathname)
[10:25:46.789]                   }
[10:25:46.789]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.789]                     rootPath = tempdir()) 
[10:25:46.789]                   {
[10:25:46.789]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.789]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.789]                       tmpdir = path, fileext = ".rds")
[10:25:46.789]                     save_rds(obj, file)
[10:25:46.789]                   }
[10:25:46.789]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.789]                   {
[10:25:46.789]                     inherits <- base::inherits
[10:25:46.789]                     invokeRestart <- base::invokeRestart
[10:25:46.789]                     is.null <- base::is.null
[10:25:46.789]                     muffled <- FALSE
[10:25:46.789]                     if (inherits(cond, "message")) {
[10:25:46.789]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.789]                       if (muffled) 
[10:25:46.789]                         invokeRestart("muffleMessage")
[10:25:46.789]                     }
[10:25:46.789]                     else if (inherits(cond, "warning")) {
[10:25:46.789]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.789]                       if (muffled) 
[10:25:46.789]                         invokeRestart("muffleWarning")
[10:25:46.789]                     }
[10:25:46.789]                     else if (inherits(cond, "condition")) {
[10:25:46.789]                       if (!is.null(pattern)) {
[10:25:46.789]                         computeRestarts <- base::computeRestarts
[10:25:46.789]                         grepl <- base::grepl
[10:25:46.789]                         restarts <- computeRestarts(cond)
[10:25:46.789]                         for (restart in restarts) {
[10:25:46.789]                           name <- restart$name
[10:25:46.789]                           if (is.null(name)) 
[10:25:46.789]                             next
[10:25:46.789]                           if (!grepl(pattern, name)) 
[10:25:46.789]                             next
[10:25:46.789]                           invokeRestart(restart)
[10:25:46.789]                           muffled <- TRUE
[10:25:46.789]                           break
[10:25:46.789]                         }
[10:25:46.789]                       }
[10:25:46.789]                     }
[10:25:46.789]                     invisible(muffled)
[10:25:46.789]                   }
[10:25:46.789]                   muffleCondition(cond)
[10:25:46.789]                 })
[10:25:46.789]             }))
[10:25:46.789]             future::FutureResult(value = ...future.value$value, 
[10:25:46.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.789]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.789]                     ...future.globalenv.names))
[10:25:46.789]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.789]         }, condition = base::local({
[10:25:46.789]             c <- base::c
[10:25:46.789]             inherits <- base::inherits
[10:25:46.789]             invokeRestart <- base::invokeRestart
[10:25:46.789]             length <- base::length
[10:25:46.789]             list <- base::list
[10:25:46.789]             seq.int <- base::seq.int
[10:25:46.789]             signalCondition <- base::signalCondition
[10:25:46.789]             sys.calls <- base::sys.calls
[10:25:46.789]             `[[` <- base::`[[`
[10:25:46.789]             `+` <- base::`+`
[10:25:46.789]             `<<-` <- base::`<<-`
[10:25:46.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.789]                   3L)]
[10:25:46.789]             }
[10:25:46.789]             function(cond) {
[10:25:46.789]                 is_error <- inherits(cond, "error")
[10:25:46.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.789]                   NULL)
[10:25:46.789]                 if (is_error) {
[10:25:46.789]                   sessionInformation <- function() {
[10:25:46.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.789]                       search = base::search(), system = base::Sys.info())
[10:25:46.789]                   }
[10:25:46.789]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.789]                     cond$call), session = sessionInformation(), 
[10:25:46.789]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.789]                   signalCondition(cond)
[10:25:46.789]                 }
[10:25:46.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.789]                 "immediateCondition"))) {
[10:25:46.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.789]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.789]                   if (TRUE && !signal) {
[10:25:46.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.789]                     {
[10:25:46.789]                       inherits <- base::inherits
[10:25:46.789]                       invokeRestart <- base::invokeRestart
[10:25:46.789]                       is.null <- base::is.null
[10:25:46.789]                       muffled <- FALSE
[10:25:46.789]                       if (inherits(cond, "message")) {
[10:25:46.789]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.789]                         if (muffled) 
[10:25:46.789]                           invokeRestart("muffleMessage")
[10:25:46.789]                       }
[10:25:46.789]                       else if (inherits(cond, "warning")) {
[10:25:46.789]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.789]                         if (muffled) 
[10:25:46.789]                           invokeRestart("muffleWarning")
[10:25:46.789]                       }
[10:25:46.789]                       else if (inherits(cond, "condition")) {
[10:25:46.789]                         if (!is.null(pattern)) {
[10:25:46.789]                           computeRestarts <- base::computeRestarts
[10:25:46.789]                           grepl <- base::grepl
[10:25:46.789]                           restarts <- computeRestarts(cond)
[10:25:46.789]                           for (restart in restarts) {
[10:25:46.789]                             name <- restart$name
[10:25:46.789]                             if (is.null(name)) 
[10:25:46.789]                               next
[10:25:46.789]                             if (!grepl(pattern, name)) 
[10:25:46.789]                               next
[10:25:46.789]                             invokeRestart(restart)
[10:25:46.789]                             muffled <- TRUE
[10:25:46.789]                             break
[10:25:46.789]                           }
[10:25:46.789]                         }
[10:25:46.789]                       }
[10:25:46.789]                       invisible(muffled)
[10:25:46.789]                     }
[10:25:46.789]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.789]                   }
[10:25:46.789]                 }
[10:25:46.789]                 else {
[10:25:46.789]                   if (TRUE) {
[10:25:46.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.789]                     {
[10:25:46.789]                       inherits <- base::inherits
[10:25:46.789]                       invokeRestart <- base::invokeRestart
[10:25:46.789]                       is.null <- base::is.null
[10:25:46.789]                       muffled <- FALSE
[10:25:46.789]                       if (inherits(cond, "message")) {
[10:25:46.789]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.789]                         if (muffled) 
[10:25:46.789]                           invokeRestart("muffleMessage")
[10:25:46.789]                       }
[10:25:46.789]                       else if (inherits(cond, "warning")) {
[10:25:46.789]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.789]                         if (muffled) 
[10:25:46.789]                           invokeRestart("muffleWarning")
[10:25:46.789]                       }
[10:25:46.789]                       else if (inherits(cond, "condition")) {
[10:25:46.789]                         if (!is.null(pattern)) {
[10:25:46.789]                           computeRestarts <- base::computeRestarts
[10:25:46.789]                           grepl <- base::grepl
[10:25:46.789]                           restarts <- computeRestarts(cond)
[10:25:46.789]                           for (restart in restarts) {
[10:25:46.789]                             name <- restart$name
[10:25:46.789]                             if (is.null(name)) 
[10:25:46.789]                               next
[10:25:46.789]                             if (!grepl(pattern, name)) 
[10:25:46.789]                               next
[10:25:46.789]                             invokeRestart(restart)
[10:25:46.789]                             muffled <- TRUE
[10:25:46.789]                             break
[10:25:46.789]                           }
[10:25:46.789]                         }
[10:25:46.789]                       }
[10:25:46.789]                       invisible(muffled)
[10:25:46.789]                     }
[10:25:46.789]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.789]                   }
[10:25:46.789]                 }
[10:25:46.789]             }
[10:25:46.789]         }))
[10:25:46.789]     }, error = function(ex) {
[10:25:46.789]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.789]                 ...future.rng), started = ...future.startTime, 
[10:25:46.789]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.789]             version = "1.8"), class = "FutureResult")
[10:25:46.789]     }, finally = {
[10:25:46.789]         if (!identical(...future.workdir, getwd())) 
[10:25:46.789]             setwd(...future.workdir)
[10:25:46.789]         {
[10:25:46.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.789]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.789]             }
[10:25:46.789]             base::options(...future.oldOptions)
[10:25:46.789]             if (.Platform$OS.type == "windows") {
[10:25:46.789]                 old_names <- names(...future.oldEnvVars)
[10:25:46.789]                 envs <- base::Sys.getenv()
[10:25:46.789]                 names <- names(envs)
[10:25:46.789]                 common <- intersect(names, old_names)
[10:25:46.789]                 added <- setdiff(names, old_names)
[10:25:46.789]                 removed <- setdiff(old_names, names)
[10:25:46.789]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.789]                   envs[common]]
[10:25:46.789]                 NAMES <- toupper(changed)
[10:25:46.789]                 args <- list()
[10:25:46.789]                 for (kk in seq_along(NAMES)) {
[10:25:46.789]                   name <- changed[[kk]]
[10:25:46.789]                   NAME <- NAMES[[kk]]
[10:25:46.789]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.789]                     next
[10:25:46.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.789]                 }
[10:25:46.789]                 NAMES <- toupper(added)
[10:25:46.789]                 for (kk in seq_along(NAMES)) {
[10:25:46.789]                   name <- added[[kk]]
[10:25:46.789]                   NAME <- NAMES[[kk]]
[10:25:46.789]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.789]                     next
[10:25:46.789]                   args[[name]] <- ""
[10:25:46.789]                 }
[10:25:46.789]                 NAMES <- toupper(removed)
[10:25:46.789]                 for (kk in seq_along(NAMES)) {
[10:25:46.789]                   name <- removed[[kk]]
[10:25:46.789]                   NAME <- NAMES[[kk]]
[10:25:46.789]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.789]                     next
[10:25:46.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.789]                 }
[10:25:46.789]                 if (length(args) > 0) 
[10:25:46.789]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.789]             }
[10:25:46.789]             else {
[10:25:46.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.789]             }
[10:25:46.789]             {
[10:25:46.789]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.789]                   0L) {
[10:25:46.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.789]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.789]                   base::options(opts)
[10:25:46.789]                 }
[10:25:46.789]                 {
[10:25:46.789]                   {
[10:25:46.789]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.789]                     NULL
[10:25:46.789]                   }
[10:25:46.789]                   options(future.plan = NULL)
[10:25:46.789]                   if (is.na(NA_character_)) 
[10:25:46.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.789]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.789]                     envir = parent.frame()) 
[10:25:46.789]                   {
[10:25:46.789]                     default_workers <- missing(workers)
[10:25:46.789]                     if (is.function(workers)) 
[10:25:46.789]                       workers <- workers()
[10:25:46.789]                     workers <- structure(as.integer(workers), 
[10:25:46.789]                       class = class(workers))
[10:25:46.789]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.789]                       1L)
[10:25:46.789]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.789]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.789]                       if (default_workers) 
[10:25:46.789]                         supportsMulticore(warn = TRUE)
[10:25:46.789]                       return(sequential(..., envir = envir))
[10:25:46.789]                     }
[10:25:46.789]                     oopts <- options(mc.cores = workers)
[10:25:46.789]                     on.exit(options(oopts))
[10:25:46.789]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.789]                       envir = envir)
[10:25:46.789]                     if (!future$lazy) 
[10:25:46.789]                       future <- run(future)
[10:25:46.789]                     invisible(future)
[10:25:46.789]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.789]                 }
[10:25:46.789]             }
[10:25:46.789]         }
[10:25:46.789]     })
[10:25:46.789]     if (TRUE) {
[10:25:46.789]         base::sink(type = "output", split = FALSE)
[10:25:46.789]         if (TRUE) {
[10:25:46.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.789]         }
[10:25:46.789]         else {
[10:25:46.789]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.789]         }
[10:25:46.789]         base::close(...future.stdout)
[10:25:46.789]         ...future.stdout <- NULL
[10:25:46.789]     }
[10:25:46.789]     ...future.result$conditions <- ...future.conditions
[10:25:46.789]     ...future.result$finished <- base::Sys.time()
[10:25:46.789]     ...future.result
[10:25:46.789] }
[10:25:46.792] requestCore(): workers = 2
[10:25:46.793] MulticoreFuture started
[10:25:46.794] - Launch lazy future ... done
[10:25:46.794] run() for ‘MulticoreFuture’ ... done
[10:25:46.794] getGlobalsAndPackages() ...
[10:25:46.795] Searching for globals...
[10:25:46.795] plan(): Setting new future strategy stack:
[10:25:46.795] 
[10:25:46.795] List of future strategies:
[10:25:46.795] 1. sequential:
[10:25:46.795]    - args: function (..., envir = parent.frame())
[10:25:46.795]    - tweaked: FALSE
[10:25:46.795]    - call: NULL
[10:25:46.796] Searching for globals ... DONE
[10:25:46.796] - globals: [0] <none>
[10:25:46.796] plan(): nbrOfWorkers() = 1
[10:25:46.796] getGlobalsAndPackages() ... DONE
[10:25:46.796] run() for ‘Future’ ...
[10:25:46.797] - state: ‘created’
[10:25:46.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.798] plan(): Setting new future strategy stack:
[10:25:46.798] List of future strategies:
[10:25:46.798] 1. multicore:
[10:25:46.798]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.798]    - tweaked: FALSE
[10:25:46.798]    - call: plan(strategy)
[10:25:46.802] plan(): nbrOfWorkers() = 2
[10:25:46.802] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.806]   - Field: ‘label’
[10:25:46.806]   - Field: ‘local’
[10:25:46.807]   - Field: ‘owner’
[10:25:46.807]   - Field: ‘envir’
[10:25:46.807]   - Field: ‘workers’
[10:25:46.808]   - Field: ‘packages’
[10:25:46.808]   - Field: ‘gc’
[10:25:46.808]   - Field: ‘job’
[10:25:46.809]   - Field: ‘conditions’
[10:25:46.809]   - Field: ‘expr’
[10:25:46.809]   - Field: ‘uuid’
[10:25:46.810]   - Field: ‘seed’
[10:25:46.810]   - Field: ‘version’
[10:25:46.810]   - Field: ‘result’
[10:25:46.810]   - Field: ‘asynchronous’
[10:25:46.810]   - Field: ‘calls’
[10:25:46.811]   - Field: ‘globals’
[10:25:46.811]   - Field: ‘stdout’
[10:25:46.811]   - Field: ‘earlySignal’
[10:25:46.811]   - Field: ‘lazy’
[10:25:46.811]   - Field: ‘state’
[10:25:46.812] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.812] - Launch lazy future ...
[10:25:46.812] Packages needed by the future expression (n = 0): <none>
[10:25:46.812] Packages needed by future strategies (n = 0): <none>
[10:25:46.813] {
[10:25:46.813]     {
[10:25:46.813]         {
[10:25:46.813]             ...future.startTime <- base::Sys.time()
[10:25:46.813]             {
[10:25:46.813]                 {
[10:25:46.813]                   {
[10:25:46.813]                     {
[10:25:46.813]                       base::local({
[10:25:46.813]                         has_future <- base::requireNamespace("future", 
[10:25:46.813]                           quietly = TRUE)
[10:25:46.813]                         if (has_future) {
[10:25:46.813]                           ns <- base::getNamespace("future")
[10:25:46.813]                           version <- ns[[".package"]][["version"]]
[10:25:46.813]                           if (is.null(version)) 
[10:25:46.813]                             version <- utils::packageVersion("future")
[10:25:46.813]                         }
[10:25:46.813]                         else {
[10:25:46.813]                           version <- NULL
[10:25:46.813]                         }
[10:25:46.813]                         if (!has_future || version < "1.8.0") {
[10:25:46.813]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.813]                             "", base::R.version$version.string), 
[10:25:46.813]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.813]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.813]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.813]                               "release", "version")], collapse = " "), 
[10:25:46.813]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.813]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.813]                             info)
[10:25:46.813]                           info <- base::paste(info, collapse = "; ")
[10:25:46.813]                           if (!has_future) {
[10:25:46.813]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.813]                               info)
[10:25:46.813]                           }
[10:25:46.813]                           else {
[10:25:46.813]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.813]                               info, version)
[10:25:46.813]                           }
[10:25:46.813]                           base::stop(msg)
[10:25:46.813]                         }
[10:25:46.813]                       })
[10:25:46.813]                     }
[10:25:46.813]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.813]                     base::options(mc.cores = 1L)
[10:25:46.813]                   }
[10:25:46.813]                   options(future.plan = NULL)
[10:25:46.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.813]                 }
[10:25:46.813]                 ...future.workdir <- getwd()
[10:25:46.813]             }
[10:25:46.813]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.813]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.813]         }
[10:25:46.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.813]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.813]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.813]             base::names(...future.oldOptions))
[10:25:46.813]     }
[10:25:46.813]     if (FALSE) {
[10:25:46.813]     }
[10:25:46.813]     else {
[10:25:46.813]         if (TRUE) {
[10:25:46.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.813]                 open = "w")
[10:25:46.813]         }
[10:25:46.813]         else {
[10:25:46.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.813]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.813]         }
[10:25:46.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.813]             base::sink(type = "output", split = FALSE)
[10:25:46.813]             base::close(...future.stdout)
[10:25:46.813]         }, add = TRUE)
[10:25:46.813]     }
[10:25:46.813]     ...future.frame <- base::sys.nframe()
[10:25:46.813]     ...future.conditions <- base::list()
[10:25:46.813]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.813]     if (FALSE) {
[10:25:46.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.813]     }
[10:25:46.813]     ...future.result <- base::tryCatch({
[10:25:46.813]         base::withCallingHandlers({
[10:25:46.813]             ...future.value <- base::withVisible(base::local({
[10:25:46.813]                 withCallingHandlers({
[10:25:46.813]                   NULL
[10:25:46.813]                 }, immediateCondition = function(cond) {
[10:25:46.813]                   save_rds <- function (object, pathname, ...) 
[10:25:46.813]                   {
[10:25:46.813]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.813]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.813]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.813]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.813]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.813]                         fi_tmp[["mtime"]])
[10:25:46.813]                     }
[10:25:46.813]                     tryCatch({
[10:25:46.813]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.813]                     }, error = function(ex) {
[10:25:46.813]                       msg <- conditionMessage(ex)
[10:25:46.813]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.813]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.813]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.813]                         fi_tmp[["mtime"]], msg)
[10:25:46.813]                       ex$message <- msg
[10:25:46.813]                       stop(ex)
[10:25:46.813]                     })
[10:25:46.813]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.813]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.813]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.813]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.813]                       fi <- file.info(pathname)
[10:25:46.813]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.813]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.813]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.813]                         fi[["size"]], fi[["mtime"]])
[10:25:46.813]                       stop(msg)
[10:25:46.813]                     }
[10:25:46.813]                     invisible(pathname)
[10:25:46.813]                   }
[10:25:46.813]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.813]                     rootPath = tempdir()) 
[10:25:46.813]                   {
[10:25:46.813]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.813]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.813]                       tmpdir = path, fileext = ".rds")
[10:25:46.813]                     save_rds(obj, file)
[10:25:46.813]                   }
[10:25:46.813]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.813]                   {
[10:25:46.813]                     inherits <- base::inherits
[10:25:46.813]                     invokeRestart <- base::invokeRestart
[10:25:46.813]                     is.null <- base::is.null
[10:25:46.813]                     muffled <- FALSE
[10:25:46.813]                     if (inherits(cond, "message")) {
[10:25:46.813]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.813]                       if (muffled) 
[10:25:46.813]                         invokeRestart("muffleMessage")
[10:25:46.813]                     }
[10:25:46.813]                     else if (inherits(cond, "warning")) {
[10:25:46.813]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.813]                       if (muffled) 
[10:25:46.813]                         invokeRestart("muffleWarning")
[10:25:46.813]                     }
[10:25:46.813]                     else if (inherits(cond, "condition")) {
[10:25:46.813]                       if (!is.null(pattern)) {
[10:25:46.813]                         computeRestarts <- base::computeRestarts
[10:25:46.813]                         grepl <- base::grepl
[10:25:46.813]                         restarts <- computeRestarts(cond)
[10:25:46.813]                         for (restart in restarts) {
[10:25:46.813]                           name <- restart$name
[10:25:46.813]                           if (is.null(name)) 
[10:25:46.813]                             next
[10:25:46.813]                           if (!grepl(pattern, name)) 
[10:25:46.813]                             next
[10:25:46.813]                           invokeRestart(restart)
[10:25:46.813]                           muffled <- TRUE
[10:25:46.813]                           break
[10:25:46.813]                         }
[10:25:46.813]                       }
[10:25:46.813]                     }
[10:25:46.813]                     invisible(muffled)
[10:25:46.813]                   }
[10:25:46.813]                   muffleCondition(cond)
[10:25:46.813]                 })
[10:25:46.813]             }))
[10:25:46.813]             future::FutureResult(value = ...future.value$value, 
[10:25:46.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.813]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.813]                     ...future.globalenv.names))
[10:25:46.813]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.813]         }, condition = base::local({
[10:25:46.813]             c <- base::c
[10:25:46.813]             inherits <- base::inherits
[10:25:46.813]             invokeRestart <- base::invokeRestart
[10:25:46.813]             length <- base::length
[10:25:46.813]             list <- base::list
[10:25:46.813]             seq.int <- base::seq.int
[10:25:46.813]             signalCondition <- base::signalCondition
[10:25:46.813]             sys.calls <- base::sys.calls
[10:25:46.813]             `[[` <- base::`[[`
[10:25:46.813]             `+` <- base::`+`
[10:25:46.813]             `<<-` <- base::`<<-`
[10:25:46.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.813]                   3L)]
[10:25:46.813]             }
[10:25:46.813]             function(cond) {
[10:25:46.813]                 is_error <- inherits(cond, "error")
[10:25:46.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.813]                   NULL)
[10:25:46.813]                 if (is_error) {
[10:25:46.813]                   sessionInformation <- function() {
[10:25:46.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.813]                       search = base::search(), system = base::Sys.info())
[10:25:46.813]                   }
[10:25:46.813]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.813]                     cond$call), session = sessionInformation(), 
[10:25:46.813]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.813]                   signalCondition(cond)
[10:25:46.813]                 }
[10:25:46.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.813]                 "immediateCondition"))) {
[10:25:46.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.813]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.813]                   if (TRUE && !signal) {
[10:25:46.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.813]                     {
[10:25:46.813]                       inherits <- base::inherits
[10:25:46.813]                       invokeRestart <- base::invokeRestart
[10:25:46.813]                       is.null <- base::is.null
[10:25:46.813]                       muffled <- FALSE
[10:25:46.813]                       if (inherits(cond, "message")) {
[10:25:46.813]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.813]                         if (muffled) 
[10:25:46.813]                           invokeRestart("muffleMessage")
[10:25:46.813]                       }
[10:25:46.813]                       else if (inherits(cond, "warning")) {
[10:25:46.813]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.813]                         if (muffled) 
[10:25:46.813]                           invokeRestart("muffleWarning")
[10:25:46.813]                       }
[10:25:46.813]                       else if (inherits(cond, "condition")) {
[10:25:46.813]                         if (!is.null(pattern)) {
[10:25:46.813]                           computeRestarts <- base::computeRestarts
[10:25:46.813]                           grepl <- base::grepl
[10:25:46.813]                           restarts <- computeRestarts(cond)
[10:25:46.813]                           for (restart in restarts) {
[10:25:46.813]                             name <- restart$name
[10:25:46.813]                             if (is.null(name)) 
[10:25:46.813]                               next
[10:25:46.813]                             if (!grepl(pattern, name)) 
[10:25:46.813]                               next
[10:25:46.813]                             invokeRestart(restart)
[10:25:46.813]                             muffled <- TRUE
[10:25:46.813]                             break
[10:25:46.813]                           }
[10:25:46.813]                         }
[10:25:46.813]                       }
[10:25:46.813]                       invisible(muffled)
[10:25:46.813]                     }
[10:25:46.813]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.813]                   }
[10:25:46.813]                 }
[10:25:46.813]                 else {
[10:25:46.813]                   if (TRUE) {
[10:25:46.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.813]                     {
[10:25:46.813]                       inherits <- base::inherits
[10:25:46.813]                       invokeRestart <- base::invokeRestart
[10:25:46.813]                       is.null <- base::is.null
[10:25:46.813]                       muffled <- FALSE
[10:25:46.813]                       if (inherits(cond, "message")) {
[10:25:46.813]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.813]                         if (muffled) 
[10:25:46.813]                           invokeRestart("muffleMessage")
[10:25:46.813]                       }
[10:25:46.813]                       else if (inherits(cond, "warning")) {
[10:25:46.813]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.813]                         if (muffled) 
[10:25:46.813]                           invokeRestart("muffleWarning")
[10:25:46.813]                       }
[10:25:46.813]                       else if (inherits(cond, "condition")) {
[10:25:46.813]                         if (!is.null(pattern)) {
[10:25:46.813]                           computeRestarts <- base::computeRestarts
[10:25:46.813]                           grepl <- base::grepl
[10:25:46.813]                           restarts <- computeRestarts(cond)
[10:25:46.813]                           for (restart in restarts) {
[10:25:46.813]                             name <- restart$name
[10:25:46.813]                             if (is.null(name)) 
[10:25:46.813]                               next
[10:25:46.813]                             if (!grepl(pattern, name)) 
[10:25:46.813]                               next
[10:25:46.813]                             invokeRestart(restart)
[10:25:46.813]                             muffled <- TRUE
[10:25:46.813]                             break
[10:25:46.813]                           }
[10:25:46.813]                         }
[10:25:46.813]                       }
[10:25:46.813]                       invisible(muffled)
[10:25:46.813]                     }
[10:25:46.813]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.813]                   }
[10:25:46.813]                 }
[10:25:46.813]             }
[10:25:46.813]         }))
[10:25:46.813]     }, error = function(ex) {
[10:25:46.813]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.813]                 ...future.rng), started = ...future.startTime, 
[10:25:46.813]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.813]             version = "1.8"), class = "FutureResult")
[10:25:46.813]     }, finally = {
[10:25:46.813]         if (!identical(...future.workdir, getwd())) 
[10:25:46.813]             setwd(...future.workdir)
[10:25:46.813]         {
[10:25:46.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.813]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.813]             }
[10:25:46.813]             base::options(...future.oldOptions)
[10:25:46.813]             if (.Platform$OS.type == "windows") {
[10:25:46.813]                 old_names <- names(...future.oldEnvVars)
[10:25:46.813]                 envs <- base::Sys.getenv()
[10:25:46.813]                 names <- names(envs)
[10:25:46.813]                 common <- intersect(names, old_names)
[10:25:46.813]                 added <- setdiff(names, old_names)
[10:25:46.813]                 removed <- setdiff(old_names, names)
[10:25:46.813]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.813]                   envs[common]]
[10:25:46.813]                 NAMES <- toupper(changed)
[10:25:46.813]                 args <- list()
[10:25:46.813]                 for (kk in seq_along(NAMES)) {
[10:25:46.813]                   name <- changed[[kk]]
[10:25:46.813]                   NAME <- NAMES[[kk]]
[10:25:46.813]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.813]                     next
[10:25:46.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.813]                 }
[10:25:46.813]                 NAMES <- toupper(added)
[10:25:46.813]                 for (kk in seq_along(NAMES)) {
[10:25:46.813]                   name <- added[[kk]]
[10:25:46.813]                   NAME <- NAMES[[kk]]
[10:25:46.813]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.813]                     next
[10:25:46.813]                   args[[name]] <- ""
[10:25:46.813]                 }
[10:25:46.813]                 NAMES <- toupper(removed)
[10:25:46.813]                 for (kk in seq_along(NAMES)) {
[10:25:46.813]                   name <- removed[[kk]]
[10:25:46.813]                   NAME <- NAMES[[kk]]
[10:25:46.813]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.813]                     next
[10:25:46.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.813]                 }
[10:25:46.813]                 if (length(args) > 0) 
[10:25:46.813]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.813]             }
[10:25:46.813]             else {
[10:25:46.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.813]             }
[10:25:46.813]             {
[10:25:46.813]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.813]                   0L) {
[10:25:46.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.813]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.813]                   base::options(opts)
[10:25:46.813]                 }
[10:25:46.813]                 {
[10:25:46.813]                   {
[10:25:46.813]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.813]                     NULL
[10:25:46.813]                   }
[10:25:46.813]                   options(future.plan = NULL)
[10:25:46.813]                   if (is.na(NA_character_)) 
[10:25:46.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.813]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.813]                     envir = parent.frame()) 
[10:25:46.813]                   {
[10:25:46.813]                     default_workers <- missing(workers)
[10:25:46.813]                     if (is.function(workers)) 
[10:25:46.813]                       workers <- workers()
[10:25:46.813]                     workers <- structure(as.integer(workers), 
[10:25:46.813]                       class = class(workers))
[10:25:46.813]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.813]                       1L)
[10:25:46.813]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.813]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.813]                       if (default_workers) 
[10:25:46.813]                         supportsMulticore(warn = TRUE)
[10:25:46.813]                       return(sequential(..., envir = envir))
[10:25:46.813]                     }
[10:25:46.813]                     oopts <- options(mc.cores = workers)
[10:25:46.813]                     on.exit(options(oopts))
[10:25:46.813]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.813]                       envir = envir)
[10:25:46.813]                     if (!future$lazy) 
[10:25:46.813]                       future <- run(future)
[10:25:46.813]                     invisible(future)
[10:25:46.813]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.813]                 }
[10:25:46.813]             }
[10:25:46.813]         }
[10:25:46.813]     })
[10:25:46.813]     if (TRUE) {
[10:25:46.813]         base::sink(type = "output", split = FALSE)
[10:25:46.813]         if (TRUE) {
[10:25:46.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.813]         }
[10:25:46.813]         else {
[10:25:46.813]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.813]         }
[10:25:46.813]         base::close(...future.stdout)
[10:25:46.813]         ...future.stdout <- NULL
[10:25:46.813]     }
[10:25:46.813]     ...future.result$conditions <- ...future.conditions
[10:25:46.813]     ...future.result$finished <- base::Sys.time()
[10:25:46.813]     ...future.result
[10:25:46.813] }
[10:25:46.816] requestCore(): workers = 2
[10:25:46.818] MulticoreFuture started
[10:25:46.819] - Launch lazy future ... done
[10:25:46.819] run() for ‘MulticoreFuture’ ... done
[10:25:46.820] plan(): Setting new future strategy stack:
List of 6
 $ a:[10:25:46.820] List of future strategies:
[10:25:46.820] 1. sequential:
[10:25:46.820]    - args: function (..., envir = parent.frame())
[10:25:46.820]    - tweaked: FALSE
[10:25:46.820]    - call: NULL
[10:25:46.821] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f50cfd78> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f56056f8> 
 $  : NULL
 $  : NULL
 $  :[10:25:46.823] plan(): Setting new future strategy stack:
 num 6
[10:25:46.823] List of future strategies:
[10:25:46.823] 1. multicore:
[10:25:46.823]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.823]    - tweaked: FALSE
[10:25:46.823]    - call: plan(strategy)
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f50cfd78> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f56056f8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ :[10:25:46.829] plan(): nbrOfWorkers() = 2
 chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:46.834] resolve() on list ...
[10:25:46.834]  recursive: 0
[10:25:46.834]  length: 6
[10:25:46.834]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:46.834] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.834] - nx: 6
[10:25:46.835] - relay: TRUE
[10:25:46.835] - stdout: TRUE
[10:25:46.835] - signal: TRUE
[10:25:46.835] - resignal: FALSE
[10:25:46.835] - force: TRUE
[10:25:46.835] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.835] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.835]  - until=2
[10:25:46.836]  - relaying element #2
[10:25:46.836] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.836] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.836] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.836]  length: 5 (resolved future 1)
[10:25:46.837] Future #2
[10:25:46.837] result() for MulticoreFuture ...
[10:25:46.838] result() for MulticoreFuture ...
[10:25:46.838] result() for MulticoreFuture ... done
[10:25:46.838] result() for MulticoreFuture ... done
[10:25:46.838] result() for MulticoreFuture ...
[10:25:46.838] result() for MulticoreFuture ... done
[10:25:46.838] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:46.838] - nx: 6
[10:25:46.839] - relay: TRUE
[10:25:46.839] - stdout: TRUE
[10:25:46.839] - signal: TRUE
[10:25:46.839] - resignal: FALSE
[10:25:46.839] - force: TRUE
[10:25:46.839] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.839] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.839]  - until=2
[10:25:46.840]  - relaying element #2
[10:25:46.840] result() for MulticoreFuture ...
[10:25:46.840] result() for MulticoreFuture ... done
[10:25:46.840] result() for MulticoreFuture ...
[10:25:46.840] result() for MulticoreFuture ... done
[10:25:46.840] result() for MulticoreFuture ...
[10:25:46.840] result() for MulticoreFuture ... done
[10:25:46.841] result() for MulticoreFuture ...
[10:25:46.841] result() for MulticoreFuture ... done
[10:25:46.841] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.841] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.841] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:46.841]  length: 4 (resolved future 2)
[10:25:46.842] Future #3
[10:25:46.842] result() for MulticoreFuture ...
[10:25:46.842] result() for MulticoreFuture ...
[10:25:46.843] result() for MulticoreFuture ... done
[10:25:46.843] result() for MulticoreFuture ... done
[10:25:46.843] result() for MulticoreFuture ...
[10:25:46.843] result() for MulticoreFuture ... done
[10:25:46.843] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:46.844] - nx: 6
[10:25:46.844] - relay: TRUE
[10:25:46.844] - stdout: TRUE
[10:25:46.844] - signal: TRUE
[10:25:46.844] - resignal: FALSE
[10:25:46.844] - force: TRUE
[10:25:46.845] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.845] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.845]  - until=3
[10:25:46.845]  - relaying element #3
[10:25:46.845] result() for MulticoreFuture ...
[10:25:46.845] result() for MulticoreFuture ... done
[10:25:46.846] result() for MulticoreFuture ...
[10:25:46.846] result() for MulticoreFuture ... done
[10:25:46.846] result() for MulticoreFuture ...
[10:25:46.846] result() for MulticoreFuture ... done
[10:25:46.846] result() for MulticoreFuture ...
[10:25:46.846] result() for MulticoreFuture ... done
[10:25:46.846] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.846] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.847] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:46.847]  length: 3 (resolved future 3)
[10:25:46.847] signalConditionsASAP(NULL, pos=4) ...
[10:25:46.847] - nx: 6
[10:25:46.847] - relay: TRUE
[10:25:46.847] - stdout: TRUE
[10:25:46.847] - signal: TRUE
[10:25:46.847] - resignal: FALSE
[10:25:46.847] - force: TRUE
[10:25:46.847] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.848] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.848]  - until=5
[10:25:46.848]  - relaying element #5
[10:25:46.848] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.848] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.848] signalConditionsASAP(NULL, pos=4) ... done
[10:25:46.848]  length: 2 (resolved future 4)
[10:25:46.848] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.848] - nx: 6
[10:25:46.849] - relay: TRUE
[10:25:46.849] - stdout: TRUE
[10:25:46.849] - signal: TRUE
[10:25:46.849] - resignal: FALSE
[10:25:46.849] - force: TRUE
[10:25:46.849] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.849] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.849]  - until=6
[10:25:46.849]  - relaying element #6
[10:25:46.849] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.850] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.850] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.850]  length: 1 (resolved future 5)
[10:25:46.850] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.850] - nx: 6
[10:25:46.850] - relay: TRUE
[10:25:46.852] - stdout: TRUE
[10:25:46.853] - signal: TRUE
[10:25:46.853] - resignal: FALSE
[10:25:46.853] - force: TRUE
[10:25:46.853] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.853] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.853]  - until=6
[10:25:46.853] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.854] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.854] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.854]  length: 0 (resolved future 6)
[10:25:46.854] Relaying remaining futures
[10:25:46.854] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.854] - nx: 6
[10:25:46.854] - relay: TRUE
[10:25:46.854] - stdout: TRUE
[10:25:46.855] - signal: TRUE
[10:25:46.855] - resignal: FALSE
[10:25:46.855] - force: TRUE
[10:25:46.855] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.855] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:46.855] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.855] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.855] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.855] resolve() on list ... DONE
[10:25:46.856] result() for MulticoreFuture ...
[10:25:46.856] result() for MulticoreFuture ... done
[10:25:46.856] result() for MulticoreFuture ...
[10:25:46.856] result() for MulticoreFuture ... done
[10:25:46.856] result() for MulticoreFuture ...
[10:25:46.856] result() for MulticoreFuture ... done
[10:25:46.856] result() for MulticoreFuture ...
[10:25:46.856] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:25:46.860] getGlobalsAndPackages() ...
[10:25:46.860] Searching for globals...
[10:25:46.861] 
[10:25:46.861] Searching for globals ... DONE
[10:25:46.861] - globals: [0] <none>
[10:25:46.861] getGlobalsAndPackages() ... DONE
[10:25:46.861] run() for ‘Future’ ...
[10:25:46.861] - state: ‘created’
[10:25:46.861] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.866] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.866]   - Field: ‘label’
[10:25:46.866]   - Field: ‘local’
[10:25:46.866]   - Field: ‘owner’
[10:25:46.866]   - Field: ‘envir’
[10:25:46.866]   - Field: ‘workers’
[10:25:46.866]   - Field: ‘packages’
[10:25:46.866]   - Field: ‘gc’
[10:25:46.866]   - Field: ‘job’
[10:25:46.867]   - Field: ‘conditions’
[10:25:46.867]   - Field: ‘expr’
[10:25:46.867]   - Field: ‘uuid’
[10:25:46.867]   - Field: ‘seed’
[10:25:46.867]   - Field: ‘version’
[10:25:46.867]   - Field: ‘result’
[10:25:46.867]   - Field: ‘asynchronous’
[10:25:46.867]   - Field: ‘calls’
[10:25:46.867]   - Field: ‘globals’
[10:25:46.867]   - Field: ‘stdout’
[10:25:46.867]   - Field: ‘earlySignal’
[10:25:46.868]   - Field: ‘lazy’
[10:25:46.868]   - Field: ‘state’
[10:25:46.868] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.868] - Launch lazy future ...
[10:25:46.868] Packages needed by the future expression (n = 0): <none>
[10:25:46.868] Packages needed by future strategies (n = 0): <none>
[10:25:46.869] {
[10:25:46.869]     {
[10:25:46.869]         {
[10:25:46.869]             ...future.startTime <- base::Sys.time()
[10:25:46.869]             {
[10:25:46.869]                 {
[10:25:46.869]                   {
[10:25:46.869]                     {
[10:25:46.869]                       base::local({
[10:25:46.869]                         has_future <- base::requireNamespace("future", 
[10:25:46.869]                           quietly = TRUE)
[10:25:46.869]                         if (has_future) {
[10:25:46.869]                           ns <- base::getNamespace("future")
[10:25:46.869]                           version <- ns[[".package"]][["version"]]
[10:25:46.869]                           if (is.null(version)) 
[10:25:46.869]                             version <- utils::packageVersion("future")
[10:25:46.869]                         }
[10:25:46.869]                         else {
[10:25:46.869]                           version <- NULL
[10:25:46.869]                         }
[10:25:46.869]                         if (!has_future || version < "1.8.0") {
[10:25:46.869]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.869]                             "", base::R.version$version.string), 
[10:25:46.869]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.869]                               "release", "version")], collapse = " "), 
[10:25:46.869]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.869]                             info)
[10:25:46.869]                           info <- base::paste(info, collapse = "; ")
[10:25:46.869]                           if (!has_future) {
[10:25:46.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.869]                               info)
[10:25:46.869]                           }
[10:25:46.869]                           else {
[10:25:46.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.869]                               info, version)
[10:25:46.869]                           }
[10:25:46.869]                           base::stop(msg)
[10:25:46.869]                         }
[10:25:46.869]                       })
[10:25:46.869]                     }
[10:25:46.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.869]                     base::options(mc.cores = 1L)
[10:25:46.869]                   }
[10:25:46.869]                   options(future.plan = NULL)
[10:25:46.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.869]                 }
[10:25:46.869]                 ...future.workdir <- getwd()
[10:25:46.869]             }
[10:25:46.869]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.869]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.869]         }
[10:25:46.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.869]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.869]             base::names(...future.oldOptions))
[10:25:46.869]     }
[10:25:46.869]     if (FALSE) {
[10:25:46.869]     }
[10:25:46.869]     else {
[10:25:46.869]         if (TRUE) {
[10:25:46.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.869]                 open = "w")
[10:25:46.869]         }
[10:25:46.869]         else {
[10:25:46.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.869]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.869]         }
[10:25:46.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.869]             base::sink(type = "output", split = FALSE)
[10:25:46.869]             base::close(...future.stdout)
[10:25:46.869]         }, add = TRUE)
[10:25:46.869]     }
[10:25:46.869]     ...future.frame <- base::sys.nframe()
[10:25:46.869]     ...future.conditions <- base::list()
[10:25:46.869]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.869]     if (FALSE) {
[10:25:46.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.869]     }
[10:25:46.869]     ...future.result <- base::tryCatch({
[10:25:46.869]         base::withCallingHandlers({
[10:25:46.869]             ...future.value <- base::withVisible(base::local({
[10:25:46.869]                 withCallingHandlers({
[10:25:46.869]                   2
[10:25:46.869]                 }, immediateCondition = function(cond) {
[10:25:46.869]                   save_rds <- function (object, pathname, ...) 
[10:25:46.869]                   {
[10:25:46.869]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.869]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.869]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.869]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.869]                         fi_tmp[["mtime"]])
[10:25:46.869]                     }
[10:25:46.869]                     tryCatch({
[10:25:46.869]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.869]                     }, error = function(ex) {
[10:25:46.869]                       msg <- conditionMessage(ex)
[10:25:46.869]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.869]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.869]                         fi_tmp[["mtime"]], msg)
[10:25:46.869]                       ex$message <- msg
[10:25:46.869]                       stop(ex)
[10:25:46.869]                     })
[10:25:46.869]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.869]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.869]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.869]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.869]                       fi <- file.info(pathname)
[10:25:46.869]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.869]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.869]                         fi[["size"]], fi[["mtime"]])
[10:25:46.869]                       stop(msg)
[10:25:46.869]                     }
[10:25:46.869]                     invisible(pathname)
[10:25:46.869]                   }
[10:25:46.869]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.869]                     rootPath = tempdir()) 
[10:25:46.869]                   {
[10:25:46.869]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.869]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.869]                       tmpdir = path, fileext = ".rds")
[10:25:46.869]                     save_rds(obj, file)
[10:25:46.869]                   }
[10:25:46.869]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.869]                   {
[10:25:46.869]                     inherits <- base::inherits
[10:25:46.869]                     invokeRestart <- base::invokeRestart
[10:25:46.869]                     is.null <- base::is.null
[10:25:46.869]                     muffled <- FALSE
[10:25:46.869]                     if (inherits(cond, "message")) {
[10:25:46.869]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.869]                       if (muffled) 
[10:25:46.869]                         invokeRestart("muffleMessage")
[10:25:46.869]                     }
[10:25:46.869]                     else if (inherits(cond, "warning")) {
[10:25:46.869]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.869]                       if (muffled) 
[10:25:46.869]                         invokeRestart("muffleWarning")
[10:25:46.869]                     }
[10:25:46.869]                     else if (inherits(cond, "condition")) {
[10:25:46.869]                       if (!is.null(pattern)) {
[10:25:46.869]                         computeRestarts <- base::computeRestarts
[10:25:46.869]                         grepl <- base::grepl
[10:25:46.869]                         restarts <- computeRestarts(cond)
[10:25:46.869]                         for (restart in restarts) {
[10:25:46.869]                           name <- restart$name
[10:25:46.869]                           if (is.null(name)) 
[10:25:46.869]                             next
[10:25:46.869]                           if (!grepl(pattern, name)) 
[10:25:46.869]                             next
[10:25:46.869]                           invokeRestart(restart)
[10:25:46.869]                           muffled <- TRUE
[10:25:46.869]                           break
[10:25:46.869]                         }
[10:25:46.869]                       }
[10:25:46.869]                     }
[10:25:46.869]                     invisible(muffled)
[10:25:46.869]                   }
[10:25:46.869]                   muffleCondition(cond)
[10:25:46.869]                 })
[10:25:46.869]             }))
[10:25:46.869]             future::FutureResult(value = ...future.value$value, 
[10:25:46.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.869]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.869]                     ...future.globalenv.names))
[10:25:46.869]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.869]         }, condition = base::local({
[10:25:46.869]             c <- base::c
[10:25:46.869]             inherits <- base::inherits
[10:25:46.869]             invokeRestart <- base::invokeRestart
[10:25:46.869]             length <- base::length
[10:25:46.869]             list <- base::list
[10:25:46.869]             seq.int <- base::seq.int
[10:25:46.869]             signalCondition <- base::signalCondition
[10:25:46.869]             sys.calls <- base::sys.calls
[10:25:46.869]             `[[` <- base::`[[`
[10:25:46.869]             `+` <- base::`+`
[10:25:46.869]             `<<-` <- base::`<<-`
[10:25:46.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.869]                   3L)]
[10:25:46.869]             }
[10:25:46.869]             function(cond) {
[10:25:46.869]                 is_error <- inherits(cond, "error")
[10:25:46.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.869]                   NULL)
[10:25:46.869]                 if (is_error) {
[10:25:46.869]                   sessionInformation <- function() {
[10:25:46.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.869]                       search = base::search(), system = base::Sys.info())
[10:25:46.869]                   }
[10:25:46.869]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.869]                     cond$call), session = sessionInformation(), 
[10:25:46.869]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.869]                   signalCondition(cond)
[10:25:46.869]                 }
[10:25:46.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.869]                 "immediateCondition"))) {
[10:25:46.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.869]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.869]                   if (TRUE && !signal) {
[10:25:46.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.869]                     {
[10:25:46.869]                       inherits <- base::inherits
[10:25:46.869]                       invokeRestart <- base::invokeRestart
[10:25:46.869]                       is.null <- base::is.null
[10:25:46.869]                       muffled <- FALSE
[10:25:46.869]                       if (inherits(cond, "message")) {
[10:25:46.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.869]                         if (muffled) 
[10:25:46.869]                           invokeRestart("muffleMessage")
[10:25:46.869]                       }
[10:25:46.869]                       else if (inherits(cond, "warning")) {
[10:25:46.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.869]                         if (muffled) 
[10:25:46.869]                           invokeRestart("muffleWarning")
[10:25:46.869]                       }
[10:25:46.869]                       else if (inherits(cond, "condition")) {
[10:25:46.869]                         if (!is.null(pattern)) {
[10:25:46.869]                           computeRestarts <- base::computeRestarts
[10:25:46.869]                           grepl <- base::grepl
[10:25:46.869]                           restarts <- computeRestarts(cond)
[10:25:46.869]                           for (restart in restarts) {
[10:25:46.869]                             name <- restart$name
[10:25:46.869]                             if (is.null(name)) 
[10:25:46.869]                               next
[10:25:46.869]                             if (!grepl(pattern, name)) 
[10:25:46.869]                               next
[10:25:46.869]                             invokeRestart(restart)
[10:25:46.869]                             muffled <- TRUE
[10:25:46.869]                             break
[10:25:46.869]                           }
[10:25:46.869]                         }
[10:25:46.869]                       }
[10:25:46.869]                       invisible(muffled)
[10:25:46.869]                     }
[10:25:46.869]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.869]                   }
[10:25:46.869]                 }
[10:25:46.869]                 else {
[10:25:46.869]                   if (TRUE) {
[10:25:46.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.869]                     {
[10:25:46.869]                       inherits <- base::inherits
[10:25:46.869]                       invokeRestart <- base::invokeRestart
[10:25:46.869]                       is.null <- base::is.null
[10:25:46.869]                       muffled <- FALSE
[10:25:46.869]                       if (inherits(cond, "message")) {
[10:25:46.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.869]                         if (muffled) 
[10:25:46.869]                           invokeRestart("muffleMessage")
[10:25:46.869]                       }
[10:25:46.869]                       else if (inherits(cond, "warning")) {
[10:25:46.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.869]                         if (muffled) 
[10:25:46.869]                           invokeRestart("muffleWarning")
[10:25:46.869]                       }
[10:25:46.869]                       else if (inherits(cond, "condition")) {
[10:25:46.869]                         if (!is.null(pattern)) {
[10:25:46.869]                           computeRestarts <- base::computeRestarts
[10:25:46.869]                           grepl <- base::grepl
[10:25:46.869]                           restarts <- computeRestarts(cond)
[10:25:46.869]                           for (restart in restarts) {
[10:25:46.869]                             name <- restart$name
[10:25:46.869]                             if (is.null(name)) 
[10:25:46.869]                               next
[10:25:46.869]                             if (!grepl(pattern, name)) 
[10:25:46.869]                               next
[10:25:46.869]                             invokeRestart(restart)
[10:25:46.869]                             muffled <- TRUE
[10:25:46.869]                             break
[10:25:46.869]                           }
[10:25:46.869]                         }
[10:25:46.869]                       }
[10:25:46.869]                       invisible(muffled)
[10:25:46.869]                     }
[10:25:46.869]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.869]                   }
[10:25:46.869]                 }
[10:25:46.869]             }
[10:25:46.869]         }))
[10:25:46.869]     }, error = function(ex) {
[10:25:46.869]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.869]                 ...future.rng), started = ...future.startTime, 
[10:25:46.869]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.869]             version = "1.8"), class = "FutureResult")
[10:25:46.869]     }, finally = {
[10:25:46.869]         if (!identical(...future.workdir, getwd())) 
[10:25:46.869]             setwd(...future.workdir)
[10:25:46.869]         {
[10:25:46.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.869]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.869]             }
[10:25:46.869]             base::options(...future.oldOptions)
[10:25:46.869]             if (.Platform$OS.type == "windows") {
[10:25:46.869]                 old_names <- names(...future.oldEnvVars)
[10:25:46.869]                 envs <- base::Sys.getenv()
[10:25:46.869]                 names <- names(envs)
[10:25:46.869]                 common <- intersect(names, old_names)
[10:25:46.869]                 added <- setdiff(names, old_names)
[10:25:46.869]                 removed <- setdiff(old_names, names)
[10:25:46.869]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.869]                   envs[common]]
[10:25:46.869]                 NAMES <- toupper(changed)
[10:25:46.869]                 args <- list()
[10:25:46.869]                 for (kk in seq_along(NAMES)) {
[10:25:46.869]                   name <- changed[[kk]]
[10:25:46.869]                   NAME <- NAMES[[kk]]
[10:25:46.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.869]                     next
[10:25:46.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.869]                 }
[10:25:46.869]                 NAMES <- toupper(added)
[10:25:46.869]                 for (kk in seq_along(NAMES)) {
[10:25:46.869]                   name <- added[[kk]]
[10:25:46.869]                   NAME <- NAMES[[kk]]
[10:25:46.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.869]                     next
[10:25:46.869]                   args[[name]] <- ""
[10:25:46.869]                 }
[10:25:46.869]                 NAMES <- toupper(removed)
[10:25:46.869]                 for (kk in seq_along(NAMES)) {
[10:25:46.869]                   name <- removed[[kk]]
[10:25:46.869]                   NAME <- NAMES[[kk]]
[10:25:46.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.869]                     next
[10:25:46.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.869]                 }
[10:25:46.869]                 if (length(args) > 0) 
[10:25:46.869]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.869]             }
[10:25:46.869]             else {
[10:25:46.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.869]             }
[10:25:46.869]             {
[10:25:46.869]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.869]                   0L) {
[10:25:46.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.869]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.869]                   base::options(opts)
[10:25:46.869]                 }
[10:25:46.869]                 {
[10:25:46.869]                   {
[10:25:46.869]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.869]                     NULL
[10:25:46.869]                   }
[10:25:46.869]                   options(future.plan = NULL)
[10:25:46.869]                   if (is.na(NA_character_)) 
[10:25:46.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.869]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.869]                     envir = parent.frame()) 
[10:25:46.869]                   {
[10:25:46.869]                     default_workers <- missing(workers)
[10:25:46.869]                     if (is.function(workers)) 
[10:25:46.869]                       workers <- workers()
[10:25:46.869]                     workers <- structure(as.integer(workers), 
[10:25:46.869]                       class = class(workers))
[10:25:46.869]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.869]                       1L)
[10:25:46.869]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.869]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.869]                       if (default_workers) 
[10:25:46.869]                         supportsMulticore(warn = TRUE)
[10:25:46.869]                       return(sequential(..., envir = envir))
[10:25:46.869]                     }
[10:25:46.869]                     oopts <- options(mc.cores = workers)
[10:25:46.869]                     on.exit(options(oopts))
[10:25:46.869]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.869]                       envir = envir)
[10:25:46.869]                     if (!future$lazy) 
[10:25:46.869]                       future <- run(future)
[10:25:46.869]                     invisible(future)
[10:25:46.869]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.869]                 }
[10:25:46.869]             }
[10:25:46.869]         }
[10:25:46.869]     })
[10:25:46.869]     if (TRUE) {
[10:25:46.869]         base::sink(type = "output", split = FALSE)
[10:25:46.869]         if (TRUE) {
[10:25:46.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.869]         }
[10:25:46.869]         else {
[10:25:46.869]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.869]         }
[10:25:46.869]         base::close(...future.stdout)
[10:25:46.869]         ...future.stdout <- NULL
[10:25:46.869]     }
[10:25:46.869]     ...future.result$conditions <- ...future.conditions
[10:25:46.869]     ...future.result$finished <- base::Sys.time()
[10:25:46.869]     ...future.result
[10:25:46.869] }
[10:25:46.871] requestCore(): workers = 2
[10:25:46.873] MulticoreFuture started
[10:25:46.873] - Launch lazy future ... done
[10:25:46.873] run() for ‘MulticoreFuture’ ... done
[10:25:46.874] getGlobalsAndPackages() ...
[10:25:46.874] Searching for globals...
[10:25:46.874] plan(): Setting new future strategy stack:
[10:25:46.875] 
[10:25:46.874] List of future strategies:
[10:25:46.874] 1. sequential:
[10:25:46.874]    - args: function (..., envir = parent.frame())
[10:25:46.874]    - tweaked: FALSE
[10:25:46.874]    - call: NULL
[10:25:46.875] Searching for globals ... DONE
[10:25:46.875] - globals: [0] <none>
[10:25:46.875] plan(): nbrOfWorkers() = 1
[10:25:46.875] getGlobalsAndPackages() ... DONE
[10:25:46.876] run() for ‘Future’ ...
[10:25:46.876] - state: ‘created’
[10:25:46.876] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:46.877] plan(): Setting new future strategy stack:
[10:25:46.877] List of future strategies:
[10:25:46.877] 1. multicore:
[10:25:46.877]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.877]    - tweaked: FALSE
[10:25:46.877]    - call: plan(strategy)
[10:25:46.881] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:46.881] plan(): nbrOfWorkers() = 2
[10:25:46.881] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:46.882]   - Field: ‘label’
[10:25:46.882]   - Field: ‘local’
[10:25:46.882]   - Field: ‘owner’
[10:25:46.882]   - Field: ‘envir’
[10:25:46.882]   - Field: ‘workers’
[10:25:46.882]   - Field: ‘packages’
[10:25:46.883]   - Field: ‘gc’
[10:25:46.883]   - Field: ‘job’
[10:25:46.883]   - Field: ‘conditions’
[10:25:46.883]   - Field: ‘expr’
[10:25:46.883]   - Field: ‘uuid’
[10:25:46.883]   - Field: ‘seed’
[10:25:46.884]   - Field: ‘version’
[10:25:46.884]   - Field: ‘result’
[10:25:46.884]   - Field: ‘asynchronous’
[10:25:46.884]   - Field: ‘calls’
[10:25:46.884]   - Field: ‘globals’
[10:25:46.884]   - Field: ‘stdout’
[10:25:46.884]   - Field: ‘earlySignal’
[10:25:46.885]   - Field: ‘lazy’
[10:25:46.885]   - Field: ‘state’
[10:25:46.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:46.885] - Launch lazy future ...
[10:25:46.886] Packages needed by the future expression (n = 0): <none>
[10:25:46.886] Packages needed by future strategies (n = 0): <none>
[10:25:46.887] {
[10:25:46.887]     {
[10:25:46.887]         {
[10:25:46.887]             ...future.startTime <- base::Sys.time()
[10:25:46.887]             {
[10:25:46.887]                 {
[10:25:46.887]                   {
[10:25:46.887]                     {
[10:25:46.887]                       base::local({
[10:25:46.887]                         has_future <- base::requireNamespace("future", 
[10:25:46.887]                           quietly = TRUE)
[10:25:46.887]                         if (has_future) {
[10:25:46.887]                           ns <- base::getNamespace("future")
[10:25:46.887]                           version <- ns[[".package"]][["version"]]
[10:25:46.887]                           if (is.null(version)) 
[10:25:46.887]                             version <- utils::packageVersion("future")
[10:25:46.887]                         }
[10:25:46.887]                         else {
[10:25:46.887]                           version <- NULL
[10:25:46.887]                         }
[10:25:46.887]                         if (!has_future || version < "1.8.0") {
[10:25:46.887]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:46.887]                             "", base::R.version$version.string), 
[10:25:46.887]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:46.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:46.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:46.887]                               "release", "version")], collapse = " "), 
[10:25:46.887]                             hostname = base::Sys.info()[["nodename"]])
[10:25:46.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:46.887]                             info)
[10:25:46.887]                           info <- base::paste(info, collapse = "; ")
[10:25:46.887]                           if (!has_future) {
[10:25:46.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:46.887]                               info)
[10:25:46.887]                           }
[10:25:46.887]                           else {
[10:25:46.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:46.887]                               info, version)
[10:25:46.887]                           }
[10:25:46.887]                           base::stop(msg)
[10:25:46.887]                         }
[10:25:46.887]                       })
[10:25:46.887]                     }
[10:25:46.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:46.887]                     base::options(mc.cores = 1L)
[10:25:46.887]                   }
[10:25:46.887]                   options(future.plan = NULL)
[10:25:46.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:46.887]                 }
[10:25:46.887]                 ...future.workdir <- getwd()
[10:25:46.887]             }
[10:25:46.887]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:46.887]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:46.887]         }
[10:25:46.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:46.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:46.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:46.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:46.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:46.887]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:46.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:46.887]             base::names(...future.oldOptions))
[10:25:46.887]     }
[10:25:46.887]     if (FALSE) {
[10:25:46.887]     }
[10:25:46.887]     else {
[10:25:46.887]         if (TRUE) {
[10:25:46.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:46.887]                 open = "w")
[10:25:46.887]         }
[10:25:46.887]         else {
[10:25:46.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:46.887]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:46.887]         }
[10:25:46.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:46.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:46.887]             base::sink(type = "output", split = FALSE)
[10:25:46.887]             base::close(...future.stdout)
[10:25:46.887]         }, add = TRUE)
[10:25:46.887]     }
[10:25:46.887]     ...future.frame <- base::sys.nframe()
[10:25:46.887]     ...future.conditions <- base::list()
[10:25:46.887]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:46.887]     if (FALSE) {
[10:25:46.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:46.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:46.887]     }
[10:25:46.887]     ...future.result <- base::tryCatch({
[10:25:46.887]         base::withCallingHandlers({
[10:25:46.887]             ...future.value <- base::withVisible(base::local({
[10:25:46.887]                 withCallingHandlers({
[10:25:46.887]                   NULL
[10:25:46.887]                 }, immediateCondition = function(cond) {
[10:25:46.887]                   save_rds <- function (object, pathname, ...) 
[10:25:46.887]                   {
[10:25:46.887]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:46.887]                     if (file_test("-f", pathname_tmp)) {
[10:25:46.887]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.887]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:46.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.887]                         fi_tmp[["mtime"]])
[10:25:46.887]                     }
[10:25:46.887]                     tryCatch({
[10:25:46.887]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:46.887]                     }, error = function(ex) {
[10:25:46.887]                       msg <- conditionMessage(ex)
[10:25:46.887]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.887]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:46.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.887]                         fi_tmp[["mtime"]], msg)
[10:25:46.887]                       ex$message <- msg
[10:25:46.887]                       stop(ex)
[10:25:46.887]                     })
[10:25:46.887]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:46.887]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:46.887]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:46.887]                       fi_tmp <- file.info(pathname_tmp)
[10:25:46.887]                       fi <- file.info(pathname)
[10:25:46.887]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:46.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:46.887]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:46.887]                         fi[["size"]], fi[["mtime"]])
[10:25:46.887]                       stop(msg)
[10:25:46.887]                     }
[10:25:46.887]                     invisible(pathname)
[10:25:46.887]                   }
[10:25:46.887]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:46.887]                     rootPath = tempdir()) 
[10:25:46.887]                   {
[10:25:46.887]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:46.887]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:46.887]                       tmpdir = path, fileext = ".rds")
[10:25:46.887]                     save_rds(obj, file)
[10:25:46.887]                   }
[10:25:46.887]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:46.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.887]                   {
[10:25:46.887]                     inherits <- base::inherits
[10:25:46.887]                     invokeRestart <- base::invokeRestart
[10:25:46.887]                     is.null <- base::is.null
[10:25:46.887]                     muffled <- FALSE
[10:25:46.887]                     if (inherits(cond, "message")) {
[10:25:46.887]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:46.887]                       if (muffled) 
[10:25:46.887]                         invokeRestart("muffleMessage")
[10:25:46.887]                     }
[10:25:46.887]                     else if (inherits(cond, "warning")) {
[10:25:46.887]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:46.887]                       if (muffled) 
[10:25:46.887]                         invokeRestart("muffleWarning")
[10:25:46.887]                     }
[10:25:46.887]                     else if (inherits(cond, "condition")) {
[10:25:46.887]                       if (!is.null(pattern)) {
[10:25:46.887]                         computeRestarts <- base::computeRestarts
[10:25:46.887]                         grepl <- base::grepl
[10:25:46.887]                         restarts <- computeRestarts(cond)
[10:25:46.887]                         for (restart in restarts) {
[10:25:46.887]                           name <- restart$name
[10:25:46.887]                           if (is.null(name)) 
[10:25:46.887]                             next
[10:25:46.887]                           if (!grepl(pattern, name)) 
[10:25:46.887]                             next
[10:25:46.887]                           invokeRestart(restart)
[10:25:46.887]                           muffled <- TRUE
[10:25:46.887]                           break
[10:25:46.887]                         }
[10:25:46.887]                       }
[10:25:46.887]                     }
[10:25:46.887]                     invisible(muffled)
[10:25:46.887]                   }
[10:25:46.887]                   muffleCondition(cond)
[10:25:46.887]                 })
[10:25:46.887]             }))
[10:25:46.887]             future::FutureResult(value = ...future.value$value, 
[10:25:46.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.887]                   ...future.rng), globalenv = if (FALSE) 
[10:25:46.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:46.887]                     ...future.globalenv.names))
[10:25:46.887]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:46.887]         }, condition = base::local({
[10:25:46.887]             c <- base::c
[10:25:46.887]             inherits <- base::inherits
[10:25:46.887]             invokeRestart <- base::invokeRestart
[10:25:46.887]             length <- base::length
[10:25:46.887]             list <- base::list
[10:25:46.887]             seq.int <- base::seq.int
[10:25:46.887]             signalCondition <- base::signalCondition
[10:25:46.887]             sys.calls <- base::sys.calls
[10:25:46.887]             `[[` <- base::`[[`
[10:25:46.887]             `+` <- base::`+`
[10:25:46.887]             `<<-` <- base::`<<-`
[10:25:46.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:46.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:46.887]                   3L)]
[10:25:46.887]             }
[10:25:46.887]             function(cond) {
[10:25:46.887]                 is_error <- inherits(cond, "error")
[10:25:46.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:46.887]                   NULL)
[10:25:46.887]                 if (is_error) {
[10:25:46.887]                   sessionInformation <- function() {
[10:25:46.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:46.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:46.887]                       search = base::search(), system = base::Sys.info())
[10:25:46.887]                   }
[10:25:46.887]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:46.887]                     cond$call), session = sessionInformation(), 
[10:25:46.887]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:46.887]                   signalCondition(cond)
[10:25:46.887]                 }
[10:25:46.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:46.887]                 "immediateCondition"))) {
[10:25:46.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:46.887]                   ...future.conditions[[length(...future.conditions) + 
[10:25:46.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:46.887]                   if (TRUE && !signal) {
[10:25:46.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.887]                     {
[10:25:46.887]                       inherits <- base::inherits
[10:25:46.887]                       invokeRestart <- base::invokeRestart
[10:25:46.887]                       is.null <- base::is.null
[10:25:46.887]                       muffled <- FALSE
[10:25:46.887]                       if (inherits(cond, "message")) {
[10:25:46.887]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.887]                         if (muffled) 
[10:25:46.887]                           invokeRestart("muffleMessage")
[10:25:46.887]                       }
[10:25:46.887]                       else if (inherits(cond, "warning")) {
[10:25:46.887]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.887]                         if (muffled) 
[10:25:46.887]                           invokeRestart("muffleWarning")
[10:25:46.887]                       }
[10:25:46.887]                       else if (inherits(cond, "condition")) {
[10:25:46.887]                         if (!is.null(pattern)) {
[10:25:46.887]                           computeRestarts <- base::computeRestarts
[10:25:46.887]                           grepl <- base::grepl
[10:25:46.887]                           restarts <- computeRestarts(cond)
[10:25:46.887]                           for (restart in restarts) {
[10:25:46.887]                             name <- restart$name
[10:25:46.887]                             if (is.null(name)) 
[10:25:46.887]                               next
[10:25:46.887]                             if (!grepl(pattern, name)) 
[10:25:46.887]                               next
[10:25:46.887]                             invokeRestart(restart)
[10:25:46.887]                             muffled <- TRUE
[10:25:46.887]                             break
[10:25:46.887]                           }
[10:25:46.887]                         }
[10:25:46.887]                       }
[10:25:46.887]                       invisible(muffled)
[10:25:46.887]                     }
[10:25:46.887]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.887]                   }
[10:25:46.887]                 }
[10:25:46.887]                 else {
[10:25:46.887]                   if (TRUE) {
[10:25:46.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:46.887]                     {
[10:25:46.887]                       inherits <- base::inherits
[10:25:46.887]                       invokeRestart <- base::invokeRestart
[10:25:46.887]                       is.null <- base::is.null
[10:25:46.887]                       muffled <- FALSE
[10:25:46.887]                       if (inherits(cond, "message")) {
[10:25:46.887]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:46.887]                         if (muffled) 
[10:25:46.887]                           invokeRestart("muffleMessage")
[10:25:46.887]                       }
[10:25:46.887]                       else if (inherits(cond, "warning")) {
[10:25:46.887]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:46.887]                         if (muffled) 
[10:25:46.887]                           invokeRestart("muffleWarning")
[10:25:46.887]                       }
[10:25:46.887]                       else if (inherits(cond, "condition")) {
[10:25:46.887]                         if (!is.null(pattern)) {
[10:25:46.887]                           computeRestarts <- base::computeRestarts
[10:25:46.887]                           grepl <- base::grepl
[10:25:46.887]                           restarts <- computeRestarts(cond)
[10:25:46.887]                           for (restart in restarts) {
[10:25:46.887]                             name <- restart$name
[10:25:46.887]                             if (is.null(name)) 
[10:25:46.887]                               next
[10:25:46.887]                             if (!grepl(pattern, name)) 
[10:25:46.887]                               next
[10:25:46.887]                             invokeRestart(restart)
[10:25:46.887]                             muffled <- TRUE
[10:25:46.887]                             break
[10:25:46.887]                           }
[10:25:46.887]                         }
[10:25:46.887]                       }
[10:25:46.887]                       invisible(muffled)
[10:25:46.887]                     }
[10:25:46.887]                     muffleCondition(cond, pattern = "^muffle")
[10:25:46.887]                   }
[10:25:46.887]                 }
[10:25:46.887]             }
[10:25:46.887]         }))
[10:25:46.887]     }, error = function(ex) {
[10:25:46.887]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:46.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:46.887]                 ...future.rng), started = ...future.startTime, 
[10:25:46.887]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:46.887]             version = "1.8"), class = "FutureResult")
[10:25:46.887]     }, finally = {
[10:25:46.887]         if (!identical(...future.workdir, getwd())) 
[10:25:46.887]             setwd(...future.workdir)
[10:25:46.887]         {
[10:25:46.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:46.887]                 ...future.oldOptions$nwarnings <- NULL
[10:25:46.887]             }
[10:25:46.887]             base::options(...future.oldOptions)
[10:25:46.887]             if (.Platform$OS.type == "windows") {
[10:25:46.887]                 old_names <- names(...future.oldEnvVars)
[10:25:46.887]                 envs <- base::Sys.getenv()
[10:25:46.887]                 names <- names(envs)
[10:25:46.887]                 common <- intersect(names, old_names)
[10:25:46.887]                 added <- setdiff(names, old_names)
[10:25:46.887]                 removed <- setdiff(old_names, names)
[10:25:46.887]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:46.887]                   envs[common]]
[10:25:46.887]                 NAMES <- toupper(changed)
[10:25:46.887]                 args <- list()
[10:25:46.887]                 for (kk in seq_along(NAMES)) {
[10:25:46.887]                   name <- changed[[kk]]
[10:25:46.887]                   NAME <- NAMES[[kk]]
[10:25:46.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.887]                     next
[10:25:46.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.887]                 }
[10:25:46.887]                 NAMES <- toupper(added)
[10:25:46.887]                 for (kk in seq_along(NAMES)) {
[10:25:46.887]                   name <- added[[kk]]
[10:25:46.887]                   NAME <- NAMES[[kk]]
[10:25:46.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.887]                     next
[10:25:46.887]                   args[[name]] <- ""
[10:25:46.887]                 }
[10:25:46.887]                 NAMES <- toupper(removed)
[10:25:46.887]                 for (kk in seq_along(NAMES)) {
[10:25:46.887]                   name <- removed[[kk]]
[10:25:46.887]                   NAME <- NAMES[[kk]]
[10:25:46.887]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:46.887]                     next
[10:25:46.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:46.887]                 }
[10:25:46.887]                 if (length(args) > 0) 
[10:25:46.887]                   base::do.call(base::Sys.setenv, args = args)
[10:25:46.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:46.887]             }
[10:25:46.887]             else {
[10:25:46.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:46.887]             }
[10:25:46.887]             {
[10:25:46.887]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:46.887]                   0L) {
[10:25:46.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:46.887]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:46.887]                   base::options(opts)
[10:25:46.887]                 }
[10:25:46.887]                 {
[10:25:46.887]                   {
[10:25:46.887]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:46.887]                     NULL
[10:25:46.887]                   }
[10:25:46.887]                   options(future.plan = NULL)
[10:25:46.887]                   if (is.na(NA_character_)) 
[10:25:46.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:46.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:46.887]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:46.887]                     envir = parent.frame()) 
[10:25:46.887]                   {
[10:25:46.887]                     default_workers <- missing(workers)
[10:25:46.887]                     if (is.function(workers)) 
[10:25:46.887]                       workers <- workers()
[10:25:46.887]                     workers <- structure(as.integer(workers), 
[10:25:46.887]                       class = class(workers))
[10:25:46.887]                     stop_if_not(is.finite(workers), workers >= 
[10:25:46.887]                       1L)
[10:25:46.887]                     if ((workers == 1L && !inherits(workers, 
[10:25:46.887]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:46.887]                       if (default_workers) 
[10:25:46.887]                         supportsMulticore(warn = TRUE)
[10:25:46.887]                       return(sequential(..., envir = envir))
[10:25:46.887]                     }
[10:25:46.887]                     oopts <- options(mc.cores = workers)
[10:25:46.887]                     on.exit(options(oopts))
[10:25:46.887]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:46.887]                       envir = envir)
[10:25:46.887]                     if (!future$lazy) 
[10:25:46.887]                       future <- run(future)
[10:25:46.887]                     invisible(future)
[10:25:46.887]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:46.887]                 }
[10:25:46.887]             }
[10:25:46.887]         }
[10:25:46.887]     })
[10:25:46.887]     if (TRUE) {
[10:25:46.887]         base::sink(type = "output", split = FALSE)
[10:25:46.887]         if (TRUE) {
[10:25:46.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:46.887]         }
[10:25:46.887]         else {
[10:25:46.887]             ...future.result["stdout"] <- base::list(NULL)
[10:25:46.887]         }
[10:25:46.887]         base::close(...future.stdout)
[10:25:46.887]         ...future.stdout <- NULL
[10:25:46.887]     }
[10:25:46.887]     ...future.result$conditions <- ...future.conditions
[10:25:46.887]     ...future.result$finished <- base::Sys.time()
[10:25:46.887]     ...future.result
[10:25:46.887] }
[10:25:46.890] requestCore(): workers = 2
[10:25:46.892] MulticoreFuture started
[10:25:46.893] - Launch lazy future ... done
[10:25:46.893] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[10:25:46.894] plan(): Setting new future strategy stack:
 num 1
[10:25:46.894] List of future strategies:
[10:25:46.894] 1. sequential:
[10:25:46.894]    - args: function (..., envir = parent.frame())
[10:25:46.894]    - tweaked: FALSE
[10:25:46.894]    - call: NULL
 $ b:[10:25:46.895] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f3d2e598> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f5036eb0> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:25:46.897] plan(): Setting new future strategy stack:
List of 6
 $ a:[10:25:46.897] List of future strategies:
[10:25:46.897] 1. multicore:
[10:25:46.897]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:46.897]    - tweaked: FALSE
[10:25:46.897]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f3d2e598> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' [10:25:46.902] plan(): nbrOfWorkers() = 2
<environment: 0x55c0f5036eb0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:46.913] resolve() on list ...
[10:25:46.913]  recursive: 0
[10:25:46.913]  length: 6
[10:25:46.914]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:46.914] signalConditionsASAP(numeric, pos=1) ...
[10:25:46.914] - nx: 6
[10:25:46.914] - relay: TRUE
[10:25:46.914] - stdout: TRUE
[10:25:46.914] - signal: TRUE
[10:25:46.915] - resignal: FALSE
[10:25:46.915] - force: TRUE
[10:25:46.915] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.915] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.915]  - until=2
[10:25:46.915]  - relaying element #2
[10:25:46.915] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.916] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.916] signalConditionsASAP(NULL, pos=1) ... done
[10:25:46.916]  length: 5 (resolved future 1)
[10:25:46.916] Future #2
[10:25:46.916] result() for MulticoreFuture ...
[10:25:46.917] result() for MulticoreFuture ...
[10:25:46.917] result() for MulticoreFuture ... done
[10:25:46.917] result() for MulticoreFuture ... done
[10:25:46.918] result() for MulticoreFuture ...
[10:25:46.918] result() for MulticoreFuture ... done
[10:25:46.918] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:46.918] - nx: 6
[10:25:46.918] - relay: TRUE
[10:25:46.918] - stdout: TRUE
[10:25:46.918] - signal: TRUE
[10:25:46.918] - resignal: FALSE
[10:25:46.919] - force: TRUE
[10:25:46.919] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.919] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:46.919]  - until=2
[10:25:46.919]  - relaying element #2
[10:25:46.919] result() for MulticoreFuture ...
[10:25:46.919] result() for MulticoreFuture ... done
[10:25:46.920] result() for MulticoreFuture ...
[10:25:46.920] result() for MulticoreFuture ... done
[10:25:46.920] result() for MulticoreFuture ...
[10:25:46.920] result() for MulticoreFuture ... done
[10:25:46.920] result() for MulticoreFuture ...
[10:25:46.920] result() for MulticoreFuture ... done
[10:25:46.920] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.920] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.921] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:46.921]  length: 4 (resolved future 2)
[10:25:46.921] Future #3
[10:25:46.921] result() for MulticoreFuture ...
[10:25:46.922] result() for MulticoreFuture ...
[10:25:46.922] result() for MulticoreFuture ... done
[10:25:46.922] result() for MulticoreFuture ... done
[10:25:46.922] result() for MulticoreFuture ...
[10:25:46.922] result() for MulticoreFuture ... done
[10:25:46.922] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:46.923] - nx: 6
[10:25:46.923] - relay: TRUE
[10:25:46.923] - stdout: TRUE
[10:25:46.923] - signal: TRUE
[10:25:46.923] - resignal: FALSE
[10:25:46.923] - force: TRUE
[10:25:46.923] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.923] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:46.923]  - until=3
[10:25:46.924]  - relaying element #3
[10:25:46.924] result() for MulticoreFuture ...
[10:25:46.924] result() for MulticoreFuture ... done
[10:25:46.924] result() for MulticoreFuture ...
[10:25:46.924] result() for MulticoreFuture ... done
[10:25:46.924] result() for MulticoreFuture ...
[10:25:46.924] result() for MulticoreFuture ... done
[10:25:46.924] result() for MulticoreFuture ...
[10:25:46.924] result() for MulticoreFuture ... done
[10:25:46.924] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.925] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.925] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:46.925]  length: 3 (resolved future 3)
[10:25:46.925] signalConditionsASAP(NULL, pos=4) ...
[10:25:46.925] - nx: 6
[10:25:46.925] - relay: TRUE
[10:25:46.925] - stdout: TRUE
[10:25:46.925] - signal: TRUE
[10:25:46.925] - resignal: FALSE
[10:25:46.926] - force: TRUE
[10:25:46.926] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.926] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.926]  - until=5
[10:25:46.926]  - relaying element #5
[10:25:46.926] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.926] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.926] signalConditionsASAP(NULL, pos=4) ... done
[10:25:46.926]  length: 2 (resolved future 4)
[10:25:46.926] signalConditionsASAP(NULL, pos=5) ...
[10:25:46.927] - nx: 6
[10:25:46.927] - relay: TRUE
[10:25:46.927] - stdout: TRUE
[10:25:46.927] - signal: TRUE
[10:25:46.927] - resignal: FALSE
[10:25:46.927] - force: TRUE
[10:25:46.927] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:46.927] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.927]  - until=6
[10:25:46.927]  - relaying element #6
[10:25:46.927] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.928] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.928] signalConditionsASAP(NULL, pos=5) ... done
[10:25:46.928]  length: 1 (resolved future 5)
[10:25:46.928] signalConditionsASAP(numeric, pos=6) ...
[10:25:46.928] - nx: 6
[10:25:46.928] - relay: TRUE
[10:25:46.928] - stdout: TRUE
[10:25:46.928] - signal: TRUE
[10:25:46.928] - resignal: FALSE
[10:25:46.928] - force: TRUE
[10:25:46.928] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:46.929] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.929]  - until=6
[10:25:46.929] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.929] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.929] signalConditionsASAP(numeric, pos=6) ... done
[10:25:46.929]  length: 0 (resolved future 6)
[10:25:46.929] Relaying remaining futures
[10:25:46.929] signalConditionsASAP(NULL, pos=0) ...
[10:25:46.929] - nx: 6
[10:25:46.929] - relay: TRUE
[10:25:46.930] - stdout: TRUE
[10:25:46.930] - signal: TRUE
[10:25:46.930] - resignal: FALSE
[10:25:46.930] - force: TRUE
[10:25:46.930] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.930] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:46.930] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:46.930] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:46.930] signalConditionsASAP(NULL, pos=0) ... done
[10:25:46.930] resolve() on list ... DONE
[10:25:46.931] result() for MulticoreFuture ...
[10:25:46.931] result() for MulticoreFuture ... done
[10:25:46.931] result() for MulticoreFuture ...
[10:25:46.931] result() for MulticoreFuture ... done
[10:25:46.931] result() for MulticoreFuture ...
[10:25:46.931] result() for MulticoreFuture ... done
[10:25:46.931] result() for MulticoreFuture ...
[10:25:46.931] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[10:25:46.937] plan(): Setting new future strategy stack:
[10:25:46.937] List of future strategies:
[10:25:46.937] 1. multisession:
[10:25:46.937]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:46.937]    - tweaked: FALSE
[10:25:46.937]    - call: plan(strategy)
[10:25:46.937] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:25:46.937] multisession:
[10:25:46.937] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:46.937] - tweaked: FALSE
[10:25:46.937] - call: plan(strategy)
[10:25:46.943] getGlobalsAndPackages() ...
[10:25:46.944] Not searching for globals
[10:25:46.944] - globals: [0] <none>
[10:25:46.944] getGlobalsAndPackages() ... DONE
[10:25:46.944] [local output] makeClusterPSOCK() ...
[10:25:46.983] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:25:46.984] [local output] Base port: 11091
[10:25:46.985] [local output] Getting setup options for 2 cluster nodes ...
[10:25:46.985] [local output]  - Node 1 of 2 ...
[10:25:46.985] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:46.986] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpt2gjBk/worker.rank=1.parallelly.parent=83526.1464633b2aa9b.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpt2gjBk/worker.rank=1.parallelly.parent=83526.1464633b2aa9b.pid")'’
[10:25:47.176] - Possible to infer worker's PID: TRUE
[10:25:47.176] [local output] Rscript port: 11091

[10:25:47.177] [local output]  - Node 2 of 2 ...
[10:25:47.177] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:47.178] [local output] Rscript port: 11091

[10:25:47.178] [local output] Getting setup options for 2 cluster nodes ... done
[10:25:47.178] [local output]  - Parallel setup requested for some PSOCK nodes
[10:25:47.179] [local output] Setting up PSOCK nodes in parallel
[10:25:47.179] List of 36
[10:25:47.179]  $ worker          : chr "localhost"
[10:25:47.179]   ..- attr(*, "localhost")= logi TRUE
[10:25:47.179]  $ master          : chr "localhost"
[10:25:47.179]  $ port            : int 11091
[10:25:47.179]  $ connectTimeout  : num 120
[10:25:47.179]  $ timeout         : num 2592000
[10:25:47.179]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:25:47.179]  $ homogeneous     : logi TRUE
[10:25:47.179]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:25:47.179]  $ rscript_envs    : NULL
[10:25:47.179]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:47.179]  $ rscript_startup : NULL
[10:25:47.179]  $ rscript_sh      : chr "sh"
[10:25:47.179]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:47.179]  $ methods         : logi TRUE
[10:25:47.179]  $ socketOptions   : chr "no-delay"
[10:25:47.179]  $ useXDR          : logi FALSE
[10:25:47.179]  $ outfile         : chr "/dev/null"
[10:25:47.179]  $ renice          : int NA
[10:25:47.179]  $ rshcmd          : NULL
[10:25:47.179]  $ user            : chr(0) 
[10:25:47.179]  $ revtunnel       : logi FALSE
[10:25:47.179]  $ rshlogfile      : NULL
[10:25:47.179]  $ rshopts         : chr(0) 
[10:25:47.179]  $ rank            : int 1
[10:25:47.179]  $ manual          : logi FALSE
[10:25:47.179]  $ dryrun          : logi FALSE
[10:25:47.179]  $ quiet           : logi FALSE
[10:25:47.179]  $ setup_strategy  : chr "parallel"
[10:25:47.179]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:47.179]  $ pidfile         : chr "/tmp/Rtmpt2gjBk/worker.rank=1.parallelly.parent=83526.1464633b2aa9b.pid"
[10:25:47.179]  $ rshcmd_label    : NULL
[10:25:47.179]  $ rsh_call        : NULL
[10:25:47.179]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:47.179]  $ localMachine    : logi TRUE
[10:25:47.179]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:25:47.179]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:25:47.179]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:25:47.179]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:25:47.179]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:25:47.179]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:25:47.179]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:25:47.179]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:25:47.179]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:25:47.179]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:25:47.179]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:25:47.179]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:25:47.179]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:25:47.179]  $ arguments       :List of 28
[10:25:47.179]   ..$ worker          : chr "localhost"
[10:25:47.179]   ..$ master          : NULL
[10:25:47.179]   ..$ port            : int 11091
[10:25:47.179]   ..$ connectTimeout  : num 120
[10:25:47.179]   ..$ timeout         : num 2592000
[10:25:47.179]   ..$ rscript         : NULL
[10:25:47.179]   ..$ homogeneous     : NULL
[10:25:47.179]   ..$ rscript_args    : NULL
[10:25:47.179]   ..$ rscript_envs    : NULL
[10:25:47.179]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:47.179]   ..$ rscript_startup : NULL
[10:25:47.179]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:25:47.179]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:47.179]   ..$ methods         : logi TRUE
[10:25:47.179]   ..$ socketOptions   : chr "no-delay"
[10:25:47.179]   ..$ useXDR          : logi FALSE
[10:25:47.179]   ..$ outfile         : chr "/dev/null"
[10:25:47.179]   ..$ renice          : int NA
[10:25:47.179]   ..$ rshcmd          : NULL
[10:25:47.179]   ..$ user            : NULL
[10:25:47.179]   ..$ revtunnel       : logi NA
[10:25:47.179]   ..$ rshlogfile      : NULL
[10:25:47.179]   ..$ rshopts         : NULL
[10:25:47.179]   ..$ rank            : int 1
[10:25:47.179]   ..$ manual          : logi FALSE
[10:25:47.179]   ..$ dryrun          : logi FALSE
[10:25:47.179]   ..$ quiet           : logi FALSE
[10:25:47.179]   ..$ setup_strategy  : chr "parallel"
[10:25:47.179]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:25:47.196] [local output] System call to launch all workers:
[10:25:47.196] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpt2gjBk/worker.rank=1.parallelly.parent=83526.1464633b2aa9b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11091 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:25:47.196] [local output] Starting PSOCK main server
[10:25:47.201] [local output] Workers launched
[10:25:47.201] [local output] Waiting for workers to connect back
[10:25:47.202]  - [local output] 0 workers out of 2 ready
[10:25:47.446]  - [local output] 0 workers out of 2 ready
[10:25:47.446]  - [local output] 1 workers out of 2 ready
[10:25:47.450]  - [local output] 1 workers out of 2 ready
[10:25:47.450]  - [local output] 2 workers out of 2 ready
[10:25:47.450] [local output] Launching of workers completed
[10:25:47.450] [local output] Collecting session information from workers
[10:25:47.451] [local output]  - Worker #1 of 2
[10:25:47.452] [local output]  - Worker #2 of 2
[10:25:47.452] [local output] makeClusterPSOCK() ... done
[10:25:47.463] Packages needed by the future expression (n = 0): <none>
[10:25:47.463] Packages needed by future strategies (n = 0): <none>
[10:25:47.464] {
[10:25:47.464]     {
[10:25:47.464]         {
[10:25:47.464]             ...future.startTime <- base::Sys.time()
[10:25:47.464]             {
[10:25:47.464]                 {
[10:25:47.464]                   {
[10:25:47.464]                     {
[10:25:47.464]                       base::local({
[10:25:47.464]                         has_future <- base::requireNamespace("future", 
[10:25:47.464]                           quietly = TRUE)
[10:25:47.464]                         if (has_future) {
[10:25:47.464]                           ns <- base::getNamespace("future")
[10:25:47.464]                           version <- ns[[".package"]][["version"]]
[10:25:47.464]                           if (is.null(version)) 
[10:25:47.464]                             version <- utils::packageVersion("future")
[10:25:47.464]                         }
[10:25:47.464]                         else {
[10:25:47.464]                           version <- NULL
[10:25:47.464]                         }
[10:25:47.464]                         if (!has_future || version < "1.8.0") {
[10:25:47.464]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:47.464]                             "", base::R.version$version.string), 
[10:25:47.464]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:47.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:47.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:47.464]                               "release", "version")], collapse = " "), 
[10:25:47.464]                             hostname = base::Sys.info()[["nodename"]])
[10:25:47.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:47.464]                             info)
[10:25:47.464]                           info <- base::paste(info, collapse = "; ")
[10:25:47.464]                           if (!has_future) {
[10:25:47.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:47.464]                               info)
[10:25:47.464]                           }
[10:25:47.464]                           else {
[10:25:47.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:47.464]                               info, version)
[10:25:47.464]                           }
[10:25:47.464]                           base::stop(msg)
[10:25:47.464]                         }
[10:25:47.464]                       })
[10:25:47.464]                     }
[10:25:47.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:47.464]                     base::options(mc.cores = 1L)
[10:25:47.464]                   }
[10:25:47.464]                   options(future.plan = NULL)
[10:25:47.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:47.464]                 }
[10:25:47.464]                 ...future.workdir <- getwd()
[10:25:47.464]             }
[10:25:47.464]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:47.464]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:47.464]         }
[10:25:47.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:47.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:47.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:47.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:47.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:47.464]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:47.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:47.464]             base::names(...future.oldOptions))
[10:25:47.464]     }
[10:25:47.464]     if (FALSE) {
[10:25:47.464]     }
[10:25:47.464]     else {
[10:25:47.464]         if (TRUE) {
[10:25:47.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:47.464]                 open = "w")
[10:25:47.464]         }
[10:25:47.464]         else {
[10:25:47.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:47.464]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:47.464]         }
[10:25:47.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:47.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:47.464]             base::sink(type = "output", split = FALSE)
[10:25:47.464]             base::close(...future.stdout)
[10:25:47.464]         }, add = TRUE)
[10:25:47.464]     }
[10:25:47.464]     ...future.frame <- base::sys.nframe()
[10:25:47.464]     ...future.conditions <- base::list()
[10:25:47.464]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:47.464]     if (FALSE) {
[10:25:47.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:47.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:47.464]     }
[10:25:47.464]     ...future.result <- base::tryCatch({
[10:25:47.464]         base::withCallingHandlers({
[10:25:47.464]             ...future.value <- base::withVisible(base::local({
[10:25:47.464]                 ...future.makeSendCondition <- base::local({
[10:25:47.464]                   sendCondition <- NULL
[10:25:47.464]                   function(frame = 1L) {
[10:25:47.464]                     if (is.function(sendCondition)) 
[10:25:47.464]                       return(sendCondition)
[10:25:47.464]                     ns <- getNamespace("parallel")
[10:25:47.464]                     if (exists("sendData", mode = "function", 
[10:25:47.464]                       envir = ns)) {
[10:25:47.464]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:47.464]                         envir = ns)
[10:25:47.464]                       envir <- sys.frame(frame)
[10:25:47.464]                       master <- NULL
[10:25:47.464]                       while (!identical(envir, .GlobalEnv) && 
[10:25:47.464]                         !identical(envir, emptyenv())) {
[10:25:47.464]                         if (exists("master", mode = "list", envir = envir, 
[10:25:47.464]                           inherits = FALSE)) {
[10:25:47.464]                           master <- get("master", mode = "list", 
[10:25:47.464]                             envir = envir, inherits = FALSE)
[10:25:47.464]                           if (inherits(master, c("SOCKnode", 
[10:25:47.464]                             "SOCK0node"))) {
[10:25:47.464]                             sendCondition <<- function(cond) {
[10:25:47.464]                               data <- list(type = "VALUE", value = cond, 
[10:25:47.464]                                 success = TRUE)
[10:25:47.464]                               parallel_sendData(master, data)
[10:25:47.464]                             }
[10:25:47.464]                             return(sendCondition)
[10:25:47.464]                           }
[10:25:47.464]                         }
[10:25:47.464]                         frame <- frame + 1L
[10:25:47.464]                         envir <- sys.frame(frame)
[10:25:47.464]                       }
[10:25:47.464]                     }
[10:25:47.464]                     sendCondition <<- function(cond) NULL
[10:25:47.464]                   }
[10:25:47.464]                 })
[10:25:47.464]                 withCallingHandlers({
[10:25:47.464]                   NA
[10:25:47.464]                 }, immediateCondition = function(cond) {
[10:25:47.464]                   sendCondition <- ...future.makeSendCondition()
[10:25:47.464]                   sendCondition(cond)
[10:25:47.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.464]                   {
[10:25:47.464]                     inherits <- base::inherits
[10:25:47.464]                     invokeRestart <- base::invokeRestart
[10:25:47.464]                     is.null <- base::is.null
[10:25:47.464]                     muffled <- FALSE
[10:25:47.464]                     if (inherits(cond, "message")) {
[10:25:47.464]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:47.464]                       if (muffled) 
[10:25:47.464]                         invokeRestart("muffleMessage")
[10:25:47.464]                     }
[10:25:47.464]                     else if (inherits(cond, "warning")) {
[10:25:47.464]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:47.464]                       if (muffled) 
[10:25:47.464]                         invokeRestart("muffleWarning")
[10:25:47.464]                     }
[10:25:47.464]                     else if (inherits(cond, "condition")) {
[10:25:47.464]                       if (!is.null(pattern)) {
[10:25:47.464]                         computeRestarts <- base::computeRestarts
[10:25:47.464]                         grepl <- base::grepl
[10:25:47.464]                         restarts <- computeRestarts(cond)
[10:25:47.464]                         for (restart in restarts) {
[10:25:47.464]                           name <- restart$name
[10:25:47.464]                           if (is.null(name)) 
[10:25:47.464]                             next
[10:25:47.464]                           if (!grepl(pattern, name)) 
[10:25:47.464]                             next
[10:25:47.464]                           invokeRestart(restart)
[10:25:47.464]                           muffled <- TRUE
[10:25:47.464]                           break
[10:25:47.464]                         }
[10:25:47.464]                       }
[10:25:47.464]                     }
[10:25:47.464]                     invisible(muffled)
[10:25:47.464]                   }
[10:25:47.464]                   muffleCondition(cond)
[10:25:47.464]                 })
[10:25:47.464]             }))
[10:25:47.464]             future::FutureResult(value = ...future.value$value, 
[10:25:47.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.464]                   ...future.rng), globalenv = if (FALSE) 
[10:25:47.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:47.464]                     ...future.globalenv.names))
[10:25:47.464]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:47.464]         }, condition = base::local({
[10:25:47.464]             c <- base::c
[10:25:47.464]             inherits <- base::inherits
[10:25:47.464]             invokeRestart <- base::invokeRestart
[10:25:47.464]             length <- base::length
[10:25:47.464]             list <- base::list
[10:25:47.464]             seq.int <- base::seq.int
[10:25:47.464]             signalCondition <- base::signalCondition
[10:25:47.464]             sys.calls <- base::sys.calls
[10:25:47.464]             `[[` <- base::`[[`
[10:25:47.464]             `+` <- base::`+`
[10:25:47.464]             `<<-` <- base::`<<-`
[10:25:47.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:47.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:47.464]                   3L)]
[10:25:47.464]             }
[10:25:47.464]             function(cond) {
[10:25:47.464]                 is_error <- inherits(cond, "error")
[10:25:47.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:47.464]                   NULL)
[10:25:47.464]                 if (is_error) {
[10:25:47.464]                   sessionInformation <- function() {
[10:25:47.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:47.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:47.464]                       search = base::search(), system = base::Sys.info())
[10:25:47.464]                   }
[10:25:47.464]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:47.464]                     cond$call), session = sessionInformation(), 
[10:25:47.464]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:47.464]                   signalCondition(cond)
[10:25:47.464]                 }
[10:25:47.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:47.464]                 "immediateCondition"))) {
[10:25:47.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:47.464]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:47.464]                   if (TRUE && !signal) {
[10:25:47.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.464]                     {
[10:25:47.464]                       inherits <- base::inherits
[10:25:47.464]                       invokeRestart <- base::invokeRestart
[10:25:47.464]                       is.null <- base::is.null
[10:25:47.464]                       muffled <- FALSE
[10:25:47.464]                       if (inherits(cond, "message")) {
[10:25:47.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.464]                         if (muffled) 
[10:25:47.464]                           invokeRestart("muffleMessage")
[10:25:47.464]                       }
[10:25:47.464]                       else if (inherits(cond, "warning")) {
[10:25:47.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.464]                         if (muffled) 
[10:25:47.464]                           invokeRestart("muffleWarning")
[10:25:47.464]                       }
[10:25:47.464]                       else if (inherits(cond, "condition")) {
[10:25:47.464]                         if (!is.null(pattern)) {
[10:25:47.464]                           computeRestarts <- base::computeRestarts
[10:25:47.464]                           grepl <- base::grepl
[10:25:47.464]                           restarts <- computeRestarts(cond)
[10:25:47.464]                           for (restart in restarts) {
[10:25:47.464]                             name <- restart$name
[10:25:47.464]                             if (is.null(name)) 
[10:25:47.464]                               next
[10:25:47.464]                             if (!grepl(pattern, name)) 
[10:25:47.464]                               next
[10:25:47.464]                             invokeRestart(restart)
[10:25:47.464]                             muffled <- TRUE
[10:25:47.464]                             break
[10:25:47.464]                           }
[10:25:47.464]                         }
[10:25:47.464]                       }
[10:25:47.464]                       invisible(muffled)
[10:25:47.464]                     }
[10:25:47.464]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.464]                   }
[10:25:47.464]                 }
[10:25:47.464]                 else {
[10:25:47.464]                   if (TRUE) {
[10:25:47.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.464]                     {
[10:25:47.464]                       inherits <- base::inherits
[10:25:47.464]                       invokeRestart <- base::invokeRestart
[10:25:47.464]                       is.null <- base::is.null
[10:25:47.464]                       muffled <- FALSE
[10:25:47.464]                       if (inherits(cond, "message")) {
[10:25:47.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.464]                         if (muffled) 
[10:25:47.464]                           invokeRestart("muffleMessage")
[10:25:47.464]                       }
[10:25:47.464]                       else if (inherits(cond, "warning")) {
[10:25:47.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.464]                         if (muffled) 
[10:25:47.464]                           invokeRestart("muffleWarning")
[10:25:47.464]                       }
[10:25:47.464]                       else if (inherits(cond, "condition")) {
[10:25:47.464]                         if (!is.null(pattern)) {
[10:25:47.464]                           computeRestarts <- base::computeRestarts
[10:25:47.464]                           grepl <- base::grepl
[10:25:47.464]                           restarts <- computeRestarts(cond)
[10:25:47.464]                           for (restart in restarts) {
[10:25:47.464]                             name <- restart$name
[10:25:47.464]                             if (is.null(name)) 
[10:25:47.464]                               next
[10:25:47.464]                             if (!grepl(pattern, name)) 
[10:25:47.464]                               next
[10:25:47.464]                             invokeRestart(restart)
[10:25:47.464]                             muffled <- TRUE
[10:25:47.464]                             break
[10:25:47.464]                           }
[10:25:47.464]                         }
[10:25:47.464]                       }
[10:25:47.464]                       invisible(muffled)
[10:25:47.464]                     }
[10:25:47.464]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.464]                   }
[10:25:47.464]                 }
[10:25:47.464]             }
[10:25:47.464]         }))
[10:25:47.464]     }, error = function(ex) {
[10:25:47.464]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:47.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.464]                 ...future.rng), started = ...future.startTime, 
[10:25:47.464]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:47.464]             version = "1.8"), class = "FutureResult")
[10:25:47.464]     }, finally = {
[10:25:47.464]         if (!identical(...future.workdir, getwd())) 
[10:25:47.464]             setwd(...future.workdir)
[10:25:47.464]         {
[10:25:47.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:47.464]                 ...future.oldOptions$nwarnings <- NULL
[10:25:47.464]             }
[10:25:47.464]             base::options(...future.oldOptions)
[10:25:47.464]             if (.Platform$OS.type == "windows") {
[10:25:47.464]                 old_names <- names(...future.oldEnvVars)
[10:25:47.464]                 envs <- base::Sys.getenv()
[10:25:47.464]                 names <- names(envs)
[10:25:47.464]                 common <- intersect(names, old_names)
[10:25:47.464]                 added <- setdiff(names, old_names)
[10:25:47.464]                 removed <- setdiff(old_names, names)
[10:25:47.464]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:47.464]                   envs[common]]
[10:25:47.464]                 NAMES <- toupper(changed)
[10:25:47.464]                 args <- list()
[10:25:47.464]                 for (kk in seq_along(NAMES)) {
[10:25:47.464]                   name <- changed[[kk]]
[10:25:47.464]                   NAME <- NAMES[[kk]]
[10:25:47.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.464]                     next
[10:25:47.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.464]                 }
[10:25:47.464]                 NAMES <- toupper(added)
[10:25:47.464]                 for (kk in seq_along(NAMES)) {
[10:25:47.464]                   name <- added[[kk]]
[10:25:47.464]                   NAME <- NAMES[[kk]]
[10:25:47.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.464]                     next
[10:25:47.464]                   args[[name]] <- ""
[10:25:47.464]                 }
[10:25:47.464]                 NAMES <- toupper(removed)
[10:25:47.464]                 for (kk in seq_along(NAMES)) {
[10:25:47.464]                   name <- removed[[kk]]
[10:25:47.464]                   NAME <- NAMES[[kk]]
[10:25:47.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.464]                     next
[10:25:47.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.464]                 }
[10:25:47.464]                 if (length(args) > 0) 
[10:25:47.464]                   base::do.call(base::Sys.setenv, args = args)
[10:25:47.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:47.464]             }
[10:25:47.464]             else {
[10:25:47.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:47.464]             }
[10:25:47.464]             {
[10:25:47.464]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:47.464]                   0L) {
[10:25:47.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:47.464]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:47.464]                   base::options(opts)
[10:25:47.464]                 }
[10:25:47.464]                 {
[10:25:47.464]                   {
[10:25:47.464]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:47.464]                     NULL
[10:25:47.464]                   }
[10:25:47.464]                   options(future.plan = NULL)
[10:25:47.464]                   if (is.na(NA_character_)) 
[10:25:47.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:47.464]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:47.464]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:47.464]                     envir = parent.frame()) 
[10:25:47.464]                   {
[10:25:47.464]                     if (is.function(workers)) 
[10:25:47.464]                       workers <- workers()
[10:25:47.464]                     workers <- structure(as.integer(workers), 
[10:25:47.464]                       class = class(workers))
[10:25:47.464]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:47.464]                       workers >= 1)
[10:25:47.464]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:47.464]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:47.464]                     }
[10:25:47.464]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:47.464]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:47.464]                       envir = envir)
[10:25:47.464]                     if (!future$lazy) 
[10:25:47.464]                       future <- run(future)
[10:25:47.464]                     invisible(future)
[10:25:47.464]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:47.464]                 }
[10:25:47.464]             }
[10:25:47.464]         }
[10:25:47.464]     })
[10:25:47.464]     if (TRUE) {
[10:25:47.464]         base::sink(type = "output", split = FALSE)
[10:25:47.464]         if (TRUE) {
[10:25:47.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:47.464]         }
[10:25:47.464]         else {
[10:25:47.464]             ...future.result["stdout"] <- base::list(NULL)
[10:25:47.464]         }
[10:25:47.464]         base::close(...future.stdout)
[10:25:47.464]         ...future.stdout <- NULL
[10:25:47.464]     }
[10:25:47.464]     ...future.result$conditions <- ...future.conditions
[10:25:47.464]     ...future.result$finished <- base::Sys.time()
[10:25:47.464]     ...future.result
[10:25:47.464] }
[10:25:47.516] MultisessionFuture started
[10:25:47.517] result() for ClusterFuture ...
[10:25:47.518] receiveMessageFromWorker() for ClusterFuture ...
[10:25:47.518] - Validating connection of MultisessionFuture
[10:25:47.561] - received message: FutureResult
[10:25:47.561] - Received FutureResult
[10:25:47.562] - Erased future from FutureRegistry
[10:25:47.562] result() for ClusterFuture ...
[10:25:47.562] - result already collected: FutureResult
[10:25:47.562] result() for ClusterFuture ... done
[10:25:47.562] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:47.562] result() for ClusterFuture ... done
[10:25:47.562] result() for ClusterFuture ...
[10:25:47.562] - result already collected: FutureResult
[10:25:47.563] result() for ClusterFuture ... done
[10:25:47.563] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:25:47.566] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:25:47.567] getGlobalsAndPackages() ...
[10:25:47.567] Searching for globals...
[10:25:47.567] 
[10:25:47.567] Searching for globals ... DONE
[10:25:47.567] - globals: [0] <none>
[10:25:47.568] getGlobalsAndPackages() ... DONE
[10:25:47.568] run() for ‘Future’ ...
[10:25:47.568] - state: ‘created’
[10:25:47.568] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:47.583] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:47.583] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:47.583]   - Field: ‘node’
[10:25:47.583]   - Field: ‘label’
[10:25:47.583]   - Field: ‘local’
[10:25:47.583]   - Field: ‘owner’
[10:25:47.583]   - Field: ‘envir’
[10:25:47.583]   - Field: ‘workers’
[10:25:47.584]   - Field: ‘packages’
[10:25:47.584]   - Field: ‘gc’
[10:25:47.584]   - Field: ‘conditions’
[10:25:47.584]   - Field: ‘persistent’
[10:25:47.584]   - Field: ‘expr’
[10:25:47.584]   - Field: ‘uuid’
[10:25:47.584]   - Field: ‘seed’
[10:25:47.584]   - Field: ‘version’
[10:25:47.584]   - Field: ‘result’
[10:25:47.585]   - Field: ‘asynchronous’
[10:25:47.585]   - Field: ‘calls’
[10:25:47.585]   - Field: ‘globals’
[10:25:47.585]   - Field: ‘stdout’
[10:25:47.585]   - Field: ‘earlySignal’
[10:25:47.585]   - Field: ‘lazy’
[10:25:47.585]   - Field: ‘state’
[10:25:47.585] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:47.586] - Launch lazy future ...
[10:25:47.586] Packages needed by the future expression (n = 0): <none>
[10:25:47.586] Packages needed by future strategies (n = 0): <none>
[10:25:47.587] {
[10:25:47.587]     {
[10:25:47.587]         {
[10:25:47.587]             ...future.startTime <- base::Sys.time()
[10:25:47.587]             {
[10:25:47.587]                 {
[10:25:47.587]                   {
[10:25:47.587]                     {
[10:25:47.587]                       base::local({
[10:25:47.587]                         has_future <- base::requireNamespace("future", 
[10:25:47.587]                           quietly = TRUE)
[10:25:47.587]                         if (has_future) {
[10:25:47.587]                           ns <- base::getNamespace("future")
[10:25:47.587]                           version <- ns[[".package"]][["version"]]
[10:25:47.587]                           if (is.null(version)) 
[10:25:47.587]                             version <- utils::packageVersion("future")
[10:25:47.587]                         }
[10:25:47.587]                         else {
[10:25:47.587]                           version <- NULL
[10:25:47.587]                         }
[10:25:47.587]                         if (!has_future || version < "1.8.0") {
[10:25:47.587]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:47.587]                             "", base::R.version$version.string), 
[10:25:47.587]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:47.587]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:47.587]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:47.587]                               "release", "version")], collapse = " "), 
[10:25:47.587]                             hostname = base::Sys.info()[["nodename"]])
[10:25:47.587]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:47.587]                             info)
[10:25:47.587]                           info <- base::paste(info, collapse = "; ")
[10:25:47.587]                           if (!has_future) {
[10:25:47.587]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:47.587]                               info)
[10:25:47.587]                           }
[10:25:47.587]                           else {
[10:25:47.587]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:47.587]                               info, version)
[10:25:47.587]                           }
[10:25:47.587]                           base::stop(msg)
[10:25:47.587]                         }
[10:25:47.587]                       })
[10:25:47.587]                     }
[10:25:47.587]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:47.587]                     base::options(mc.cores = 1L)
[10:25:47.587]                   }
[10:25:47.587]                   options(future.plan = NULL)
[10:25:47.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:47.587]                 }
[10:25:47.587]                 ...future.workdir <- getwd()
[10:25:47.587]             }
[10:25:47.587]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:47.587]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:47.587]         }
[10:25:47.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:47.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:47.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:47.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:47.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:47.587]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:47.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:47.587]             base::names(...future.oldOptions))
[10:25:47.587]     }
[10:25:47.587]     if (FALSE) {
[10:25:47.587]     }
[10:25:47.587]     else {
[10:25:47.587]         if (TRUE) {
[10:25:47.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:47.587]                 open = "w")
[10:25:47.587]         }
[10:25:47.587]         else {
[10:25:47.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:47.587]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:47.587]         }
[10:25:47.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:47.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:47.587]             base::sink(type = "output", split = FALSE)
[10:25:47.587]             base::close(...future.stdout)
[10:25:47.587]         }, add = TRUE)
[10:25:47.587]     }
[10:25:47.587]     ...future.frame <- base::sys.nframe()
[10:25:47.587]     ...future.conditions <- base::list()
[10:25:47.587]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:47.587]     if (FALSE) {
[10:25:47.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:47.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:47.587]     }
[10:25:47.587]     ...future.result <- base::tryCatch({
[10:25:47.587]         base::withCallingHandlers({
[10:25:47.587]             ...future.value <- base::withVisible(base::local({
[10:25:47.587]                 ...future.makeSendCondition <- base::local({
[10:25:47.587]                   sendCondition <- NULL
[10:25:47.587]                   function(frame = 1L) {
[10:25:47.587]                     if (is.function(sendCondition)) 
[10:25:47.587]                       return(sendCondition)
[10:25:47.587]                     ns <- getNamespace("parallel")
[10:25:47.587]                     if (exists("sendData", mode = "function", 
[10:25:47.587]                       envir = ns)) {
[10:25:47.587]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:47.587]                         envir = ns)
[10:25:47.587]                       envir <- sys.frame(frame)
[10:25:47.587]                       master <- NULL
[10:25:47.587]                       while (!identical(envir, .GlobalEnv) && 
[10:25:47.587]                         !identical(envir, emptyenv())) {
[10:25:47.587]                         if (exists("master", mode = "list", envir = envir, 
[10:25:47.587]                           inherits = FALSE)) {
[10:25:47.587]                           master <- get("master", mode = "list", 
[10:25:47.587]                             envir = envir, inherits = FALSE)
[10:25:47.587]                           if (inherits(master, c("SOCKnode", 
[10:25:47.587]                             "SOCK0node"))) {
[10:25:47.587]                             sendCondition <<- function(cond) {
[10:25:47.587]                               data <- list(type = "VALUE", value = cond, 
[10:25:47.587]                                 success = TRUE)
[10:25:47.587]                               parallel_sendData(master, data)
[10:25:47.587]                             }
[10:25:47.587]                             return(sendCondition)
[10:25:47.587]                           }
[10:25:47.587]                         }
[10:25:47.587]                         frame <- frame + 1L
[10:25:47.587]                         envir <- sys.frame(frame)
[10:25:47.587]                       }
[10:25:47.587]                     }
[10:25:47.587]                     sendCondition <<- function(cond) NULL
[10:25:47.587]                   }
[10:25:47.587]                 })
[10:25:47.587]                 withCallingHandlers({
[10:25:47.587]                   2
[10:25:47.587]                 }, immediateCondition = function(cond) {
[10:25:47.587]                   sendCondition <- ...future.makeSendCondition()
[10:25:47.587]                   sendCondition(cond)
[10:25:47.587]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.587]                   {
[10:25:47.587]                     inherits <- base::inherits
[10:25:47.587]                     invokeRestart <- base::invokeRestart
[10:25:47.587]                     is.null <- base::is.null
[10:25:47.587]                     muffled <- FALSE
[10:25:47.587]                     if (inherits(cond, "message")) {
[10:25:47.587]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:47.587]                       if (muffled) 
[10:25:47.587]                         invokeRestart("muffleMessage")
[10:25:47.587]                     }
[10:25:47.587]                     else if (inherits(cond, "warning")) {
[10:25:47.587]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:47.587]                       if (muffled) 
[10:25:47.587]                         invokeRestart("muffleWarning")
[10:25:47.587]                     }
[10:25:47.587]                     else if (inherits(cond, "condition")) {
[10:25:47.587]                       if (!is.null(pattern)) {
[10:25:47.587]                         computeRestarts <- base::computeRestarts
[10:25:47.587]                         grepl <- base::grepl
[10:25:47.587]                         restarts <- computeRestarts(cond)
[10:25:47.587]                         for (restart in restarts) {
[10:25:47.587]                           name <- restart$name
[10:25:47.587]                           if (is.null(name)) 
[10:25:47.587]                             next
[10:25:47.587]                           if (!grepl(pattern, name)) 
[10:25:47.587]                             next
[10:25:47.587]                           invokeRestart(restart)
[10:25:47.587]                           muffled <- TRUE
[10:25:47.587]                           break
[10:25:47.587]                         }
[10:25:47.587]                       }
[10:25:47.587]                     }
[10:25:47.587]                     invisible(muffled)
[10:25:47.587]                   }
[10:25:47.587]                   muffleCondition(cond)
[10:25:47.587]                 })
[10:25:47.587]             }))
[10:25:47.587]             future::FutureResult(value = ...future.value$value, 
[10:25:47.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.587]                   ...future.rng), globalenv = if (FALSE) 
[10:25:47.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:47.587]                     ...future.globalenv.names))
[10:25:47.587]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:47.587]         }, condition = base::local({
[10:25:47.587]             c <- base::c
[10:25:47.587]             inherits <- base::inherits
[10:25:47.587]             invokeRestart <- base::invokeRestart
[10:25:47.587]             length <- base::length
[10:25:47.587]             list <- base::list
[10:25:47.587]             seq.int <- base::seq.int
[10:25:47.587]             signalCondition <- base::signalCondition
[10:25:47.587]             sys.calls <- base::sys.calls
[10:25:47.587]             `[[` <- base::`[[`
[10:25:47.587]             `+` <- base::`+`
[10:25:47.587]             `<<-` <- base::`<<-`
[10:25:47.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:47.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:47.587]                   3L)]
[10:25:47.587]             }
[10:25:47.587]             function(cond) {
[10:25:47.587]                 is_error <- inherits(cond, "error")
[10:25:47.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:47.587]                   NULL)
[10:25:47.587]                 if (is_error) {
[10:25:47.587]                   sessionInformation <- function() {
[10:25:47.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:47.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:47.587]                       search = base::search(), system = base::Sys.info())
[10:25:47.587]                   }
[10:25:47.587]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:47.587]                     cond$call), session = sessionInformation(), 
[10:25:47.587]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:47.587]                   signalCondition(cond)
[10:25:47.587]                 }
[10:25:47.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:47.587]                 "immediateCondition"))) {
[10:25:47.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:47.587]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:47.587]                   if (TRUE && !signal) {
[10:25:47.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.587]                     {
[10:25:47.587]                       inherits <- base::inherits
[10:25:47.587]                       invokeRestart <- base::invokeRestart
[10:25:47.587]                       is.null <- base::is.null
[10:25:47.587]                       muffled <- FALSE
[10:25:47.587]                       if (inherits(cond, "message")) {
[10:25:47.587]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.587]                         if (muffled) 
[10:25:47.587]                           invokeRestart("muffleMessage")
[10:25:47.587]                       }
[10:25:47.587]                       else if (inherits(cond, "warning")) {
[10:25:47.587]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.587]                         if (muffled) 
[10:25:47.587]                           invokeRestart("muffleWarning")
[10:25:47.587]                       }
[10:25:47.587]                       else if (inherits(cond, "condition")) {
[10:25:47.587]                         if (!is.null(pattern)) {
[10:25:47.587]                           computeRestarts <- base::computeRestarts
[10:25:47.587]                           grepl <- base::grepl
[10:25:47.587]                           restarts <- computeRestarts(cond)
[10:25:47.587]                           for (restart in restarts) {
[10:25:47.587]                             name <- restart$name
[10:25:47.587]                             if (is.null(name)) 
[10:25:47.587]                               next
[10:25:47.587]                             if (!grepl(pattern, name)) 
[10:25:47.587]                               next
[10:25:47.587]                             invokeRestart(restart)
[10:25:47.587]                             muffled <- TRUE
[10:25:47.587]                             break
[10:25:47.587]                           }
[10:25:47.587]                         }
[10:25:47.587]                       }
[10:25:47.587]                       invisible(muffled)
[10:25:47.587]                     }
[10:25:47.587]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.587]                   }
[10:25:47.587]                 }
[10:25:47.587]                 else {
[10:25:47.587]                   if (TRUE) {
[10:25:47.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.587]                     {
[10:25:47.587]                       inherits <- base::inherits
[10:25:47.587]                       invokeRestart <- base::invokeRestart
[10:25:47.587]                       is.null <- base::is.null
[10:25:47.587]                       muffled <- FALSE
[10:25:47.587]                       if (inherits(cond, "message")) {
[10:25:47.587]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.587]                         if (muffled) 
[10:25:47.587]                           invokeRestart("muffleMessage")
[10:25:47.587]                       }
[10:25:47.587]                       else if (inherits(cond, "warning")) {
[10:25:47.587]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.587]                         if (muffled) 
[10:25:47.587]                           invokeRestart("muffleWarning")
[10:25:47.587]                       }
[10:25:47.587]                       else if (inherits(cond, "condition")) {
[10:25:47.587]                         if (!is.null(pattern)) {
[10:25:47.587]                           computeRestarts <- base::computeRestarts
[10:25:47.587]                           grepl <- base::grepl
[10:25:47.587]                           restarts <- computeRestarts(cond)
[10:25:47.587]                           for (restart in restarts) {
[10:25:47.587]                             name <- restart$name
[10:25:47.587]                             if (is.null(name)) 
[10:25:47.587]                               next
[10:25:47.587]                             if (!grepl(pattern, name)) 
[10:25:47.587]                               next
[10:25:47.587]                             invokeRestart(restart)
[10:25:47.587]                             muffled <- TRUE
[10:25:47.587]                             break
[10:25:47.587]                           }
[10:25:47.587]                         }
[10:25:47.587]                       }
[10:25:47.587]                       invisible(muffled)
[10:25:47.587]                     }
[10:25:47.587]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.587]                   }
[10:25:47.587]                 }
[10:25:47.587]             }
[10:25:47.587]         }))
[10:25:47.587]     }, error = function(ex) {
[10:25:47.587]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:47.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.587]                 ...future.rng), started = ...future.startTime, 
[10:25:47.587]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:47.587]             version = "1.8"), class = "FutureResult")
[10:25:47.587]     }, finally = {
[10:25:47.587]         if (!identical(...future.workdir, getwd())) 
[10:25:47.587]             setwd(...future.workdir)
[10:25:47.587]         {
[10:25:47.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:47.587]                 ...future.oldOptions$nwarnings <- NULL
[10:25:47.587]             }
[10:25:47.587]             base::options(...future.oldOptions)
[10:25:47.587]             if (.Platform$OS.type == "windows") {
[10:25:47.587]                 old_names <- names(...future.oldEnvVars)
[10:25:47.587]                 envs <- base::Sys.getenv()
[10:25:47.587]                 names <- names(envs)
[10:25:47.587]                 common <- intersect(names, old_names)
[10:25:47.587]                 added <- setdiff(names, old_names)
[10:25:47.587]                 removed <- setdiff(old_names, names)
[10:25:47.587]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:47.587]                   envs[common]]
[10:25:47.587]                 NAMES <- toupper(changed)
[10:25:47.587]                 args <- list()
[10:25:47.587]                 for (kk in seq_along(NAMES)) {
[10:25:47.587]                   name <- changed[[kk]]
[10:25:47.587]                   NAME <- NAMES[[kk]]
[10:25:47.587]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.587]                     next
[10:25:47.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.587]                 }
[10:25:47.587]                 NAMES <- toupper(added)
[10:25:47.587]                 for (kk in seq_along(NAMES)) {
[10:25:47.587]                   name <- added[[kk]]
[10:25:47.587]                   NAME <- NAMES[[kk]]
[10:25:47.587]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.587]                     next
[10:25:47.587]                   args[[name]] <- ""
[10:25:47.587]                 }
[10:25:47.587]                 NAMES <- toupper(removed)
[10:25:47.587]                 for (kk in seq_along(NAMES)) {
[10:25:47.587]                   name <- removed[[kk]]
[10:25:47.587]                   NAME <- NAMES[[kk]]
[10:25:47.587]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.587]                     next
[10:25:47.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.587]                 }
[10:25:47.587]                 if (length(args) > 0) 
[10:25:47.587]                   base::do.call(base::Sys.setenv, args = args)
[10:25:47.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:47.587]             }
[10:25:47.587]             else {
[10:25:47.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:47.587]             }
[10:25:47.587]             {
[10:25:47.587]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:47.587]                   0L) {
[10:25:47.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:47.587]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:47.587]                   base::options(opts)
[10:25:47.587]                 }
[10:25:47.587]                 {
[10:25:47.587]                   {
[10:25:47.587]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:47.587]                     NULL
[10:25:47.587]                   }
[10:25:47.587]                   options(future.plan = NULL)
[10:25:47.587]                   if (is.na(NA_character_)) 
[10:25:47.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:47.587]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:47.587]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:47.587]                     envir = parent.frame()) 
[10:25:47.587]                   {
[10:25:47.587]                     if (is.function(workers)) 
[10:25:47.587]                       workers <- workers()
[10:25:47.587]                     workers <- structure(as.integer(workers), 
[10:25:47.587]                       class = class(workers))
[10:25:47.587]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:47.587]                       workers >= 1)
[10:25:47.587]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:47.587]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:47.587]                     }
[10:25:47.587]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:47.587]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:47.587]                       envir = envir)
[10:25:47.587]                     if (!future$lazy) 
[10:25:47.587]                       future <- run(future)
[10:25:47.587]                     invisible(future)
[10:25:47.587]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:47.587]                 }
[10:25:47.587]             }
[10:25:47.587]         }
[10:25:47.587]     })
[10:25:47.587]     if (TRUE) {
[10:25:47.587]         base::sink(type = "output", split = FALSE)
[10:25:47.587]         if (TRUE) {
[10:25:47.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:47.587]         }
[10:25:47.587]         else {
[10:25:47.587]             ...future.result["stdout"] <- base::list(NULL)
[10:25:47.587]         }
[10:25:47.587]         base::close(...future.stdout)
[10:25:47.587]         ...future.stdout <- NULL
[10:25:47.587]     }
[10:25:47.587]     ...future.result$conditions <- ...future.conditions
[10:25:47.587]     ...future.result$finished <- base::Sys.time()
[10:25:47.587]     ...future.result
[10:25:47.587] }
[10:25:47.590] MultisessionFuture started
[10:25:47.590] - Launch lazy future ... done
[10:25:47.590] run() for ‘MultisessionFuture’ ... done
[10:25:47.591] getGlobalsAndPackages() ...
[10:25:47.591] Searching for globals...
[10:25:47.591] 
[10:25:47.591] Searching for globals ... DONE
[10:25:47.591] - globals: [0] <none>
[10:25:47.591] getGlobalsAndPackages() ... DONE
[10:25:47.592] run() for ‘Future’ ...
[10:25:47.592] - state: ‘created’
[10:25:47.592] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:47.606] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:47.606] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:47.606]   - Field: ‘node’
[10:25:47.606]   - Field: ‘label’
[10:25:47.607]   - Field: ‘local’
[10:25:47.607]   - Field: ‘owner’
[10:25:47.607]   - Field: ‘envir’
[10:25:47.607]   - Field: ‘workers’
[10:25:47.607]   - Field: ‘packages’
[10:25:47.607]   - Field: ‘gc’
[10:25:47.607]   - Field: ‘conditions’
[10:25:47.607]   - Field: ‘persistent’
[10:25:47.607]   - Field: ‘expr’
[10:25:47.607]   - Field: ‘uuid’
[10:25:47.608]   - Field: ‘seed’
[10:25:47.608]   - Field: ‘version’
[10:25:47.608]   - Field: ‘result’
[10:25:47.608]   - Field: ‘asynchronous’
[10:25:47.608]   - Field: ‘calls’
[10:25:47.608]   - Field: ‘globals’
[10:25:47.608]   - Field: ‘stdout’
[10:25:47.608]   - Field: ‘earlySignal’
[10:25:47.608]   - Field: ‘lazy’
[10:25:47.609]   - Field: ‘state’
[10:25:47.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:47.609] - Launch lazy future ...
[10:25:47.609] Packages needed by the future expression (n = 0): <none>
[10:25:47.609] Packages needed by future strategies (n = 0): <none>
[10:25:47.610] {
[10:25:47.610]     {
[10:25:47.610]         {
[10:25:47.610]             ...future.startTime <- base::Sys.time()
[10:25:47.610]             {
[10:25:47.610]                 {
[10:25:47.610]                   {
[10:25:47.610]                     {
[10:25:47.610]                       base::local({
[10:25:47.610]                         has_future <- base::requireNamespace("future", 
[10:25:47.610]                           quietly = TRUE)
[10:25:47.610]                         if (has_future) {
[10:25:47.610]                           ns <- base::getNamespace("future")
[10:25:47.610]                           version <- ns[[".package"]][["version"]]
[10:25:47.610]                           if (is.null(version)) 
[10:25:47.610]                             version <- utils::packageVersion("future")
[10:25:47.610]                         }
[10:25:47.610]                         else {
[10:25:47.610]                           version <- NULL
[10:25:47.610]                         }
[10:25:47.610]                         if (!has_future || version < "1.8.0") {
[10:25:47.610]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:47.610]                             "", base::R.version$version.string), 
[10:25:47.610]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:47.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:47.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:47.610]                               "release", "version")], collapse = " "), 
[10:25:47.610]                             hostname = base::Sys.info()[["nodename"]])
[10:25:47.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:47.610]                             info)
[10:25:47.610]                           info <- base::paste(info, collapse = "; ")
[10:25:47.610]                           if (!has_future) {
[10:25:47.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:47.610]                               info)
[10:25:47.610]                           }
[10:25:47.610]                           else {
[10:25:47.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:47.610]                               info, version)
[10:25:47.610]                           }
[10:25:47.610]                           base::stop(msg)
[10:25:47.610]                         }
[10:25:47.610]                       })
[10:25:47.610]                     }
[10:25:47.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:47.610]                     base::options(mc.cores = 1L)
[10:25:47.610]                   }
[10:25:47.610]                   options(future.plan = NULL)
[10:25:47.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:47.610]                 }
[10:25:47.610]                 ...future.workdir <- getwd()
[10:25:47.610]             }
[10:25:47.610]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:47.610]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:47.610]         }
[10:25:47.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:47.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:47.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:47.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:47.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:47.610]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:47.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:47.610]             base::names(...future.oldOptions))
[10:25:47.610]     }
[10:25:47.610]     if (FALSE) {
[10:25:47.610]     }
[10:25:47.610]     else {
[10:25:47.610]         if (TRUE) {
[10:25:47.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:47.610]                 open = "w")
[10:25:47.610]         }
[10:25:47.610]         else {
[10:25:47.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:47.610]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:47.610]         }
[10:25:47.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:47.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:47.610]             base::sink(type = "output", split = FALSE)
[10:25:47.610]             base::close(...future.stdout)
[10:25:47.610]         }, add = TRUE)
[10:25:47.610]     }
[10:25:47.610]     ...future.frame <- base::sys.nframe()
[10:25:47.610]     ...future.conditions <- base::list()
[10:25:47.610]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:47.610]     if (FALSE) {
[10:25:47.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:47.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:47.610]     }
[10:25:47.610]     ...future.result <- base::tryCatch({
[10:25:47.610]         base::withCallingHandlers({
[10:25:47.610]             ...future.value <- base::withVisible(base::local({
[10:25:47.610]                 ...future.makeSendCondition <- base::local({
[10:25:47.610]                   sendCondition <- NULL
[10:25:47.610]                   function(frame = 1L) {
[10:25:47.610]                     if (is.function(sendCondition)) 
[10:25:47.610]                       return(sendCondition)
[10:25:47.610]                     ns <- getNamespace("parallel")
[10:25:47.610]                     if (exists("sendData", mode = "function", 
[10:25:47.610]                       envir = ns)) {
[10:25:47.610]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:47.610]                         envir = ns)
[10:25:47.610]                       envir <- sys.frame(frame)
[10:25:47.610]                       master <- NULL
[10:25:47.610]                       while (!identical(envir, .GlobalEnv) && 
[10:25:47.610]                         !identical(envir, emptyenv())) {
[10:25:47.610]                         if (exists("master", mode = "list", envir = envir, 
[10:25:47.610]                           inherits = FALSE)) {
[10:25:47.610]                           master <- get("master", mode = "list", 
[10:25:47.610]                             envir = envir, inherits = FALSE)
[10:25:47.610]                           if (inherits(master, c("SOCKnode", 
[10:25:47.610]                             "SOCK0node"))) {
[10:25:47.610]                             sendCondition <<- function(cond) {
[10:25:47.610]                               data <- list(type = "VALUE", value = cond, 
[10:25:47.610]                                 success = TRUE)
[10:25:47.610]                               parallel_sendData(master, data)
[10:25:47.610]                             }
[10:25:47.610]                             return(sendCondition)
[10:25:47.610]                           }
[10:25:47.610]                         }
[10:25:47.610]                         frame <- frame + 1L
[10:25:47.610]                         envir <- sys.frame(frame)
[10:25:47.610]                       }
[10:25:47.610]                     }
[10:25:47.610]                     sendCondition <<- function(cond) NULL
[10:25:47.610]                   }
[10:25:47.610]                 })
[10:25:47.610]                 withCallingHandlers({
[10:25:47.610]                   NULL
[10:25:47.610]                 }, immediateCondition = function(cond) {
[10:25:47.610]                   sendCondition <- ...future.makeSendCondition()
[10:25:47.610]                   sendCondition(cond)
[10:25:47.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.610]                   {
[10:25:47.610]                     inherits <- base::inherits
[10:25:47.610]                     invokeRestart <- base::invokeRestart
[10:25:47.610]                     is.null <- base::is.null
[10:25:47.610]                     muffled <- FALSE
[10:25:47.610]                     if (inherits(cond, "message")) {
[10:25:47.610]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:47.610]                       if (muffled) 
[10:25:47.610]                         invokeRestart("muffleMessage")
[10:25:47.610]                     }
[10:25:47.610]                     else if (inherits(cond, "warning")) {
[10:25:47.610]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:47.610]                       if (muffled) 
[10:25:47.610]                         invokeRestart("muffleWarning")
[10:25:47.610]                     }
[10:25:47.610]                     else if (inherits(cond, "condition")) {
[10:25:47.610]                       if (!is.null(pattern)) {
[10:25:47.610]                         computeRestarts <- base::computeRestarts
[10:25:47.610]                         grepl <- base::grepl
[10:25:47.610]                         restarts <- computeRestarts(cond)
[10:25:47.610]                         for (restart in restarts) {
[10:25:47.610]                           name <- restart$name
[10:25:47.610]                           if (is.null(name)) 
[10:25:47.610]                             next
[10:25:47.610]                           if (!grepl(pattern, name)) 
[10:25:47.610]                             next
[10:25:47.610]                           invokeRestart(restart)
[10:25:47.610]                           muffled <- TRUE
[10:25:47.610]                           break
[10:25:47.610]                         }
[10:25:47.610]                       }
[10:25:47.610]                     }
[10:25:47.610]                     invisible(muffled)
[10:25:47.610]                   }
[10:25:47.610]                   muffleCondition(cond)
[10:25:47.610]                 })
[10:25:47.610]             }))
[10:25:47.610]             future::FutureResult(value = ...future.value$value, 
[10:25:47.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.610]                   ...future.rng), globalenv = if (FALSE) 
[10:25:47.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:47.610]                     ...future.globalenv.names))
[10:25:47.610]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:47.610]         }, condition = base::local({
[10:25:47.610]             c <- base::c
[10:25:47.610]             inherits <- base::inherits
[10:25:47.610]             invokeRestart <- base::invokeRestart
[10:25:47.610]             length <- base::length
[10:25:47.610]             list <- base::list
[10:25:47.610]             seq.int <- base::seq.int
[10:25:47.610]             signalCondition <- base::signalCondition
[10:25:47.610]             sys.calls <- base::sys.calls
[10:25:47.610]             `[[` <- base::`[[`
[10:25:47.610]             `+` <- base::`+`
[10:25:47.610]             `<<-` <- base::`<<-`
[10:25:47.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:47.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:47.610]                   3L)]
[10:25:47.610]             }
[10:25:47.610]             function(cond) {
[10:25:47.610]                 is_error <- inherits(cond, "error")
[10:25:47.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:47.610]                   NULL)
[10:25:47.610]                 if (is_error) {
[10:25:47.610]                   sessionInformation <- function() {
[10:25:47.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:47.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:47.610]                       search = base::search(), system = base::Sys.info())
[10:25:47.610]                   }
[10:25:47.610]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:47.610]                     cond$call), session = sessionInformation(), 
[10:25:47.610]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:47.610]                   signalCondition(cond)
[10:25:47.610]                 }
[10:25:47.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:47.610]                 "immediateCondition"))) {
[10:25:47.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:47.610]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:47.610]                   if (TRUE && !signal) {
[10:25:47.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.610]                     {
[10:25:47.610]                       inherits <- base::inherits
[10:25:47.610]                       invokeRestart <- base::invokeRestart
[10:25:47.610]                       is.null <- base::is.null
[10:25:47.610]                       muffled <- FALSE
[10:25:47.610]                       if (inherits(cond, "message")) {
[10:25:47.610]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.610]                         if (muffled) 
[10:25:47.610]                           invokeRestart("muffleMessage")
[10:25:47.610]                       }
[10:25:47.610]                       else if (inherits(cond, "warning")) {
[10:25:47.610]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.610]                         if (muffled) 
[10:25:47.610]                           invokeRestart("muffleWarning")
[10:25:47.610]                       }
[10:25:47.610]                       else if (inherits(cond, "condition")) {
[10:25:47.610]                         if (!is.null(pattern)) {
[10:25:47.610]                           computeRestarts <- base::computeRestarts
[10:25:47.610]                           grepl <- base::grepl
[10:25:47.610]                           restarts <- computeRestarts(cond)
[10:25:47.610]                           for (restart in restarts) {
[10:25:47.610]                             name <- restart$name
[10:25:47.610]                             if (is.null(name)) 
[10:25:47.610]                               next
[10:25:47.610]                             if (!grepl(pattern, name)) 
[10:25:47.610]                               next
[10:25:47.610]                             invokeRestart(restart)
[10:25:47.610]                             muffled <- TRUE
[10:25:47.610]                             break
[10:25:47.610]                           }
[10:25:47.610]                         }
[10:25:47.610]                       }
[10:25:47.610]                       invisible(muffled)
[10:25:47.610]                     }
[10:25:47.610]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.610]                   }
[10:25:47.610]                 }
[10:25:47.610]                 else {
[10:25:47.610]                   if (TRUE) {
[10:25:47.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.610]                     {
[10:25:47.610]                       inherits <- base::inherits
[10:25:47.610]                       invokeRestart <- base::invokeRestart
[10:25:47.610]                       is.null <- base::is.null
[10:25:47.610]                       muffled <- FALSE
[10:25:47.610]                       if (inherits(cond, "message")) {
[10:25:47.610]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.610]                         if (muffled) 
[10:25:47.610]                           invokeRestart("muffleMessage")
[10:25:47.610]                       }
[10:25:47.610]                       else if (inherits(cond, "warning")) {
[10:25:47.610]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.610]                         if (muffled) 
[10:25:47.610]                           invokeRestart("muffleWarning")
[10:25:47.610]                       }
[10:25:47.610]                       else if (inherits(cond, "condition")) {
[10:25:47.610]                         if (!is.null(pattern)) {
[10:25:47.610]                           computeRestarts <- base::computeRestarts
[10:25:47.610]                           grepl <- base::grepl
[10:25:47.610]                           restarts <- computeRestarts(cond)
[10:25:47.610]                           for (restart in restarts) {
[10:25:47.610]                             name <- restart$name
[10:25:47.610]                             if (is.null(name)) 
[10:25:47.610]                               next
[10:25:47.610]                             if (!grepl(pattern, name)) 
[10:25:47.610]                               next
[10:25:47.610]                             invokeRestart(restart)
[10:25:47.610]                             muffled <- TRUE
[10:25:47.610]                             break
[10:25:47.610]                           }
[10:25:47.610]                         }
[10:25:47.610]                       }
[10:25:47.610]                       invisible(muffled)
[10:25:47.610]                     }
[10:25:47.610]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.610]                   }
[10:25:47.610]                 }
[10:25:47.610]             }
[10:25:47.610]         }))
[10:25:47.610]     }, error = function(ex) {
[10:25:47.610]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:47.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.610]                 ...future.rng), started = ...future.startTime, 
[10:25:47.610]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:47.610]             version = "1.8"), class = "FutureResult")
[10:25:47.610]     }, finally = {
[10:25:47.610]         if (!identical(...future.workdir, getwd())) 
[10:25:47.610]             setwd(...future.workdir)
[10:25:47.610]         {
[10:25:47.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:47.610]                 ...future.oldOptions$nwarnings <- NULL
[10:25:47.610]             }
[10:25:47.610]             base::options(...future.oldOptions)
[10:25:47.610]             if (.Platform$OS.type == "windows") {
[10:25:47.610]                 old_names <- names(...future.oldEnvVars)
[10:25:47.610]                 envs <- base::Sys.getenv()
[10:25:47.610]                 names <- names(envs)
[10:25:47.610]                 common <- intersect(names, old_names)
[10:25:47.610]                 added <- setdiff(names, old_names)
[10:25:47.610]                 removed <- setdiff(old_names, names)
[10:25:47.610]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:47.610]                   envs[common]]
[10:25:47.610]                 NAMES <- toupper(changed)
[10:25:47.610]                 args <- list()
[10:25:47.610]                 for (kk in seq_along(NAMES)) {
[10:25:47.610]                   name <- changed[[kk]]
[10:25:47.610]                   NAME <- NAMES[[kk]]
[10:25:47.610]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.610]                     next
[10:25:47.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.610]                 }
[10:25:47.610]                 NAMES <- toupper(added)
[10:25:47.610]                 for (kk in seq_along(NAMES)) {
[10:25:47.610]                   name <- added[[kk]]
[10:25:47.610]                   NAME <- NAMES[[kk]]
[10:25:47.610]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.610]                     next
[10:25:47.610]                   args[[name]] <- ""
[10:25:47.610]                 }
[10:25:47.610]                 NAMES <- toupper(removed)
[10:25:47.610]                 for (kk in seq_along(NAMES)) {
[10:25:47.610]                   name <- removed[[kk]]
[10:25:47.610]                   NAME <- NAMES[[kk]]
[10:25:47.610]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.610]                     next
[10:25:47.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.610]                 }
[10:25:47.610]                 if (length(args) > 0) 
[10:25:47.610]                   base::do.call(base::Sys.setenv, args = args)
[10:25:47.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:47.610]             }
[10:25:47.610]             else {
[10:25:47.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:47.610]             }
[10:25:47.610]             {
[10:25:47.610]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:47.610]                   0L) {
[10:25:47.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:47.610]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:47.610]                   base::options(opts)
[10:25:47.610]                 }
[10:25:47.610]                 {
[10:25:47.610]                   {
[10:25:47.610]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:47.610]                     NULL
[10:25:47.610]                   }
[10:25:47.610]                   options(future.plan = NULL)
[10:25:47.610]                   if (is.na(NA_character_)) 
[10:25:47.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:47.610]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:47.610]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:47.610]                     envir = parent.frame()) 
[10:25:47.610]                   {
[10:25:47.610]                     if (is.function(workers)) 
[10:25:47.610]                       workers <- workers()
[10:25:47.610]                     workers <- structure(as.integer(workers), 
[10:25:47.610]                       class = class(workers))
[10:25:47.610]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:47.610]                       workers >= 1)
[10:25:47.610]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:47.610]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:47.610]                     }
[10:25:47.610]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:47.610]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:47.610]                       envir = envir)
[10:25:47.610]                     if (!future$lazy) 
[10:25:47.610]                       future <- run(future)
[10:25:47.610]                     invisible(future)
[10:25:47.610]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:47.610]                 }
[10:25:47.610]             }
[10:25:47.610]         }
[10:25:47.610]     })
[10:25:47.610]     if (TRUE) {
[10:25:47.610]         base::sink(type = "output", split = FALSE)
[10:25:47.610]         if (TRUE) {
[10:25:47.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:47.610]         }
[10:25:47.610]         else {
[10:25:47.610]             ...future.result["stdout"] <- base::list(NULL)
[10:25:47.610]         }
[10:25:47.610]         base::close(...future.stdout)
[10:25:47.610]         ...future.stdout <- NULL
[10:25:47.610]     }
[10:25:47.610]     ...future.result$conditions <- ...future.conditions
[10:25:47.610]     ...future.result$finished <- base::Sys.time()
[10:25:47.610]     ...future.result
[10:25:47.610] }
[10:25:47.664] MultisessionFuture started
[10:25:47.664] - Launch lazy future ... done
[10:25:47.665] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f6297498> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f6703a18> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f6297498> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f6703a18> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:25:47.670] receiveMessageFromWorker() for ClusterFuture ...
[10:25:47.670] - Validating connection of MultisessionFuture
[10:25:47.671] - received message: FutureResult
[10:25:47.671] - Received FutureResult
[10:25:47.671] - Erased future from FutureRegistry
[10:25:47.671] result() for ClusterFuture ...
[10:25:47.671] - result already collected: FutureResult
[10:25:47.671] result() for ClusterFuture ... done
[10:25:47.671] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:47.683] resolve() on list ...
[10:25:47.683]  recursive: 0
[10:25:47.683]  length: 6
[10:25:47.683]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:47.683] signalConditionsASAP(numeric, pos=1) ...
[10:25:47.683] - nx: 6
[10:25:47.684] - relay: TRUE
[10:25:47.684] - stdout: TRUE
[10:25:47.684] - signal: TRUE
[10:25:47.684] - resignal: FALSE
[10:25:47.684] - force: TRUE
[10:25:47.684] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.684] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.684]  - until=2
[10:25:47.684]  - relaying element #2
[10:25:47.685] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.685] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.685] signalConditionsASAP(NULL, pos=1) ... done
[10:25:47.685]  length: 5 (resolved future 1)
[10:25:47.685] Future #2
[10:25:47.685] result() for ClusterFuture ...
[10:25:47.685] - result already collected: FutureResult
[10:25:47.685] result() for ClusterFuture ... done
[10:25:47.686] result() for ClusterFuture ...
[10:25:47.686] - result already collected: FutureResult
[10:25:47.686] result() for ClusterFuture ... done
[10:25:47.686] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:47.686] - nx: 6
[10:25:47.686] - relay: TRUE
[10:25:47.686] - stdout: TRUE
[10:25:47.686] - signal: TRUE
[10:25:47.686] - resignal: FALSE
[10:25:47.687] - force: TRUE
[10:25:47.687] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.687] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.687]  - until=2
[10:25:47.687]  - relaying element #2
[10:25:47.687] result() for ClusterFuture ...
[10:25:47.687] - result already collected: FutureResult
[10:25:47.687] result() for ClusterFuture ... done
[10:25:47.687] result() for ClusterFuture ...
[10:25:47.688] - result already collected: FutureResult
[10:25:47.688] result() for ClusterFuture ... done
[10:25:47.688] result() for ClusterFuture ...
[10:25:47.688] - result already collected: FutureResult
[10:25:47.688] result() for ClusterFuture ... done
[10:25:47.688] result() for ClusterFuture ...
[10:25:47.688] - result already collected: FutureResult
[10:25:47.688] result() for ClusterFuture ... done
[10:25:47.688] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.689] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.689] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:47.689]  length: 4 (resolved future 2)
[10:25:47.699] signalConditionsASAP(NULL, pos=4) ...
[10:25:47.700] - nx: 6
[10:25:47.700] - relay: TRUE
[10:25:47.700] - stdout: TRUE
[10:25:47.700] - signal: TRUE
[10:25:47.700] - resignal: FALSE
[10:25:47.700] - force: TRUE
[10:25:47.700] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.701] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.701]  - until=5
[10:25:47.701]  - relaying element #3
[10:25:47.701]  - relaying element #5
[10:25:47.701] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[10:25:47.701] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.702] signalConditionsASAP(NULL, pos=4) ... done
[10:25:47.702]  length: 3 (resolved future 4)
[10:25:47.702] signalConditionsASAP(NULL, pos=5) ...
[10:25:47.702] - nx: 6
[10:25:47.702] - relay: TRUE
[10:25:47.702] - stdout: TRUE
[10:25:47.702] - signal: TRUE
[10:25:47.702] - resignal: FALSE
[10:25:47.703] - force: TRUE
[10:25:47.703] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[10:25:47.703] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.703]  - until=6
[10:25:47.703]  - relaying element #3
[10:25:47.703]  - relaying element #6
[10:25:47.703] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[10:25:47.704] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.704] signalConditionsASAP(NULL, pos=5) ... done
[10:25:47.704]  length: 2 (resolved future 5)
[10:25:47.704] signalConditionsASAP(numeric, pos=6) ...
[10:25:47.704] - nx: 6
[10:25:47.704] - relay: TRUE
[10:25:47.704] - stdout: TRUE
[10:25:47.704] - signal: TRUE
[10:25:47.704] - resignal: FALSE
[10:25:47.705] - force: TRUE
[10:25:47.705] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[10:25:47.705] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.705]  - until=6
[10:25:47.705]  - relaying element #3
[10:25:47.705] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[10:25:47.705] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.705] signalConditionsASAP(NULL, pos=6) ... done
[10:25:47.706]  length: 1 (resolved future 6)
[10:25:47.716] receiveMessageFromWorker() for ClusterFuture ...
[10:25:47.717] - Validating connection of MultisessionFuture
[10:25:47.717] - received message: FutureResult
[10:25:47.717] - Received FutureResult
[10:25:47.717] - Erased future from FutureRegistry
[10:25:47.717] result() for ClusterFuture ...
[10:25:47.717] - result already collected: FutureResult
[10:25:47.717] result() for ClusterFuture ... done
[10:25:47.718] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:47.718] Future #3
[10:25:47.718] result() for ClusterFuture ...
[10:25:47.718] - result already collected: FutureResult
[10:25:47.718] result() for ClusterFuture ... done
[10:25:47.718] result() for ClusterFuture ...
[10:25:47.718] - result already collected: FutureResult
[10:25:47.718] result() for ClusterFuture ... done
[10:25:47.718] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:47.719] - nx: 6
[10:25:47.719] - relay: TRUE
[10:25:47.719] - stdout: TRUE
[10:25:47.719] - signal: TRUE
[10:25:47.719] - resignal: FALSE
[10:25:47.719] - force: TRUE
[10:25:47.719] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[10:25:47.719] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.719]  - until=6
[10:25:47.720]  - relaying element #3
[10:25:47.720] result() for ClusterFuture ...
[10:25:47.720] - result already collected: FutureResult
[10:25:47.720] result() for ClusterFuture ... done
[10:25:47.720] result() for ClusterFuture ...
[10:25:47.720] - result already collected: FutureResult
[10:25:47.720] result() for ClusterFuture ... done
[10:25:47.720] result() for ClusterFuture ...
[10:25:47.720] - result already collected: FutureResult
[10:25:47.721] result() for ClusterFuture ... done
[10:25:47.721] result() for ClusterFuture ...
[10:25:47.721] - result already collected: FutureResult
[10:25:47.721] result() for ClusterFuture ... done
[10:25:47.721] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:47.721] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.721] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:47.721]  length: 0 (resolved future 3)
[10:25:47.724] Relaying remaining futures
[10:25:47.724] signalConditionsASAP(NULL, pos=0) ...
[10:25:47.724] - nx: 6
[10:25:47.724] - relay: TRUE
[10:25:47.724] - stdout: TRUE
[10:25:47.724] - signal: TRUE
[10:25:47.724] - resignal: FALSE
[10:25:47.724] - force: TRUE
[10:25:47.724] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:47.725] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:47.725] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:47.725] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.725] signalConditionsASAP(NULL, pos=0) ... done
[10:25:47.725] resolve() on list ... DONE
[10:25:47.725] result() for ClusterFuture ...
[10:25:47.725] - result already collected: FutureResult
[10:25:47.725] result() for ClusterFuture ... done
[10:25:47.725] result() for ClusterFuture ...
[10:25:47.725] - result already collected: FutureResult
[10:25:47.725] result() for ClusterFuture ... done
[10:25:47.726] result() for ClusterFuture ...
[10:25:47.726] - result already collected: FutureResult
[10:25:47.726] result() for ClusterFuture ... done
[10:25:47.726] result() for ClusterFuture ...
[10:25:47.726] - result already collected: FutureResult
[10:25:47.726] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[10:25:47.728] getGlobalsAndPackages() ...
[10:25:47.728] Searching for globals...
[10:25:47.729] 
[10:25:47.729] Searching for globals ... DONE
[10:25:47.729] - globals: [0] <none>
[10:25:47.729] getGlobalsAndPackages() ... DONE
[10:25:47.729] run() for ‘Future’ ...
[10:25:47.729] - state: ‘created’
[10:25:47.729] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:47.743] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:47.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:47.743]   - Field: ‘node’
[10:25:47.744]   - Field: ‘label’
[10:25:47.744]   - Field: ‘local’
[10:25:47.744]   - Field: ‘owner’
[10:25:47.744]   - Field: ‘envir’
[10:25:47.744]   - Field: ‘workers’
[10:25:47.744]   - Field: ‘packages’
[10:25:47.744]   - Field: ‘gc’
[10:25:47.744]   - Field: ‘conditions’
[10:25:47.744]   - Field: ‘persistent’
[10:25:47.744]   - Field: ‘expr’
[10:25:47.744]   - Field: ‘uuid’
[10:25:47.745]   - Field: ‘seed’
[10:25:47.745]   - Field: ‘version’
[10:25:47.745]   - Field: ‘result’
[10:25:47.745]   - Field: ‘asynchronous’
[10:25:47.745]   - Field: ‘calls’
[10:25:47.745]   - Field: ‘globals’
[10:25:47.745]   - Field: ‘stdout’
[10:25:47.745]   - Field: ‘earlySignal’
[10:25:47.745]   - Field: ‘lazy’
[10:25:47.745]   - Field: ‘state’
[10:25:47.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:47.746] - Launch lazy future ...
[10:25:47.746] Packages needed by the future expression (n = 0): <none>
[10:25:47.746] Packages needed by future strategies (n = 0): <none>
[10:25:47.746] {
[10:25:47.746]     {
[10:25:47.746]         {
[10:25:47.746]             ...future.startTime <- base::Sys.time()
[10:25:47.746]             {
[10:25:47.746]                 {
[10:25:47.746]                   {
[10:25:47.746]                     {
[10:25:47.746]                       base::local({
[10:25:47.746]                         has_future <- base::requireNamespace("future", 
[10:25:47.746]                           quietly = TRUE)
[10:25:47.746]                         if (has_future) {
[10:25:47.746]                           ns <- base::getNamespace("future")
[10:25:47.746]                           version <- ns[[".package"]][["version"]]
[10:25:47.746]                           if (is.null(version)) 
[10:25:47.746]                             version <- utils::packageVersion("future")
[10:25:47.746]                         }
[10:25:47.746]                         else {
[10:25:47.746]                           version <- NULL
[10:25:47.746]                         }
[10:25:47.746]                         if (!has_future || version < "1.8.0") {
[10:25:47.746]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:47.746]                             "", base::R.version$version.string), 
[10:25:47.746]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:47.746]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:47.746]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:47.746]                               "release", "version")], collapse = " "), 
[10:25:47.746]                             hostname = base::Sys.info()[["nodename"]])
[10:25:47.746]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:47.746]                             info)
[10:25:47.746]                           info <- base::paste(info, collapse = "; ")
[10:25:47.746]                           if (!has_future) {
[10:25:47.746]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:47.746]                               info)
[10:25:47.746]                           }
[10:25:47.746]                           else {
[10:25:47.746]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:47.746]                               info, version)
[10:25:47.746]                           }
[10:25:47.746]                           base::stop(msg)
[10:25:47.746]                         }
[10:25:47.746]                       })
[10:25:47.746]                     }
[10:25:47.746]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:47.746]                     base::options(mc.cores = 1L)
[10:25:47.746]                   }
[10:25:47.746]                   options(future.plan = NULL)
[10:25:47.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:47.746]                 }
[10:25:47.746]                 ...future.workdir <- getwd()
[10:25:47.746]             }
[10:25:47.746]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:47.746]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:47.746]         }
[10:25:47.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:47.746]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:47.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:47.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:47.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:47.746]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:47.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:47.746]             base::names(...future.oldOptions))
[10:25:47.746]     }
[10:25:47.746]     if (FALSE) {
[10:25:47.746]     }
[10:25:47.746]     else {
[10:25:47.746]         if (TRUE) {
[10:25:47.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:47.746]                 open = "w")
[10:25:47.746]         }
[10:25:47.746]         else {
[10:25:47.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:47.746]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:47.746]         }
[10:25:47.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:47.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:47.746]             base::sink(type = "output", split = FALSE)
[10:25:47.746]             base::close(...future.stdout)
[10:25:47.746]         }, add = TRUE)
[10:25:47.746]     }
[10:25:47.746]     ...future.frame <- base::sys.nframe()
[10:25:47.746]     ...future.conditions <- base::list()
[10:25:47.746]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:47.746]     if (FALSE) {
[10:25:47.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:47.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:47.746]     }
[10:25:47.746]     ...future.result <- base::tryCatch({
[10:25:47.746]         base::withCallingHandlers({
[10:25:47.746]             ...future.value <- base::withVisible(base::local({
[10:25:47.746]                 ...future.makeSendCondition <- base::local({
[10:25:47.746]                   sendCondition <- NULL
[10:25:47.746]                   function(frame = 1L) {
[10:25:47.746]                     if (is.function(sendCondition)) 
[10:25:47.746]                       return(sendCondition)
[10:25:47.746]                     ns <- getNamespace("parallel")
[10:25:47.746]                     if (exists("sendData", mode = "function", 
[10:25:47.746]                       envir = ns)) {
[10:25:47.746]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:47.746]                         envir = ns)
[10:25:47.746]                       envir <- sys.frame(frame)
[10:25:47.746]                       master <- NULL
[10:25:47.746]                       while (!identical(envir, .GlobalEnv) && 
[10:25:47.746]                         !identical(envir, emptyenv())) {
[10:25:47.746]                         if (exists("master", mode = "list", envir = envir, 
[10:25:47.746]                           inherits = FALSE)) {
[10:25:47.746]                           master <- get("master", mode = "list", 
[10:25:47.746]                             envir = envir, inherits = FALSE)
[10:25:47.746]                           if (inherits(master, c("SOCKnode", 
[10:25:47.746]                             "SOCK0node"))) {
[10:25:47.746]                             sendCondition <<- function(cond) {
[10:25:47.746]                               data <- list(type = "VALUE", value = cond, 
[10:25:47.746]                                 success = TRUE)
[10:25:47.746]                               parallel_sendData(master, data)
[10:25:47.746]                             }
[10:25:47.746]                             return(sendCondition)
[10:25:47.746]                           }
[10:25:47.746]                         }
[10:25:47.746]                         frame <- frame + 1L
[10:25:47.746]                         envir <- sys.frame(frame)
[10:25:47.746]                       }
[10:25:47.746]                     }
[10:25:47.746]                     sendCondition <<- function(cond) NULL
[10:25:47.746]                   }
[10:25:47.746]                 })
[10:25:47.746]                 withCallingHandlers({
[10:25:47.746]                   2
[10:25:47.746]                 }, immediateCondition = function(cond) {
[10:25:47.746]                   sendCondition <- ...future.makeSendCondition()
[10:25:47.746]                   sendCondition(cond)
[10:25:47.746]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.746]                   {
[10:25:47.746]                     inherits <- base::inherits
[10:25:47.746]                     invokeRestart <- base::invokeRestart
[10:25:47.746]                     is.null <- base::is.null
[10:25:47.746]                     muffled <- FALSE
[10:25:47.746]                     if (inherits(cond, "message")) {
[10:25:47.746]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:47.746]                       if (muffled) 
[10:25:47.746]                         invokeRestart("muffleMessage")
[10:25:47.746]                     }
[10:25:47.746]                     else if (inherits(cond, "warning")) {
[10:25:47.746]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:47.746]                       if (muffled) 
[10:25:47.746]                         invokeRestart("muffleWarning")
[10:25:47.746]                     }
[10:25:47.746]                     else if (inherits(cond, "condition")) {
[10:25:47.746]                       if (!is.null(pattern)) {
[10:25:47.746]                         computeRestarts <- base::computeRestarts
[10:25:47.746]                         grepl <- base::grepl
[10:25:47.746]                         restarts <- computeRestarts(cond)
[10:25:47.746]                         for (restart in restarts) {
[10:25:47.746]                           name <- restart$name
[10:25:47.746]                           if (is.null(name)) 
[10:25:47.746]                             next
[10:25:47.746]                           if (!grepl(pattern, name)) 
[10:25:47.746]                             next
[10:25:47.746]                           invokeRestart(restart)
[10:25:47.746]                           muffled <- TRUE
[10:25:47.746]                           break
[10:25:47.746]                         }
[10:25:47.746]                       }
[10:25:47.746]                     }
[10:25:47.746]                     invisible(muffled)
[10:25:47.746]                   }
[10:25:47.746]                   muffleCondition(cond)
[10:25:47.746]                 })
[10:25:47.746]             }))
[10:25:47.746]             future::FutureResult(value = ...future.value$value, 
[10:25:47.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.746]                   ...future.rng), globalenv = if (FALSE) 
[10:25:47.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:47.746]                     ...future.globalenv.names))
[10:25:47.746]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:47.746]         }, condition = base::local({
[10:25:47.746]             c <- base::c
[10:25:47.746]             inherits <- base::inherits
[10:25:47.746]             invokeRestart <- base::invokeRestart
[10:25:47.746]             length <- base::length
[10:25:47.746]             list <- base::list
[10:25:47.746]             seq.int <- base::seq.int
[10:25:47.746]             signalCondition <- base::signalCondition
[10:25:47.746]             sys.calls <- base::sys.calls
[10:25:47.746]             `[[` <- base::`[[`
[10:25:47.746]             `+` <- base::`+`
[10:25:47.746]             `<<-` <- base::`<<-`
[10:25:47.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:47.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:47.746]                   3L)]
[10:25:47.746]             }
[10:25:47.746]             function(cond) {
[10:25:47.746]                 is_error <- inherits(cond, "error")
[10:25:47.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:47.746]                   NULL)
[10:25:47.746]                 if (is_error) {
[10:25:47.746]                   sessionInformation <- function() {
[10:25:47.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:47.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:47.746]                       search = base::search(), system = base::Sys.info())
[10:25:47.746]                   }
[10:25:47.746]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:47.746]                     cond$call), session = sessionInformation(), 
[10:25:47.746]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:47.746]                   signalCondition(cond)
[10:25:47.746]                 }
[10:25:47.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:47.746]                 "immediateCondition"))) {
[10:25:47.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:47.746]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:47.746]                   if (TRUE && !signal) {
[10:25:47.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.746]                     {
[10:25:47.746]                       inherits <- base::inherits
[10:25:47.746]                       invokeRestart <- base::invokeRestart
[10:25:47.746]                       is.null <- base::is.null
[10:25:47.746]                       muffled <- FALSE
[10:25:47.746]                       if (inherits(cond, "message")) {
[10:25:47.746]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.746]                         if (muffled) 
[10:25:47.746]                           invokeRestart("muffleMessage")
[10:25:47.746]                       }
[10:25:47.746]                       else if (inherits(cond, "warning")) {
[10:25:47.746]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.746]                         if (muffled) 
[10:25:47.746]                           invokeRestart("muffleWarning")
[10:25:47.746]                       }
[10:25:47.746]                       else if (inherits(cond, "condition")) {
[10:25:47.746]                         if (!is.null(pattern)) {
[10:25:47.746]                           computeRestarts <- base::computeRestarts
[10:25:47.746]                           grepl <- base::grepl
[10:25:47.746]                           restarts <- computeRestarts(cond)
[10:25:47.746]                           for (restart in restarts) {
[10:25:47.746]                             name <- restart$name
[10:25:47.746]                             if (is.null(name)) 
[10:25:47.746]                               next
[10:25:47.746]                             if (!grepl(pattern, name)) 
[10:25:47.746]                               next
[10:25:47.746]                             invokeRestart(restart)
[10:25:47.746]                             muffled <- TRUE
[10:25:47.746]                             break
[10:25:47.746]                           }
[10:25:47.746]                         }
[10:25:47.746]                       }
[10:25:47.746]                       invisible(muffled)
[10:25:47.746]                     }
[10:25:47.746]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.746]                   }
[10:25:47.746]                 }
[10:25:47.746]                 else {
[10:25:47.746]                   if (TRUE) {
[10:25:47.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.746]                     {
[10:25:47.746]                       inherits <- base::inherits
[10:25:47.746]                       invokeRestart <- base::invokeRestart
[10:25:47.746]                       is.null <- base::is.null
[10:25:47.746]                       muffled <- FALSE
[10:25:47.746]                       if (inherits(cond, "message")) {
[10:25:47.746]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.746]                         if (muffled) 
[10:25:47.746]                           invokeRestart("muffleMessage")
[10:25:47.746]                       }
[10:25:47.746]                       else if (inherits(cond, "warning")) {
[10:25:47.746]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.746]                         if (muffled) 
[10:25:47.746]                           invokeRestart("muffleWarning")
[10:25:47.746]                       }
[10:25:47.746]                       else if (inherits(cond, "condition")) {
[10:25:47.746]                         if (!is.null(pattern)) {
[10:25:47.746]                           computeRestarts <- base::computeRestarts
[10:25:47.746]                           grepl <- base::grepl
[10:25:47.746]                           restarts <- computeRestarts(cond)
[10:25:47.746]                           for (restart in restarts) {
[10:25:47.746]                             name <- restart$name
[10:25:47.746]                             if (is.null(name)) 
[10:25:47.746]                               next
[10:25:47.746]                             if (!grepl(pattern, name)) 
[10:25:47.746]                               next
[10:25:47.746]                             invokeRestart(restart)
[10:25:47.746]                             muffled <- TRUE
[10:25:47.746]                             break
[10:25:47.746]                           }
[10:25:47.746]                         }
[10:25:47.746]                       }
[10:25:47.746]                       invisible(muffled)
[10:25:47.746]                     }
[10:25:47.746]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.746]                   }
[10:25:47.746]                 }
[10:25:47.746]             }
[10:25:47.746]         }))
[10:25:47.746]     }, error = function(ex) {
[10:25:47.746]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:47.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.746]                 ...future.rng), started = ...future.startTime, 
[10:25:47.746]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:47.746]             version = "1.8"), class = "FutureResult")
[10:25:47.746]     }, finally = {
[10:25:47.746]         if (!identical(...future.workdir, getwd())) 
[10:25:47.746]             setwd(...future.workdir)
[10:25:47.746]         {
[10:25:47.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:47.746]                 ...future.oldOptions$nwarnings <- NULL
[10:25:47.746]             }
[10:25:47.746]             base::options(...future.oldOptions)
[10:25:47.746]             if (.Platform$OS.type == "windows") {
[10:25:47.746]                 old_names <- names(...future.oldEnvVars)
[10:25:47.746]                 envs <- base::Sys.getenv()
[10:25:47.746]                 names <- names(envs)
[10:25:47.746]                 common <- intersect(names, old_names)
[10:25:47.746]                 added <- setdiff(names, old_names)
[10:25:47.746]                 removed <- setdiff(old_names, names)
[10:25:47.746]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:47.746]                   envs[common]]
[10:25:47.746]                 NAMES <- toupper(changed)
[10:25:47.746]                 args <- list()
[10:25:47.746]                 for (kk in seq_along(NAMES)) {
[10:25:47.746]                   name <- changed[[kk]]
[10:25:47.746]                   NAME <- NAMES[[kk]]
[10:25:47.746]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.746]                     next
[10:25:47.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.746]                 }
[10:25:47.746]                 NAMES <- toupper(added)
[10:25:47.746]                 for (kk in seq_along(NAMES)) {
[10:25:47.746]                   name <- added[[kk]]
[10:25:47.746]                   NAME <- NAMES[[kk]]
[10:25:47.746]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.746]                     next
[10:25:47.746]                   args[[name]] <- ""
[10:25:47.746]                 }
[10:25:47.746]                 NAMES <- toupper(removed)
[10:25:47.746]                 for (kk in seq_along(NAMES)) {
[10:25:47.746]                   name <- removed[[kk]]
[10:25:47.746]                   NAME <- NAMES[[kk]]
[10:25:47.746]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.746]                     next
[10:25:47.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.746]                 }
[10:25:47.746]                 if (length(args) > 0) 
[10:25:47.746]                   base::do.call(base::Sys.setenv, args = args)
[10:25:47.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:47.746]             }
[10:25:47.746]             else {
[10:25:47.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:47.746]             }
[10:25:47.746]             {
[10:25:47.746]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:47.746]                   0L) {
[10:25:47.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:47.746]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:47.746]                   base::options(opts)
[10:25:47.746]                 }
[10:25:47.746]                 {
[10:25:47.746]                   {
[10:25:47.746]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:47.746]                     NULL
[10:25:47.746]                   }
[10:25:47.746]                   options(future.plan = NULL)
[10:25:47.746]                   if (is.na(NA_character_)) 
[10:25:47.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:47.746]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:47.746]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:47.746]                     envir = parent.frame()) 
[10:25:47.746]                   {
[10:25:47.746]                     if (is.function(workers)) 
[10:25:47.746]                       workers <- workers()
[10:25:47.746]                     workers <- structure(as.integer(workers), 
[10:25:47.746]                       class = class(workers))
[10:25:47.746]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:47.746]                       workers >= 1)
[10:25:47.746]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:47.746]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:47.746]                     }
[10:25:47.746]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:47.746]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:47.746]                       envir = envir)
[10:25:47.746]                     if (!future$lazy) 
[10:25:47.746]                       future <- run(future)
[10:25:47.746]                     invisible(future)
[10:25:47.746]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:47.746]                 }
[10:25:47.746]             }
[10:25:47.746]         }
[10:25:47.746]     })
[10:25:47.746]     if (TRUE) {
[10:25:47.746]         base::sink(type = "output", split = FALSE)
[10:25:47.746]         if (TRUE) {
[10:25:47.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:47.746]         }
[10:25:47.746]         else {
[10:25:47.746]             ...future.result["stdout"] <- base::list(NULL)
[10:25:47.746]         }
[10:25:47.746]         base::close(...future.stdout)
[10:25:47.746]         ...future.stdout <- NULL
[10:25:47.746]     }
[10:25:47.746]     ...future.result$conditions <- ...future.conditions
[10:25:47.746]     ...future.result$finished <- base::Sys.time()
[10:25:47.746]     ...future.result
[10:25:47.746] }
[10:25:47.749] MultisessionFuture started
[10:25:47.749] - Launch lazy future ... done
[10:25:47.750] run() for ‘MultisessionFuture’ ... done
[10:25:47.750] getGlobalsAndPackages() ...
[10:25:47.750] Searching for globals...
[10:25:47.750] 
[10:25:47.750] Searching for globals ... DONE
[10:25:47.750] - globals: [0] <none>
[10:25:47.750] getGlobalsAndPackages() ... DONE
[10:25:47.751] run() for ‘Future’ ...
[10:25:47.751] - state: ‘created’
[10:25:47.751] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:47.764] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:47.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:47.765]   - Field: ‘node’
[10:25:47.765]   - Field: ‘label’
[10:25:47.765]   - Field: ‘local’
[10:25:47.765]   - Field: ‘owner’
[10:25:47.765]   - Field: ‘envir’
[10:25:47.765]   - Field: ‘workers’
[10:25:47.765]   - Field: ‘packages’
[10:25:47.765]   - Field: ‘gc’
[10:25:47.765]   - Field: ‘conditions’
[10:25:47.766]   - Field: ‘persistent’
[10:25:47.766]   - Field: ‘expr’
[10:25:47.766]   - Field: ‘uuid’
[10:25:47.766]   - Field: ‘seed’
[10:25:47.766]   - Field: ‘version’
[10:25:47.766]   - Field: ‘result’
[10:25:47.766]   - Field: ‘asynchronous’
[10:25:47.766]   - Field: ‘calls’
[10:25:47.766]   - Field: ‘globals’
[10:25:47.766]   - Field: ‘stdout’
[10:25:47.766]   - Field: ‘earlySignal’
[10:25:47.767]   - Field: ‘lazy’
[10:25:47.767]   - Field: ‘state’
[10:25:47.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:47.767] - Launch lazy future ...
[10:25:47.767] Packages needed by the future expression (n = 0): <none>
[10:25:47.767] Packages needed by future strategies (n = 0): <none>
[10:25:47.768] {
[10:25:47.768]     {
[10:25:47.768]         {
[10:25:47.768]             ...future.startTime <- base::Sys.time()
[10:25:47.768]             {
[10:25:47.768]                 {
[10:25:47.768]                   {
[10:25:47.768]                     {
[10:25:47.768]                       base::local({
[10:25:47.768]                         has_future <- base::requireNamespace("future", 
[10:25:47.768]                           quietly = TRUE)
[10:25:47.768]                         if (has_future) {
[10:25:47.768]                           ns <- base::getNamespace("future")
[10:25:47.768]                           version <- ns[[".package"]][["version"]]
[10:25:47.768]                           if (is.null(version)) 
[10:25:47.768]                             version <- utils::packageVersion("future")
[10:25:47.768]                         }
[10:25:47.768]                         else {
[10:25:47.768]                           version <- NULL
[10:25:47.768]                         }
[10:25:47.768]                         if (!has_future || version < "1.8.0") {
[10:25:47.768]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:47.768]                             "", base::R.version$version.string), 
[10:25:47.768]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:47.768]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:47.768]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:47.768]                               "release", "version")], collapse = " "), 
[10:25:47.768]                             hostname = base::Sys.info()[["nodename"]])
[10:25:47.768]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:47.768]                             info)
[10:25:47.768]                           info <- base::paste(info, collapse = "; ")
[10:25:47.768]                           if (!has_future) {
[10:25:47.768]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:47.768]                               info)
[10:25:47.768]                           }
[10:25:47.768]                           else {
[10:25:47.768]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:47.768]                               info, version)
[10:25:47.768]                           }
[10:25:47.768]                           base::stop(msg)
[10:25:47.768]                         }
[10:25:47.768]                       })
[10:25:47.768]                     }
[10:25:47.768]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:47.768]                     base::options(mc.cores = 1L)
[10:25:47.768]                   }
[10:25:47.768]                   options(future.plan = NULL)
[10:25:47.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:47.768]                 }
[10:25:47.768]                 ...future.workdir <- getwd()
[10:25:47.768]             }
[10:25:47.768]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:47.768]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:47.768]         }
[10:25:47.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:47.768]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:47.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:47.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:47.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:47.768]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:47.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:47.768]             base::names(...future.oldOptions))
[10:25:47.768]     }
[10:25:47.768]     if (FALSE) {
[10:25:47.768]     }
[10:25:47.768]     else {
[10:25:47.768]         if (TRUE) {
[10:25:47.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:47.768]                 open = "w")
[10:25:47.768]         }
[10:25:47.768]         else {
[10:25:47.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:47.768]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:47.768]         }
[10:25:47.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:47.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:47.768]             base::sink(type = "output", split = FALSE)
[10:25:47.768]             base::close(...future.stdout)
[10:25:47.768]         }, add = TRUE)
[10:25:47.768]     }
[10:25:47.768]     ...future.frame <- base::sys.nframe()
[10:25:47.768]     ...future.conditions <- base::list()
[10:25:47.768]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:47.768]     if (FALSE) {
[10:25:47.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:47.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:47.768]     }
[10:25:47.768]     ...future.result <- base::tryCatch({
[10:25:47.768]         base::withCallingHandlers({
[10:25:47.768]             ...future.value <- base::withVisible(base::local({
[10:25:47.768]                 ...future.makeSendCondition <- base::local({
[10:25:47.768]                   sendCondition <- NULL
[10:25:47.768]                   function(frame = 1L) {
[10:25:47.768]                     if (is.function(sendCondition)) 
[10:25:47.768]                       return(sendCondition)
[10:25:47.768]                     ns <- getNamespace("parallel")
[10:25:47.768]                     if (exists("sendData", mode = "function", 
[10:25:47.768]                       envir = ns)) {
[10:25:47.768]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:47.768]                         envir = ns)
[10:25:47.768]                       envir <- sys.frame(frame)
[10:25:47.768]                       master <- NULL
[10:25:47.768]                       while (!identical(envir, .GlobalEnv) && 
[10:25:47.768]                         !identical(envir, emptyenv())) {
[10:25:47.768]                         if (exists("master", mode = "list", envir = envir, 
[10:25:47.768]                           inherits = FALSE)) {
[10:25:47.768]                           master <- get("master", mode = "list", 
[10:25:47.768]                             envir = envir, inherits = FALSE)
[10:25:47.768]                           if (inherits(master, c("SOCKnode", 
[10:25:47.768]                             "SOCK0node"))) {
[10:25:47.768]                             sendCondition <<- function(cond) {
[10:25:47.768]                               data <- list(type = "VALUE", value = cond, 
[10:25:47.768]                                 success = TRUE)
[10:25:47.768]                               parallel_sendData(master, data)
[10:25:47.768]                             }
[10:25:47.768]                             return(sendCondition)
[10:25:47.768]                           }
[10:25:47.768]                         }
[10:25:47.768]                         frame <- frame + 1L
[10:25:47.768]                         envir <- sys.frame(frame)
[10:25:47.768]                       }
[10:25:47.768]                     }
[10:25:47.768]                     sendCondition <<- function(cond) NULL
[10:25:47.768]                   }
[10:25:47.768]                 })
[10:25:47.768]                 withCallingHandlers({
[10:25:47.768]                   NULL
[10:25:47.768]                 }, immediateCondition = function(cond) {
[10:25:47.768]                   sendCondition <- ...future.makeSendCondition()
[10:25:47.768]                   sendCondition(cond)
[10:25:47.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.768]                   {
[10:25:47.768]                     inherits <- base::inherits
[10:25:47.768]                     invokeRestart <- base::invokeRestart
[10:25:47.768]                     is.null <- base::is.null
[10:25:47.768]                     muffled <- FALSE
[10:25:47.768]                     if (inherits(cond, "message")) {
[10:25:47.768]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:47.768]                       if (muffled) 
[10:25:47.768]                         invokeRestart("muffleMessage")
[10:25:47.768]                     }
[10:25:47.768]                     else if (inherits(cond, "warning")) {
[10:25:47.768]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:47.768]                       if (muffled) 
[10:25:47.768]                         invokeRestart("muffleWarning")
[10:25:47.768]                     }
[10:25:47.768]                     else if (inherits(cond, "condition")) {
[10:25:47.768]                       if (!is.null(pattern)) {
[10:25:47.768]                         computeRestarts <- base::computeRestarts
[10:25:47.768]                         grepl <- base::grepl
[10:25:47.768]                         restarts <- computeRestarts(cond)
[10:25:47.768]                         for (restart in restarts) {
[10:25:47.768]                           name <- restart$name
[10:25:47.768]                           if (is.null(name)) 
[10:25:47.768]                             next
[10:25:47.768]                           if (!grepl(pattern, name)) 
[10:25:47.768]                             next
[10:25:47.768]                           invokeRestart(restart)
[10:25:47.768]                           muffled <- TRUE
[10:25:47.768]                           break
[10:25:47.768]                         }
[10:25:47.768]                       }
[10:25:47.768]                     }
[10:25:47.768]                     invisible(muffled)
[10:25:47.768]                   }
[10:25:47.768]                   muffleCondition(cond)
[10:25:47.768]                 })
[10:25:47.768]             }))
[10:25:47.768]             future::FutureResult(value = ...future.value$value, 
[10:25:47.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.768]                   ...future.rng), globalenv = if (FALSE) 
[10:25:47.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:47.768]                     ...future.globalenv.names))
[10:25:47.768]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:47.768]         }, condition = base::local({
[10:25:47.768]             c <- base::c
[10:25:47.768]             inherits <- base::inherits
[10:25:47.768]             invokeRestart <- base::invokeRestart
[10:25:47.768]             length <- base::length
[10:25:47.768]             list <- base::list
[10:25:47.768]             seq.int <- base::seq.int
[10:25:47.768]             signalCondition <- base::signalCondition
[10:25:47.768]             sys.calls <- base::sys.calls
[10:25:47.768]             `[[` <- base::`[[`
[10:25:47.768]             `+` <- base::`+`
[10:25:47.768]             `<<-` <- base::`<<-`
[10:25:47.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:47.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:47.768]                   3L)]
[10:25:47.768]             }
[10:25:47.768]             function(cond) {
[10:25:47.768]                 is_error <- inherits(cond, "error")
[10:25:47.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:47.768]                   NULL)
[10:25:47.768]                 if (is_error) {
[10:25:47.768]                   sessionInformation <- function() {
[10:25:47.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:47.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:47.768]                       search = base::search(), system = base::Sys.info())
[10:25:47.768]                   }
[10:25:47.768]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:47.768]                     cond$call), session = sessionInformation(), 
[10:25:47.768]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:47.768]                   signalCondition(cond)
[10:25:47.768]                 }
[10:25:47.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:47.768]                 "immediateCondition"))) {
[10:25:47.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:47.768]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:47.768]                   if (TRUE && !signal) {
[10:25:47.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.768]                     {
[10:25:47.768]                       inherits <- base::inherits
[10:25:47.768]                       invokeRestart <- base::invokeRestart
[10:25:47.768]                       is.null <- base::is.null
[10:25:47.768]                       muffled <- FALSE
[10:25:47.768]                       if (inherits(cond, "message")) {
[10:25:47.768]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.768]                         if (muffled) 
[10:25:47.768]                           invokeRestart("muffleMessage")
[10:25:47.768]                       }
[10:25:47.768]                       else if (inherits(cond, "warning")) {
[10:25:47.768]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.768]                         if (muffled) 
[10:25:47.768]                           invokeRestart("muffleWarning")
[10:25:47.768]                       }
[10:25:47.768]                       else if (inherits(cond, "condition")) {
[10:25:47.768]                         if (!is.null(pattern)) {
[10:25:47.768]                           computeRestarts <- base::computeRestarts
[10:25:47.768]                           grepl <- base::grepl
[10:25:47.768]                           restarts <- computeRestarts(cond)
[10:25:47.768]                           for (restart in restarts) {
[10:25:47.768]                             name <- restart$name
[10:25:47.768]                             if (is.null(name)) 
[10:25:47.768]                               next
[10:25:47.768]                             if (!grepl(pattern, name)) 
[10:25:47.768]                               next
[10:25:47.768]                             invokeRestart(restart)
[10:25:47.768]                             muffled <- TRUE
[10:25:47.768]                             break
[10:25:47.768]                           }
[10:25:47.768]                         }
[10:25:47.768]                       }
[10:25:47.768]                       invisible(muffled)
[10:25:47.768]                     }
[10:25:47.768]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.768]                   }
[10:25:47.768]                 }
[10:25:47.768]                 else {
[10:25:47.768]                   if (TRUE) {
[10:25:47.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.768]                     {
[10:25:47.768]                       inherits <- base::inherits
[10:25:47.768]                       invokeRestart <- base::invokeRestart
[10:25:47.768]                       is.null <- base::is.null
[10:25:47.768]                       muffled <- FALSE
[10:25:47.768]                       if (inherits(cond, "message")) {
[10:25:47.768]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.768]                         if (muffled) 
[10:25:47.768]                           invokeRestart("muffleMessage")
[10:25:47.768]                       }
[10:25:47.768]                       else if (inherits(cond, "warning")) {
[10:25:47.768]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.768]                         if (muffled) 
[10:25:47.768]                           invokeRestart("muffleWarning")
[10:25:47.768]                       }
[10:25:47.768]                       else if (inherits(cond, "condition")) {
[10:25:47.768]                         if (!is.null(pattern)) {
[10:25:47.768]                           computeRestarts <- base::computeRestarts
[10:25:47.768]                           grepl <- base::grepl
[10:25:47.768]                           restarts <- computeRestarts(cond)
[10:25:47.768]                           for (restart in restarts) {
[10:25:47.768]                             name <- restart$name
[10:25:47.768]                             if (is.null(name)) 
[10:25:47.768]                               next
[10:25:47.768]                             if (!grepl(pattern, name)) 
[10:25:47.768]                               next
[10:25:47.768]                             invokeRestart(restart)
[10:25:47.768]                             muffled <- TRUE
[10:25:47.768]                             break
[10:25:47.768]                           }
[10:25:47.768]                         }
[10:25:47.768]                       }
[10:25:47.768]                       invisible(muffled)
[10:25:47.768]                     }
[10:25:47.768]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.768]                   }
[10:25:47.768]                 }
[10:25:47.768]             }
[10:25:47.768]         }))
[10:25:47.768]     }, error = function(ex) {
[10:25:47.768]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:47.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.768]                 ...future.rng), started = ...future.startTime, 
[10:25:47.768]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:47.768]             version = "1.8"), class = "FutureResult")
[10:25:47.768]     }, finally = {
[10:25:47.768]         if (!identical(...future.workdir, getwd())) 
[10:25:47.768]             setwd(...future.workdir)
[10:25:47.768]         {
[10:25:47.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:47.768]                 ...future.oldOptions$nwarnings <- NULL
[10:25:47.768]             }
[10:25:47.768]             base::options(...future.oldOptions)
[10:25:47.768]             if (.Platform$OS.type == "windows") {
[10:25:47.768]                 old_names <- names(...future.oldEnvVars)
[10:25:47.768]                 envs <- base::Sys.getenv()
[10:25:47.768]                 names <- names(envs)
[10:25:47.768]                 common <- intersect(names, old_names)
[10:25:47.768]                 added <- setdiff(names, old_names)
[10:25:47.768]                 removed <- setdiff(old_names, names)
[10:25:47.768]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:47.768]                   envs[common]]
[10:25:47.768]                 NAMES <- toupper(changed)
[10:25:47.768]                 args <- list()
[10:25:47.768]                 for (kk in seq_along(NAMES)) {
[10:25:47.768]                   name <- changed[[kk]]
[10:25:47.768]                   NAME <- NAMES[[kk]]
[10:25:47.768]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.768]                     next
[10:25:47.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.768]                 }
[10:25:47.768]                 NAMES <- toupper(added)
[10:25:47.768]                 for (kk in seq_along(NAMES)) {
[10:25:47.768]                   name <- added[[kk]]
[10:25:47.768]                   NAME <- NAMES[[kk]]
[10:25:47.768]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.768]                     next
[10:25:47.768]                   args[[name]] <- ""
[10:25:47.768]                 }
[10:25:47.768]                 NAMES <- toupper(removed)
[10:25:47.768]                 for (kk in seq_along(NAMES)) {
[10:25:47.768]                   name <- removed[[kk]]
[10:25:47.768]                   NAME <- NAMES[[kk]]
[10:25:47.768]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.768]                     next
[10:25:47.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.768]                 }
[10:25:47.768]                 if (length(args) > 0) 
[10:25:47.768]                   base::do.call(base::Sys.setenv, args = args)
[10:25:47.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:47.768]             }
[10:25:47.768]             else {
[10:25:47.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:47.768]             }
[10:25:47.768]             {
[10:25:47.768]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:47.768]                   0L) {
[10:25:47.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:47.768]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:47.768]                   base::options(opts)
[10:25:47.768]                 }
[10:25:47.768]                 {
[10:25:47.768]                   {
[10:25:47.768]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:47.768]                     NULL
[10:25:47.768]                   }
[10:25:47.768]                   options(future.plan = NULL)
[10:25:47.768]                   if (is.na(NA_character_)) 
[10:25:47.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:47.768]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:47.768]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:47.768]                     envir = parent.frame()) 
[10:25:47.768]                   {
[10:25:47.768]                     if (is.function(workers)) 
[10:25:47.768]                       workers <- workers()
[10:25:47.768]                     workers <- structure(as.integer(workers), 
[10:25:47.768]                       class = class(workers))
[10:25:47.768]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:47.768]                       workers >= 1)
[10:25:47.768]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:47.768]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:47.768]                     }
[10:25:47.768]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:47.768]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:47.768]                       envir = envir)
[10:25:47.768]                     if (!future$lazy) 
[10:25:47.768]                       future <- run(future)
[10:25:47.768]                     invisible(future)
[10:25:47.768]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:47.768]                 }
[10:25:47.768]             }
[10:25:47.768]         }
[10:25:47.768]     })
[10:25:47.768]     if (TRUE) {
[10:25:47.768]         base::sink(type = "output", split = FALSE)
[10:25:47.768]         if (TRUE) {
[10:25:47.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:47.768]         }
[10:25:47.768]         else {
[10:25:47.768]             ...future.result["stdout"] <- base::list(NULL)
[10:25:47.768]         }
[10:25:47.768]         base::close(...future.stdout)
[10:25:47.768]         ...future.stdout <- NULL
[10:25:47.768]     }
[10:25:47.768]     ...future.result$conditions <- ...future.conditions
[10:25:47.768]     ...future.result$finished <- base::Sys.time()
[10:25:47.768]     ...future.result
[10:25:47.768] }
[10:25:47.770] MultisessionFuture started
[10:25:47.771] - Launch lazy future ... done
[10:25:47.771] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f55c6488> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f4fd9e70> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f55c6488> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f4fd9e70> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:47.798] resolve() on list ...
[10:25:47.798]  recursive: 0
[10:25:47.798]  length: 6
[10:25:47.798]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:47.798] signalConditionsASAP(numeric, pos=1) ...
[10:25:47.799] - nx: 6
[10:25:47.799] - relay: TRUE
[10:25:47.799] - stdout: TRUE
[10:25:47.799] - signal: TRUE
[10:25:47.799] - resignal: FALSE
[10:25:47.799] - force: TRUE
[10:25:47.799] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.799] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.799]  - until=2
[10:25:47.799]  - relaying element #2
[10:25:47.799] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.799] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.800] signalConditionsASAP(NULL, pos=1) ... done
[10:25:47.800]  length: 5 (resolved future 1)
[10:25:47.800] receiveMessageFromWorker() for ClusterFuture ...
[10:25:47.800] - Validating connection of MultisessionFuture
[10:25:47.800] - received message: FutureResult
[10:25:47.800] - Received FutureResult
[10:25:47.801] - Erased future from FutureRegistry
[10:25:47.801] result() for ClusterFuture ...
[10:25:47.801] - result already collected: FutureResult
[10:25:47.801] result() for ClusterFuture ... done
[10:25:47.801] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:47.801] Future #2
[10:25:47.801] result() for ClusterFuture ...
[10:25:47.801] - result already collected: FutureResult
[10:25:47.801] result() for ClusterFuture ... done
[10:25:47.801] result() for ClusterFuture ...
[10:25:47.802] - result already collected: FutureResult
[10:25:47.802] result() for ClusterFuture ... done
[10:25:47.802] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:47.802] - nx: 6
[10:25:47.802] - relay: TRUE
[10:25:47.802] - stdout: TRUE
[10:25:47.802] - signal: TRUE
[10:25:47.802] - resignal: FALSE
[10:25:47.802] - force: TRUE
[10:25:47.802] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.802] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.802]  - until=2
[10:25:47.803]  - relaying element #2
[10:25:47.803] result() for ClusterFuture ...
[10:25:47.803] - result already collected: FutureResult
[10:25:47.803] result() for ClusterFuture ... done
[10:25:47.803] result() for ClusterFuture ...
[10:25:47.803] - result already collected: FutureResult
[10:25:47.803] result() for ClusterFuture ... done
[10:25:47.803] result() for ClusterFuture ...
[10:25:47.803] - result already collected: FutureResult
[10:25:47.803] result() for ClusterFuture ... done
[10:25:47.803] result() for ClusterFuture ...
[10:25:47.804] - result already collected: FutureResult
[10:25:47.804] result() for ClusterFuture ... done
[10:25:47.804] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.804] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.804] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:47.804]  length: 4 (resolved future 2)
[10:25:47.814] signalConditionsASAP(NULL, pos=4) ...
[10:25:47.815] - nx: 6
[10:25:47.815] - relay: TRUE
[10:25:47.815] - stdout: TRUE
[10:25:47.815] - signal: TRUE
[10:25:47.815] - resignal: FALSE
[10:25:47.815] - force: TRUE
[10:25:47.815] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.815] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.815]  - until=5
[10:25:47.815]  - relaying element #3
[10:25:47.816]  - relaying element #5
[10:25:47.816] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[10:25:47.816] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.816] signalConditionsASAP(NULL, pos=4) ... done
[10:25:47.816]  length: 3 (resolved future 4)
[10:25:47.816] signalConditionsASAP(NULL, pos=5) ...
[10:25:47.816] - nx: 6
[10:25:47.816] - relay: TRUE
[10:25:47.816] - stdout: TRUE
[10:25:47.816] - signal: TRUE
[10:25:47.816] - resignal: FALSE
[10:25:47.816] - force: TRUE
[10:25:47.817] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[10:25:47.817] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.817]  - until=6
[10:25:47.817]  - relaying element #3
[10:25:47.817]  - relaying element #6
[10:25:47.817] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[10:25:47.817] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.817] signalConditionsASAP(NULL, pos=5) ... done
[10:25:47.817]  length: 2 (resolved future 5)
[10:25:47.817] signalConditionsASAP(numeric, pos=6) ...
[10:25:47.817] - nx: 6
[10:25:47.818] - relay: TRUE
[10:25:47.818] - stdout: TRUE
[10:25:47.818] - signal: TRUE
[10:25:47.818] - resignal: FALSE
[10:25:47.818] - force: TRUE
[10:25:47.818] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[10:25:47.818] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.818]  - until=6
[10:25:47.818]  - relaying element #3
[10:25:47.818] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[10:25:47.818] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.818] signalConditionsASAP(NULL, pos=6) ... done
[10:25:47.819]  length: 1 (resolved future 6)
[10:25:47.829] receiveMessageFromWorker() for ClusterFuture ...
[10:25:47.829] - Validating connection of MultisessionFuture
[10:25:47.830] - received message: FutureResult
[10:25:47.830] - Received FutureResult
[10:25:47.830] - Erased future from FutureRegistry
[10:25:47.830] result() for ClusterFuture ...
[10:25:47.830] - result already collected: FutureResult
[10:25:47.830] result() for ClusterFuture ... done
[10:25:47.830] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:47.830] Future #3
[10:25:47.830] result() for ClusterFuture ...
[10:25:47.831] - result already collected: FutureResult
[10:25:47.831] result() for ClusterFuture ... done
[10:25:47.831] result() for ClusterFuture ...
[10:25:47.831] - result already collected: FutureResult
[10:25:47.831] result() for ClusterFuture ... done
[10:25:47.831] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:47.831] - nx: 6
[10:25:47.831] - relay: TRUE
[10:25:47.831] - stdout: TRUE
[10:25:47.831] - signal: TRUE
[10:25:47.831] - resignal: FALSE
[10:25:47.831] - force: TRUE
[10:25:47.832] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[10:25:47.832] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.832]  - until=6
[10:25:47.832]  - relaying element #3
[10:25:47.832] result() for ClusterFuture ...
[10:25:47.832] - result already collected: FutureResult
[10:25:47.832] result() for ClusterFuture ... done
[10:25:47.832] result() for ClusterFuture ...
[10:25:47.832] - result already collected: FutureResult
[10:25:47.832] result() for ClusterFuture ... done
[10:25:47.832] result() for ClusterFuture ...
[10:25:47.833] - result already collected: FutureResult
[10:25:47.833] result() for ClusterFuture ... done
[10:25:47.833] result() for ClusterFuture ...
[10:25:47.833] - result already collected: FutureResult
[10:25:47.833] result() for ClusterFuture ... done
[10:25:47.833] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:47.833] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.833] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:47.833]  length: 0 (resolved future 3)
[10:25:47.833] Relaying remaining futures
[10:25:47.833] signalConditionsASAP(NULL, pos=0) ...
[10:25:47.834] - nx: 6
[10:25:47.834] - relay: TRUE
[10:25:47.834] - stdout: TRUE
[10:25:47.834] - signal: TRUE
[10:25:47.834] - resignal: FALSE
[10:25:47.834] - force: TRUE
[10:25:47.834] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:47.834] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:47.834] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:47.834] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.834] signalConditionsASAP(NULL, pos=0) ... done
[10:25:47.835] resolve() on list ... DONE
[10:25:47.835] result() for ClusterFuture ...
[10:25:47.835] - result already collected: FutureResult
[10:25:47.835] result() for ClusterFuture ... done
[10:25:47.835] result() for ClusterFuture ...
[10:25:47.835] - result already collected: FutureResult
[10:25:47.835] result() for ClusterFuture ... done
[10:25:47.835] result() for ClusterFuture ...
[10:25:47.835] - result already collected: FutureResult
[10:25:47.835] result() for ClusterFuture ... done
[10:25:47.835] result() for ClusterFuture ...
[10:25:47.836] - result already collected: FutureResult
[10:25:47.836] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:25:47.839] getGlobalsAndPackages() ...
[10:25:47.839] Searching for globals...
[10:25:47.839] 
[10:25:47.839] Searching for globals ... DONE
[10:25:47.839] - globals: [0] <none>
[10:25:47.839] getGlobalsAndPackages() ... DONE
[10:25:47.840] run() for ‘Future’ ...
[10:25:47.840] - state: ‘created’
[10:25:47.840] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:47.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:47.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:47.854]   - Field: ‘node’
[10:25:47.854]   - Field: ‘label’
[10:25:47.854]   - Field: ‘local’
[10:25:47.854]   - Field: ‘owner’
[10:25:47.854]   - Field: ‘envir’
[10:25:47.854]   - Field: ‘workers’
[10:25:47.854]   - Field: ‘packages’
[10:25:47.854]   - Field: ‘gc’
[10:25:47.854]   - Field: ‘conditions’
[10:25:47.854]   - Field: ‘persistent’
[10:25:47.854]   - Field: ‘expr’
[10:25:47.855]   - Field: ‘uuid’
[10:25:47.855]   - Field: ‘seed’
[10:25:47.855]   - Field: ‘version’
[10:25:47.855]   - Field: ‘result’
[10:25:47.855]   - Field: ‘asynchronous’
[10:25:47.855]   - Field: ‘calls’
[10:25:47.855]   - Field: ‘globals’
[10:25:47.855]   - Field: ‘stdout’
[10:25:47.855]   - Field: ‘earlySignal’
[10:25:47.855]   - Field: ‘lazy’
[10:25:47.855]   - Field: ‘state’
[10:25:47.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:47.856] - Launch lazy future ...
[10:25:47.856] Packages needed by the future expression (n = 0): <none>
[10:25:47.856] Packages needed by future strategies (n = 0): <none>
[10:25:47.856] {
[10:25:47.856]     {
[10:25:47.856]         {
[10:25:47.856]             ...future.startTime <- base::Sys.time()
[10:25:47.856]             {
[10:25:47.856]                 {
[10:25:47.856]                   {
[10:25:47.856]                     {
[10:25:47.856]                       base::local({
[10:25:47.856]                         has_future <- base::requireNamespace("future", 
[10:25:47.856]                           quietly = TRUE)
[10:25:47.856]                         if (has_future) {
[10:25:47.856]                           ns <- base::getNamespace("future")
[10:25:47.856]                           version <- ns[[".package"]][["version"]]
[10:25:47.856]                           if (is.null(version)) 
[10:25:47.856]                             version <- utils::packageVersion("future")
[10:25:47.856]                         }
[10:25:47.856]                         else {
[10:25:47.856]                           version <- NULL
[10:25:47.856]                         }
[10:25:47.856]                         if (!has_future || version < "1.8.0") {
[10:25:47.856]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:47.856]                             "", base::R.version$version.string), 
[10:25:47.856]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:47.856]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:47.856]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:47.856]                               "release", "version")], collapse = " "), 
[10:25:47.856]                             hostname = base::Sys.info()[["nodename"]])
[10:25:47.856]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:47.856]                             info)
[10:25:47.856]                           info <- base::paste(info, collapse = "; ")
[10:25:47.856]                           if (!has_future) {
[10:25:47.856]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:47.856]                               info)
[10:25:47.856]                           }
[10:25:47.856]                           else {
[10:25:47.856]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:47.856]                               info, version)
[10:25:47.856]                           }
[10:25:47.856]                           base::stop(msg)
[10:25:47.856]                         }
[10:25:47.856]                       })
[10:25:47.856]                     }
[10:25:47.856]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:47.856]                     base::options(mc.cores = 1L)
[10:25:47.856]                   }
[10:25:47.856]                   options(future.plan = NULL)
[10:25:47.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:47.856]                 }
[10:25:47.856]                 ...future.workdir <- getwd()
[10:25:47.856]             }
[10:25:47.856]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:47.856]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:47.856]         }
[10:25:47.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:47.856]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:47.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:47.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:47.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:47.856]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:47.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:47.856]             base::names(...future.oldOptions))
[10:25:47.856]     }
[10:25:47.856]     if (FALSE) {
[10:25:47.856]     }
[10:25:47.856]     else {
[10:25:47.856]         if (TRUE) {
[10:25:47.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:47.856]                 open = "w")
[10:25:47.856]         }
[10:25:47.856]         else {
[10:25:47.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:47.856]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:47.856]         }
[10:25:47.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:47.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:47.856]             base::sink(type = "output", split = FALSE)
[10:25:47.856]             base::close(...future.stdout)
[10:25:47.856]         }, add = TRUE)
[10:25:47.856]     }
[10:25:47.856]     ...future.frame <- base::sys.nframe()
[10:25:47.856]     ...future.conditions <- base::list()
[10:25:47.856]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:47.856]     if (FALSE) {
[10:25:47.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:47.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:47.856]     }
[10:25:47.856]     ...future.result <- base::tryCatch({
[10:25:47.856]         base::withCallingHandlers({
[10:25:47.856]             ...future.value <- base::withVisible(base::local({
[10:25:47.856]                 ...future.makeSendCondition <- base::local({
[10:25:47.856]                   sendCondition <- NULL
[10:25:47.856]                   function(frame = 1L) {
[10:25:47.856]                     if (is.function(sendCondition)) 
[10:25:47.856]                       return(sendCondition)
[10:25:47.856]                     ns <- getNamespace("parallel")
[10:25:47.856]                     if (exists("sendData", mode = "function", 
[10:25:47.856]                       envir = ns)) {
[10:25:47.856]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:47.856]                         envir = ns)
[10:25:47.856]                       envir <- sys.frame(frame)
[10:25:47.856]                       master <- NULL
[10:25:47.856]                       while (!identical(envir, .GlobalEnv) && 
[10:25:47.856]                         !identical(envir, emptyenv())) {
[10:25:47.856]                         if (exists("master", mode = "list", envir = envir, 
[10:25:47.856]                           inherits = FALSE)) {
[10:25:47.856]                           master <- get("master", mode = "list", 
[10:25:47.856]                             envir = envir, inherits = FALSE)
[10:25:47.856]                           if (inherits(master, c("SOCKnode", 
[10:25:47.856]                             "SOCK0node"))) {
[10:25:47.856]                             sendCondition <<- function(cond) {
[10:25:47.856]                               data <- list(type = "VALUE", value = cond, 
[10:25:47.856]                                 success = TRUE)
[10:25:47.856]                               parallel_sendData(master, data)
[10:25:47.856]                             }
[10:25:47.856]                             return(sendCondition)
[10:25:47.856]                           }
[10:25:47.856]                         }
[10:25:47.856]                         frame <- frame + 1L
[10:25:47.856]                         envir <- sys.frame(frame)
[10:25:47.856]                       }
[10:25:47.856]                     }
[10:25:47.856]                     sendCondition <<- function(cond) NULL
[10:25:47.856]                   }
[10:25:47.856]                 })
[10:25:47.856]                 withCallingHandlers({
[10:25:47.856]                   2
[10:25:47.856]                 }, immediateCondition = function(cond) {
[10:25:47.856]                   sendCondition <- ...future.makeSendCondition()
[10:25:47.856]                   sendCondition(cond)
[10:25:47.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.856]                   {
[10:25:47.856]                     inherits <- base::inherits
[10:25:47.856]                     invokeRestart <- base::invokeRestart
[10:25:47.856]                     is.null <- base::is.null
[10:25:47.856]                     muffled <- FALSE
[10:25:47.856]                     if (inherits(cond, "message")) {
[10:25:47.856]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:47.856]                       if (muffled) 
[10:25:47.856]                         invokeRestart("muffleMessage")
[10:25:47.856]                     }
[10:25:47.856]                     else if (inherits(cond, "warning")) {
[10:25:47.856]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:47.856]                       if (muffled) 
[10:25:47.856]                         invokeRestart("muffleWarning")
[10:25:47.856]                     }
[10:25:47.856]                     else if (inherits(cond, "condition")) {
[10:25:47.856]                       if (!is.null(pattern)) {
[10:25:47.856]                         computeRestarts <- base::computeRestarts
[10:25:47.856]                         grepl <- base::grepl
[10:25:47.856]                         restarts <- computeRestarts(cond)
[10:25:47.856]                         for (restart in restarts) {
[10:25:47.856]                           name <- restart$name
[10:25:47.856]                           if (is.null(name)) 
[10:25:47.856]                             next
[10:25:47.856]                           if (!grepl(pattern, name)) 
[10:25:47.856]                             next
[10:25:47.856]                           invokeRestart(restart)
[10:25:47.856]                           muffled <- TRUE
[10:25:47.856]                           break
[10:25:47.856]                         }
[10:25:47.856]                       }
[10:25:47.856]                     }
[10:25:47.856]                     invisible(muffled)
[10:25:47.856]                   }
[10:25:47.856]                   muffleCondition(cond)
[10:25:47.856]                 })
[10:25:47.856]             }))
[10:25:47.856]             future::FutureResult(value = ...future.value$value, 
[10:25:47.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.856]                   ...future.rng), globalenv = if (FALSE) 
[10:25:47.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:47.856]                     ...future.globalenv.names))
[10:25:47.856]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:47.856]         }, condition = base::local({
[10:25:47.856]             c <- base::c
[10:25:47.856]             inherits <- base::inherits
[10:25:47.856]             invokeRestart <- base::invokeRestart
[10:25:47.856]             length <- base::length
[10:25:47.856]             list <- base::list
[10:25:47.856]             seq.int <- base::seq.int
[10:25:47.856]             signalCondition <- base::signalCondition
[10:25:47.856]             sys.calls <- base::sys.calls
[10:25:47.856]             `[[` <- base::`[[`
[10:25:47.856]             `+` <- base::`+`
[10:25:47.856]             `<<-` <- base::`<<-`
[10:25:47.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:47.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:47.856]                   3L)]
[10:25:47.856]             }
[10:25:47.856]             function(cond) {
[10:25:47.856]                 is_error <- inherits(cond, "error")
[10:25:47.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:47.856]                   NULL)
[10:25:47.856]                 if (is_error) {
[10:25:47.856]                   sessionInformation <- function() {
[10:25:47.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:47.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:47.856]                       search = base::search(), system = base::Sys.info())
[10:25:47.856]                   }
[10:25:47.856]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:47.856]                     cond$call), session = sessionInformation(), 
[10:25:47.856]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:47.856]                   signalCondition(cond)
[10:25:47.856]                 }
[10:25:47.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:47.856]                 "immediateCondition"))) {
[10:25:47.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:47.856]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:47.856]                   if (TRUE && !signal) {
[10:25:47.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.856]                     {
[10:25:47.856]                       inherits <- base::inherits
[10:25:47.856]                       invokeRestart <- base::invokeRestart
[10:25:47.856]                       is.null <- base::is.null
[10:25:47.856]                       muffled <- FALSE
[10:25:47.856]                       if (inherits(cond, "message")) {
[10:25:47.856]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.856]                         if (muffled) 
[10:25:47.856]                           invokeRestart("muffleMessage")
[10:25:47.856]                       }
[10:25:47.856]                       else if (inherits(cond, "warning")) {
[10:25:47.856]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.856]                         if (muffled) 
[10:25:47.856]                           invokeRestart("muffleWarning")
[10:25:47.856]                       }
[10:25:47.856]                       else if (inherits(cond, "condition")) {
[10:25:47.856]                         if (!is.null(pattern)) {
[10:25:47.856]                           computeRestarts <- base::computeRestarts
[10:25:47.856]                           grepl <- base::grepl
[10:25:47.856]                           restarts <- computeRestarts(cond)
[10:25:47.856]                           for (restart in restarts) {
[10:25:47.856]                             name <- restart$name
[10:25:47.856]                             if (is.null(name)) 
[10:25:47.856]                               next
[10:25:47.856]                             if (!grepl(pattern, name)) 
[10:25:47.856]                               next
[10:25:47.856]                             invokeRestart(restart)
[10:25:47.856]                             muffled <- TRUE
[10:25:47.856]                             break
[10:25:47.856]                           }
[10:25:47.856]                         }
[10:25:47.856]                       }
[10:25:47.856]                       invisible(muffled)
[10:25:47.856]                     }
[10:25:47.856]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.856]                   }
[10:25:47.856]                 }
[10:25:47.856]                 else {
[10:25:47.856]                   if (TRUE) {
[10:25:47.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.856]                     {
[10:25:47.856]                       inherits <- base::inherits
[10:25:47.856]                       invokeRestart <- base::invokeRestart
[10:25:47.856]                       is.null <- base::is.null
[10:25:47.856]                       muffled <- FALSE
[10:25:47.856]                       if (inherits(cond, "message")) {
[10:25:47.856]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.856]                         if (muffled) 
[10:25:47.856]                           invokeRestart("muffleMessage")
[10:25:47.856]                       }
[10:25:47.856]                       else if (inherits(cond, "warning")) {
[10:25:47.856]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.856]                         if (muffled) 
[10:25:47.856]                           invokeRestart("muffleWarning")
[10:25:47.856]                       }
[10:25:47.856]                       else if (inherits(cond, "condition")) {
[10:25:47.856]                         if (!is.null(pattern)) {
[10:25:47.856]                           computeRestarts <- base::computeRestarts
[10:25:47.856]                           grepl <- base::grepl
[10:25:47.856]                           restarts <- computeRestarts(cond)
[10:25:47.856]                           for (restart in restarts) {
[10:25:47.856]                             name <- restart$name
[10:25:47.856]                             if (is.null(name)) 
[10:25:47.856]                               next
[10:25:47.856]                             if (!grepl(pattern, name)) 
[10:25:47.856]                               next
[10:25:47.856]                             invokeRestart(restart)
[10:25:47.856]                             muffled <- TRUE
[10:25:47.856]                             break
[10:25:47.856]                           }
[10:25:47.856]                         }
[10:25:47.856]                       }
[10:25:47.856]                       invisible(muffled)
[10:25:47.856]                     }
[10:25:47.856]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.856]                   }
[10:25:47.856]                 }
[10:25:47.856]             }
[10:25:47.856]         }))
[10:25:47.856]     }, error = function(ex) {
[10:25:47.856]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:47.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.856]                 ...future.rng), started = ...future.startTime, 
[10:25:47.856]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:47.856]             version = "1.8"), class = "FutureResult")
[10:25:47.856]     }, finally = {
[10:25:47.856]         if (!identical(...future.workdir, getwd())) 
[10:25:47.856]             setwd(...future.workdir)
[10:25:47.856]         {
[10:25:47.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:47.856]                 ...future.oldOptions$nwarnings <- NULL
[10:25:47.856]             }
[10:25:47.856]             base::options(...future.oldOptions)
[10:25:47.856]             if (.Platform$OS.type == "windows") {
[10:25:47.856]                 old_names <- names(...future.oldEnvVars)
[10:25:47.856]                 envs <- base::Sys.getenv()
[10:25:47.856]                 names <- names(envs)
[10:25:47.856]                 common <- intersect(names, old_names)
[10:25:47.856]                 added <- setdiff(names, old_names)
[10:25:47.856]                 removed <- setdiff(old_names, names)
[10:25:47.856]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:47.856]                   envs[common]]
[10:25:47.856]                 NAMES <- toupper(changed)
[10:25:47.856]                 args <- list()
[10:25:47.856]                 for (kk in seq_along(NAMES)) {
[10:25:47.856]                   name <- changed[[kk]]
[10:25:47.856]                   NAME <- NAMES[[kk]]
[10:25:47.856]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.856]                     next
[10:25:47.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.856]                 }
[10:25:47.856]                 NAMES <- toupper(added)
[10:25:47.856]                 for (kk in seq_along(NAMES)) {
[10:25:47.856]                   name <- added[[kk]]
[10:25:47.856]                   NAME <- NAMES[[kk]]
[10:25:47.856]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.856]                     next
[10:25:47.856]                   args[[name]] <- ""
[10:25:47.856]                 }
[10:25:47.856]                 NAMES <- toupper(removed)
[10:25:47.856]                 for (kk in seq_along(NAMES)) {
[10:25:47.856]                   name <- removed[[kk]]
[10:25:47.856]                   NAME <- NAMES[[kk]]
[10:25:47.856]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.856]                     next
[10:25:47.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.856]                 }
[10:25:47.856]                 if (length(args) > 0) 
[10:25:47.856]                   base::do.call(base::Sys.setenv, args = args)
[10:25:47.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:47.856]             }
[10:25:47.856]             else {
[10:25:47.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:47.856]             }
[10:25:47.856]             {
[10:25:47.856]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:47.856]                   0L) {
[10:25:47.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:47.856]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:47.856]                   base::options(opts)
[10:25:47.856]                 }
[10:25:47.856]                 {
[10:25:47.856]                   {
[10:25:47.856]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:47.856]                     NULL
[10:25:47.856]                   }
[10:25:47.856]                   options(future.plan = NULL)
[10:25:47.856]                   if (is.na(NA_character_)) 
[10:25:47.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:47.856]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:47.856]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:47.856]                     envir = parent.frame()) 
[10:25:47.856]                   {
[10:25:47.856]                     if (is.function(workers)) 
[10:25:47.856]                       workers <- workers()
[10:25:47.856]                     workers <- structure(as.integer(workers), 
[10:25:47.856]                       class = class(workers))
[10:25:47.856]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:47.856]                       workers >= 1)
[10:25:47.856]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:47.856]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:47.856]                     }
[10:25:47.856]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:47.856]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:47.856]                       envir = envir)
[10:25:47.856]                     if (!future$lazy) 
[10:25:47.856]                       future <- run(future)
[10:25:47.856]                     invisible(future)
[10:25:47.856]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:47.856]                 }
[10:25:47.856]             }
[10:25:47.856]         }
[10:25:47.856]     })
[10:25:47.856]     if (TRUE) {
[10:25:47.856]         base::sink(type = "output", split = FALSE)
[10:25:47.856]         if (TRUE) {
[10:25:47.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:47.856]         }
[10:25:47.856]         else {
[10:25:47.856]             ...future.result["stdout"] <- base::list(NULL)
[10:25:47.856]         }
[10:25:47.856]         base::close(...future.stdout)
[10:25:47.856]         ...future.stdout <- NULL
[10:25:47.856]     }
[10:25:47.856]     ...future.result$conditions <- ...future.conditions
[10:25:47.856]     ...future.result$finished <- base::Sys.time()
[10:25:47.856]     ...future.result
[10:25:47.856] }
[10:25:47.859] MultisessionFuture started
[10:25:47.860] - Launch lazy future ... done
[10:25:47.860] run() for ‘MultisessionFuture’ ... done
[10:25:47.860] getGlobalsAndPackages() ...
[10:25:47.860] Searching for globals...
[10:25:47.860] 
[10:25:47.860] Searching for globals ... DONE
[10:25:47.861] - globals: [0] <none>
[10:25:47.861] getGlobalsAndPackages() ... DONE
[10:25:47.861] run() for ‘Future’ ...
[10:25:47.861] - state: ‘created’
[10:25:47.861] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:47.875] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:47.875] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:47.875]   - Field: ‘node’
[10:25:47.875]   - Field: ‘label’
[10:25:47.875]   - Field: ‘local’
[10:25:47.875]   - Field: ‘owner’
[10:25:47.875]   - Field: ‘envir’
[10:25:47.875]   - Field: ‘workers’
[10:25:47.875]   - Field: ‘packages’
[10:25:47.875]   - Field: ‘gc’
[10:25:47.876]   - Field: ‘conditions’
[10:25:47.876]   - Field: ‘persistent’
[10:25:47.876]   - Field: ‘expr’
[10:25:47.876]   - Field: ‘uuid’
[10:25:47.876]   - Field: ‘seed’
[10:25:47.876]   - Field: ‘version’
[10:25:47.876]   - Field: ‘result’
[10:25:47.876]   - Field: ‘asynchronous’
[10:25:47.876]   - Field: ‘calls’
[10:25:47.876]   - Field: ‘globals’
[10:25:47.876]   - Field: ‘stdout’
[10:25:47.877]   - Field: ‘earlySignal’
[10:25:47.877]   - Field: ‘lazy’
[10:25:47.877]   - Field: ‘state’
[10:25:47.877] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:47.877] - Launch lazy future ...
[10:25:47.877] Packages needed by the future expression (n = 0): <none>
[10:25:47.877] Packages needed by future strategies (n = 0): <none>
[10:25:47.878] {
[10:25:47.878]     {
[10:25:47.878]         {
[10:25:47.878]             ...future.startTime <- base::Sys.time()
[10:25:47.878]             {
[10:25:47.878]                 {
[10:25:47.878]                   {
[10:25:47.878]                     {
[10:25:47.878]                       base::local({
[10:25:47.878]                         has_future <- base::requireNamespace("future", 
[10:25:47.878]                           quietly = TRUE)
[10:25:47.878]                         if (has_future) {
[10:25:47.878]                           ns <- base::getNamespace("future")
[10:25:47.878]                           version <- ns[[".package"]][["version"]]
[10:25:47.878]                           if (is.null(version)) 
[10:25:47.878]                             version <- utils::packageVersion("future")
[10:25:47.878]                         }
[10:25:47.878]                         else {
[10:25:47.878]                           version <- NULL
[10:25:47.878]                         }
[10:25:47.878]                         if (!has_future || version < "1.8.0") {
[10:25:47.878]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:47.878]                             "", base::R.version$version.string), 
[10:25:47.878]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:47.878]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:47.878]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:47.878]                               "release", "version")], collapse = " "), 
[10:25:47.878]                             hostname = base::Sys.info()[["nodename"]])
[10:25:47.878]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:47.878]                             info)
[10:25:47.878]                           info <- base::paste(info, collapse = "; ")
[10:25:47.878]                           if (!has_future) {
[10:25:47.878]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:47.878]                               info)
[10:25:47.878]                           }
[10:25:47.878]                           else {
[10:25:47.878]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:47.878]                               info, version)
[10:25:47.878]                           }
[10:25:47.878]                           base::stop(msg)
[10:25:47.878]                         }
[10:25:47.878]                       })
[10:25:47.878]                     }
[10:25:47.878]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:47.878]                     base::options(mc.cores = 1L)
[10:25:47.878]                   }
[10:25:47.878]                   options(future.plan = NULL)
[10:25:47.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:47.878]                 }
[10:25:47.878]                 ...future.workdir <- getwd()
[10:25:47.878]             }
[10:25:47.878]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:47.878]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:47.878]         }
[10:25:47.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:47.878]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:47.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:47.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:47.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:47.878]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:47.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:47.878]             base::names(...future.oldOptions))
[10:25:47.878]     }
[10:25:47.878]     if (FALSE) {
[10:25:47.878]     }
[10:25:47.878]     else {
[10:25:47.878]         if (TRUE) {
[10:25:47.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:47.878]                 open = "w")
[10:25:47.878]         }
[10:25:47.878]         else {
[10:25:47.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:47.878]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:47.878]         }
[10:25:47.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:47.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:47.878]             base::sink(type = "output", split = FALSE)
[10:25:47.878]             base::close(...future.stdout)
[10:25:47.878]         }, add = TRUE)
[10:25:47.878]     }
[10:25:47.878]     ...future.frame <- base::sys.nframe()
[10:25:47.878]     ...future.conditions <- base::list()
[10:25:47.878]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:47.878]     if (FALSE) {
[10:25:47.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:47.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:47.878]     }
[10:25:47.878]     ...future.result <- base::tryCatch({
[10:25:47.878]         base::withCallingHandlers({
[10:25:47.878]             ...future.value <- base::withVisible(base::local({
[10:25:47.878]                 ...future.makeSendCondition <- base::local({
[10:25:47.878]                   sendCondition <- NULL
[10:25:47.878]                   function(frame = 1L) {
[10:25:47.878]                     if (is.function(sendCondition)) 
[10:25:47.878]                       return(sendCondition)
[10:25:47.878]                     ns <- getNamespace("parallel")
[10:25:47.878]                     if (exists("sendData", mode = "function", 
[10:25:47.878]                       envir = ns)) {
[10:25:47.878]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:47.878]                         envir = ns)
[10:25:47.878]                       envir <- sys.frame(frame)
[10:25:47.878]                       master <- NULL
[10:25:47.878]                       while (!identical(envir, .GlobalEnv) && 
[10:25:47.878]                         !identical(envir, emptyenv())) {
[10:25:47.878]                         if (exists("master", mode = "list", envir = envir, 
[10:25:47.878]                           inherits = FALSE)) {
[10:25:47.878]                           master <- get("master", mode = "list", 
[10:25:47.878]                             envir = envir, inherits = FALSE)
[10:25:47.878]                           if (inherits(master, c("SOCKnode", 
[10:25:47.878]                             "SOCK0node"))) {
[10:25:47.878]                             sendCondition <<- function(cond) {
[10:25:47.878]                               data <- list(type = "VALUE", value = cond, 
[10:25:47.878]                                 success = TRUE)
[10:25:47.878]                               parallel_sendData(master, data)
[10:25:47.878]                             }
[10:25:47.878]                             return(sendCondition)
[10:25:47.878]                           }
[10:25:47.878]                         }
[10:25:47.878]                         frame <- frame + 1L
[10:25:47.878]                         envir <- sys.frame(frame)
[10:25:47.878]                       }
[10:25:47.878]                     }
[10:25:47.878]                     sendCondition <<- function(cond) NULL
[10:25:47.878]                   }
[10:25:47.878]                 })
[10:25:47.878]                 withCallingHandlers({
[10:25:47.878]                   NULL
[10:25:47.878]                 }, immediateCondition = function(cond) {
[10:25:47.878]                   sendCondition <- ...future.makeSendCondition()
[10:25:47.878]                   sendCondition(cond)
[10:25:47.878]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.878]                   {
[10:25:47.878]                     inherits <- base::inherits
[10:25:47.878]                     invokeRestart <- base::invokeRestart
[10:25:47.878]                     is.null <- base::is.null
[10:25:47.878]                     muffled <- FALSE
[10:25:47.878]                     if (inherits(cond, "message")) {
[10:25:47.878]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:47.878]                       if (muffled) 
[10:25:47.878]                         invokeRestart("muffleMessage")
[10:25:47.878]                     }
[10:25:47.878]                     else if (inherits(cond, "warning")) {
[10:25:47.878]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:47.878]                       if (muffled) 
[10:25:47.878]                         invokeRestart("muffleWarning")
[10:25:47.878]                     }
[10:25:47.878]                     else if (inherits(cond, "condition")) {
[10:25:47.878]                       if (!is.null(pattern)) {
[10:25:47.878]                         computeRestarts <- base::computeRestarts
[10:25:47.878]                         grepl <- base::grepl
[10:25:47.878]                         restarts <- computeRestarts(cond)
[10:25:47.878]                         for (restart in restarts) {
[10:25:47.878]                           name <- restart$name
[10:25:47.878]                           if (is.null(name)) 
[10:25:47.878]                             next
[10:25:47.878]                           if (!grepl(pattern, name)) 
[10:25:47.878]                             next
[10:25:47.878]                           invokeRestart(restart)
[10:25:47.878]                           muffled <- TRUE
[10:25:47.878]                           break
[10:25:47.878]                         }
[10:25:47.878]                       }
[10:25:47.878]                     }
[10:25:47.878]                     invisible(muffled)
[10:25:47.878]                   }
[10:25:47.878]                   muffleCondition(cond)
[10:25:47.878]                 })
[10:25:47.878]             }))
[10:25:47.878]             future::FutureResult(value = ...future.value$value, 
[10:25:47.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.878]                   ...future.rng), globalenv = if (FALSE) 
[10:25:47.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:47.878]                     ...future.globalenv.names))
[10:25:47.878]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:47.878]         }, condition = base::local({
[10:25:47.878]             c <- base::c
[10:25:47.878]             inherits <- base::inherits
[10:25:47.878]             invokeRestart <- base::invokeRestart
[10:25:47.878]             length <- base::length
[10:25:47.878]             list <- base::list
[10:25:47.878]             seq.int <- base::seq.int
[10:25:47.878]             signalCondition <- base::signalCondition
[10:25:47.878]             sys.calls <- base::sys.calls
[10:25:47.878]             `[[` <- base::`[[`
[10:25:47.878]             `+` <- base::`+`
[10:25:47.878]             `<<-` <- base::`<<-`
[10:25:47.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:47.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:47.878]                   3L)]
[10:25:47.878]             }
[10:25:47.878]             function(cond) {
[10:25:47.878]                 is_error <- inherits(cond, "error")
[10:25:47.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:47.878]                   NULL)
[10:25:47.878]                 if (is_error) {
[10:25:47.878]                   sessionInformation <- function() {
[10:25:47.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:47.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:47.878]                       search = base::search(), system = base::Sys.info())
[10:25:47.878]                   }
[10:25:47.878]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:47.878]                     cond$call), session = sessionInformation(), 
[10:25:47.878]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:47.878]                   signalCondition(cond)
[10:25:47.878]                 }
[10:25:47.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:47.878]                 "immediateCondition"))) {
[10:25:47.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:47.878]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:47.878]                   if (TRUE && !signal) {
[10:25:47.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.878]                     {
[10:25:47.878]                       inherits <- base::inherits
[10:25:47.878]                       invokeRestart <- base::invokeRestart
[10:25:47.878]                       is.null <- base::is.null
[10:25:47.878]                       muffled <- FALSE
[10:25:47.878]                       if (inherits(cond, "message")) {
[10:25:47.878]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.878]                         if (muffled) 
[10:25:47.878]                           invokeRestart("muffleMessage")
[10:25:47.878]                       }
[10:25:47.878]                       else if (inherits(cond, "warning")) {
[10:25:47.878]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.878]                         if (muffled) 
[10:25:47.878]                           invokeRestart("muffleWarning")
[10:25:47.878]                       }
[10:25:47.878]                       else if (inherits(cond, "condition")) {
[10:25:47.878]                         if (!is.null(pattern)) {
[10:25:47.878]                           computeRestarts <- base::computeRestarts
[10:25:47.878]                           grepl <- base::grepl
[10:25:47.878]                           restarts <- computeRestarts(cond)
[10:25:47.878]                           for (restart in restarts) {
[10:25:47.878]                             name <- restart$name
[10:25:47.878]                             if (is.null(name)) 
[10:25:47.878]                               next
[10:25:47.878]                             if (!grepl(pattern, name)) 
[10:25:47.878]                               next
[10:25:47.878]                             invokeRestart(restart)
[10:25:47.878]                             muffled <- TRUE
[10:25:47.878]                             break
[10:25:47.878]                           }
[10:25:47.878]                         }
[10:25:47.878]                       }
[10:25:47.878]                       invisible(muffled)
[10:25:47.878]                     }
[10:25:47.878]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.878]                   }
[10:25:47.878]                 }
[10:25:47.878]                 else {
[10:25:47.878]                   if (TRUE) {
[10:25:47.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.878]                     {
[10:25:47.878]                       inherits <- base::inherits
[10:25:47.878]                       invokeRestart <- base::invokeRestart
[10:25:47.878]                       is.null <- base::is.null
[10:25:47.878]                       muffled <- FALSE
[10:25:47.878]                       if (inherits(cond, "message")) {
[10:25:47.878]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.878]                         if (muffled) 
[10:25:47.878]                           invokeRestart("muffleMessage")
[10:25:47.878]                       }
[10:25:47.878]                       else if (inherits(cond, "warning")) {
[10:25:47.878]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.878]                         if (muffled) 
[10:25:47.878]                           invokeRestart("muffleWarning")
[10:25:47.878]                       }
[10:25:47.878]                       else if (inherits(cond, "condition")) {
[10:25:47.878]                         if (!is.null(pattern)) {
[10:25:47.878]                           computeRestarts <- base::computeRestarts
[10:25:47.878]                           grepl <- base::grepl
[10:25:47.878]                           restarts <- computeRestarts(cond)
[10:25:47.878]                           for (restart in restarts) {
[10:25:47.878]                             name <- restart$name
[10:25:47.878]                             if (is.null(name)) 
[10:25:47.878]                               next
[10:25:47.878]                             if (!grepl(pattern, name)) 
[10:25:47.878]                               next
[10:25:47.878]                             invokeRestart(restart)
[10:25:47.878]                             muffled <- TRUE
[10:25:47.878]                             break
[10:25:47.878]                           }
[10:25:47.878]                         }
[10:25:47.878]                       }
[10:25:47.878]                       invisible(muffled)
[10:25:47.878]                     }
[10:25:47.878]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.878]                   }
[10:25:47.878]                 }
[10:25:47.878]             }
[10:25:47.878]         }))
[10:25:47.878]     }, error = function(ex) {
[10:25:47.878]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:47.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.878]                 ...future.rng), started = ...future.startTime, 
[10:25:47.878]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:47.878]             version = "1.8"), class = "FutureResult")
[10:25:47.878]     }, finally = {
[10:25:47.878]         if (!identical(...future.workdir, getwd())) 
[10:25:47.878]             setwd(...future.workdir)
[10:25:47.878]         {
[10:25:47.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:47.878]                 ...future.oldOptions$nwarnings <- NULL
[10:25:47.878]             }
[10:25:47.878]             base::options(...future.oldOptions)
[10:25:47.878]             if (.Platform$OS.type == "windows") {
[10:25:47.878]                 old_names <- names(...future.oldEnvVars)
[10:25:47.878]                 envs <- base::Sys.getenv()
[10:25:47.878]                 names <- names(envs)
[10:25:47.878]                 common <- intersect(names, old_names)
[10:25:47.878]                 added <- setdiff(names, old_names)
[10:25:47.878]                 removed <- setdiff(old_names, names)
[10:25:47.878]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:47.878]                   envs[common]]
[10:25:47.878]                 NAMES <- toupper(changed)
[10:25:47.878]                 args <- list()
[10:25:47.878]                 for (kk in seq_along(NAMES)) {
[10:25:47.878]                   name <- changed[[kk]]
[10:25:47.878]                   NAME <- NAMES[[kk]]
[10:25:47.878]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.878]                     next
[10:25:47.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.878]                 }
[10:25:47.878]                 NAMES <- toupper(added)
[10:25:47.878]                 for (kk in seq_along(NAMES)) {
[10:25:47.878]                   name <- added[[kk]]
[10:25:47.878]                   NAME <- NAMES[[kk]]
[10:25:47.878]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.878]                     next
[10:25:47.878]                   args[[name]] <- ""
[10:25:47.878]                 }
[10:25:47.878]                 NAMES <- toupper(removed)
[10:25:47.878]                 for (kk in seq_along(NAMES)) {
[10:25:47.878]                   name <- removed[[kk]]
[10:25:47.878]                   NAME <- NAMES[[kk]]
[10:25:47.878]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.878]                     next
[10:25:47.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.878]                 }
[10:25:47.878]                 if (length(args) > 0) 
[10:25:47.878]                   base::do.call(base::Sys.setenv, args = args)
[10:25:47.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:47.878]             }
[10:25:47.878]             else {
[10:25:47.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:47.878]             }
[10:25:47.878]             {
[10:25:47.878]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:47.878]                   0L) {
[10:25:47.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:47.878]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:47.878]                   base::options(opts)
[10:25:47.878]                 }
[10:25:47.878]                 {
[10:25:47.878]                   {
[10:25:47.878]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:47.878]                     NULL
[10:25:47.878]                   }
[10:25:47.878]                   options(future.plan = NULL)
[10:25:47.878]                   if (is.na(NA_character_)) 
[10:25:47.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:47.878]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:47.878]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:47.878]                     envir = parent.frame()) 
[10:25:47.878]                   {
[10:25:47.878]                     if (is.function(workers)) 
[10:25:47.878]                       workers <- workers()
[10:25:47.878]                     workers <- structure(as.integer(workers), 
[10:25:47.878]                       class = class(workers))
[10:25:47.878]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:47.878]                       workers >= 1)
[10:25:47.878]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:47.878]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:47.878]                     }
[10:25:47.878]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:47.878]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:47.878]                       envir = envir)
[10:25:47.878]                     if (!future$lazy) 
[10:25:47.878]                       future <- run(future)
[10:25:47.878]                     invisible(future)
[10:25:47.878]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:47.878]                 }
[10:25:47.878]             }
[10:25:47.878]         }
[10:25:47.878]     })
[10:25:47.878]     if (TRUE) {
[10:25:47.878]         base::sink(type = "output", split = FALSE)
[10:25:47.878]         if (TRUE) {
[10:25:47.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:47.878]         }
[10:25:47.878]         else {
[10:25:47.878]             ...future.result["stdout"] <- base::list(NULL)
[10:25:47.878]         }
[10:25:47.878]         base::close(...future.stdout)
[10:25:47.878]         ...future.stdout <- NULL
[10:25:47.878]     }
[10:25:47.878]     ...future.result$conditions <- ...future.conditions
[10:25:47.878]     ...future.result$finished <- base::Sys.time()
[10:25:47.878]     ...future.result
[10:25:47.878] }
[10:25:47.881] MultisessionFuture started
[10:25:47.881] - Launch lazy future ... done
[10:25:47.881] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f6b5e4f0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f6eb3bc0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f6b5e4f0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f6eb3bc0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:47.911] resolve() on list ...
[10:25:47.911]  recursive: 0
[10:25:47.911]  length: 6
[10:25:47.911]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:47.911] signalConditionsASAP(numeric, pos=1) ...
[10:25:47.911] - nx: 6
[10:25:47.911] - relay: TRUE
[10:25:47.911] - stdout: TRUE
[10:25:47.911] - signal: TRUE
[10:25:47.911] - resignal: FALSE
[10:25:47.911] - force: TRUE
[10:25:47.912] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.912] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.912]  - until=2
[10:25:47.912]  - relaying element #2
[10:25:47.912] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.912] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.912] signalConditionsASAP(NULL, pos=1) ... done
[10:25:47.912]  length: 5 (resolved future 1)
[10:25:47.913] receiveMessageFromWorker() for ClusterFuture ...
[10:25:47.913] - Validating connection of MultisessionFuture
[10:25:47.913] - received message: FutureResult
[10:25:47.913] - Received FutureResult
[10:25:47.913] - Erased future from FutureRegistry
[10:25:47.913] result() for ClusterFuture ...
[10:25:47.913] - result already collected: FutureResult
[10:25:47.913] result() for ClusterFuture ... done
[10:25:47.914] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:47.914] Future #2
[10:25:47.914] result() for ClusterFuture ...
[10:25:47.914] - result already collected: FutureResult
[10:25:47.914] result() for ClusterFuture ... done
[10:25:47.914] result() for ClusterFuture ...
[10:25:47.914] - result already collected: FutureResult
[10:25:47.914] result() for ClusterFuture ... done
[10:25:47.914] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:47.914] - nx: 6
[10:25:47.914] - relay: TRUE
[10:25:47.914] - stdout: TRUE
[10:25:47.915] - signal: TRUE
[10:25:47.915] - resignal: FALSE
[10:25:47.915] - force: TRUE
[10:25:47.915] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.915] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:47.915]  - until=2
[10:25:47.915]  - relaying element #2
[10:25:47.915] result() for ClusterFuture ...
[10:25:47.915] - result already collected: FutureResult
[10:25:47.915] result() for ClusterFuture ... done
[10:25:47.915] result() for ClusterFuture ...
[10:25:47.915] - result already collected: FutureResult
[10:25:47.916] result() for ClusterFuture ... done
[10:25:47.916] result() for ClusterFuture ...
[10:25:47.916] - result already collected: FutureResult
[10:25:47.916] result() for ClusterFuture ... done
[10:25:47.916] result() for ClusterFuture ...
[10:25:47.916] - result already collected: FutureResult
[10:25:47.916] result() for ClusterFuture ... done
[10:25:47.916] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.916] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.916] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:47.916]  length: 4 (resolved future 2)
[10:25:47.926] receiveMessageFromWorker() for ClusterFuture ...
[10:25:47.926] - Validating connection of MultisessionFuture
[10:25:47.926] - received message: FutureResult
[10:25:47.926] - Received FutureResult
[10:25:47.927] - Erased future from FutureRegistry
[10:25:47.927] result() for ClusterFuture ...
[10:25:47.927] - result already collected: FutureResult
[10:25:47.927] result() for ClusterFuture ... done
[10:25:47.927] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:47.927] Future #3
[10:25:47.927] result() for ClusterFuture ...
[10:25:47.927] - result already collected: FutureResult
[10:25:47.927] result() for ClusterFuture ... done
[10:25:47.927] result() for ClusterFuture ...
[10:25:47.927] - result already collected: FutureResult
[10:25:47.927] result() for ClusterFuture ... done
[10:25:47.928] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:47.928] - nx: 6
[10:25:47.928] - relay: TRUE
[10:25:47.928] - stdout: TRUE
[10:25:47.928] - signal: TRUE
[10:25:47.928] - resignal: FALSE
[10:25:47.928] - force: TRUE
[10:25:47.928] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.928] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:47.928]  - until=3
[10:25:47.928]  - relaying element #3
[10:25:47.928] result() for ClusterFuture ...
[10:25:47.929] - result already collected: FutureResult
[10:25:47.929] result() for ClusterFuture ... done
[10:25:47.929] result() for ClusterFuture ...
[10:25:47.929] - result already collected: FutureResult
[10:25:47.929] result() for ClusterFuture ... done
[10:25:47.929] result() for ClusterFuture ...
[10:25:47.929] - result already collected: FutureResult
[10:25:47.929] result() for ClusterFuture ... done
[10:25:47.929] result() for ClusterFuture ...
[10:25:47.929] - result already collected: FutureResult
[10:25:47.929] result() for ClusterFuture ... done
[10:25:47.930] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.930] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.930] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:47.930]  length: 3 (resolved future 3)
[10:25:47.930] signalConditionsASAP(NULL, pos=4) ...
[10:25:47.930] - nx: 6
[10:25:47.930] - relay: TRUE
[10:25:47.930] - stdout: TRUE
[10:25:47.930] - signal: TRUE
[10:25:47.930] - resignal: FALSE
[10:25:47.930] - force: TRUE
[10:25:47.931] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.931]  - until=5
[10:25:47.931]  - relaying element #5
[10:25:47.931] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:47.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.931] signalConditionsASAP(NULL, pos=4) ... done
[10:25:47.931]  length: 2 (resolved future 4)
[10:25:47.931] signalConditionsASAP(NULL, pos=5) ...
[10:25:47.931] - nx: 6
[10:25:47.931] - relay: TRUE
[10:25:47.931] - stdout: TRUE
[10:25:47.932] - signal: TRUE
[10:25:47.932] - resignal: FALSE
[10:25:47.932] - force: TRUE
[10:25:47.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:47.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.932]  - until=6
[10:25:47.932]  - relaying element #6
[10:25:47.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:47.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.932] signalConditionsASAP(NULL, pos=5) ... done
[10:25:47.932]  length: 1 (resolved future 5)
[10:25:47.932] signalConditionsASAP(numeric, pos=6) ...
[10:25:47.933] - nx: 6
[10:25:47.933] - relay: TRUE
[10:25:47.933] - stdout: TRUE
[10:25:47.933] - signal: TRUE
[10:25:47.933] - resignal: FALSE
[10:25:47.933] - force: TRUE
[10:25:47.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:47.933] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.933]  - until=6
[10:25:47.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:47.933] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.933] signalConditionsASAP(numeric, pos=6) ... done
[10:25:47.934]  length: 0 (resolved future 6)
[10:25:47.934] Relaying remaining futures
[10:25:47.934] signalConditionsASAP(NULL, pos=0) ...
[10:25:47.934] - nx: 6
[10:25:47.934] - relay: TRUE
[10:25:47.934] - stdout: TRUE
[10:25:47.934] - signal: TRUE
[10:25:47.934] - resignal: FALSE
[10:25:47.934] - force: TRUE
[10:25:47.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:47.934] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:47.935] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:47.935] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:47.935] signalConditionsASAP(NULL, pos=0) ... done
[10:25:47.935] resolve() on list ... DONE
[10:25:47.935] result() for ClusterFuture ...
[10:25:47.935] - result already collected: FutureResult
[10:25:47.935] result() for ClusterFuture ... done
[10:25:47.935] result() for ClusterFuture ...
[10:25:47.935] - result already collected: FutureResult
[10:25:47.935] result() for ClusterFuture ... done
[10:25:47.935] result() for ClusterFuture ...
[10:25:47.935] - result already collected: FutureResult
[10:25:47.936] result() for ClusterFuture ... done
[10:25:47.936] result() for ClusterFuture ...
[10:25:47.936] - result already collected: FutureResult
[10:25:47.936] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:25:47.939] getGlobalsAndPackages() ...
[10:25:47.939] Searching for globals...
[10:25:47.939] 
[10:25:47.939] Searching for globals ... DONE
[10:25:47.940] - globals: [0] <none>
[10:25:47.940] getGlobalsAndPackages() ... DONE
[10:25:47.940] run() for ‘Future’ ...
[10:25:47.940] - state: ‘created’
[10:25:47.940] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:47.954] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:47.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:47.954]   - Field: ‘node’
[10:25:47.954]   - Field: ‘label’
[10:25:47.954]   - Field: ‘local’
[10:25:47.954]   - Field: ‘owner’
[10:25:47.954]   - Field: ‘envir’
[10:25:47.954]   - Field: ‘workers’
[10:25:47.954]   - Field: ‘packages’
[10:25:47.955]   - Field: ‘gc’
[10:25:47.955]   - Field: ‘conditions’
[10:25:47.955]   - Field: ‘persistent’
[10:25:47.955]   - Field: ‘expr’
[10:25:47.955]   - Field: ‘uuid’
[10:25:47.955]   - Field: ‘seed’
[10:25:47.955]   - Field: ‘version’
[10:25:47.955]   - Field: ‘result’
[10:25:47.955]   - Field: ‘asynchronous’
[10:25:47.955]   - Field: ‘calls’
[10:25:47.955]   - Field: ‘globals’
[10:25:47.956]   - Field: ‘stdout’
[10:25:47.956]   - Field: ‘earlySignal’
[10:25:47.956]   - Field: ‘lazy’
[10:25:47.956]   - Field: ‘state’
[10:25:47.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:47.956] - Launch lazy future ...
[10:25:47.956] Packages needed by the future expression (n = 0): <none>
[10:25:47.956] Packages needed by future strategies (n = 0): <none>
[10:25:47.957] {
[10:25:47.957]     {
[10:25:47.957]         {
[10:25:47.957]             ...future.startTime <- base::Sys.time()
[10:25:47.957]             {
[10:25:47.957]                 {
[10:25:47.957]                   {
[10:25:47.957]                     {
[10:25:47.957]                       base::local({
[10:25:47.957]                         has_future <- base::requireNamespace("future", 
[10:25:47.957]                           quietly = TRUE)
[10:25:47.957]                         if (has_future) {
[10:25:47.957]                           ns <- base::getNamespace("future")
[10:25:47.957]                           version <- ns[[".package"]][["version"]]
[10:25:47.957]                           if (is.null(version)) 
[10:25:47.957]                             version <- utils::packageVersion("future")
[10:25:47.957]                         }
[10:25:47.957]                         else {
[10:25:47.957]                           version <- NULL
[10:25:47.957]                         }
[10:25:47.957]                         if (!has_future || version < "1.8.0") {
[10:25:47.957]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:47.957]                             "", base::R.version$version.string), 
[10:25:47.957]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:47.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:47.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:47.957]                               "release", "version")], collapse = " "), 
[10:25:47.957]                             hostname = base::Sys.info()[["nodename"]])
[10:25:47.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:47.957]                             info)
[10:25:47.957]                           info <- base::paste(info, collapse = "; ")
[10:25:47.957]                           if (!has_future) {
[10:25:47.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:47.957]                               info)
[10:25:47.957]                           }
[10:25:47.957]                           else {
[10:25:47.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:47.957]                               info, version)
[10:25:47.957]                           }
[10:25:47.957]                           base::stop(msg)
[10:25:47.957]                         }
[10:25:47.957]                       })
[10:25:47.957]                     }
[10:25:47.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:47.957]                     base::options(mc.cores = 1L)
[10:25:47.957]                   }
[10:25:47.957]                   options(future.plan = NULL)
[10:25:47.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:47.957]                 }
[10:25:47.957]                 ...future.workdir <- getwd()
[10:25:47.957]             }
[10:25:47.957]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:47.957]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:47.957]         }
[10:25:47.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:47.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:47.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:47.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:47.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:47.957]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:47.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:47.957]             base::names(...future.oldOptions))
[10:25:47.957]     }
[10:25:47.957]     if (FALSE) {
[10:25:47.957]     }
[10:25:47.957]     else {
[10:25:47.957]         if (TRUE) {
[10:25:47.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:47.957]                 open = "w")
[10:25:47.957]         }
[10:25:47.957]         else {
[10:25:47.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:47.957]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:47.957]         }
[10:25:47.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:47.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:47.957]             base::sink(type = "output", split = FALSE)
[10:25:47.957]             base::close(...future.stdout)
[10:25:47.957]         }, add = TRUE)
[10:25:47.957]     }
[10:25:47.957]     ...future.frame <- base::sys.nframe()
[10:25:47.957]     ...future.conditions <- base::list()
[10:25:47.957]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:47.957]     if (FALSE) {
[10:25:47.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:47.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:47.957]     }
[10:25:47.957]     ...future.result <- base::tryCatch({
[10:25:47.957]         base::withCallingHandlers({
[10:25:47.957]             ...future.value <- base::withVisible(base::local({
[10:25:47.957]                 ...future.makeSendCondition <- base::local({
[10:25:47.957]                   sendCondition <- NULL
[10:25:47.957]                   function(frame = 1L) {
[10:25:47.957]                     if (is.function(sendCondition)) 
[10:25:47.957]                       return(sendCondition)
[10:25:47.957]                     ns <- getNamespace("parallel")
[10:25:47.957]                     if (exists("sendData", mode = "function", 
[10:25:47.957]                       envir = ns)) {
[10:25:47.957]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:47.957]                         envir = ns)
[10:25:47.957]                       envir <- sys.frame(frame)
[10:25:47.957]                       master <- NULL
[10:25:47.957]                       while (!identical(envir, .GlobalEnv) && 
[10:25:47.957]                         !identical(envir, emptyenv())) {
[10:25:47.957]                         if (exists("master", mode = "list", envir = envir, 
[10:25:47.957]                           inherits = FALSE)) {
[10:25:47.957]                           master <- get("master", mode = "list", 
[10:25:47.957]                             envir = envir, inherits = FALSE)
[10:25:47.957]                           if (inherits(master, c("SOCKnode", 
[10:25:47.957]                             "SOCK0node"))) {
[10:25:47.957]                             sendCondition <<- function(cond) {
[10:25:47.957]                               data <- list(type = "VALUE", value = cond, 
[10:25:47.957]                                 success = TRUE)
[10:25:47.957]                               parallel_sendData(master, data)
[10:25:47.957]                             }
[10:25:47.957]                             return(sendCondition)
[10:25:47.957]                           }
[10:25:47.957]                         }
[10:25:47.957]                         frame <- frame + 1L
[10:25:47.957]                         envir <- sys.frame(frame)
[10:25:47.957]                       }
[10:25:47.957]                     }
[10:25:47.957]                     sendCondition <<- function(cond) NULL
[10:25:47.957]                   }
[10:25:47.957]                 })
[10:25:47.957]                 withCallingHandlers({
[10:25:47.957]                   2
[10:25:47.957]                 }, immediateCondition = function(cond) {
[10:25:47.957]                   sendCondition <- ...future.makeSendCondition()
[10:25:47.957]                   sendCondition(cond)
[10:25:47.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.957]                   {
[10:25:47.957]                     inherits <- base::inherits
[10:25:47.957]                     invokeRestart <- base::invokeRestart
[10:25:47.957]                     is.null <- base::is.null
[10:25:47.957]                     muffled <- FALSE
[10:25:47.957]                     if (inherits(cond, "message")) {
[10:25:47.957]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:47.957]                       if (muffled) 
[10:25:47.957]                         invokeRestart("muffleMessage")
[10:25:47.957]                     }
[10:25:47.957]                     else if (inherits(cond, "warning")) {
[10:25:47.957]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:47.957]                       if (muffled) 
[10:25:47.957]                         invokeRestart("muffleWarning")
[10:25:47.957]                     }
[10:25:47.957]                     else if (inherits(cond, "condition")) {
[10:25:47.957]                       if (!is.null(pattern)) {
[10:25:47.957]                         computeRestarts <- base::computeRestarts
[10:25:47.957]                         grepl <- base::grepl
[10:25:47.957]                         restarts <- computeRestarts(cond)
[10:25:47.957]                         for (restart in restarts) {
[10:25:47.957]                           name <- restart$name
[10:25:47.957]                           if (is.null(name)) 
[10:25:47.957]                             next
[10:25:47.957]                           if (!grepl(pattern, name)) 
[10:25:47.957]                             next
[10:25:47.957]                           invokeRestart(restart)
[10:25:47.957]                           muffled <- TRUE
[10:25:47.957]                           break
[10:25:47.957]                         }
[10:25:47.957]                       }
[10:25:47.957]                     }
[10:25:47.957]                     invisible(muffled)
[10:25:47.957]                   }
[10:25:47.957]                   muffleCondition(cond)
[10:25:47.957]                 })
[10:25:47.957]             }))
[10:25:47.957]             future::FutureResult(value = ...future.value$value, 
[10:25:47.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.957]                   ...future.rng), globalenv = if (FALSE) 
[10:25:47.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:47.957]                     ...future.globalenv.names))
[10:25:47.957]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:47.957]         }, condition = base::local({
[10:25:47.957]             c <- base::c
[10:25:47.957]             inherits <- base::inherits
[10:25:47.957]             invokeRestart <- base::invokeRestart
[10:25:47.957]             length <- base::length
[10:25:47.957]             list <- base::list
[10:25:47.957]             seq.int <- base::seq.int
[10:25:47.957]             signalCondition <- base::signalCondition
[10:25:47.957]             sys.calls <- base::sys.calls
[10:25:47.957]             `[[` <- base::`[[`
[10:25:47.957]             `+` <- base::`+`
[10:25:47.957]             `<<-` <- base::`<<-`
[10:25:47.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:47.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:47.957]                   3L)]
[10:25:47.957]             }
[10:25:47.957]             function(cond) {
[10:25:47.957]                 is_error <- inherits(cond, "error")
[10:25:47.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:47.957]                   NULL)
[10:25:47.957]                 if (is_error) {
[10:25:47.957]                   sessionInformation <- function() {
[10:25:47.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:47.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:47.957]                       search = base::search(), system = base::Sys.info())
[10:25:47.957]                   }
[10:25:47.957]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:47.957]                     cond$call), session = sessionInformation(), 
[10:25:47.957]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:47.957]                   signalCondition(cond)
[10:25:47.957]                 }
[10:25:47.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:47.957]                 "immediateCondition"))) {
[10:25:47.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:47.957]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:47.957]                   if (TRUE && !signal) {
[10:25:47.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.957]                     {
[10:25:47.957]                       inherits <- base::inherits
[10:25:47.957]                       invokeRestart <- base::invokeRestart
[10:25:47.957]                       is.null <- base::is.null
[10:25:47.957]                       muffled <- FALSE
[10:25:47.957]                       if (inherits(cond, "message")) {
[10:25:47.957]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.957]                         if (muffled) 
[10:25:47.957]                           invokeRestart("muffleMessage")
[10:25:47.957]                       }
[10:25:47.957]                       else if (inherits(cond, "warning")) {
[10:25:47.957]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.957]                         if (muffled) 
[10:25:47.957]                           invokeRestart("muffleWarning")
[10:25:47.957]                       }
[10:25:47.957]                       else if (inherits(cond, "condition")) {
[10:25:47.957]                         if (!is.null(pattern)) {
[10:25:47.957]                           computeRestarts <- base::computeRestarts
[10:25:47.957]                           grepl <- base::grepl
[10:25:47.957]                           restarts <- computeRestarts(cond)
[10:25:47.957]                           for (restart in restarts) {
[10:25:47.957]                             name <- restart$name
[10:25:47.957]                             if (is.null(name)) 
[10:25:47.957]                               next
[10:25:47.957]                             if (!grepl(pattern, name)) 
[10:25:47.957]                               next
[10:25:47.957]                             invokeRestart(restart)
[10:25:47.957]                             muffled <- TRUE
[10:25:47.957]                             break
[10:25:47.957]                           }
[10:25:47.957]                         }
[10:25:47.957]                       }
[10:25:47.957]                       invisible(muffled)
[10:25:47.957]                     }
[10:25:47.957]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.957]                   }
[10:25:47.957]                 }
[10:25:47.957]                 else {
[10:25:47.957]                   if (TRUE) {
[10:25:47.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.957]                     {
[10:25:47.957]                       inherits <- base::inherits
[10:25:47.957]                       invokeRestart <- base::invokeRestart
[10:25:47.957]                       is.null <- base::is.null
[10:25:47.957]                       muffled <- FALSE
[10:25:47.957]                       if (inherits(cond, "message")) {
[10:25:47.957]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.957]                         if (muffled) 
[10:25:47.957]                           invokeRestart("muffleMessage")
[10:25:47.957]                       }
[10:25:47.957]                       else if (inherits(cond, "warning")) {
[10:25:47.957]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.957]                         if (muffled) 
[10:25:47.957]                           invokeRestart("muffleWarning")
[10:25:47.957]                       }
[10:25:47.957]                       else if (inherits(cond, "condition")) {
[10:25:47.957]                         if (!is.null(pattern)) {
[10:25:47.957]                           computeRestarts <- base::computeRestarts
[10:25:47.957]                           grepl <- base::grepl
[10:25:47.957]                           restarts <- computeRestarts(cond)
[10:25:47.957]                           for (restart in restarts) {
[10:25:47.957]                             name <- restart$name
[10:25:47.957]                             if (is.null(name)) 
[10:25:47.957]                               next
[10:25:47.957]                             if (!grepl(pattern, name)) 
[10:25:47.957]                               next
[10:25:47.957]                             invokeRestart(restart)
[10:25:47.957]                             muffled <- TRUE
[10:25:47.957]                             break
[10:25:47.957]                           }
[10:25:47.957]                         }
[10:25:47.957]                       }
[10:25:47.957]                       invisible(muffled)
[10:25:47.957]                     }
[10:25:47.957]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.957]                   }
[10:25:47.957]                 }
[10:25:47.957]             }
[10:25:47.957]         }))
[10:25:47.957]     }, error = function(ex) {
[10:25:47.957]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:47.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.957]                 ...future.rng), started = ...future.startTime, 
[10:25:47.957]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:47.957]             version = "1.8"), class = "FutureResult")
[10:25:47.957]     }, finally = {
[10:25:47.957]         if (!identical(...future.workdir, getwd())) 
[10:25:47.957]             setwd(...future.workdir)
[10:25:47.957]         {
[10:25:47.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:47.957]                 ...future.oldOptions$nwarnings <- NULL
[10:25:47.957]             }
[10:25:47.957]             base::options(...future.oldOptions)
[10:25:47.957]             if (.Platform$OS.type == "windows") {
[10:25:47.957]                 old_names <- names(...future.oldEnvVars)
[10:25:47.957]                 envs <- base::Sys.getenv()
[10:25:47.957]                 names <- names(envs)
[10:25:47.957]                 common <- intersect(names, old_names)
[10:25:47.957]                 added <- setdiff(names, old_names)
[10:25:47.957]                 removed <- setdiff(old_names, names)
[10:25:47.957]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:47.957]                   envs[common]]
[10:25:47.957]                 NAMES <- toupper(changed)
[10:25:47.957]                 args <- list()
[10:25:47.957]                 for (kk in seq_along(NAMES)) {
[10:25:47.957]                   name <- changed[[kk]]
[10:25:47.957]                   NAME <- NAMES[[kk]]
[10:25:47.957]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.957]                     next
[10:25:47.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.957]                 }
[10:25:47.957]                 NAMES <- toupper(added)
[10:25:47.957]                 for (kk in seq_along(NAMES)) {
[10:25:47.957]                   name <- added[[kk]]
[10:25:47.957]                   NAME <- NAMES[[kk]]
[10:25:47.957]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.957]                     next
[10:25:47.957]                   args[[name]] <- ""
[10:25:47.957]                 }
[10:25:47.957]                 NAMES <- toupper(removed)
[10:25:47.957]                 for (kk in seq_along(NAMES)) {
[10:25:47.957]                   name <- removed[[kk]]
[10:25:47.957]                   NAME <- NAMES[[kk]]
[10:25:47.957]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.957]                     next
[10:25:47.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.957]                 }
[10:25:47.957]                 if (length(args) > 0) 
[10:25:47.957]                   base::do.call(base::Sys.setenv, args = args)
[10:25:47.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:47.957]             }
[10:25:47.957]             else {
[10:25:47.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:47.957]             }
[10:25:47.957]             {
[10:25:47.957]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:47.957]                   0L) {
[10:25:47.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:47.957]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:47.957]                   base::options(opts)
[10:25:47.957]                 }
[10:25:47.957]                 {
[10:25:47.957]                   {
[10:25:47.957]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:47.957]                     NULL
[10:25:47.957]                   }
[10:25:47.957]                   options(future.plan = NULL)
[10:25:47.957]                   if (is.na(NA_character_)) 
[10:25:47.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:47.957]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:47.957]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:47.957]                     envir = parent.frame()) 
[10:25:47.957]                   {
[10:25:47.957]                     if (is.function(workers)) 
[10:25:47.957]                       workers <- workers()
[10:25:47.957]                     workers <- structure(as.integer(workers), 
[10:25:47.957]                       class = class(workers))
[10:25:47.957]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:47.957]                       workers >= 1)
[10:25:47.957]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:47.957]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:47.957]                     }
[10:25:47.957]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:47.957]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:47.957]                       envir = envir)
[10:25:47.957]                     if (!future$lazy) 
[10:25:47.957]                       future <- run(future)
[10:25:47.957]                     invisible(future)
[10:25:47.957]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:47.957]                 }
[10:25:47.957]             }
[10:25:47.957]         }
[10:25:47.957]     })
[10:25:47.957]     if (TRUE) {
[10:25:47.957]         base::sink(type = "output", split = FALSE)
[10:25:47.957]         if (TRUE) {
[10:25:47.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:47.957]         }
[10:25:47.957]         else {
[10:25:47.957]             ...future.result["stdout"] <- base::list(NULL)
[10:25:47.957]         }
[10:25:47.957]         base::close(...future.stdout)
[10:25:47.957]         ...future.stdout <- NULL
[10:25:47.957]     }
[10:25:47.957]     ...future.result$conditions <- ...future.conditions
[10:25:47.957]     ...future.result$finished <- base::Sys.time()
[10:25:47.957]     ...future.result
[10:25:47.957] }
[10:25:47.960] MultisessionFuture started
[10:25:47.960] - Launch lazy future ... done
[10:25:47.960] run() for ‘MultisessionFuture’ ... done
[10:25:47.960] getGlobalsAndPackages() ...
[10:25:47.960] Searching for globals...
[10:25:47.960] 
[10:25:47.960] Searching for globals ... DONE
[10:25:47.961] - globals: [0] <none>
[10:25:47.961] getGlobalsAndPackages() ... DONE
[10:25:47.961] run() for ‘Future’ ...
[10:25:47.961] - state: ‘created’
[10:25:47.961] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:47.974] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:47.975] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:47.975]   - Field: ‘node’
[10:25:47.975]   - Field: ‘label’
[10:25:47.975]   - Field: ‘local’
[10:25:47.975]   - Field: ‘owner’
[10:25:47.975]   - Field: ‘envir’
[10:25:47.975]   - Field: ‘workers’
[10:25:47.975]   - Field: ‘packages’
[10:25:47.975]   - Field: ‘gc’
[10:25:47.975]   - Field: ‘conditions’
[10:25:47.976]   - Field: ‘persistent’
[10:25:47.976]   - Field: ‘expr’
[10:25:47.976]   - Field: ‘uuid’
[10:25:47.976]   - Field: ‘seed’
[10:25:47.976]   - Field: ‘version’
[10:25:47.976]   - Field: ‘result’
[10:25:47.976]   - Field: ‘asynchronous’
[10:25:47.976]   - Field: ‘calls’
[10:25:47.976]   - Field: ‘globals’
[10:25:47.976]   - Field: ‘stdout’
[10:25:47.976]   - Field: ‘earlySignal’
[10:25:47.976]   - Field: ‘lazy’
[10:25:47.977]   - Field: ‘state’
[10:25:47.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:47.977] - Launch lazy future ...
[10:25:47.977] Packages needed by the future expression (n = 0): <none>
[10:25:47.977] Packages needed by future strategies (n = 0): <none>
[10:25:47.978] {
[10:25:47.978]     {
[10:25:47.978]         {
[10:25:47.978]             ...future.startTime <- base::Sys.time()
[10:25:47.978]             {
[10:25:47.978]                 {
[10:25:47.978]                   {
[10:25:47.978]                     {
[10:25:47.978]                       base::local({
[10:25:47.978]                         has_future <- base::requireNamespace("future", 
[10:25:47.978]                           quietly = TRUE)
[10:25:47.978]                         if (has_future) {
[10:25:47.978]                           ns <- base::getNamespace("future")
[10:25:47.978]                           version <- ns[[".package"]][["version"]]
[10:25:47.978]                           if (is.null(version)) 
[10:25:47.978]                             version <- utils::packageVersion("future")
[10:25:47.978]                         }
[10:25:47.978]                         else {
[10:25:47.978]                           version <- NULL
[10:25:47.978]                         }
[10:25:47.978]                         if (!has_future || version < "1.8.0") {
[10:25:47.978]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:47.978]                             "", base::R.version$version.string), 
[10:25:47.978]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:47.978]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:47.978]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:47.978]                               "release", "version")], collapse = " "), 
[10:25:47.978]                             hostname = base::Sys.info()[["nodename"]])
[10:25:47.978]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:47.978]                             info)
[10:25:47.978]                           info <- base::paste(info, collapse = "; ")
[10:25:47.978]                           if (!has_future) {
[10:25:47.978]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:47.978]                               info)
[10:25:47.978]                           }
[10:25:47.978]                           else {
[10:25:47.978]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:47.978]                               info, version)
[10:25:47.978]                           }
[10:25:47.978]                           base::stop(msg)
[10:25:47.978]                         }
[10:25:47.978]                       })
[10:25:47.978]                     }
[10:25:47.978]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:47.978]                     base::options(mc.cores = 1L)
[10:25:47.978]                   }
[10:25:47.978]                   options(future.plan = NULL)
[10:25:47.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:47.978]                 }
[10:25:47.978]                 ...future.workdir <- getwd()
[10:25:47.978]             }
[10:25:47.978]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:47.978]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:47.978]         }
[10:25:47.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:47.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:47.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:47.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:47.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:47.978]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:47.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:47.978]             base::names(...future.oldOptions))
[10:25:47.978]     }
[10:25:47.978]     if (FALSE) {
[10:25:47.978]     }
[10:25:47.978]     else {
[10:25:47.978]         if (TRUE) {
[10:25:47.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:47.978]                 open = "w")
[10:25:47.978]         }
[10:25:47.978]         else {
[10:25:47.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:47.978]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:47.978]         }
[10:25:47.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:47.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:47.978]             base::sink(type = "output", split = FALSE)
[10:25:47.978]             base::close(...future.stdout)
[10:25:47.978]         }, add = TRUE)
[10:25:47.978]     }
[10:25:47.978]     ...future.frame <- base::sys.nframe()
[10:25:47.978]     ...future.conditions <- base::list()
[10:25:47.978]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:47.978]     if (FALSE) {
[10:25:47.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:47.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:47.978]     }
[10:25:47.978]     ...future.result <- base::tryCatch({
[10:25:47.978]         base::withCallingHandlers({
[10:25:47.978]             ...future.value <- base::withVisible(base::local({
[10:25:47.978]                 ...future.makeSendCondition <- base::local({
[10:25:47.978]                   sendCondition <- NULL
[10:25:47.978]                   function(frame = 1L) {
[10:25:47.978]                     if (is.function(sendCondition)) 
[10:25:47.978]                       return(sendCondition)
[10:25:47.978]                     ns <- getNamespace("parallel")
[10:25:47.978]                     if (exists("sendData", mode = "function", 
[10:25:47.978]                       envir = ns)) {
[10:25:47.978]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:47.978]                         envir = ns)
[10:25:47.978]                       envir <- sys.frame(frame)
[10:25:47.978]                       master <- NULL
[10:25:47.978]                       while (!identical(envir, .GlobalEnv) && 
[10:25:47.978]                         !identical(envir, emptyenv())) {
[10:25:47.978]                         if (exists("master", mode = "list", envir = envir, 
[10:25:47.978]                           inherits = FALSE)) {
[10:25:47.978]                           master <- get("master", mode = "list", 
[10:25:47.978]                             envir = envir, inherits = FALSE)
[10:25:47.978]                           if (inherits(master, c("SOCKnode", 
[10:25:47.978]                             "SOCK0node"))) {
[10:25:47.978]                             sendCondition <<- function(cond) {
[10:25:47.978]                               data <- list(type = "VALUE", value = cond, 
[10:25:47.978]                                 success = TRUE)
[10:25:47.978]                               parallel_sendData(master, data)
[10:25:47.978]                             }
[10:25:47.978]                             return(sendCondition)
[10:25:47.978]                           }
[10:25:47.978]                         }
[10:25:47.978]                         frame <- frame + 1L
[10:25:47.978]                         envir <- sys.frame(frame)
[10:25:47.978]                       }
[10:25:47.978]                     }
[10:25:47.978]                     sendCondition <<- function(cond) NULL
[10:25:47.978]                   }
[10:25:47.978]                 })
[10:25:47.978]                 withCallingHandlers({
[10:25:47.978]                   NULL
[10:25:47.978]                 }, immediateCondition = function(cond) {
[10:25:47.978]                   sendCondition <- ...future.makeSendCondition()
[10:25:47.978]                   sendCondition(cond)
[10:25:47.978]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.978]                   {
[10:25:47.978]                     inherits <- base::inherits
[10:25:47.978]                     invokeRestart <- base::invokeRestart
[10:25:47.978]                     is.null <- base::is.null
[10:25:47.978]                     muffled <- FALSE
[10:25:47.978]                     if (inherits(cond, "message")) {
[10:25:47.978]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:47.978]                       if (muffled) 
[10:25:47.978]                         invokeRestart("muffleMessage")
[10:25:47.978]                     }
[10:25:47.978]                     else if (inherits(cond, "warning")) {
[10:25:47.978]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:47.978]                       if (muffled) 
[10:25:47.978]                         invokeRestart("muffleWarning")
[10:25:47.978]                     }
[10:25:47.978]                     else if (inherits(cond, "condition")) {
[10:25:47.978]                       if (!is.null(pattern)) {
[10:25:47.978]                         computeRestarts <- base::computeRestarts
[10:25:47.978]                         grepl <- base::grepl
[10:25:47.978]                         restarts <- computeRestarts(cond)
[10:25:47.978]                         for (restart in restarts) {
[10:25:47.978]                           name <- restart$name
[10:25:47.978]                           if (is.null(name)) 
[10:25:47.978]                             next
[10:25:47.978]                           if (!grepl(pattern, name)) 
[10:25:47.978]                             next
[10:25:47.978]                           invokeRestart(restart)
[10:25:47.978]                           muffled <- TRUE
[10:25:47.978]                           break
[10:25:47.978]                         }
[10:25:47.978]                       }
[10:25:47.978]                     }
[10:25:47.978]                     invisible(muffled)
[10:25:47.978]                   }
[10:25:47.978]                   muffleCondition(cond)
[10:25:47.978]                 })
[10:25:47.978]             }))
[10:25:47.978]             future::FutureResult(value = ...future.value$value, 
[10:25:47.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.978]                   ...future.rng), globalenv = if (FALSE) 
[10:25:47.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:47.978]                     ...future.globalenv.names))
[10:25:47.978]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:47.978]         }, condition = base::local({
[10:25:47.978]             c <- base::c
[10:25:47.978]             inherits <- base::inherits
[10:25:47.978]             invokeRestart <- base::invokeRestart
[10:25:47.978]             length <- base::length
[10:25:47.978]             list <- base::list
[10:25:47.978]             seq.int <- base::seq.int
[10:25:47.978]             signalCondition <- base::signalCondition
[10:25:47.978]             sys.calls <- base::sys.calls
[10:25:47.978]             `[[` <- base::`[[`
[10:25:47.978]             `+` <- base::`+`
[10:25:47.978]             `<<-` <- base::`<<-`
[10:25:47.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:47.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:47.978]                   3L)]
[10:25:47.978]             }
[10:25:47.978]             function(cond) {
[10:25:47.978]                 is_error <- inherits(cond, "error")
[10:25:47.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:47.978]                   NULL)
[10:25:47.978]                 if (is_error) {
[10:25:47.978]                   sessionInformation <- function() {
[10:25:47.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:47.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:47.978]                       search = base::search(), system = base::Sys.info())
[10:25:47.978]                   }
[10:25:47.978]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:47.978]                     cond$call), session = sessionInformation(), 
[10:25:47.978]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:47.978]                   signalCondition(cond)
[10:25:47.978]                 }
[10:25:47.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:47.978]                 "immediateCondition"))) {
[10:25:47.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:47.978]                   ...future.conditions[[length(...future.conditions) + 
[10:25:47.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:47.978]                   if (TRUE && !signal) {
[10:25:47.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.978]                     {
[10:25:47.978]                       inherits <- base::inherits
[10:25:47.978]                       invokeRestart <- base::invokeRestart
[10:25:47.978]                       is.null <- base::is.null
[10:25:47.978]                       muffled <- FALSE
[10:25:47.978]                       if (inherits(cond, "message")) {
[10:25:47.978]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.978]                         if (muffled) 
[10:25:47.978]                           invokeRestart("muffleMessage")
[10:25:47.978]                       }
[10:25:47.978]                       else if (inherits(cond, "warning")) {
[10:25:47.978]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.978]                         if (muffled) 
[10:25:47.978]                           invokeRestart("muffleWarning")
[10:25:47.978]                       }
[10:25:47.978]                       else if (inherits(cond, "condition")) {
[10:25:47.978]                         if (!is.null(pattern)) {
[10:25:47.978]                           computeRestarts <- base::computeRestarts
[10:25:47.978]                           grepl <- base::grepl
[10:25:47.978]                           restarts <- computeRestarts(cond)
[10:25:47.978]                           for (restart in restarts) {
[10:25:47.978]                             name <- restart$name
[10:25:47.978]                             if (is.null(name)) 
[10:25:47.978]                               next
[10:25:47.978]                             if (!grepl(pattern, name)) 
[10:25:47.978]                               next
[10:25:47.978]                             invokeRestart(restart)
[10:25:47.978]                             muffled <- TRUE
[10:25:47.978]                             break
[10:25:47.978]                           }
[10:25:47.978]                         }
[10:25:47.978]                       }
[10:25:47.978]                       invisible(muffled)
[10:25:47.978]                     }
[10:25:47.978]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.978]                   }
[10:25:47.978]                 }
[10:25:47.978]                 else {
[10:25:47.978]                   if (TRUE) {
[10:25:47.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:47.978]                     {
[10:25:47.978]                       inherits <- base::inherits
[10:25:47.978]                       invokeRestart <- base::invokeRestart
[10:25:47.978]                       is.null <- base::is.null
[10:25:47.978]                       muffled <- FALSE
[10:25:47.978]                       if (inherits(cond, "message")) {
[10:25:47.978]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:47.978]                         if (muffled) 
[10:25:47.978]                           invokeRestart("muffleMessage")
[10:25:47.978]                       }
[10:25:47.978]                       else if (inherits(cond, "warning")) {
[10:25:47.978]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:47.978]                         if (muffled) 
[10:25:47.978]                           invokeRestart("muffleWarning")
[10:25:47.978]                       }
[10:25:47.978]                       else if (inherits(cond, "condition")) {
[10:25:47.978]                         if (!is.null(pattern)) {
[10:25:47.978]                           computeRestarts <- base::computeRestarts
[10:25:47.978]                           grepl <- base::grepl
[10:25:47.978]                           restarts <- computeRestarts(cond)
[10:25:47.978]                           for (restart in restarts) {
[10:25:47.978]                             name <- restart$name
[10:25:47.978]                             if (is.null(name)) 
[10:25:47.978]                               next
[10:25:47.978]                             if (!grepl(pattern, name)) 
[10:25:47.978]                               next
[10:25:47.978]                             invokeRestart(restart)
[10:25:47.978]                             muffled <- TRUE
[10:25:47.978]                             break
[10:25:47.978]                           }
[10:25:47.978]                         }
[10:25:47.978]                       }
[10:25:47.978]                       invisible(muffled)
[10:25:47.978]                     }
[10:25:47.978]                     muffleCondition(cond, pattern = "^muffle")
[10:25:47.978]                   }
[10:25:47.978]                 }
[10:25:47.978]             }
[10:25:47.978]         }))
[10:25:47.978]     }, error = function(ex) {
[10:25:47.978]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:47.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:47.978]                 ...future.rng), started = ...future.startTime, 
[10:25:47.978]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:47.978]             version = "1.8"), class = "FutureResult")
[10:25:47.978]     }, finally = {
[10:25:47.978]         if (!identical(...future.workdir, getwd())) 
[10:25:47.978]             setwd(...future.workdir)
[10:25:47.978]         {
[10:25:47.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:47.978]                 ...future.oldOptions$nwarnings <- NULL
[10:25:47.978]             }
[10:25:47.978]             base::options(...future.oldOptions)
[10:25:47.978]             if (.Platform$OS.type == "windows") {
[10:25:47.978]                 old_names <- names(...future.oldEnvVars)
[10:25:47.978]                 envs <- base::Sys.getenv()
[10:25:47.978]                 names <- names(envs)
[10:25:47.978]                 common <- intersect(names, old_names)
[10:25:47.978]                 added <- setdiff(names, old_names)
[10:25:47.978]                 removed <- setdiff(old_names, names)
[10:25:47.978]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:47.978]                   envs[common]]
[10:25:47.978]                 NAMES <- toupper(changed)
[10:25:47.978]                 args <- list()
[10:25:47.978]                 for (kk in seq_along(NAMES)) {
[10:25:47.978]                   name <- changed[[kk]]
[10:25:47.978]                   NAME <- NAMES[[kk]]
[10:25:47.978]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.978]                     next
[10:25:47.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.978]                 }
[10:25:47.978]                 NAMES <- toupper(added)
[10:25:47.978]                 for (kk in seq_along(NAMES)) {
[10:25:47.978]                   name <- added[[kk]]
[10:25:47.978]                   NAME <- NAMES[[kk]]
[10:25:47.978]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.978]                     next
[10:25:47.978]                   args[[name]] <- ""
[10:25:47.978]                 }
[10:25:47.978]                 NAMES <- toupper(removed)
[10:25:47.978]                 for (kk in seq_along(NAMES)) {
[10:25:47.978]                   name <- removed[[kk]]
[10:25:47.978]                   NAME <- NAMES[[kk]]
[10:25:47.978]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:47.978]                     next
[10:25:47.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:47.978]                 }
[10:25:47.978]                 if (length(args) > 0) 
[10:25:47.978]                   base::do.call(base::Sys.setenv, args = args)
[10:25:47.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:47.978]             }
[10:25:47.978]             else {
[10:25:47.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:47.978]             }
[10:25:47.978]             {
[10:25:47.978]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:47.978]                   0L) {
[10:25:47.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:47.978]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:47.978]                   base::options(opts)
[10:25:47.978]                 }
[10:25:47.978]                 {
[10:25:47.978]                   {
[10:25:47.978]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:47.978]                     NULL
[10:25:47.978]                   }
[10:25:47.978]                   options(future.plan = NULL)
[10:25:47.978]                   if (is.na(NA_character_)) 
[10:25:47.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:47.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:47.978]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:47.978]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:47.978]                     envir = parent.frame()) 
[10:25:47.978]                   {
[10:25:47.978]                     if (is.function(workers)) 
[10:25:47.978]                       workers <- workers()
[10:25:47.978]                     workers <- structure(as.integer(workers), 
[10:25:47.978]                       class = class(workers))
[10:25:47.978]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:47.978]                       workers >= 1)
[10:25:47.978]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:47.978]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:47.978]                     }
[10:25:47.978]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:47.978]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:47.978]                       envir = envir)
[10:25:47.978]                     if (!future$lazy) 
[10:25:47.978]                       future <- run(future)
[10:25:47.978]                     invisible(future)
[10:25:47.978]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:47.978]                 }
[10:25:47.978]             }
[10:25:47.978]         }
[10:25:47.978]     })
[10:25:47.978]     if (TRUE) {
[10:25:47.978]         base::sink(type = "output", split = FALSE)
[10:25:47.978]         if (TRUE) {
[10:25:47.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:47.978]         }
[10:25:47.978]         else {
[10:25:47.978]             ...future.result["stdout"] <- base::list(NULL)
[10:25:47.978]         }
[10:25:47.978]         base::close(...future.stdout)
[10:25:47.978]         ...future.stdout <- NULL
[10:25:47.978]     }
[10:25:47.978]     ...future.result$conditions <- ...future.conditions
[10:25:47.978]     ...future.result$finished <- base::Sys.time()
[10:25:47.978]     ...future.result
[10:25:47.978] }
[10:25:47.981] MultisessionFuture started
[10:25:47.981] - Launch lazy future ... done
[10:25:47.981] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f2fed150> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f61b4e78> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f2fed150> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f61b4e78> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:48.009] resolve() on list ...
[10:25:48.009]  recursive: 0
[10:25:48.009]  length: 6
[10:25:48.009]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:48.009] signalConditionsASAP(numeric, pos=1) ...
[10:25:48.009] - nx: 6
[10:25:48.009] - relay: TRUE
[10:25:48.009] - stdout: TRUE
[10:25:48.009] - signal: TRUE
[10:25:48.009] - resignal: FALSE
[10:25:48.010] - force: TRUE
[10:25:48.010] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.010] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.010]  - until=2
[10:25:48.010]  - relaying element #2
[10:25:48.010] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.010] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.010] signalConditionsASAP(NULL, pos=1) ... done
[10:25:48.010]  length: 5 (resolved future 1)
[10:25:48.011] receiveMessageFromWorker() for ClusterFuture ...
[10:25:48.011] - Validating connection of MultisessionFuture
[10:25:48.011] - received message: FutureResult
[10:25:48.011] - Received FutureResult
[10:25:48.011] - Erased future from FutureRegistry
[10:25:48.011] result() for ClusterFuture ...
[10:25:48.011] - result already collected: FutureResult
[10:25:48.011] result() for ClusterFuture ... done
[10:25:48.012] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:48.012] Future #2
[10:25:48.012] result() for ClusterFuture ...
[10:25:48.012] - result already collected: FutureResult
[10:25:48.012] result() for ClusterFuture ... done
[10:25:48.012] result() for ClusterFuture ...
[10:25:48.012] - result already collected: FutureResult
[10:25:48.012] result() for ClusterFuture ... done
[10:25:48.012] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:48.012] - nx: 6
[10:25:48.012] - relay: TRUE
[10:25:48.013] - stdout: TRUE
[10:25:48.013] - signal: TRUE
[10:25:48.013] - resignal: FALSE
[10:25:48.013] - force: TRUE
[10:25:48.013] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.013] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.013]  - until=2
[10:25:48.013]  - relaying element #2
[10:25:48.013] result() for ClusterFuture ...
[10:25:48.013] - result already collected: FutureResult
[10:25:48.013] result() for ClusterFuture ... done
[10:25:48.013] result() for ClusterFuture ...
[10:25:48.014] - result already collected: FutureResult
[10:25:48.014] result() for ClusterFuture ... done
[10:25:48.014] result() for ClusterFuture ...
[10:25:48.014] - result already collected: FutureResult
[10:25:48.014] result() for ClusterFuture ... done
[10:25:48.014] result() for ClusterFuture ...
[10:25:48.014] - result already collected: FutureResult
[10:25:48.014] result() for ClusterFuture ... done
[10:25:48.014] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.014] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.014] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:48.015]  length: 4 (resolved future 2)
[10:25:48.025] signalConditionsASAP(NULL, pos=4) ...
[10:25:48.025] - nx: 6
[10:25:48.025] - relay: TRUE
[10:25:48.025] - stdout: TRUE
[10:25:48.026] - signal: TRUE
[10:25:48.026] - resignal: FALSE
[10:25:48.026] - force: TRUE
[10:25:48.026] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.026] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.026]  - until=5
[10:25:48.026]  - relaying element #3
[10:25:48.026]  - relaying element #5
[10:25:48.026] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[10:25:48.026] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.026] signalConditionsASAP(NULL, pos=4) ... done
[10:25:48.026]  length: 3 (resolved future 4)
[10:25:48.027] signalConditionsASAP(NULL, pos=5) ...
[10:25:48.027] - nx: 6
[10:25:48.027] - relay: TRUE
[10:25:48.027] - stdout: TRUE
[10:25:48.027] - signal: TRUE
[10:25:48.027] - resignal: FALSE
[10:25:48.027] - force: TRUE
[10:25:48.027] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[10:25:48.027] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.027]  - until=6
[10:25:48.027]  - relaying element #3
[10:25:48.027]  - relaying element #6
[10:25:48.028] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[10:25:48.028] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.028] signalConditionsASAP(NULL, pos=5) ... done
[10:25:48.028]  length: 2 (resolved future 5)
[10:25:48.028] signalConditionsASAP(numeric, pos=6) ...
[10:25:48.028] - nx: 6
[10:25:48.028] - relay: TRUE
[10:25:48.028] - stdout: TRUE
[10:25:48.028] - signal: TRUE
[10:25:48.028] - resignal: FALSE
[10:25:48.028] - force: TRUE
[10:25:48.028] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[10:25:48.029] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.029]  - until=6
[10:25:48.029]  - relaying element #3
[10:25:48.029] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[10:25:48.029] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.029] signalConditionsASAP(NULL, pos=6) ... done
[10:25:48.029]  length: 1 (resolved future 6)
[10:25:48.040] receiveMessageFromWorker() for ClusterFuture ...
[10:25:48.040] - Validating connection of MultisessionFuture
[10:25:48.040] - received message: FutureResult
[10:25:48.040] - Received FutureResult
[10:25:48.040] - Erased future from FutureRegistry
[10:25:48.040] result() for ClusterFuture ...
[10:25:48.041] - result already collected: FutureResult
[10:25:48.041] result() for ClusterFuture ... done
[10:25:48.041] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:48.041] Future #3
[10:25:48.041] result() for ClusterFuture ...
[10:25:48.041] - result already collected: FutureResult
[10:25:48.041] result() for ClusterFuture ... done
[10:25:48.041] result() for ClusterFuture ...
[10:25:48.041] - result already collected: FutureResult
[10:25:48.041] result() for ClusterFuture ... done
[10:25:48.042] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:48.042] - nx: 6
[10:25:48.042] - relay: TRUE
[10:25:48.042] - stdout: TRUE
[10:25:48.042] - signal: TRUE
[10:25:48.042] - resignal: FALSE
[10:25:48.042] - force: TRUE
[10:25:48.042] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[10:25:48.042] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.042]  - until=6
[10:25:48.042]  - relaying element #3
[10:25:48.042] result() for ClusterFuture ...
[10:25:48.043] - result already collected: FutureResult
[10:25:48.043] result() for ClusterFuture ... done
[10:25:48.043] result() for ClusterFuture ...
[10:25:48.043] - result already collected: FutureResult
[10:25:48.043] result() for ClusterFuture ... done
[10:25:48.043] result() for ClusterFuture ...
[10:25:48.043] - result already collected: FutureResult
[10:25:48.043] result() for ClusterFuture ... done
[10:25:48.043] result() for ClusterFuture ...
[10:25:48.043] - result already collected: FutureResult
[10:25:48.043] result() for ClusterFuture ... done
[10:25:48.043] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:48.044] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.044] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:48.044]  length: 0 (resolved future 3)
[10:25:48.044] Relaying remaining futures
[10:25:48.044] signalConditionsASAP(NULL, pos=0) ...
[10:25:48.044] - nx: 6
[10:25:48.044] - relay: TRUE
[10:25:48.044] - stdout: TRUE
[10:25:48.044] - signal: TRUE
[10:25:48.044] - resignal: FALSE
[10:25:48.044] - force: TRUE
[10:25:48.044] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:48.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:48.045] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:48.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.045] signalConditionsASAP(NULL, pos=0) ... done
[10:25:48.045] resolve() on list ... DONE
[10:25:48.045] result() for ClusterFuture ...
[10:25:48.045] - result already collected: FutureResult
[10:25:48.045] result() for ClusterFuture ... done
[10:25:48.045] result() for ClusterFuture ...
[10:25:48.045] - result already collected: FutureResult
[10:25:48.046] result() for ClusterFuture ... done
[10:25:48.046] result() for ClusterFuture ...
[10:25:48.046] - result already collected: FutureResult
[10:25:48.046] result() for ClusterFuture ... done
[10:25:48.046] result() for ClusterFuture ...
[10:25:48.046] - result already collected: FutureResult
[10:25:48.046] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:25:48.051] getGlobalsAndPackages() ...
[10:25:48.051] Searching for globals...
[10:25:48.052] 
[10:25:48.052] Searching for globals ... DONE
[10:25:48.052] - globals: [0] <none>
[10:25:48.052] getGlobalsAndPackages() ... DONE
[10:25:48.052] run() for ‘Future’ ...
[10:25:48.052] - state: ‘created’
[10:25:48.052] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.066] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:48.067]   - Field: ‘node’
[10:25:48.067]   - Field: ‘label’
[10:25:48.067]   - Field: ‘local’
[10:25:48.067]   - Field: ‘owner’
[10:25:48.067]   - Field: ‘envir’
[10:25:48.067]   - Field: ‘workers’
[10:25:48.067]   - Field: ‘packages’
[10:25:48.067]   - Field: ‘gc’
[10:25:48.067]   - Field: ‘conditions’
[10:25:48.067]   - Field: ‘persistent’
[10:25:48.067]   - Field: ‘expr’
[10:25:48.068]   - Field: ‘uuid’
[10:25:48.068]   - Field: ‘seed’
[10:25:48.068]   - Field: ‘version’
[10:25:48.068]   - Field: ‘result’
[10:25:48.068]   - Field: ‘asynchronous’
[10:25:48.068]   - Field: ‘calls’
[10:25:48.068]   - Field: ‘globals’
[10:25:48.068]   - Field: ‘stdout’
[10:25:48.068]   - Field: ‘earlySignal’
[10:25:48.068]   - Field: ‘lazy’
[10:25:48.068]   - Field: ‘state’
[10:25:48.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:48.069] - Launch lazy future ...
[10:25:48.069] Packages needed by the future expression (n = 0): <none>
[10:25:48.069] Packages needed by future strategies (n = 0): <none>
[10:25:48.069] {
[10:25:48.069]     {
[10:25:48.069]         {
[10:25:48.069]             ...future.startTime <- base::Sys.time()
[10:25:48.069]             {
[10:25:48.069]                 {
[10:25:48.069]                   {
[10:25:48.069]                     {
[10:25:48.069]                       base::local({
[10:25:48.069]                         has_future <- base::requireNamespace("future", 
[10:25:48.069]                           quietly = TRUE)
[10:25:48.069]                         if (has_future) {
[10:25:48.069]                           ns <- base::getNamespace("future")
[10:25:48.069]                           version <- ns[[".package"]][["version"]]
[10:25:48.069]                           if (is.null(version)) 
[10:25:48.069]                             version <- utils::packageVersion("future")
[10:25:48.069]                         }
[10:25:48.069]                         else {
[10:25:48.069]                           version <- NULL
[10:25:48.069]                         }
[10:25:48.069]                         if (!has_future || version < "1.8.0") {
[10:25:48.069]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.069]                             "", base::R.version$version.string), 
[10:25:48.069]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.069]                               "release", "version")], collapse = " "), 
[10:25:48.069]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.069]                             info)
[10:25:48.069]                           info <- base::paste(info, collapse = "; ")
[10:25:48.069]                           if (!has_future) {
[10:25:48.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.069]                               info)
[10:25:48.069]                           }
[10:25:48.069]                           else {
[10:25:48.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.069]                               info, version)
[10:25:48.069]                           }
[10:25:48.069]                           base::stop(msg)
[10:25:48.069]                         }
[10:25:48.069]                       })
[10:25:48.069]                     }
[10:25:48.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.069]                     base::options(mc.cores = 1L)
[10:25:48.069]                   }
[10:25:48.069]                   options(future.plan = NULL)
[10:25:48.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.069]                 }
[10:25:48.069]                 ...future.workdir <- getwd()
[10:25:48.069]             }
[10:25:48.069]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.069]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.069]         }
[10:25:48.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.069]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.069]             base::names(...future.oldOptions))
[10:25:48.069]     }
[10:25:48.069]     if (FALSE) {
[10:25:48.069]     }
[10:25:48.069]     else {
[10:25:48.069]         if (TRUE) {
[10:25:48.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.069]                 open = "w")
[10:25:48.069]         }
[10:25:48.069]         else {
[10:25:48.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.069]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.069]         }
[10:25:48.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.069]             base::sink(type = "output", split = FALSE)
[10:25:48.069]             base::close(...future.stdout)
[10:25:48.069]         }, add = TRUE)
[10:25:48.069]     }
[10:25:48.069]     ...future.frame <- base::sys.nframe()
[10:25:48.069]     ...future.conditions <- base::list()
[10:25:48.069]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.069]     if (FALSE) {
[10:25:48.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.069]     }
[10:25:48.069]     ...future.result <- base::tryCatch({
[10:25:48.069]         base::withCallingHandlers({
[10:25:48.069]             ...future.value <- base::withVisible(base::local({
[10:25:48.069]                 ...future.makeSendCondition <- base::local({
[10:25:48.069]                   sendCondition <- NULL
[10:25:48.069]                   function(frame = 1L) {
[10:25:48.069]                     if (is.function(sendCondition)) 
[10:25:48.069]                       return(sendCondition)
[10:25:48.069]                     ns <- getNamespace("parallel")
[10:25:48.069]                     if (exists("sendData", mode = "function", 
[10:25:48.069]                       envir = ns)) {
[10:25:48.069]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:48.069]                         envir = ns)
[10:25:48.069]                       envir <- sys.frame(frame)
[10:25:48.069]                       master <- NULL
[10:25:48.069]                       while (!identical(envir, .GlobalEnv) && 
[10:25:48.069]                         !identical(envir, emptyenv())) {
[10:25:48.069]                         if (exists("master", mode = "list", envir = envir, 
[10:25:48.069]                           inherits = FALSE)) {
[10:25:48.069]                           master <- get("master", mode = "list", 
[10:25:48.069]                             envir = envir, inherits = FALSE)
[10:25:48.069]                           if (inherits(master, c("SOCKnode", 
[10:25:48.069]                             "SOCK0node"))) {
[10:25:48.069]                             sendCondition <<- function(cond) {
[10:25:48.069]                               data <- list(type = "VALUE", value = cond, 
[10:25:48.069]                                 success = TRUE)
[10:25:48.069]                               parallel_sendData(master, data)
[10:25:48.069]                             }
[10:25:48.069]                             return(sendCondition)
[10:25:48.069]                           }
[10:25:48.069]                         }
[10:25:48.069]                         frame <- frame + 1L
[10:25:48.069]                         envir <- sys.frame(frame)
[10:25:48.069]                       }
[10:25:48.069]                     }
[10:25:48.069]                     sendCondition <<- function(cond) NULL
[10:25:48.069]                   }
[10:25:48.069]                 })
[10:25:48.069]                 withCallingHandlers({
[10:25:48.069]                   2
[10:25:48.069]                 }, immediateCondition = function(cond) {
[10:25:48.069]                   sendCondition <- ...future.makeSendCondition()
[10:25:48.069]                   sendCondition(cond)
[10:25:48.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.069]                   {
[10:25:48.069]                     inherits <- base::inherits
[10:25:48.069]                     invokeRestart <- base::invokeRestart
[10:25:48.069]                     is.null <- base::is.null
[10:25:48.069]                     muffled <- FALSE
[10:25:48.069]                     if (inherits(cond, "message")) {
[10:25:48.069]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.069]                       if (muffled) 
[10:25:48.069]                         invokeRestart("muffleMessage")
[10:25:48.069]                     }
[10:25:48.069]                     else if (inherits(cond, "warning")) {
[10:25:48.069]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.069]                       if (muffled) 
[10:25:48.069]                         invokeRestart("muffleWarning")
[10:25:48.069]                     }
[10:25:48.069]                     else if (inherits(cond, "condition")) {
[10:25:48.069]                       if (!is.null(pattern)) {
[10:25:48.069]                         computeRestarts <- base::computeRestarts
[10:25:48.069]                         grepl <- base::grepl
[10:25:48.069]                         restarts <- computeRestarts(cond)
[10:25:48.069]                         for (restart in restarts) {
[10:25:48.069]                           name <- restart$name
[10:25:48.069]                           if (is.null(name)) 
[10:25:48.069]                             next
[10:25:48.069]                           if (!grepl(pattern, name)) 
[10:25:48.069]                             next
[10:25:48.069]                           invokeRestart(restart)
[10:25:48.069]                           muffled <- TRUE
[10:25:48.069]                           break
[10:25:48.069]                         }
[10:25:48.069]                       }
[10:25:48.069]                     }
[10:25:48.069]                     invisible(muffled)
[10:25:48.069]                   }
[10:25:48.069]                   muffleCondition(cond)
[10:25:48.069]                 })
[10:25:48.069]             }))
[10:25:48.069]             future::FutureResult(value = ...future.value$value, 
[10:25:48.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.069]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.069]                     ...future.globalenv.names))
[10:25:48.069]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.069]         }, condition = base::local({
[10:25:48.069]             c <- base::c
[10:25:48.069]             inherits <- base::inherits
[10:25:48.069]             invokeRestart <- base::invokeRestart
[10:25:48.069]             length <- base::length
[10:25:48.069]             list <- base::list
[10:25:48.069]             seq.int <- base::seq.int
[10:25:48.069]             signalCondition <- base::signalCondition
[10:25:48.069]             sys.calls <- base::sys.calls
[10:25:48.069]             `[[` <- base::`[[`
[10:25:48.069]             `+` <- base::`+`
[10:25:48.069]             `<<-` <- base::`<<-`
[10:25:48.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.069]                   3L)]
[10:25:48.069]             }
[10:25:48.069]             function(cond) {
[10:25:48.069]                 is_error <- inherits(cond, "error")
[10:25:48.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.069]                   NULL)
[10:25:48.069]                 if (is_error) {
[10:25:48.069]                   sessionInformation <- function() {
[10:25:48.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.069]                       search = base::search(), system = base::Sys.info())
[10:25:48.069]                   }
[10:25:48.069]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.069]                     cond$call), session = sessionInformation(), 
[10:25:48.069]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.069]                   signalCondition(cond)
[10:25:48.069]                 }
[10:25:48.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.069]                 "immediateCondition"))) {
[10:25:48.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.069]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.069]                   if (TRUE && !signal) {
[10:25:48.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.069]                     {
[10:25:48.069]                       inherits <- base::inherits
[10:25:48.069]                       invokeRestart <- base::invokeRestart
[10:25:48.069]                       is.null <- base::is.null
[10:25:48.069]                       muffled <- FALSE
[10:25:48.069]                       if (inherits(cond, "message")) {
[10:25:48.069]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.069]                         if (muffled) 
[10:25:48.069]                           invokeRestart("muffleMessage")
[10:25:48.069]                       }
[10:25:48.069]                       else if (inherits(cond, "warning")) {
[10:25:48.069]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.069]                         if (muffled) 
[10:25:48.069]                           invokeRestart("muffleWarning")
[10:25:48.069]                       }
[10:25:48.069]                       else if (inherits(cond, "condition")) {
[10:25:48.069]                         if (!is.null(pattern)) {
[10:25:48.069]                           computeRestarts <- base::computeRestarts
[10:25:48.069]                           grepl <- base::grepl
[10:25:48.069]                           restarts <- computeRestarts(cond)
[10:25:48.069]                           for (restart in restarts) {
[10:25:48.069]                             name <- restart$name
[10:25:48.069]                             if (is.null(name)) 
[10:25:48.069]                               next
[10:25:48.069]                             if (!grepl(pattern, name)) 
[10:25:48.069]                               next
[10:25:48.069]                             invokeRestart(restart)
[10:25:48.069]                             muffled <- TRUE
[10:25:48.069]                             break
[10:25:48.069]                           }
[10:25:48.069]                         }
[10:25:48.069]                       }
[10:25:48.069]                       invisible(muffled)
[10:25:48.069]                     }
[10:25:48.069]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.069]                   }
[10:25:48.069]                 }
[10:25:48.069]                 else {
[10:25:48.069]                   if (TRUE) {
[10:25:48.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.069]                     {
[10:25:48.069]                       inherits <- base::inherits
[10:25:48.069]                       invokeRestart <- base::invokeRestart
[10:25:48.069]                       is.null <- base::is.null
[10:25:48.069]                       muffled <- FALSE
[10:25:48.069]                       if (inherits(cond, "message")) {
[10:25:48.069]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.069]                         if (muffled) 
[10:25:48.069]                           invokeRestart("muffleMessage")
[10:25:48.069]                       }
[10:25:48.069]                       else if (inherits(cond, "warning")) {
[10:25:48.069]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.069]                         if (muffled) 
[10:25:48.069]                           invokeRestart("muffleWarning")
[10:25:48.069]                       }
[10:25:48.069]                       else if (inherits(cond, "condition")) {
[10:25:48.069]                         if (!is.null(pattern)) {
[10:25:48.069]                           computeRestarts <- base::computeRestarts
[10:25:48.069]                           grepl <- base::grepl
[10:25:48.069]                           restarts <- computeRestarts(cond)
[10:25:48.069]                           for (restart in restarts) {
[10:25:48.069]                             name <- restart$name
[10:25:48.069]                             if (is.null(name)) 
[10:25:48.069]                               next
[10:25:48.069]                             if (!grepl(pattern, name)) 
[10:25:48.069]                               next
[10:25:48.069]                             invokeRestart(restart)
[10:25:48.069]                             muffled <- TRUE
[10:25:48.069]                             break
[10:25:48.069]                           }
[10:25:48.069]                         }
[10:25:48.069]                       }
[10:25:48.069]                       invisible(muffled)
[10:25:48.069]                     }
[10:25:48.069]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.069]                   }
[10:25:48.069]                 }
[10:25:48.069]             }
[10:25:48.069]         }))
[10:25:48.069]     }, error = function(ex) {
[10:25:48.069]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.069]                 ...future.rng), started = ...future.startTime, 
[10:25:48.069]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.069]             version = "1.8"), class = "FutureResult")
[10:25:48.069]     }, finally = {
[10:25:48.069]         if (!identical(...future.workdir, getwd())) 
[10:25:48.069]             setwd(...future.workdir)
[10:25:48.069]         {
[10:25:48.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.069]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.069]             }
[10:25:48.069]             base::options(...future.oldOptions)
[10:25:48.069]             if (.Platform$OS.type == "windows") {
[10:25:48.069]                 old_names <- names(...future.oldEnvVars)
[10:25:48.069]                 envs <- base::Sys.getenv()
[10:25:48.069]                 names <- names(envs)
[10:25:48.069]                 common <- intersect(names, old_names)
[10:25:48.069]                 added <- setdiff(names, old_names)
[10:25:48.069]                 removed <- setdiff(old_names, names)
[10:25:48.069]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.069]                   envs[common]]
[10:25:48.069]                 NAMES <- toupper(changed)
[10:25:48.069]                 args <- list()
[10:25:48.069]                 for (kk in seq_along(NAMES)) {
[10:25:48.069]                   name <- changed[[kk]]
[10:25:48.069]                   NAME <- NAMES[[kk]]
[10:25:48.069]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.069]                     next
[10:25:48.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.069]                 }
[10:25:48.069]                 NAMES <- toupper(added)
[10:25:48.069]                 for (kk in seq_along(NAMES)) {
[10:25:48.069]                   name <- added[[kk]]
[10:25:48.069]                   NAME <- NAMES[[kk]]
[10:25:48.069]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.069]                     next
[10:25:48.069]                   args[[name]] <- ""
[10:25:48.069]                 }
[10:25:48.069]                 NAMES <- toupper(removed)
[10:25:48.069]                 for (kk in seq_along(NAMES)) {
[10:25:48.069]                   name <- removed[[kk]]
[10:25:48.069]                   NAME <- NAMES[[kk]]
[10:25:48.069]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.069]                     next
[10:25:48.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.069]                 }
[10:25:48.069]                 if (length(args) > 0) 
[10:25:48.069]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.069]             }
[10:25:48.069]             else {
[10:25:48.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.069]             }
[10:25:48.069]             {
[10:25:48.069]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.069]                   0L) {
[10:25:48.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.069]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.069]                   base::options(opts)
[10:25:48.069]                 }
[10:25:48.069]                 {
[10:25:48.069]                   {
[10:25:48.069]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.069]                     NULL
[10:25:48.069]                   }
[10:25:48.069]                   options(future.plan = NULL)
[10:25:48.069]                   if (is.na(NA_character_)) 
[10:25:48.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.069]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:48.069]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:48.069]                     envir = parent.frame()) 
[10:25:48.069]                   {
[10:25:48.069]                     if (is.function(workers)) 
[10:25:48.069]                       workers <- workers()
[10:25:48.069]                     workers <- structure(as.integer(workers), 
[10:25:48.069]                       class = class(workers))
[10:25:48.069]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:48.069]                       workers >= 1)
[10:25:48.069]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:48.069]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:48.069]                     }
[10:25:48.069]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:48.069]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:48.069]                       envir = envir)
[10:25:48.069]                     if (!future$lazy) 
[10:25:48.069]                       future <- run(future)
[10:25:48.069]                     invisible(future)
[10:25:48.069]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.069]                 }
[10:25:48.069]             }
[10:25:48.069]         }
[10:25:48.069]     })
[10:25:48.069]     if (TRUE) {
[10:25:48.069]         base::sink(type = "output", split = FALSE)
[10:25:48.069]         if (TRUE) {
[10:25:48.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.069]         }
[10:25:48.069]         else {
[10:25:48.069]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.069]         }
[10:25:48.069]         base::close(...future.stdout)
[10:25:48.069]         ...future.stdout <- NULL
[10:25:48.069]     }
[10:25:48.069]     ...future.result$conditions <- ...future.conditions
[10:25:48.069]     ...future.result$finished <- base::Sys.time()
[10:25:48.069]     ...future.result
[10:25:48.069] }
[10:25:48.072] MultisessionFuture started
[10:25:48.073] - Launch lazy future ... done
[10:25:48.073] run() for ‘MultisessionFuture’ ... done
[10:25:48.073] getGlobalsAndPackages() ...
[10:25:48.073] Searching for globals...
[10:25:48.073] 
[10:25:48.073] Searching for globals ... DONE
[10:25:48.073] - globals: [0] <none>
[10:25:48.073] getGlobalsAndPackages() ... DONE
[10:25:48.074] run() for ‘Future’ ...
[10:25:48.074] - state: ‘created’
[10:25:48.074] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.087] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:48.087]   - Field: ‘node’
[10:25:48.088]   - Field: ‘label’
[10:25:48.088]   - Field: ‘local’
[10:25:48.088]   - Field: ‘owner’
[10:25:48.088]   - Field: ‘envir’
[10:25:48.088]   - Field: ‘workers’
[10:25:48.088]   - Field: ‘packages’
[10:25:48.088]   - Field: ‘gc’
[10:25:48.088]   - Field: ‘conditions’
[10:25:48.088]   - Field: ‘persistent’
[10:25:48.088]   - Field: ‘expr’
[10:25:48.088]   - Field: ‘uuid’
[10:25:48.089]   - Field: ‘seed’
[10:25:48.089]   - Field: ‘version’
[10:25:48.089]   - Field: ‘result’
[10:25:48.089]   - Field: ‘asynchronous’
[10:25:48.089]   - Field: ‘calls’
[10:25:48.089]   - Field: ‘globals’
[10:25:48.089]   - Field: ‘stdout’
[10:25:48.089]   - Field: ‘earlySignal’
[10:25:48.089]   - Field: ‘lazy’
[10:25:48.089]   - Field: ‘state’
[10:25:48.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:48.090] - Launch lazy future ...
[10:25:48.090] Packages needed by the future expression (n = 0): <none>
[10:25:48.090] Packages needed by future strategies (n = 0): <none>
[10:25:48.090] {
[10:25:48.090]     {
[10:25:48.090]         {
[10:25:48.090]             ...future.startTime <- base::Sys.time()
[10:25:48.090]             {
[10:25:48.090]                 {
[10:25:48.090]                   {
[10:25:48.090]                     {
[10:25:48.090]                       base::local({
[10:25:48.090]                         has_future <- base::requireNamespace("future", 
[10:25:48.090]                           quietly = TRUE)
[10:25:48.090]                         if (has_future) {
[10:25:48.090]                           ns <- base::getNamespace("future")
[10:25:48.090]                           version <- ns[[".package"]][["version"]]
[10:25:48.090]                           if (is.null(version)) 
[10:25:48.090]                             version <- utils::packageVersion("future")
[10:25:48.090]                         }
[10:25:48.090]                         else {
[10:25:48.090]                           version <- NULL
[10:25:48.090]                         }
[10:25:48.090]                         if (!has_future || version < "1.8.0") {
[10:25:48.090]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.090]                             "", base::R.version$version.string), 
[10:25:48.090]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.090]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.090]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.090]                               "release", "version")], collapse = " "), 
[10:25:48.090]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.090]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.090]                             info)
[10:25:48.090]                           info <- base::paste(info, collapse = "; ")
[10:25:48.090]                           if (!has_future) {
[10:25:48.090]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.090]                               info)
[10:25:48.090]                           }
[10:25:48.090]                           else {
[10:25:48.090]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.090]                               info, version)
[10:25:48.090]                           }
[10:25:48.090]                           base::stop(msg)
[10:25:48.090]                         }
[10:25:48.090]                       })
[10:25:48.090]                     }
[10:25:48.090]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.090]                     base::options(mc.cores = 1L)
[10:25:48.090]                   }
[10:25:48.090]                   options(future.plan = NULL)
[10:25:48.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.090]                 }
[10:25:48.090]                 ...future.workdir <- getwd()
[10:25:48.090]             }
[10:25:48.090]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.090]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.090]         }
[10:25:48.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.090]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.090]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.090]             base::names(...future.oldOptions))
[10:25:48.090]     }
[10:25:48.090]     if (FALSE) {
[10:25:48.090]     }
[10:25:48.090]     else {
[10:25:48.090]         if (TRUE) {
[10:25:48.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.090]                 open = "w")
[10:25:48.090]         }
[10:25:48.090]         else {
[10:25:48.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.090]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.090]         }
[10:25:48.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.090]             base::sink(type = "output", split = FALSE)
[10:25:48.090]             base::close(...future.stdout)
[10:25:48.090]         }, add = TRUE)
[10:25:48.090]     }
[10:25:48.090]     ...future.frame <- base::sys.nframe()
[10:25:48.090]     ...future.conditions <- base::list()
[10:25:48.090]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.090]     if (FALSE) {
[10:25:48.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.090]     }
[10:25:48.090]     ...future.result <- base::tryCatch({
[10:25:48.090]         base::withCallingHandlers({
[10:25:48.090]             ...future.value <- base::withVisible(base::local({
[10:25:48.090]                 ...future.makeSendCondition <- base::local({
[10:25:48.090]                   sendCondition <- NULL
[10:25:48.090]                   function(frame = 1L) {
[10:25:48.090]                     if (is.function(sendCondition)) 
[10:25:48.090]                       return(sendCondition)
[10:25:48.090]                     ns <- getNamespace("parallel")
[10:25:48.090]                     if (exists("sendData", mode = "function", 
[10:25:48.090]                       envir = ns)) {
[10:25:48.090]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:48.090]                         envir = ns)
[10:25:48.090]                       envir <- sys.frame(frame)
[10:25:48.090]                       master <- NULL
[10:25:48.090]                       while (!identical(envir, .GlobalEnv) && 
[10:25:48.090]                         !identical(envir, emptyenv())) {
[10:25:48.090]                         if (exists("master", mode = "list", envir = envir, 
[10:25:48.090]                           inherits = FALSE)) {
[10:25:48.090]                           master <- get("master", mode = "list", 
[10:25:48.090]                             envir = envir, inherits = FALSE)
[10:25:48.090]                           if (inherits(master, c("SOCKnode", 
[10:25:48.090]                             "SOCK0node"))) {
[10:25:48.090]                             sendCondition <<- function(cond) {
[10:25:48.090]                               data <- list(type = "VALUE", value = cond, 
[10:25:48.090]                                 success = TRUE)
[10:25:48.090]                               parallel_sendData(master, data)
[10:25:48.090]                             }
[10:25:48.090]                             return(sendCondition)
[10:25:48.090]                           }
[10:25:48.090]                         }
[10:25:48.090]                         frame <- frame + 1L
[10:25:48.090]                         envir <- sys.frame(frame)
[10:25:48.090]                       }
[10:25:48.090]                     }
[10:25:48.090]                     sendCondition <<- function(cond) NULL
[10:25:48.090]                   }
[10:25:48.090]                 })
[10:25:48.090]                 withCallingHandlers({
[10:25:48.090]                   NULL
[10:25:48.090]                 }, immediateCondition = function(cond) {
[10:25:48.090]                   sendCondition <- ...future.makeSendCondition()
[10:25:48.090]                   sendCondition(cond)
[10:25:48.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.090]                   {
[10:25:48.090]                     inherits <- base::inherits
[10:25:48.090]                     invokeRestart <- base::invokeRestart
[10:25:48.090]                     is.null <- base::is.null
[10:25:48.090]                     muffled <- FALSE
[10:25:48.090]                     if (inherits(cond, "message")) {
[10:25:48.090]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.090]                       if (muffled) 
[10:25:48.090]                         invokeRestart("muffleMessage")
[10:25:48.090]                     }
[10:25:48.090]                     else if (inherits(cond, "warning")) {
[10:25:48.090]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.090]                       if (muffled) 
[10:25:48.090]                         invokeRestart("muffleWarning")
[10:25:48.090]                     }
[10:25:48.090]                     else if (inherits(cond, "condition")) {
[10:25:48.090]                       if (!is.null(pattern)) {
[10:25:48.090]                         computeRestarts <- base::computeRestarts
[10:25:48.090]                         grepl <- base::grepl
[10:25:48.090]                         restarts <- computeRestarts(cond)
[10:25:48.090]                         for (restart in restarts) {
[10:25:48.090]                           name <- restart$name
[10:25:48.090]                           if (is.null(name)) 
[10:25:48.090]                             next
[10:25:48.090]                           if (!grepl(pattern, name)) 
[10:25:48.090]                             next
[10:25:48.090]                           invokeRestart(restart)
[10:25:48.090]                           muffled <- TRUE
[10:25:48.090]                           break
[10:25:48.090]                         }
[10:25:48.090]                       }
[10:25:48.090]                     }
[10:25:48.090]                     invisible(muffled)
[10:25:48.090]                   }
[10:25:48.090]                   muffleCondition(cond)
[10:25:48.090]                 })
[10:25:48.090]             }))
[10:25:48.090]             future::FutureResult(value = ...future.value$value, 
[10:25:48.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.090]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.090]                     ...future.globalenv.names))
[10:25:48.090]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.090]         }, condition = base::local({
[10:25:48.090]             c <- base::c
[10:25:48.090]             inherits <- base::inherits
[10:25:48.090]             invokeRestart <- base::invokeRestart
[10:25:48.090]             length <- base::length
[10:25:48.090]             list <- base::list
[10:25:48.090]             seq.int <- base::seq.int
[10:25:48.090]             signalCondition <- base::signalCondition
[10:25:48.090]             sys.calls <- base::sys.calls
[10:25:48.090]             `[[` <- base::`[[`
[10:25:48.090]             `+` <- base::`+`
[10:25:48.090]             `<<-` <- base::`<<-`
[10:25:48.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.090]                   3L)]
[10:25:48.090]             }
[10:25:48.090]             function(cond) {
[10:25:48.090]                 is_error <- inherits(cond, "error")
[10:25:48.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.090]                   NULL)
[10:25:48.090]                 if (is_error) {
[10:25:48.090]                   sessionInformation <- function() {
[10:25:48.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.090]                       search = base::search(), system = base::Sys.info())
[10:25:48.090]                   }
[10:25:48.090]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.090]                     cond$call), session = sessionInformation(), 
[10:25:48.090]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.090]                   signalCondition(cond)
[10:25:48.090]                 }
[10:25:48.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.090]                 "immediateCondition"))) {
[10:25:48.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.090]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.090]                   if (TRUE && !signal) {
[10:25:48.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.090]                     {
[10:25:48.090]                       inherits <- base::inherits
[10:25:48.090]                       invokeRestart <- base::invokeRestart
[10:25:48.090]                       is.null <- base::is.null
[10:25:48.090]                       muffled <- FALSE
[10:25:48.090]                       if (inherits(cond, "message")) {
[10:25:48.090]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.090]                         if (muffled) 
[10:25:48.090]                           invokeRestart("muffleMessage")
[10:25:48.090]                       }
[10:25:48.090]                       else if (inherits(cond, "warning")) {
[10:25:48.090]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.090]                         if (muffled) 
[10:25:48.090]                           invokeRestart("muffleWarning")
[10:25:48.090]                       }
[10:25:48.090]                       else if (inherits(cond, "condition")) {
[10:25:48.090]                         if (!is.null(pattern)) {
[10:25:48.090]                           computeRestarts <- base::computeRestarts
[10:25:48.090]                           grepl <- base::grepl
[10:25:48.090]                           restarts <- computeRestarts(cond)
[10:25:48.090]                           for (restart in restarts) {
[10:25:48.090]                             name <- restart$name
[10:25:48.090]                             if (is.null(name)) 
[10:25:48.090]                               next
[10:25:48.090]                             if (!grepl(pattern, name)) 
[10:25:48.090]                               next
[10:25:48.090]                             invokeRestart(restart)
[10:25:48.090]                             muffled <- TRUE
[10:25:48.090]                             break
[10:25:48.090]                           }
[10:25:48.090]                         }
[10:25:48.090]                       }
[10:25:48.090]                       invisible(muffled)
[10:25:48.090]                     }
[10:25:48.090]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.090]                   }
[10:25:48.090]                 }
[10:25:48.090]                 else {
[10:25:48.090]                   if (TRUE) {
[10:25:48.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.090]                     {
[10:25:48.090]                       inherits <- base::inherits
[10:25:48.090]                       invokeRestart <- base::invokeRestart
[10:25:48.090]                       is.null <- base::is.null
[10:25:48.090]                       muffled <- FALSE
[10:25:48.090]                       if (inherits(cond, "message")) {
[10:25:48.090]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.090]                         if (muffled) 
[10:25:48.090]                           invokeRestart("muffleMessage")
[10:25:48.090]                       }
[10:25:48.090]                       else if (inherits(cond, "warning")) {
[10:25:48.090]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.090]                         if (muffled) 
[10:25:48.090]                           invokeRestart("muffleWarning")
[10:25:48.090]                       }
[10:25:48.090]                       else if (inherits(cond, "condition")) {
[10:25:48.090]                         if (!is.null(pattern)) {
[10:25:48.090]                           computeRestarts <- base::computeRestarts
[10:25:48.090]                           grepl <- base::grepl
[10:25:48.090]                           restarts <- computeRestarts(cond)
[10:25:48.090]                           for (restart in restarts) {
[10:25:48.090]                             name <- restart$name
[10:25:48.090]                             if (is.null(name)) 
[10:25:48.090]                               next
[10:25:48.090]                             if (!grepl(pattern, name)) 
[10:25:48.090]                               next
[10:25:48.090]                             invokeRestart(restart)
[10:25:48.090]                             muffled <- TRUE
[10:25:48.090]                             break
[10:25:48.090]                           }
[10:25:48.090]                         }
[10:25:48.090]                       }
[10:25:48.090]                       invisible(muffled)
[10:25:48.090]                     }
[10:25:48.090]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.090]                   }
[10:25:48.090]                 }
[10:25:48.090]             }
[10:25:48.090]         }))
[10:25:48.090]     }, error = function(ex) {
[10:25:48.090]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.090]                 ...future.rng), started = ...future.startTime, 
[10:25:48.090]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.090]             version = "1.8"), class = "FutureResult")
[10:25:48.090]     }, finally = {
[10:25:48.090]         if (!identical(...future.workdir, getwd())) 
[10:25:48.090]             setwd(...future.workdir)
[10:25:48.090]         {
[10:25:48.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.090]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.090]             }
[10:25:48.090]             base::options(...future.oldOptions)
[10:25:48.090]             if (.Platform$OS.type == "windows") {
[10:25:48.090]                 old_names <- names(...future.oldEnvVars)
[10:25:48.090]                 envs <- base::Sys.getenv()
[10:25:48.090]                 names <- names(envs)
[10:25:48.090]                 common <- intersect(names, old_names)
[10:25:48.090]                 added <- setdiff(names, old_names)
[10:25:48.090]                 removed <- setdiff(old_names, names)
[10:25:48.090]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.090]                   envs[common]]
[10:25:48.090]                 NAMES <- toupper(changed)
[10:25:48.090]                 args <- list()
[10:25:48.090]                 for (kk in seq_along(NAMES)) {
[10:25:48.090]                   name <- changed[[kk]]
[10:25:48.090]                   NAME <- NAMES[[kk]]
[10:25:48.090]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.090]                     next
[10:25:48.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.090]                 }
[10:25:48.090]                 NAMES <- toupper(added)
[10:25:48.090]                 for (kk in seq_along(NAMES)) {
[10:25:48.090]                   name <- added[[kk]]
[10:25:48.090]                   NAME <- NAMES[[kk]]
[10:25:48.090]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.090]                     next
[10:25:48.090]                   args[[name]] <- ""
[10:25:48.090]                 }
[10:25:48.090]                 NAMES <- toupper(removed)
[10:25:48.090]                 for (kk in seq_along(NAMES)) {
[10:25:48.090]                   name <- removed[[kk]]
[10:25:48.090]                   NAME <- NAMES[[kk]]
[10:25:48.090]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.090]                     next
[10:25:48.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.090]                 }
[10:25:48.090]                 if (length(args) > 0) 
[10:25:48.090]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.090]             }
[10:25:48.090]             else {
[10:25:48.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.090]             }
[10:25:48.090]             {
[10:25:48.090]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.090]                   0L) {
[10:25:48.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.090]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.090]                   base::options(opts)
[10:25:48.090]                 }
[10:25:48.090]                 {
[10:25:48.090]                   {
[10:25:48.090]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.090]                     NULL
[10:25:48.090]                   }
[10:25:48.090]                   options(future.plan = NULL)
[10:25:48.090]                   if (is.na(NA_character_)) 
[10:25:48.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.090]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:48.090]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:48.090]                     envir = parent.frame()) 
[10:25:48.090]                   {
[10:25:48.090]                     if (is.function(workers)) 
[10:25:48.090]                       workers <- workers()
[10:25:48.090]                     workers <- structure(as.integer(workers), 
[10:25:48.090]                       class = class(workers))
[10:25:48.090]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:48.090]                       workers >= 1)
[10:25:48.090]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:48.090]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:48.090]                     }
[10:25:48.090]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:48.090]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:48.090]                       envir = envir)
[10:25:48.090]                     if (!future$lazy) 
[10:25:48.090]                       future <- run(future)
[10:25:48.090]                     invisible(future)
[10:25:48.090]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.090]                 }
[10:25:48.090]             }
[10:25:48.090]         }
[10:25:48.090]     })
[10:25:48.090]     if (TRUE) {
[10:25:48.090]         base::sink(type = "output", split = FALSE)
[10:25:48.090]         if (TRUE) {
[10:25:48.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.090]         }
[10:25:48.090]         else {
[10:25:48.090]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.090]         }
[10:25:48.090]         base::close(...future.stdout)
[10:25:48.090]         ...future.stdout <- NULL
[10:25:48.090]     }
[10:25:48.090]     ...future.result$conditions <- ...future.conditions
[10:25:48.090]     ...future.result$finished <- base::Sys.time()
[10:25:48.090]     ...future.result
[10:25:48.090] }
[10:25:48.093] MultisessionFuture started
[10:25:48.093] - Launch lazy future ... done
[10:25:48.094] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f5a08b30> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f5331888> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f5a08b30> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55c0f5331888> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:25:48.122] resolve() on list ...
[10:25:48.122]  recursive: 0
[10:25:48.122]  length: 6
[10:25:48.122]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:25:48.122] signalConditionsASAP(numeric, pos=1) ...
[10:25:48.123] - nx: 6
[10:25:48.123] - relay: TRUE
[10:25:48.123] - stdout: TRUE
[10:25:48.123] - signal: TRUE
[10:25:48.123] - resignal: FALSE
[10:25:48.123] - force: TRUE
[10:25:48.123] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.123] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.123]  - until=2
[10:25:48.123]  - relaying element #2
[10:25:48.123] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.123] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.124] signalConditionsASAP(NULL, pos=1) ... done
[10:25:48.124]  length: 5 (resolved future 1)
[10:25:48.124] receiveMessageFromWorker() for ClusterFuture ...
[10:25:48.124] - Validating connection of MultisessionFuture
[10:25:48.124] - received message: FutureResult
[10:25:48.125] - Received FutureResult
[10:25:48.125] - Erased future from FutureRegistry
[10:25:48.125] result() for ClusterFuture ...
[10:25:48.125] - result already collected: FutureResult
[10:25:48.125] result() for ClusterFuture ... done
[10:25:48.125] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:48.125] Future #2
[10:25:48.125] result() for ClusterFuture ...
[10:25:48.125] - result already collected: FutureResult
[10:25:48.125] result() for ClusterFuture ... done
[10:25:48.125] result() for ClusterFuture ...
[10:25:48.126] - result already collected: FutureResult
[10:25:48.126] result() for ClusterFuture ... done
[10:25:48.126] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:48.126] - nx: 6
[10:25:48.126] - relay: TRUE
[10:25:48.126] - stdout: TRUE
[10:25:48.126] - signal: TRUE
[10:25:48.126] - resignal: FALSE
[10:25:48.126] - force: TRUE
[10:25:48.126] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.126] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:48.127]  - until=2
[10:25:48.127]  - relaying element #2
[10:25:48.127] result() for ClusterFuture ...
[10:25:48.127] - result already collected: FutureResult
[10:25:48.127] result() for ClusterFuture ... done
[10:25:48.127] result() for ClusterFuture ...
[10:25:48.127] - result already collected: FutureResult
[10:25:48.127] result() for ClusterFuture ... done
[10:25:48.127] result() for ClusterFuture ...
[10:25:48.127] - result already collected: FutureResult
[10:25:48.127] result() for ClusterFuture ... done
[10:25:48.128] result() for ClusterFuture ...
[10:25:48.128] - result already collected: FutureResult
[10:25:48.128] result() for ClusterFuture ... done
[10:25:48.128] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.128] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.128] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:48.128]  length: 4 (resolved future 2)
[10:25:48.138] receiveMessageFromWorker() for ClusterFuture ...
[10:25:48.138] - Validating connection of MultisessionFuture
[10:25:48.139] - received message: FutureResult
[10:25:48.139] - Received FutureResult
[10:25:48.139] - Erased future from FutureRegistry
[10:25:48.139] result() for ClusterFuture ...
[10:25:48.139] - result already collected: FutureResult
[10:25:48.139] result() for ClusterFuture ... done
[10:25:48.139] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:48.139] Future #3
[10:25:48.139] result() for ClusterFuture ...
[10:25:48.139] - result already collected: FutureResult
[10:25:48.140] result() for ClusterFuture ... done
[10:25:48.140] result() for ClusterFuture ...
[10:25:48.140] - result already collected: FutureResult
[10:25:48.140] result() for ClusterFuture ... done
[10:25:48.140] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:48.140] - nx: 6
[10:25:48.140] - relay: TRUE
[10:25:48.140] - stdout: TRUE
[10:25:48.140] - signal: TRUE
[10:25:48.140] - resignal: FALSE
[10:25:48.140] - force: TRUE
[10:25:48.140] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.141] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:48.141]  - until=3
[10:25:48.141]  - relaying element #3
[10:25:48.141] result() for ClusterFuture ...
[10:25:48.141] - result already collected: FutureResult
[10:25:48.141] result() for ClusterFuture ... done
[10:25:48.141] result() for ClusterFuture ...
[10:25:48.141] - result already collected: FutureResult
[10:25:48.141] result() for ClusterFuture ... done
[10:25:48.141] result() for ClusterFuture ...
[10:25:48.142] - result already collected: FutureResult
[10:25:48.142] result() for ClusterFuture ... done
[10:25:48.142] result() for ClusterFuture ...
[10:25:48.142] - result already collected: FutureResult
[10:25:48.142] result() for ClusterFuture ... done
[10:25:48.142] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.142] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.142] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:48.142]  length: 3 (resolved future 3)
[10:25:48.142] signalConditionsASAP(NULL, pos=4) ...
[10:25:48.142] - nx: 6
[10:25:48.142] - relay: TRUE
[10:25:48.143] - stdout: TRUE
[10:25:48.143] - signal: TRUE
[10:25:48.143] - resignal: FALSE
[10:25:48.143] - force: TRUE
[10:25:48.143] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.143] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.143]  - until=5
[10:25:48.143]  - relaying element #5
[10:25:48.143] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:48.143] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.143] signalConditionsASAP(NULL, pos=4) ... done
[10:25:48.144]  length: 2 (resolved future 4)
[10:25:48.144] signalConditionsASAP(NULL, pos=5) ...
[10:25:48.144] - nx: 6
[10:25:48.144] - relay: TRUE
[10:25:48.144] - stdout: TRUE
[10:25:48.144] - signal: TRUE
[10:25:48.144] - resignal: FALSE
[10:25:48.144] - force: TRUE
[10:25:48.144] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:48.144] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.144]  - until=6
[10:25:48.144]  - relaying element #6
[10:25:48.144] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:48.145] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.145] signalConditionsASAP(NULL, pos=5) ... done
[10:25:48.145]  length: 1 (resolved future 5)
[10:25:48.145] signalConditionsASAP(numeric, pos=6) ...
[10:25:48.145] - nx: 6
[10:25:48.145] - relay: TRUE
[10:25:48.145] - stdout: TRUE
[10:25:48.145] - signal: TRUE
[10:25:48.145] - resignal: FALSE
[10:25:48.145] - force: TRUE
[10:25:48.145] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:48.146] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.146]  - until=6
[10:25:48.146] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:48.146] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.146] signalConditionsASAP(numeric, pos=6) ... done
[10:25:48.146]  length: 0 (resolved future 6)
[10:25:48.146] Relaying remaining futures
[10:25:48.146] signalConditionsASAP(NULL, pos=0) ...
[10:25:48.146] - nx: 6
[10:25:48.146] - relay: TRUE
[10:25:48.146] - stdout: TRUE
[10:25:48.146] - signal: TRUE
[10:25:48.147] - resignal: FALSE
[10:25:48.147] - force: TRUE
[10:25:48.147] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:48.147] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:25:48.147] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:48.147] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:48.147] signalConditionsASAP(NULL, pos=0) ... done
[10:25:48.147] resolve() on list ... DONE
[10:25:48.147] result() for ClusterFuture ...
[10:25:48.147] - result already collected: FutureResult
[10:25:48.148] result() for ClusterFuture ... done
[10:25:48.148] result() for ClusterFuture ...
[10:25:48.148] - result already collected: FutureResult
[10:25:48.148] result() for ClusterFuture ... done
[10:25:48.148] result() for ClusterFuture ...
[10:25:48.148] - result already collected: FutureResult
[10:25:48.148] result() for ClusterFuture ... done
[10:25:48.148] result() for ClusterFuture ...
[10:25:48.148] - result already collected: FutureResult
[10:25:48.148] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[10:25:48.152] plan(): Setting new future strategy stack:
[10:25:48.152] List of future strategies:
[10:25:48.152] 1. multicore:
[10:25:48.152]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.152]    - tweaked: FALSE
[10:25:48.152]    - call: plan(strategy)
[10:25:48.157] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:25:48.157] getGlobalsAndPackages() ...
[10:25:48.157] Searching for globals...
[10:25:48.158] 
[10:25:48.158] Searching for globals ... DONE
[10:25:48.158] - globals: [0] <none>
[10:25:48.158] getGlobalsAndPackages() ... DONE
[10:25:48.159] run() for ‘Future’ ...
[10:25:48.159] - state: ‘created’
[10:25:48.159] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.163] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.164]   - Field: ‘label’
[10:25:48.164]   - Field: ‘local’
[10:25:48.164]   - Field: ‘owner’
[10:25:48.164]   - Field: ‘envir’
[10:25:48.164]   - Field: ‘workers’
[10:25:48.164]   - Field: ‘packages’
[10:25:48.164]   - Field: ‘gc’
[10:25:48.164]   - Field: ‘job’
[10:25:48.165]   - Field: ‘conditions’
[10:25:48.165]   - Field: ‘expr’
[10:25:48.165]   - Field: ‘uuid’
[10:25:48.165]   - Field: ‘seed’
[10:25:48.165]   - Field: ‘version’
[10:25:48.165]   - Field: ‘result’
[10:25:48.165]   - Field: ‘asynchronous’
[10:25:48.165]   - Field: ‘calls’
[10:25:48.165]   - Field: ‘globals’
[10:25:48.165]   - Field: ‘stdout’
[10:25:48.165]   - Field: ‘earlySignal’
[10:25:48.166]   - Field: ‘lazy’
[10:25:48.166]   - Field: ‘state’
[10:25:48.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.166] - Launch lazy future ...
[10:25:48.166] Packages needed by the future expression (n = 0): <none>
[10:25:48.166] Packages needed by future strategies (n = 0): <none>
[10:25:48.167] {
[10:25:48.167]     {
[10:25:48.167]         {
[10:25:48.167]             ...future.startTime <- base::Sys.time()
[10:25:48.167]             {
[10:25:48.167]                 {
[10:25:48.167]                   {
[10:25:48.167]                     {
[10:25:48.167]                       base::local({
[10:25:48.167]                         has_future <- base::requireNamespace("future", 
[10:25:48.167]                           quietly = TRUE)
[10:25:48.167]                         if (has_future) {
[10:25:48.167]                           ns <- base::getNamespace("future")
[10:25:48.167]                           version <- ns[[".package"]][["version"]]
[10:25:48.167]                           if (is.null(version)) 
[10:25:48.167]                             version <- utils::packageVersion("future")
[10:25:48.167]                         }
[10:25:48.167]                         else {
[10:25:48.167]                           version <- NULL
[10:25:48.167]                         }
[10:25:48.167]                         if (!has_future || version < "1.8.0") {
[10:25:48.167]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.167]                             "", base::R.version$version.string), 
[10:25:48.167]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.167]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.167]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.167]                               "release", "version")], collapse = " "), 
[10:25:48.167]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.167]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.167]                             info)
[10:25:48.167]                           info <- base::paste(info, collapse = "; ")
[10:25:48.167]                           if (!has_future) {
[10:25:48.167]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.167]                               info)
[10:25:48.167]                           }
[10:25:48.167]                           else {
[10:25:48.167]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.167]                               info, version)
[10:25:48.167]                           }
[10:25:48.167]                           base::stop(msg)
[10:25:48.167]                         }
[10:25:48.167]                       })
[10:25:48.167]                     }
[10:25:48.167]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.167]                     base::options(mc.cores = 1L)
[10:25:48.167]                   }
[10:25:48.167]                   options(future.plan = NULL)
[10:25:48.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.167]                 }
[10:25:48.167]                 ...future.workdir <- getwd()
[10:25:48.167]             }
[10:25:48.167]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.167]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.167]         }
[10:25:48.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.167]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.167]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.167]             base::names(...future.oldOptions))
[10:25:48.167]     }
[10:25:48.167]     if (FALSE) {
[10:25:48.167]     }
[10:25:48.167]     else {
[10:25:48.167]         if (TRUE) {
[10:25:48.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.167]                 open = "w")
[10:25:48.167]         }
[10:25:48.167]         else {
[10:25:48.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.167]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.167]         }
[10:25:48.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.167]             base::sink(type = "output", split = FALSE)
[10:25:48.167]             base::close(...future.stdout)
[10:25:48.167]         }, add = TRUE)
[10:25:48.167]     }
[10:25:48.167]     ...future.frame <- base::sys.nframe()
[10:25:48.167]     ...future.conditions <- base::list()
[10:25:48.167]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.167]     if (FALSE) {
[10:25:48.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.167]     }
[10:25:48.167]     ...future.result <- base::tryCatch({
[10:25:48.167]         base::withCallingHandlers({
[10:25:48.167]             ...future.value <- base::withVisible(base::local({
[10:25:48.167]                 withCallingHandlers({
[10:25:48.167]                   2
[10:25:48.167]                 }, immediateCondition = function(cond) {
[10:25:48.167]                   save_rds <- function (object, pathname, ...) 
[10:25:48.167]                   {
[10:25:48.167]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.167]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.167]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.167]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.167]                         fi_tmp[["mtime"]])
[10:25:48.167]                     }
[10:25:48.167]                     tryCatch({
[10:25:48.167]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.167]                     }, error = function(ex) {
[10:25:48.167]                       msg <- conditionMessage(ex)
[10:25:48.167]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.167]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.167]                         fi_tmp[["mtime"]], msg)
[10:25:48.167]                       ex$message <- msg
[10:25:48.167]                       stop(ex)
[10:25:48.167]                     })
[10:25:48.167]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.167]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.167]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.167]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.167]                       fi <- file.info(pathname)
[10:25:48.167]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.167]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.167]                         fi[["size"]], fi[["mtime"]])
[10:25:48.167]                       stop(msg)
[10:25:48.167]                     }
[10:25:48.167]                     invisible(pathname)
[10:25:48.167]                   }
[10:25:48.167]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.167]                     rootPath = tempdir()) 
[10:25:48.167]                   {
[10:25:48.167]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.167]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.167]                       tmpdir = path, fileext = ".rds")
[10:25:48.167]                     save_rds(obj, file)
[10:25:48.167]                   }
[10:25:48.167]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.167]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.167]                   {
[10:25:48.167]                     inherits <- base::inherits
[10:25:48.167]                     invokeRestart <- base::invokeRestart
[10:25:48.167]                     is.null <- base::is.null
[10:25:48.167]                     muffled <- FALSE
[10:25:48.167]                     if (inherits(cond, "message")) {
[10:25:48.167]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.167]                       if (muffled) 
[10:25:48.167]                         invokeRestart("muffleMessage")
[10:25:48.167]                     }
[10:25:48.167]                     else if (inherits(cond, "warning")) {
[10:25:48.167]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.167]                       if (muffled) 
[10:25:48.167]                         invokeRestart("muffleWarning")
[10:25:48.167]                     }
[10:25:48.167]                     else if (inherits(cond, "condition")) {
[10:25:48.167]                       if (!is.null(pattern)) {
[10:25:48.167]                         computeRestarts <- base::computeRestarts
[10:25:48.167]                         grepl <- base::grepl
[10:25:48.167]                         restarts <- computeRestarts(cond)
[10:25:48.167]                         for (restart in restarts) {
[10:25:48.167]                           name <- restart$name
[10:25:48.167]                           if (is.null(name)) 
[10:25:48.167]                             next
[10:25:48.167]                           if (!grepl(pattern, name)) 
[10:25:48.167]                             next
[10:25:48.167]                           invokeRestart(restart)
[10:25:48.167]                           muffled <- TRUE
[10:25:48.167]                           break
[10:25:48.167]                         }
[10:25:48.167]                       }
[10:25:48.167]                     }
[10:25:48.167]                     invisible(muffled)
[10:25:48.167]                   }
[10:25:48.167]                   muffleCondition(cond)
[10:25:48.167]                 })
[10:25:48.167]             }))
[10:25:48.167]             future::FutureResult(value = ...future.value$value, 
[10:25:48.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.167]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.167]                     ...future.globalenv.names))
[10:25:48.167]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.167]         }, condition = base::local({
[10:25:48.167]             c <- base::c
[10:25:48.167]             inherits <- base::inherits
[10:25:48.167]             invokeRestart <- base::invokeRestart
[10:25:48.167]             length <- base::length
[10:25:48.167]             list <- base::list
[10:25:48.167]             seq.int <- base::seq.int
[10:25:48.167]             signalCondition <- base::signalCondition
[10:25:48.167]             sys.calls <- base::sys.calls
[10:25:48.167]             `[[` <- base::`[[`
[10:25:48.167]             `+` <- base::`+`
[10:25:48.167]             `<<-` <- base::`<<-`
[10:25:48.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.167]                   3L)]
[10:25:48.167]             }
[10:25:48.167]             function(cond) {
[10:25:48.167]                 is_error <- inherits(cond, "error")
[10:25:48.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.167]                   NULL)
[10:25:48.167]                 if (is_error) {
[10:25:48.167]                   sessionInformation <- function() {
[10:25:48.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.167]                       search = base::search(), system = base::Sys.info())
[10:25:48.167]                   }
[10:25:48.167]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.167]                     cond$call), session = sessionInformation(), 
[10:25:48.167]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.167]                   signalCondition(cond)
[10:25:48.167]                 }
[10:25:48.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.167]                 "immediateCondition"))) {
[10:25:48.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.167]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.167]                   if (TRUE && !signal) {
[10:25:48.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.167]                     {
[10:25:48.167]                       inherits <- base::inherits
[10:25:48.167]                       invokeRestart <- base::invokeRestart
[10:25:48.167]                       is.null <- base::is.null
[10:25:48.167]                       muffled <- FALSE
[10:25:48.167]                       if (inherits(cond, "message")) {
[10:25:48.167]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.167]                         if (muffled) 
[10:25:48.167]                           invokeRestart("muffleMessage")
[10:25:48.167]                       }
[10:25:48.167]                       else if (inherits(cond, "warning")) {
[10:25:48.167]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.167]                         if (muffled) 
[10:25:48.167]                           invokeRestart("muffleWarning")
[10:25:48.167]                       }
[10:25:48.167]                       else if (inherits(cond, "condition")) {
[10:25:48.167]                         if (!is.null(pattern)) {
[10:25:48.167]                           computeRestarts <- base::computeRestarts
[10:25:48.167]                           grepl <- base::grepl
[10:25:48.167]                           restarts <- computeRestarts(cond)
[10:25:48.167]                           for (restart in restarts) {
[10:25:48.167]                             name <- restart$name
[10:25:48.167]                             if (is.null(name)) 
[10:25:48.167]                               next
[10:25:48.167]                             if (!grepl(pattern, name)) 
[10:25:48.167]                               next
[10:25:48.167]                             invokeRestart(restart)
[10:25:48.167]                             muffled <- TRUE
[10:25:48.167]                             break
[10:25:48.167]                           }
[10:25:48.167]                         }
[10:25:48.167]                       }
[10:25:48.167]                       invisible(muffled)
[10:25:48.167]                     }
[10:25:48.167]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.167]                   }
[10:25:48.167]                 }
[10:25:48.167]                 else {
[10:25:48.167]                   if (TRUE) {
[10:25:48.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.167]                     {
[10:25:48.167]                       inherits <- base::inherits
[10:25:48.167]                       invokeRestart <- base::invokeRestart
[10:25:48.167]                       is.null <- base::is.null
[10:25:48.167]                       muffled <- FALSE
[10:25:48.167]                       if (inherits(cond, "message")) {
[10:25:48.167]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.167]                         if (muffled) 
[10:25:48.167]                           invokeRestart("muffleMessage")
[10:25:48.167]                       }
[10:25:48.167]                       else if (inherits(cond, "warning")) {
[10:25:48.167]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.167]                         if (muffled) 
[10:25:48.167]                           invokeRestart("muffleWarning")
[10:25:48.167]                       }
[10:25:48.167]                       else if (inherits(cond, "condition")) {
[10:25:48.167]                         if (!is.null(pattern)) {
[10:25:48.167]                           computeRestarts <- base::computeRestarts
[10:25:48.167]                           grepl <- base::grepl
[10:25:48.167]                           restarts <- computeRestarts(cond)
[10:25:48.167]                           for (restart in restarts) {
[10:25:48.167]                             name <- restart$name
[10:25:48.167]                             if (is.null(name)) 
[10:25:48.167]                               next
[10:25:48.167]                             if (!grepl(pattern, name)) 
[10:25:48.167]                               next
[10:25:48.167]                             invokeRestart(restart)
[10:25:48.167]                             muffled <- TRUE
[10:25:48.167]                             break
[10:25:48.167]                           }
[10:25:48.167]                         }
[10:25:48.167]                       }
[10:25:48.167]                       invisible(muffled)
[10:25:48.167]                     }
[10:25:48.167]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.167]                   }
[10:25:48.167]                 }
[10:25:48.167]             }
[10:25:48.167]         }))
[10:25:48.167]     }, error = function(ex) {
[10:25:48.167]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.167]                 ...future.rng), started = ...future.startTime, 
[10:25:48.167]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.167]             version = "1.8"), class = "FutureResult")
[10:25:48.167]     }, finally = {
[10:25:48.167]         if (!identical(...future.workdir, getwd())) 
[10:25:48.167]             setwd(...future.workdir)
[10:25:48.167]         {
[10:25:48.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.167]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.167]             }
[10:25:48.167]             base::options(...future.oldOptions)
[10:25:48.167]             if (.Platform$OS.type == "windows") {
[10:25:48.167]                 old_names <- names(...future.oldEnvVars)
[10:25:48.167]                 envs <- base::Sys.getenv()
[10:25:48.167]                 names <- names(envs)
[10:25:48.167]                 common <- intersect(names, old_names)
[10:25:48.167]                 added <- setdiff(names, old_names)
[10:25:48.167]                 removed <- setdiff(old_names, names)
[10:25:48.167]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.167]                   envs[common]]
[10:25:48.167]                 NAMES <- toupper(changed)
[10:25:48.167]                 args <- list()
[10:25:48.167]                 for (kk in seq_along(NAMES)) {
[10:25:48.167]                   name <- changed[[kk]]
[10:25:48.167]                   NAME <- NAMES[[kk]]
[10:25:48.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.167]                     next
[10:25:48.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.167]                 }
[10:25:48.167]                 NAMES <- toupper(added)
[10:25:48.167]                 for (kk in seq_along(NAMES)) {
[10:25:48.167]                   name <- added[[kk]]
[10:25:48.167]                   NAME <- NAMES[[kk]]
[10:25:48.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.167]                     next
[10:25:48.167]                   args[[name]] <- ""
[10:25:48.167]                 }
[10:25:48.167]                 NAMES <- toupper(removed)
[10:25:48.167]                 for (kk in seq_along(NAMES)) {
[10:25:48.167]                   name <- removed[[kk]]
[10:25:48.167]                   NAME <- NAMES[[kk]]
[10:25:48.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.167]                     next
[10:25:48.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.167]                 }
[10:25:48.167]                 if (length(args) > 0) 
[10:25:48.167]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.167]             }
[10:25:48.167]             else {
[10:25:48.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.167]             }
[10:25:48.167]             {
[10:25:48.167]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.167]                   0L) {
[10:25:48.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.167]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.167]                   base::options(opts)
[10:25:48.167]                 }
[10:25:48.167]                 {
[10:25:48.167]                   {
[10:25:48.167]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.167]                     NULL
[10:25:48.167]                   }
[10:25:48.167]                   options(future.plan = NULL)
[10:25:48.167]                   if (is.na(NA_character_)) 
[10:25:48.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.167]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.167]                     envir = parent.frame()) 
[10:25:48.167]                   {
[10:25:48.167]                     default_workers <- missing(workers)
[10:25:48.167]                     if (is.function(workers)) 
[10:25:48.167]                       workers <- workers()
[10:25:48.167]                     workers <- structure(as.integer(workers), 
[10:25:48.167]                       class = class(workers))
[10:25:48.167]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.167]                       1L)
[10:25:48.167]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.167]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.167]                       if (default_workers) 
[10:25:48.167]                         supportsMulticore(warn = TRUE)
[10:25:48.167]                       return(sequential(..., envir = envir))
[10:25:48.167]                     }
[10:25:48.167]                     oopts <- options(mc.cores = workers)
[10:25:48.167]                     on.exit(options(oopts))
[10:25:48.167]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.167]                       envir = envir)
[10:25:48.167]                     if (!future$lazy) 
[10:25:48.167]                       future <- run(future)
[10:25:48.167]                     invisible(future)
[10:25:48.167]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.167]                 }
[10:25:48.167]             }
[10:25:48.167]         }
[10:25:48.167]     })
[10:25:48.167]     if (TRUE) {
[10:25:48.167]         base::sink(type = "output", split = FALSE)
[10:25:48.167]         if (TRUE) {
[10:25:48.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.167]         }
[10:25:48.167]         else {
[10:25:48.167]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.167]         }
[10:25:48.167]         base::close(...future.stdout)
[10:25:48.167]         ...future.stdout <- NULL
[10:25:48.167]     }
[10:25:48.167]     ...future.result$conditions <- ...future.conditions
[10:25:48.167]     ...future.result$finished <- base::Sys.time()
[10:25:48.167]     ...future.result
[10:25:48.167] }
[10:25:48.169] requestCore(): workers = 2
[10:25:48.172] MulticoreFuture started
[10:25:48.172] - Launch lazy future ... done
[10:25:48.172] run() for ‘MulticoreFuture’ ... done
[10:25:48.172] getGlobalsAndPackages() ...
[10:25:48.173] Searching for globals...
[10:25:48.173] plan(): Setting new future strategy stack:
[10:25:48.173] 
[10:25:48.174] Searching for globals ... DONE
[10:25:48.173] List of future strategies:
[10:25:48.173] 1. sequential:
[10:25:48.173]    - args: function (..., envir = parent.frame())
[10:25:48.173]    - tweaked: FALSE
[10:25:48.173]    - call: NULL
[10:25:48.174] - globals: [0] <none>
[10:25:48.174] getGlobalsAndPackages() ... DONE
[10:25:48.174] plan(): nbrOfWorkers() = 1
[10:25:48.174] run() for ‘Future’ ...
[10:25:48.175] - state: ‘created’
[10:25:48.175] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.176] plan(): Setting new future strategy stack:
[10:25:48.176] List of future strategies:
[10:25:48.176] 1. multicore:
[10:25:48.176]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.176]    - tweaked: FALSE
[10:25:48.176]    - call: plan(strategy)
[10:25:48.180] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.180] plan(): nbrOfWorkers() = 2
[10:25:48.180]   - Field: ‘label’
[10:25:48.180]   - Field: ‘local’
[10:25:48.181]   - Field: ‘owner’
[10:25:48.181]   - Field: ‘envir’
[10:25:48.181]   - Field: ‘workers’
[10:25:48.181]   - Field: ‘packages’
[10:25:48.181]   - Field: ‘gc’
[10:25:48.181]   - Field: ‘job’
[10:25:48.182]   - Field: ‘conditions’
[10:25:48.182]   - Field: ‘expr’
[10:25:48.182]   - Field: ‘uuid’
[10:25:48.182]   - Field: ‘seed’
[10:25:48.182]   - Field: ‘version’
[10:25:48.182]   - Field: ‘result’
[10:25:48.182]   - Field: ‘asynchronous’
[10:25:48.182]   - Field: ‘calls’
[10:25:48.183]   - Field: ‘globals’
[10:25:48.183]   - Field: ‘stdout’
[10:25:48.183]   - Field: ‘earlySignal’
[10:25:48.183]   - Field: ‘lazy’
[10:25:48.183]   - Field: ‘state’
[10:25:48.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.183] - Launch lazy future ...
[10:25:48.184] Packages needed by the future expression (n = 0): <none>
[10:25:48.184] Packages needed by future strategies (n = 0): <none>
[10:25:48.185] {
[10:25:48.185]     {
[10:25:48.185]         {
[10:25:48.185]             ...future.startTime <- base::Sys.time()
[10:25:48.185]             {
[10:25:48.185]                 {
[10:25:48.185]                   {
[10:25:48.185]                     {
[10:25:48.185]                       base::local({
[10:25:48.185]                         has_future <- base::requireNamespace("future", 
[10:25:48.185]                           quietly = TRUE)
[10:25:48.185]                         if (has_future) {
[10:25:48.185]                           ns <- base::getNamespace("future")
[10:25:48.185]                           version <- ns[[".package"]][["version"]]
[10:25:48.185]                           if (is.null(version)) 
[10:25:48.185]                             version <- utils::packageVersion("future")
[10:25:48.185]                         }
[10:25:48.185]                         else {
[10:25:48.185]                           version <- NULL
[10:25:48.185]                         }
[10:25:48.185]                         if (!has_future || version < "1.8.0") {
[10:25:48.185]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.185]                             "", base::R.version$version.string), 
[10:25:48.185]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.185]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.185]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.185]                               "release", "version")], collapse = " "), 
[10:25:48.185]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.185]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.185]                             info)
[10:25:48.185]                           info <- base::paste(info, collapse = "; ")
[10:25:48.185]                           if (!has_future) {
[10:25:48.185]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.185]                               info)
[10:25:48.185]                           }
[10:25:48.185]                           else {
[10:25:48.185]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.185]                               info, version)
[10:25:48.185]                           }
[10:25:48.185]                           base::stop(msg)
[10:25:48.185]                         }
[10:25:48.185]                       })
[10:25:48.185]                     }
[10:25:48.185]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.185]                     base::options(mc.cores = 1L)
[10:25:48.185]                   }
[10:25:48.185]                   options(future.plan = NULL)
[10:25:48.185]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.185]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.185]                 }
[10:25:48.185]                 ...future.workdir <- getwd()
[10:25:48.185]             }
[10:25:48.185]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.185]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.185]         }
[10:25:48.185]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.185]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.185]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.185]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.185]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.185]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.185]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.185]             base::names(...future.oldOptions))
[10:25:48.185]     }
[10:25:48.185]     if (FALSE) {
[10:25:48.185]     }
[10:25:48.185]     else {
[10:25:48.185]         if (TRUE) {
[10:25:48.185]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.185]                 open = "w")
[10:25:48.185]         }
[10:25:48.185]         else {
[10:25:48.185]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.185]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.185]         }
[10:25:48.185]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.185]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.185]             base::sink(type = "output", split = FALSE)
[10:25:48.185]             base::close(...future.stdout)
[10:25:48.185]         }, add = TRUE)
[10:25:48.185]     }
[10:25:48.185]     ...future.frame <- base::sys.nframe()
[10:25:48.185]     ...future.conditions <- base::list()
[10:25:48.185]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.185]     if (FALSE) {
[10:25:48.185]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.185]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.185]     }
[10:25:48.185]     ...future.result <- base::tryCatch({
[10:25:48.185]         base::withCallingHandlers({
[10:25:48.185]             ...future.value <- base::withVisible(base::local({
[10:25:48.185]                 withCallingHandlers({
[10:25:48.185]                   NULL
[10:25:48.185]                 }, immediateCondition = function(cond) {
[10:25:48.185]                   save_rds <- function (object, pathname, ...) 
[10:25:48.185]                   {
[10:25:48.185]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.185]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.185]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.185]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.185]                         fi_tmp[["mtime"]])
[10:25:48.185]                     }
[10:25:48.185]                     tryCatch({
[10:25:48.185]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.185]                     }, error = function(ex) {
[10:25:48.185]                       msg <- conditionMessage(ex)
[10:25:48.185]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.185]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.185]                         fi_tmp[["mtime"]], msg)
[10:25:48.185]                       ex$message <- msg
[10:25:48.185]                       stop(ex)
[10:25:48.185]                     })
[10:25:48.185]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.185]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.185]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.185]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.185]                       fi <- file.info(pathname)
[10:25:48.185]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.185]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.185]                         fi[["size"]], fi[["mtime"]])
[10:25:48.185]                       stop(msg)
[10:25:48.185]                     }
[10:25:48.185]                     invisible(pathname)
[10:25:48.185]                   }
[10:25:48.185]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.185]                     rootPath = tempdir()) 
[10:25:48.185]                   {
[10:25:48.185]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.185]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.185]                       tmpdir = path, fileext = ".rds")
[10:25:48.185]                     save_rds(obj, file)
[10:25:48.185]                   }
[10:25:48.185]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.185]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.185]                   {
[10:25:48.185]                     inherits <- base::inherits
[10:25:48.185]                     invokeRestart <- base::invokeRestart
[10:25:48.185]                     is.null <- base::is.null
[10:25:48.185]                     muffled <- FALSE
[10:25:48.185]                     if (inherits(cond, "message")) {
[10:25:48.185]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.185]                       if (muffled) 
[10:25:48.185]                         invokeRestart("muffleMessage")
[10:25:48.185]                     }
[10:25:48.185]                     else if (inherits(cond, "warning")) {
[10:25:48.185]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.185]                       if (muffled) 
[10:25:48.185]                         invokeRestart("muffleWarning")
[10:25:48.185]                     }
[10:25:48.185]                     else if (inherits(cond, "condition")) {
[10:25:48.185]                       if (!is.null(pattern)) {
[10:25:48.185]                         computeRestarts <- base::computeRestarts
[10:25:48.185]                         grepl <- base::grepl
[10:25:48.185]                         restarts <- computeRestarts(cond)
[10:25:48.185]                         for (restart in restarts) {
[10:25:48.185]                           name <- restart$name
[10:25:48.185]                           if (is.null(name)) 
[10:25:48.185]                             next
[10:25:48.185]                           if (!grepl(pattern, name)) 
[10:25:48.185]                             next
[10:25:48.185]                           invokeRestart(restart)
[10:25:48.185]                           muffled <- TRUE
[10:25:48.185]                           break
[10:25:48.185]                         }
[10:25:48.185]                       }
[10:25:48.185]                     }
[10:25:48.185]                     invisible(muffled)
[10:25:48.185]                   }
[10:25:48.185]                   muffleCondition(cond)
[10:25:48.185]                 })
[10:25:48.185]             }))
[10:25:48.185]             future::FutureResult(value = ...future.value$value, 
[10:25:48.185]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.185]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.185]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.185]                     ...future.globalenv.names))
[10:25:48.185]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.185]         }, condition = base::local({
[10:25:48.185]             c <- base::c
[10:25:48.185]             inherits <- base::inherits
[10:25:48.185]             invokeRestart <- base::invokeRestart
[10:25:48.185]             length <- base::length
[10:25:48.185]             list <- base::list
[10:25:48.185]             seq.int <- base::seq.int
[10:25:48.185]             signalCondition <- base::signalCondition
[10:25:48.185]             sys.calls <- base::sys.calls
[10:25:48.185]             `[[` <- base::`[[`
[10:25:48.185]             `+` <- base::`+`
[10:25:48.185]             `<<-` <- base::`<<-`
[10:25:48.185]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.185]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.185]                   3L)]
[10:25:48.185]             }
[10:25:48.185]             function(cond) {
[10:25:48.185]                 is_error <- inherits(cond, "error")
[10:25:48.185]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.185]                   NULL)
[10:25:48.185]                 if (is_error) {
[10:25:48.185]                   sessionInformation <- function() {
[10:25:48.185]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.185]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.185]                       search = base::search(), system = base::Sys.info())
[10:25:48.185]                   }
[10:25:48.185]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.185]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.185]                     cond$call), session = sessionInformation(), 
[10:25:48.185]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.185]                   signalCondition(cond)
[10:25:48.185]                 }
[10:25:48.185]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.185]                 "immediateCondition"))) {
[10:25:48.185]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.185]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.185]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.185]                   if (TRUE && !signal) {
[10:25:48.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.185]                     {
[10:25:48.185]                       inherits <- base::inherits
[10:25:48.185]                       invokeRestart <- base::invokeRestart
[10:25:48.185]                       is.null <- base::is.null
[10:25:48.185]                       muffled <- FALSE
[10:25:48.185]                       if (inherits(cond, "message")) {
[10:25:48.185]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.185]                         if (muffled) 
[10:25:48.185]                           invokeRestart("muffleMessage")
[10:25:48.185]                       }
[10:25:48.185]                       else if (inherits(cond, "warning")) {
[10:25:48.185]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.185]                         if (muffled) 
[10:25:48.185]                           invokeRestart("muffleWarning")
[10:25:48.185]                       }
[10:25:48.185]                       else if (inherits(cond, "condition")) {
[10:25:48.185]                         if (!is.null(pattern)) {
[10:25:48.185]                           computeRestarts <- base::computeRestarts
[10:25:48.185]                           grepl <- base::grepl
[10:25:48.185]                           restarts <- computeRestarts(cond)
[10:25:48.185]                           for (restart in restarts) {
[10:25:48.185]                             name <- restart$name
[10:25:48.185]                             if (is.null(name)) 
[10:25:48.185]                               next
[10:25:48.185]                             if (!grepl(pattern, name)) 
[10:25:48.185]                               next
[10:25:48.185]                             invokeRestart(restart)
[10:25:48.185]                             muffled <- TRUE
[10:25:48.185]                             break
[10:25:48.185]                           }
[10:25:48.185]                         }
[10:25:48.185]                       }
[10:25:48.185]                       invisible(muffled)
[10:25:48.185]                     }
[10:25:48.185]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.185]                   }
[10:25:48.185]                 }
[10:25:48.185]                 else {
[10:25:48.185]                   if (TRUE) {
[10:25:48.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.185]                     {
[10:25:48.185]                       inherits <- base::inherits
[10:25:48.185]                       invokeRestart <- base::invokeRestart
[10:25:48.185]                       is.null <- base::is.null
[10:25:48.185]                       muffled <- FALSE
[10:25:48.185]                       if (inherits(cond, "message")) {
[10:25:48.185]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.185]                         if (muffled) 
[10:25:48.185]                           invokeRestart("muffleMessage")
[10:25:48.185]                       }
[10:25:48.185]                       else if (inherits(cond, "warning")) {
[10:25:48.185]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.185]                         if (muffled) 
[10:25:48.185]                           invokeRestart("muffleWarning")
[10:25:48.185]                       }
[10:25:48.185]                       else if (inherits(cond, "condition")) {
[10:25:48.185]                         if (!is.null(pattern)) {
[10:25:48.185]                           computeRestarts <- base::computeRestarts
[10:25:48.185]                           grepl <- base::grepl
[10:25:48.185]                           restarts <- computeRestarts(cond)
[10:25:48.185]                           for (restart in restarts) {
[10:25:48.185]                             name <- restart$name
[10:25:48.185]                             if (is.null(name)) 
[10:25:48.185]                               next
[10:25:48.185]                             if (!grepl(pattern, name)) 
[10:25:48.185]                               next
[10:25:48.185]                             invokeRestart(restart)
[10:25:48.185]                             muffled <- TRUE
[10:25:48.185]                             break
[10:25:48.185]                           }
[10:25:48.185]                         }
[10:25:48.185]                       }
[10:25:48.185]                       invisible(muffled)
[10:25:48.185]                     }
[10:25:48.185]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.185]                   }
[10:25:48.185]                 }
[10:25:48.185]             }
[10:25:48.185]         }))
[10:25:48.185]     }, error = function(ex) {
[10:25:48.185]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.185]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.185]                 ...future.rng), started = ...future.startTime, 
[10:25:48.185]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.185]             version = "1.8"), class = "FutureResult")
[10:25:48.185]     }, finally = {
[10:25:48.185]         if (!identical(...future.workdir, getwd())) 
[10:25:48.185]             setwd(...future.workdir)
[10:25:48.185]         {
[10:25:48.185]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.185]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.185]             }
[10:25:48.185]             base::options(...future.oldOptions)
[10:25:48.185]             if (.Platform$OS.type == "windows") {
[10:25:48.185]                 old_names <- names(...future.oldEnvVars)
[10:25:48.185]                 envs <- base::Sys.getenv()
[10:25:48.185]                 names <- names(envs)
[10:25:48.185]                 common <- intersect(names, old_names)
[10:25:48.185]                 added <- setdiff(names, old_names)
[10:25:48.185]                 removed <- setdiff(old_names, names)
[10:25:48.185]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.185]                   envs[common]]
[10:25:48.185]                 NAMES <- toupper(changed)
[10:25:48.185]                 args <- list()
[10:25:48.185]                 for (kk in seq_along(NAMES)) {
[10:25:48.185]                   name <- changed[[kk]]
[10:25:48.185]                   NAME <- NAMES[[kk]]
[10:25:48.185]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.185]                     next
[10:25:48.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.185]                 }
[10:25:48.185]                 NAMES <- toupper(added)
[10:25:48.185]                 for (kk in seq_along(NAMES)) {
[10:25:48.185]                   name <- added[[kk]]
[10:25:48.185]                   NAME <- NAMES[[kk]]
[10:25:48.185]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.185]                     next
[10:25:48.185]                   args[[name]] <- ""
[10:25:48.185]                 }
[10:25:48.185]                 NAMES <- toupper(removed)
[10:25:48.185]                 for (kk in seq_along(NAMES)) {
[10:25:48.185]                   name <- removed[[kk]]
[10:25:48.185]                   NAME <- NAMES[[kk]]
[10:25:48.185]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.185]                     next
[10:25:48.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.185]                 }
[10:25:48.185]                 if (length(args) > 0) 
[10:25:48.185]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.185]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.185]             }
[10:25:48.185]             else {
[10:25:48.185]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.185]             }
[10:25:48.185]             {
[10:25:48.185]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.185]                   0L) {
[10:25:48.185]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.185]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.185]                   base::options(opts)
[10:25:48.185]                 }
[10:25:48.185]                 {
[10:25:48.185]                   {
[10:25:48.185]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.185]                     NULL
[10:25:48.185]                   }
[10:25:48.185]                   options(future.plan = NULL)
[10:25:48.185]                   if (is.na(NA_character_)) 
[10:25:48.185]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.185]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.185]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.185]                     envir = parent.frame()) 
[10:25:48.185]                   {
[10:25:48.185]                     default_workers <- missing(workers)
[10:25:48.185]                     if (is.function(workers)) 
[10:25:48.185]                       workers <- workers()
[10:25:48.185]                     workers <- structure(as.integer(workers), 
[10:25:48.185]                       class = class(workers))
[10:25:48.185]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.185]                       1L)
[10:25:48.185]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.185]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.185]                       if (default_workers) 
[10:25:48.185]                         supportsMulticore(warn = TRUE)
[10:25:48.185]                       return(sequential(..., envir = envir))
[10:25:48.185]                     }
[10:25:48.185]                     oopts <- options(mc.cores = workers)
[10:25:48.185]                     on.exit(options(oopts))
[10:25:48.185]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.185]                       envir = envir)
[10:25:48.185]                     if (!future$lazy) 
[10:25:48.185]                       future <- run(future)
[10:25:48.185]                     invisible(future)
[10:25:48.185]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.185]                 }
[10:25:48.185]             }
[10:25:48.185]         }
[10:25:48.185]     })
[10:25:48.185]     if (TRUE) {
[10:25:48.185]         base::sink(type = "output", split = FALSE)
[10:25:48.185]         if (TRUE) {
[10:25:48.185]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.185]         }
[10:25:48.185]         else {
[10:25:48.185]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.185]         }
[10:25:48.185]         base::close(...future.stdout)
[10:25:48.185]         ...future.stdout <- NULL
[10:25:48.185]     }
[10:25:48.185]     ...future.result$conditions <- ...future.conditions
[10:25:48.185]     ...future.result$finished <- base::Sys.time()
[10:25:48.185]     ...future.result
[10:25:48.185] }
[10:25:48.188] requestCore(): workers = 2
[10:25:48.191] MulticoreFuture started
[10:25:48.191] - Launch lazy future ... done
[10:25:48.191] run() for ‘MulticoreFuture’ ... done
[10:25:48.192] plan(): Setting new future strategy stack:
[10:25:48.192] getGlobalsAndPackages() ...
[10:25:48.192] Searching for globals...
[10:25:48.192] List of future strategies:
[10:25:48.192] 1. sequential:
[10:25:48.192]    - args: function (..., envir = parent.frame())
[10:25:48.192]    - tweaked: FALSE
[10:25:48.192]    - call: NULL
[10:25:48.193] plan(): nbrOfWorkers() = 1
[10:25:48.194] - globals found: [1] ‘{’
[10:25:48.194] Searching for globals ... DONE
[10:25:48.194] Resolving globals: FALSE
[10:25:48.195] 
[10:25:48.195] 
[10:25:48.195] plan(): Setting new future strategy stack:
[10:25:48.195] getGlobalsAndPackages() ... DONE
[10:25:48.195] run() for ‘Future’ ...
[10:25:48.195] List of future strategies:
[10:25:48.195] 1. multicore:
[10:25:48.195]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.195]    - tweaked: FALSE
[10:25:48.195]    - call: plan(strategy)
[10:25:48.195] - state: ‘created’
[10:25:48.196] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.200] plan(): nbrOfWorkers() = 2
[10:25:48.200] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.201]   - Field: ‘label’
[10:25:48.201]   - Field: ‘local’
[10:25:48.201]   - Field: ‘owner’
[10:25:48.201]   - Field: ‘envir’
[10:25:48.201]   - Field: ‘workers’
[10:25:48.201]   - Field: ‘packages’
[10:25:48.201]   - Field: ‘gc’
[10:25:48.202]   - Field: ‘job’
[10:25:48.202]   - Field: ‘conditions’
[10:25:48.202]   - Field: ‘expr’
[10:25:48.202]   - Field: ‘uuid’
[10:25:48.202]   - Field: ‘seed’
[10:25:48.202]   - Field: ‘version’
[10:25:48.202]   - Field: ‘result’
[10:25:48.203]   - Field: ‘asynchronous’
[10:25:48.203]   - Field: ‘calls’
[10:25:48.203]   - Field: ‘globals’
[10:25:48.203]   - Field: ‘stdout’
[10:25:48.203]   - Field: ‘earlySignal’
[10:25:48.203]   - Field: ‘lazy’
[10:25:48.203]   - Field: ‘state’
[10:25:48.203] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.204] - Launch lazy future ...
[10:25:48.204] Packages needed by the future expression (n = 0): <none>
[10:25:48.204] Packages needed by future strategies (n = 0): <none>
[10:25:48.205] {
[10:25:48.205]     {
[10:25:48.205]         {
[10:25:48.205]             ...future.startTime <- base::Sys.time()
[10:25:48.205]             {
[10:25:48.205]                 {
[10:25:48.205]                   {
[10:25:48.205]                     {
[10:25:48.205]                       base::local({
[10:25:48.205]                         has_future <- base::requireNamespace("future", 
[10:25:48.205]                           quietly = TRUE)
[10:25:48.205]                         if (has_future) {
[10:25:48.205]                           ns <- base::getNamespace("future")
[10:25:48.205]                           version <- ns[[".package"]][["version"]]
[10:25:48.205]                           if (is.null(version)) 
[10:25:48.205]                             version <- utils::packageVersion("future")
[10:25:48.205]                         }
[10:25:48.205]                         else {
[10:25:48.205]                           version <- NULL
[10:25:48.205]                         }
[10:25:48.205]                         if (!has_future || version < "1.8.0") {
[10:25:48.205]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.205]                             "", base::R.version$version.string), 
[10:25:48.205]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.205]                               "release", "version")], collapse = " "), 
[10:25:48.205]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.205]                             info)
[10:25:48.205]                           info <- base::paste(info, collapse = "; ")
[10:25:48.205]                           if (!has_future) {
[10:25:48.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.205]                               info)
[10:25:48.205]                           }
[10:25:48.205]                           else {
[10:25:48.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.205]                               info, version)
[10:25:48.205]                           }
[10:25:48.205]                           base::stop(msg)
[10:25:48.205]                         }
[10:25:48.205]                       })
[10:25:48.205]                     }
[10:25:48.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.205]                     base::options(mc.cores = 1L)
[10:25:48.205]                   }
[10:25:48.205]                   options(future.plan = NULL)
[10:25:48.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.205]                 }
[10:25:48.205]                 ...future.workdir <- getwd()
[10:25:48.205]             }
[10:25:48.205]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.205]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.205]         }
[10:25:48.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.205]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.205]             base::names(...future.oldOptions))
[10:25:48.205]     }
[10:25:48.205]     if (FALSE) {
[10:25:48.205]     }
[10:25:48.205]     else {
[10:25:48.205]         if (TRUE) {
[10:25:48.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.205]                 open = "w")
[10:25:48.205]         }
[10:25:48.205]         else {
[10:25:48.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.205]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.205]         }
[10:25:48.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.205]             base::sink(type = "output", split = FALSE)
[10:25:48.205]             base::close(...future.stdout)
[10:25:48.205]         }, add = TRUE)
[10:25:48.205]     }
[10:25:48.205]     ...future.frame <- base::sys.nframe()
[10:25:48.205]     ...future.conditions <- base::list()
[10:25:48.205]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.205]     if (FALSE) {
[10:25:48.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.205]     }
[10:25:48.205]     ...future.result <- base::tryCatch({
[10:25:48.205]         base::withCallingHandlers({
[10:25:48.205]             ...future.value <- base::withVisible(base::local({
[10:25:48.205]                 withCallingHandlers({
[10:25:48.205]                   {
[10:25:48.205]                     4
[10:25:48.205]                   }
[10:25:48.205]                 }, immediateCondition = function(cond) {
[10:25:48.205]                   save_rds <- function (object, pathname, ...) 
[10:25:48.205]                   {
[10:25:48.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.205]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.205]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.205]                         fi_tmp[["mtime"]])
[10:25:48.205]                     }
[10:25:48.205]                     tryCatch({
[10:25:48.205]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.205]                     }, error = function(ex) {
[10:25:48.205]                       msg <- conditionMessage(ex)
[10:25:48.205]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.205]                         fi_tmp[["mtime"]], msg)
[10:25:48.205]                       ex$message <- msg
[10:25:48.205]                       stop(ex)
[10:25:48.205]                     })
[10:25:48.205]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.205]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.205]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.205]                       fi <- file.info(pathname)
[10:25:48.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.205]                         fi[["size"]], fi[["mtime"]])
[10:25:48.205]                       stop(msg)
[10:25:48.205]                     }
[10:25:48.205]                     invisible(pathname)
[10:25:48.205]                   }
[10:25:48.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.205]                     rootPath = tempdir()) 
[10:25:48.205]                   {
[10:25:48.205]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.205]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.205]                       tmpdir = path, fileext = ".rds")
[10:25:48.205]                     save_rds(obj, file)
[10:25:48.205]                   }
[10:25:48.205]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.205]                   {
[10:25:48.205]                     inherits <- base::inherits
[10:25:48.205]                     invokeRestart <- base::invokeRestart
[10:25:48.205]                     is.null <- base::is.null
[10:25:48.205]                     muffled <- FALSE
[10:25:48.205]                     if (inherits(cond, "message")) {
[10:25:48.205]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.205]                       if (muffled) 
[10:25:48.205]                         invokeRestart("muffleMessage")
[10:25:48.205]                     }
[10:25:48.205]                     else if (inherits(cond, "warning")) {
[10:25:48.205]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.205]                       if (muffled) 
[10:25:48.205]                         invokeRestart("muffleWarning")
[10:25:48.205]                     }
[10:25:48.205]                     else if (inherits(cond, "condition")) {
[10:25:48.205]                       if (!is.null(pattern)) {
[10:25:48.205]                         computeRestarts <- base::computeRestarts
[10:25:48.205]                         grepl <- base::grepl
[10:25:48.205]                         restarts <- computeRestarts(cond)
[10:25:48.205]                         for (restart in restarts) {
[10:25:48.205]                           name <- restart$name
[10:25:48.205]                           if (is.null(name)) 
[10:25:48.205]                             next
[10:25:48.205]                           if (!grepl(pattern, name)) 
[10:25:48.205]                             next
[10:25:48.205]                           invokeRestart(restart)
[10:25:48.205]                           muffled <- TRUE
[10:25:48.205]                           break
[10:25:48.205]                         }
[10:25:48.205]                       }
[10:25:48.205]                     }
[10:25:48.205]                     invisible(muffled)
[10:25:48.205]                   }
[10:25:48.205]                   muffleCondition(cond)
[10:25:48.205]                 })
[10:25:48.205]             }))
[10:25:48.205]             future::FutureResult(value = ...future.value$value, 
[10:25:48.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.205]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.205]                     ...future.globalenv.names))
[10:25:48.205]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.205]         }, condition = base::local({
[10:25:48.205]             c <- base::c
[10:25:48.205]             inherits <- base::inherits
[10:25:48.205]             invokeRestart <- base::invokeRestart
[10:25:48.205]             length <- base::length
[10:25:48.205]             list <- base::list
[10:25:48.205]             seq.int <- base::seq.int
[10:25:48.205]             signalCondition <- base::signalCondition
[10:25:48.205]             sys.calls <- base::sys.calls
[10:25:48.205]             `[[` <- base::`[[`
[10:25:48.205]             `+` <- base::`+`
[10:25:48.205]             `<<-` <- base::`<<-`
[10:25:48.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.205]                   3L)]
[10:25:48.205]             }
[10:25:48.205]             function(cond) {
[10:25:48.205]                 is_error <- inherits(cond, "error")
[10:25:48.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.205]                   NULL)
[10:25:48.205]                 if (is_error) {
[10:25:48.205]                   sessionInformation <- function() {
[10:25:48.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.205]                       search = base::search(), system = base::Sys.info())
[10:25:48.205]                   }
[10:25:48.205]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.205]                     cond$call), session = sessionInformation(), 
[10:25:48.205]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.205]                   signalCondition(cond)
[10:25:48.205]                 }
[10:25:48.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.205]                 "immediateCondition"))) {
[10:25:48.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.205]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.205]                   if (TRUE && !signal) {
[10:25:48.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.205]                     {
[10:25:48.205]                       inherits <- base::inherits
[10:25:48.205]                       invokeRestart <- base::invokeRestart
[10:25:48.205]                       is.null <- base::is.null
[10:25:48.205]                       muffled <- FALSE
[10:25:48.205]                       if (inherits(cond, "message")) {
[10:25:48.205]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.205]                         if (muffled) 
[10:25:48.205]                           invokeRestart("muffleMessage")
[10:25:48.205]                       }
[10:25:48.205]                       else if (inherits(cond, "warning")) {
[10:25:48.205]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.205]                         if (muffled) 
[10:25:48.205]                           invokeRestart("muffleWarning")
[10:25:48.205]                       }
[10:25:48.205]                       else if (inherits(cond, "condition")) {
[10:25:48.205]                         if (!is.null(pattern)) {
[10:25:48.205]                           computeRestarts <- base::computeRestarts
[10:25:48.205]                           grepl <- base::grepl
[10:25:48.205]                           restarts <- computeRestarts(cond)
[10:25:48.205]                           for (restart in restarts) {
[10:25:48.205]                             name <- restart$name
[10:25:48.205]                             if (is.null(name)) 
[10:25:48.205]                               next
[10:25:48.205]                             if (!grepl(pattern, name)) 
[10:25:48.205]                               next
[10:25:48.205]                             invokeRestart(restart)
[10:25:48.205]                             muffled <- TRUE
[10:25:48.205]                             break
[10:25:48.205]                           }
[10:25:48.205]                         }
[10:25:48.205]                       }
[10:25:48.205]                       invisible(muffled)
[10:25:48.205]                     }
[10:25:48.205]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.205]                   }
[10:25:48.205]                 }
[10:25:48.205]                 else {
[10:25:48.205]                   if (TRUE) {
[10:25:48.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.205]                     {
[10:25:48.205]                       inherits <- base::inherits
[10:25:48.205]                       invokeRestart <- base::invokeRestart
[10:25:48.205]                       is.null <- base::is.null
[10:25:48.205]                       muffled <- FALSE
[10:25:48.205]                       if (inherits(cond, "message")) {
[10:25:48.205]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.205]                         if (muffled) 
[10:25:48.205]                           invokeRestart("muffleMessage")
[10:25:48.205]                       }
[10:25:48.205]                       else if (inherits(cond, "warning")) {
[10:25:48.205]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.205]                         if (muffled) 
[10:25:48.205]                           invokeRestart("muffleWarning")
[10:25:48.205]                       }
[10:25:48.205]                       else if (inherits(cond, "condition")) {
[10:25:48.205]                         if (!is.null(pattern)) {
[10:25:48.205]                           computeRestarts <- base::computeRestarts
[10:25:48.205]                           grepl <- base::grepl
[10:25:48.205]                           restarts <- computeRestarts(cond)
[10:25:48.205]                           for (restart in restarts) {
[10:25:48.205]                             name <- restart$name
[10:25:48.205]                             if (is.null(name)) 
[10:25:48.205]                               next
[10:25:48.205]                             if (!grepl(pattern, name)) 
[10:25:48.205]                               next
[10:25:48.205]                             invokeRestart(restart)
[10:25:48.205]                             muffled <- TRUE
[10:25:48.205]                             break
[10:25:48.205]                           }
[10:25:48.205]                         }
[10:25:48.205]                       }
[10:25:48.205]                       invisible(muffled)
[10:25:48.205]                     }
[10:25:48.205]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.205]                   }
[10:25:48.205]                 }
[10:25:48.205]             }
[10:25:48.205]         }))
[10:25:48.205]     }, error = function(ex) {
[10:25:48.205]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.205]                 ...future.rng), started = ...future.startTime, 
[10:25:48.205]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.205]             version = "1.8"), class = "FutureResult")
[10:25:48.205]     }, finally = {
[10:25:48.205]         if (!identical(...future.workdir, getwd())) 
[10:25:48.205]             setwd(...future.workdir)
[10:25:48.205]         {
[10:25:48.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.205]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.205]             }
[10:25:48.205]             base::options(...future.oldOptions)
[10:25:48.205]             if (.Platform$OS.type == "windows") {
[10:25:48.205]                 old_names <- names(...future.oldEnvVars)
[10:25:48.205]                 envs <- base::Sys.getenv()
[10:25:48.205]                 names <- names(envs)
[10:25:48.205]                 common <- intersect(names, old_names)
[10:25:48.205]                 added <- setdiff(names, old_names)
[10:25:48.205]                 removed <- setdiff(old_names, names)
[10:25:48.205]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.205]                   envs[common]]
[10:25:48.205]                 NAMES <- toupper(changed)
[10:25:48.205]                 args <- list()
[10:25:48.205]                 for (kk in seq_along(NAMES)) {
[10:25:48.205]                   name <- changed[[kk]]
[10:25:48.205]                   NAME <- NAMES[[kk]]
[10:25:48.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.205]                     next
[10:25:48.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.205]                 }
[10:25:48.205]                 NAMES <- toupper(added)
[10:25:48.205]                 for (kk in seq_along(NAMES)) {
[10:25:48.205]                   name <- added[[kk]]
[10:25:48.205]                   NAME <- NAMES[[kk]]
[10:25:48.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.205]                     next
[10:25:48.205]                   args[[name]] <- ""
[10:25:48.205]                 }
[10:25:48.205]                 NAMES <- toupper(removed)
[10:25:48.205]                 for (kk in seq_along(NAMES)) {
[10:25:48.205]                   name <- removed[[kk]]
[10:25:48.205]                   NAME <- NAMES[[kk]]
[10:25:48.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.205]                     next
[10:25:48.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.205]                 }
[10:25:48.205]                 if (length(args) > 0) 
[10:25:48.205]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.205]             }
[10:25:48.205]             else {
[10:25:48.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.205]             }
[10:25:48.205]             {
[10:25:48.205]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.205]                   0L) {
[10:25:48.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.205]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.205]                   base::options(opts)
[10:25:48.205]                 }
[10:25:48.205]                 {
[10:25:48.205]                   {
[10:25:48.205]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.205]                     NULL
[10:25:48.205]                   }
[10:25:48.205]                   options(future.plan = NULL)
[10:25:48.205]                   if (is.na(NA_character_)) 
[10:25:48.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.205]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.205]                     envir = parent.frame()) 
[10:25:48.205]                   {
[10:25:48.205]                     default_workers <- missing(workers)
[10:25:48.205]                     if (is.function(workers)) 
[10:25:48.205]                       workers <- workers()
[10:25:48.205]                     workers <- structure(as.integer(workers), 
[10:25:48.205]                       class = class(workers))
[10:25:48.205]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.205]                       1L)
[10:25:48.205]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.205]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.205]                       if (default_workers) 
[10:25:48.205]                         supportsMulticore(warn = TRUE)
[10:25:48.205]                       return(sequential(..., envir = envir))
[10:25:48.205]                     }
[10:25:48.205]                     oopts <- options(mc.cores = workers)
[10:25:48.205]                     on.exit(options(oopts))
[10:25:48.205]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.205]                       envir = envir)
[10:25:48.205]                     if (!future$lazy) 
[10:25:48.205]                       future <- run(future)
[10:25:48.205]                     invisible(future)
[10:25:48.205]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.205]                 }
[10:25:48.205]             }
[10:25:48.205]         }
[10:25:48.205]     })
[10:25:48.205]     if (TRUE) {
[10:25:48.205]         base::sink(type = "output", split = FALSE)
[10:25:48.205]         if (TRUE) {
[10:25:48.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.205]         }
[10:25:48.205]         else {
[10:25:48.205]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.205]         }
[10:25:48.205]         base::close(...future.stdout)
[10:25:48.205]         ...future.stdout <- NULL
[10:25:48.205]     }
[10:25:48.205]     ...future.result$conditions <- ...future.conditions
[10:25:48.205]     ...future.result$finished <- base::Sys.time()
[10:25:48.205]     ...future.result
[10:25:48.205] }
[10:25:48.208] requestCore(): workers = 2
[10:25:48.208] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:48.219] result() for MulticoreFuture ...
[10:25:48.220] result() for MulticoreFuture ...
[10:25:48.226] result() for MulticoreFuture ... done
[10:25:48.226] result() for MulticoreFuture ... done
[10:25:48.226] result() for MulticoreFuture ...
[10:25:48.226] result() for MulticoreFuture ... done
[10:25:48.228] MulticoreFuture started
[10:25:48.229] - Launch lazy future ... done
[10:25:48.229] run() for ‘MulticoreFuture’ ... done
[10:25:48.230] plan(): Setting new future strategy stack:
<environment: 0x55c0f69c1980> 
[10:25:48.230] List of future strategies:
[10:25:48.230] 1. sequential:
[10:25:48.230]    - args: function (..., envir = parent.frame())
[10:25:48.230]    - tweaked: FALSE
[10:25:48.230]    - call: NULL
[10:25:48.231] plan(): nbrOfWorkers() = 1
<environment: 0x55c0f59439b8> 
[10:25:48.232] plan(): Setting new future strategy stack:
[10:25:48.233] List of future strategies:
[10:25:48.233] 1. multicore:
[10:25:48.233]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.233]    - tweaked: FALSE
[10:25:48.233]    - call: plan(strategy)
[10:25:48.237] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:48.240] resolve() on environment ...
[10:25:48.240]  recursive: 0
[10:25:48.241]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:48.241] signalConditionsASAP(numeric, pos=1) ...
[10:25:48.241] - nx: 4
[10:25:48.241] - relay: TRUE
[10:25:48.241] - stdout: TRUE
[10:25:48.241] - signal: TRUE
[10:25:48.241] - resignal: FALSE
[10:25:48.242] - force: TRUE
[10:25:48.242] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.242] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.242]  - until=2
[10:25:48.242]  - relaying element #2
[10:25:48.242] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.242] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.243] signalConditionsASAP(NULL, pos=1) ... done
[10:25:48.243]  length: 3 (resolved future 1)
[10:25:48.243] Future #2
[10:25:48.243] result() for MulticoreFuture ...
[10:25:48.243] result() for MulticoreFuture ... done
[10:25:48.243] result() for MulticoreFuture ...
[10:25:48.244] result() for MulticoreFuture ... done
[10:25:48.244] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:48.244] - nx: 4
[10:25:48.244] - relay: TRUE
[10:25:48.244] - stdout: TRUE
[10:25:48.244] - signal: TRUE
[10:25:48.244] - resignal: FALSE
[10:25:48.244] - force: TRUE
[10:25:48.245] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.245] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.245]  - until=2
[10:25:48.245]  - relaying element #2
[10:25:48.245] result() for MulticoreFuture ...
[10:25:48.245] result() for MulticoreFuture ... done
[10:25:48.245] result() for MulticoreFuture ...
[10:25:48.246] result() for MulticoreFuture ... done
[10:25:48.246] result() for MulticoreFuture ...
[10:25:48.246] result() for MulticoreFuture ... done
[10:25:48.246] result() for MulticoreFuture ...
[10:25:48.246] result() for MulticoreFuture ... done
[10:25:48.246] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.246] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.247] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:48.247]  length: 2 (resolved future 2)
[10:25:48.247] Future #3
[10:25:48.247] result() for MulticoreFuture ...
[10:25:48.248] result() for MulticoreFuture ...
[10:25:48.248] result() for MulticoreFuture ... done
[10:25:48.248] result() for MulticoreFuture ... done
[10:25:48.248] result() for MulticoreFuture ...
[10:25:48.249] result() for MulticoreFuture ... done
[10:25:48.249] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:48.249] - nx: 4
[10:25:48.249] - relay: TRUE
[10:25:48.249] - stdout: TRUE
[10:25:48.249] - signal: TRUE
[10:25:48.249] - resignal: FALSE
[10:25:48.249] - force: TRUE
[10:25:48.250] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.250] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.250]  - until=3
[10:25:48.250]  - relaying element #3
[10:25:48.250] result() for MulticoreFuture ...
[10:25:48.250] result() for MulticoreFuture ... done
[10:25:48.251] result() for MulticoreFuture ...
[10:25:48.251] result() for MulticoreFuture ... done
[10:25:48.251] result() for MulticoreFuture ...
[10:25:48.251] result() for MulticoreFuture ... done
[10:25:48.251] result() for MulticoreFuture ...
[10:25:48.252] result() for MulticoreFuture ... done
[10:25:48.252] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.252] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.252] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:48.252]  length: 1 (resolved future 3)
[10:25:48.253] Future #4
[10:25:48.253] result() for MulticoreFuture ...
[10:25:48.253] result() for MulticoreFuture ...
[10:25:48.254] result() for MulticoreFuture ... done
[10:25:48.254] result() for MulticoreFuture ... done
[10:25:48.254] result() for MulticoreFuture ...
[10:25:48.254] result() for MulticoreFuture ... done
[10:25:48.254] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:48.255] - nx: 4
[10:25:48.255] - relay: TRUE
[10:25:48.255] - stdout: TRUE
[10:25:48.255] - signal: TRUE
[10:25:48.255] - resignal: FALSE
[10:25:48.255] - force: TRUE
[10:25:48.255] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.256] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.256]  - until=4
[10:25:48.256]  - relaying element #4
[10:25:48.256] result() for MulticoreFuture ...
[10:25:48.256] result() for MulticoreFuture ... done
[10:25:48.256] result() for MulticoreFuture ...
[10:25:48.256] result() for MulticoreFuture ... done
[10:25:48.257] result() for MulticoreFuture ...
[10:25:48.257] result() for MulticoreFuture ... done
[10:25:48.257] result() for MulticoreFuture ...
[10:25:48.257] result() for MulticoreFuture ... done
[10:25:48.257] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.257] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.257] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:48.258]  length: 0 (resolved future 4)
[10:25:48.258] Relaying remaining futures
[10:25:48.258] signalConditionsASAP(NULL, pos=0) ...
[10:25:48.258] - nx: 4
[10:25:48.258] - relay: TRUE
[10:25:48.258] - stdout: TRUE
[10:25:48.258] - signal: TRUE
[10:25:48.258] - resignal: FALSE
[10:25:48.258] - force: TRUE
[10:25:48.258] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.259] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:48.259] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.259] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.259] signalConditionsASAP(NULL, pos=0) ... done
[10:25:48.259] resolve() on environment ... DONE
[10:25:48.259] result() for MulticoreFuture ...
[10:25:48.259] result() for MulticoreFuture ... done
[10:25:48.259] result() for MulticoreFuture ...
[10:25:48.260] result() for MulticoreFuture ... done
[10:25:48.260] result() for MulticoreFuture ...
[10:25:48.260] result() for MulticoreFuture ... done
[10:25:48.260] result() for MulticoreFuture ...
[10:25:48.260] result() for MulticoreFuture ... done
[10:25:48.260] result() for MulticoreFuture ...
[10:25:48.260] result() for MulticoreFuture ... done
[10:25:48.260] result() for MulticoreFuture ...
[10:25:48.260] result() for MulticoreFuture ... done
<environment: 0x55c0f57f77a0> 
Dimensions: c(1, 6)
[10:25:48.261] getGlobalsAndPackages() ...
[10:25:48.261] Searching for globals...
[10:25:48.262] 
[10:25:48.262] Searching for globals ... DONE
[10:25:48.262] - globals: [0] <none>
[10:25:48.262] getGlobalsAndPackages() ... DONE
[10:25:48.262] run() for ‘Future’ ...
[10:25:48.263] - state: ‘created’
[10:25:48.263] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.267] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.267]   - Field: ‘label’
[10:25:48.267]   - Field: ‘local’
[10:25:48.268]   - Field: ‘owner’
[10:25:48.268]   - Field: ‘envir’
[10:25:48.268]   - Field: ‘workers’
[10:25:48.268]   - Field: ‘packages’
[10:25:48.268]   - Field: ‘gc’
[10:25:48.268]   - Field: ‘job’
[10:25:48.268]   - Field: ‘conditions’
[10:25:48.268]   - Field: ‘expr’
[10:25:48.268]   - Field: ‘uuid’
[10:25:48.269]   - Field: ‘seed’
[10:25:48.269]   - Field: ‘version’
[10:25:48.269]   - Field: ‘result’
[10:25:48.269]   - Field: ‘asynchronous’
[10:25:48.269]   - Field: ‘calls’
[10:25:48.269]   - Field: ‘globals’
[10:25:48.269]   - Field: ‘stdout’
[10:25:48.269]   - Field: ‘earlySignal’
[10:25:48.270]   - Field: ‘lazy’
[10:25:48.270]   - Field: ‘state’
[10:25:48.270] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.270] - Launch lazy future ...
[10:25:48.270] Packages needed by the future expression (n = 0): <none>
[10:25:48.270] Packages needed by future strategies (n = 0): <none>
[10:25:48.271] {
[10:25:48.271]     {
[10:25:48.271]         {
[10:25:48.271]             ...future.startTime <- base::Sys.time()
[10:25:48.271]             {
[10:25:48.271]                 {
[10:25:48.271]                   {
[10:25:48.271]                     {
[10:25:48.271]                       base::local({
[10:25:48.271]                         has_future <- base::requireNamespace("future", 
[10:25:48.271]                           quietly = TRUE)
[10:25:48.271]                         if (has_future) {
[10:25:48.271]                           ns <- base::getNamespace("future")
[10:25:48.271]                           version <- ns[[".package"]][["version"]]
[10:25:48.271]                           if (is.null(version)) 
[10:25:48.271]                             version <- utils::packageVersion("future")
[10:25:48.271]                         }
[10:25:48.271]                         else {
[10:25:48.271]                           version <- NULL
[10:25:48.271]                         }
[10:25:48.271]                         if (!has_future || version < "1.8.0") {
[10:25:48.271]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.271]                             "", base::R.version$version.string), 
[10:25:48.271]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.271]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.271]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.271]                               "release", "version")], collapse = " "), 
[10:25:48.271]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.271]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.271]                             info)
[10:25:48.271]                           info <- base::paste(info, collapse = "; ")
[10:25:48.271]                           if (!has_future) {
[10:25:48.271]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.271]                               info)
[10:25:48.271]                           }
[10:25:48.271]                           else {
[10:25:48.271]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.271]                               info, version)
[10:25:48.271]                           }
[10:25:48.271]                           base::stop(msg)
[10:25:48.271]                         }
[10:25:48.271]                       })
[10:25:48.271]                     }
[10:25:48.271]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.271]                     base::options(mc.cores = 1L)
[10:25:48.271]                   }
[10:25:48.271]                   options(future.plan = NULL)
[10:25:48.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.271]                 }
[10:25:48.271]                 ...future.workdir <- getwd()
[10:25:48.271]             }
[10:25:48.271]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.271]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.271]         }
[10:25:48.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.271]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.271]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.271]             base::names(...future.oldOptions))
[10:25:48.271]     }
[10:25:48.271]     if (FALSE) {
[10:25:48.271]     }
[10:25:48.271]     else {
[10:25:48.271]         if (TRUE) {
[10:25:48.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.271]                 open = "w")
[10:25:48.271]         }
[10:25:48.271]         else {
[10:25:48.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.271]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.271]         }
[10:25:48.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.271]             base::sink(type = "output", split = FALSE)
[10:25:48.271]             base::close(...future.stdout)
[10:25:48.271]         }, add = TRUE)
[10:25:48.271]     }
[10:25:48.271]     ...future.frame <- base::sys.nframe()
[10:25:48.271]     ...future.conditions <- base::list()
[10:25:48.271]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.271]     if (FALSE) {
[10:25:48.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.271]     }
[10:25:48.271]     ...future.result <- base::tryCatch({
[10:25:48.271]         base::withCallingHandlers({
[10:25:48.271]             ...future.value <- base::withVisible(base::local({
[10:25:48.271]                 withCallingHandlers({
[10:25:48.271]                   2
[10:25:48.271]                 }, immediateCondition = function(cond) {
[10:25:48.271]                   save_rds <- function (object, pathname, ...) 
[10:25:48.271]                   {
[10:25:48.271]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.271]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.271]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.271]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.271]                         fi_tmp[["mtime"]])
[10:25:48.271]                     }
[10:25:48.271]                     tryCatch({
[10:25:48.271]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.271]                     }, error = function(ex) {
[10:25:48.271]                       msg <- conditionMessage(ex)
[10:25:48.271]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.271]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.271]                         fi_tmp[["mtime"]], msg)
[10:25:48.271]                       ex$message <- msg
[10:25:48.271]                       stop(ex)
[10:25:48.271]                     })
[10:25:48.271]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.271]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.271]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.271]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.271]                       fi <- file.info(pathname)
[10:25:48.271]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.271]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.271]                         fi[["size"]], fi[["mtime"]])
[10:25:48.271]                       stop(msg)
[10:25:48.271]                     }
[10:25:48.271]                     invisible(pathname)
[10:25:48.271]                   }
[10:25:48.271]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.271]                     rootPath = tempdir()) 
[10:25:48.271]                   {
[10:25:48.271]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.271]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.271]                       tmpdir = path, fileext = ".rds")
[10:25:48.271]                     save_rds(obj, file)
[10:25:48.271]                   }
[10:25:48.271]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.271]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.271]                   {
[10:25:48.271]                     inherits <- base::inherits
[10:25:48.271]                     invokeRestart <- base::invokeRestart
[10:25:48.271]                     is.null <- base::is.null
[10:25:48.271]                     muffled <- FALSE
[10:25:48.271]                     if (inherits(cond, "message")) {
[10:25:48.271]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.271]                       if (muffled) 
[10:25:48.271]                         invokeRestart("muffleMessage")
[10:25:48.271]                     }
[10:25:48.271]                     else if (inherits(cond, "warning")) {
[10:25:48.271]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.271]                       if (muffled) 
[10:25:48.271]                         invokeRestart("muffleWarning")
[10:25:48.271]                     }
[10:25:48.271]                     else if (inherits(cond, "condition")) {
[10:25:48.271]                       if (!is.null(pattern)) {
[10:25:48.271]                         computeRestarts <- base::computeRestarts
[10:25:48.271]                         grepl <- base::grepl
[10:25:48.271]                         restarts <- computeRestarts(cond)
[10:25:48.271]                         for (restart in restarts) {
[10:25:48.271]                           name <- restart$name
[10:25:48.271]                           if (is.null(name)) 
[10:25:48.271]                             next
[10:25:48.271]                           if (!grepl(pattern, name)) 
[10:25:48.271]                             next
[10:25:48.271]                           invokeRestart(restart)
[10:25:48.271]                           muffled <- TRUE
[10:25:48.271]                           break
[10:25:48.271]                         }
[10:25:48.271]                       }
[10:25:48.271]                     }
[10:25:48.271]                     invisible(muffled)
[10:25:48.271]                   }
[10:25:48.271]                   muffleCondition(cond)
[10:25:48.271]                 })
[10:25:48.271]             }))
[10:25:48.271]             future::FutureResult(value = ...future.value$value, 
[10:25:48.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.271]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.271]                     ...future.globalenv.names))
[10:25:48.271]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.271]         }, condition = base::local({
[10:25:48.271]             c <- base::c
[10:25:48.271]             inherits <- base::inherits
[10:25:48.271]             invokeRestart <- base::invokeRestart
[10:25:48.271]             length <- base::length
[10:25:48.271]             list <- base::list
[10:25:48.271]             seq.int <- base::seq.int
[10:25:48.271]             signalCondition <- base::signalCondition
[10:25:48.271]             sys.calls <- base::sys.calls
[10:25:48.271]             `[[` <- base::`[[`
[10:25:48.271]             `+` <- base::`+`
[10:25:48.271]             `<<-` <- base::`<<-`
[10:25:48.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.271]                   3L)]
[10:25:48.271]             }
[10:25:48.271]             function(cond) {
[10:25:48.271]                 is_error <- inherits(cond, "error")
[10:25:48.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.271]                   NULL)
[10:25:48.271]                 if (is_error) {
[10:25:48.271]                   sessionInformation <- function() {
[10:25:48.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.271]                       search = base::search(), system = base::Sys.info())
[10:25:48.271]                   }
[10:25:48.271]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.271]                     cond$call), session = sessionInformation(), 
[10:25:48.271]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.271]                   signalCondition(cond)
[10:25:48.271]                 }
[10:25:48.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.271]                 "immediateCondition"))) {
[10:25:48.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.271]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.271]                   if (TRUE && !signal) {
[10:25:48.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.271]                     {
[10:25:48.271]                       inherits <- base::inherits
[10:25:48.271]                       invokeRestart <- base::invokeRestart
[10:25:48.271]                       is.null <- base::is.null
[10:25:48.271]                       muffled <- FALSE
[10:25:48.271]                       if (inherits(cond, "message")) {
[10:25:48.271]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.271]                         if (muffled) 
[10:25:48.271]                           invokeRestart("muffleMessage")
[10:25:48.271]                       }
[10:25:48.271]                       else if (inherits(cond, "warning")) {
[10:25:48.271]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.271]                         if (muffled) 
[10:25:48.271]                           invokeRestart("muffleWarning")
[10:25:48.271]                       }
[10:25:48.271]                       else if (inherits(cond, "condition")) {
[10:25:48.271]                         if (!is.null(pattern)) {
[10:25:48.271]                           computeRestarts <- base::computeRestarts
[10:25:48.271]                           grepl <- base::grepl
[10:25:48.271]                           restarts <- computeRestarts(cond)
[10:25:48.271]                           for (restart in restarts) {
[10:25:48.271]                             name <- restart$name
[10:25:48.271]                             if (is.null(name)) 
[10:25:48.271]                               next
[10:25:48.271]                             if (!grepl(pattern, name)) 
[10:25:48.271]                               next
[10:25:48.271]                             invokeRestart(restart)
[10:25:48.271]                             muffled <- TRUE
[10:25:48.271]                             break
[10:25:48.271]                           }
[10:25:48.271]                         }
[10:25:48.271]                       }
[10:25:48.271]                       invisible(muffled)
[10:25:48.271]                     }
[10:25:48.271]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.271]                   }
[10:25:48.271]                 }
[10:25:48.271]                 else {
[10:25:48.271]                   if (TRUE) {
[10:25:48.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.271]                     {
[10:25:48.271]                       inherits <- base::inherits
[10:25:48.271]                       invokeRestart <- base::invokeRestart
[10:25:48.271]                       is.null <- base::is.null
[10:25:48.271]                       muffled <- FALSE
[10:25:48.271]                       if (inherits(cond, "message")) {
[10:25:48.271]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.271]                         if (muffled) 
[10:25:48.271]                           invokeRestart("muffleMessage")
[10:25:48.271]                       }
[10:25:48.271]                       else if (inherits(cond, "warning")) {
[10:25:48.271]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.271]                         if (muffled) 
[10:25:48.271]                           invokeRestart("muffleWarning")
[10:25:48.271]                       }
[10:25:48.271]                       else if (inherits(cond, "condition")) {
[10:25:48.271]                         if (!is.null(pattern)) {
[10:25:48.271]                           computeRestarts <- base::computeRestarts
[10:25:48.271]                           grepl <- base::grepl
[10:25:48.271]                           restarts <- computeRestarts(cond)
[10:25:48.271]                           for (restart in restarts) {
[10:25:48.271]                             name <- restart$name
[10:25:48.271]                             if (is.null(name)) 
[10:25:48.271]                               next
[10:25:48.271]                             if (!grepl(pattern, name)) 
[10:25:48.271]                               next
[10:25:48.271]                             invokeRestart(restart)
[10:25:48.271]                             muffled <- TRUE
[10:25:48.271]                             break
[10:25:48.271]                           }
[10:25:48.271]                         }
[10:25:48.271]                       }
[10:25:48.271]                       invisible(muffled)
[10:25:48.271]                     }
[10:25:48.271]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.271]                   }
[10:25:48.271]                 }
[10:25:48.271]             }
[10:25:48.271]         }))
[10:25:48.271]     }, error = function(ex) {
[10:25:48.271]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.271]                 ...future.rng), started = ...future.startTime, 
[10:25:48.271]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.271]             version = "1.8"), class = "FutureResult")
[10:25:48.271]     }, finally = {
[10:25:48.271]         if (!identical(...future.workdir, getwd())) 
[10:25:48.271]             setwd(...future.workdir)
[10:25:48.271]         {
[10:25:48.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.271]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.271]             }
[10:25:48.271]             base::options(...future.oldOptions)
[10:25:48.271]             if (.Platform$OS.type == "windows") {
[10:25:48.271]                 old_names <- names(...future.oldEnvVars)
[10:25:48.271]                 envs <- base::Sys.getenv()
[10:25:48.271]                 names <- names(envs)
[10:25:48.271]                 common <- intersect(names, old_names)
[10:25:48.271]                 added <- setdiff(names, old_names)
[10:25:48.271]                 removed <- setdiff(old_names, names)
[10:25:48.271]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.271]                   envs[common]]
[10:25:48.271]                 NAMES <- toupper(changed)
[10:25:48.271]                 args <- list()
[10:25:48.271]                 for (kk in seq_along(NAMES)) {
[10:25:48.271]                   name <- changed[[kk]]
[10:25:48.271]                   NAME <- NAMES[[kk]]
[10:25:48.271]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.271]                     next
[10:25:48.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.271]                 }
[10:25:48.271]                 NAMES <- toupper(added)
[10:25:48.271]                 for (kk in seq_along(NAMES)) {
[10:25:48.271]                   name <- added[[kk]]
[10:25:48.271]                   NAME <- NAMES[[kk]]
[10:25:48.271]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.271]                     next
[10:25:48.271]                   args[[name]] <- ""
[10:25:48.271]                 }
[10:25:48.271]                 NAMES <- toupper(removed)
[10:25:48.271]                 for (kk in seq_along(NAMES)) {
[10:25:48.271]                   name <- removed[[kk]]
[10:25:48.271]                   NAME <- NAMES[[kk]]
[10:25:48.271]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.271]                     next
[10:25:48.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.271]                 }
[10:25:48.271]                 if (length(args) > 0) 
[10:25:48.271]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.271]             }
[10:25:48.271]             else {
[10:25:48.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.271]             }
[10:25:48.271]             {
[10:25:48.271]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.271]                   0L) {
[10:25:48.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.271]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.271]                   base::options(opts)
[10:25:48.271]                 }
[10:25:48.271]                 {
[10:25:48.271]                   {
[10:25:48.271]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.271]                     NULL
[10:25:48.271]                   }
[10:25:48.271]                   options(future.plan = NULL)
[10:25:48.271]                   if (is.na(NA_character_)) 
[10:25:48.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.271]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.271]                     envir = parent.frame()) 
[10:25:48.271]                   {
[10:25:48.271]                     default_workers <- missing(workers)
[10:25:48.271]                     if (is.function(workers)) 
[10:25:48.271]                       workers <- workers()
[10:25:48.271]                     workers <- structure(as.integer(workers), 
[10:25:48.271]                       class = class(workers))
[10:25:48.271]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.271]                       1L)
[10:25:48.271]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.271]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.271]                       if (default_workers) 
[10:25:48.271]                         supportsMulticore(warn = TRUE)
[10:25:48.271]                       return(sequential(..., envir = envir))
[10:25:48.271]                     }
[10:25:48.271]                     oopts <- options(mc.cores = workers)
[10:25:48.271]                     on.exit(options(oopts))
[10:25:48.271]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.271]                       envir = envir)
[10:25:48.271]                     if (!future$lazy) 
[10:25:48.271]                       future <- run(future)
[10:25:48.271]                     invisible(future)
[10:25:48.271]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.271]                 }
[10:25:48.271]             }
[10:25:48.271]         }
[10:25:48.271]     })
[10:25:48.271]     if (TRUE) {
[10:25:48.271]         base::sink(type = "output", split = FALSE)
[10:25:48.271]         if (TRUE) {
[10:25:48.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.271]         }
[10:25:48.271]         else {
[10:25:48.271]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.271]         }
[10:25:48.271]         base::close(...future.stdout)
[10:25:48.271]         ...future.stdout <- NULL
[10:25:48.271]     }
[10:25:48.271]     ...future.result$conditions <- ...future.conditions
[10:25:48.271]     ...future.result$finished <- base::Sys.time()
[10:25:48.271]     ...future.result
[10:25:48.271] }
[10:25:48.274] requestCore(): workers = 2
[10:25:48.276] MulticoreFuture started
[10:25:48.277] - Launch lazy future ... done
[10:25:48.277] run() for ‘MulticoreFuture’ ... done
[10:25:48.277] getGlobalsAndPackages() ...
[10:25:48.277] Searching for globals...
[10:25:48.278] plan(): Setting new future strategy stack:
[10:25:48.278] 
[10:25:48.278] List of future strategies:
[10:25:48.278] 1. sequential:
[10:25:48.278]    - args: function (..., envir = parent.frame())
[10:25:48.278]    - tweaked: FALSE
[10:25:48.278]    - call: NULL
[10:25:48.278] Searching for globals ... DONE
[10:25:48.279] - globals: [0] <none>
[10:25:48.279] plan(): nbrOfWorkers() = 1
[10:25:48.279] getGlobalsAndPackages() ... DONE
[10:25:48.279] run() for ‘Future’ ...
[10:25:48.279] - state: ‘created’
[10:25:48.280] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.281] plan(): Setting new future strategy stack:
[10:25:48.281] List of future strategies:
[10:25:48.281] 1. multicore:
[10:25:48.281]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.281]    - tweaked: FALSE
[10:25:48.281]    - call: plan(strategy)
[10:25:48.285] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.285] plan(): nbrOfWorkers() = 2
[10:25:48.285] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.285]   - Field: ‘label’
[10:25:48.285]   - Field: ‘local’
[10:25:48.285]   - Field: ‘owner’
[10:25:48.286]   - Field: ‘envir’
[10:25:48.286]   - Field: ‘workers’
[10:25:48.286]   - Field: ‘packages’
[10:25:48.286]   - Field: ‘gc’
[10:25:48.286]   - Field: ‘job’
[10:25:48.286]   - Field: ‘conditions’
[10:25:48.287]   - Field: ‘expr’
[10:25:48.287]   - Field: ‘uuid’
[10:25:48.287]   - Field: ‘seed’
[10:25:48.287]   - Field: ‘version’
[10:25:48.287]   - Field: ‘result’
[10:25:48.287]   - Field: ‘asynchronous’
[10:25:48.287]   - Field: ‘calls’
[10:25:48.288]   - Field: ‘globals’
[10:25:48.288]   - Field: ‘stdout’
[10:25:48.288]   - Field: ‘earlySignal’
[10:25:48.288]   - Field: ‘lazy’
[10:25:48.288]   - Field: ‘state’
[10:25:48.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.289] - Launch lazy future ...
[10:25:48.289] Packages needed by the future expression (n = 0): <none>
[10:25:48.289] Packages needed by future strategies (n = 0): <none>
[10:25:48.290] {
[10:25:48.290]     {
[10:25:48.290]         {
[10:25:48.290]             ...future.startTime <- base::Sys.time()
[10:25:48.290]             {
[10:25:48.290]                 {
[10:25:48.290]                   {
[10:25:48.290]                     {
[10:25:48.290]                       base::local({
[10:25:48.290]                         has_future <- base::requireNamespace("future", 
[10:25:48.290]                           quietly = TRUE)
[10:25:48.290]                         if (has_future) {
[10:25:48.290]                           ns <- base::getNamespace("future")
[10:25:48.290]                           version <- ns[[".package"]][["version"]]
[10:25:48.290]                           if (is.null(version)) 
[10:25:48.290]                             version <- utils::packageVersion("future")
[10:25:48.290]                         }
[10:25:48.290]                         else {
[10:25:48.290]                           version <- NULL
[10:25:48.290]                         }
[10:25:48.290]                         if (!has_future || version < "1.8.0") {
[10:25:48.290]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.290]                             "", base::R.version$version.string), 
[10:25:48.290]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.290]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.290]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.290]                               "release", "version")], collapse = " "), 
[10:25:48.290]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.290]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.290]                             info)
[10:25:48.290]                           info <- base::paste(info, collapse = "; ")
[10:25:48.290]                           if (!has_future) {
[10:25:48.290]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.290]                               info)
[10:25:48.290]                           }
[10:25:48.290]                           else {
[10:25:48.290]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.290]                               info, version)
[10:25:48.290]                           }
[10:25:48.290]                           base::stop(msg)
[10:25:48.290]                         }
[10:25:48.290]                       })
[10:25:48.290]                     }
[10:25:48.290]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.290]                     base::options(mc.cores = 1L)
[10:25:48.290]                   }
[10:25:48.290]                   options(future.plan = NULL)
[10:25:48.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.290]                 }
[10:25:48.290]                 ...future.workdir <- getwd()
[10:25:48.290]             }
[10:25:48.290]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.290]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.290]         }
[10:25:48.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.290]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.290]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.290]             base::names(...future.oldOptions))
[10:25:48.290]     }
[10:25:48.290]     if (FALSE) {
[10:25:48.290]     }
[10:25:48.290]     else {
[10:25:48.290]         if (TRUE) {
[10:25:48.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.290]                 open = "w")
[10:25:48.290]         }
[10:25:48.290]         else {
[10:25:48.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.290]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.290]         }
[10:25:48.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.290]             base::sink(type = "output", split = FALSE)
[10:25:48.290]             base::close(...future.stdout)
[10:25:48.290]         }, add = TRUE)
[10:25:48.290]     }
[10:25:48.290]     ...future.frame <- base::sys.nframe()
[10:25:48.290]     ...future.conditions <- base::list()
[10:25:48.290]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.290]     if (FALSE) {
[10:25:48.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.290]     }
[10:25:48.290]     ...future.result <- base::tryCatch({
[10:25:48.290]         base::withCallingHandlers({
[10:25:48.290]             ...future.value <- base::withVisible(base::local({
[10:25:48.290]                 withCallingHandlers({
[10:25:48.290]                   NULL
[10:25:48.290]                 }, immediateCondition = function(cond) {
[10:25:48.290]                   save_rds <- function (object, pathname, ...) 
[10:25:48.290]                   {
[10:25:48.290]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.290]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.290]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.290]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.290]                         fi_tmp[["mtime"]])
[10:25:48.290]                     }
[10:25:48.290]                     tryCatch({
[10:25:48.290]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.290]                     }, error = function(ex) {
[10:25:48.290]                       msg <- conditionMessage(ex)
[10:25:48.290]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.290]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.290]                         fi_tmp[["mtime"]], msg)
[10:25:48.290]                       ex$message <- msg
[10:25:48.290]                       stop(ex)
[10:25:48.290]                     })
[10:25:48.290]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.290]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.290]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.290]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.290]                       fi <- file.info(pathname)
[10:25:48.290]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.290]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.290]                         fi[["size"]], fi[["mtime"]])
[10:25:48.290]                       stop(msg)
[10:25:48.290]                     }
[10:25:48.290]                     invisible(pathname)
[10:25:48.290]                   }
[10:25:48.290]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.290]                     rootPath = tempdir()) 
[10:25:48.290]                   {
[10:25:48.290]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.290]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.290]                       tmpdir = path, fileext = ".rds")
[10:25:48.290]                     save_rds(obj, file)
[10:25:48.290]                   }
[10:25:48.290]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.290]                   {
[10:25:48.290]                     inherits <- base::inherits
[10:25:48.290]                     invokeRestart <- base::invokeRestart
[10:25:48.290]                     is.null <- base::is.null
[10:25:48.290]                     muffled <- FALSE
[10:25:48.290]                     if (inherits(cond, "message")) {
[10:25:48.290]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.290]                       if (muffled) 
[10:25:48.290]                         invokeRestart("muffleMessage")
[10:25:48.290]                     }
[10:25:48.290]                     else if (inherits(cond, "warning")) {
[10:25:48.290]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.290]                       if (muffled) 
[10:25:48.290]                         invokeRestart("muffleWarning")
[10:25:48.290]                     }
[10:25:48.290]                     else if (inherits(cond, "condition")) {
[10:25:48.290]                       if (!is.null(pattern)) {
[10:25:48.290]                         computeRestarts <- base::computeRestarts
[10:25:48.290]                         grepl <- base::grepl
[10:25:48.290]                         restarts <- computeRestarts(cond)
[10:25:48.290]                         for (restart in restarts) {
[10:25:48.290]                           name <- restart$name
[10:25:48.290]                           if (is.null(name)) 
[10:25:48.290]                             next
[10:25:48.290]                           if (!grepl(pattern, name)) 
[10:25:48.290]                             next
[10:25:48.290]                           invokeRestart(restart)
[10:25:48.290]                           muffled <- TRUE
[10:25:48.290]                           break
[10:25:48.290]                         }
[10:25:48.290]                       }
[10:25:48.290]                     }
[10:25:48.290]                     invisible(muffled)
[10:25:48.290]                   }
[10:25:48.290]                   muffleCondition(cond)
[10:25:48.290]                 })
[10:25:48.290]             }))
[10:25:48.290]             future::FutureResult(value = ...future.value$value, 
[10:25:48.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.290]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.290]                     ...future.globalenv.names))
[10:25:48.290]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.290]         }, condition = base::local({
[10:25:48.290]             c <- base::c
[10:25:48.290]             inherits <- base::inherits
[10:25:48.290]             invokeRestart <- base::invokeRestart
[10:25:48.290]             length <- base::length
[10:25:48.290]             list <- base::list
[10:25:48.290]             seq.int <- base::seq.int
[10:25:48.290]             signalCondition <- base::signalCondition
[10:25:48.290]             sys.calls <- base::sys.calls
[10:25:48.290]             `[[` <- base::`[[`
[10:25:48.290]             `+` <- base::`+`
[10:25:48.290]             `<<-` <- base::`<<-`
[10:25:48.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.290]                   3L)]
[10:25:48.290]             }
[10:25:48.290]             function(cond) {
[10:25:48.290]                 is_error <- inherits(cond, "error")
[10:25:48.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.290]                   NULL)
[10:25:48.290]                 if (is_error) {
[10:25:48.290]                   sessionInformation <- function() {
[10:25:48.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.290]                       search = base::search(), system = base::Sys.info())
[10:25:48.290]                   }
[10:25:48.290]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.290]                     cond$call), session = sessionInformation(), 
[10:25:48.290]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.290]                   signalCondition(cond)
[10:25:48.290]                 }
[10:25:48.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.290]                 "immediateCondition"))) {
[10:25:48.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.290]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.290]                   if (TRUE && !signal) {
[10:25:48.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.290]                     {
[10:25:48.290]                       inherits <- base::inherits
[10:25:48.290]                       invokeRestart <- base::invokeRestart
[10:25:48.290]                       is.null <- base::is.null
[10:25:48.290]                       muffled <- FALSE
[10:25:48.290]                       if (inherits(cond, "message")) {
[10:25:48.290]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.290]                         if (muffled) 
[10:25:48.290]                           invokeRestart("muffleMessage")
[10:25:48.290]                       }
[10:25:48.290]                       else if (inherits(cond, "warning")) {
[10:25:48.290]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.290]                         if (muffled) 
[10:25:48.290]                           invokeRestart("muffleWarning")
[10:25:48.290]                       }
[10:25:48.290]                       else if (inherits(cond, "condition")) {
[10:25:48.290]                         if (!is.null(pattern)) {
[10:25:48.290]                           computeRestarts <- base::computeRestarts
[10:25:48.290]                           grepl <- base::grepl
[10:25:48.290]                           restarts <- computeRestarts(cond)
[10:25:48.290]                           for (restart in restarts) {
[10:25:48.290]                             name <- restart$name
[10:25:48.290]                             if (is.null(name)) 
[10:25:48.290]                               next
[10:25:48.290]                             if (!grepl(pattern, name)) 
[10:25:48.290]                               next
[10:25:48.290]                             invokeRestart(restart)
[10:25:48.290]                             muffled <- TRUE
[10:25:48.290]                             break
[10:25:48.290]                           }
[10:25:48.290]                         }
[10:25:48.290]                       }
[10:25:48.290]                       invisible(muffled)
[10:25:48.290]                     }
[10:25:48.290]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.290]                   }
[10:25:48.290]                 }
[10:25:48.290]                 else {
[10:25:48.290]                   if (TRUE) {
[10:25:48.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.290]                     {
[10:25:48.290]                       inherits <- base::inherits
[10:25:48.290]                       invokeRestart <- base::invokeRestart
[10:25:48.290]                       is.null <- base::is.null
[10:25:48.290]                       muffled <- FALSE
[10:25:48.290]                       if (inherits(cond, "message")) {
[10:25:48.290]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.290]                         if (muffled) 
[10:25:48.290]                           invokeRestart("muffleMessage")
[10:25:48.290]                       }
[10:25:48.290]                       else if (inherits(cond, "warning")) {
[10:25:48.290]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.290]                         if (muffled) 
[10:25:48.290]                           invokeRestart("muffleWarning")
[10:25:48.290]                       }
[10:25:48.290]                       else if (inherits(cond, "condition")) {
[10:25:48.290]                         if (!is.null(pattern)) {
[10:25:48.290]                           computeRestarts <- base::computeRestarts
[10:25:48.290]                           grepl <- base::grepl
[10:25:48.290]                           restarts <- computeRestarts(cond)
[10:25:48.290]                           for (restart in restarts) {
[10:25:48.290]                             name <- restart$name
[10:25:48.290]                             if (is.null(name)) 
[10:25:48.290]                               next
[10:25:48.290]                             if (!grepl(pattern, name)) 
[10:25:48.290]                               next
[10:25:48.290]                             invokeRestart(restart)
[10:25:48.290]                             muffled <- TRUE
[10:25:48.290]                             break
[10:25:48.290]                           }
[10:25:48.290]                         }
[10:25:48.290]                       }
[10:25:48.290]                       invisible(muffled)
[10:25:48.290]                     }
[10:25:48.290]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.290]                   }
[10:25:48.290]                 }
[10:25:48.290]             }
[10:25:48.290]         }))
[10:25:48.290]     }, error = function(ex) {
[10:25:48.290]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.290]                 ...future.rng), started = ...future.startTime, 
[10:25:48.290]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.290]             version = "1.8"), class = "FutureResult")
[10:25:48.290]     }, finally = {
[10:25:48.290]         if (!identical(...future.workdir, getwd())) 
[10:25:48.290]             setwd(...future.workdir)
[10:25:48.290]         {
[10:25:48.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.290]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.290]             }
[10:25:48.290]             base::options(...future.oldOptions)
[10:25:48.290]             if (.Platform$OS.type == "windows") {
[10:25:48.290]                 old_names <- names(...future.oldEnvVars)
[10:25:48.290]                 envs <- base::Sys.getenv()
[10:25:48.290]                 names <- names(envs)
[10:25:48.290]                 common <- intersect(names, old_names)
[10:25:48.290]                 added <- setdiff(names, old_names)
[10:25:48.290]                 removed <- setdiff(old_names, names)
[10:25:48.290]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.290]                   envs[common]]
[10:25:48.290]                 NAMES <- toupper(changed)
[10:25:48.290]                 args <- list()
[10:25:48.290]                 for (kk in seq_along(NAMES)) {
[10:25:48.290]                   name <- changed[[kk]]
[10:25:48.290]                   NAME <- NAMES[[kk]]
[10:25:48.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.290]                     next
[10:25:48.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.290]                 }
[10:25:48.290]                 NAMES <- toupper(added)
[10:25:48.290]                 for (kk in seq_along(NAMES)) {
[10:25:48.290]                   name <- added[[kk]]
[10:25:48.290]                   NAME <- NAMES[[kk]]
[10:25:48.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.290]                     next
[10:25:48.290]                   args[[name]] <- ""
[10:25:48.290]                 }
[10:25:48.290]                 NAMES <- toupper(removed)
[10:25:48.290]                 for (kk in seq_along(NAMES)) {
[10:25:48.290]                   name <- removed[[kk]]
[10:25:48.290]                   NAME <- NAMES[[kk]]
[10:25:48.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.290]                     next
[10:25:48.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.290]                 }
[10:25:48.290]                 if (length(args) > 0) 
[10:25:48.290]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.290]             }
[10:25:48.290]             else {
[10:25:48.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.290]             }
[10:25:48.290]             {
[10:25:48.290]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.290]                   0L) {
[10:25:48.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.290]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.290]                   base::options(opts)
[10:25:48.290]                 }
[10:25:48.290]                 {
[10:25:48.290]                   {
[10:25:48.290]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.290]                     NULL
[10:25:48.290]                   }
[10:25:48.290]                   options(future.plan = NULL)
[10:25:48.290]                   if (is.na(NA_character_)) 
[10:25:48.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.290]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.290]                     envir = parent.frame()) 
[10:25:48.290]                   {
[10:25:48.290]                     default_workers <- missing(workers)
[10:25:48.290]                     if (is.function(workers)) 
[10:25:48.290]                       workers <- workers()
[10:25:48.290]                     workers <- structure(as.integer(workers), 
[10:25:48.290]                       class = class(workers))
[10:25:48.290]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.290]                       1L)
[10:25:48.290]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.290]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.290]                       if (default_workers) 
[10:25:48.290]                         supportsMulticore(warn = TRUE)
[10:25:48.290]                       return(sequential(..., envir = envir))
[10:25:48.290]                     }
[10:25:48.290]                     oopts <- options(mc.cores = workers)
[10:25:48.290]                     on.exit(options(oopts))
[10:25:48.290]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.290]                       envir = envir)
[10:25:48.290]                     if (!future$lazy) 
[10:25:48.290]                       future <- run(future)
[10:25:48.290]                     invisible(future)
[10:25:48.290]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.290]                 }
[10:25:48.290]             }
[10:25:48.290]         }
[10:25:48.290]     })
[10:25:48.290]     if (TRUE) {
[10:25:48.290]         base::sink(type = "output", split = FALSE)
[10:25:48.290]         if (TRUE) {
[10:25:48.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.290]         }
[10:25:48.290]         else {
[10:25:48.290]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.290]         }
[10:25:48.290]         base::close(...future.stdout)
[10:25:48.290]         ...future.stdout <- NULL
[10:25:48.290]     }
[10:25:48.290]     ...future.result$conditions <- ...future.conditions
[10:25:48.290]     ...future.result$finished <- base::Sys.time()
[10:25:48.290]     ...future.result
[10:25:48.290] }
[10:25:48.294] requestCore(): workers = 2
[10:25:48.296] MulticoreFuture started
[10:25:48.296] - Launch lazy future ... done
[10:25:48.297] run() for ‘MulticoreFuture’ ... done
[10:25:48.297] getGlobalsAndPackages() ...
[10:25:48.297] plan(): Setting new future strategy stack:
[10:25:48.298] Searching for globals...
[10:25:48.298] List of future strategies:
[10:25:48.298] 1. sequential:
[10:25:48.298]    - args: function (..., envir = parent.frame())
[10:25:48.298]    - tweaked: FALSE
[10:25:48.298]    - call: NULL
[10:25:48.298] plan(): nbrOfWorkers() = 1
[10:25:48.299] - globals found: [1] ‘{’
[10:25:48.299] Searching for globals ... DONE
[10:25:48.299] Resolving globals: FALSE
[10:25:48.300] 
[10:25:48.300] 
[10:25:48.300] getGlobalsAndPackages() ... DONE
[10:25:48.300] plan(): Setting new future strategy stack:
[10:25:48.301] run() for ‘Future’ ...
[10:25:48.301] - state: ‘created’
[10:25:48.300] List of future strategies:
[10:25:48.300] 1. multicore:
[10:25:48.300]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.300]    - tweaked: FALSE
[10:25:48.300]    - call: plan(strategy)
[10:25:48.301] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.305] plan(): nbrOfWorkers() = 2
[10:25:48.306] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.306]   - Field: ‘label’
[10:25:48.306]   - Field: ‘local’
[10:25:48.306]   - Field: ‘owner’
[10:25:48.306]   - Field: ‘envir’
[10:25:48.306]   - Field: ‘workers’
[10:25:48.307]   - Field: ‘packages’
[10:25:48.307]   - Field: ‘gc’
[10:25:48.307]   - Field: ‘job’
[10:25:48.307]   - Field: ‘conditions’
[10:25:48.307]   - Field: ‘expr’
[10:25:48.307]   - Field: ‘uuid’
[10:25:48.307]   - Field: ‘seed’
[10:25:48.308]   - Field: ‘version’
[10:25:48.308]   - Field: ‘result’
[10:25:48.308]   - Field: ‘asynchronous’
[10:25:48.308]   - Field: ‘calls’
[10:25:48.308]   - Field: ‘globals’
[10:25:48.308]   - Field: ‘stdout’
[10:25:48.308]   - Field: ‘earlySignal’
[10:25:48.308]   - Field: ‘lazy’
[10:25:48.309]   - Field: ‘state’
[10:25:48.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.309] - Launch lazy future ...
[10:25:48.309] Packages needed by the future expression (n = 0): <none>
[10:25:48.310] Packages needed by future strategies (n = 0): <none>
[10:25:48.310] {
[10:25:48.310]     {
[10:25:48.310]         {
[10:25:48.310]             ...future.startTime <- base::Sys.time()
[10:25:48.310]             {
[10:25:48.310]                 {
[10:25:48.310]                   {
[10:25:48.310]                     {
[10:25:48.310]                       base::local({
[10:25:48.310]                         has_future <- base::requireNamespace("future", 
[10:25:48.310]                           quietly = TRUE)
[10:25:48.310]                         if (has_future) {
[10:25:48.310]                           ns <- base::getNamespace("future")
[10:25:48.310]                           version <- ns[[".package"]][["version"]]
[10:25:48.310]                           if (is.null(version)) 
[10:25:48.310]                             version <- utils::packageVersion("future")
[10:25:48.310]                         }
[10:25:48.310]                         else {
[10:25:48.310]                           version <- NULL
[10:25:48.310]                         }
[10:25:48.310]                         if (!has_future || version < "1.8.0") {
[10:25:48.310]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.310]                             "", base::R.version$version.string), 
[10:25:48.310]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.310]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.310]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.310]                               "release", "version")], collapse = " "), 
[10:25:48.310]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.310]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.310]                             info)
[10:25:48.310]                           info <- base::paste(info, collapse = "; ")
[10:25:48.310]                           if (!has_future) {
[10:25:48.310]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.310]                               info)
[10:25:48.310]                           }
[10:25:48.310]                           else {
[10:25:48.310]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.310]                               info, version)
[10:25:48.310]                           }
[10:25:48.310]                           base::stop(msg)
[10:25:48.310]                         }
[10:25:48.310]                       })
[10:25:48.310]                     }
[10:25:48.310]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.310]                     base::options(mc.cores = 1L)
[10:25:48.310]                   }
[10:25:48.310]                   options(future.plan = NULL)
[10:25:48.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.310]                 }
[10:25:48.310]                 ...future.workdir <- getwd()
[10:25:48.310]             }
[10:25:48.310]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.310]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.310]         }
[10:25:48.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.310]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.310]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.310]             base::names(...future.oldOptions))
[10:25:48.310]     }
[10:25:48.310]     if (FALSE) {
[10:25:48.310]     }
[10:25:48.310]     else {
[10:25:48.310]         if (TRUE) {
[10:25:48.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.310]                 open = "w")
[10:25:48.310]         }
[10:25:48.310]         else {
[10:25:48.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.310]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.310]         }
[10:25:48.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.310]             base::sink(type = "output", split = FALSE)
[10:25:48.310]             base::close(...future.stdout)
[10:25:48.310]         }, add = TRUE)
[10:25:48.310]     }
[10:25:48.310]     ...future.frame <- base::sys.nframe()
[10:25:48.310]     ...future.conditions <- base::list()
[10:25:48.310]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.310]     if (FALSE) {
[10:25:48.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.310]     }
[10:25:48.310]     ...future.result <- base::tryCatch({
[10:25:48.310]         base::withCallingHandlers({
[10:25:48.310]             ...future.value <- base::withVisible(base::local({
[10:25:48.310]                 withCallingHandlers({
[10:25:48.310]                   {
[10:25:48.310]                     4
[10:25:48.310]                   }
[10:25:48.310]                 }, immediateCondition = function(cond) {
[10:25:48.310]                   save_rds <- function (object, pathname, ...) 
[10:25:48.310]                   {
[10:25:48.310]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.310]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.310]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.310]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.310]                         fi_tmp[["mtime"]])
[10:25:48.310]                     }
[10:25:48.310]                     tryCatch({
[10:25:48.310]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.310]                     }, error = function(ex) {
[10:25:48.310]                       msg <- conditionMessage(ex)
[10:25:48.310]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.310]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.310]                         fi_tmp[["mtime"]], msg)
[10:25:48.310]                       ex$message <- msg
[10:25:48.310]                       stop(ex)
[10:25:48.310]                     })
[10:25:48.310]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.310]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.310]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.310]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.310]                       fi <- file.info(pathname)
[10:25:48.310]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.310]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.310]                         fi[["size"]], fi[["mtime"]])
[10:25:48.310]                       stop(msg)
[10:25:48.310]                     }
[10:25:48.310]                     invisible(pathname)
[10:25:48.310]                   }
[10:25:48.310]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.310]                     rootPath = tempdir()) 
[10:25:48.310]                   {
[10:25:48.310]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.310]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.310]                       tmpdir = path, fileext = ".rds")
[10:25:48.310]                     save_rds(obj, file)
[10:25:48.310]                   }
[10:25:48.310]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.310]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.310]                   {
[10:25:48.310]                     inherits <- base::inherits
[10:25:48.310]                     invokeRestart <- base::invokeRestart
[10:25:48.310]                     is.null <- base::is.null
[10:25:48.310]                     muffled <- FALSE
[10:25:48.310]                     if (inherits(cond, "message")) {
[10:25:48.310]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.310]                       if (muffled) 
[10:25:48.310]                         invokeRestart("muffleMessage")
[10:25:48.310]                     }
[10:25:48.310]                     else if (inherits(cond, "warning")) {
[10:25:48.310]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.310]                       if (muffled) 
[10:25:48.310]                         invokeRestart("muffleWarning")
[10:25:48.310]                     }
[10:25:48.310]                     else if (inherits(cond, "condition")) {
[10:25:48.310]                       if (!is.null(pattern)) {
[10:25:48.310]                         computeRestarts <- base::computeRestarts
[10:25:48.310]                         grepl <- base::grepl
[10:25:48.310]                         restarts <- computeRestarts(cond)
[10:25:48.310]                         for (restart in restarts) {
[10:25:48.310]                           name <- restart$name
[10:25:48.310]                           if (is.null(name)) 
[10:25:48.310]                             next
[10:25:48.310]                           if (!grepl(pattern, name)) 
[10:25:48.310]                             next
[10:25:48.310]                           invokeRestart(restart)
[10:25:48.310]                           muffled <- TRUE
[10:25:48.310]                           break
[10:25:48.310]                         }
[10:25:48.310]                       }
[10:25:48.310]                     }
[10:25:48.310]                     invisible(muffled)
[10:25:48.310]                   }
[10:25:48.310]                   muffleCondition(cond)
[10:25:48.310]                 })
[10:25:48.310]             }))
[10:25:48.310]             future::FutureResult(value = ...future.value$value, 
[10:25:48.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.310]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.310]                     ...future.globalenv.names))
[10:25:48.310]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.310]         }, condition = base::local({
[10:25:48.310]             c <- base::c
[10:25:48.310]             inherits <- base::inherits
[10:25:48.310]             invokeRestart <- base::invokeRestart
[10:25:48.310]             length <- base::length
[10:25:48.310]             list <- base::list
[10:25:48.310]             seq.int <- base::seq.int
[10:25:48.310]             signalCondition <- base::signalCondition
[10:25:48.310]             sys.calls <- base::sys.calls
[10:25:48.310]             `[[` <- base::`[[`
[10:25:48.310]             `+` <- base::`+`
[10:25:48.310]             `<<-` <- base::`<<-`
[10:25:48.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.310]                   3L)]
[10:25:48.310]             }
[10:25:48.310]             function(cond) {
[10:25:48.310]                 is_error <- inherits(cond, "error")
[10:25:48.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.310]                   NULL)
[10:25:48.310]                 if (is_error) {
[10:25:48.310]                   sessionInformation <- function() {
[10:25:48.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.310]                       search = base::search(), system = base::Sys.info())
[10:25:48.310]                   }
[10:25:48.310]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.310]                     cond$call), session = sessionInformation(), 
[10:25:48.310]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.310]                   signalCondition(cond)
[10:25:48.310]                 }
[10:25:48.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.310]                 "immediateCondition"))) {
[10:25:48.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.310]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.310]                   if (TRUE && !signal) {
[10:25:48.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.310]                     {
[10:25:48.310]                       inherits <- base::inherits
[10:25:48.310]                       invokeRestart <- base::invokeRestart
[10:25:48.310]                       is.null <- base::is.null
[10:25:48.310]                       muffled <- FALSE
[10:25:48.310]                       if (inherits(cond, "message")) {
[10:25:48.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.310]                         if (muffled) 
[10:25:48.310]                           invokeRestart("muffleMessage")
[10:25:48.310]                       }
[10:25:48.310]                       else if (inherits(cond, "warning")) {
[10:25:48.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.310]                         if (muffled) 
[10:25:48.310]                           invokeRestart("muffleWarning")
[10:25:48.310]                       }
[10:25:48.310]                       else if (inherits(cond, "condition")) {
[10:25:48.310]                         if (!is.null(pattern)) {
[10:25:48.310]                           computeRestarts <- base::computeRestarts
[10:25:48.310]                           grepl <- base::grepl
[10:25:48.310]                           restarts <- computeRestarts(cond)
[10:25:48.310]                           for (restart in restarts) {
[10:25:48.310]                             name <- restart$name
[10:25:48.310]                             if (is.null(name)) 
[10:25:48.310]                               next
[10:25:48.310]                             if (!grepl(pattern, name)) 
[10:25:48.310]                               next
[10:25:48.310]                             invokeRestart(restart)
[10:25:48.310]                             muffled <- TRUE
[10:25:48.310]                             break
[10:25:48.310]                           }
[10:25:48.310]                         }
[10:25:48.310]                       }
[10:25:48.310]                       invisible(muffled)
[10:25:48.310]                     }
[10:25:48.310]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.310]                   }
[10:25:48.310]                 }
[10:25:48.310]                 else {
[10:25:48.310]                   if (TRUE) {
[10:25:48.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.310]                     {
[10:25:48.310]                       inherits <- base::inherits
[10:25:48.310]                       invokeRestart <- base::invokeRestart
[10:25:48.310]                       is.null <- base::is.null
[10:25:48.310]                       muffled <- FALSE
[10:25:48.310]                       if (inherits(cond, "message")) {
[10:25:48.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.310]                         if (muffled) 
[10:25:48.310]                           invokeRestart("muffleMessage")
[10:25:48.310]                       }
[10:25:48.310]                       else if (inherits(cond, "warning")) {
[10:25:48.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.310]                         if (muffled) 
[10:25:48.310]                           invokeRestart("muffleWarning")
[10:25:48.310]                       }
[10:25:48.310]                       else if (inherits(cond, "condition")) {
[10:25:48.310]                         if (!is.null(pattern)) {
[10:25:48.310]                           computeRestarts <- base::computeRestarts
[10:25:48.310]                           grepl <- base::grepl
[10:25:48.310]                           restarts <- computeRestarts(cond)
[10:25:48.310]                           for (restart in restarts) {
[10:25:48.310]                             name <- restart$name
[10:25:48.310]                             if (is.null(name)) 
[10:25:48.310]                               next
[10:25:48.310]                             if (!grepl(pattern, name)) 
[10:25:48.310]                               next
[10:25:48.310]                             invokeRestart(restart)
[10:25:48.310]                             muffled <- TRUE
[10:25:48.310]                             break
[10:25:48.310]                           }
[10:25:48.310]                         }
[10:25:48.310]                       }
[10:25:48.310]                       invisible(muffled)
[10:25:48.310]                     }
[10:25:48.310]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.310]                   }
[10:25:48.310]                 }
[10:25:48.310]             }
[10:25:48.310]         }))
[10:25:48.310]     }, error = function(ex) {
[10:25:48.310]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.310]                 ...future.rng), started = ...future.startTime, 
[10:25:48.310]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.310]             version = "1.8"), class = "FutureResult")
[10:25:48.310]     }, finally = {
[10:25:48.310]         if (!identical(...future.workdir, getwd())) 
[10:25:48.310]             setwd(...future.workdir)
[10:25:48.310]         {
[10:25:48.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.310]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.310]             }
[10:25:48.310]             base::options(...future.oldOptions)
[10:25:48.310]             if (.Platform$OS.type == "windows") {
[10:25:48.310]                 old_names <- names(...future.oldEnvVars)
[10:25:48.310]                 envs <- base::Sys.getenv()
[10:25:48.310]                 names <- names(envs)
[10:25:48.310]                 common <- intersect(names, old_names)
[10:25:48.310]                 added <- setdiff(names, old_names)
[10:25:48.310]                 removed <- setdiff(old_names, names)
[10:25:48.310]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.310]                   envs[common]]
[10:25:48.310]                 NAMES <- toupper(changed)
[10:25:48.310]                 args <- list()
[10:25:48.310]                 for (kk in seq_along(NAMES)) {
[10:25:48.310]                   name <- changed[[kk]]
[10:25:48.310]                   NAME <- NAMES[[kk]]
[10:25:48.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.310]                     next
[10:25:48.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.310]                 }
[10:25:48.310]                 NAMES <- toupper(added)
[10:25:48.310]                 for (kk in seq_along(NAMES)) {
[10:25:48.310]                   name <- added[[kk]]
[10:25:48.310]                   NAME <- NAMES[[kk]]
[10:25:48.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.310]                     next
[10:25:48.310]                   args[[name]] <- ""
[10:25:48.310]                 }
[10:25:48.310]                 NAMES <- toupper(removed)
[10:25:48.310]                 for (kk in seq_along(NAMES)) {
[10:25:48.310]                   name <- removed[[kk]]
[10:25:48.310]                   NAME <- NAMES[[kk]]
[10:25:48.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.310]                     next
[10:25:48.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.310]                 }
[10:25:48.310]                 if (length(args) > 0) 
[10:25:48.310]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.310]             }
[10:25:48.310]             else {
[10:25:48.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.310]             }
[10:25:48.310]             {
[10:25:48.310]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.310]                   0L) {
[10:25:48.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.310]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.310]                   base::options(opts)
[10:25:48.310]                 }
[10:25:48.310]                 {
[10:25:48.310]                   {
[10:25:48.310]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.310]                     NULL
[10:25:48.310]                   }
[10:25:48.310]                   options(future.plan = NULL)
[10:25:48.310]                   if (is.na(NA_character_)) 
[10:25:48.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.310]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.310]                     envir = parent.frame()) 
[10:25:48.310]                   {
[10:25:48.310]                     default_workers <- missing(workers)
[10:25:48.310]                     if (is.function(workers)) 
[10:25:48.310]                       workers <- workers()
[10:25:48.310]                     workers <- structure(as.integer(workers), 
[10:25:48.310]                       class = class(workers))
[10:25:48.310]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.310]                       1L)
[10:25:48.310]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.310]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.310]                       if (default_workers) 
[10:25:48.310]                         supportsMulticore(warn = TRUE)
[10:25:48.310]                       return(sequential(..., envir = envir))
[10:25:48.310]                     }
[10:25:48.310]                     oopts <- options(mc.cores = workers)
[10:25:48.310]                     on.exit(options(oopts))
[10:25:48.310]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.310]                       envir = envir)
[10:25:48.310]                     if (!future$lazy) 
[10:25:48.310]                       future <- run(future)
[10:25:48.310]                     invisible(future)
[10:25:48.310]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.310]                 }
[10:25:48.310]             }
[10:25:48.310]         }
[10:25:48.310]     })
[10:25:48.310]     if (TRUE) {
[10:25:48.310]         base::sink(type = "output", split = FALSE)
[10:25:48.310]         if (TRUE) {
[10:25:48.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.310]         }
[10:25:48.310]         else {
[10:25:48.310]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.310]         }
[10:25:48.310]         base::close(...future.stdout)
[10:25:48.310]         ...future.stdout <- NULL
[10:25:48.310]     }
[10:25:48.310]     ...future.result$conditions <- ...future.conditions
[10:25:48.310]     ...future.result$finished <- base::Sys.time()
[10:25:48.310]     ...future.result
[10:25:48.310] }
[10:25:48.314] requestCore(): workers = 2
[10:25:48.314] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:48.337] result() for MulticoreFuture ...
[10:25:48.338] result() for MulticoreFuture ...
[10:25:48.338] result() for MulticoreFuture ... done
[10:25:48.339] result() for MulticoreFuture ... done
[10:25:48.339] result() for MulticoreFuture ...
[10:25:48.339] result() for MulticoreFuture ... done
[10:25:48.341] MulticoreFuture started
[10:25:48.342] - Launch lazy future ... done
[10:25:48.342] run() for ‘MulticoreFuture’ ... done
[10:25:48.343] plan(): Setting new future strategy stack:
<environment: 0x55c0f4c0baf0> 
[10:25:48.343] List of future strategies:
[10:25:48.343] 1. sequential:
[10:25:48.343]    - args: function (..., envir = parent.frame())
[10:25:48.343]    - tweaked: FALSE
[10:25:48.343]    - call: NULL
[10:25:48.344] plan(): nbrOfWorkers() = 1
<environment: 0x55c0f6b95120> 
[10:25:48.347] plan(): Setting new future strategy stack:
[10:25:48.347] List of future strategies:
[10:25:48.347] 1. multicore:
[10:25:48.347]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.347]    - tweaked: FALSE
[10:25:48.347]    - call: plan(strategy)
[10:25:48.352] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:48.354] resolve() on environment ...
[10:25:48.354]  recursive: 0
[10:25:48.355]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:48.355] signalConditionsASAP(numeric, pos=1) ...
[10:25:48.355] - nx: 4
[10:25:48.356] - relay: TRUE
[10:25:48.356] - stdout: TRUE
[10:25:48.356] - signal: TRUE
[10:25:48.356] - resignal: FALSE
[10:25:48.356] - force: TRUE
[10:25:48.356] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.356] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.356]  - until=2
[10:25:48.357]  - relaying element #2
[10:25:48.357] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.357] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.357] signalConditionsASAP(NULL, pos=1) ... done
[10:25:48.357]  length: 3 (resolved future 1)
[10:25:48.357] Future #2
[10:25:48.357] result() for MulticoreFuture ...
[10:25:48.358] result() for MulticoreFuture ... done
[10:25:48.358] result() for MulticoreFuture ...
[10:25:48.358] result() for MulticoreFuture ... done
[10:25:48.358] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:48.358] - nx: 4
[10:25:48.358] - relay: TRUE
[10:25:48.358] - stdout: TRUE
[10:25:48.359] - signal: TRUE
[10:25:48.359] - resignal: FALSE
[10:25:48.359] - force: TRUE
[10:25:48.359] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.359] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.359]  - until=2
[10:25:48.359]  - relaying element #2
[10:25:48.359] result() for MulticoreFuture ...
[10:25:48.359] result() for MulticoreFuture ... done
[10:25:48.360] result() for MulticoreFuture ...
[10:25:48.360] result() for MulticoreFuture ... done
[10:25:48.360] result() for MulticoreFuture ...
[10:25:48.360] result() for MulticoreFuture ... done
[10:25:48.360] result() for MulticoreFuture ...
[10:25:48.360] result() for MulticoreFuture ... done
[10:25:48.360] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.361] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.361] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:48.361]  length: 2 (resolved future 2)
[10:25:48.361] Future #3
[10:25:48.361] result() for MulticoreFuture ...
[10:25:48.362] result() for MulticoreFuture ...
[10:25:48.362] result() for MulticoreFuture ... done
[10:25:48.362] result() for MulticoreFuture ... done
[10:25:48.363] result() for MulticoreFuture ...
[10:25:48.363] result() for MulticoreFuture ... done
[10:25:48.363] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:48.363] - nx: 4
[10:25:48.363] - relay: TRUE
[10:25:48.363] - stdout: TRUE
[10:25:48.363] - signal: TRUE
[10:25:48.363] - resignal: FALSE
[10:25:48.363] - force: TRUE
[10:25:48.364] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.364] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.364]  - until=3
[10:25:48.364]  - relaying element #3
[10:25:48.364] result() for MulticoreFuture ...
[10:25:48.364] result() for MulticoreFuture ... done
[10:25:48.364] result() for MulticoreFuture ...
[10:25:48.364] result() for MulticoreFuture ... done
[10:25:48.365] result() for MulticoreFuture ...
[10:25:48.365] result() for MulticoreFuture ... done
[10:25:48.365] result() for MulticoreFuture ...
[10:25:48.365] result() for MulticoreFuture ... done
[10:25:48.365] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.365] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.365] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:48.366]  length: 1 (resolved future 3)
[10:25:48.366] Future #4
[10:25:48.366] result() for MulticoreFuture ...
[10:25:48.367] result() for MulticoreFuture ...
[10:25:48.367] result() for MulticoreFuture ... done
[10:25:48.367] result() for MulticoreFuture ... done
[10:25:48.367] result() for MulticoreFuture ...
[10:25:48.367] result() for MulticoreFuture ... done
[10:25:48.368] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:48.368] - nx: 4
[10:25:48.368] - relay: TRUE
[10:25:48.368] - stdout: TRUE
[10:25:48.368] - signal: TRUE
[10:25:48.368] - resignal: FALSE
[10:25:48.369] - force: TRUE
[10:25:48.369] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.369] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.369]  - until=4
[10:25:48.369]  - relaying element #4
[10:25:48.369] result() for MulticoreFuture ...
[10:25:48.370] result() for MulticoreFuture ... done
[10:25:48.370] result() for MulticoreFuture ...
[10:25:48.370] result() for MulticoreFuture ... done
[10:25:48.370] result() for MulticoreFuture ...
[10:25:48.370] result() for MulticoreFuture ... done
[10:25:48.370] result() for MulticoreFuture ...
[10:25:48.370] result() for MulticoreFuture ... done
[10:25:48.370] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.371] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.371] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:48.371]  length: 0 (resolved future 4)
[10:25:48.371] Relaying remaining futures
[10:25:48.371] signalConditionsASAP(NULL, pos=0) ...
[10:25:48.371] - nx: 4
[10:25:48.371] - relay: TRUE
[10:25:48.371] - stdout: TRUE
[10:25:48.371] - signal: TRUE
[10:25:48.371] - resignal: FALSE
[10:25:48.372] - force: TRUE
[10:25:48.372] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.372] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:48.372] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.372] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.372] signalConditionsASAP(NULL, pos=0) ... done
[10:25:48.372] resolve() on environment ... DONE
[10:25:48.372] result() for MulticoreFuture ...
[10:25:48.372] result() for MulticoreFuture ... done
[10:25:48.373] result() for MulticoreFuture ...
[10:25:48.373] result() for MulticoreFuture ... done
[10:25:48.373] result() for MulticoreFuture ...
[10:25:48.373] result() for MulticoreFuture ... done
[10:25:48.373] result() for MulticoreFuture ...
[10:25:48.373] result() for MulticoreFuture ... done
[10:25:48.373] result() for MulticoreFuture ...
[10:25:48.373] result() for MulticoreFuture ... done
[10:25:48.373] result() for MulticoreFuture ...
[10:25:48.374] result() for MulticoreFuture ... done
<environment: 0x55c0f6c42bc0> 
Dimensions: c(2, 3)
[10:25:48.374] getGlobalsAndPackages() ...
[10:25:48.374] Searching for globals...
[10:25:48.375] 
[10:25:48.375] Searching for globals ... DONE
[10:25:48.375] - globals: [0] <none>
[10:25:48.375] getGlobalsAndPackages() ... DONE
[10:25:48.375] run() for ‘Future’ ...
[10:25:48.375] - state: ‘created’
[10:25:48.376] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.383] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.384]   - Field: ‘label’
[10:25:48.384]   - Field: ‘local’
[10:25:48.384]   - Field: ‘owner’
[10:25:48.384]   - Field: ‘envir’
[10:25:48.384]   - Field: ‘workers’
[10:25:48.385]   - Field: ‘packages’
[10:25:48.385]   - Field: ‘gc’
[10:25:48.385]   - Field: ‘job’
[10:25:48.385]   - Field: ‘conditions’
[10:25:48.385]   - Field: ‘expr’
[10:25:48.385]   - Field: ‘uuid’
[10:25:48.385]   - Field: ‘seed’
[10:25:48.385]   - Field: ‘version’
[10:25:48.386]   - Field: ‘result’
[10:25:48.386]   - Field: ‘asynchronous’
[10:25:48.386]   - Field: ‘calls’
[10:25:48.386]   - Field: ‘globals’
[10:25:48.386]   - Field: ‘stdout’
[10:25:48.386]   - Field: ‘earlySignal’
[10:25:48.386]   - Field: ‘lazy’
[10:25:48.386]   - Field: ‘state’
[10:25:48.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.387] - Launch lazy future ...
[10:25:48.387] Packages needed by the future expression (n = 0): <none>
[10:25:48.387] Packages needed by future strategies (n = 0): <none>
[10:25:48.388] {
[10:25:48.388]     {
[10:25:48.388]         {
[10:25:48.388]             ...future.startTime <- base::Sys.time()
[10:25:48.388]             {
[10:25:48.388]                 {
[10:25:48.388]                   {
[10:25:48.388]                     {
[10:25:48.388]                       base::local({
[10:25:48.388]                         has_future <- base::requireNamespace("future", 
[10:25:48.388]                           quietly = TRUE)
[10:25:48.388]                         if (has_future) {
[10:25:48.388]                           ns <- base::getNamespace("future")
[10:25:48.388]                           version <- ns[[".package"]][["version"]]
[10:25:48.388]                           if (is.null(version)) 
[10:25:48.388]                             version <- utils::packageVersion("future")
[10:25:48.388]                         }
[10:25:48.388]                         else {
[10:25:48.388]                           version <- NULL
[10:25:48.388]                         }
[10:25:48.388]                         if (!has_future || version < "1.8.0") {
[10:25:48.388]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.388]                             "", base::R.version$version.string), 
[10:25:48.388]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.388]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.388]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.388]                               "release", "version")], collapse = " "), 
[10:25:48.388]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.388]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.388]                             info)
[10:25:48.388]                           info <- base::paste(info, collapse = "; ")
[10:25:48.388]                           if (!has_future) {
[10:25:48.388]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.388]                               info)
[10:25:48.388]                           }
[10:25:48.388]                           else {
[10:25:48.388]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.388]                               info, version)
[10:25:48.388]                           }
[10:25:48.388]                           base::stop(msg)
[10:25:48.388]                         }
[10:25:48.388]                       })
[10:25:48.388]                     }
[10:25:48.388]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.388]                     base::options(mc.cores = 1L)
[10:25:48.388]                   }
[10:25:48.388]                   options(future.plan = NULL)
[10:25:48.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.388]                 }
[10:25:48.388]                 ...future.workdir <- getwd()
[10:25:48.388]             }
[10:25:48.388]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.388]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.388]         }
[10:25:48.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.388]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.388]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.388]             base::names(...future.oldOptions))
[10:25:48.388]     }
[10:25:48.388]     if (FALSE) {
[10:25:48.388]     }
[10:25:48.388]     else {
[10:25:48.388]         if (TRUE) {
[10:25:48.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.388]                 open = "w")
[10:25:48.388]         }
[10:25:48.388]         else {
[10:25:48.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.388]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.388]         }
[10:25:48.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.388]             base::sink(type = "output", split = FALSE)
[10:25:48.388]             base::close(...future.stdout)
[10:25:48.388]         }, add = TRUE)
[10:25:48.388]     }
[10:25:48.388]     ...future.frame <- base::sys.nframe()
[10:25:48.388]     ...future.conditions <- base::list()
[10:25:48.388]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.388]     if (FALSE) {
[10:25:48.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.388]     }
[10:25:48.388]     ...future.result <- base::tryCatch({
[10:25:48.388]         base::withCallingHandlers({
[10:25:48.388]             ...future.value <- base::withVisible(base::local({
[10:25:48.388]                 withCallingHandlers({
[10:25:48.388]                   2
[10:25:48.388]                 }, immediateCondition = function(cond) {
[10:25:48.388]                   save_rds <- function (object, pathname, ...) 
[10:25:48.388]                   {
[10:25:48.388]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.388]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.388]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.388]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.388]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.388]                         fi_tmp[["mtime"]])
[10:25:48.388]                     }
[10:25:48.388]                     tryCatch({
[10:25:48.388]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.388]                     }, error = function(ex) {
[10:25:48.388]                       msg <- conditionMessage(ex)
[10:25:48.388]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.388]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.388]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.388]                         fi_tmp[["mtime"]], msg)
[10:25:48.388]                       ex$message <- msg
[10:25:48.388]                       stop(ex)
[10:25:48.388]                     })
[10:25:48.388]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.388]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.388]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.388]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.388]                       fi <- file.info(pathname)
[10:25:48.388]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.388]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.388]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.388]                         fi[["size"]], fi[["mtime"]])
[10:25:48.388]                       stop(msg)
[10:25:48.388]                     }
[10:25:48.388]                     invisible(pathname)
[10:25:48.388]                   }
[10:25:48.388]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.388]                     rootPath = tempdir()) 
[10:25:48.388]                   {
[10:25:48.388]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.388]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.388]                       tmpdir = path, fileext = ".rds")
[10:25:48.388]                     save_rds(obj, file)
[10:25:48.388]                   }
[10:25:48.388]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.388]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.388]                   {
[10:25:48.388]                     inherits <- base::inherits
[10:25:48.388]                     invokeRestart <- base::invokeRestart
[10:25:48.388]                     is.null <- base::is.null
[10:25:48.388]                     muffled <- FALSE
[10:25:48.388]                     if (inherits(cond, "message")) {
[10:25:48.388]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.388]                       if (muffled) 
[10:25:48.388]                         invokeRestart("muffleMessage")
[10:25:48.388]                     }
[10:25:48.388]                     else if (inherits(cond, "warning")) {
[10:25:48.388]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.388]                       if (muffled) 
[10:25:48.388]                         invokeRestart("muffleWarning")
[10:25:48.388]                     }
[10:25:48.388]                     else if (inherits(cond, "condition")) {
[10:25:48.388]                       if (!is.null(pattern)) {
[10:25:48.388]                         computeRestarts <- base::computeRestarts
[10:25:48.388]                         grepl <- base::grepl
[10:25:48.388]                         restarts <- computeRestarts(cond)
[10:25:48.388]                         for (restart in restarts) {
[10:25:48.388]                           name <- restart$name
[10:25:48.388]                           if (is.null(name)) 
[10:25:48.388]                             next
[10:25:48.388]                           if (!grepl(pattern, name)) 
[10:25:48.388]                             next
[10:25:48.388]                           invokeRestart(restart)
[10:25:48.388]                           muffled <- TRUE
[10:25:48.388]                           break
[10:25:48.388]                         }
[10:25:48.388]                       }
[10:25:48.388]                     }
[10:25:48.388]                     invisible(muffled)
[10:25:48.388]                   }
[10:25:48.388]                   muffleCondition(cond)
[10:25:48.388]                 })
[10:25:48.388]             }))
[10:25:48.388]             future::FutureResult(value = ...future.value$value, 
[10:25:48.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.388]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.388]                     ...future.globalenv.names))
[10:25:48.388]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.388]         }, condition = base::local({
[10:25:48.388]             c <- base::c
[10:25:48.388]             inherits <- base::inherits
[10:25:48.388]             invokeRestart <- base::invokeRestart
[10:25:48.388]             length <- base::length
[10:25:48.388]             list <- base::list
[10:25:48.388]             seq.int <- base::seq.int
[10:25:48.388]             signalCondition <- base::signalCondition
[10:25:48.388]             sys.calls <- base::sys.calls
[10:25:48.388]             `[[` <- base::`[[`
[10:25:48.388]             `+` <- base::`+`
[10:25:48.388]             `<<-` <- base::`<<-`
[10:25:48.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.388]                   3L)]
[10:25:48.388]             }
[10:25:48.388]             function(cond) {
[10:25:48.388]                 is_error <- inherits(cond, "error")
[10:25:48.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.388]                   NULL)
[10:25:48.388]                 if (is_error) {
[10:25:48.388]                   sessionInformation <- function() {
[10:25:48.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.388]                       search = base::search(), system = base::Sys.info())
[10:25:48.388]                   }
[10:25:48.388]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.388]                     cond$call), session = sessionInformation(), 
[10:25:48.388]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.388]                   signalCondition(cond)
[10:25:48.388]                 }
[10:25:48.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.388]                 "immediateCondition"))) {
[10:25:48.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.388]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.388]                   if (TRUE && !signal) {
[10:25:48.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.388]                     {
[10:25:48.388]                       inherits <- base::inherits
[10:25:48.388]                       invokeRestart <- base::invokeRestart
[10:25:48.388]                       is.null <- base::is.null
[10:25:48.388]                       muffled <- FALSE
[10:25:48.388]                       if (inherits(cond, "message")) {
[10:25:48.388]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.388]                         if (muffled) 
[10:25:48.388]                           invokeRestart("muffleMessage")
[10:25:48.388]                       }
[10:25:48.388]                       else if (inherits(cond, "warning")) {
[10:25:48.388]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.388]                         if (muffled) 
[10:25:48.388]                           invokeRestart("muffleWarning")
[10:25:48.388]                       }
[10:25:48.388]                       else if (inherits(cond, "condition")) {
[10:25:48.388]                         if (!is.null(pattern)) {
[10:25:48.388]                           computeRestarts <- base::computeRestarts
[10:25:48.388]                           grepl <- base::grepl
[10:25:48.388]                           restarts <- computeRestarts(cond)
[10:25:48.388]                           for (restart in restarts) {
[10:25:48.388]                             name <- restart$name
[10:25:48.388]                             if (is.null(name)) 
[10:25:48.388]                               next
[10:25:48.388]                             if (!grepl(pattern, name)) 
[10:25:48.388]                               next
[10:25:48.388]                             invokeRestart(restart)
[10:25:48.388]                             muffled <- TRUE
[10:25:48.388]                             break
[10:25:48.388]                           }
[10:25:48.388]                         }
[10:25:48.388]                       }
[10:25:48.388]                       invisible(muffled)
[10:25:48.388]                     }
[10:25:48.388]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.388]                   }
[10:25:48.388]                 }
[10:25:48.388]                 else {
[10:25:48.388]                   if (TRUE) {
[10:25:48.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.388]                     {
[10:25:48.388]                       inherits <- base::inherits
[10:25:48.388]                       invokeRestart <- base::invokeRestart
[10:25:48.388]                       is.null <- base::is.null
[10:25:48.388]                       muffled <- FALSE
[10:25:48.388]                       if (inherits(cond, "message")) {
[10:25:48.388]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.388]                         if (muffled) 
[10:25:48.388]                           invokeRestart("muffleMessage")
[10:25:48.388]                       }
[10:25:48.388]                       else if (inherits(cond, "warning")) {
[10:25:48.388]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.388]                         if (muffled) 
[10:25:48.388]                           invokeRestart("muffleWarning")
[10:25:48.388]                       }
[10:25:48.388]                       else if (inherits(cond, "condition")) {
[10:25:48.388]                         if (!is.null(pattern)) {
[10:25:48.388]                           computeRestarts <- base::computeRestarts
[10:25:48.388]                           grepl <- base::grepl
[10:25:48.388]                           restarts <- computeRestarts(cond)
[10:25:48.388]                           for (restart in restarts) {
[10:25:48.388]                             name <- restart$name
[10:25:48.388]                             if (is.null(name)) 
[10:25:48.388]                               next
[10:25:48.388]                             if (!grepl(pattern, name)) 
[10:25:48.388]                               next
[10:25:48.388]                             invokeRestart(restart)
[10:25:48.388]                             muffled <- TRUE
[10:25:48.388]                             break
[10:25:48.388]                           }
[10:25:48.388]                         }
[10:25:48.388]                       }
[10:25:48.388]                       invisible(muffled)
[10:25:48.388]                     }
[10:25:48.388]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.388]                   }
[10:25:48.388]                 }
[10:25:48.388]             }
[10:25:48.388]         }))
[10:25:48.388]     }, error = function(ex) {
[10:25:48.388]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.388]                 ...future.rng), started = ...future.startTime, 
[10:25:48.388]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.388]             version = "1.8"), class = "FutureResult")
[10:25:48.388]     }, finally = {
[10:25:48.388]         if (!identical(...future.workdir, getwd())) 
[10:25:48.388]             setwd(...future.workdir)
[10:25:48.388]         {
[10:25:48.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.388]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.388]             }
[10:25:48.388]             base::options(...future.oldOptions)
[10:25:48.388]             if (.Platform$OS.type == "windows") {
[10:25:48.388]                 old_names <- names(...future.oldEnvVars)
[10:25:48.388]                 envs <- base::Sys.getenv()
[10:25:48.388]                 names <- names(envs)
[10:25:48.388]                 common <- intersect(names, old_names)
[10:25:48.388]                 added <- setdiff(names, old_names)
[10:25:48.388]                 removed <- setdiff(old_names, names)
[10:25:48.388]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.388]                   envs[common]]
[10:25:48.388]                 NAMES <- toupper(changed)
[10:25:48.388]                 args <- list()
[10:25:48.388]                 for (kk in seq_along(NAMES)) {
[10:25:48.388]                   name <- changed[[kk]]
[10:25:48.388]                   NAME <- NAMES[[kk]]
[10:25:48.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.388]                     next
[10:25:48.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.388]                 }
[10:25:48.388]                 NAMES <- toupper(added)
[10:25:48.388]                 for (kk in seq_along(NAMES)) {
[10:25:48.388]                   name <- added[[kk]]
[10:25:48.388]                   NAME <- NAMES[[kk]]
[10:25:48.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.388]                     next
[10:25:48.388]                   args[[name]] <- ""
[10:25:48.388]                 }
[10:25:48.388]                 NAMES <- toupper(removed)
[10:25:48.388]                 for (kk in seq_along(NAMES)) {
[10:25:48.388]                   name <- removed[[kk]]
[10:25:48.388]                   NAME <- NAMES[[kk]]
[10:25:48.388]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.388]                     next
[10:25:48.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.388]                 }
[10:25:48.388]                 if (length(args) > 0) 
[10:25:48.388]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.388]             }
[10:25:48.388]             else {
[10:25:48.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.388]             }
[10:25:48.388]             {
[10:25:48.388]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.388]                   0L) {
[10:25:48.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.388]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.388]                   base::options(opts)
[10:25:48.388]                 }
[10:25:48.388]                 {
[10:25:48.388]                   {
[10:25:48.388]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.388]                     NULL
[10:25:48.388]                   }
[10:25:48.388]                   options(future.plan = NULL)
[10:25:48.388]                   if (is.na(NA_character_)) 
[10:25:48.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.388]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.388]                     envir = parent.frame()) 
[10:25:48.388]                   {
[10:25:48.388]                     default_workers <- missing(workers)
[10:25:48.388]                     if (is.function(workers)) 
[10:25:48.388]                       workers <- workers()
[10:25:48.388]                     workers <- structure(as.integer(workers), 
[10:25:48.388]                       class = class(workers))
[10:25:48.388]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.388]                       1L)
[10:25:48.388]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.388]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.388]                       if (default_workers) 
[10:25:48.388]                         supportsMulticore(warn = TRUE)
[10:25:48.388]                       return(sequential(..., envir = envir))
[10:25:48.388]                     }
[10:25:48.388]                     oopts <- options(mc.cores = workers)
[10:25:48.388]                     on.exit(options(oopts))
[10:25:48.388]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.388]                       envir = envir)
[10:25:48.388]                     if (!future$lazy) 
[10:25:48.388]                       future <- run(future)
[10:25:48.388]                     invisible(future)
[10:25:48.388]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.388]                 }
[10:25:48.388]             }
[10:25:48.388]         }
[10:25:48.388]     })
[10:25:48.388]     if (TRUE) {
[10:25:48.388]         base::sink(type = "output", split = FALSE)
[10:25:48.388]         if (TRUE) {
[10:25:48.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.388]         }
[10:25:48.388]         else {
[10:25:48.388]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.388]         }
[10:25:48.388]         base::close(...future.stdout)
[10:25:48.388]         ...future.stdout <- NULL
[10:25:48.388]     }
[10:25:48.388]     ...future.result$conditions <- ...future.conditions
[10:25:48.388]     ...future.result$finished <- base::Sys.time()
[10:25:48.388]     ...future.result
[10:25:48.388] }
[10:25:48.390] requestCore(): workers = 2
[10:25:48.392] MulticoreFuture started
[10:25:48.393] - Launch lazy future ... done
[10:25:48.393] run() for ‘MulticoreFuture’ ... done
[10:25:48.393] getGlobalsAndPackages() ...
[10:25:48.393] Searching for globals...
[10:25:48.394] plan(): Setting new future strategy stack:
[10:25:48.394] 
[10:25:48.394] Searching for globals ... DONE
[10:25:48.394] List of future strategies:
[10:25:48.394] 1. sequential:
[10:25:48.394]    - args: function (..., envir = parent.frame())
[10:25:48.394]    - tweaked: FALSE
[10:25:48.394]    - call: NULL
[10:25:48.394] - globals: [0] <none>
[10:25:48.395] plan(): nbrOfWorkers() = 1
[10:25:48.395] getGlobalsAndPackages() ... DONE
[10:25:48.395] run() for ‘Future’ ...
[10:25:48.395] - state: ‘created’
[10:25:48.396] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.396] plan(): Setting new future strategy stack:
[10:25:48.396] List of future strategies:
[10:25:48.396] 1. multicore:
[10:25:48.396]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.396]    - tweaked: FALSE
[10:25:48.396]    - call: plan(strategy)
[10:25:48.400] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.401] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.401]   - Field: ‘label’
[10:25:48.401]   - Field: ‘local’
[10:25:48.401]   - Field: ‘owner’
[10:25:48.401] plan(): nbrOfWorkers() = 2
[10:25:48.401]   - Field: ‘envir’
[10:25:48.401]   - Field: ‘workers’
[10:25:48.402]   - Field: ‘packages’
[10:25:48.402]   - Field: ‘gc’
[10:25:48.402]   - Field: ‘job’
[10:25:48.402]   - Field: ‘conditions’
[10:25:48.402]   - Field: ‘expr’
[10:25:48.402]   - Field: ‘uuid’
[10:25:48.402]   - Field: ‘seed’
[10:25:48.403]   - Field: ‘version’
[10:25:48.403]   - Field: ‘result’
[10:25:48.403]   - Field: ‘asynchronous’
[10:25:48.403]   - Field: ‘calls’
[10:25:48.403]   - Field: ‘globals’
[10:25:48.403]   - Field: ‘stdout’
[10:25:48.403]   - Field: ‘earlySignal’
[10:25:48.404]   - Field: ‘lazy’
[10:25:48.404]   - Field: ‘state’
[10:25:48.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.404] - Launch lazy future ...
[10:25:48.405] Packages needed by the future expression (n = 0): <none>
[10:25:48.405] Packages needed by future strategies (n = 0): <none>
[10:25:48.405] {
[10:25:48.405]     {
[10:25:48.405]         {
[10:25:48.405]             ...future.startTime <- base::Sys.time()
[10:25:48.405]             {
[10:25:48.405]                 {
[10:25:48.405]                   {
[10:25:48.405]                     {
[10:25:48.405]                       base::local({
[10:25:48.405]                         has_future <- base::requireNamespace("future", 
[10:25:48.405]                           quietly = TRUE)
[10:25:48.405]                         if (has_future) {
[10:25:48.405]                           ns <- base::getNamespace("future")
[10:25:48.405]                           version <- ns[[".package"]][["version"]]
[10:25:48.405]                           if (is.null(version)) 
[10:25:48.405]                             version <- utils::packageVersion("future")
[10:25:48.405]                         }
[10:25:48.405]                         else {
[10:25:48.405]                           version <- NULL
[10:25:48.405]                         }
[10:25:48.405]                         if (!has_future || version < "1.8.0") {
[10:25:48.405]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.405]                             "", base::R.version$version.string), 
[10:25:48.405]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.405]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.405]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.405]                               "release", "version")], collapse = " "), 
[10:25:48.405]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.405]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.405]                             info)
[10:25:48.405]                           info <- base::paste(info, collapse = "; ")
[10:25:48.405]                           if (!has_future) {
[10:25:48.405]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.405]                               info)
[10:25:48.405]                           }
[10:25:48.405]                           else {
[10:25:48.405]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.405]                               info, version)
[10:25:48.405]                           }
[10:25:48.405]                           base::stop(msg)
[10:25:48.405]                         }
[10:25:48.405]                       })
[10:25:48.405]                     }
[10:25:48.405]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.405]                     base::options(mc.cores = 1L)
[10:25:48.405]                   }
[10:25:48.405]                   options(future.plan = NULL)
[10:25:48.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.405]                 }
[10:25:48.405]                 ...future.workdir <- getwd()
[10:25:48.405]             }
[10:25:48.405]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.405]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.405]         }
[10:25:48.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.405]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.405]             base::names(...future.oldOptions))
[10:25:48.405]     }
[10:25:48.405]     if (FALSE) {
[10:25:48.405]     }
[10:25:48.405]     else {
[10:25:48.405]         if (TRUE) {
[10:25:48.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.405]                 open = "w")
[10:25:48.405]         }
[10:25:48.405]         else {
[10:25:48.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.405]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.405]         }
[10:25:48.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.405]             base::sink(type = "output", split = FALSE)
[10:25:48.405]             base::close(...future.stdout)
[10:25:48.405]         }, add = TRUE)
[10:25:48.405]     }
[10:25:48.405]     ...future.frame <- base::sys.nframe()
[10:25:48.405]     ...future.conditions <- base::list()
[10:25:48.405]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.405]     if (FALSE) {
[10:25:48.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.405]     }
[10:25:48.405]     ...future.result <- base::tryCatch({
[10:25:48.405]         base::withCallingHandlers({
[10:25:48.405]             ...future.value <- base::withVisible(base::local({
[10:25:48.405]                 withCallingHandlers({
[10:25:48.405]                   NULL
[10:25:48.405]                 }, immediateCondition = function(cond) {
[10:25:48.405]                   save_rds <- function (object, pathname, ...) 
[10:25:48.405]                   {
[10:25:48.405]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.405]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.405]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.405]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.405]                         fi_tmp[["mtime"]])
[10:25:48.405]                     }
[10:25:48.405]                     tryCatch({
[10:25:48.405]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.405]                     }, error = function(ex) {
[10:25:48.405]                       msg <- conditionMessage(ex)
[10:25:48.405]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.405]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.405]                         fi_tmp[["mtime"]], msg)
[10:25:48.405]                       ex$message <- msg
[10:25:48.405]                       stop(ex)
[10:25:48.405]                     })
[10:25:48.405]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.405]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.405]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.405]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.405]                       fi <- file.info(pathname)
[10:25:48.405]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.405]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.405]                         fi[["size"]], fi[["mtime"]])
[10:25:48.405]                       stop(msg)
[10:25:48.405]                     }
[10:25:48.405]                     invisible(pathname)
[10:25:48.405]                   }
[10:25:48.405]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.405]                     rootPath = tempdir()) 
[10:25:48.405]                   {
[10:25:48.405]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.405]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.405]                       tmpdir = path, fileext = ".rds")
[10:25:48.405]                     save_rds(obj, file)
[10:25:48.405]                   }
[10:25:48.405]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.405]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.405]                   {
[10:25:48.405]                     inherits <- base::inherits
[10:25:48.405]                     invokeRestart <- base::invokeRestart
[10:25:48.405]                     is.null <- base::is.null
[10:25:48.405]                     muffled <- FALSE
[10:25:48.405]                     if (inherits(cond, "message")) {
[10:25:48.405]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.405]                       if (muffled) 
[10:25:48.405]                         invokeRestart("muffleMessage")
[10:25:48.405]                     }
[10:25:48.405]                     else if (inherits(cond, "warning")) {
[10:25:48.405]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.405]                       if (muffled) 
[10:25:48.405]                         invokeRestart("muffleWarning")
[10:25:48.405]                     }
[10:25:48.405]                     else if (inherits(cond, "condition")) {
[10:25:48.405]                       if (!is.null(pattern)) {
[10:25:48.405]                         computeRestarts <- base::computeRestarts
[10:25:48.405]                         grepl <- base::grepl
[10:25:48.405]                         restarts <- computeRestarts(cond)
[10:25:48.405]                         for (restart in restarts) {
[10:25:48.405]                           name <- restart$name
[10:25:48.405]                           if (is.null(name)) 
[10:25:48.405]                             next
[10:25:48.405]                           if (!grepl(pattern, name)) 
[10:25:48.405]                             next
[10:25:48.405]                           invokeRestart(restart)
[10:25:48.405]                           muffled <- TRUE
[10:25:48.405]                           break
[10:25:48.405]                         }
[10:25:48.405]                       }
[10:25:48.405]                     }
[10:25:48.405]                     invisible(muffled)
[10:25:48.405]                   }
[10:25:48.405]                   muffleCondition(cond)
[10:25:48.405]                 })
[10:25:48.405]             }))
[10:25:48.405]             future::FutureResult(value = ...future.value$value, 
[10:25:48.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.405]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.405]                     ...future.globalenv.names))
[10:25:48.405]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.405]         }, condition = base::local({
[10:25:48.405]             c <- base::c
[10:25:48.405]             inherits <- base::inherits
[10:25:48.405]             invokeRestart <- base::invokeRestart
[10:25:48.405]             length <- base::length
[10:25:48.405]             list <- base::list
[10:25:48.405]             seq.int <- base::seq.int
[10:25:48.405]             signalCondition <- base::signalCondition
[10:25:48.405]             sys.calls <- base::sys.calls
[10:25:48.405]             `[[` <- base::`[[`
[10:25:48.405]             `+` <- base::`+`
[10:25:48.405]             `<<-` <- base::`<<-`
[10:25:48.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.405]                   3L)]
[10:25:48.405]             }
[10:25:48.405]             function(cond) {
[10:25:48.405]                 is_error <- inherits(cond, "error")
[10:25:48.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.405]                   NULL)
[10:25:48.405]                 if (is_error) {
[10:25:48.405]                   sessionInformation <- function() {
[10:25:48.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.405]                       search = base::search(), system = base::Sys.info())
[10:25:48.405]                   }
[10:25:48.405]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.405]                     cond$call), session = sessionInformation(), 
[10:25:48.405]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.405]                   signalCondition(cond)
[10:25:48.405]                 }
[10:25:48.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.405]                 "immediateCondition"))) {
[10:25:48.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.405]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.405]                   if (TRUE && !signal) {
[10:25:48.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.405]                     {
[10:25:48.405]                       inherits <- base::inherits
[10:25:48.405]                       invokeRestart <- base::invokeRestart
[10:25:48.405]                       is.null <- base::is.null
[10:25:48.405]                       muffled <- FALSE
[10:25:48.405]                       if (inherits(cond, "message")) {
[10:25:48.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.405]                         if (muffled) 
[10:25:48.405]                           invokeRestart("muffleMessage")
[10:25:48.405]                       }
[10:25:48.405]                       else if (inherits(cond, "warning")) {
[10:25:48.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.405]                         if (muffled) 
[10:25:48.405]                           invokeRestart("muffleWarning")
[10:25:48.405]                       }
[10:25:48.405]                       else if (inherits(cond, "condition")) {
[10:25:48.405]                         if (!is.null(pattern)) {
[10:25:48.405]                           computeRestarts <- base::computeRestarts
[10:25:48.405]                           grepl <- base::grepl
[10:25:48.405]                           restarts <- computeRestarts(cond)
[10:25:48.405]                           for (restart in restarts) {
[10:25:48.405]                             name <- restart$name
[10:25:48.405]                             if (is.null(name)) 
[10:25:48.405]                               next
[10:25:48.405]                             if (!grepl(pattern, name)) 
[10:25:48.405]                               next
[10:25:48.405]                             invokeRestart(restart)
[10:25:48.405]                             muffled <- TRUE
[10:25:48.405]                             break
[10:25:48.405]                           }
[10:25:48.405]                         }
[10:25:48.405]                       }
[10:25:48.405]                       invisible(muffled)
[10:25:48.405]                     }
[10:25:48.405]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.405]                   }
[10:25:48.405]                 }
[10:25:48.405]                 else {
[10:25:48.405]                   if (TRUE) {
[10:25:48.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.405]                     {
[10:25:48.405]                       inherits <- base::inherits
[10:25:48.405]                       invokeRestart <- base::invokeRestart
[10:25:48.405]                       is.null <- base::is.null
[10:25:48.405]                       muffled <- FALSE
[10:25:48.405]                       if (inherits(cond, "message")) {
[10:25:48.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.405]                         if (muffled) 
[10:25:48.405]                           invokeRestart("muffleMessage")
[10:25:48.405]                       }
[10:25:48.405]                       else if (inherits(cond, "warning")) {
[10:25:48.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.405]                         if (muffled) 
[10:25:48.405]                           invokeRestart("muffleWarning")
[10:25:48.405]                       }
[10:25:48.405]                       else if (inherits(cond, "condition")) {
[10:25:48.405]                         if (!is.null(pattern)) {
[10:25:48.405]                           computeRestarts <- base::computeRestarts
[10:25:48.405]                           grepl <- base::grepl
[10:25:48.405]                           restarts <- computeRestarts(cond)
[10:25:48.405]                           for (restart in restarts) {
[10:25:48.405]                             name <- restart$name
[10:25:48.405]                             if (is.null(name)) 
[10:25:48.405]                               next
[10:25:48.405]                             if (!grepl(pattern, name)) 
[10:25:48.405]                               next
[10:25:48.405]                             invokeRestart(restart)
[10:25:48.405]                             muffled <- TRUE
[10:25:48.405]                             break
[10:25:48.405]                           }
[10:25:48.405]                         }
[10:25:48.405]                       }
[10:25:48.405]                       invisible(muffled)
[10:25:48.405]                     }
[10:25:48.405]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.405]                   }
[10:25:48.405]                 }
[10:25:48.405]             }
[10:25:48.405]         }))
[10:25:48.405]     }, error = function(ex) {
[10:25:48.405]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.405]                 ...future.rng), started = ...future.startTime, 
[10:25:48.405]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.405]             version = "1.8"), class = "FutureResult")
[10:25:48.405]     }, finally = {
[10:25:48.405]         if (!identical(...future.workdir, getwd())) 
[10:25:48.405]             setwd(...future.workdir)
[10:25:48.405]         {
[10:25:48.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.405]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.405]             }
[10:25:48.405]             base::options(...future.oldOptions)
[10:25:48.405]             if (.Platform$OS.type == "windows") {
[10:25:48.405]                 old_names <- names(...future.oldEnvVars)
[10:25:48.405]                 envs <- base::Sys.getenv()
[10:25:48.405]                 names <- names(envs)
[10:25:48.405]                 common <- intersect(names, old_names)
[10:25:48.405]                 added <- setdiff(names, old_names)
[10:25:48.405]                 removed <- setdiff(old_names, names)
[10:25:48.405]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.405]                   envs[common]]
[10:25:48.405]                 NAMES <- toupper(changed)
[10:25:48.405]                 args <- list()
[10:25:48.405]                 for (kk in seq_along(NAMES)) {
[10:25:48.405]                   name <- changed[[kk]]
[10:25:48.405]                   NAME <- NAMES[[kk]]
[10:25:48.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.405]                     next
[10:25:48.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.405]                 }
[10:25:48.405]                 NAMES <- toupper(added)
[10:25:48.405]                 for (kk in seq_along(NAMES)) {
[10:25:48.405]                   name <- added[[kk]]
[10:25:48.405]                   NAME <- NAMES[[kk]]
[10:25:48.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.405]                     next
[10:25:48.405]                   args[[name]] <- ""
[10:25:48.405]                 }
[10:25:48.405]                 NAMES <- toupper(removed)
[10:25:48.405]                 for (kk in seq_along(NAMES)) {
[10:25:48.405]                   name <- removed[[kk]]
[10:25:48.405]                   NAME <- NAMES[[kk]]
[10:25:48.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.405]                     next
[10:25:48.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.405]                 }
[10:25:48.405]                 if (length(args) > 0) 
[10:25:48.405]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.405]             }
[10:25:48.405]             else {
[10:25:48.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.405]             }
[10:25:48.405]             {
[10:25:48.405]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.405]                   0L) {
[10:25:48.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.405]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.405]                   base::options(opts)
[10:25:48.405]                 }
[10:25:48.405]                 {
[10:25:48.405]                   {
[10:25:48.405]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.405]                     NULL
[10:25:48.405]                   }
[10:25:48.405]                   options(future.plan = NULL)
[10:25:48.405]                   if (is.na(NA_character_)) 
[10:25:48.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.405]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.405]                     envir = parent.frame()) 
[10:25:48.405]                   {
[10:25:48.405]                     default_workers <- missing(workers)
[10:25:48.405]                     if (is.function(workers)) 
[10:25:48.405]                       workers <- workers()
[10:25:48.405]                     workers <- structure(as.integer(workers), 
[10:25:48.405]                       class = class(workers))
[10:25:48.405]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.405]                       1L)
[10:25:48.405]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.405]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.405]                       if (default_workers) 
[10:25:48.405]                         supportsMulticore(warn = TRUE)
[10:25:48.405]                       return(sequential(..., envir = envir))
[10:25:48.405]                     }
[10:25:48.405]                     oopts <- options(mc.cores = workers)
[10:25:48.405]                     on.exit(options(oopts))
[10:25:48.405]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.405]                       envir = envir)
[10:25:48.405]                     if (!future$lazy) 
[10:25:48.405]                       future <- run(future)
[10:25:48.405]                     invisible(future)
[10:25:48.405]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.405]                 }
[10:25:48.405]             }
[10:25:48.405]         }
[10:25:48.405]     })
[10:25:48.405]     if (TRUE) {
[10:25:48.405]         base::sink(type = "output", split = FALSE)
[10:25:48.405]         if (TRUE) {
[10:25:48.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.405]         }
[10:25:48.405]         else {
[10:25:48.405]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.405]         }
[10:25:48.405]         base::close(...future.stdout)
[10:25:48.405]         ...future.stdout <- NULL
[10:25:48.405]     }
[10:25:48.405]     ...future.result$conditions <- ...future.conditions
[10:25:48.405]     ...future.result$finished <- base::Sys.time()
[10:25:48.405]     ...future.result
[10:25:48.405] }
[10:25:48.409] requestCore(): workers = 2
[10:25:48.412] MulticoreFuture started
[10:25:48.412] - Launch lazy future ... done
[10:25:48.412] run() for ‘MulticoreFuture’ ... done
[10:25:48.413] plan(): Setting new future strategy stack:
[10:25:48.413] getGlobalsAndPackages() ...
[10:25:48.413] Searching for globals...
[10:25:48.413] List of future strategies:
[10:25:48.413] 1. sequential:
[10:25:48.413]    - args: function (..., envir = parent.frame())
[10:25:48.413]    - tweaked: FALSE
[10:25:48.413]    - call: NULL
[10:25:48.414] plan(): nbrOfWorkers() = 1
[10:25:48.414] - globals found: [1] ‘{’
[10:25:48.415] Searching for globals ... DONE
[10:25:48.415] Resolving globals: FALSE
[10:25:48.415] 
[10:25:48.415] 
[10:25:48.416] getGlobalsAndPackages() ... DONE
[10:25:48.416] plan(): Setting new future strategy stack:
[10:25:48.416] run() for ‘Future’ ...
[10:25:48.416] - state: ‘created’
[10:25:48.416] List of future strategies:
[10:25:48.416] 1. multicore:
[10:25:48.416]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.416]    - tweaked: FALSE
[10:25:48.416]    - call: plan(strategy)
[10:25:48.416] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.421] plan(): nbrOfWorkers() = 2
[10:25:48.422] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.422]   - Field: ‘label’
[10:25:48.422]   - Field: ‘local’
[10:25:48.423]   - Field: ‘owner’
[10:25:48.423]   - Field: ‘envir’
[10:25:48.423]   - Field: ‘workers’
[10:25:48.423]   - Field: ‘packages’
[10:25:48.423]   - Field: ‘gc’
[10:25:48.423]   - Field: ‘job’
[10:25:48.423]   - Field: ‘conditions’
[10:25:48.424]   - Field: ‘expr’
[10:25:48.424]   - Field: ‘uuid’
[10:25:48.424]   - Field: ‘seed’
[10:25:48.424]   - Field: ‘version’
[10:25:48.424]   - Field: ‘result’
[10:25:48.424]   - Field: ‘asynchronous’
[10:25:48.425]   - Field: ‘calls’
[10:25:48.425]   - Field: ‘globals’
[10:25:48.425]   - Field: ‘stdout’
[10:25:48.425]   - Field: ‘earlySignal’
[10:25:48.425]   - Field: ‘lazy’
[10:25:48.425]   - Field: ‘state’
[10:25:48.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.426] - Launch lazy future ...
[10:25:48.426] Packages needed by the future expression (n = 0): <none>
[10:25:48.426] Packages needed by future strategies (n = 0): <none>
[10:25:48.427] {
[10:25:48.427]     {
[10:25:48.427]         {
[10:25:48.427]             ...future.startTime <- base::Sys.time()
[10:25:48.427]             {
[10:25:48.427]                 {
[10:25:48.427]                   {
[10:25:48.427]                     {
[10:25:48.427]                       base::local({
[10:25:48.427]                         has_future <- base::requireNamespace("future", 
[10:25:48.427]                           quietly = TRUE)
[10:25:48.427]                         if (has_future) {
[10:25:48.427]                           ns <- base::getNamespace("future")
[10:25:48.427]                           version <- ns[[".package"]][["version"]]
[10:25:48.427]                           if (is.null(version)) 
[10:25:48.427]                             version <- utils::packageVersion("future")
[10:25:48.427]                         }
[10:25:48.427]                         else {
[10:25:48.427]                           version <- NULL
[10:25:48.427]                         }
[10:25:48.427]                         if (!has_future || version < "1.8.0") {
[10:25:48.427]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.427]                             "", base::R.version$version.string), 
[10:25:48.427]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.427]                               "release", "version")], collapse = " "), 
[10:25:48.427]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.427]                             info)
[10:25:48.427]                           info <- base::paste(info, collapse = "; ")
[10:25:48.427]                           if (!has_future) {
[10:25:48.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.427]                               info)
[10:25:48.427]                           }
[10:25:48.427]                           else {
[10:25:48.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.427]                               info, version)
[10:25:48.427]                           }
[10:25:48.427]                           base::stop(msg)
[10:25:48.427]                         }
[10:25:48.427]                       })
[10:25:48.427]                     }
[10:25:48.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.427]                     base::options(mc.cores = 1L)
[10:25:48.427]                   }
[10:25:48.427]                   options(future.plan = NULL)
[10:25:48.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.427]                 }
[10:25:48.427]                 ...future.workdir <- getwd()
[10:25:48.427]             }
[10:25:48.427]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.427]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.427]         }
[10:25:48.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.427]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.427]             base::names(...future.oldOptions))
[10:25:48.427]     }
[10:25:48.427]     if (FALSE) {
[10:25:48.427]     }
[10:25:48.427]     else {
[10:25:48.427]         if (TRUE) {
[10:25:48.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.427]                 open = "w")
[10:25:48.427]         }
[10:25:48.427]         else {
[10:25:48.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.427]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.427]         }
[10:25:48.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.427]             base::sink(type = "output", split = FALSE)
[10:25:48.427]             base::close(...future.stdout)
[10:25:48.427]         }, add = TRUE)
[10:25:48.427]     }
[10:25:48.427]     ...future.frame <- base::sys.nframe()
[10:25:48.427]     ...future.conditions <- base::list()
[10:25:48.427]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.427]     if (FALSE) {
[10:25:48.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.427]     }
[10:25:48.427]     ...future.result <- base::tryCatch({
[10:25:48.427]         base::withCallingHandlers({
[10:25:48.427]             ...future.value <- base::withVisible(base::local({
[10:25:48.427]                 withCallingHandlers({
[10:25:48.427]                   {
[10:25:48.427]                     4
[10:25:48.427]                   }
[10:25:48.427]                 }, immediateCondition = function(cond) {
[10:25:48.427]                   save_rds <- function (object, pathname, ...) 
[10:25:48.427]                   {
[10:25:48.427]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.427]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.427]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.427]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.427]                         fi_tmp[["mtime"]])
[10:25:48.427]                     }
[10:25:48.427]                     tryCatch({
[10:25:48.427]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.427]                     }, error = function(ex) {
[10:25:48.427]                       msg <- conditionMessage(ex)
[10:25:48.427]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.427]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.427]                         fi_tmp[["mtime"]], msg)
[10:25:48.427]                       ex$message <- msg
[10:25:48.427]                       stop(ex)
[10:25:48.427]                     })
[10:25:48.427]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.427]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.427]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.427]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.427]                       fi <- file.info(pathname)
[10:25:48.427]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.427]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.427]                         fi[["size"]], fi[["mtime"]])
[10:25:48.427]                       stop(msg)
[10:25:48.427]                     }
[10:25:48.427]                     invisible(pathname)
[10:25:48.427]                   }
[10:25:48.427]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.427]                     rootPath = tempdir()) 
[10:25:48.427]                   {
[10:25:48.427]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.427]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.427]                       tmpdir = path, fileext = ".rds")
[10:25:48.427]                     save_rds(obj, file)
[10:25:48.427]                   }
[10:25:48.427]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.427]                   {
[10:25:48.427]                     inherits <- base::inherits
[10:25:48.427]                     invokeRestart <- base::invokeRestart
[10:25:48.427]                     is.null <- base::is.null
[10:25:48.427]                     muffled <- FALSE
[10:25:48.427]                     if (inherits(cond, "message")) {
[10:25:48.427]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.427]                       if (muffled) 
[10:25:48.427]                         invokeRestart("muffleMessage")
[10:25:48.427]                     }
[10:25:48.427]                     else if (inherits(cond, "warning")) {
[10:25:48.427]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.427]                       if (muffled) 
[10:25:48.427]                         invokeRestart("muffleWarning")
[10:25:48.427]                     }
[10:25:48.427]                     else if (inherits(cond, "condition")) {
[10:25:48.427]                       if (!is.null(pattern)) {
[10:25:48.427]                         computeRestarts <- base::computeRestarts
[10:25:48.427]                         grepl <- base::grepl
[10:25:48.427]                         restarts <- computeRestarts(cond)
[10:25:48.427]                         for (restart in restarts) {
[10:25:48.427]                           name <- restart$name
[10:25:48.427]                           if (is.null(name)) 
[10:25:48.427]                             next
[10:25:48.427]                           if (!grepl(pattern, name)) 
[10:25:48.427]                             next
[10:25:48.427]                           invokeRestart(restart)
[10:25:48.427]                           muffled <- TRUE
[10:25:48.427]                           break
[10:25:48.427]                         }
[10:25:48.427]                       }
[10:25:48.427]                     }
[10:25:48.427]                     invisible(muffled)
[10:25:48.427]                   }
[10:25:48.427]                   muffleCondition(cond)
[10:25:48.427]                 })
[10:25:48.427]             }))
[10:25:48.427]             future::FutureResult(value = ...future.value$value, 
[10:25:48.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.427]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.427]                     ...future.globalenv.names))
[10:25:48.427]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.427]         }, condition = base::local({
[10:25:48.427]             c <- base::c
[10:25:48.427]             inherits <- base::inherits
[10:25:48.427]             invokeRestart <- base::invokeRestart
[10:25:48.427]             length <- base::length
[10:25:48.427]             list <- base::list
[10:25:48.427]             seq.int <- base::seq.int
[10:25:48.427]             signalCondition <- base::signalCondition
[10:25:48.427]             sys.calls <- base::sys.calls
[10:25:48.427]             `[[` <- base::`[[`
[10:25:48.427]             `+` <- base::`+`
[10:25:48.427]             `<<-` <- base::`<<-`
[10:25:48.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.427]                   3L)]
[10:25:48.427]             }
[10:25:48.427]             function(cond) {
[10:25:48.427]                 is_error <- inherits(cond, "error")
[10:25:48.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.427]                   NULL)
[10:25:48.427]                 if (is_error) {
[10:25:48.427]                   sessionInformation <- function() {
[10:25:48.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.427]                       search = base::search(), system = base::Sys.info())
[10:25:48.427]                   }
[10:25:48.427]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.427]                     cond$call), session = sessionInformation(), 
[10:25:48.427]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.427]                   signalCondition(cond)
[10:25:48.427]                 }
[10:25:48.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.427]                 "immediateCondition"))) {
[10:25:48.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.427]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.427]                   if (TRUE && !signal) {
[10:25:48.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.427]                     {
[10:25:48.427]                       inherits <- base::inherits
[10:25:48.427]                       invokeRestart <- base::invokeRestart
[10:25:48.427]                       is.null <- base::is.null
[10:25:48.427]                       muffled <- FALSE
[10:25:48.427]                       if (inherits(cond, "message")) {
[10:25:48.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.427]                         if (muffled) 
[10:25:48.427]                           invokeRestart("muffleMessage")
[10:25:48.427]                       }
[10:25:48.427]                       else if (inherits(cond, "warning")) {
[10:25:48.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.427]                         if (muffled) 
[10:25:48.427]                           invokeRestart("muffleWarning")
[10:25:48.427]                       }
[10:25:48.427]                       else if (inherits(cond, "condition")) {
[10:25:48.427]                         if (!is.null(pattern)) {
[10:25:48.427]                           computeRestarts <- base::computeRestarts
[10:25:48.427]                           grepl <- base::grepl
[10:25:48.427]                           restarts <- computeRestarts(cond)
[10:25:48.427]                           for (restart in restarts) {
[10:25:48.427]                             name <- restart$name
[10:25:48.427]                             if (is.null(name)) 
[10:25:48.427]                               next
[10:25:48.427]                             if (!grepl(pattern, name)) 
[10:25:48.427]                               next
[10:25:48.427]                             invokeRestart(restart)
[10:25:48.427]                             muffled <- TRUE
[10:25:48.427]                             break
[10:25:48.427]                           }
[10:25:48.427]                         }
[10:25:48.427]                       }
[10:25:48.427]                       invisible(muffled)
[10:25:48.427]                     }
[10:25:48.427]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.427]                   }
[10:25:48.427]                 }
[10:25:48.427]                 else {
[10:25:48.427]                   if (TRUE) {
[10:25:48.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.427]                     {
[10:25:48.427]                       inherits <- base::inherits
[10:25:48.427]                       invokeRestart <- base::invokeRestart
[10:25:48.427]                       is.null <- base::is.null
[10:25:48.427]                       muffled <- FALSE
[10:25:48.427]                       if (inherits(cond, "message")) {
[10:25:48.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.427]                         if (muffled) 
[10:25:48.427]                           invokeRestart("muffleMessage")
[10:25:48.427]                       }
[10:25:48.427]                       else if (inherits(cond, "warning")) {
[10:25:48.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.427]                         if (muffled) 
[10:25:48.427]                           invokeRestart("muffleWarning")
[10:25:48.427]                       }
[10:25:48.427]                       else if (inherits(cond, "condition")) {
[10:25:48.427]                         if (!is.null(pattern)) {
[10:25:48.427]                           computeRestarts <- base::computeRestarts
[10:25:48.427]                           grepl <- base::grepl
[10:25:48.427]                           restarts <- computeRestarts(cond)
[10:25:48.427]                           for (restart in restarts) {
[10:25:48.427]                             name <- restart$name
[10:25:48.427]                             if (is.null(name)) 
[10:25:48.427]                               next
[10:25:48.427]                             if (!grepl(pattern, name)) 
[10:25:48.427]                               next
[10:25:48.427]                             invokeRestart(restart)
[10:25:48.427]                             muffled <- TRUE
[10:25:48.427]                             break
[10:25:48.427]                           }
[10:25:48.427]                         }
[10:25:48.427]                       }
[10:25:48.427]                       invisible(muffled)
[10:25:48.427]                     }
[10:25:48.427]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.427]                   }
[10:25:48.427]                 }
[10:25:48.427]             }
[10:25:48.427]         }))
[10:25:48.427]     }, error = function(ex) {
[10:25:48.427]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.427]                 ...future.rng), started = ...future.startTime, 
[10:25:48.427]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.427]             version = "1.8"), class = "FutureResult")
[10:25:48.427]     }, finally = {
[10:25:48.427]         if (!identical(...future.workdir, getwd())) 
[10:25:48.427]             setwd(...future.workdir)
[10:25:48.427]         {
[10:25:48.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.427]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.427]             }
[10:25:48.427]             base::options(...future.oldOptions)
[10:25:48.427]             if (.Platform$OS.type == "windows") {
[10:25:48.427]                 old_names <- names(...future.oldEnvVars)
[10:25:48.427]                 envs <- base::Sys.getenv()
[10:25:48.427]                 names <- names(envs)
[10:25:48.427]                 common <- intersect(names, old_names)
[10:25:48.427]                 added <- setdiff(names, old_names)
[10:25:48.427]                 removed <- setdiff(old_names, names)
[10:25:48.427]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.427]                   envs[common]]
[10:25:48.427]                 NAMES <- toupper(changed)
[10:25:48.427]                 args <- list()
[10:25:48.427]                 for (kk in seq_along(NAMES)) {
[10:25:48.427]                   name <- changed[[kk]]
[10:25:48.427]                   NAME <- NAMES[[kk]]
[10:25:48.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.427]                     next
[10:25:48.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.427]                 }
[10:25:48.427]                 NAMES <- toupper(added)
[10:25:48.427]                 for (kk in seq_along(NAMES)) {
[10:25:48.427]                   name <- added[[kk]]
[10:25:48.427]                   NAME <- NAMES[[kk]]
[10:25:48.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.427]                     next
[10:25:48.427]                   args[[name]] <- ""
[10:25:48.427]                 }
[10:25:48.427]                 NAMES <- toupper(removed)
[10:25:48.427]                 for (kk in seq_along(NAMES)) {
[10:25:48.427]                   name <- removed[[kk]]
[10:25:48.427]                   NAME <- NAMES[[kk]]
[10:25:48.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.427]                     next
[10:25:48.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.427]                 }
[10:25:48.427]                 if (length(args) > 0) 
[10:25:48.427]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.427]             }
[10:25:48.427]             else {
[10:25:48.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.427]             }
[10:25:48.427]             {
[10:25:48.427]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.427]                   0L) {
[10:25:48.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.427]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.427]                   base::options(opts)
[10:25:48.427]                 }
[10:25:48.427]                 {
[10:25:48.427]                   {
[10:25:48.427]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.427]                     NULL
[10:25:48.427]                   }
[10:25:48.427]                   options(future.plan = NULL)
[10:25:48.427]                   if (is.na(NA_character_)) 
[10:25:48.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.427]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.427]                     envir = parent.frame()) 
[10:25:48.427]                   {
[10:25:48.427]                     default_workers <- missing(workers)
[10:25:48.427]                     if (is.function(workers)) 
[10:25:48.427]                       workers <- workers()
[10:25:48.427]                     workers <- structure(as.integer(workers), 
[10:25:48.427]                       class = class(workers))
[10:25:48.427]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.427]                       1L)
[10:25:48.427]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.427]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.427]                       if (default_workers) 
[10:25:48.427]                         supportsMulticore(warn = TRUE)
[10:25:48.427]                       return(sequential(..., envir = envir))
[10:25:48.427]                     }
[10:25:48.427]                     oopts <- options(mc.cores = workers)
[10:25:48.427]                     on.exit(options(oopts))
[10:25:48.427]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.427]                       envir = envir)
[10:25:48.427]                     if (!future$lazy) 
[10:25:48.427]                       future <- run(future)
[10:25:48.427]                     invisible(future)
[10:25:48.427]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.427]                 }
[10:25:48.427]             }
[10:25:48.427]         }
[10:25:48.427]     })
[10:25:48.427]     if (TRUE) {
[10:25:48.427]         base::sink(type = "output", split = FALSE)
[10:25:48.427]         if (TRUE) {
[10:25:48.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.427]         }
[10:25:48.427]         else {
[10:25:48.427]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.427]         }
[10:25:48.427]         base::close(...future.stdout)
[10:25:48.427]         ...future.stdout <- NULL
[10:25:48.427]     }
[10:25:48.427]     ...future.result$conditions <- ...future.conditions
[10:25:48.427]     ...future.result$finished <- base::Sys.time()
[10:25:48.427]     ...future.result
[10:25:48.427] }
[10:25:48.431] requestCore(): workers = 2
[10:25:48.431] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:48.442] result() for MulticoreFuture ...
[10:25:48.443] result() for MulticoreFuture ...
[10:25:48.443] result() for MulticoreFuture ... done
[10:25:48.443] result() for MulticoreFuture ... done
[10:25:48.443] result() for MulticoreFuture ...
[10:25:48.443] result() for MulticoreFuture ... done
[10:25:48.446] MulticoreFuture started
[10:25:48.446] - Launch lazy future ... done
[10:25:48.447] run() for ‘MulticoreFuture’ ... done
[10:25:48.447] plan(): Setting new future strategy stack:
<environment: 0x55c0f7282598> 
[10:25:48.448] List of future strategies:
[10:25:48.448] 1. sequential:
[10:25:48.448]    - args: function (..., envir = parent.frame())
[10:25:48.448]    - tweaked: FALSE
[10:25:48.448]    - call: NULL
[10:25:48.449] plan(): nbrOfWorkers() = 1
<environment: 0x55c0f3cae490> 
[10:25:48.452] plan(): Setting new future strategy stack:
[10:25:48.452] List of future strategies:
[10:25:48.452] 1. multicore:
[10:25:48.452]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.452]    - tweaked: FALSE
[10:25:48.452]    - call: plan(strategy)
[10:25:48.457] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:48.459] resolve() on environment ...
[10:25:48.460]  recursive: 0
[10:25:48.461]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:48.461] signalConditionsASAP(numeric, pos=1) ...
[10:25:48.461] - nx: 4
[10:25:48.461] - relay: TRUE
[10:25:48.461] - stdout: TRUE
[10:25:48.461] - signal: TRUE
[10:25:48.462] - resignal: FALSE
[10:25:48.462] - force: TRUE
[10:25:48.462] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.462] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.462]  - until=2
[10:25:48.462]  - relaying element #2
[10:25:48.463] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.463] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.463] signalConditionsASAP(NULL, pos=1) ... done
[10:25:48.463]  length: 3 (resolved future 1)
[10:25:48.463] Future #2
[10:25:48.463] result() for MulticoreFuture ...
[10:25:48.464] result() for MulticoreFuture ... done
[10:25:48.464] result() for MulticoreFuture ...
[10:25:48.464] result() for MulticoreFuture ... done
[10:25:48.464] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:48.464] - nx: 4
[10:25:48.464] - relay: TRUE
[10:25:48.465] - stdout: TRUE
[10:25:48.465] - signal: TRUE
[10:25:48.465] - resignal: FALSE
[10:25:48.465] - force: TRUE
[10:25:48.465] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.465] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.465]  - until=2
[10:25:48.465]  - relaying element #2
[10:25:48.466] result() for MulticoreFuture ...
[10:25:48.466] result() for MulticoreFuture ... done
[10:25:48.466] result() for MulticoreFuture ...
[10:25:48.466] result() for MulticoreFuture ... done
[10:25:48.466] result() for MulticoreFuture ...
[10:25:48.466] result() for MulticoreFuture ... done
[10:25:48.467] result() for MulticoreFuture ...
[10:25:48.467] result() for MulticoreFuture ... done
[10:25:48.467] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.467] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.467] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:48.467]  length: 2 (resolved future 2)
[10:25:48.468] Future #3
[10:25:48.468] result() for MulticoreFuture ...
[10:25:48.469] result() for MulticoreFuture ...
[10:25:48.469] result() for MulticoreFuture ... done
[10:25:48.469] result() for MulticoreFuture ... done
[10:25:48.469] result() for MulticoreFuture ...
[10:25:48.470] result() for MulticoreFuture ... done
[10:25:48.470] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:48.470] - nx: 4
[10:25:48.470] - relay: TRUE
[10:25:48.470] - stdout: TRUE
[10:25:48.471] - signal: TRUE
[10:25:48.471] - resignal: FALSE
[10:25:48.471] - force: TRUE
[10:25:48.471] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.471] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.471]  - until=3
[10:25:48.472]  - relaying element #3
[10:25:48.472] result() for MulticoreFuture ...
[10:25:48.472] result() for MulticoreFuture ... done
[10:25:48.472] result() for MulticoreFuture ...
[10:25:48.472] result() for MulticoreFuture ... done
[10:25:48.473] result() for MulticoreFuture ...
[10:25:48.473] result() for MulticoreFuture ... done
[10:25:48.473] result() for MulticoreFuture ...
[10:25:48.473] result() for MulticoreFuture ... done
[10:25:48.473] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.474] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.474] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:48.474]  length: 1 (resolved future 3)
[10:25:48.474] Future #4
[10:25:48.475] result() for MulticoreFuture ...
[10:25:48.475] result() for MulticoreFuture ...
[10:25:48.475] result() for MulticoreFuture ... done
[10:25:48.476] result() for MulticoreFuture ... done
[10:25:48.476] result() for MulticoreFuture ...
[10:25:48.476] result() for MulticoreFuture ... done
[10:25:48.476] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:48.476] - nx: 4
[10:25:48.477] - relay: TRUE
[10:25:48.477] - stdout: TRUE
[10:25:48.477] - signal: TRUE
[10:25:48.477] - resignal: FALSE
[10:25:48.477] - force: TRUE
[10:25:48.477] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.477] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.478]  - until=4
[10:25:48.478]  - relaying element #4
[10:25:48.478] result() for MulticoreFuture ...
[10:25:48.478] result() for MulticoreFuture ... done
[10:25:48.478] result() for MulticoreFuture ...
[10:25:48.478] result() for MulticoreFuture ... done
[10:25:48.479] result() for MulticoreFuture ...
[10:25:48.479] result() for MulticoreFuture ... done
[10:25:48.479] result() for MulticoreFuture ...
[10:25:48.479] result() for MulticoreFuture ... done
[10:25:48.479] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.479] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.479] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:48.479]  length: 0 (resolved future 4)
[10:25:48.480] Relaying remaining futures
[10:25:48.480] signalConditionsASAP(NULL, pos=0) ...
[10:25:48.480] - nx: 4
[10:25:48.480] - relay: TRUE
[10:25:48.480] - stdout: TRUE
[10:25:48.480] - signal: TRUE
[10:25:48.480] - resignal: FALSE
[10:25:48.480] - force: TRUE
[10:25:48.480] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.480] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:48.481] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.481] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.481] signalConditionsASAP(NULL, pos=0) ... done
[10:25:48.481] resolve() on environment ... DONE
[10:25:48.481] result() for MulticoreFuture ...
[10:25:48.481] result() for MulticoreFuture ... done
[10:25:48.481] result() for MulticoreFuture ...
[10:25:48.481] result() for MulticoreFuture ... done
[10:25:48.482] result() for MulticoreFuture ...
[10:25:48.482] result() for MulticoreFuture ... done
[10:25:48.482] result() for MulticoreFuture ...
[10:25:48.482] result() for MulticoreFuture ... done
[10:25:48.482] result() for MulticoreFuture ...
[10:25:48.482] result() for MulticoreFuture ... done
[10:25:48.482] result() for MulticoreFuture ...
[10:25:48.482] result() for MulticoreFuture ... done
<environment: 0x55c0f4626a28> 
Dimensions: c(2, 3, 1)
[10:25:48.483] getGlobalsAndPackages() ...
[10:25:48.483] Searching for globals...
[10:25:48.483] 
[10:25:48.483] Searching for globals ... DONE
[10:25:48.484] - globals: [0] <none>
[10:25:48.484] getGlobalsAndPackages() ... DONE
[10:25:48.484] run() for ‘Future’ ...
[10:25:48.484] - state: ‘created’
[10:25:48.484] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.488] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.488] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.488]   - Field: ‘label’
[10:25:48.489]   - Field: ‘local’
[10:25:48.489]   - Field: ‘owner’
[10:25:48.489]   - Field: ‘envir’
[10:25:48.489]   - Field: ‘workers’
[10:25:48.489]   - Field: ‘packages’
[10:25:48.489]   - Field: ‘gc’
[10:25:48.489]   - Field: ‘job’
[10:25:48.489]   - Field: ‘conditions’
[10:25:48.490]   - Field: ‘expr’
[10:25:48.490]   - Field: ‘uuid’
[10:25:48.490]   - Field: ‘seed’
[10:25:48.490]   - Field: ‘version’
[10:25:48.490]   - Field: ‘result’
[10:25:48.490]   - Field: ‘asynchronous’
[10:25:48.490]   - Field: ‘calls’
[10:25:48.490]   - Field: ‘globals’
[10:25:48.490]   - Field: ‘stdout’
[10:25:48.491]   - Field: ‘earlySignal’
[10:25:48.491]   - Field: ‘lazy’
[10:25:48.491]   - Field: ‘state’
[10:25:48.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.491] - Launch lazy future ...
[10:25:48.491] Packages needed by the future expression (n = 0): <none>
[10:25:48.492] Packages needed by future strategies (n = 0): <none>
[10:25:48.492] {
[10:25:48.492]     {
[10:25:48.492]         {
[10:25:48.492]             ...future.startTime <- base::Sys.time()
[10:25:48.492]             {
[10:25:48.492]                 {
[10:25:48.492]                   {
[10:25:48.492]                     {
[10:25:48.492]                       base::local({
[10:25:48.492]                         has_future <- base::requireNamespace("future", 
[10:25:48.492]                           quietly = TRUE)
[10:25:48.492]                         if (has_future) {
[10:25:48.492]                           ns <- base::getNamespace("future")
[10:25:48.492]                           version <- ns[[".package"]][["version"]]
[10:25:48.492]                           if (is.null(version)) 
[10:25:48.492]                             version <- utils::packageVersion("future")
[10:25:48.492]                         }
[10:25:48.492]                         else {
[10:25:48.492]                           version <- NULL
[10:25:48.492]                         }
[10:25:48.492]                         if (!has_future || version < "1.8.0") {
[10:25:48.492]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.492]                             "", base::R.version$version.string), 
[10:25:48.492]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.492]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.492]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.492]                               "release", "version")], collapse = " "), 
[10:25:48.492]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.492]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.492]                             info)
[10:25:48.492]                           info <- base::paste(info, collapse = "; ")
[10:25:48.492]                           if (!has_future) {
[10:25:48.492]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.492]                               info)
[10:25:48.492]                           }
[10:25:48.492]                           else {
[10:25:48.492]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.492]                               info, version)
[10:25:48.492]                           }
[10:25:48.492]                           base::stop(msg)
[10:25:48.492]                         }
[10:25:48.492]                       })
[10:25:48.492]                     }
[10:25:48.492]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.492]                     base::options(mc.cores = 1L)
[10:25:48.492]                   }
[10:25:48.492]                   options(future.plan = NULL)
[10:25:48.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.492]                 }
[10:25:48.492]                 ...future.workdir <- getwd()
[10:25:48.492]             }
[10:25:48.492]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.492]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.492]         }
[10:25:48.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.492]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.492]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.492]             base::names(...future.oldOptions))
[10:25:48.492]     }
[10:25:48.492]     if (FALSE) {
[10:25:48.492]     }
[10:25:48.492]     else {
[10:25:48.492]         if (TRUE) {
[10:25:48.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.492]                 open = "w")
[10:25:48.492]         }
[10:25:48.492]         else {
[10:25:48.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.492]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.492]         }
[10:25:48.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.492]             base::sink(type = "output", split = FALSE)
[10:25:48.492]             base::close(...future.stdout)
[10:25:48.492]         }, add = TRUE)
[10:25:48.492]     }
[10:25:48.492]     ...future.frame <- base::sys.nframe()
[10:25:48.492]     ...future.conditions <- base::list()
[10:25:48.492]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.492]     if (FALSE) {
[10:25:48.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.492]     }
[10:25:48.492]     ...future.result <- base::tryCatch({
[10:25:48.492]         base::withCallingHandlers({
[10:25:48.492]             ...future.value <- base::withVisible(base::local({
[10:25:48.492]                 withCallingHandlers({
[10:25:48.492]                   2
[10:25:48.492]                 }, immediateCondition = function(cond) {
[10:25:48.492]                   save_rds <- function (object, pathname, ...) 
[10:25:48.492]                   {
[10:25:48.492]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.492]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.492]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.492]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.492]                         fi_tmp[["mtime"]])
[10:25:48.492]                     }
[10:25:48.492]                     tryCatch({
[10:25:48.492]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.492]                     }, error = function(ex) {
[10:25:48.492]                       msg <- conditionMessage(ex)
[10:25:48.492]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.492]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.492]                         fi_tmp[["mtime"]], msg)
[10:25:48.492]                       ex$message <- msg
[10:25:48.492]                       stop(ex)
[10:25:48.492]                     })
[10:25:48.492]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.492]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.492]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.492]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.492]                       fi <- file.info(pathname)
[10:25:48.492]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.492]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.492]                         fi[["size"]], fi[["mtime"]])
[10:25:48.492]                       stop(msg)
[10:25:48.492]                     }
[10:25:48.492]                     invisible(pathname)
[10:25:48.492]                   }
[10:25:48.492]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.492]                     rootPath = tempdir()) 
[10:25:48.492]                   {
[10:25:48.492]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.492]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.492]                       tmpdir = path, fileext = ".rds")
[10:25:48.492]                     save_rds(obj, file)
[10:25:48.492]                   }
[10:25:48.492]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.492]                   {
[10:25:48.492]                     inherits <- base::inherits
[10:25:48.492]                     invokeRestart <- base::invokeRestart
[10:25:48.492]                     is.null <- base::is.null
[10:25:48.492]                     muffled <- FALSE
[10:25:48.492]                     if (inherits(cond, "message")) {
[10:25:48.492]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.492]                       if (muffled) 
[10:25:48.492]                         invokeRestart("muffleMessage")
[10:25:48.492]                     }
[10:25:48.492]                     else if (inherits(cond, "warning")) {
[10:25:48.492]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.492]                       if (muffled) 
[10:25:48.492]                         invokeRestart("muffleWarning")
[10:25:48.492]                     }
[10:25:48.492]                     else if (inherits(cond, "condition")) {
[10:25:48.492]                       if (!is.null(pattern)) {
[10:25:48.492]                         computeRestarts <- base::computeRestarts
[10:25:48.492]                         grepl <- base::grepl
[10:25:48.492]                         restarts <- computeRestarts(cond)
[10:25:48.492]                         for (restart in restarts) {
[10:25:48.492]                           name <- restart$name
[10:25:48.492]                           if (is.null(name)) 
[10:25:48.492]                             next
[10:25:48.492]                           if (!grepl(pattern, name)) 
[10:25:48.492]                             next
[10:25:48.492]                           invokeRestart(restart)
[10:25:48.492]                           muffled <- TRUE
[10:25:48.492]                           break
[10:25:48.492]                         }
[10:25:48.492]                       }
[10:25:48.492]                     }
[10:25:48.492]                     invisible(muffled)
[10:25:48.492]                   }
[10:25:48.492]                   muffleCondition(cond)
[10:25:48.492]                 })
[10:25:48.492]             }))
[10:25:48.492]             future::FutureResult(value = ...future.value$value, 
[10:25:48.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.492]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.492]                     ...future.globalenv.names))
[10:25:48.492]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.492]         }, condition = base::local({
[10:25:48.492]             c <- base::c
[10:25:48.492]             inherits <- base::inherits
[10:25:48.492]             invokeRestart <- base::invokeRestart
[10:25:48.492]             length <- base::length
[10:25:48.492]             list <- base::list
[10:25:48.492]             seq.int <- base::seq.int
[10:25:48.492]             signalCondition <- base::signalCondition
[10:25:48.492]             sys.calls <- base::sys.calls
[10:25:48.492]             `[[` <- base::`[[`
[10:25:48.492]             `+` <- base::`+`
[10:25:48.492]             `<<-` <- base::`<<-`
[10:25:48.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.492]                   3L)]
[10:25:48.492]             }
[10:25:48.492]             function(cond) {
[10:25:48.492]                 is_error <- inherits(cond, "error")
[10:25:48.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.492]                   NULL)
[10:25:48.492]                 if (is_error) {
[10:25:48.492]                   sessionInformation <- function() {
[10:25:48.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.492]                       search = base::search(), system = base::Sys.info())
[10:25:48.492]                   }
[10:25:48.492]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.492]                     cond$call), session = sessionInformation(), 
[10:25:48.492]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.492]                   signalCondition(cond)
[10:25:48.492]                 }
[10:25:48.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.492]                 "immediateCondition"))) {
[10:25:48.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.492]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.492]                   if (TRUE && !signal) {
[10:25:48.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.492]                     {
[10:25:48.492]                       inherits <- base::inherits
[10:25:48.492]                       invokeRestart <- base::invokeRestart
[10:25:48.492]                       is.null <- base::is.null
[10:25:48.492]                       muffled <- FALSE
[10:25:48.492]                       if (inherits(cond, "message")) {
[10:25:48.492]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.492]                         if (muffled) 
[10:25:48.492]                           invokeRestart("muffleMessage")
[10:25:48.492]                       }
[10:25:48.492]                       else if (inherits(cond, "warning")) {
[10:25:48.492]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.492]                         if (muffled) 
[10:25:48.492]                           invokeRestart("muffleWarning")
[10:25:48.492]                       }
[10:25:48.492]                       else if (inherits(cond, "condition")) {
[10:25:48.492]                         if (!is.null(pattern)) {
[10:25:48.492]                           computeRestarts <- base::computeRestarts
[10:25:48.492]                           grepl <- base::grepl
[10:25:48.492]                           restarts <- computeRestarts(cond)
[10:25:48.492]                           for (restart in restarts) {
[10:25:48.492]                             name <- restart$name
[10:25:48.492]                             if (is.null(name)) 
[10:25:48.492]                               next
[10:25:48.492]                             if (!grepl(pattern, name)) 
[10:25:48.492]                               next
[10:25:48.492]                             invokeRestart(restart)
[10:25:48.492]                             muffled <- TRUE
[10:25:48.492]                             break
[10:25:48.492]                           }
[10:25:48.492]                         }
[10:25:48.492]                       }
[10:25:48.492]                       invisible(muffled)
[10:25:48.492]                     }
[10:25:48.492]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.492]                   }
[10:25:48.492]                 }
[10:25:48.492]                 else {
[10:25:48.492]                   if (TRUE) {
[10:25:48.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.492]                     {
[10:25:48.492]                       inherits <- base::inherits
[10:25:48.492]                       invokeRestart <- base::invokeRestart
[10:25:48.492]                       is.null <- base::is.null
[10:25:48.492]                       muffled <- FALSE
[10:25:48.492]                       if (inherits(cond, "message")) {
[10:25:48.492]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.492]                         if (muffled) 
[10:25:48.492]                           invokeRestart("muffleMessage")
[10:25:48.492]                       }
[10:25:48.492]                       else if (inherits(cond, "warning")) {
[10:25:48.492]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.492]                         if (muffled) 
[10:25:48.492]                           invokeRestart("muffleWarning")
[10:25:48.492]                       }
[10:25:48.492]                       else if (inherits(cond, "condition")) {
[10:25:48.492]                         if (!is.null(pattern)) {
[10:25:48.492]                           computeRestarts <- base::computeRestarts
[10:25:48.492]                           grepl <- base::grepl
[10:25:48.492]                           restarts <- computeRestarts(cond)
[10:25:48.492]                           for (restart in restarts) {
[10:25:48.492]                             name <- restart$name
[10:25:48.492]                             if (is.null(name)) 
[10:25:48.492]                               next
[10:25:48.492]                             if (!grepl(pattern, name)) 
[10:25:48.492]                               next
[10:25:48.492]                             invokeRestart(restart)
[10:25:48.492]                             muffled <- TRUE
[10:25:48.492]                             break
[10:25:48.492]                           }
[10:25:48.492]                         }
[10:25:48.492]                       }
[10:25:48.492]                       invisible(muffled)
[10:25:48.492]                     }
[10:25:48.492]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.492]                   }
[10:25:48.492]                 }
[10:25:48.492]             }
[10:25:48.492]         }))
[10:25:48.492]     }, error = function(ex) {
[10:25:48.492]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.492]                 ...future.rng), started = ...future.startTime, 
[10:25:48.492]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.492]             version = "1.8"), class = "FutureResult")
[10:25:48.492]     }, finally = {
[10:25:48.492]         if (!identical(...future.workdir, getwd())) 
[10:25:48.492]             setwd(...future.workdir)
[10:25:48.492]         {
[10:25:48.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.492]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.492]             }
[10:25:48.492]             base::options(...future.oldOptions)
[10:25:48.492]             if (.Platform$OS.type == "windows") {
[10:25:48.492]                 old_names <- names(...future.oldEnvVars)
[10:25:48.492]                 envs <- base::Sys.getenv()
[10:25:48.492]                 names <- names(envs)
[10:25:48.492]                 common <- intersect(names, old_names)
[10:25:48.492]                 added <- setdiff(names, old_names)
[10:25:48.492]                 removed <- setdiff(old_names, names)
[10:25:48.492]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.492]                   envs[common]]
[10:25:48.492]                 NAMES <- toupper(changed)
[10:25:48.492]                 args <- list()
[10:25:48.492]                 for (kk in seq_along(NAMES)) {
[10:25:48.492]                   name <- changed[[kk]]
[10:25:48.492]                   NAME <- NAMES[[kk]]
[10:25:48.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.492]                     next
[10:25:48.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.492]                 }
[10:25:48.492]                 NAMES <- toupper(added)
[10:25:48.492]                 for (kk in seq_along(NAMES)) {
[10:25:48.492]                   name <- added[[kk]]
[10:25:48.492]                   NAME <- NAMES[[kk]]
[10:25:48.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.492]                     next
[10:25:48.492]                   args[[name]] <- ""
[10:25:48.492]                 }
[10:25:48.492]                 NAMES <- toupper(removed)
[10:25:48.492]                 for (kk in seq_along(NAMES)) {
[10:25:48.492]                   name <- removed[[kk]]
[10:25:48.492]                   NAME <- NAMES[[kk]]
[10:25:48.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.492]                     next
[10:25:48.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.492]                 }
[10:25:48.492]                 if (length(args) > 0) 
[10:25:48.492]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.492]             }
[10:25:48.492]             else {
[10:25:48.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.492]             }
[10:25:48.492]             {
[10:25:48.492]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.492]                   0L) {
[10:25:48.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.492]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.492]                   base::options(opts)
[10:25:48.492]                 }
[10:25:48.492]                 {
[10:25:48.492]                   {
[10:25:48.492]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.492]                     NULL
[10:25:48.492]                   }
[10:25:48.492]                   options(future.plan = NULL)
[10:25:48.492]                   if (is.na(NA_character_)) 
[10:25:48.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.492]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.492]                     envir = parent.frame()) 
[10:25:48.492]                   {
[10:25:48.492]                     default_workers <- missing(workers)
[10:25:48.492]                     if (is.function(workers)) 
[10:25:48.492]                       workers <- workers()
[10:25:48.492]                     workers <- structure(as.integer(workers), 
[10:25:48.492]                       class = class(workers))
[10:25:48.492]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.492]                       1L)
[10:25:48.492]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.492]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.492]                       if (default_workers) 
[10:25:48.492]                         supportsMulticore(warn = TRUE)
[10:25:48.492]                       return(sequential(..., envir = envir))
[10:25:48.492]                     }
[10:25:48.492]                     oopts <- options(mc.cores = workers)
[10:25:48.492]                     on.exit(options(oopts))
[10:25:48.492]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.492]                       envir = envir)
[10:25:48.492]                     if (!future$lazy) 
[10:25:48.492]                       future <- run(future)
[10:25:48.492]                     invisible(future)
[10:25:48.492]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.492]                 }
[10:25:48.492]             }
[10:25:48.492]         }
[10:25:48.492]     })
[10:25:48.492]     if (TRUE) {
[10:25:48.492]         base::sink(type = "output", split = FALSE)
[10:25:48.492]         if (TRUE) {
[10:25:48.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.492]         }
[10:25:48.492]         else {
[10:25:48.492]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.492]         }
[10:25:48.492]         base::close(...future.stdout)
[10:25:48.492]         ...future.stdout <- NULL
[10:25:48.492]     }
[10:25:48.492]     ...future.result$conditions <- ...future.conditions
[10:25:48.492]     ...future.result$finished <- base::Sys.time()
[10:25:48.492]     ...future.result
[10:25:48.492] }
[10:25:48.496] requestCore(): workers = 2
[10:25:48.498] MulticoreFuture started
[10:25:48.499] - Launch lazy future ... done
[10:25:48.499] run() for ‘MulticoreFuture’ ... done
[10:25:48.499] getGlobalsAndPackages() ...
[10:25:48.500] Searching for globals...
[10:25:48.500] plan(): Setting new future strategy stack:
[10:25:48.500] 
[10:25:48.501] Searching for globals ... DONE
[10:25:48.501] - globals: [0] <none>
[10:25:48.500] List of future strategies:
[10:25:48.500] 1. sequential:
[10:25:48.500]    - args: function (..., envir = parent.frame())
[10:25:48.500]    - tweaked: FALSE
[10:25:48.500]    - call: NULL
[10:25:48.501] getGlobalsAndPackages() ... DONE
[10:25:48.501] plan(): nbrOfWorkers() = 1
[10:25:48.502] run() for ‘Future’ ...
[10:25:48.502] - state: ‘created’
[10:25:48.502] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.504] plan(): Setting new future strategy stack:
[10:25:48.504] List of future strategies:
[10:25:48.504] 1. multicore:
[10:25:48.504]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.504]    - tweaked: FALSE
[10:25:48.504]    - call: plan(strategy)
[10:25:48.509] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.509] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.509]   - Field: ‘label’
[10:25:48.510]   - Field: ‘local’
[10:25:48.510]   - Field: ‘owner’
[10:25:48.510]   - Field: ‘envir’
[10:25:48.510]   - Field: ‘workers’
[10:25:48.510]   - Field: ‘packages’
[10:25:48.511]   - Field: ‘gc’
[10:25:48.511]   - Field: ‘job’
[10:25:48.511]   - Field: ‘conditions’
[10:25:48.511]   - Field: ‘expr’
[10:25:48.511]   - Field: ‘uuid’
[10:25:48.512]   - Field: ‘seed’
[10:25:48.512] plan(): nbrOfWorkers() = 2
[10:25:48.512]   - Field: ‘version’
[10:25:48.512]   - Field: ‘result’
[10:25:48.512]   - Field: ‘asynchronous’
[10:25:48.513]   - Field: ‘calls’
[10:25:48.513]   - Field: ‘globals’
[10:25:48.513]   - Field: ‘stdout’
[10:25:48.513]   - Field: ‘earlySignal’
[10:25:48.513]   - Field: ‘lazy’
[10:25:48.514]   - Field: ‘state’
[10:25:48.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.514] - Launch lazy future ...
[10:25:48.515] Packages needed by the future expression (n = 0): <none>
[10:25:48.515] Packages needed by future strategies (n = 0): <none>
[10:25:48.516] {
[10:25:48.516]     {
[10:25:48.516]         {
[10:25:48.516]             ...future.startTime <- base::Sys.time()
[10:25:48.516]             {
[10:25:48.516]                 {
[10:25:48.516]                   {
[10:25:48.516]                     {
[10:25:48.516]                       base::local({
[10:25:48.516]                         has_future <- base::requireNamespace("future", 
[10:25:48.516]                           quietly = TRUE)
[10:25:48.516]                         if (has_future) {
[10:25:48.516]                           ns <- base::getNamespace("future")
[10:25:48.516]                           version <- ns[[".package"]][["version"]]
[10:25:48.516]                           if (is.null(version)) 
[10:25:48.516]                             version <- utils::packageVersion("future")
[10:25:48.516]                         }
[10:25:48.516]                         else {
[10:25:48.516]                           version <- NULL
[10:25:48.516]                         }
[10:25:48.516]                         if (!has_future || version < "1.8.0") {
[10:25:48.516]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.516]                             "", base::R.version$version.string), 
[10:25:48.516]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.516]                               "release", "version")], collapse = " "), 
[10:25:48.516]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.516]                             info)
[10:25:48.516]                           info <- base::paste(info, collapse = "; ")
[10:25:48.516]                           if (!has_future) {
[10:25:48.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.516]                               info)
[10:25:48.516]                           }
[10:25:48.516]                           else {
[10:25:48.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.516]                               info, version)
[10:25:48.516]                           }
[10:25:48.516]                           base::stop(msg)
[10:25:48.516]                         }
[10:25:48.516]                       })
[10:25:48.516]                     }
[10:25:48.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.516]                     base::options(mc.cores = 1L)
[10:25:48.516]                   }
[10:25:48.516]                   options(future.plan = NULL)
[10:25:48.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.516]                 }
[10:25:48.516]                 ...future.workdir <- getwd()
[10:25:48.516]             }
[10:25:48.516]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.516]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.516]         }
[10:25:48.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.516]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.516]             base::names(...future.oldOptions))
[10:25:48.516]     }
[10:25:48.516]     if (FALSE) {
[10:25:48.516]     }
[10:25:48.516]     else {
[10:25:48.516]         if (TRUE) {
[10:25:48.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.516]                 open = "w")
[10:25:48.516]         }
[10:25:48.516]         else {
[10:25:48.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.516]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.516]         }
[10:25:48.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.516]             base::sink(type = "output", split = FALSE)
[10:25:48.516]             base::close(...future.stdout)
[10:25:48.516]         }, add = TRUE)
[10:25:48.516]     }
[10:25:48.516]     ...future.frame <- base::sys.nframe()
[10:25:48.516]     ...future.conditions <- base::list()
[10:25:48.516]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.516]     if (FALSE) {
[10:25:48.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.516]     }
[10:25:48.516]     ...future.result <- base::tryCatch({
[10:25:48.516]         base::withCallingHandlers({
[10:25:48.516]             ...future.value <- base::withVisible(base::local({
[10:25:48.516]                 withCallingHandlers({
[10:25:48.516]                   NULL
[10:25:48.516]                 }, immediateCondition = function(cond) {
[10:25:48.516]                   save_rds <- function (object, pathname, ...) 
[10:25:48.516]                   {
[10:25:48.516]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.516]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.516]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.516]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.516]                         fi_tmp[["mtime"]])
[10:25:48.516]                     }
[10:25:48.516]                     tryCatch({
[10:25:48.516]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.516]                     }, error = function(ex) {
[10:25:48.516]                       msg <- conditionMessage(ex)
[10:25:48.516]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.516]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.516]                         fi_tmp[["mtime"]], msg)
[10:25:48.516]                       ex$message <- msg
[10:25:48.516]                       stop(ex)
[10:25:48.516]                     })
[10:25:48.516]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.516]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.516]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.516]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.516]                       fi <- file.info(pathname)
[10:25:48.516]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.516]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.516]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.516]                         fi[["size"]], fi[["mtime"]])
[10:25:48.516]                       stop(msg)
[10:25:48.516]                     }
[10:25:48.516]                     invisible(pathname)
[10:25:48.516]                   }
[10:25:48.516]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.516]                     rootPath = tempdir()) 
[10:25:48.516]                   {
[10:25:48.516]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.516]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.516]                       tmpdir = path, fileext = ".rds")
[10:25:48.516]                     save_rds(obj, file)
[10:25:48.516]                   }
[10:25:48.516]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.516]                   {
[10:25:48.516]                     inherits <- base::inherits
[10:25:48.516]                     invokeRestart <- base::invokeRestart
[10:25:48.516]                     is.null <- base::is.null
[10:25:48.516]                     muffled <- FALSE
[10:25:48.516]                     if (inherits(cond, "message")) {
[10:25:48.516]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.516]                       if (muffled) 
[10:25:48.516]                         invokeRestart("muffleMessage")
[10:25:48.516]                     }
[10:25:48.516]                     else if (inherits(cond, "warning")) {
[10:25:48.516]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.516]                       if (muffled) 
[10:25:48.516]                         invokeRestart("muffleWarning")
[10:25:48.516]                     }
[10:25:48.516]                     else if (inherits(cond, "condition")) {
[10:25:48.516]                       if (!is.null(pattern)) {
[10:25:48.516]                         computeRestarts <- base::computeRestarts
[10:25:48.516]                         grepl <- base::grepl
[10:25:48.516]                         restarts <- computeRestarts(cond)
[10:25:48.516]                         for (restart in restarts) {
[10:25:48.516]                           name <- restart$name
[10:25:48.516]                           if (is.null(name)) 
[10:25:48.516]                             next
[10:25:48.516]                           if (!grepl(pattern, name)) 
[10:25:48.516]                             next
[10:25:48.516]                           invokeRestart(restart)
[10:25:48.516]                           muffled <- TRUE
[10:25:48.516]                           break
[10:25:48.516]                         }
[10:25:48.516]                       }
[10:25:48.516]                     }
[10:25:48.516]                     invisible(muffled)
[10:25:48.516]                   }
[10:25:48.516]                   muffleCondition(cond)
[10:25:48.516]                 })
[10:25:48.516]             }))
[10:25:48.516]             future::FutureResult(value = ...future.value$value, 
[10:25:48.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.516]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.516]                     ...future.globalenv.names))
[10:25:48.516]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.516]         }, condition = base::local({
[10:25:48.516]             c <- base::c
[10:25:48.516]             inherits <- base::inherits
[10:25:48.516]             invokeRestart <- base::invokeRestart
[10:25:48.516]             length <- base::length
[10:25:48.516]             list <- base::list
[10:25:48.516]             seq.int <- base::seq.int
[10:25:48.516]             signalCondition <- base::signalCondition
[10:25:48.516]             sys.calls <- base::sys.calls
[10:25:48.516]             `[[` <- base::`[[`
[10:25:48.516]             `+` <- base::`+`
[10:25:48.516]             `<<-` <- base::`<<-`
[10:25:48.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.516]                   3L)]
[10:25:48.516]             }
[10:25:48.516]             function(cond) {
[10:25:48.516]                 is_error <- inherits(cond, "error")
[10:25:48.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.516]                   NULL)
[10:25:48.516]                 if (is_error) {
[10:25:48.516]                   sessionInformation <- function() {
[10:25:48.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.516]                       search = base::search(), system = base::Sys.info())
[10:25:48.516]                   }
[10:25:48.516]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.516]                     cond$call), session = sessionInformation(), 
[10:25:48.516]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.516]                   signalCondition(cond)
[10:25:48.516]                 }
[10:25:48.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.516]                 "immediateCondition"))) {
[10:25:48.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.516]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.516]                   if (TRUE && !signal) {
[10:25:48.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.516]                     {
[10:25:48.516]                       inherits <- base::inherits
[10:25:48.516]                       invokeRestart <- base::invokeRestart
[10:25:48.516]                       is.null <- base::is.null
[10:25:48.516]                       muffled <- FALSE
[10:25:48.516]                       if (inherits(cond, "message")) {
[10:25:48.516]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.516]                         if (muffled) 
[10:25:48.516]                           invokeRestart("muffleMessage")
[10:25:48.516]                       }
[10:25:48.516]                       else if (inherits(cond, "warning")) {
[10:25:48.516]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.516]                         if (muffled) 
[10:25:48.516]                           invokeRestart("muffleWarning")
[10:25:48.516]                       }
[10:25:48.516]                       else if (inherits(cond, "condition")) {
[10:25:48.516]                         if (!is.null(pattern)) {
[10:25:48.516]                           computeRestarts <- base::computeRestarts
[10:25:48.516]                           grepl <- base::grepl
[10:25:48.516]                           restarts <- computeRestarts(cond)
[10:25:48.516]                           for (restart in restarts) {
[10:25:48.516]                             name <- restart$name
[10:25:48.516]                             if (is.null(name)) 
[10:25:48.516]                               next
[10:25:48.516]                             if (!grepl(pattern, name)) 
[10:25:48.516]                               next
[10:25:48.516]                             invokeRestart(restart)
[10:25:48.516]                             muffled <- TRUE
[10:25:48.516]                             break
[10:25:48.516]                           }
[10:25:48.516]                         }
[10:25:48.516]                       }
[10:25:48.516]                       invisible(muffled)
[10:25:48.516]                     }
[10:25:48.516]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.516]                   }
[10:25:48.516]                 }
[10:25:48.516]                 else {
[10:25:48.516]                   if (TRUE) {
[10:25:48.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.516]                     {
[10:25:48.516]                       inherits <- base::inherits
[10:25:48.516]                       invokeRestart <- base::invokeRestart
[10:25:48.516]                       is.null <- base::is.null
[10:25:48.516]                       muffled <- FALSE
[10:25:48.516]                       if (inherits(cond, "message")) {
[10:25:48.516]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.516]                         if (muffled) 
[10:25:48.516]                           invokeRestart("muffleMessage")
[10:25:48.516]                       }
[10:25:48.516]                       else if (inherits(cond, "warning")) {
[10:25:48.516]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.516]                         if (muffled) 
[10:25:48.516]                           invokeRestart("muffleWarning")
[10:25:48.516]                       }
[10:25:48.516]                       else if (inherits(cond, "condition")) {
[10:25:48.516]                         if (!is.null(pattern)) {
[10:25:48.516]                           computeRestarts <- base::computeRestarts
[10:25:48.516]                           grepl <- base::grepl
[10:25:48.516]                           restarts <- computeRestarts(cond)
[10:25:48.516]                           for (restart in restarts) {
[10:25:48.516]                             name <- restart$name
[10:25:48.516]                             if (is.null(name)) 
[10:25:48.516]                               next
[10:25:48.516]                             if (!grepl(pattern, name)) 
[10:25:48.516]                               next
[10:25:48.516]                             invokeRestart(restart)
[10:25:48.516]                             muffled <- TRUE
[10:25:48.516]                             break
[10:25:48.516]                           }
[10:25:48.516]                         }
[10:25:48.516]                       }
[10:25:48.516]                       invisible(muffled)
[10:25:48.516]                     }
[10:25:48.516]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.516]                   }
[10:25:48.516]                 }
[10:25:48.516]             }
[10:25:48.516]         }))
[10:25:48.516]     }, error = function(ex) {
[10:25:48.516]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.516]                 ...future.rng), started = ...future.startTime, 
[10:25:48.516]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.516]             version = "1.8"), class = "FutureResult")
[10:25:48.516]     }, finally = {
[10:25:48.516]         if (!identical(...future.workdir, getwd())) 
[10:25:48.516]             setwd(...future.workdir)
[10:25:48.516]         {
[10:25:48.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.516]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.516]             }
[10:25:48.516]             base::options(...future.oldOptions)
[10:25:48.516]             if (.Platform$OS.type == "windows") {
[10:25:48.516]                 old_names <- names(...future.oldEnvVars)
[10:25:48.516]                 envs <- base::Sys.getenv()
[10:25:48.516]                 names <- names(envs)
[10:25:48.516]                 common <- intersect(names, old_names)
[10:25:48.516]                 added <- setdiff(names, old_names)
[10:25:48.516]                 removed <- setdiff(old_names, names)
[10:25:48.516]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.516]                   envs[common]]
[10:25:48.516]                 NAMES <- toupper(changed)
[10:25:48.516]                 args <- list()
[10:25:48.516]                 for (kk in seq_along(NAMES)) {
[10:25:48.516]                   name <- changed[[kk]]
[10:25:48.516]                   NAME <- NAMES[[kk]]
[10:25:48.516]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.516]                     next
[10:25:48.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.516]                 }
[10:25:48.516]                 NAMES <- toupper(added)
[10:25:48.516]                 for (kk in seq_along(NAMES)) {
[10:25:48.516]                   name <- added[[kk]]
[10:25:48.516]                   NAME <- NAMES[[kk]]
[10:25:48.516]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.516]                     next
[10:25:48.516]                   args[[name]] <- ""
[10:25:48.516]                 }
[10:25:48.516]                 NAMES <- toupper(removed)
[10:25:48.516]                 for (kk in seq_along(NAMES)) {
[10:25:48.516]                   name <- removed[[kk]]
[10:25:48.516]                   NAME <- NAMES[[kk]]
[10:25:48.516]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.516]                     next
[10:25:48.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.516]                 }
[10:25:48.516]                 if (length(args) > 0) 
[10:25:48.516]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.516]             }
[10:25:48.516]             else {
[10:25:48.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.516]             }
[10:25:48.516]             {
[10:25:48.516]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.516]                   0L) {
[10:25:48.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.516]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.516]                   base::options(opts)
[10:25:48.516]                 }
[10:25:48.516]                 {
[10:25:48.516]                   {
[10:25:48.516]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.516]                     NULL
[10:25:48.516]                   }
[10:25:48.516]                   options(future.plan = NULL)
[10:25:48.516]                   if (is.na(NA_character_)) 
[10:25:48.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.516]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.516]                     envir = parent.frame()) 
[10:25:48.516]                   {
[10:25:48.516]                     default_workers <- missing(workers)
[10:25:48.516]                     if (is.function(workers)) 
[10:25:48.516]                       workers <- workers()
[10:25:48.516]                     workers <- structure(as.integer(workers), 
[10:25:48.516]                       class = class(workers))
[10:25:48.516]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.516]                       1L)
[10:25:48.516]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.516]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.516]                       if (default_workers) 
[10:25:48.516]                         supportsMulticore(warn = TRUE)
[10:25:48.516]                       return(sequential(..., envir = envir))
[10:25:48.516]                     }
[10:25:48.516]                     oopts <- options(mc.cores = workers)
[10:25:48.516]                     on.exit(options(oopts))
[10:25:48.516]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.516]                       envir = envir)
[10:25:48.516]                     if (!future$lazy) 
[10:25:48.516]                       future <- run(future)
[10:25:48.516]                     invisible(future)
[10:25:48.516]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.516]                 }
[10:25:48.516]             }
[10:25:48.516]         }
[10:25:48.516]     })
[10:25:48.516]     if (TRUE) {
[10:25:48.516]         base::sink(type = "output", split = FALSE)
[10:25:48.516]         if (TRUE) {
[10:25:48.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.516]         }
[10:25:48.516]         else {
[10:25:48.516]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.516]         }
[10:25:48.516]         base::close(...future.stdout)
[10:25:48.516]         ...future.stdout <- NULL
[10:25:48.516]     }
[10:25:48.516]     ...future.result$conditions <- ...future.conditions
[10:25:48.516]     ...future.result$finished <- base::Sys.time()
[10:25:48.516]     ...future.result
[10:25:48.516] }
[10:25:48.521] requestCore(): workers = 2
[10:25:48.525] MulticoreFuture started
[10:25:48.526] - Launch lazy future ... done
[10:25:48.526] run() for ‘MulticoreFuture’ ... done
[10:25:48.526] plan(): Setting new future strategy stack:
[10:25:48.526] List of future strategies:
[10:25:48.526] 1. sequential:
[10:25:48.526]    - args: function (..., envir = parent.frame())
[10:25:48.526]    - tweaked: FALSE
[10:25:48.526]    - call: NULL
[10:25:48.527] getGlobalsAndPackages() ...
[10:25:48.527] plan(): nbrOfWorkers() = 1
[10:25:48.527] Searching for globals...
[10:25:48.529] plan(): Setting new future strategy stack:
[10:25:48.529] - globals found: [1] ‘{’
[10:25:48.530] Searching for globals ... DONE
[10:25:48.530] Resolving globals: FALSE
[10:25:48.530] List of future strategies:
[10:25:48.530] 1. multicore:
[10:25:48.530]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.530]    - tweaked: FALSE
[10:25:48.530]    - call: plan(strategy)
[10:25:48.531] 
[10:25:48.531] 
[10:25:48.531] getGlobalsAndPackages() ... DONE
[10:25:48.532] run() for ‘Future’ ...
[10:25:48.532] - state: ‘created’
[10:25:48.533] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.536] plan(): nbrOfWorkers() = 2
[10:25:48.540] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.540] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.540]   - Field: ‘label’
[10:25:48.540]   - Field: ‘local’
[10:25:48.540]   - Field: ‘owner’
[10:25:48.541]   - Field: ‘envir’
[10:25:48.541]   - Field: ‘workers’
[10:25:48.541]   - Field: ‘packages’
[10:25:48.541]   - Field: ‘gc’
[10:25:48.541]   - Field: ‘job’
[10:25:48.542]   - Field: ‘conditions’
[10:25:48.542]   - Field: ‘expr’
[10:25:48.542]   - Field: ‘uuid’
[10:25:48.542]   - Field: ‘seed’
[10:25:48.543]   - Field: ‘version’
[10:25:48.543]   - Field: ‘result’
[10:25:48.543]   - Field: ‘asynchronous’
[10:25:48.543]   - Field: ‘calls’
[10:25:48.543]   - Field: ‘globals’
[10:25:48.544]   - Field: ‘stdout’
[10:25:48.544]   - Field: ‘earlySignal’
[10:25:48.544]   - Field: ‘lazy’
[10:25:48.544]   - Field: ‘state’
[10:25:48.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.545] - Launch lazy future ...
[10:25:48.546] Packages needed by the future expression (n = 0): <none>
[10:25:48.546] Packages needed by future strategies (n = 0): <none>
[10:25:48.547] {
[10:25:48.547]     {
[10:25:48.547]         {
[10:25:48.547]             ...future.startTime <- base::Sys.time()
[10:25:48.547]             {
[10:25:48.547]                 {
[10:25:48.547]                   {
[10:25:48.547]                     {
[10:25:48.547]                       base::local({
[10:25:48.547]                         has_future <- base::requireNamespace("future", 
[10:25:48.547]                           quietly = TRUE)
[10:25:48.547]                         if (has_future) {
[10:25:48.547]                           ns <- base::getNamespace("future")
[10:25:48.547]                           version <- ns[[".package"]][["version"]]
[10:25:48.547]                           if (is.null(version)) 
[10:25:48.547]                             version <- utils::packageVersion("future")
[10:25:48.547]                         }
[10:25:48.547]                         else {
[10:25:48.547]                           version <- NULL
[10:25:48.547]                         }
[10:25:48.547]                         if (!has_future || version < "1.8.0") {
[10:25:48.547]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.547]                             "", base::R.version$version.string), 
[10:25:48.547]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.547]                               "release", "version")], collapse = " "), 
[10:25:48.547]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.547]                             info)
[10:25:48.547]                           info <- base::paste(info, collapse = "; ")
[10:25:48.547]                           if (!has_future) {
[10:25:48.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.547]                               info)
[10:25:48.547]                           }
[10:25:48.547]                           else {
[10:25:48.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.547]                               info, version)
[10:25:48.547]                           }
[10:25:48.547]                           base::stop(msg)
[10:25:48.547]                         }
[10:25:48.547]                       })
[10:25:48.547]                     }
[10:25:48.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.547]                     base::options(mc.cores = 1L)
[10:25:48.547]                   }
[10:25:48.547]                   options(future.plan = NULL)
[10:25:48.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.547]                 }
[10:25:48.547]                 ...future.workdir <- getwd()
[10:25:48.547]             }
[10:25:48.547]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.547]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.547]         }
[10:25:48.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.547]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.547]             base::names(...future.oldOptions))
[10:25:48.547]     }
[10:25:48.547]     if (FALSE) {
[10:25:48.547]     }
[10:25:48.547]     else {
[10:25:48.547]         if (TRUE) {
[10:25:48.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.547]                 open = "w")
[10:25:48.547]         }
[10:25:48.547]         else {
[10:25:48.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.547]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.547]         }
[10:25:48.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.547]             base::sink(type = "output", split = FALSE)
[10:25:48.547]             base::close(...future.stdout)
[10:25:48.547]         }, add = TRUE)
[10:25:48.547]     }
[10:25:48.547]     ...future.frame <- base::sys.nframe()
[10:25:48.547]     ...future.conditions <- base::list()
[10:25:48.547]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.547]     if (FALSE) {
[10:25:48.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.547]     }
[10:25:48.547]     ...future.result <- base::tryCatch({
[10:25:48.547]         base::withCallingHandlers({
[10:25:48.547]             ...future.value <- base::withVisible(base::local({
[10:25:48.547]                 withCallingHandlers({
[10:25:48.547]                   {
[10:25:48.547]                     4
[10:25:48.547]                   }
[10:25:48.547]                 }, immediateCondition = function(cond) {
[10:25:48.547]                   save_rds <- function (object, pathname, ...) 
[10:25:48.547]                   {
[10:25:48.547]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.547]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.547]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.547]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.547]                         fi_tmp[["mtime"]])
[10:25:48.547]                     }
[10:25:48.547]                     tryCatch({
[10:25:48.547]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.547]                     }, error = function(ex) {
[10:25:48.547]                       msg <- conditionMessage(ex)
[10:25:48.547]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.547]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.547]                         fi_tmp[["mtime"]], msg)
[10:25:48.547]                       ex$message <- msg
[10:25:48.547]                       stop(ex)
[10:25:48.547]                     })
[10:25:48.547]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.547]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.547]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.547]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.547]                       fi <- file.info(pathname)
[10:25:48.547]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.547]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.547]                         fi[["size"]], fi[["mtime"]])
[10:25:48.547]                       stop(msg)
[10:25:48.547]                     }
[10:25:48.547]                     invisible(pathname)
[10:25:48.547]                   }
[10:25:48.547]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.547]                     rootPath = tempdir()) 
[10:25:48.547]                   {
[10:25:48.547]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.547]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.547]                       tmpdir = path, fileext = ".rds")
[10:25:48.547]                     save_rds(obj, file)
[10:25:48.547]                   }
[10:25:48.547]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.547]                   {
[10:25:48.547]                     inherits <- base::inherits
[10:25:48.547]                     invokeRestart <- base::invokeRestart
[10:25:48.547]                     is.null <- base::is.null
[10:25:48.547]                     muffled <- FALSE
[10:25:48.547]                     if (inherits(cond, "message")) {
[10:25:48.547]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.547]                       if (muffled) 
[10:25:48.547]                         invokeRestart("muffleMessage")
[10:25:48.547]                     }
[10:25:48.547]                     else if (inherits(cond, "warning")) {
[10:25:48.547]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.547]                       if (muffled) 
[10:25:48.547]                         invokeRestart("muffleWarning")
[10:25:48.547]                     }
[10:25:48.547]                     else if (inherits(cond, "condition")) {
[10:25:48.547]                       if (!is.null(pattern)) {
[10:25:48.547]                         computeRestarts <- base::computeRestarts
[10:25:48.547]                         grepl <- base::grepl
[10:25:48.547]                         restarts <- computeRestarts(cond)
[10:25:48.547]                         for (restart in restarts) {
[10:25:48.547]                           name <- restart$name
[10:25:48.547]                           if (is.null(name)) 
[10:25:48.547]                             next
[10:25:48.547]                           if (!grepl(pattern, name)) 
[10:25:48.547]                             next
[10:25:48.547]                           invokeRestart(restart)
[10:25:48.547]                           muffled <- TRUE
[10:25:48.547]                           break
[10:25:48.547]                         }
[10:25:48.547]                       }
[10:25:48.547]                     }
[10:25:48.547]                     invisible(muffled)
[10:25:48.547]                   }
[10:25:48.547]                   muffleCondition(cond)
[10:25:48.547]                 })
[10:25:48.547]             }))
[10:25:48.547]             future::FutureResult(value = ...future.value$value, 
[10:25:48.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.547]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.547]                     ...future.globalenv.names))
[10:25:48.547]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.547]         }, condition = base::local({
[10:25:48.547]             c <- base::c
[10:25:48.547]             inherits <- base::inherits
[10:25:48.547]             invokeRestart <- base::invokeRestart
[10:25:48.547]             length <- base::length
[10:25:48.547]             list <- base::list
[10:25:48.547]             seq.int <- base::seq.int
[10:25:48.547]             signalCondition <- base::signalCondition
[10:25:48.547]             sys.calls <- base::sys.calls
[10:25:48.547]             `[[` <- base::`[[`
[10:25:48.547]             `+` <- base::`+`
[10:25:48.547]             `<<-` <- base::`<<-`
[10:25:48.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.547]                   3L)]
[10:25:48.547]             }
[10:25:48.547]             function(cond) {
[10:25:48.547]                 is_error <- inherits(cond, "error")
[10:25:48.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.547]                   NULL)
[10:25:48.547]                 if (is_error) {
[10:25:48.547]                   sessionInformation <- function() {
[10:25:48.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.547]                       search = base::search(), system = base::Sys.info())
[10:25:48.547]                   }
[10:25:48.547]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.547]                     cond$call), session = sessionInformation(), 
[10:25:48.547]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.547]                   signalCondition(cond)
[10:25:48.547]                 }
[10:25:48.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.547]                 "immediateCondition"))) {
[10:25:48.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.547]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.547]                   if (TRUE && !signal) {
[10:25:48.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.547]                     {
[10:25:48.547]                       inherits <- base::inherits
[10:25:48.547]                       invokeRestart <- base::invokeRestart
[10:25:48.547]                       is.null <- base::is.null
[10:25:48.547]                       muffled <- FALSE
[10:25:48.547]                       if (inherits(cond, "message")) {
[10:25:48.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.547]                         if (muffled) 
[10:25:48.547]                           invokeRestart("muffleMessage")
[10:25:48.547]                       }
[10:25:48.547]                       else if (inherits(cond, "warning")) {
[10:25:48.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.547]                         if (muffled) 
[10:25:48.547]                           invokeRestart("muffleWarning")
[10:25:48.547]                       }
[10:25:48.547]                       else if (inherits(cond, "condition")) {
[10:25:48.547]                         if (!is.null(pattern)) {
[10:25:48.547]                           computeRestarts <- base::computeRestarts
[10:25:48.547]                           grepl <- base::grepl
[10:25:48.547]                           restarts <- computeRestarts(cond)
[10:25:48.547]                           for (restart in restarts) {
[10:25:48.547]                             name <- restart$name
[10:25:48.547]                             if (is.null(name)) 
[10:25:48.547]                               next
[10:25:48.547]                             if (!grepl(pattern, name)) 
[10:25:48.547]                               next
[10:25:48.547]                             invokeRestart(restart)
[10:25:48.547]                             muffled <- TRUE
[10:25:48.547]                             break
[10:25:48.547]                           }
[10:25:48.547]                         }
[10:25:48.547]                       }
[10:25:48.547]                       invisible(muffled)
[10:25:48.547]                     }
[10:25:48.547]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.547]                   }
[10:25:48.547]                 }
[10:25:48.547]                 else {
[10:25:48.547]                   if (TRUE) {
[10:25:48.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.547]                     {
[10:25:48.547]                       inherits <- base::inherits
[10:25:48.547]                       invokeRestart <- base::invokeRestart
[10:25:48.547]                       is.null <- base::is.null
[10:25:48.547]                       muffled <- FALSE
[10:25:48.547]                       if (inherits(cond, "message")) {
[10:25:48.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.547]                         if (muffled) 
[10:25:48.547]                           invokeRestart("muffleMessage")
[10:25:48.547]                       }
[10:25:48.547]                       else if (inherits(cond, "warning")) {
[10:25:48.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.547]                         if (muffled) 
[10:25:48.547]                           invokeRestart("muffleWarning")
[10:25:48.547]                       }
[10:25:48.547]                       else if (inherits(cond, "condition")) {
[10:25:48.547]                         if (!is.null(pattern)) {
[10:25:48.547]                           computeRestarts <- base::computeRestarts
[10:25:48.547]                           grepl <- base::grepl
[10:25:48.547]                           restarts <- computeRestarts(cond)
[10:25:48.547]                           for (restart in restarts) {
[10:25:48.547]                             name <- restart$name
[10:25:48.547]                             if (is.null(name)) 
[10:25:48.547]                               next
[10:25:48.547]                             if (!grepl(pattern, name)) 
[10:25:48.547]                               next
[10:25:48.547]                             invokeRestart(restart)
[10:25:48.547]                             muffled <- TRUE
[10:25:48.547]                             break
[10:25:48.547]                           }
[10:25:48.547]                         }
[10:25:48.547]                       }
[10:25:48.547]                       invisible(muffled)
[10:25:48.547]                     }
[10:25:48.547]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.547]                   }
[10:25:48.547]                 }
[10:25:48.547]             }
[10:25:48.547]         }))
[10:25:48.547]     }, error = function(ex) {
[10:25:48.547]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.547]                 ...future.rng), started = ...future.startTime, 
[10:25:48.547]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.547]             version = "1.8"), class = "FutureResult")
[10:25:48.547]     }, finally = {
[10:25:48.547]         if (!identical(...future.workdir, getwd())) 
[10:25:48.547]             setwd(...future.workdir)
[10:25:48.547]         {
[10:25:48.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.547]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.547]             }
[10:25:48.547]             base::options(...future.oldOptions)
[10:25:48.547]             if (.Platform$OS.type == "windows") {
[10:25:48.547]                 old_names <- names(...future.oldEnvVars)
[10:25:48.547]                 envs <- base::Sys.getenv()
[10:25:48.547]                 names <- names(envs)
[10:25:48.547]                 common <- intersect(names, old_names)
[10:25:48.547]                 added <- setdiff(names, old_names)
[10:25:48.547]                 removed <- setdiff(old_names, names)
[10:25:48.547]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.547]                   envs[common]]
[10:25:48.547]                 NAMES <- toupper(changed)
[10:25:48.547]                 args <- list()
[10:25:48.547]                 for (kk in seq_along(NAMES)) {
[10:25:48.547]                   name <- changed[[kk]]
[10:25:48.547]                   NAME <- NAMES[[kk]]
[10:25:48.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.547]                     next
[10:25:48.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.547]                 }
[10:25:48.547]                 NAMES <- toupper(added)
[10:25:48.547]                 for (kk in seq_along(NAMES)) {
[10:25:48.547]                   name <- added[[kk]]
[10:25:48.547]                   NAME <- NAMES[[kk]]
[10:25:48.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.547]                     next
[10:25:48.547]                   args[[name]] <- ""
[10:25:48.547]                 }
[10:25:48.547]                 NAMES <- toupper(removed)
[10:25:48.547]                 for (kk in seq_along(NAMES)) {
[10:25:48.547]                   name <- removed[[kk]]
[10:25:48.547]                   NAME <- NAMES[[kk]]
[10:25:48.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.547]                     next
[10:25:48.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.547]                 }
[10:25:48.547]                 if (length(args) > 0) 
[10:25:48.547]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.547]             }
[10:25:48.547]             else {
[10:25:48.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.547]             }
[10:25:48.547]             {
[10:25:48.547]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.547]                   0L) {
[10:25:48.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.547]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.547]                   base::options(opts)
[10:25:48.547]                 }
[10:25:48.547]                 {
[10:25:48.547]                   {
[10:25:48.547]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.547]                     NULL
[10:25:48.547]                   }
[10:25:48.547]                   options(future.plan = NULL)
[10:25:48.547]                   if (is.na(NA_character_)) 
[10:25:48.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.547]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.547]                     envir = parent.frame()) 
[10:25:48.547]                   {
[10:25:48.547]                     default_workers <- missing(workers)
[10:25:48.547]                     if (is.function(workers)) 
[10:25:48.547]                       workers <- workers()
[10:25:48.547]                     workers <- structure(as.integer(workers), 
[10:25:48.547]                       class = class(workers))
[10:25:48.547]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.547]                       1L)
[10:25:48.547]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.547]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.547]                       if (default_workers) 
[10:25:48.547]                         supportsMulticore(warn = TRUE)
[10:25:48.547]                       return(sequential(..., envir = envir))
[10:25:48.547]                     }
[10:25:48.547]                     oopts <- options(mc.cores = workers)
[10:25:48.547]                     on.exit(options(oopts))
[10:25:48.547]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.547]                       envir = envir)
[10:25:48.547]                     if (!future$lazy) 
[10:25:48.547]                       future <- run(future)
[10:25:48.547]                     invisible(future)
[10:25:48.547]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.547]                 }
[10:25:48.547]             }
[10:25:48.547]         }
[10:25:48.547]     })
[10:25:48.547]     if (TRUE) {
[10:25:48.547]         base::sink(type = "output", split = FALSE)
[10:25:48.547]         if (TRUE) {
[10:25:48.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.547]         }
[10:25:48.547]         else {
[10:25:48.547]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.547]         }
[10:25:48.547]         base::close(...future.stdout)
[10:25:48.547]         ...future.stdout <- NULL
[10:25:48.547]     }
[10:25:48.547]     ...future.result$conditions <- ...future.conditions
[10:25:48.547]     ...future.result$finished <- base::Sys.time()
[10:25:48.547]     ...future.result
[10:25:48.547] }
[10:25:48.553] requestCore(): workers = 2
[10:25:48.553] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:48.564] result() for MulticoreFuture ...
[10:25:48.565] result() for MulticoreFuture ...
[10:25:48.565] result() for MulticoreFuture ... done
[10:25:48.566] result() for MulticoreFuture ... done
[10:25:48.566] result() for MulticoreFuture ...
[10:25:48.566] result() for MulticoreFuture ... done
[10:25:48.569] MulticoreFuture started
[10:25:48.569] - Launch lazy future ... done
[10:25:48.569] run() for ‘MulticoreFuture’ ... done
[10:25:48.570] plan(): Setting new future strategy stack:
<environment: 0x55c0f63e22f0> 
[10:25:48.570] List of future strategies:
[10:25:48.570] 1. sequential:
[10:25:48.570]    - args: function (..., envir = parent.frame())
[10:25:48.570]    - tweaked: FALSE
[10:25:48.570]    - call: NULL
[10:25:48.571] plan(): nbrOfWorkers() = 1
<environment: 0x55c0f6f48bd8> 
[10:25:48.574] plan(): Setting new future strategy stack:
[10:25:48.574] List of future strategies:
[10:25:48.574] 1. multicore:
[10:25:48.574]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.574]    - tweaked: FALSE
[10:25:48.574]    - call: plan(strategy)
[10:25:48.579] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:48.582] resolve() on environment ...
[10:25:48.582]  recursive: 0
[10:25:48.583]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:48.583] signalConditionsASAP(numeric, pos=1) ...
[10:25:48.583] - nx: 4
[10:25:48.583] - relay: TRUE
[10:25:48.583] - stdout: TRUE
[10:25:48.583] - signal: TRUE
[10:25:48.583] - resignal: FALSE
[10:25:48.583] - force: TRUE
[10:25:48.584] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.584] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.584]  - until=2
[10:25:48.584]  - relaying element #2
[10:25:48.584] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.584] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.584] signalConditionsASAP(NULL, pos=1) ... done
[10:25:48.585]  length: 3 (resolved future 1)
[10:25:48.585] Future #2
[10:25:48.585] result() for MulticoreFuture ...
[10:25:48.585] result() for MulticoreFuture ... done
[10:25:48.585] result() for MulticoreFuture ...
[10:25:48.585] result() for MulticoreFuture ... done
[10:25:48.586] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:48.586] - nx: 4
[10:25:48.586] - relay: TRUE
[10:25:48.586] - stdout: TRUE
[10:25:48.586] - signal: TRUE
[10:25:48.586] - resignal: FALSE
[10:25:48.586] - force: TRUE
[10:25:48.586] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.586] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.587]  - until=2
[10:25:48.587]  - relaying element #2
[10:25:48.587] result() for MulticoreFuture ...
[10:25:48.587] result() for MulticoreFuture ... done
[10:25:48.587] result() for MulticoreFuture ...
[10:25:48.587] result() for MulticoreFuture ... done
[10:25:48.587] result() for MulticoreFuture ...
[10:25:48.588] result() for MulticoreFuture ... done
[10:25:48.588] result() for MulticoreFuture ...
[10:25:48.588] result() for MulticoreFuture ... done
[10:25:48.588] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.588] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.588] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:48.588]  length: 2 (resolved future 2)
[10:25:48.589] Future #3
[10:25:48.589] result() for MulticoreFuture ...
[10:25:48.590] result() for MulticoreFuture ...
[10:25:48.590] result() for MulticoreFuture ... done
[10:25:48.590] result() for MulticoreFuture ... done
[10:25:48.590] result() for MulticoreFuture ...
[10:25:48.590] result() for MulticoreFuture ... done
[10:25:48.590] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:48.590] - nx: 4
[10:25:48.591] - relay: TRUE
[10:25:48.591] - stdout: TRUE
[10:25:48.603] - signal: TRUE
[10:25:48.603] - resignal: FALSE
[10:25:48.603] - force: TRUE
[10:25:48.603] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.603] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.604]  - until=3
[10:25:48.604]  - relaying element #3
[10:25:48.604] result() for MulticoreFuture ...
[10:25:48.604] result() for MulticoreFuture ... done
[10:25:48.604] result() for MulticoreFuture ...
[10:25:48.604] result() for MulticoreFuture ... done
[10:25:48.604] result() for MulticoreFuture ...
[10:25:48.604] result() for MulticoreFuture ... done
[10:25:48.605] result() for MulticoreFuture ...
[10:25:48.605] result() for MulticoreFuture ... done
[10:25:48.605] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.605] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.605] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:48.605]  length: 1 (resolved future 3)
[10:25:48.606] Future #4
[10:25:48.606] result() for MulticoreFuture ...
[10:25:48.606] result() for MulticoreFuture ...
[10:25:48.606] result() for MulticoreFuture ... done
[10:25:48.607] result() for MulticoreFuture ... done
[10:25:48.607] result() for MulticoreFuture ...
[10:25:48.607] result() for MulticoreFuture ... done
[10:25:48.607] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:48.607] - nx: 4
[10:25:48.607] - relay: TRUE
[10:25:48.607] - stdout: TRUE
[10:25:48.607] - signal: TRUE
[10:25:48.607] - resignal: FALSE
[10:25:48.608] - force: TRUE
[10:25:48.608] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.608] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.608]  - until=4
[10:25:48.608]  - relaying element #4
[10:25:48.608] result() for MulticoreFuture ...
[10:25:48.608] result() for MulticoreFuture ... done
[10:25:48.608] result() for MulticoreFuture ...
[10:25:48.609] result() for MulticoreFuture ... done
[10:25:48.609] result() for MulticoreFuture ...
[10:25:48.609] result() for MulticoreFuture ... done
[10:25:48.609] result() for MulticoreFuture ...
[10:25:48.609] result() for MulticoreFuture ... done
[10:25:48.609] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.609] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.609] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:48.610]  length: 0 (resolved future 4)
[10:25:48.610] Relaying remaining futures
[10:25:48.610] signalConditionsASAP(NULL, pos=0) ...
[10:25:48.610] - nx: 4
[10:25:48.610] - relay: TRUE
[10:25:48.610] - stdout: TRUE
[10:25:48.610] - signal: TRUE
[10:25:48.610] - resignal: FALSE
[10:25:48.610] - force: TRUE
[10:25:48.610] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.610] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:48.611] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.611] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.611] signalConditionsASAP(NULL, pos=0) ... done
[10:25:48.611] resolve() on environment ... DONE
[10:25:48.611] result() for MulticoreFuture ...
[10:25:48.611] result() for MulticoreFuture ... done
[10:25:48.611] result() for MulticoreFuture ...
[10:25:48.611] result() for MulticoreFuture ... done
[10:25:48.612] result() for MulticoreFuture ...
[10:25:48.612] result() for MulticoreFuture ... done
[10:25:48.612] result() for MulticoreFuture ...
[10:25:48.612] result() for MulticoreFuture ... done
[10:25:48.612] result() for MulticoreFuture ...
[10:25:48.612] result() for MulticoreFuture ... done
[10:25:48.612] result() for MulticoreFuture ...
[10:25:48.612] result() for MulticoreFuture ... done
<environment: 0x55c0f6ffbee8> 
Dimensions: c(2, 1, 3, 1)
[10:25:48.613] getGlobalsAndPackages() ...
[10:25:48.613] Searching for globals...
[10:25:48.613] 
[10:25:48.613] Searching for globals ... DONE
[10:25:48.614] - globals: [0] <none>
[10:25:48.614] getGlobalsAndPackages() ... DONE
[10:25:48.614] run() for ‘Future’ ...
[10:25:48.614] - state: ‘created’
[10:25:48.614] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.618] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.618] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.619]   - Field: ‘label’
[10:25:48.619]   - Field: ‘local’
[10:25:48.619]   - Field: ‘owner’
[10:25:48.619]   - Field: ‘envir’
[10:25:48.619]   - Field: ‘workers’
[10:25:48.619]   - Field: ‘packages’
[10:25:48.619]   - Field: ‘gc’
[10:25:48.619]   - Field: ‘job’
[10:25:48.619]   - Field: ‘conditions’
[10:25:48.620]   - Field: ‘expr’
[10:25:48.620]   - Field: ‘uuid’
[10:25:48.620]   - Field: ‘seed’
[10:25:48.620]   - Field: ‘version’
[10:25:48.620]   - Field: ‘result’
[10:25:48.620]   - Field: ‘asynchronous’
[10:25:48.620]   - Field: ‘calls’
[10:25:48.620]   - Field: ‘globals’
[10:25:48.620]   - Field: ‘stdout’
[10:25:48.620]   - Field: ‘earlySignal’
[10:25:48.621]   - Field: ‘lazy’
[10:25:48.621]   - Field: ‘state’
[10:25:48.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.621] - Launch lazy future ...
[10:25:48.621] Packages needed by the future expression (n = 0): <none>
[10:25:48.621] Packages needed by future strategies (n = 0): <none>
[10:25:48.622] {
[10:25:48.622]     {
[10:25:48.622]         {
[10:25:48.622]             ...future.startTime <- base::Sys.time()
[10:25:48.622]             {
[10:25:48.622]                 {
[10:25:48.622]                   {
[10:25:48.622]                     {
[10:25:48.622]                       base::local({
[10:25:48.622]                         has_future <- base::requireNamespace("future", 
[10:25:48.622]                           quietly = TRUE)
[10:25:48.622]                         if (has_future) {
[10:25:48.622]                           ns <- base::getNamespace("future")
[10:25:48.622]                           version <- ns[[".package"]][["version"]]
[10:25:48.622]                           if (is.null(version)) 
[10:25:48.622]                             version <- utils::packageVersion("future")
[10:25:48.622]                         }
[10:25:48.622]                         else {
[10:25:48.622]                           version <- NULL
[10:25:48.622]                         }
[10:25:48.622]                         if (!has_future || version < "1.8.0") {
[10:25:48.622]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.622]                             "", base::R.version$version.string), 
[10:25:48.622]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.622]                               "release", "version")], collapse = " "), 
[10:25:48.622]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.622]                             info)
[10:25:48.622]                           info <- base::paste(info, collapse = "; ")
[10:25:48.622]                           if (!has_future) {
[10:25:48.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.622]                               info)
[10:25:48.622]                           }
[10:25:48.622]                           else {
[10:25:48.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.622]                               info, version)
[10:25:48.622]                           }
[10:25:48.622]                           base::stop(msg)
[10:25:48.622]                         }
[10:25:48.622]                       })
[10:25:48.622]                     }
[10:25:48.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.622]                     base::options(mc.cores = 1L)
[10:25:48.622]                   }
[10:25:48.622]                   options(future.plan = NULL)
[10:25:48.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.622]                 }
[10:25:48.622]                 ...future.workdir <- getwd()
[10:25:48.622]             }
[10:25:48.622]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.622]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.622]         }
[10:25:48.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.622]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.622]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.622]             base::names(...future.oldOptions))
[10:25:48.622]     }
[10:25:48.622]     if (FALSE) {
[10:25:48.622]     }
[10:25:48.622]     else {
[10:25:48.622]         if (TRUE) {
[10:25:48.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.622]                 open = "w")
[10:25:48.622]         }
[10:25:48.622]         else {
[10:25:48.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.622]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.622]         }
[10:25:48.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.622]             base::sink(type = "output", split = FALSE)
[10:25:48.622]             base::close(...future.stdout)
[10:25:48.622]         }, add = TRUE)
[10:25:48.622]     }
[10:25:48.622]     ...future.frame <- base::sys.nframe()
[10:25:48.622]     ...future.conditions <- base::list()
[10:25:48.622]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.622]     if (FALSE) {
[10:25:48.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.622]     }
[10:25:48.622]     ...future.result <- base::tryCatch({
[10:25:48.622]         base::withCallingHandlers({
[10:25:48.622]             ...future.value <- base::withVisible(base::local({
[10:25:48.622]                 withCallingHandlers({
[10:25:48.622]                   2
[10:25:48.622]                 }, immediateCondition = function(cond) {
[10:25:48.622]                   save_rds <- function (object, pathname, ...) 
[10:25:48.622]                   {
[10:25:48.622]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.622]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.622]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.622]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.622]                         fi_tmp[["mtime"]])
[10:25:48.622]                     }
[10:25:48.622]                     tryCatch({
[10:25:48.622]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.622]                     }, error = function(ex) {
[10:25:48.622]                       msg <- conditionMessage(ex)
[10:25:48.622]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.622]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.622]                         fi_tmp[["mtime"]], msg)
[10:25:48.622]                       ex$message <- msg
[10:25:48.622]                       stop(ex)
[10:25:48.622]                     })
[10:25:48.622]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.622]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.622]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.622]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.622]                       fi <- file.info(pathname)
[10:25:48.622]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.622]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.622]                         fi[["size"]], fi[["mtime"]])
[10:25:48.622]                       stop(msg)
[10:25:48.622]                     }
[10:25:48.622]                     invisible(pathname)
[10:25:48.622]                   }
[10:25:48.622]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.622]                     rootPath = tempdir()) 
[10:25:48.622]                   {
[10:25:48.622]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.622]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.622]                       tmpdir = path, fileext = ".rds")
[10:25:48.622]                     save_rds(obj, file)
[10:25:48.622]                   }
[10:25:48.622]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.622]                   {
[10:25:48.622]                     inherits <- base::inherits
[10:25:48.622]                     invokeRestart <- base::invokeRestart
[10:25:48.622]                     is.null <- base::is.null
[10:25:48.622]                     muffled <- FALSE
[10:25:48.622]                     if (inherits(cond, "message")) {
[10:25:48.622]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.622]                       if (muffled) 
[10:25:48.622]                         invokeRestart("muffleMessage")
[10:25:48.622]                     }
[10:25:48.622]                     else if (inherits(cond, "warning")) {
[10:25:48.622]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.622]                       if (muffled) 
[10:25:48.622]                         invokeRestart("muffleWarning")
[10:25:48.622]                     }
[10:25:48.622]                     else if (inherits(cond, "condition")) {
[10:25:48.622]                       if (!is.null(pattern)) {
[10:25:48.622]                         computeRestarts <- base::computeRestarts
[10:25:48.622]                         grepl <- base::grepl
[10:25:48.622]                         restarts <- computeRestarts(cond)
[10:25:48.622]                         for (restart in restarts) {
[10:25:48.622]                           name <- restart$name
[10:25:48.622]                           if (is.null(name)) 
[10:25:48.622]                             next
[10:25:48.622]                           if (!grepl(pattern, name)) 
[10:25:48.622]                             next
[10:25:48.622]                           invokeRestart(restart)
[10:25:48.622]                           muffled <- TRUE
[10:25:48.622]                           break
[10:25:48.622]                         }
[10:25:48.622]                       }
[10:25:48.622]                     }
[10:25:48.622]                     invisible(muffled)
[10:25:48.622]                   }
[10:25:48.622]                   muffleCondition(cond)
[10:25:48.622]                 })
[10:25:48.622]             }))
[10:25:48.622]             future::FutureResult(value = ...future.value$value, 
[10:25:48.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.622]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.622]                     ...future.globalenv.names))
[10:25:48.622]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.622]         }, condition = base::local({
[10:25:48.622]             c <- base::c
[10:25:48.622]             inherits <- base::inherits
[10:25:48.622]             invokeRestart <- base::invokeRestart
[10:25:48.622]             length <- base::length
[10:25:48.622]             list <- base::list
[10:25:48.622]             seq.int <- base::seq.int
[10:25:48.622]             signalCondition <- base::signalCondition
[10:25:48.622]             sys.calls <- base::sys.calls
[10:25:48.622]             `[[` <- base::`[[`
[10:25:48.622]             `+` <- base::`+`
[10:25:48.622]             `<<-` <- base::`<<-`
[10:25:48.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.622]                   3L)]
[10:25:48.622]             }
[10:25:48.622]             function(cond) {
[10:25:48.622]                 is_error <- inherits(cond, "error")
[10:25:48.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.622]                   NULL)
[10:25:48.622]                 if (is_error) {
[10:25:48.622]                   sessionInformation <- function() {
[10:25:48.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.622]                       search = base::search(), system = base::Sys.info())
[10:25:48.622]                   }
[10:25:48.622]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.622]                     cond$call), session = sessionInformation(), 
[10:25:48.622]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.622]                   signalCondition(cond)
[10:25:48.622]                 }
[10:25:48.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.622]                 "immediateCondition"))) {
[10:25:48.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.622]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.622]                   if (TRUE && !signal) {
[10:25:48.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.622]                     {
[10:25:48.622]                       inherits <- base::inherits
[10:25:48.622]                       invokeRestart <- base::invokeRestart
[10:25:48.622]                       is.null <- base::is.null
[10:25:48.622]                       muffled <- FALSE
[10:25:48.622]                       if (inherits(cond, "message")) {
[10:25:48.622]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.622]                         if (muffled) 
[10:25:48.622]                           invokeRestart("muffleMessage")
[10:25:48.622]                       }
[10:25:48.622]                       else if (inherits(cond, "warning")) {
[10:25:48.622]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.622]                         if (muffled) 
[10:25:48.622]                           invokeRestart("muffleWarning")
[10:25:48.622]                       }
[10:25:48.622]                       else if (inherits(cond, "condition")) {
[10:25:48.622]                         if (!is.null(pattern)) {
[10:25:48.622]                           computeRestarts <- base::computeRestarts
[10:25:48.622]                           grepl <- base::grepl
[10:25:48.622]                           restarts <- computeRestarts(cond)
[10:25:48.622]                           for (restart in restarts) {
[10:25:48.622]                             name <- restart$name
[10:25:48.622]                             if (is.null(name)) 
[10:25:48.622]                               next
[10:25:48.622]                             if (!grepl(pattern, name)) 
[10:25:48.622]                               next
[10:25:48.622]                             invokeRestart(restart)
[10:25:48.622]                             muffled <- TRUE
[10:25:48.622]                             break
[10:25:48.622]                           }
[10:25:48.622]                         }
[10:25:48.622]                       }
[10:25:48.622]                       invisible(muffled)
[10:25:48.622]                     }
[10:25:48.622]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.622]                   }
[10:25:48.622]                 }
[10:25:48.622]                 else {
[10:25:48.622]                   if (TRUE) {
[10:25:48.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.622]                     {
[10:25:48.622]                       inherits <- base::inherits
[10:25:48.622]                       invokeRestart <- base::invokeRestart
[10:25:48.622]                       is.null <- base::is.null
[10:25:48.622]                       muffled <- FALSE
[10:25:48.622]                       if (inherits(cond, "message")) {
[10:25:48.622]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.622]                         if (muffled) 
[10:25:48.622]                           invokeRestart("muffleMessage")
[10:25:48.622]                       }
[10:25:48.622]                       else if (inherits(cond, "warning")) {
[10:25:48.622]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.622]                         if (muffled) 
[10:25:48.622]                           invokeRestart("muffleWarning")
[10:25:48.622]                       }
[10:25:48.622]                       else if (inherits(cond, "condition")) {
[10:25:48.622]                         if (!is.null(pattern)) {
[10:25:48.622]                           computeRestarts <- base::computeRestarts
[10:25:48.622]                           grepl <- base::grepl
[10:25:48.622]                           restarts <- computeRestarts(cond)
[10:25:48.622]                           for (restart in restarts) {
[10:25:48.622]                             name <- restart$name
[10:25:48.622]                             if (is.null(name)) 
[10:25:48.622]                               next
[10:25:48.622]                             if (!grepl(pattern, name)) 
[10:25:48.622]                               next
[10:25:48.622]                             invokeRestart(restart)
[10:25:48.622]                             muffled <- TRUE
[10:25:48.622]                             break
[10:25:48.622]                           }
[10:25:48.622]                         }
[10:25:48.622]                       }
[10:25:48.622]                       invisible(muffled)
[10:25:48.622]                     }
[10:25:48.622]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.622]                   }
[10:25:48.622]                 }
[10:25:48.622]             }
[10:25:48.622]         }))
[10:25:48.622]     }, error = function(ex) {
[10:25:48.622]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.622]                 ...future.rng), started = ...future.startTime, 
[10:25:48.622]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.622]             version = "1.8"), class = "FutureResult")
[10:25:48.622]     }, finally = {
[10:25:48.622]         if (!identical(...future.workdir, getwd())) 
[10:25:48.622]             setwd(...future.workdir)
[10:25:48.622]         {
[10:25:48.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.622]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.622]             }
[10:25:48.622]             base::options(...future.oldOptions)
[10:25:48.622]             if (.Platform$OS.type == "windows") {
[10:25:48.622]                 old_names <- names(...future.oldEnvVars)
[10:25:48.622]                 envs <- base::Sys.getenv()
[10:25:48.622]                 names <- names(envs)
[10:25:48.622]                 common <- intersect(names, old_names)
[10:25:48.622]                 added <- setdiff(names, old_names)
[10:25:48.622]                 removed <- setdiff(old_names, names)
[10:25:48.622]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.622]                   envs[common]]
[10:25:48.622]                 NAMES <- toupper(changed)
[10:25:48.622]                 args <- list()
[10:25:48.622]                 for (kk in seq_along(NAMES)) {
[10:25:48.622]                   name <- changed[[kk]]
[10:25:48.622]                   NAME <- NAMES[[kk]]
[10:25:48.622]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.622]                     next
[10:25:48.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.622]                 }
[10:25:48.622]                 NAMES <- toupper(added)
[10:25:48.622]                 for (kk in seq_along(NAMES)) {
[10:25:48.622]                   name <- added[[kk]]
[10:25:48.622]                   NAME <- NAMES[[kk]]
[10:25:48.622]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.622]                     next
[10:25:48.622]                   args[[name]] <- ""
[10:25:48.622]                 }
[10:25:48.622]                 NAMES <- toupper(removed)
[10:25:48.622]                 for (kk in seq_along(NAMES)) {
[10:25:48.622]                   name <- removed[[kk]]
[10:25:48.622]                   NAME <- NAMES[[kk]]
[10:25:48.622]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.622]                     next
[10:25:48.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.622]                 }
[10:25:48.622]                 if (length(args) > 0) 
[10:25:48.622]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.622]             }
[10:25:48.622]             else {
[10:25:48.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.622]             }
[10:25:48.622]             {
[10:25:48.622]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.622]                   0L) {
[10:25:48.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.622]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.622]                   base::options(opts)
[10:25:48.622]                 }
[10:25:48.622]                 {
[10:25:48.622]                   {
[10:25:48.622]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.622]                     NULL
[10:25:48.622]                   }
[10:25:48.622]                   options(future.plan = NULL)
[10:25:48.622]                   if (is.na(NA_character_)) 
[10:25:48.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.622]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.622]                     envir = parent.frame()) 
[10:25:48.622]                   {
[10:25:48.622]                     default_workers <- missing(workers)
[10:25:48.622]                     if (is.function(workers)) 
[10:25:48.622]                       workers <- workers()
[10:25:48.622]                     workers <- structure(as.integer(workers), 
[10:25:48.622]                       class = class(workers))
[10:25:48.622]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.622]                       1L)
[10:25:48.622]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.622]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.622]                       if (default_workers) 
[10:25:48.622]                         supportsMulticore(warn = TRUE)
[10:25:48.622]                       return(sequential(..., envir = envir))
[10:25:48.622]                     }
[10:25:48.622]                     oopts <- options(mc.cores = workers)
[10:25:48.622]                     on.exit(options(oopts))
[10:25:48.622]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.622]                       envir = envir)
[10:25:48.622]                     if (!future$lazy) 
[10:25:48.622]                       future <- run(future)
[10:25:48.622]                     invisible(future)
[10:25:48.622]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.622]                 }
[10:25:48.622]             }
[10:25:48.622]         }
[10:25:48.622]     })
[10:25:48.622]     if (TRUE) {
[10:25:48.622]         base::sink(type = "output", split = FALSE)
[10:25:48.622]         if (TRUE) {
[10:25:48.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.622]         }
[10:25:48.622]         else {
[10:25:48.622]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.622]         }
[10:25:48.622]         base::close(...future.stdout)
[10:25:48.622]         ...future.stdout <- NULL
[10:25:48.622]     }
[10:25:48.622]     ...future.result$conditions <- ...future.conditions
[10:25:48.622]     ...future.result$finished <- base::Sys.time()
[10:25:48.622]     ...future.result
[10:25:48.622] }
[10:25:48.624] requestCore(): workers = 2
[10:25:48.627] MulticoreFuture started
[10:25:48.627] - Launch lazy future ... done
[10:25:48.627] run() for ‘MulticoreFuture’ ... done
[10:25:48.627] getGlobalsAndPackages() ...
[10:25:48.628] Searching for globals...
[10:25:48.628] plan(): Setting new future strategy stack:
[10:25:48.628] 
[10:25:48.628] List of future strategies:
[10:25:48.628] 1. sequential:
[10:25:48.628]    - args: function (..., envir = parent.frame())
[10:25:48.628]    - tweaked: FALSE
[10:25:48.628]    - call: NULL
[10:25:48.628] Searching for globals ... DONE
[10:25:48.629] - globals: [0] <none>
[10:25:48.629] plan(): nbrOfWorkers() = 1
[10:25:48.629] getGlobalsAndPackages() ... DONE
[10:25:48.629] run() for ‘Future’ ...
[10:25:48.629] - state: ‘created’
[10:25:48.630] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.630] plan(): Setting new future strategy stack:
[10:25:48.631] List of future strategies:
[10:25:48.631] 1. multicore:
[10:25:48.631]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.631]    - tweaked: FALSE
[10:25:48.631]    - call: plan(strategy)
[10:25:48.635] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.635] plan(): nbrOfWorkers() = 2
[10:25:48.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.635]   - Field: ‘label’
[10:25:48.635]   - Field: ‘local’
[10:25:48.635]   - Field: ‘owner’
[10:25:48.636]   - Field: ‘envir’
[10:25:48.636]   - Field: ‘workers’
[10:25:48.636]   - Field: ‘packages’
[10:25:48.636]   - Field: ‘gc’
[10:25:48.636]   - Field: ‘job’
[10:25:48.636]   - Field: ‘conditions’
[10:25:48.637]   - Field: ‘expr’
[10:25:48.637]   - Field: ‘uuid’
[10:25:48.637]   - Field: ‘seed’
[10:25:48.637]   - Field: ‘version’
[10:25:48.637]   - Field: ‘result’
[10:25:48.637]   - Field: ‘asynchronous’
[10:25:48.638]   - Field: ‘calls’
[10:25:48.638]   - Field: ‘globals’
[10:25:48.638]   - Field: ‘stdout’
[10:25:48.638]   - Field: ‘earlySignal’
[10:25:48.638]   - Field: ‘lazy’
[10:25:48.638]   - Field: ‘state’
[10:25:48.638] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.639] - Launch lazy future ...
[10:25:48.639] Packages needed by the future expression (n = 0): <none>
[10:25:48.639] Packages needed by future strategies (n = 0): <none>
[10:25:48.640] {
[10:25:48.640]     {
[10:25:48.640]         {
[10:25:48.640]             ...future.startTime <- base::Sys.time()
[10:25:48.640]             {
[10:25:48.640]                 {
[10:25:48.640]                   {
[10:25:48.640]                     {
[10:25:48.640]                       base::local({
[10:25:48.640]                         has_future <- base::requireNamespace("future", 
[10:25:48.640]                           quietly = TRUE)
[10:25:48.640]                         if (has_future) {
[10:25:48.640]                           ns <- base::getNamespace("future")
[10:25:48.640]                           version <- ns[[".package"]][["version"]]
[10:25:48.640]                           if (is.null(version)) 
[10:25:48.640]                             version <- utils::packageVersion("future")
[10:25:48.640]                         }
[10:25:48.640]                         else {
[10:25:48.640]                           version <- NULL
[10:25:48.640]                         }
[10:25:48.640]                         if (!has_future || version < "1.8.0") {
[10:25:48.640]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.640]                             "", base::R.version$version.string), 
[10:25:48.640]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.640]                               "release", "version")], collapse = " "), 
[10:25:48.640]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.640]                             info)
[10:25:48.640]                           info <- base::paste(info, collapse = "; ")
[10:25:48.640]                           if (!has_future) {
[10:25:48.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.640]                               info)
[10:25:48.640]                           }
[10:25:48.640]                           else {
[10:25:48.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.640]                               info, version)
[10:25:48.640]                           }
[10:25:48.640]                           base::stop(msg)
[10:25:48.640]                         }
[10:25:48.640]                       })
[10:25:48.640]                     }
[10:25:48.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.640]                     base::options(mc.cores = 1L)
[10:25:48.640]                   }
[10:25:48.640]                   options(future.plan = NULL)
[10:25:48.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.640]                 }
[10:25:48.640]                 ...future.workdir <- getwd()
[10:25:48.640]             }
[10:25:48.640]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.640]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.640]         }
[10:25:48.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.640]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.640]             base::names(...future.oldOptions))
[10:25:48.640]     }
[10:25:48.640]     if (FALSE) {
[10:25:48.640]     }
[10:25:48.640]     else {
[10:25:48.640]         if (TRUE) {
[10:25:48.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.640]                 open = "w")
[10:25:48.640]         }
[10:25:48.640]         else {
[10:25:48.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.640]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.640]         }
[10:25:48.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.640]             base::sink(type = "output", split = FALSE)
[10:25:48.640]             base::close(...future.stdout)
[10:25:48.640]         }, add = TRUE)
[10:25:48.640]     }
[10:25:48.640]     ...future.frame <- base::sys.nframe()
[10:25:48.640]     ...future.conditions <- base::list()
[10:25:48.640]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.640]     if (FALSE) {
[10:25:48.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.640]     }
[10:25:48.640]     ...future.result <- base::tryCatch({
[10:25:48.640]         base::withCallingHandlers({
[10:25:48.640]             ...future.value <- base::withVisible(base::local({
[10:25:48.640]                 withCallingHandlers({
[10:25:48.640]                   NULL
[10:25:48.640]                 }, immediateCondition = function(cond) {
[10:25:48.640]                   save_rds <- function (object, pathname, ...) 
[10:25:48.640]                   {
[10:25:48.640]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.640]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.640]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.640]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.640]                         fi_tmp[["mtime"]])
[10:25:48.640]                     }
[10:25:48.640]                     tryCatch({
[10:25:48.640]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.640]                     }, error = function(ex) {
[10:25:48.640]                       msg <- conditionMessage(ex)
[10:25:48.640]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.640]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.640]                         fi_tmp[["mtime"]], msg)
[10:25:48.640]                       ex$message <- msg
[10:25:48.640]                       stop(ex)
[10:25:48.640]                     })
[10:25:48.640]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.640]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.640]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.640]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.640]                       fi <- file.info(pathname)
[10:25:48.640]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.640]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.640]                         fi[["size"]], fi[["mtime"]])
[10:25:48.640]                       stop(msg)
[10:25:48.640]                     }
[10:25:48.640]                     invisible(pathname)
[10:25:48.640]                   }
[10:25:48.640]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.640]                     rootPath = tempdir()) 
[10:25:48.640]                   {
[10:25:48.640]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.640]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.640]                       tmpdir = path, fileext = ".rds")
[10:25:48.640]                     save_rds(obj, file)
[10:25:48.640]                   }
[10:25:48.640]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.640]                   {
[10:25:48.640]                     inherits <- base::inherits
[10:25:48.640]                     invokeRestart <- base::invokeRestart
[10:25:48.640]                     is.null <- base::is.null
[10:25:48.640]                     muffled <- FALSE
[10:25:48.640]                     if (inherits(cond, "message")) {
[10:25:48.640]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.640]                       if (muffled) 
[10:25:48.640]                         invokeRestart("muffleMessage")
[10:25:48.640]                     }
[10:25:48.640]                     else if (inherits(cond, "warning")) {
[10:25:48.640]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.640]                       if (muffled) 
[10:25:48.640]                         invokeRestart("muffleWarning")
[10:25:48.640]                     }
[10:25:48.640]                     else if (inherits(cond, "condition")) {
[10:25:48.640]                       if (!is.null(pattern)) {
[10:25:48.640]                         computeRestarts <- base::computeRestarts
[10:25:48.640]                         grepl <- base::grepl
[10:25:48.640]                         restarts <- computeRestarts(cond)
[10:25:48.640]                         for (restart in restarts) {
[10:25:48.640]                           name <- restart$name
[10:25:48.640]                           if (is.null(name)) 
[10:25:48.640]                             next
[10:25:48.640]                           if (!grepl(pattern, name)) 
[10:25:48.640]                             next
[10:25:48.640]                           invokeRestart(restart)
[10:25:48.640]                           muffled <- TRUE
[10:25:48.640]                           break
[10:25:48.640]                         }
[10:25:48.640]                       }
[10:25:48.640]                     }
[10:25:48.640]                     invisible(muffled)
[10:25:48.640]                   }
[10:25:48.640]                   muffleCondition(cond)
[10:25:48.640]                 })
[10:25:48.640]             }))
[10:25:48.640]             future::FutureResult(value = ...future.value$value, 
[10:25:48.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.640]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.640]                     ...future.globalenv.names))
[10:25:48.640]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.640]         }, condition = base::local({
[10:25:48.640]             c <- base::c
[10:25:48.640]             inherits <- base::inherits
[10:25:48.640]             invokeRestart <- base::invokeRestart
[10:25:48.640]             length <- base::length
[10:25:48.640]             list <- base::list
[10:25:48.640]             seq.int <- base::seq.int
[10:25:48.640]             signalCondition <- base::signalCondition
[10:25:48.640]             sys.calls <- base::sys.calls
[10:25:48.640]             `[[` <- base::`[[`
[10:25:48.640]             `+` <- base::`+`
[10:25:48.640]             `<<-` <- base::`<<-`
[10:25:48.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.640]                   3L)]
[10:25:48.640]             }
[10:25:48.640]             function(cond) {
[10:25:48.640]                 is_error <- inherits(cond, "error")
[10:25:48.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.640]                   NULL)
[10:25:48.640]                 if (is_error) {
[10:25:48.640]                   sessionInformation <- function() {
[10:25:48.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.640]                       search = base::search(), system = base::Sys.info())
[10:25:48.640]                   }
[10:25:48.640]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.640]                     cond$call), session = sessionInformation(), 
[10:25:48.640]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.640]                   signalCondition(cond)
[10:25:48.640]                 }
[10:25:48.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.640]                 "immediateCondition"))) {
[10:25:48.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.640]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.640]                   if (TRUE && !signal) {
[10:25:48.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.640]                     {
[10:25:48.640]                       inherits <- base::inherits
[10:25:48.640]                       invokeRestart <- base::invokeRestart
[10:25:48.640]                       is.null <- base::is.null
[10:25:48.640]                       muffled <- FALSE
[10:25:48.640]                       if (inherits(cond, "message")) {
[10:25:48.640]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.640]                         if (muffled) 
[10:25:48.640]                           invokeRestart("muffleMessage")
[10:25:48.640]                       }
[10:25:48.640]                       else if (inherits(cond, "warning")) {
[10:25:48.640]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.640]                         if (muffled) 
[10:25:48.640]                           invokeRestart("muffleWarning")
[10:25:48.640]                       }
[10:25:48.640]                       else if (inherits(cond, "condition")) {
[10:25:48.640]                         if (!is.null(pattern)) {
[10:25:48.640]                           computeRestarts <- base::computeRestarts
[10:25:48.640]                           grepl <- base::grepl
[10:25:48.640]                           restarts <- computeRestarts(cond)
[10:25:48.640]                           for (restart in restarts) {
[10:25:48.640]                             name <- restart$name
[10:25:48.640]                             if (is.null(name)) 
[10:25:48.640]                               next
[10:25:48.640]                             if (!grepl(pattern, name)) 
[10:25:48.640]                               next
[10:25:48.640]                             invokeRestart(restart)
[10:25:48.640]                             muffled <- TRUE
[10:25:48.640]                             break
[10:25:48.640]                           }
[10:25:48.640]                         }
[10:25:48.640]                       }
[10:25:48.640]                       invisible(muffled)
[10:25:48.640]                     }
[10:25:48.640]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.640]                   }
[10:25:48.640]                 }
[10:25:48.640]                 else {
[10:25:48.640]                   if (TRUE) {
[10:25:48.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.640]                     {
[10:25:48.640]                       inherits <- base::inherits
[10:25:48.640]                       invokeRestart <- base::invokeRestart
[10:25:48.640]                       is.null <- base::is.null
[10:25:48.640]                       muffled <- FALSE
[10:25:48.640]                       if (inherits(cond, "message")) {
[10:25:48.640]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.640]                         if (muffled) 
[10:25:48.640]                           invokeRestart("muffleMessage")
[10:25:48.640]                       }
[10:25:48.640]                       else if (inherits(cond, "warning")) {
[10:25:48.640]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.640]                         if (muffled) 
[10:25:48.640]                           invokeRestart("muffleWarning")
[10:25:48.640]                       }
[10:25:48.640]                       else if (inherits(cond, "condition")) {
[10:25:48.640]                         if (!is.null(pattern)) {
[10:25:48.640]                           computeRestarts <- base::computeRestarts
[10:25:48.640]                           grepl <- base::grepl
[10:25:48.640]                           restarts <- computeRestarts(cond)
[10:25:48.640]                           for (restart in restarts) {
[10:25:48.640]                             name <- restart$name
[10:25:48.640]                             if (is.null(name)) 
[10:25:48.640]                               next
[10:25:48.640]                             if (!grepl(pattern, name)) 
[10:25:48.640]                               next
[10:25:48.640]                             invokeRestart(restart)
[10:25:48.640]                             muffled <- TRUE
[10:25:48.640]                             break
[10:25:48.640]                           }
[10:25:48.640]                         }
[10:25:48.640]                       }
[10:25:48.640]                       invisible(muffled)
[10:25:48.640]                     }
[10:25:48.640]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.640]                   }
[10:25:48.640]                 }
[10:25:48.640]             }
[10:25:48.640]         }))
[10:25:48.640]     }, error = function(ex) {
[10:25:48.640]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.640]                 ...future.rng), started = ...future.startTime, 
[10:25:48.640]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.640]             version = "1.8"), class = "FutureResult")
[10:25:48.640]     }, finally = {
[10:25:48.640]         if (!identical(...future.workdir, getwd())) 
[10:25:48.640]             setwd(...future.workdir)
[10:25:48.640]         {
[10:25:48.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.640]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.640]             }
[10:25:48.640]             base::options(...future.oldOptions)
[10:25:48.640]             if (.Platform$OS.type == "windows") {
[10:25:48.640]                 old_names <- names(...future.oldEnvVars)
[10:25:48.640]                 envs <- base::Sys.getenv()
[10:25:48.640]                 names <- names(envs)
[10:25:48.640]                 common <- intersect(names, old_names)
[10:25:48.640]                 added <- setdiff(names, old_names)
[10:25:48.640]                 removed <- setdiff(old_names, names)
[10:25:48.640]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.640]                   envs[common]]
[10:25:48.640]                 NAMES <- toupper(changed)
[10:25:48.640]                 args <- list()
[10:25:48.640]                 for (kk in seq_along(NAMES)) {
[10:25:48.640]                   name <- changed[[kk]]
[10:25:48.640]                   NAME <- NAMES[[kk]]
[10:25:48.640]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.640]                     next
[10:25:48.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.640]                 }
[10:25:48.640]                 NAMES <- toupper(added)
[10:25:48.640]                 for (kk in seq_along(NAMES)) {
[10:25:48.640]                   name <- added[[kk]]
[10:25:48.640]                   NAME <- NAMES[[kk]]
[10:25:48.640]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.640]                     next
[10:25:48.640]                   args[[name]] <- ""
[10:25:48.640]                 }
[10:25:48.640]                 NAMES <- toupper(removed)
[10:25:48.640]                 for (kk in seq_along(NAMES)) {
[10:25:48.640]                   name <- removed[[kk]]
[10:25:48.640]                   NAME <- NAMES[[kk]]
[10:25:48.640]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.640]                     next
[10:25:48.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.640]                 }
[10:25:48.640]                 if (length(args) > 0) 
[10:25:48.640]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.640]             }
[10:25:48.640]             else {
[10:25:48.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.640]             }
[10:25:48.640]             {
[10:25:48.640]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.640]                   0L) {
[10:25:48.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.640]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.640]                   base::options(opts)
[10:25:48.640]                 }
[10:25:48.640]                 {
[10:25:48.640]                   {
[10:25:48.640]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.640]                     NULL
[10:25:48.640]                   }
[10:25:48.640]                   options(future.plan = NULL)
[10:25:48.640]                   if (is.na(NA_character_)) 
[10:25:48.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.640]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.640]                     envir = parent.frame()) 
[10:25:48.640]                   {
[10:25:48.640]                     default_workers <- missing(workers)
[10:25:48.640]                     if (is.function(workers)) 
[10:25:48.640]                       workers <- workers()
[10:25:48.640]                     workers <- structure(as.integer(workers), 
[10:25:48.640]                       class = class(workers))
[10:25:48.640]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.640]                       1L)
[10:25:48.640]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.640]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.640]                       if (default_workers) 
[10:25:48.640]                         supportsMulticore(warn = TRUE)
[10:25:48.640]                       return(sequential(..., envir = envir))
[10:25:48.640]                     }
[10:25:48.640]                     oopts <- options(mc.cores = workers)
[10:25:48.640]                     on.exit(options(oopts))
[10:25:48.640]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.640]                       envir = envir)
[10:25:48.640]                     if (!future$lazy) 
[10:25:48.640]                       future <- run(future)
[10:25:48.640]                     invisible(future)
[10:25:48.640]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.640]                 }
[10:25:48.640]             }
[10:25:48.640]         }
[10:25:48.640]     })
[10:25:48.640]     if (TRUE) {
[10:25:48.640]         base::sink(type = "output", split = FALSE)
[10:25:48.640]         if (TRUE) {
[10:25:48.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.640]         }
[10:25:48.640]         else {
[10:25:48.640]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.640]         }
[10:25:48.640]         base::close(...future.stdout)
[10:25:48.640]         ...future.stdout <- NULL
[10:25:48.640]     }
[10:25:48.640]     ...future.result$conditions <- ...future.conditions
[10:25:48.640]     ...future.result$finished <- base::Sys.time()
[10:25:48.640]     ...future.result
[10:25:48.640] }
[10:25:48.644] requestCore(): workers = 2
[10:25:48.646] MulticoreFuture started
[10:25:48.647] - Launch lazy future ... done
[10:25:48.647] run() for ‘MulticoreFuture’ ... done
[10:25:48.648] plan(): Setting new future strategy stack:
[10:25:48.648] getGlobalsAndPackages() ...
[10:25:48.648] Searching for globals...
[10:25:48.648] List of future strategies:
[10:25:48.648] 1. sequential:
[10:25:48.648]    - args: function (..., envir = parent.frame())
[10:25:48.648]    - tweaked: FALSE
[10:25:48.648]    - call: NULL
[10:25:48.649] plan(): nbrOfWorkers() = 1
[10:25:48.650] - globals found: [1] ‘{’
[10:25:48.650] Searching for globals ... DONE
[10:25:48.650] Resolving globals: FALSE
[10:25:48.651] 
[10:25:48.651] 
[10:25:48.651] plan(): Setting new future strategy stack:
[10:25:48.651] getGlobalsAndPackages() ... DONE
[10:25:48.651] List of future strategies:
[10:25:48.651] 1. multicore:
[10:25:48.651]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.651]    - tweaked: FALSE
[10:25:48.651]    - call: plan(strategy)
[10:25:48.652] run() for ‘Future’ ...
[10:25:48.652] - state: ‘created’
[10:25:48.652] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:48.656] plan(): nbrOfWorkers() = 2
[10:25:48.657] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:48.657] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:48.658]   - Field: ‘label’
[10:25:48.658]   - Field: ‘local’
[10:25:48.658]   - Field: ‘owner’
[10:25:48.658]   - Field: ‘envir’
[10:25:48.659]   - Field: ‘workers’
[10:25:48.659]   - Field: ‘packages’
[10:25:48.659]   - Field: ‘gc’
[10:25:48.659]   - Field: ‘job’
[10:25:48.659]   - Field: ‘conditions’
[10:25:48.660]   - Field: ‘expr’
[10:25:48.660]   - Field: ‘uuid’
[10:25:48.660]   - Field: ‘seed’
[10:25:48.660]   - Field: ‘version’
[10:25:48.661]   - Field: ‘result’
[10:25:48.661]   - Field: ‘asynchronous’
[10:25:48.661]   - Field: ‘calls’
[10:25:48.661]   - Field: ‘globals’
[10:25:48.661]   - Field: ‘stdout’
[10:25:48.662]   - Field: ‘earlySignal’
[10:25:48.662]   - Field: ‘lazy’
[10:25:48.662]   - Field: ‘state’
[10:25:48.662] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:48.662] - Launch lazy future ...
[10:25:48.663] Packages needed by the future expression (n = 0): <none>
[10:25:48.663] Packages needed by future strategies (n = 0): <none>
[10:25:48.664] {
[10:25:48.664]     {
[10:25:48.664]         {
[10:25:48.664]             ...future.startTime <- base::Sys.time()
[10:25:48.664]             {
[10:25:48.664]                 {
[10:25:48.664]                   {
[10:25:48.664]                     {
[10:25:48.664]                       base::local({
[10:25:48.664]                         has_future <- base::requireNamespace("future", 
[10:25:48.664]                           quietly = TRUE)
[10:25:48.664]                         if (has_future) {
[10:25:48.664]                           ns <- base::getNamespace("future")
[10:25:48.664]                           version <- ns[[".package"]][["version"]]
[10:25:48.664]                           if (is.null(version)) 
[10:25:48.664]                             version <- utils::packageVersion("future")
[10:25:48.664]                         }
[10:25:48.664]                         else {
[10:25:48.664]                           version <- NULL
[10:25:48.664]                         }
[10:25:48.664]                         if (!has_future || version < "1.8.0") {
[10:25:48.664]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:48.664]                             "", base::R.version$version.string), 
[10:25:48.664]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:48.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:48.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:48.664]                               "release", "version")], collapse = " "), 
[10:25:48.664]                             hostname = base::Sys.info()[["nodename"]])
[10:25:48.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:48.664]                             info)
[10:25:48.664]                           info <- base::paste(info, collapse = "; ")
[10:25:48.664]                           if (!has_future) {
[10:25:48.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:48.664]                               info)
[10:25:48.664]                           }
[10:25:48.664]                           else {
[10:25:48.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:48.664]                               info, version)
[10:25:48.664]                           }
[10:25:48.664]                           base::stop(msg)
[10:25:48.664]                         }
[10:25:48.664]                       })
[10:25:48.664]                     }
[10:25:48.664]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:48.664]                     base::options(mc.cores = 1L)
[10:25:48.664]                   }
[10:25:48.664]                   options(future.plan = NULL)
[10:25:48.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:48.664]                 }
[10:25:48.664]                 ...future.workdir <- getwd()
[10:25:48.664]             }
[10:25:48.664]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:48.664]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:48.664]         }
[10:25:48.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:48.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:48.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:48.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:48.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:48.664]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:48.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:48.664]             base::names(...future.oldOptions))
[10:25:48.664]     }
[10:25:48.664]     if (FALSE) {
[10:25:48.664]     }
[10:25:48.664]     else {
[10:25:48.664]         if (TRUE) {
[10:25:48.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:48.664]                 open = "w")
[10:25:48.664]         }
[10:25:48.664]         else {
[10:25:48.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:48.664]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:48.664]         }
[10:25:48.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:48.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:48.664]             base::sink(type = "output", split = FALSE)
[10:25:48.664]             base::close(...future.stdout)
[10:25:48.664]         }, add = TRUE)
[10:25:48.664]     }
[10:25:48.664]     ...future.frame <- base::sys.nframe()
[10:25:48.664]     ...future.conditions <- base::list()
[10:25:48.664]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:48.664]     if (FALSE) {
[10:25:48.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:48.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:48.664]     }
[10:25:48.664]     ...future.result <- base::tryCatch({
[10:25:48.664]         base::withCallingHandlers({
[10:25:48.664]             ...future.value <- base::withVisible(base::local({
[10:25:48.664]                 withCallingHandlers({
[10:25:48.664]                   {
[10:25:48.664]                     4
[10:25:48.664]                   }
[10:25:48.664]                 }, immediateCondition = function(cond) {
[10:25:48.664]                   save_rds <- function (object, pathname, ...) 
[10:25:48.664]                   {
[10:25:48.664]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:48.664]                     if (file_test("-f", pathname_tmp)) {
[10:25:48.664]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.664]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:48.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.664]                         fi_tmp[["mtime"]])
[10:25:48.664]                     }
[10:25:48.664]                     tryCatch({
[10:25:48.664]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:48.664]                     }, error = function(ex) {
[10:25:48.664]                       msg <- conditionMessage(ex)
[10:25:48.664]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.664]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:48.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.664]                         fi_tmp[["mtime"]], msg)
[10:25:48.664]                       ex$message <- msg
[10:25:48.664]                       stop(ex)
[10:25:48.664]                     })
[10:25:48.664]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:48.664]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:48.664]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:48.664]                       fi_tmp <- file.info(pathname_tmp)
[10:25:48.664]                       fi <- file.info(pathname)
[10:25:48.664]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:48.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:48.664]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:48.664]                         fi[["size"]], fi[["mtime"]])
[10:25:48.664]                       stop(msg)
[10:25:48.664]                     }
[10:25:48.664]                     invisible(pathname)
[10:25:48.664]                   }
[10:25:48.664]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:48.664]                     rootPath = tempdir()) 
[10:25:48.664]                   {
[10:25:48.664]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:48.664]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:48.664]                       tmpdir = path, fileext = ".rds")
[10:25:48.664]                     save_rds(obj, file)
[10:25:48.664]                   }
[10:25:48.664]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:48.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.664]                   {
[10:25:48.664]                     inherits <- base::inherits
[10:25:48.664]                     invokeRestart <- base::invokeRestart
[10:25:48.664]                     is.null <- base::is.null
[10:25:48.664]                     muffled <- FALSE
[10:25:48.664]                     if (inherits(cond, "message")) {
[10:25:48.664]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:48.664]                       if (muffled) 
[10:25:48.664]                         invokeRestart("muffleMessage")
[10:25:48.664]                     }
[10:25:48.664]                     else if (inherits(cond, "warning")) {
[10:25:48.664]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:48.664]                       if (muffled) 
[10:25:48.664]                         invokeRestart("muffleWarning")
[10:25:48.664]                     }
[10:25:48.664]                     else if (inherits(cond, "condition")) {
[10:25:48.664]                       if (!is.null(pattern)) {
[10:25:48.664]                         computeRestarts <- base::computeRestarts
[10:25:48.664]                         grepl <- base::grepl
[10:25:48.664]                         restarts <- computeRestarts(cond)
[10:25:48.664]                         for (restart in restarts) {
[10:25:48.664]                           name <- restart$name
[10:25:48.664]                           if (is.null(name)) 
[10:25:48.664]                             next
[10:25:48.664]                           if (!grepl(pattern, name)) 
[10:25:48.664]                             next
[10:25:48.664]                           invokeRestart(restart)
[10:25:48.664]                           muffled <- TRUE
[10:25:48.664]                           break
[10:25:48.664]                         }
[10:25:48.664]                       }
[10:25:48.664]                     }
[10:25:48.664]                     invisible(muffled)
[10:25:48.664]                   }
[10:25:48.664]                   muffleCondition(cond)
[10:25:48.664]                 })
[10:25:48.664]             }))
[10:25:48.664]             future::FutureResult(value = ...future.value$value, 
[10:25:48.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.664]                   ...future.rng), globalenv = if (FALSE) 
[10:25:48.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:48.664]                     ...future.globalenv.names))
[10:25:48.664]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:48.664]         }, condition = base::local({
[10:25:48.664]             c <- base::c
[10:25:48.664]             inherits <- base::inherits
[10:25:48.664]             invokeRestart <- base::invokeRestart
[10:25:48.664]             length <- base::length
[10:25:48.664]             list <- base::list
[10:25:48.664]             seq.int <- base::seq.int
[10:25:48.664]             signalCondition <- base::signalCondition
[10:25:48.664]             sys.calls <- base::sys.calls
[10:25:48.664]             `[[` <- base::`[[`
[10:25:48.664]             `+` <- base::`+`
[10:25:48.664]             `<<-` <- base::`<<-`
[10:25:48.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:48.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:48.664]                   3L)]
[10:25:48.664]             }
[10:25:48.664]             function(cond) {
[10:25:48.664]                 is_error <- inherits(cond, "error")
[10:25:48.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:48.664]                   NULL)
[10:25:48.664]                 if (is_error) {
[10:25:48.664]                   sessionInformation <- function() {
[10:25:48.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:48.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:48.664]                       search = base::search(), system = base::Sys.info())
[10:25:48.664]                   }
[10:25:48.664]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:48.664]                     cond$call), session = sessionInformation(), 
[10:25:48.664]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:48.664]                   signalCondition(cond)
[10:25:48.664]                 }
[10:25:48.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:48.664]                 "immediateCondition"))) {
[10:25:48.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:48.664]                   ...future.conditions[[length(...future.conditions) + 
[10:25:48.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:48.664]                   if (TRUE && !signal) {
[10:25:48.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.664]                     {
[10:25:48.664]                       inherits <- base::inherits
[10:25:48.664]                       invokeRestart <- base::invokeRestart
[10:25:48.664]                       is.null <- base::is.null
[10:25:48.664]                       muffled <- FALSE
[10:25:48.664]                       if (inherits(cond, "message")) {
[10:25:48.664]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.664]                         if (muffled) 
[10:25:48.664]                           invokeRestart("muffleMessage")
[10:25:48.664]                       }
[10:25:48.664]                       else if (inherits(cond, "warning")) {
[10:25:48.664]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.664]                         if (muffled) 
[10:25:48.664]                           invokeRestart("muffleWarning")
[10:25:48.664]                       }
[10:25:48.664]                       else if (inherits(cond, "condition")) {
[10:25:48.664]                         if (!is.null(pattern)) {
[10:25:48.664]                           computeRestarts <- base::computeRestarts
[10:25:48.664]                           grepl <- base::grepl
[10:25:48.664]                           restarts <- computeRestarts(cond)
[10:25:48.664]                           for (restart in restarts) {
[10:25:48.664]                             name <- restart$name
[10:25:48.664]                             if (is.null(name)) 
[10:25:48.664]                               next
[10:25:48.664]                             if (!grepl(pattern, name)) 
[10:25:48.664]                               next
[10:25:48.664]                             invokeRestart(restart)
[10:25:48.664]                             muffled <- TRUE
[10:25:48.664]                             break
[10:25:48.664]                           }
[10:25:48.664]                         }
[10:25:48.664]                       }
[10:25:48.664]                       invisible(muffled)
[10:25:48.664]                     }
[10:25:48.664]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.664]                   }
[10:25:48.664]                 }
[10:25:48.664]                 else {
[10:25:48.664]                   if (TRUE) {
[10:25:48.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:48.664]                     {
[10:25:48.664]                       inherits <- base::inherits
[10:25:48.664]                       invokeRestart <- base::invokeRestart
[10:25:48.664]                       is.null <- base::is.null
[10:25:48.664]                       muffled <- FALSE
[10:25:48.664]                       if (inherits(cond, "message")) {
[10:25:48.664]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:48.664]                         if (muffled) 
[10:25:48.664]                           invokeRestart("muffleMessage")
[10:25:48.664]                       }
[10:25:48.664]                       else if (inherits(cond, "warning")) {
[10:25:48.664]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:48.664]                         if (muffled) 
[10:25:48.664]                           invokeRestart("muffleWarning")
[10:25:48.664]                       }
[10:25:48.664]                       else if (inherits(cond, "condition")) {
[10:25:48.664]                         if (!is.null(pattern)) {
[10:25:48.664]                           computeRestarts <- base::computeRestarts
[10:25:48.664]                           grepl <- base::grepl
[10:25:48.664]                           restarts <- computeRestarts(cond)
[10:25:48.664]                           for (restart in restarts) {
[10:25:48.664]                             name <- restart$name
[10:25:48.664]                             if (is.null(name)) 
[10:25:48.664]                               next
[10:25:48.664]                             if (!grepl(pattern, name)) 
[10:25:48.664]                               next
[10:25:48.664]                             invokeRestart(restart)
[10:25:48.664]                             muffled <- TRUE
[10:25:48.664]                             break
[10:25:48.664]                           }
[10:25:48.664]                         }
[10:25:48.664]                       }
[10:25:48.664]                       invisible(muffled)
[10:25:48.664]                     }
[10:25:48.664]                     muffleCondition(cond, pattern = "^muffle")
[10:25:48.664]                   }
[10:25:48.664]                 }
[10:25:48.664]             }
[10:25:48.664]         }))
[10:25:48.664]     }, error = function(ex) {
[10:25:48.664]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:48.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:48.664]                 ...future.rng), started = ...future.startTime, 
[10:25:48.664]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:48.664]             version = "1.8"), class = "FutureResult")
[10:25:48.664]     }, finally = {
[10:25:48.664]         if (!identical(...future.workdir, getwd())) 
[10:25:48.664]             setwd(...future.workdir)
[10:25:48.664]         {
[10:25:48.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:48.664]                 ...future.oldOptions$nwarnings <- NULL
[10:25:48.664]             }
[10:25:48.664]             base::options(...future.oldOptions)
[10:25:48.664]             if (.Platform$OS.type == "windows") {
[10:25:48.664]                 old_names <- names(...future.oldEnvVars)
[10:25:48.664]                 envs <- base::Sys.getenv()
[10:25:48.664]                 names <- names(envs)
[10:25:48.664]                 common <- intersect(names, old_names)
[10:25:48.664]                 added <- setdiff(names, old_names)
[10:25:48.664]                 removed <- setdiff(old_names, names)
[10:25:48.664]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:48.664]                   envs[common]]
[10:25:48.664]                 NAMES <- toupper(changed)
[10:25:48.664]                 args <- list()
[10:25:48.664]                 for (kk in seq_along(NAMES)) {
[10:25:48.664]                   name <- changed[[kk]]
[10:25:48.664]                   NAME <- NAMES[[kk]]
[10:25:48.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.664]                     next
[10:25:48.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.664]                 }
[10:25:48.664]                 NAMES <- toupper(added)
[10:25:48.664]                 for (kk in seq_along(NAMES)) {
[10:25:48.664]                   name <- added[[kk]]
[10:25:48.664]                   NAME <- NAMES[[kk]]
[10:25:48.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.664]                     next
[10:25:48.664]                   args[[name]] <- ""
[10:25:48.664]                 }
[10:25:48.664]                 NAMES <- toupper(removed)
[10:25:48.664]                 for (kk in seq_along(NAMES)) {
[10:25:48.664]                   name <- removed[[kk]]
[10:25:48.664]                   NAME <- NAMES[[kk]]
[10:25:48.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:48.664]                     next
[10:25:48.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:48.664]                 }
[10:25:48.664]                 if (length(args) > 0) 
[10:25:48.664]                   base::do.call(base::Sys.setenv, args = args)
[10:25:48.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:48.664]             }
[10:25:48.664]             else {
[10:25:48.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:48.664]             }
[10:25:48.664]             {
[10:25:48.664]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:48.664]                   0L) {
[10:25:48.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:48.664]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:48.664]                   base::options(opts)
[10:25:48.664]                 }
[10:25:48.664]                 {
[10:25:48.664]                   {
[10:25:48.664]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:48.664]                     NULL
[10:25:48.664]                   }
[10:25:48.664]                   options(future.plan = NULL)
[10:25:48.664]                   if (is.na(NA_character_)) 
[10:25:48.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:48.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:48.664]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:48.664]                     envir = parent.frame()) 
[10:25:48.664]                   {
[10:25:48.664]                     default_workers <- missing(workers)
[10:25:48.664]                     if (is.function(workers)) 
[10:25:48.664]                       workers <- workers()
[10:25:48.664]                     workers <- structure(as.integer(workers), 
[10:25:48.664]                       class = class(workers))
[10:25:48.664]                     stop_if_not(is.finite(workers), workers >= 
[10:25:48.664]                       1L)
[10:25:48.664]                     if ((workers == 1L && !inherits(workers, 
[10:25:48.664]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:48.664]                       if (default_workers) 
[10:25:48.664]                         supportsMulticore(warn = TRUE)
[10:25:48.664]                       return(sequential(..., envir = envir))
[10:25:48.664]                     }
[10:25:48.664]                     oopts <- options(mc.cores = workers)
[10:25:48.664]                     on.exit(options(oopts))
[10:25:48.664]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:48.664]                       envir = envir)
[10:25:48.664]                     if (!future$lazy) 
[10:25:48.664]                       future <- run(future)
[10:25:48.664]                     invisible(future)
[10:25:48.664]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:48.664]                 }
[10:25:48.664]             }
[10:25:48.664]         }
[10:25:48.664]     })
[10:25:48.664]     if (TRUE) {
[10:25:48.664]         base::sink(type = "output", split = FALSE)
[10:25:48.664]         if (TRUE) {
[10:25:48.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:48.664]         }
[10:25:48.664]         else {
[10:25:48.664]             ...future.result["stdout"] <- base::list(NULL)
[10:25:48.664]         }
[10:25:48.664]         base::close(...future.stdout)
[10:25:48.664]         ...future.stdout <- NULL
[10:25:48.664]     }
[10:25:48.664]     ...future.result$conditions <- ...future.conditions
[10:25:48.664]     ...future.result$finished <- base::Sys.time()
[10:25:48.664]     ...future.result
[10:25:48.664] }
[10:25:48.668] requestCore(): workers = 2
[10:25:48.669] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:48.679] result() for MulticoreFuture ...
[10:25:48.680] result() for MulticoreFuture ...
[10:25:48.680] result() for MulticoreFuture ... done
[10:25:48.681] result() for MulticoreFuture ... done
[10:25:48.681] result() for MulticoreFuture ...
[10:25:48.681] result() for MulticoreFuture ... done
[10:25:48.683] MulticoreFuture started
[10:25:48.684] - Launch lazy future ... done
[10:25:48.684] run() for ‘MulticoreFuture’ ... done
[10:25:48.685] plan(): Setting new future strategy stack:
<environment: 0x55c0f53f09e8> 
[10:25:48.685] List of future strategies:
[10:25:48.685] 1. sequential:
[10:25:48.685]    - args: function (..., envir = parent.frame())
[10:25:48.685]    - tweaked: FALSE
[10:25:48.685]    - call: NULL
[10:25:48.686] plan(): nbrOfWorkers() = 1
<environment: 0x55c0f5c90010> 
[10:25:48.689] plan(): Setting new future strategy stack:
[10:25:48.689] List of future strategies:
[10:25:48.689] 1. multicore:
[10:25:48.689]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:48.689]    - tweaked: FALSE
[10:25:48.689]    - call: plan(strategy)
[10:25:48.694] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:48.697] resolve() on environment ...
[10:25:48.697]  recursive: 0
[10:25:48.698]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:48.698] signalConditionsASAP(numeric, pos=1) ...
[10:25:48.698] - nx: 4
[10:25:48.698] - relay: TRUE
[10:25:48.698] - stdout: TRUE
[10:25:48.698] - signal: TRUE
[10:25:48.699] - resignal: FALSE
[10:25:48.699] - force: TRUE
[10:25:48.699] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.699] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.699]  - until=2
[10:25:48.699]  - relaying element #2
[10:25:48.699] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.699] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.700] signalConditionsASAP(NULL, pos=1) ... done
[10:25:48.700]  length: 3 (resolved future 1)
[10:25:48.700] Future #2
[10:25:48.700] result() for MulticoreFuture ...
[10:25:48.700] result() for MulticoreFuture ... done
[10:25:48.700] result() for MulticoreFuture ...
[10:25:48.700] result() for MulticoreFuture ... done
[10:25:48.701] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:48.701] - nx: 4
[10:25:48.701] - relay: TRUE
[10:25:48.701] - stdout: TRUE
[10:25:48.701] - signal: TRUE
[10:25:48.701] - resignal: FALSE
[10:25:48.701] - force: TRUE
[10:25:48.702] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:48.702] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:48.702]  - until=2
[10:25:48.702]  - relaying element #2
[10:25:48.702] result() for MulticoreFuture ...
[10:25:48.702] result() for MulticoreFuture ... done
[10:25:48.702] result() for MulticoreFuture ...
[10:25:48.703] result() for MulticoreFuture ... done
[10:25:48.703] result() for MulticoreFuture ...
[10:25:48.703] result() for MulticoreFuture ... done
[10:25:48.703] result() for MulticoreFuture ...
[10:25:48.703] result() for MulticoreFuture ... done
[10:25:48.703] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.703] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.704] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:48.704]  length: 2 (resolved future 2)
[10:25:48.704] Future #3
[10:25:48.704] result() for MulticoreFuture ...
[10:25:48.705] result() for MulticoreFuture ...
[10:25:48.705] result() for MulticoreFuture ... done
[10:25:48.705] result() for MulticoreFuture ... done
[10:25:48.706] result() for MulticoreFuture ...
[10:25:48.706] result() for MulticoreFuture ... done
[10:25:48.706] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:48.706] - nx: 4
[10:25:48.706] - relay: TRUE
[10:25:48.706] - stdout: TRUE
[10:25:48.707] - signal: TRUE
[10:25:48.707] - resignal: FALSE
[10:25:48.707] - force: TRUE
[10:25:48.707] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:48.707] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:48.707]  - until=3
[10:25:48.708]  - relaying element #3
[10:25:48.708] result() for MulticoreFuture ...
[10:25:48.708] result() for MulticoreFuture ... done
[10:25:48.708] result() for MulticoreFuture ...
[10:25:48.708] result() for MulticoreFuture ... done
[10:25:48.709] result() for MulticoreFuture ...
[10:25:48.709] result() for MulticoreFuture ... done
[10:25:48.709] result() for MulticoreFuture ...
[10:25:48.709] result() for MulticoreFuture ... done
[10:25:48.709] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.709] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.709] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:48.710]  length: 1 (resolved future 3)
[10:25:48.710] Future #4
[10:25:48.710] result() for MulticoreFuture ...
[10:25:48.711] result() for MulticoreFuture ...
[10:25:48.711] result() for MulticoreFuture ... done
[10:25:48.711] result() for MulticoreFuture ... done
[10:25:48.711] result() for MulticoreFuture ...
[10:25:48.711] result() for MulticoreFuture ... done
[10:25:48.711] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:48.711] - nx: 4
[10:25:48.712] - relay: TRUE
[10:25:48.712] - stdout: TRUE
[10:25:48.712] - signal: TRUE
[10:25:48.712] - resignal: FALSE
[10:25:48.712] - force: TRUE
[10:25:48.712] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:48.712] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:48.712]  - until=4
[10:25:48.712]  - relaying element #4
[10:25:48.713] result() for MulticoreFuture ...
[10:25:48.713] result() for MulticoreFuture ... done
[10:25:48.713] result() for MulticoreFuture ...
[10:25:48.713] result() for MulticoreFuture ... done
[10:25:48.713] result() for MulticoreFuture ...
[10:25:48.713] result() for MulticoreFuture ... done
[10:25:48.713] result() for MulticoreFuture ...
[10:25:48.713] result() for MulticoreFuture ... done
[10:25:48.713] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.714] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.714] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:48.714]  length: 0 (resolved future 4)
[10:25:48.714] Relaying remaining futures
[10:25:48.714] signalConditionsASAP(NULL, pos=0) ...
[10:25:48.714] - nx: 4
[10:25:48.714] - relay: TRUE
[10:25:48.714] - stdout: TRUE
[10:25:48.714] - signal: TRUE
[10:25:48.714] - resignal: FALSE
[10:25:48.715] - force: TRUE
[10:25:48.715] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.715] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:48.715] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:48.715] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:48.715] signalConditionsASAP(NULL, pos=0) ... done
[10:25:48.715] resolve() on environment ... DONE
[10:25:48.715] result() for MulticoreFuture ...
[10:25:48.715] result() for MulticoreFuture ... done
[10:25:48.716] result() for MulticoreFuture ...
[10:25:48.716] result() for MulticoreFuture ... done
[10:25:48.716] result() for MulticoreFuture ...
[10:25:48.716] result() for MulticoreFuture ... done
[10:25:48.716] result() for MulticoreFuture ...
[10:25:48.716] result() for MulticoreFuture ... done
[10:25:48.716] result() for MulticoreFuture ...
[10:25:48.716] result() for MulticoreFuture ... done
[10:25:48.716] result() for MulticoreFuture ...
[10:25:48.717] result() for MulticoreFuture ... done
<environment: 0x55c0f60ee668> 
Type of future: multisession
[10:25:48.717] plan(): Setting new future strategy stack:
[10:25:48.717] List of future strategies:
[10:25:48.717] 1. multisession:
[10:25:48.717]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:48.717]    - tweaked: FALSE
[10:25:48.717]    - call: plan(strategy)
[10:25:48.718] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:25:48.718] multisession:
[10:25:48.718] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:48.718] - tweaked: FALSE
[10:25:48.718] - call: plan(strategy)
[10:25:48.722] getGlobalsAndPackages() ...
[10:25:48.722] Not searching for globals
[10:25:48.722] - globals: [0] <none>
[10:25:48.722] getGlobalsAndPackages() ... DONE
[10:25:48.723] [local output] makeClusterPSOCK() ...
[10:25:48.726] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:25:48.727] [local output] Base port: 11568
[10:25:48.727] [local output] Getting setup options for 2 cluster nodes ...
[10:25:48.727] [local output]  - Node 1 of 2 ...
[10:25:48.727] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:48.728] [local output] Rscript port: 11568

[10:25:48.729] [local output]  - Node 2 of 2 ...
[10:25:48.729] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:48.730] [local output] Rscript port: 11568

[10:25:48.730] [local output] Getting setup options for 2 cluster nodes ... done
[10:25:48.730] [local output]  - Parallel setup requested for some PSOCK nodes
[10:25:48.730] [local output] Setting up PSOCK nodes in parallel
[10:25:48.730] List of 36
[10:25:48.730]  $ worker          : chr "localhost"
[10:25:48.730]   ..- attr(*, "localhost")= logi TRUE
[10:25:48.730]  $ master          : chr "localhost"
[10:25:48.730]  $ port            : int 11568
[10:25:48.730]  $ connectTimeout  : num 120
[10:25:48.730]  $ timeout         : num 2592000
[10:25:48.730]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:25:48.730]  $ homogeneous     : logi TRUE
[10:25:48.730]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:25:48.730]  $ rscript_envs    : NULL
[10:25:48.730]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:48.730]  $ rscript_startup : NULL
[10:25:48.730]  $ rscript_sh      : chr "sh"
[10:25:48.730]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:48.730]  $ methods         : logi TRUE
[10:25:48.730]  $ socketOptions   : chr "no-delay"
[10:25:48.730]  $ useXDR          : logi FALSE
[10:25:48.730]  $ outfile         : chr "/dev/null"
[10:25:48.730]  $ renice          : int NA
[10:25:48.730]  $ rshcmd          : NULL
[10:25:48.730]  $ user            : chr(0) 
[10:25:48.730]  $ revtunnel       : logi FALSE
[10:25:48.730]  $ rshlogfile      : NULL
[10:25:48.730]  $ rshopts         : chr(0) 
[10:25:48.730]  $ rank            : int 1
[10:25:48.730]  $ manual          : logi FALSE
[10:25:48.730]  $ dryrun          : logi FALSE
[10:25:48.730]  $ quiet           : logi FALSE
[10:25:48.730]  $ setup_strategy  : chr "parallel"
[10:25:48.730]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:48.730]  $ pidfile         : chr "/tmp/Rtmpt2gjBk/worker.rank=1.parallelly.parent=83526.1464651c3c62a.pid"
[10:25:48.730]  $ rshcmd_label    : NULL
[10:25:48.730]  $ rsh_call        : NULL
[10:25:48.730]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:48.730]  $ localMachine    : logi TRUE
[10:25:48.730]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:25:48.730]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:25:48.730]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:25:48.730]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:25:48.730]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:25:48.730]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:25:48.730]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:25:48.730]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:25:48.730]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:25:48.730]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:25:48.730]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:25:48.730]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:25:48.730]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:25:48.730]  $ arguments       :List of 28
[10:25:48.730]   ..$ worker          : chr "localhost"
[10:25:48.730]   ..$ master          : NULL
[10:25:48.730]   ..$ port            : int 11568
[10:25:48.730]   ..$ connectTimeout  : num 120
[10:25:48.730]   ..$ timeout         : num 2592000
[10:25:48.730]   ..$ rscript         : NULL
[10:25:48.730]   ..$ homogeneous     : NULL
[10:25:48.730]   ..$ rscript_args    : NULL
[10:25:48.730]   ..$ rscript_envs    : NULL
[10:25:48.730]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:48.730]   ..$ rscript_startup : NULL
[10:25:48.730]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:25:48.730]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:48.730]   ..$ methods         : logi TRUE
[10:25:48.730]   ..$ socketOptions   : chr "no-delay"
[10:25:48.730]   ..$ useXDR          : logi FALSE
[10:25:48.730]   ..$ outfile         : chr "/dev/null"
[10:25:48.730]   ..$ renice          : int NA
[10:25:48.730]   ..$ rshcmd          : NULL
[10:25:48.730]   ..$ user            : NULL
[10:25:48.730]   ..$ revtunnel       : logi NA
[10:25:48.730]   ..$ rshlogfile      : NULL
[10:25:48.730]   ..$ rshopts         : NULL
[10:25:48.730]   ..$ rank            : int 1
[10:25:48.730]   ..$ manual          : logi FALSE
[10:25:48.730]   ..$ dryrun          : logi FALSE
[10:25:48.730]   ..$ quiet           : logi FALSE
[10:25:48.730]   ..$ setup_strategy  : chr "parallel"
[10:25:48.730]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:25:48.754] [local output] System call to launch all workers:
[10:25:48.754] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpt2gjBk/worker.rank=1.parallelly.parent=83526.1464651c3c62a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11568 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:25:48.754] [local output] Starting PSOCK main server
[10:25:48.755] [local output] Workers launched
[10:25:48.755] [local output] Waiting for workers to connect back
[10:25:48.756]  - [local output] 0 workers out of 2 ready
[10:25:49.022]  - [local output] 0 workers out of 2 ready
[10:25:49.023]  - [local output] 1 workers out of 2 ready
[10:25:49.024]  - [local output] 1 workers out of 2 ready
[10:25:49.025]  - [local output] 2 workers out of 2 ready
[10:25:49.025] [local output] Launching of workers completed
[10:25:49.025] [local output] Collecting session information from workers
[10:25:49.026] [local output]  - Worker #1 of 2
[10:25:49.026] [local output]  - Worker #2 of 2
[10:25:49.027] [local output] makeClusterPSOCK() ... done
[10:25:49.038] Packages needed by the future expression (n = 0): <none>
[10:25:49.038] Packages needed by future strategies (n = 0): <none>
[10:25:49.039] {
[10:25:49.039]     {
[10:25:49.039]         {
[10:25:49.039]             ...future.startTime <- base::Sys.time()
[10:25:49.039]             {
[10:25:49.039]                 {
[10:25:49.039]                   {
[10:25:49.039]                     {
[10:25:49.039]                       base::local({
[10:25:49.039]                         has_future <- base::requireNamespace("future", 
[10:25:49.039]                           quietly = TRUE)
[10:25:49.039]                         if (has_future) {
[10:25:49.039]                           ns <- base::getNamespace("future")
[10:25:49.039]                           version <- ns[[".package"]][["version"]]
[10:25:49.039]                           if (is.null(version)) 
[10:25:49.039]                             version <- utils::packageVersion("future")
[10:25:49.039]                         }
[10:25:49.039]                         else {
[10:25:49.039]                           version <- NULL
[10:25:49.039]                         }
[10:25:49.039]                         if (!has_future || version < "1.8.0") {
[10:25:49.039]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.039]                             "", base::R.version$version.string), 
[10:25:49.039]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.039]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.039]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.039]                               "release", "version")], collapse = " "), 
[10:25:49.039]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.039]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.039]                             info)
[10:25:49.039]                           info <- base::paste(info, collapse = "; ")
[10:25:49.039]                           if (!has_future) {
[10:25:49.039]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.039]                               info)
[10:25:49.039]                           }
[10:25:49.039]                           else {
[10:25:49.039]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.039]                               info, version)
[10:25:49.039]                           }
[10:25:49.039]                           base::stop(msg)
[10:25:49.039]                         }
[10:25:49.039]                       })
[10:25:49.039]                     }
[10:25:49.039]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.039]                     base::options(mc.cores = 1L)
[10:25:49.039]                   }
[10:25:49.039]                   options(future.plan = NULL)
[10:25:49.039]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.039]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.039]                 }
[10:25:49.039]                 ...future.workdir <- getwd()
[10:25:49.039]             }
[10:25:49.039]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.039]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.039]         }
[10:25:49.039]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.039]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.039]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.039]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.039]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.039]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.039]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.039]             base::names(...future.oldOptions))
[10:25:49.039]     }
[10:25:49.039]     if (FALSE) {
[10:25:49.039]     }
[10:25:49.039]     else {
[10:25:49.039]         if (TRUE) {
[10:25:49.039]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.039]                 open = "w")
[10:25:49.039]         }
[10:25:49.039]         else {
[10:25:49.039]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.039]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.039]         }
[10:25:49.039]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.039]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.039]             base::sink(type = "output", split = FALSE)
[10:25:49.039]             base::close(...future.stdout)
[10:25:49.039]         }, add = TRUE)
[10:25:49.039]     }
[10:25:49.039]     ...future.frame <- base::sys.nframe()
[10:25:49.039]     ...future.conditions <- base::list()
[10:25:49.039]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.039]     if (FALSE) {
[10:25:49.039]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.039]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.039]     }
[10:25:49.039]     ...future.result <- base::tryCatch({
[10:25:49.039]         base::withCallingHandlers({
[10:25:49.039]             ...future.value <- base::withVisible(base::local({
[10:25:49.039]                 ...future.makeSendCondition <- base::local({
[10:25:49.039]                   sendCondition <- NULL
[10:25:49.039]                   function(frame = 1L) {
[10:25:49.039]                     if (is.function(sendCondition)) 
[10:25:49.039]                       return(sendCondition)
[10:25:49.039]                     ns <- getNamespace("parallel")
[10:25:49.039]                     if (exists("sendData", mode = "function", 
[10:25:49.039]                       envir = ns)) {
[10:25:49.039]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.039]                         envir = ns)
[10:25:49.039]                       envir <- sys.frame(frame)
[10:25:49.039]                       master <- NULL
[10:25:49.039]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.039]                         !identical(envir, emptyenv())) {
[10:25:49.039]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.039]                           inherits = FALSE)) {
[10:25:49.039]                           master <- get("master", mode = "list", 
[10:25:49.039]                             envir = envir, inherits = FALSE)
[10:25:49.039]                           if (inherits(master, c("SOCKnode", 
[10:25:49.039]                             "SOCK0node"))) {
[10:25:49.039]                             sendCondition <<- function(cond) {
[10:25:49.039]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.039]                                 success = TRUE)
[10:25:49.039]                               parallel_sendData(master, data)
[10:25:49.039]                             }
[10:25:49.039]                             return(sendCondition)
[10:25:49.039]                           }
[10:25:49.039]                         }
[10:25:49.039]                         frame <- frame + 1L
[10:25:49.039]                         envir <- sys.frame(frame)
[10:25:49.039]                       }
[10:25:49.039]                     }
[10:25:49.039]                     sendCondition <<- function(cond) NULL
[10:25:49.039]                   }
[10:25:49.039]                 })
[10:25:49.039]                 withCallingHandlers({
[10:25:49.039]                   NA
[10:25:49.039]                 }, immediateCondition = function(cond) {
[10:25:49.039]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.039]                   sendCondition(cond)
[10:25:49.039]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.039]                   {
[10:25:49.039]                     inherits <- base::inherits
[10:25:49.039]                     invokeRestart <- base::invokeRestart
[10:25:49.039]                     is.null <- base::is.null
[10:25:49.039]                     muffled <- FALSE
[10:25:49.039]                     if (inherits(cond, "message")) {
[10:25:49.039]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.039]                       if (muffled) 
[10:25:49.039]                         invokeRestart("muffleMessage")
[10:25:49.039]                     }
[10:25:49.039]                     else if (inherits(cond, "warning")) {
[10:25:49.039]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.039]                       if (muffled) 
[10:25:49.039]                         invokeRestart("muffleWarning")
[10:25:49.039]                     }
[10:25:49.039]                     else if (inherits(cond, "condition")) {
[10:25:49.039]                       if (!is.null(pattern)) {
[10:25:49.039]                         computeRestarts <- base::computeRestarts
[10:25:49.039]                         grepl <- base::grepl
[10:25:49.039]                         restarts <- computeRestarts(cond)
[10:25:49.039]                         for (restart in restarts) {
[10:25:49.039]                           name <- restart$name
[10:25:49.039]                           if (is.null(name)) 
[10:25:49.039]                             next
[10:25:49.039]                           if (!grepl(pattern, name)) 
[10:25:49.039]                             next
[10:25:49.039]                           invokeRestart(restart)
[10:25:49.039]                           muffled <- TRUE
[10:25:49.039]                           break
[10:25:49.039]                         }
[10:25:49.039]                       }
[10:25:49.039]                     }
[10:25:49.039]                     invisible(muffled)
[10:25:49.039]                   }
[10:25:49.039]                   muffleCondition(cond)
[10:25:49.039]                 })
[10:25:49.039]             }))
[10:25:49.039]             future::FutureResult(value = ...future.value$value, 
[10:25:49.039]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.039]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.039]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.039]                     ...future.globalenv.names))
[10:25:49.039]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.039]         }, condition = base::local({
[10:25:49.039]             c <- base::c
[10:25:49.039]             inherits <- base::inherits
[10:25:49.039]             invokeRestart <- base::invokeRestart
[10:25:49.039]             length <- base::length
[10:25:49.039]             list <- base::list
[10:25:49.039]             seq.int <- base::seq.int
[10:25:49.039]             signalCondition <- base::signalCondition
[10:25:49.039]             sys.calls <- base::sys.calls
[10:25:49.039]             `[[` <- base::`[[`
[10:25:49.039]             `+` <- base::`+`
[10:25:49.039]             `<<-` <- base::`<<-`
[10:25:49.039]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.039]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.039]                   3L)]
[10:25:49.039]             }
[10:25:49.039]             function(cond) {
[10:25:49.039]                 is_error <- inherits(cond, "error")
[10:25:49.039]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.039]                   NULL)
[10:25:49.039]                 if (is_error) {
[10:25:49.039]                   sessionInformation <- function() {
[10:25:49.039]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.039]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.039]                       search = base::search(), system = base::Sys.info())
[10:25:49.039]                   }
[10:25:49.039]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.039]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.039]                     cond$call), session = sessionInformation(), 
[10:25:49.039]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.039]                   signalCondition(cond)
[10:25:49.039]                 }
[10:25:49.039]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.039]                 "immediateCondition"))) {
[10:25:49.039]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.039]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.039]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.039]                   if (TRUE && !signal) {
[10:25:49.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.039]                     {
[10:25:49.039]                       inherits <- base::inherits
[10:25:49.039]                       invokeRestart <- base::invokeRestart
[10:25:49.039]                       is.null <- base::is.null
[10:25:49.039]                       muffled <- FALSE
[10:25:49.039]                       if (inherits(cond, "message")) {
[10:25:49.039]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.039]                         if (muffled) 
[10:25:49.039]                           invokeRestart("muffleMessage")
[10:25:49.039]                       }
[10:25:49.039]                       else if (inherits(cond, "warning")) {
[10:25:49.039]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.039]                         if (muffled) 
[10:25:49.039]                           invokeRestart("muffleWarning")
[10:25:49.039]                       }
[10:25:49.039]                       else if (inherits(cond, "condition")) {
[10:25:49.039]                         if (!is.null(pattern)) {
[10:25:49.039]                           computeRestarts <- base::computeRestarts
[10:25:49.039]                           grepl <- base::grepl
[10:25:49.039]                           restarts <- computeRestarts(cond)
[10:25:49.039]                           for (restart in restarts) {
[10:25:49.039]                             name <- restart$name
[10:25:49.039]                             if (is.null(name)) 
[10:25:49.039]                               next
[10:25:49.039]                             if (!grepl(pattern, name)) 
[10:25:49.039]                               next
[10:25:49.039]                             invokeRestart(restart)
[10:25:49.039]                             muffled <- TRUE
[10:25:49.039]                             break
[10:25:49.039]                           }
[10:25:49.039]                         }
[10:25:49.039]                       }
[10:25:49.039]                       invisible(muffled)
[10:25:49.039]                     }
[10:25:49.039]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.039]                   }
[10:25:49.039]                 }
[10:25:49.039]                 else {
[10:25:49.039]                   if (TRUE) {
[10:25:49.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.039]                     {
[10:25:49.039]                       inherits <- base::inherits
[10:25:49.039]                       invokeRestart <- base::invokeRestart
[10:25:49.039]                       is.null <- base::is.null
[10:25:49.039]                       muffled <- FALSE
[10:25:49.039]                       if (inherits(cond, "message")) {
[10:25:49.039]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.039]                         if (muffled) 
[10:25:49.039]                           invokeRestart("muffleMessage")
[10:25:49.039]                       }
[10:25:49.039]                       else if (inherits(cond, "warning")) {
[10:25:49.039]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.039]                         if (muffled) 
[10:25:49.039]                           invokeRestart("muffleWarning")
[10:25:49.039]                       }
[10:25:49.039]                       else if (inherits(cond, "condition")) {
[10:25:49.039]                         if (!is.null(pattern)) {
[10:25:49.039]                           computeRestarts <- base::computeRestarts
[10:25:49.039]                           grepl <- base::grepl
[10:25:49.039]                           restarts <- computeRestarts(cond)
[10:25:49.039]                           for (restart in restarts) {
[10:25:49.039]                             name <- restart$name
[10:25:49.039]                             if (is.null(name)) 
[10:25:49.039]                               next
[10:25:49.039]                             if (!grepl(pattern, name)) 
[10:25:49.039]                               next
[10:25:49.039]                             invokeRestart(restart)
[10:25:49.039]                             muffled <- TRUE
[10:25:49.039]                             break
[10:25:49.039]                           }
[10:25:49.039]                         }
[10:25:49.039]                       }
[10:25:49.039]                       invisible(muffled)
[10:25:49.039]                     }
[10:25:49.039]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.039]                   }
[10:25:49.039]                 }
[10:25:49.039]             }
[10:25:49.039]         }))
[10:25:49.039]     }, error = function(ex) {
[10:25:49.039]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.039]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.039]                 ...future.rng), started = ...future.startTime, 
[10:25:49.039]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.039]             version = "1.8"), class = "FutureResult")
[10:25:49.039]     }, finally = {
[10:25:49.039]         if (!identical(...future.workdir, getwd())) 
[10:25:49.039]             setwd(...future.workdir)
[10:25:49.039]         {
[10:25:49.039]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.039]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.039]             }
[10:25:49.039]             base::options(...future.oldOptions)
[10:25:49.039]             if (.Platform$OS.type == "windows") {
[10:25:49.039]                 old_names <- names(...future.oldEnvVars)
[10:25:49.039]                 envs <- base::Sys.getenv()
[10:25:49.039]                 names <- names(envs)
[10:25:49.039]                 common <- intersect(names, old_names)
[10:25:49.039]                 added <- setdiff(names, old_names)
[10:25:49.039]                 removed <- setdiff(old_names, names)
[10:25:49.039]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.039]                   envs[common]]
[10:25:49.039]                 NAMES <- toupper(changed)
[10:25:49.039]                 args <- list()
[10:25:49.039]                 for (kk in seq_along(NAMES)) {
[10:25:49.039]                   name <- changed[[kk]]
[10:25:49.039]                   NAME <- NAMES[[kk]]
[10:25:49.039]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.039]                     next
[10:25:49.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.039]                 }
[10:25:49.039]                 NAMES <- toupper(added)
[10:25:49.039]                 for (kk in seq_along(NAMES)) {
[10:25:49.039]                   name <- added[[kk]]
[10:25:49.039]                   NAME <- NAMES[[kk]]
[10:25:49.039]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.039]                     next
[10:25:49.039]                   args[[name]] <- ""
[10:25:49.039]                 }
[10:25:49.039]                 NAMES <- toupper(removed)
[10:25:49.039]                 for (kk in seq_along(NAMES)) {
[10:25:49.039]                   name <- removed[[kk]]
[10:25:49.039]                   NAME <- NAMES[[kk]]
[10:25:49.039]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.039]                     next
[10:25:49.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.039]                 }
[10:25:49.039]                 if (length(args) > 0) 
[10:25:49.039]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.039]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.039]             }
[10:25:49.039]             else {
[10:25:49.039]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.039]             }
[10:25:49.039]             {
[10:25:49.039]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.039]                   0L) {
[10:25:49.039]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.039]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.039]                   base::options(opts)
[10:25:49.039]                 }
[10:25:49.039]                 {
[10:25:49.039]                   {
[10:25:49.039]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.039]                     NULL
[10:25:49.039]                   }
[10:25:49.039]                   options(future.plan = NULL)
[10:25:49.039]                   if (is.na(NA_character_)) 
[10:25:49.039]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.039]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.039]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.039]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.039]                     envir = parent.frame()) 
[10:25:49.039]                   {
[10:25:49.039]                     if (is.function(workers)) 
[10:25:49.039]                       workers <- workers()
[10:25:49.039]                     workers <- structure(as.integer(workers), 
[10:25:49.039]                       class = class(workers))
[10:25:49.039]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.039]                       workers >= 1)
[10:25:49.039]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.039]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.039]                     }
[10:25:49.039]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.039]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.039]                       envir = envir)
[10:25:49.039]                     if (!future$lazy) 
[10:25:49.039]                       future <- run(future)
[10:25:49.039]                     invisible(future)
[10:25:49.039]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.039]                 }
[10:25:49.039]             }
[10:25:49.039]         }
[10:25:49.039]     })
[10:25:49.039]     if (TRUE) {
[10:25:49.039]         base::sink(type = "output", split = FALSE)
[10:25:49.039]         if (TRUE) {
[10:25:49.039]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.039]         }
[10:25:49.039]         else {
[10:25:49.039]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.039]         }
[10:25:49.039]         base::close(...future.stdout)
[10:25:49.039]         ...future.stdout <- NULL
[10:25:49.039]     }
[10:25:49.039]     ...future.result$conditions <- ...future.conditions
[10:25:49.039]     ...future.result$finished <- base::Sys.time()
[10:25:49.039]     ...future.result
[10:25:49.039] }
[10:25:49.093] MultisessionFuture started
[10:25:49.093] result() for ClusterFuture ...
[10:25:49.093] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.093] - Validating connection of MultisessionFuture
[10:25:49.137] - received message: FutureResult
[10:25:49.137] - Received FutureResult
[10:25:49.137] - Erased future from FutureRegistry
[10:25:49.137] result() for ClusterFuture ...
[10:25:49.138] - result already collected: FutureResult
[10:25:49.138] result() for ClusterFuture ... done
[10:25:49.138] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.138] result() for ClusterFuture ... done
[10:25:49.138] result() for ClusterFuture ...
[10:25:49.138] - result already collected: FutureResult
[10:25:49.138] result() for ClusterFuture ... done
[10:25:49.138] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:25:49.142] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:25:49.142] getGlobalsAndPackages() ...
[10:25:49.143] Searching for globals...
[10:25:49.143] 
[10:25:49.143] Searching for globals ... DONE
[10:25:49.143] - globals: [0] <none>
[10:25:49.143] getGlobalsAndPackages() ... DONE
[10:25:49.144] run() for ‘Future’ ...
[10:25:49.144] - state: ‘created’
[10:25:49.144] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.158] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.159]   - Field: ‘node’
[10:25:49.159]   - Field: ‘label’
[10:25:49.159]   - Field: ‘local’
[10:25:49.159]   - Field: ‘owner’
[10:25:49.159]   - Field: ‘envir’
[10:25:49.159]   - Field: ‘workers’
[10:25:49.159]   - Field: ‘packages’
[10:25:49.159]   - Field: ‘gc’
[10:25:49.159]   - Field: ‘conditions’
[10:25:49.160]   - Field: ‘persistent’
[10:25:49.160]   - Field: ‘expr’
[10:25:49.160]   - Field: ‘uuid’
[10:25:49.160]   - Field: ‘seed’
[10:25:49.160]   - Field: ‘version’
[10:25:49.160]   - Field: ‘result’
[10:25:49.160]   - Field: ‘asynchronous’
[10:25:49.160]   - Field: ‘calls’
[10:25:49.160]   - Field: ‘globals’
[10:25:49.161]   - Field: ‘stdout’
[10:25:49.161]   - Field: ‘earlySignal’
[10:25:49.161]   - Field: ‘lazy’
[10:25:49.161]   - Field: ‘state’
[10:25:49.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.161] - Launch lazy future ...
[10:25:49.161] Packages needed by the future expression (n = 0): <none>
[10:25:49.162] Packages needed by future strategies (n = 0): <none>
[10:25:49.162] {
[10:25:49.162]     {
[10:25:49.162]         {
[10:25:49.162]             ...future.startTime <- base::Sys.time()
[10:25:49.162]             {
[10:25:49.162]                 {
[10:25:49.162]                   {
[10:25:49.162]                     {
[10:25:49.162]                       base::local({
[10:25:49.162]                         has_future <- base::requireNamespace("future", 
[10:25:49.162]                           quietly = TRUE)
[10:25:49.162]                         if (has_future) {
[10:25:49.162]                           ns <- base::getNamespace("future")
[10:25:49.162]                           version <- ns[[".package"]][["version"]]
[10:25:49.162]                           if (is.null(version)) 
[10:25:49.162]                             version <- utils::packageVersion("future")
[10:25:49.162]                         }
[10:25:49.162]                         else {
[10:25:49.162]                           version <- NULL
[10:25:49.162]                         }
[10:25:49.162]                         if (!has_future || version < "1.8.0") {
[10:25:49.162]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.162]                             "", base::R.version$version.string), 
[10:25:49.162]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.162]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.162]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.162]                               "release", "version")], collapse = " "), 
[10:25:49.162]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.162]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.162]                             info)
[10:25:49.162]                           info <- base::paste(info, collapse = "; ")
[10:25:49.162]                           if (!has_future) {
[10:25:49.162]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.162]                               info)
[10:25:49.162]                           }
[10:25:49.162]                           else {
[10:25:49.162]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.162]                               info, version)
[10:25:49.162]                           }
[10:25:49.162]                           base::stop(msg)
[10:25:49.162]                         }
[10:25:49.162]                       })
[10:25:49.162]                     }
[10:25:49.162]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.162]                     base::options(mc.cores = 1L)
[10:25:49.162]                   }
[10:25:49.162]                   options(future.plan = NULL)
[10:25:49.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.162]                 }
[10:25:49.162]                 ...future.workdir <- getwd()
[10:25:49.162]             }
[10:25:49.162]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.162]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.162]         }
[10:25:49.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.162]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.162]             base::names(...future.oldOptions))
[10:25:49.162]     }
[10:25:49.162]     if (FALSE) {
[10:25:49.162]     }
[10:25:49.162]     else {
[10:25:49.162]         if (TRUE) {
[10:25:49.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.162]                 open = "w")
[10:25:49.162]         }
[10:25:49.162]         else {
[10:25:49.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.162]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.162]         }
[10:25:49.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.162]             base::sink(type = "output", split = FALSE)
[10:25:49.162]             base::close(...future.stdout)
[10:25:49.162]         }, add = TRUE)
[10:25:49.162]     }
[10:25:49.162]     ...future.frame <- base::sys.nframe()
[10:25:49.162]     ...future.conditions <- base::list()
[10:25:49.162]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.162]     if (FALSE) {
[10:25:49.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.162]     }
[10:25:49.162]     ...future.result <- base::tryCatch({
[10:25:49.162]         base::withCallingHandlers({
[10:25:49.162]             ...future.value <- base::withVisible(base::local({
[10:25:49.162]                 ...future.makeSendCondition <- base::local({
[10:25:49.162]                   sendCondition <- NULL
[10:25:49.162]                   function(frame = 1L) {
[10:25:49.162]                     if (is.function(sendCondition)) 
[10:25:49.162]                       return(sendCondition)
[10:25:49.162]                     ns <- getNamespace("parallel")
[10:25:49.162]                     if (exists("sendData", mode = "function", 
[10:25:49.162]                       envir = ns)) {
[10:25:49.162]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.162]                         envir = ns)
[10:25:49.162]                       envir <- sys.frame(frame)
[10:25:49.162]                       master <- NULL
[10:25:49.162]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.162]                         !identical(envir, emptyenv())) {
[10:25:49.162]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.162]                           inherits = FALSE)) {
[10:25:49.162]                           master <- get("master", mode = "list", 
[10:25:49.162]                             envir = envir, inherits = FALSE)
[10:25:49.162]                           if (inherits(master, c("SOCKnode", 
[10:25:49.162]                             "SOCK0node"))) {
[10:25:49.162]                             sendCondition <<- function(cond) {
[10:25:49.162]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.162]                                 success = TRUE)
[10:25:49.162]                               parallel_sendData(master, data)
[10:25:49.162]                             }
[10:25:49.162]                             return(sendCondition)
[10:25:49.162]                           }
[10:25:49.162]                         }
[10:25:49.162]                         frame <- frame + 1L
[10:25:49.162]                         envir <- sys.frame(frame)
[10:25:49.162]                       }
[10:25:49.162]                     }
[10:25:49.162]                     sendCondition <<- function(cond) NULL
[10:25:49.162]                   }
[10:25:49.162]                 })
[10:25:49.162]                 withCallingHandlers({
[10:25:49.162]                   2
[10:25:49.162]                 }, immediateCondition = function(cond) {
[10:25:49.162]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.162]                   sendCondition(cond)
[10:25:49.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.162]                   {
[10:25:49.162]                     inherits <- base::inherits
[10:25:49.162]                     invokeRestart <- base::invokeRestart
[10:25:49.162]                     is.null <- base::is.null
[10:25:49.162]                     muffled <- FALSE
[10:25:49.162]                     if (inherits(cond, "message")) {
[10:25:49.162]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.162]                       if (muffled) 
[10:25:49.162]                         invokeRestart("muffleMessage")
[10:25:49.162]                     }
[10:25:49.162]                     else if (inherits(cond, "warning")) {
[10:25:49.162]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.162]                       if (muffled) 
[10:25:49.162]                         invokeRestart("muffleWarning")
[10:25:49.162]                     }
[10:25:49.162]                     else if (inherits(cond, "condition")) {
[10:25:49.162]                       if (!is.null(pattern)) {
[10:25:49.162]                         computeRestarts <- base::computeRestarts
[10:25:49.162]                         grepl <- base::grepl
[10:25:49.162]                         restarts <- computeRestarts(cond)
[10:25:49.162]                         for (restart in restarts) {
[10:25:49.162]                           name <- restart$name
[10:25:49.162]                           if (is.null(name)) 
[10:25:49.162]                             next
[10:25:49.162]                           if (!grepl(pattern, name)) 
[10:25:49.162]                             next
[10:25:49.162]                           invokeRestart(restart)
[10:25:49.162]                           muffled <- TRUE
[10:25:49.162]                           break
[10:25:49.162]                         }
[10:25:49.162]                       }
[10:25:49.162]                     }
[10:25:49.162]                     invisible(muffled)
[10:25:49.162]                   }
[10:25:49.162]                   muffleCondition(cond)
[10:25:49.162]                 })
[10:25:49.162]             }))
[10:25:49.162]             future::FutureResult(value = ...future.value$value, 
[10:25:49.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.162]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.162]                     ...future.globalenv.names))
[10:25:49.162]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.162]         }, condition = base::local({
[10:25:49.162]             c <- base::c
[10:25:49.162]             inherits <- base::inherits
[10:25:49.162]             invokeRestart <- base::invokeRestart
[10:25:49.162]             length <- base::length
[10:25:49.162]             list <- base::list
[10:25:49.162]             seq.int <- base::seq.int
[10:25:49.162]             signalCondition <- base::signalCondition
[10:25:49.162]             sys.calls <- base::sys.calls
[10:25:49.162]             `[[` <- base::`[[`
[10:25:49.162]             `+` <- base::`+`
[10:25:49.162]             `<<-` <- base::`<<-`
[10:25:49.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.162]                   3L)]
[10:25:49.162]             }
[10:25:49.162]             function(cond) {
[10:25:49.162]                 is_error <- inherits(cond, "error")
[10:25:49.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.162]                   NULL)
[10:25:49.162]                 if (is_error) {
[10:25:49.162]                   sessionInformation <- function() {
[10:25:49.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.162]                       search = base::search(), system = base::Sys.info())
[10:25:49.162]                   }
[10:25:49.162]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.162]                     cond$call), session = sessionInformation(), 
[10:25:49.162]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.162]                   signalCondition(cond)
[10:25:49.162]                 }
[10:25:49.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.162]                 "immediateCondition"))) {
[10:25:49.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.162]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.162]                   if (TRUE && !signal) {
[10:25:49.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.162]                     {
[10:25:49.162]                       inherits <- base::inherits
[10:25:49.162]                       invokeRestart <- base::invokeRestart
[10:25:49.162]                       is.null <- base::is.null
[10:25:49.162]                       muffled <- FALSE
[10:25:49.162]                       if (inherits(cond, "message")) {
[10:25:49.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.162]                         if (muffled) 
[10:25:49.162]                           invokeRestart("muffleMessage")
[10:25:49.162]                       }
[10:25:49.162]                       else if (inherits(cond, "warning")) {
[10:25:49.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.162]                         if (muffled) 
[10:25:49.162]                           invokeRestart("muffleWarning")
[10:25:49.162]                       }
[10:25:49.162]                       else if (inherits(cond, "condition")) {
[10:25:49.162]                         if (!is.null(pattern)) {
[10:25:49.162]                           computeRestarts <- base::computeRestarts
[10:25:49.162]                           grepl <- base::grepl
[10:25:49.162]                           restarts <- computeRestarts(cond)
[10:25:49.162]                           for (restart in restarts) {
[10:25:49.162]                             name <- restart$name
[10:25:49.162]                             if (is.null(name)) 
[10:25:49.162]                               next
[10:25:49.162]                             if (!grepl(pattern, name)) 
[10:25:49.162]                               next
[10:25:49.162]                             invokeRestart(restart)
[10:25:49.162]                             muffled <- TRUE
[10:25:49.162]                             break
[10:25:49.162]                           }
[10:25:49.162]                         }
[10:25:49.162]                       }
[10:25:49.162]                       invisible(muffled)
[10:25:49.162]                     }
[10:25:49.162]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.162]                   }
[10:25:49.162]                 }
[10:25:49.162]                 else {
[10:25:49.162]                   if (TRUE) {
[10:25:49.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.162]                     {
[10:25:49.162]                       inherits <- base::inherits
[10:25:49.162]                       invokeRestart <- base::invokeRestart
[10:25:49.162]                       is.null <- base::is.null
[10:25:49.162]                       muffled <- FALSE
[10:25:49.162]                       if (inherits(cond, "message")) {
[10:25:49.162]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.162]                         if (muffled) 
[10:25:49.162]                           invokeRestart("muffleMessage")
[10:25:49.162]                       }
[10:25:49.162]                       else if (inherits(cond, "warning")) {
[10:25:49.162]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.162]                         if (muffled) 
[10:25:49.162]                           invokeRestart("muffleWarning")
[10:25:49.162]                       }
[10:25:49.162]                       else if (inherits(cond, "condition")) {
[10:25:49.162]                         if (!is.null(pattern)) {
[10:25:49.162]                           computeRestarts <- base::computeRestarts
[10:25:49.162]                           grepl <- base::grepl
[10:25:49.162]                           restarts <- computeRestarts(cond)
[10:25:49.162]                           for (restart in restarts) {
[10:25:49.162]                             name <- restart$name
[10:25:49.162]                             if (is.null(name)) 
[10:25:49.162]                               next
[10:25:49.162]                             if (!grepl(pattern, name)) 
[10:25:49.162]                               next
[10:25:49.162]                             invokeRestart(restart)
[10:25:49.162]                             muffled <- TRUE
[10:25:49.162]                             break
[10:25:49.162]                           }
[10:25:49.162]                         }
[10:25:49.162]                       }
[10:25:49.162]                       invisible(muffled)
[10:25:49.162]                     }
[10:25:49.162]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.162]                   }
[10:25:49.162]                 }
[10:25:49.162]             }
[10:25:49.162]         }))
[10:25:49.162]     }, error = function(ex) {
[10:25:49.162]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.162]                 ...future.rng), started = ...future.startTime, 
[10:25:49.162]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.162]             version = "1.8"), class = "FutureResult")
[10:25:49.162]     }, finally = {
[10:25:49.162]         if (!identical(...future.workdir, getwd())) 
[10:25:49.162]             setwd(...future.workdir)
[10:25:49.162]         {
[10:25:49.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.162]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.162]             }
[10:25:49.162]             base::options(...future.oldOptions)
[10:25:49.162]             if (.Platform$OS.type == "windows") {
[10:25:49.162]                 old_names <- names(...future.oldEnvVars)
[10:25:49.162]                 envs <- base::Sys.getenv()
[10:25:49.162]                 names <- names(envs)
[10:25:49.162]                 common <- intersect(names, old_names)
[10:25:49.162]                 added <- setdiff(names, old_names)
[10:25:49.162]                 removed <- setdiff(old_names, names)
[10:25:49.162]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.162]                   envs[common]]
[10:25:49.162]                 NAMES <- toupper(changed)
[10:25:49.162]                 args <- list()
[10:25:49.162]                 for (kk in seq_along(NAMES)) {
[10:25:49.162]                   name <- changed[[kk]]
[10:25:49.162]                   NAME <- NAMES[[kk]]
[10:25:49.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.162]                     next
[10:25:49.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.162]                 }
[10:25:49.162]                 NAMES <- toupper(added)
[10:25:49.162]                 for (kk in seq_along(NAMES)) {
[10:25:49.162]                   name <- added[[kk]]
[10:25:49.162]                   NAME <- NAMES[[kk]]
[10:25:49.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.162]                     next
[10:25:49.162]                   args[[name]] <- ""
[10:25:49.162]                 }
[10:25:49.162]                 NAMES <- toupper(removed)
[10:25:49.162]                 for (kk in seq_along(NAMES)) {
[10:25:49.162]                   name <- removed[[kk]]
[10:25:49.162]                   NAME <- NAMES[[kk]]
[10:25:49.162]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.162]                     next
[10:25:49.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.162]                 }
[10:25:49.162]                 if (length(args) > 0) 
[10:25:49.162]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.162]             }
[10:25:49.162]             else {
[10:25:49.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.162]             }
[10:25:49.162]             {
[10:25:49.162]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.162]                   0L) {
[10:25:49.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.162]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.162]                   base::options(opts)
[10:25:49.162]                 }
[10:25:49.162]                 {
[10:25:49.162]                   {
[10:25:49.162]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.162]                     NULL
[10:25:49.162]                   }
[10:25:49.162]                   options(future.plan = NULL)
[10:25:49.162]                   if (is.na(NA_character_)) 
[10:25:49.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.162]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.162]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.162]                     envir = parent.frame()) 
[10:25:49.162]                   {
[10:25:49.162]                     if (is.function(workers)) 
[10:25:49.162]                       workers <- workers()
[10:25:49.162]                     workers <- structure(as.integer(workers), 
[10:25:49.162]                       class = class(workers))
[10:25:49.162]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.162]                       workers >= 1)
[10:25:49.162]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.162]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.162]                     }
[10:25:49.162]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.162]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.162]                       envir = envir)
[10:25:49.162]                     if (!future$lazy) 
[10:25:49.162]                       future <- run(future)
[10:25:49.162]                     invisible(future)
[10:25:49.162]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.162]                 }
[10:25:49.162]             }
[10:25:49.162]         }
[10:25:49.162]     })
[10:25:49.162]     if (TRUE) {
[10:25:49.162]         base::sink(type = "output", split = FALSE)
[10:25:49.162]         if (TRUE) {
[10:25:49.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.162]         }
[10:25:49.162]         else {
[10:25:49.162]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.162]         }
[10:25:49.162]         base::close(...future.stdout)
[10:25:49.162]         ...future.stdout <- NULL
[10:25:49.162]     }
[10:25:49.162]     ...future.result$conditions <- ...future.conditions
[10:25:49.162]     ...future.result$finished <- base::Sys.time()
[10:25:49.162]     ...future.result
[10:25:49.162] }
[10:25:49.165] MultisessionFuture started
[10:25:49.165] - Launch lazy future ... done
[10:25:49.166] run() for ‘MultisessionFuture’ ... done
[10:25:49.166] getGlobalsAndPackages() ...
[10:25:49.166] Searching for globals...
[10:25:49.166] 
[10:25:49.166] Searching for globals ... DONE
[10:25:49.166] - globals: [0] <none>
[10:25:49.167] getGlobalsAndPackages() ... DONE
[10:25:49.167] run() for ‘Future’ ...
[10:25:49.167] - state: ‘created’
[10:25:49.167] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.183] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.183] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.184]   - Field: ‘node’
[10:25:49.184]   - Field: ‘label’
[10:25:49.184]   - Field: ‘local’
[10:25:49.184]   - Field: ‘owner’
[10:25:49.184]   - Field: ‘envir’
[10:25:49.184]   - Field: ‘workers’
[10:25:49.184]   - Field: ‘packages’
[10:25:49.184]   - Field: ‘gc’
[10:25:49.185]   - Field: ‘conditions’
[10:25:49.185]   - Field: ‘persistent’
[10:25:49.185]   - Field: ‘expr’
[10:25:49.185]   - Field: ‘uuid’
[10:25:49.185]   - Field: ‘seed’
[10:25:49.185]   - Field: ‘version’
[10:25:49.185]   - Field: ‘result’
[10:25:49.185]   - Field: ‘asynchronous’
[10:25:49.185]   - Field: ‘calls’
[10:25:49.186]   - Field: ‘globals’
[10:25:49.186]   - Field: ‘stdout’
[10:25:49.186]   - Field: ‘earlySignal’
[10:25:49.186]   - Field: ‘lazy’
[10:25:49.186]   - Field: ‘state’
[10:25:49.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.186] - Launch lazy future ...
[10:25:49.186] Packages needed by the future expression (n = 0): <none>
[10:25:49.187] Packages needed by future strategies (n = 0): <none>
[10:25:49.187] {
[10:25:49.187]     {
[10:25:49.187]         {
[10:25:49.187]             ...future.startTime <- base::Sys.time()
[10:25:49.187]             {
[10:25:49.187]                 {
[10:25:49.187]                   {
[10:25:49.187]                     {
[10:25:49.187]                       base::local({
[10:25:49.187]                         has_future <- base::requireNamespace("future", 
[10:25:49.187]                           quietly = TRUE)
[10:25:49.187]                         if (has_future) {
[10:25:49.187]                           ns <- base::getNamespace("future")
[10:25:49.187]                           version <- ns[[".package"]][["version"]]
[10:25:49.187]                           if (is.null(version)) 
[10:25:49.187]                             version <- utils::packageVersion("future")
[10:25:49.187]                         }
[10:25:49.187]                         else {
[10:25:49.187]                           version <- NULL
[10:25:49.187]                         }
[10:25:49.187]                         if (!has_future || version < "1.8.0") {
[10:25:49.187]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.187]                             "", base::R.version$version.string), 
[10:25:49.187]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.187]                               "release", "version")], collapse = " "), 
[10:25:49.187]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.187]                             info)
[10:25:49.187]                           info <- base::paste(info, collapse = "; ")
[10:25:49.187]                           if (!has_future) {
[10:25:49.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.187]                               info)
[10:25:49.187]                           }
[10:25:49.187]                           else {
[10:25:49.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.187]                               info, version)
[10:25:49.187]                           }
[10:25:49.187]                           base::stop(msg)
[10:25:49.187]                         }
[10:25:49.187]                       })
[10:25:49.187]                     }
[10:25:49.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.187]                     base::options(mc.cores = 1L)
[10:25:49.187]                   }
[10:25:49.187]                   options(future.plan = NULL)
[10:25:49.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.187]                 }
[10:25:49.187]                 ...future.workdir <- getwd()
[10:25:49.187]             }
[10:25:49.187]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.187]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.187]         }
[10:25:49.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.187]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.187]             base::names(...future.oldOptions))
[10:25:49.187]     }
[10:25:49.187]     if (FALSE) {
[10:25:49.187]     }
[10:25:49.187]     else {
[10:25:49.187]         if (TRUE) {
[10:25:49.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.187]                 open = "w")
[10:25:49.187]         }
[10:25:49.187]         else {
[10:25:49.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.187]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.187]         }
[10:25:49.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.187]             base::sink(type = "output", split = FALSE)
[10:25:49.187]             base::close(...future.stdout)
[10:25:49.187]         }, add = TRUE)
[10:25:49.187]     }
[10:25:49.187]     ...future.frame <- base::sys.nframe()
[10:25:49.187]     ...future.conditions <- base::list()
[10:25:49.187]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.187]     if (FALSE) {
[10:25:49.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.187]     }
[10:25:49.187]     ...future.result <- base::tryCatch({
[10:25:49.187]         base::withCallingHandlers({
[10:25:49.187]             ...future.value <- base::withVisible(base::local({
[10:25:49.187]                 ...future.makeSendCondition <- base::local({
[10:25:49.187]                   sendCondition <- NULL
[10:25:49.187]                   function(frame = 1L) {
[10:25:49.187]                     if (is.function(sendCondition)) 
[10:25:49.187]                       return(sendCondition)
[10:25:49.187]                     ns <- getNamespace("parallel")
[10:25:49.187]                     if (exists("sendData", mode = "function", 
[10:25:49.187]                       envir = ns)) {
[10:25:49.187]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.187]                         envir = ns)
[10:25:49.187]                       envir <- sys.frame(frame)
[10:25:49.187]                       master <- NULL
[10:25:49.187]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.187]                         !identical(envir, emptyenv())) {
[10:25:49.187]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.187]                           inherits = FALSE)) {
[10:25:49.187]                           master <- get("master", mode = "list", 
[10:25:49.187]                             envir = envir, inherits = FALSE)
[10:25:49.187]                           if (inherits(master, c("SOCKnode", 
[10:25:49.187]                             "SOCK0node"))) {
[10:25:49.187]                             sendCondition <<- function(cond) {
[10:25:49.187]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.187]                                 success = TRUE)
[10:25:49.187]                               parallel_sendData(master, data)
[10:25:49.187]                             }
[10:25:49.187]                             return(sendCondition)
[10:25:49.187]                           }
[10:25:49.187]                         }
[10:25:49.187]                         frame <- frame + 1L
[10:25:49.187]                         envir <- sys.frame(frame)
[10:25:49.187]                       }
[10:25:49.187]                     }
[10:25:49.187]                     sendCondition <<- function(cond) NULL
[10:25:49.187]                   }
[10:25:49.187]                 })
[10:25:49.187]                 withCallingHandlers({
[10:25:49.187]                   NULL
[10:25:49.187]                 }, immediateCondition = function(cond) {
[10:25:49.187]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.187]                   sendCondition(cond)
[10:25:49.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.187]                   {
[10:25:49.187]                     inherits <- base::inherits
[10:25:49.187]                     invokeRestart <- base::invokeRestart
[10:25:49.187]                     is.null <- base::is.null
[10:25:49.187]                     muffled <- FALSE
[10:25:49.187]                     if (inherits(cond, "message")) {
[10:25:49.187]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.187]                       if (muffled) 
[10:25:49.187]                         invokeRestart("muffleMessage")
[10:25:49.187]                     }
[10:25:49.187]                     else if (inherits(cond, "warning")) {
[10:25:49.187]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.187]                       if (muffled) 
[10:25:49.187]                         invokeRestart("muffleWarning")
[10:25:49.187]                     }
[10:25:49.187]                     else if (inherits(cond, "condition")) {
[10:25:49.187]                       if (!is.null(pattern)) {
[10:25:49.187]                         computeRestarts <- base::computeRestarts
[10:25:49.187]                         grepl <- base::grepl
[10:25:49.187]                         restarts <- computeRestarts(cond)
[10:25:49.187]                         for (restart in restarts) {
[10:25:49.187]                           name <- restart$name
[10:25:49.187]                           if (is.null(name)) 
[10:25:49.187]                             next
[10:25:49.187]                           if (!grepl(pattern, name)) 
[10:25:49.187]                             next
[10:25:49.187]                           invokeRestart(restart)
[10:25:49.187]                           muffled <- TRUE
[10:25:49.187]                           break
[10:25:49.187]                         }
[10:25:49.187]                       }
[10:25:49.187]                     }
[10:25:49.187]                     invisible(muffled)
[10:25:49.187]                   }
[10:25:49.187]                   muffleCondition(cond)
[10:25:49.187]                 })
[10:25:49.187]             }))
[10:25:49.187]             future::FutureResult(value = ...future.value$value, 
[10:25:49.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.187]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.187]                     ...future.globalenv.names))
[10:25:49.187]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.187]         }, condition = base::local({
[10:25:49.187]             c <- base::c
[10:25:49.187]             inherits <- base::inherits
[10:25:49.187]             invokeRestart <- base::invokeRestart
[10:25:49.187]             length <- base::length
[10:25:49.187]             list <- base::list
[10:25:49.187]             seq.int <- base::seq.int
[10:25:49.187]             signalCondition <- base::signalCondition
[10:25:49.187]             sys.calls <- base::sys.calls
[10:25:49.187]             `[[` <- base::`[[`
[10:25:49.187]             `+` <- base::`+`
[10:25:49.187]             `<<-` <- base::`<<-`
[10:25:49.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.187]                   3L)]
[10:25:49.187]             }
[10:25:49.187]             function(cond) {
[10:25:49.187]                 is_error <- inherits(cond, "error")
[10:25:49.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.187]                   NULL)
[10:25:49.187]                 if (is_error) {
[10:25:49.187]                   sessionInformation <- function() {
[10:25:49.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.187]                       search = base::search(), system = base::Sys.info())
[10:25:49.187]                   }
[10:25:49.187]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.187]                     cond$call), session = sessionInformation(), 
[10:25:49.187]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.187]                   signalCondition(cond)
[10:25:49.187]                 }
[10:25:49.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.187]                 "immediateCondition"))) {
[10:25:49.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.187]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.187]                   if (TRUE && !signal) {
[10:25:49.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.187]                     {
[10:25:49.187]                       inherits <- base::inherits
[10:25:49.187]                       invokeRestart <- base::invokeRestart
[10:25:49.187]                       is.null <- base::is.null
[10:25:49.187]                       muffled <- FALSE
[10:25:49.187]                       if (inherits(cond, "message")) {
[10:25:49.187]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.187]                         if (muffled) 
[10:25:49.187]                           invokeRestart("muffleMessage")
[10:25:49.187]                       }
[10:25:49.187]                       else if (inherits(cond, "warning")) {
[10:25:49.187]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.187]                         if (muffled) 
[10:25:49.187]                           invokeRestart("muffleWarning")
[10:25:49.187]                       }
[10:25:49.187]                       else if (inherits(cond, "condition")) {
[10:25:49.187]                         if (!is.null(pattern)) {
[10:25:49.187]                           computeRestarts <- base::computeRestarts
[10:25:49.187]                           grepl <- base::grepl
[10:25:49.187]                           restarts <- computeRestarts(cond)
[10:25:49.187]                           for (restart in restarts) {
[10:25:49.187]                             name <- restart$name
[10:25:49.187]                             if (is.null(name)) 
[10:25:49.187]                               next
[10:25:49.187]                             if (!grepl(pattern, name)) 
[10:25:49.187]                               next
[10:25:49.187]                             invokeRestart(restart)
[10:25:49.187]                             muffled <- TRUE
[10:25:49.187]                             break
[10:25:49.187]                           }
[10:25:49.187]                         }
[10:25:49.187]                       }
[10:25:49.187]                       invisible(muffled)
[10:25:49.187]                     }
[10:25:49.187]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.187]                   }
[10:25:49.187]                 }
[10:25:49.187]                 else {
[10:25:49.187]                   if (TRUE) {
[10:25:49.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.187]                     {
[10:25:49.187]                       inherits <- base::inherits
[10:25:49.187]                       invokeRestart <- base::invokeRestart
[10:25:49.187]                       is.null <- base::is.null
[10:25:49.187]                       muffled <- FALSE
[10:25:49.187]                       if (inherits(cond, "message")) {
[10:25:49.187]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.187]                         if (muffled) 
[10:25:49.187]                           invokeRestart("muffleMessage")
[10:25:49.187]                       }
[10:25:49.187]                       else if (inherits(cond, "warning")) {
[10:25:49.187]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.187]                         if (muffled) 
[10:25:49.187]                           invokeRestart("muffleWarning")
[10:25:49.187]                       }
[10:25:49.187]                       else if (inherits(cond, "condition")) {
[10:25:49.187]                         if (!is.null(pattern)) {
[10:25:49.187]                           computeRestarts <- base::computeRestarts
[10:25:49.187]                           grepl <- base::grepl
[10:25:49.187]                           restarts <- computeRestarts(cond)
[10:25:49.187]                           for (restart in restarts) {
[10:25:49.187]                             name <- restart$name
[10:25:49.187]                             if (is.null(name)) 
[10:25:49.187]                               next
[10:25:49.187]                             if (!grepl(pattern, name)) 
[10:25:49.187]                               next
[10:25:49.187]                             invokeRestart(restart)
[10:25:49.187]                             muffled <- TRUE
[10:25:49.187]                             break
[10:25:49.187]                           }
[10:25:49.187]                         }
[10:25:49.187]                       }
[10:25:49.187]                       invisible(muffled)
[10:25:49.187]                     }
[10:25:49.187]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.187]                   }
[10:25:49.187]                 }
[10:25:49.187]             }
[10:25:49.187]         }))
[10:25:49.187]     }, error = function(ex) {
[10:25:49.187]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.187]                 ...future.rng), started = ...future.startTime, 
[10:25:49.187]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.187]             version = "1.8"), class = "FutureResult")
[10:25:49.187]     }, finally = {
[10:25:49.187]         if (!identical(...future.workdir, getwd())) 
[10:25:49.187]             setwd(...future.workdir)
[10:25:49.187]         {
[10:25:49.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.187]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.187]             }
[10:25:49.187]             base::options(...future.oldOptions)
[10:25:49.187]             if (.Platform$OS.type == "windows") {
[10:25:49.187]                 old_names <- names(...future.oldEnvVars)
[10:25:49.187]                 envs <- base::Sys.getenv()
[10:25:49.187]                 names <- names(envs)
[10:25:49.187]                 common <- intersect(names, old_names)
[10:25:49.187]                 added <- setdiff(names, old_names)
[10:25:49.187]                 removed <- setdiff(old_names, names)
[10:25:49.187]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.187]                   envs[common]]
[10:25:49.187]                 NAMES <- toupper(changed)
[10:25:49.187]                 args <- list()
[10:25:49.187]                 for (kk in seq_along(NAMES)) {
[10:25:49.187]                   name <- changed[[kk]]
[10:25:49.187]                   NAME <- NAMES[[kk]]
[10:25:49.187]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.187]                     next
[10:25:49.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.187]                 }
[10:25:49.187]                 NAMES <- toupper(added)
[10:25:49.187]                 for (kk in seq_along(NAMES)) {
[10:25:49.187]                   name <- added[[kk]]
[10:25:49.187]                   NAME <- NAMES[[kk]]
[10:25:49.187]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.187]                     next
[10:25:49.187]                   args[[name]] <- ""
[10:25:49.187]                 }
[10:25:49.187]                 NAMES <- toupper(removed)
[10:25:49.187]                 for (kk in seq_along(NAMES)) {
[10:25:49.187]                   name <- removed[[kk]]
[10:25:49.187]                   NAME <- NAMES[[kk]]
[10:25:49.187]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.187]                     next
[10:25:49.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.187]                 }
[10:25:49.187]                 if (length(args) > 0) 
[10:25:49.187]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.187]             }
[10:25:49.187]             else {
[10:25:49.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.187]             }
[10:25:49.187]             {
[10:25:49.187]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.187]                   0L) {
[10:25:49.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.187]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.187]                   base::options(opts)
[10:25:49.187]                 }
[10:25:49.187]                 {
[10:25:49.187]                   {
[10:25:49.187]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.187]                     NULL
[10:25:49.187]                   }
[10:25:49.187]                   options(future.plan = NULL)
[10:25:49.187]                   if (is.na(NA_character_)) 
[10:25:49.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.187]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.187]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.187]                     envir = parent.frame()) 
[10:25:49.187]                   {
[10:25:49.187]                     if (is.function(workers)) 
[10:25:49.187]                       workers <- workers()
[10:25:49.187]                     workers <- structure(as.integer(workers), 
[10:25:49.187]                       class = class(workers))
[10:25:49.187]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.187]                       workers >= 1)
[10:25:49.187]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.187]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.187]                     }
[10:25:49.187]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.187]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.187]                       envir = envir)
[10:25:49.187]                     if (!future$lazy) 
[10:25:49.187]                       future <- run(future)
[10:25:49.187]                     invisible(future)
[10:25:49.187]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.187]                 }
[10:25:49.187]             }
[10:25:49.187]         }
[10:25:49.187]     })
[10:25:49.187]     if (TRUE) {
[10:25:49.187]         base::sink(type = "output", split = FALSE)
[10:25:49.187]         if (TRUE) {
[10:25:49.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.187]         }
[10:25:49.187]         else {
[10:25:49.187]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.187]         }
[10:25:49.187]         base::close(...future.stdout)
[10:25:49.187]         ...future.stdout <- NULL
[10:25:49.187]     }
[10:25:49.187]     ...future.result$conditions <- ...future.conditions
[10:25:49.187]     ...future.result$finished <- base::Sys.time()
[10:25:49.187]     ...future.result
[10:25:49.187] }
[10:25:49.241] MultisessionFuture started
[10:25:49.241] - Launch lazy future ... done
[10:25:49.241] run() for ‘MultisessionFuture’ ... done
[10:25:49.242] getGlobalsAndPackages() ...
[10:25:49.242] Searching for globals...
[10:25:49.243] - globals found: [1] ‘{’
[10:25:49.243] Searching for globals ... DONE
[10:25:49.243] Resolving globals: FALSE
[10:25:49.243] 
[10:25:49.243] 
[10:25:49.243] getGlobalsAndPackages() ... DONE
[10:25:49.244] run() for ‘Future’ ...
[10:25:49.244] - state: ‘created’
[10:25:49.244] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.262]   - Field: ‘node’
[10:25:49.262]   - Field: ‘label’
[10:25:49.262]   - Field: ‘local’
[10:25:49.262]   - Field: ‘owner’
[10:25:49.262]   - Field: ‘envir’
[10:25:49.262]   - Field: ‘workers’
[10:25:49.263]   - Field: ‘packages’
[10:25:49.263]   - Field: ‘gc’
[10:25:49.263]   - Field: ‘conditions’
[10:25:49.263]   - Field: ‘persistent’
[10:25:49.263]   - Field: ‘expr’
[10:25:49.263]   - Field: ‘uuid’
[10:25:49.264]   - Field: ‘seed’
[10:25:49.264]   - Field: ‘version’
[10:25:49.264]   - Field: ‘result’
[10:25:49.264]   - Field: ‘asynchronous’
[10:25:49.264]   - Field: ‘calls’
[10:25:49.264]   - Field: ‘globals’
[10:25:49.265]   - Field: ‘stdout’
[10:25:49.265]   - Field: ‘earlySignal’
[10:25:49.265]   - Field: ‘lazy’
[10:25:49.265]   - Field: ‘state’
[10:25:49.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.265] - Launch lazy future ...
[10:25:49.266] Packages needed by the future expression (n = 0): <none>
[10:25:49.266] Packages needed by future strategies (n = 0): <none>
[10:25:49.267] {
[10:25:49.267]     {
[10:25:49.267]         {
[10:25:49.267]             ...future.startTime <- base::Sys.time()
[10:25:49.267]             {
[10:25:49.267]                 {
[10:25:49.267]                   {
[10:25:49.267]                     {
[10:25:49.267]                       base::local({
[10:25:49.267]                         has_future <- base::requireNamespace("future", 
[10:25:49.267]                           quietly = TRUE)
[10:25:49.267]                         if (has_future) {
[10:25:49.267]                           ns <- base::getNamespace("future")
[10:25:49.267]                           version <- ns[[".package"]][["version"]]
[10:25:49.267]                           if (is.null(version)) 
[10:25:49.267]                             version <- utils::packageVersion("future")
[10:25:49.267]                         }
[10:25:49.267]                         else {
[10:25:49.267]                           version <- NULL
[10:25:49.267]                         }
[10:25:49.267]                         if (!has_future || version < "1.8.0") {
[10:25:49.267]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.267]                             "", base::R.version$version.string), 
[10:25:49.267]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.267]                               "release", "version")], collapse = " "), 
[10:25:49.267]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.267]                             info)
[10:25:49.267]                           info <- base::paste(info, collapse = "; ")
[10:25:49.267]                           if (!has_future) {
[10:25:49.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.267]                               info)
[10:25:49.267]                           }
[10:25:49.267]                           else {
[10:25:49.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.267]                               info, version)
[10:25:49.267]                           }
[10:25:49.267]                           base::stop(msg)
[10:25:49.267]                         }
[10:25:49.267]                       })
[10:25:49.267]                     }
[10:25:49.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.267]                     base::options(mc.cores = 1L)
[10:25:49.267]                   }
[10:25:49.267]                   options(future.plan = NULL)
[10:25:49.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.267]                 }
[10:25:49.267]                 ...future.workdir <- getwd()
[10:25:49.267]             }
[10:25:49.267]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.267]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.267]         }
[10:25:49.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.267]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.267]             base::names(...future.oldOptions))
[10:25:49.267]     }
[10:25:49.267]     if (FALSE) {
[10:25:49.267]     }
[10:25:49.267]     else {
[10:25:49.267]         if (TRUE) {
[10:25:49.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.267]                 open = "w")
[10:25:49.267]         }
[10:25:49.267]         else {
[10:25:49.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.267]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.267]         }
[10:25:49.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.267]             base::sink(type = "output", split = FALSE)
[10:25:49.267]             base::close(...future.stdout)
[10:25:49.267]         }, add = TRUE)
[10:25:49.267]     }
[10:25:49.267]     ...future.frame <- base::sys.nframe()
[10:25:49.267]     ...future.conditions <- base::list()
[10:25:49.267]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.267]     if (FALSE) {
[10:25:49.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.267]     }
[10:25:49.267]     ...future.result <- base::tryCatch({
[10:25:49.267]         base::withCallingHandlers({
[10:25:49.267]             ...future.value <- base::withVisible(base::local({
[10:25:49.267]                 ...future.makeSendCondition <- base::local({
[10:25:49.267]                   sendCondition <- NULL
[10:25:49.267]                   function(frame = 1L) {
[10:25:49.267]                     if (is.function(sendCondition)) 
[10:25:49.267]                       return(sendCondition)
[10:25:49.267]                     ns <- getNamespace("parallel")
[10:25:49.267]                     if (exists("sendData", mode = "function", 
[10:25:49.267]                       envir = ns)) {
[10:25:49.267]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.267]                         envir = ns)
[10:25:49.267]                       envir <- sys.frame(frame)
[10:25:49.267]                       master <- NULL
[10:25:49.267]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.267]                         !identical(envir, emptyenv())) {
[10:25:49.267]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.267]                           inherits = FALSE)) {
[10:25:49.267]                           master <- get("master", mode = "list", 
[10:25:49.267]                             envir = envir, inherits = FALSE)
[10:25:49.267]                           if (inherits(master, c("SOCKnode", 
[10:25:49.267]                             "SOCK0node"))) {
[10:25:49.267]                             sendCondition <<- function(cond) {
[10:25:49.267]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.267]                                 success = TRUE)
[10:25:49.267]                               parallel_sendData(master, data)
[10:25:49.267]                             }
[10:25:49.267]                             return(sendCondition)
[10:25:49.267]                           }
[10:25:49.267]                         }
[10:25:49.267]                         frame <- frame + 1L
[10:25:49.267]                         envir <- sys.frame(frame)
[10:25:49.267]                       }
[10:25:49.267]                     }
[10:25:49.267]                     sendCondition <<- function(cond) NULL
[10:25:49.267]                   }
[10:25:49.267]                 })
[10:25:49.267]                 withCallingHandlers({
[10:25:49.267]                   {
[10:25:49.267]                     4
[10:25:49.267]                   }
[10:25:49.267]                 }, immediateCondition = function(cond) {
[10:25:49.267]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.267]                   sendCondition(cond)
[10:25:49.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.267]                   {
[10:25:49.267]                     inherits <- base::inherits
[10:25:49.267]                     invokeRestart <- base::invokeRestart
[10:25:49.267]                     is.null <- base::is.null
[10:25:49.267]                     muffled <- FALSE
[10:25:49.267]                     if (inherits(cond, "message")) {
[10:25:49.267]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.267]                       if (muffled) 
[10:25:49.267]                         invokeRestart("muffleMessage")
[10:25:49.267]                     }
[10:25:49.267]                     else if (inherits(cond, "warning")) {
[10:25:49.267]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.267]                       if (muffled) 
[10:25:49.267]                         invokeRestart("muffleWarning")
[10:25:49.267]                     }
[10:25:49.267]                     else if (inherits(cond, "condition")) {
[10:25:49.267]                       if (!is.null(pattern)) {
[10:25:49.267]                         computeRestarts <- base::computeRestarts
[10:25:49.267]                         grepl <- base::grepl
[10:25:49.267]                         restarts <- computeRestarts(cond)
[10:25:49.267]                         for (restart in restarts) {
[10:25:49.267]                           name <- restart$name
[10:25:49.267]                           if (is.null(name)) 
[10:25:49.267]                             next
[10:25:49.267]                           if (!grepl(pattern, name)) 
[10:25:49.267]                             next
[10:25:49.267]                           invokeRestart(restart)
[10:25:49.267]                           muffled <- TRUE
[10:25:49.267]                           break
[10:25:49.267]                         }
[10:25:49.267]                       }
[10:25:49.267]                     }
[10:25:49.267]                     invisible(muffled)
[10:25:49.267]                   }
[10:25:49.267]                   muffleCondition(cond)
[10:25:49.267]                 })
[10:25:49.267]             }))
[10:25:49.267]             future::FutureResult(value = ...future.value$value, 
[10:25:49.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.267]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.267]                     ...future.globalenv.names))
[10:25:49.267]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.267]         }, condition = base::local({
[10:25:49.267]             c <- base::c
[10:25:49.267]             inherits <- base::inherits
[10:25:49.267]             invokeRestart <- base::invokeRestart
[10:25:49.267]             length <- base::length
[10:25:49.267]             list <- base::list
[10:25:49.267]             seq.int <- base::seq.int
[10:25:49.267]             signalCondition <- base::signalCondition
[10:25:49.267]             sys.calls <- base::sys.calls
[10:25:49.267]             `[[` <- base::`[[`
[10:25:49.267]             `+` <- base::`+`
[10:25:49.267]             `<<-` <- base::`<<-`
[10:25:49.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.267]                   3L)]
[10:25:49.267]             }
[10:25:49.267]             function(cond) {
[10:25:49.267]                 is_error <- inherits(cond, "error")
[10:25:49.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.267]                   NULL)
[10:25:49.267]                 if (is_error) {
[10:25:49.267]                   sessionInformation <- function() {
[10:25:49.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.267]                       search = base::search(), system = base::Sys.info())
[10:25:49.267]                   }
[10:25:49.267]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.267]                     cond$call), session = sessionInformation(), 
[10:25:49.267]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.267]                   signalCondition(cond)
[10:25:49.267]                 }
[10:25:49.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.267]                 "immediateCondition"))) {
[10:25:49.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.267]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.267]                   if (TRUE && !signal) {
[10:25:49.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.267]                     {
[10:25:49.267]                       inherits <- base::inherits
[10:25:49.267]                       invokeRestart <- base::invokeRestart
[10:25:49.267]                       is.null <- base::is.null
[10:25:49.267]                       muffled <- FALSE
[10:25:49.267]                       if (inherits(cond, "message")) {
[10:25:49.267]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.267]                         if (muffled) 
[10:25:49.267]                           invokeRestart("muffleMessage")
[10:25:49.267]                       }
[10:25:49.267]                       else if (inherits(cond, "warning")) {
[10:25:49.267]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.267]                         if (muffled) 
[10:25:49.267]                           invokeRestart("muffleWarning")
[10:25:49.267]                       }
[10:25:49.267]                       else if (inherits(cond, "condition")) {
[10:25:49.267]                         if (!is.null(pattern)) {
[10:25:49.267]                           computeRestarts <- base::computeRestarts
[10:25:49.267]                           grepl <- base::grepl
[10:25:49.267]                           restarts <- computeRestarts(cond)
[10:25:49.267]                           for (restart in restarts) {
[10:25:49.267]                             name <- restart$name
[10:25:49.267]                             if (is.null(name)) 
[10:25:49.267]                               next
[10:25:49.267]                             if (!grepl(pattern, name)) 
[10:25:49.267]                               next
[10:25:49.267]                             invokeRestart(restart)
[10:25:49.267]                             muffled <- TRUE
[10:25:49.267]                             break
[10:25:49.267]                           }
[10:25:49.267]                         }
[10:25:49.267]                       }
[10:25:49.267]                       invisible(muffled)
[10:25:49.267]                     }
[10:25:49.267]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.267]                   }
[10:25:49.267]                 }
[10:25:49.267]                 else {
[10:25:49.267]                   if (TRUE) {
[10:25:49.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.267]                     {
[10:25:49.267]                       inherits <- base::inherits
[10:25:49.267]                       invokeRestart <- base::invokeRestart
[10:25:49.267]                       is.null <- base::is.null
[10:25:49.267]                       muffled <- FALSE
[10:25:49.267]                       if (inherits(cond, "message")) {
[10:25:49.267]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.267]                         if (muffled) 
[10:25:49.267]                           invokeRestart("muffleMessage")
[10:25:49.267]                       }
[10:25:49.267]                       else if (inherits(cond, "warning")) {
[10:25:49.267]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.267]                         if (muffled) 
[10:25:49.267]                           invokeRestart("muffleWarning")
[10:25:49.267]                       }
[10:25:49.267]                       else if (inherits(cond, "condition")) {
[10:25:49.267]                         if (!is.null(pattern)) {
[10:25:49.267]                           computeRestarts <- base::computeRestarts
[10:25:49.267]                           grepl <- base::grepl
[10:25:49.267]                           restarts <- computeRestarts(cond)
[10:25:49.267]                           for (restart in restarts) {
[10:25:49.267]                             name <- restart$name
[10:25:49.267]                             if (is.null(name)) 
[10:25:49.267]                               next
[10:25:49.267]                             if (!grepl(pattern, name)) 
[10:25:49.267]                               next
[10:25:49.267]                             invokeRestart(restart)
[10:25:49.267]                             muffled <- TRUE
[10:25:49.267]                             break
[10:25:49.267]                           }
[10:25:49.267]                         }
[10:25:49.267]                       }
[10:25:49.267]                       invisible(muffled)
[10:25:49.267]                     }
[10:25:49.267]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.267]                   }
[10:25:49.267]                 }
[10:25:49.267]             }
[10:25:49.267]         }))
[10:25:49.267]     }, error = function(ex) {
[10:25:49.267]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.267]                 ...future.rng), started = ...future.startTime, 
[10:25:49.267]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.267]             version = "1.8"), class = "FutureResult")
[10:25:49.267]     }, finally = {
[10:25:49.267]         if (!identical(...future.workdir, getwd())) 
[10:25:49.267]             setwd(...future.workdir)
[10:25:49.267]         {
[10:25:49.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.267]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.267]             }
[10:25:49.267]             base::options(...future.oldOptions)
[10:25:49.267]             if (.Platform$OS.type == "windows") {
[10:25:49.267]                 old_names <- names(...future.oldEnvVars)
[10:25:49.267]                 envs <- base::Sys.getenv()
[10:25:49.267]                 names <- names(envs)
[10:25:49.267]                 common <- intersect(names, old_names)
[10:25:49.267]                 added <- setdiff(names, old_names)
[10:25:49.267]                 removed <- setdiff(old_names, names)
[10:25:49.267]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.267]                   envs[common]]
[10:25:49.267]                 NAMES <- toupper(changed)
[10:25:49.267]                 args <- list()
[10:25:49.267]                 for (kk in seq_along(NAMES)) {
[10:25:49.267]                   name <- changed[[kk]]
[10:25:49.267]                   NAME <- NAMES[[kk]]
[10:25:49.267]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.267]                     next
[10:25:49.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.267]                 }
[10:25:49.267]                 NAMES <- toupper(added)
[10:25:49.267]                 for (kk in seq_along(NAMES)) {
[10:25:49.267]                   name <- added[[kk]]
[10:25:49.267]                   NAME <- NAMES[[kk]]
[10:25:49.267]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.267]                     next
[10:25:49.267]                   args[[name]] <- ""
[10:25:49.267]                 }
[10:25:49.267]                 NAMES <- toupper(removed)
[10:25:49.267]                 for (kk in seq_along(NAMES)) {
[10:25:49.267]                   name <- removed[[kk]]
[10:25:49.267]                   NAME <- NAMES[[kk]]
[10:25:49.267]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.267]                     next
[10:25:49.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.267]                 }
[10:25:49.267]                 if (length(args) > 0) 
[10:25:49.267]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.267]             }
[10:25:49.267]             else {
[10:25:49.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.267]             }
[10:25:49.267]             {
[10:25:49.267]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.267]                   0L) {
[10:25:49.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.267]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.267]                   base::options(opts)
[10:25:49.267]                 }
[10:25:49.267]                 {
[10:25:49.267]                   {
[10:25:49.267]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.267]                     NULL
[10:25:49.267]                   }
[10:25:49.267]                   options(future.plan = NULL)
[10:25:49.267]                   if (is.na(NA_character_)) 
[10:25:49.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.267]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.267]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.267]                     envir = parent.frame()) 
[10:25:49.267]                   {
[10:25:49.267]                     if (is.function(workers)) 
[10:25:49.267]                       workers <- workers()
[10:25:49.267]                     workers <- structure(as.integer(workers), 
[10:25:49.267]                       class = class(workers))
[10:25:49.267]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.267]                       workers >= 1)
[10:25:49.267]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.267]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.267]                     }
[10:25:49.267]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.267]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.267]                       envir = envir)
[10:25:49.267]                     if (!future$lazy) 
[10:25:49.267]                       future <- run(future)
[10:25:49.267]                     invisible(future)
[10:25:49.267]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.267]                 }
[10:25:49.267]             }
[10:25:49.267]         }
[10:25:49.267]     })
[10:25:49.267]     if (TRUE) {
[10:25:49.267]         base::sink(type = "output", split = FALSE)
[10:25:49.267]         if (TRUE) {
[10:25:49.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.267]         }
[10:25:49.267]         else {
[10:25:49.267]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.267]         }
[10:25:49.267]         base::close(...future.stdout)
[10:25:49.267]         ...future.stdout <- NULL
[10:25:49.267]     }
[10:25:49.267]     ...future.result$conditions <- ...future.conditions
[10:25:49.267]     ...future.result$finished <- base::Sys.time()
[10:25:49.267]     ...future.result
[10:25:49.267] }
[10:25:49.271] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:49.282] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.282] - Validating connection of MultisessionFuture
[10:25:49.282] - received message: FutureResult
[10:25:49.283] - Received FutureResult
[10:25:49.283] - Erased future from FutureRegistry
[10:25:49.283] result() for ClusterFuture ...
[10:25:49.283] - result already collected: FutureResult
[10:25:49.283] result() for ClusterFuture ... done
[10:25:49.284] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.284] result() for ClusterFuture ...
[10:25:49.284] - result already collected: FutureResult
[10:25:49.284] result() for ClusterFuture ... done
[10:25:49.284] result() for ClusterFuture ...
[10:25:49.284] - result already collected: FutureResult
[10:25:49.284] result() for ClusterFuture ... done
[10:25:49.286] MultisessionFuture started
[10:25:49.286] - Launch lazy future ... done
[10:25:49.286] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c0f50ec798> 
<environment: 0x55c0f647a1c8> 
[10:25:49.298] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.298] - Validating connection of MultisessionFuture
[10:25:49.298] - received message: FutureResult
[10:25:49.298] - Received FutureResult
[10:25:49.298] - Erased future from FutureRegistry
[10:25:49.298] result() for ClusterFuture ...
[10:25:49.298] - result already collected: FutureResult
[10:25:49.298] result() for ClusterFuture ... done
[10:25:49.299] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:49.310] resolve() on environment ...
[10:25:49.310]  recursive: 0
[10:25:49.311]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:49.311] signalConditionsASAP(numeric, pos=1) ...
[10:25:49.311] - nx: 4
[10:25:49.311] - relay: TRUE
[10:25:49.311] - stdout: TRUE
[10:25:49.311] - signal: TRUE
[10:25:49.311] - resignal: FALSE
[10:25:49.312] - force: TRUE
[10:25:49.312] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.312] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.312]  - until=2
[10:25:49.312]  - relaying element #2
[10:25:49.312] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.312] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.312] signalConditionsASAP(NULL, pos=1) ... done
[10:25:49.312]  length: 3 (resolved future 1)
[10:25:49.312] Future #2
[10:25:49.313] result() for ClusterFuture ...
[10:25:49.313] - result already collected: FutureResult
[10:25:49.313] result() for ClusterFuture ... done
[10:25:49.313] result() for ClusterFuture ...
[10:25:49.313] - result already collected: FutureResult
[10:25:49.313] result() for ClusterFuture ... done
[10:25:49.313] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:49.313] - nx: 4
[10:25:49.313] - relay: TRUE
[10:25:49.313] - stdout: TRUE
[10:25:49.313] - signal: TRUE
[10:25:49.314] - resignal: FALSE
[10:25:49.314] - force: TRUE
[10:25:49.314] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.314] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.314]  - until=2
[10:25:49.314]  - relaying element #2
[10:25:49.314] result() for ClusterFuture ...
[10:25:49.314] - result already collected: FutureResult
[10:25:49.314] result() for ClusterFuture ... done
[10:25:49.314] result() for ClusterFuture ...
[10:25:49.314] - result already collected: FutureResult
[10:25:49.315] result() for ClusterFuture ... done
[10:25:49.315] result() for ClusterFuture ...
[10:25:49.315] - result already collected: FutureResult
[10:25:49.315] result() for ClusterFuture ... done
[10:25:49.315] result() for ClusterFuture ...
[10:25:49.315] - result already collected: FutureResult
[10:25:49.315] result() for ClusterFuture ... done
[10:25:49.315] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.315] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.315] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:49.315]  length: 2 (resolved future 2)
[10:25:49.316] Future #3
[10:25:49.316] result() for ClusterFuture ...
[10:25:49.316] - result already collected: FutureResult
[10:25:49.316] result() for ClusterFuture ... done
[10:25:49.316] result() for ClusterFuture ...
[10:25:49.316] - result already collected: FutureResult
[10:25:49.316] result() for ClusterFuture ... done
[10:25:49.316] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:49.316] - nx: 4
[10:25:49.316] - relay: TRUE
[10:25:49.316] - stdout: TRUE
[10:25:49.317] - signal: TRUE
[10:25:49.317] - resignal: FALSE
[10:25:49.317] - force: TRUE
[10:25:49.317] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.317] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.317]  - until=3
[10:25:49.317]  - relaying element #3
[10:25:49.317] result() for ClusterFuture ...
[10:25:49.317] - result already collected: FutureResult
[10:25:49.317] result() for ClusterFuture ... done
[10:25:49.317] result() for ClusterFuture ...
[10:25:49.318] - result already collected: FutureResult
[10:25:49.318] result() for ClusterFuture ... done
[10:25:49.318] result() for ClusterFuture ...
[10:25:49.318] - result already collected: FutureResult
[10:25:49.318] result() for ClusterFuture ... done
[10:25:49.318] result() for ClusterFuture ...
[10:25:49.318] - result already collected: FutureResult
[10:25:49.318] result() for ClusterFuture ... done
[10:25:49.318] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.318] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.318] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:49.319]  length: 1 (resolved future 3)
[10:25:49.339] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.340] - Validating connection of MultisessionFuture
[10:25:49.340] - received message: FutureResult
[10:25:49.340] - Received FutureResult
[10:25:49.340] - Erased future from FutureRegistry
[10:25:49.340] result() for ClusterFuture ...
[10:25:49.340] - result already collected: FutureResult
[10:25:49.340] result() for ClusterFuture ... done
[10:25:49.340] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.340] Future #4
[10:25:49.341] result() for ClusterFuture ...
[10:25:49.341] - result already collected: FutureResult
[10:25:49.341] result() for ClusterFuture ... done
[10:25:49.341] result() for ClusterFuture ...
[10:25:49.341] - result already collected: FutureResult
[10:25:49.341] result() for ClusterFuture ... done
[10:25:49.341] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:49.341] - nx: 4
[10:25:49.341] - relay: TRUE
[10:25:49.341] - stdout: TRUE
[10:25:49.341] - signal: TRUE
[10:25:49.342] - resignal: FALSE
[10:25:49.342] - force: TRUE
[10:25:49.342] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.342] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.342]  - until=4
[10:25:49.342]  - relaying element #4
[10:25:49.342] result() for ClusterFuture ...
[10:25:49.342] - result already collected: FutureResult
[10:25:49.342] result() for ClusterFuture ... done
[10:25:49.342] result() for ClusterFuture ...
[10:25:49.342] - result already collected: FutureResult
[10:25:49.343] result() for ClusterFuture ... done
[10:25:49.343] result() for ClusterFuture ...
[10:25:49.343] - result already collected: FutureResult
[10:25:49.343] result() for ClusterFuture ... done
[10:25:49.343] result() for ClusterFuture ...
[10:25:49.343] - result already collected: FutureResult
[10:25:49.343] result() for ClusterFuture ... done
[10:25:49.343] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.343] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.343] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:49.343]  length: 0 (resolved future 4)
[10:25:49.344] Relaying remaining futures
[10:25:49.344] signalConditionsASAP(NULL, pos=0) ...
[10:25:49.344] - nx: 4
[10:25:49.344] - relay: TRUE
[10:25:49.344] - stdout: TRUE
[10:25:49.344] - signal: TRUE
[10:25:49.344] - resignal: FALSE
[10:25:49.344] - force: TRUE
[10:25:49.344] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.344] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:49.344] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.345] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.345] signalConditionsASAP(NULL, pos=0) ... done
[10:25:49.345] resolve() on environment ... DONE
[10:25:49.345] result() for ClusterFuture ...
[10:25:49.345] - result already collected: FutureResult
[10:25:49.345] result() for ClusterFuture ... done
[10:25:49.345] result() for ClusterFuture ...
[10:25:49.345] - result already collected: FutureResult
[10:25:49.345] result() for ClusterFuture ... done
[10:25:49.345] result() for ClusterFuture ...
[10:25:49.345] - result already collected: FutureResult
[10:25:49.346] result() for ClusterFuture ... done
[10:25:49.346] result() for ClusterFuture ...
[10:25:49.346] - result already collected: FutureResult
[10:25:49.346] result() for ClusterFuture ... done
[10:25:49.346] result() for ClusterFuture ...
[10:25:49.346] - result already collected: FutureResult
[10:25:49.346] result() for ClusterFuture ... done
[10:25:49.346] result() for ClusterFuture ...
[10:25:49.346] - result already collected: FutureResult
[10:25:49.346] result() for ClusterFuture ... done
<environment: 0x55c0f66ad928> 
Dimensions: c(1, 6)
[10:25:49.347] getGlobalsAndPackages() ...
[10:25:49.347] Searching for globals...
[10:25:49.347] 
[10:25:49.347] Searching for globals ... DONE
[10:25:49.347] - globals: [0] <none>
[10:25:49.348] getGlobalsAndPackages() ... DONE
[10:25:49.348] run() for ‘Future’ ...
[10:25:49.348] - state: ‘created’
[10:25:49.348] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.362] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.362]   - Field: ‘node’
[10:25:49.362]   - Field: ‘label’
[10:25:49.363]   - Field: ‘local’
[10:25:49.363]   - Field: ‘owner’
[10:25:49.363]   - Field: ‘envir’
[10:25:49.363]   - Field: ‘workers’
[10:25:49.363]   - Field: ‘packages’
[10:25:49.363]   - Field: ‘gc’
[10:25:49.363]   - Field: ‘conditions’
[10:25:49.363]   - Field: ‘persistent’
[10:25:49.363]   - Field: ‘expr’
[10:25:49.363]   - Field: ‘uuid’
[10:25:49.363]   - Field: ‘seed’
[10:25:49.364]   - Field: ‘version’
[10:25:49.364]   - Field: ‘result’
[10:25:49.364]   - Field: ‘asynchronous’
[10:25:49.364]   - Field: ‘calls’
[10:25:49.364]   - Field: ‘globals’
[10:25:49.364]   - Field: ‘stdout’
[10:25:49.364]   - Field: ‘earlySignal’
[10:25:49.364]   - Field: ‘lazy’
[10:25:49.364]   - Field: ‘state’
[10:25:49.364] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.365] - Launch lazy future ...
[10:25:49.365] Packages needed by the future expression (n = 0): <none>
[10:25:49.365] Packages needed by future strategies (n = 0): <none>
[10:25:49.365] {
[10:25:49.365]     {
[10:25:49.365]         {
[10:25:49.365]             ...future.startTime <- base::Sys.time()
[10:25:49.365]             {
[10:25:49.365]                 {
[10:25:49.365]                   {
[10:25:49.365]                     {
[10:25:49.365]                       base::local({
[10:25:49.365]                         has_future <- base::requireNamespace("future", 
[10:25:49.365]                           quietly = TRUE)
[10:25:49.365]                         if (has_future) {
[10:25:49.365]                           ns <- base::getNamespace("future")
[10:25:49.365]                           version <- ns[[".package"]][["version"]]
[10:25:49.365]                           if (is.null(version)) 
[10:25:49.365]                             version <- utils::packageVersion("future")
[10:25:49.365]                         }
[10:25:49.365]                         else {
[10:25:49.365]                           version <- NULL
[10:25:49.365]                         }
[10:25:49.365]                         if (!has_future || version < "1.8.0") {
[10:25:49.365]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.365]                             "", base::R.version$version.string), 
[10:25:49.365]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.365]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.365]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.365]                               "release", "version")], collapse = " "), 
[10:25:49.365]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.365]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.365]                             info)
[10:25:49.365]                           info <- base::paste(info, collapse = "; ")
[10:25:49.365]                           if (!has_future) {
[10:25:49.365]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.365]                               info)
[10:25:49.365]                           }
[10:25:49.365]                           else {
[10:25:49.365]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.365]                               info, version)
[10:25:49.365]                           }
[10:25:49.365]                           base::stop(msg)
[10:25:49.365]                         }
[10:25:49.365]                       })
[10:25:49.365]                     }
[10:25:49.365]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.365]                     base::options(mc.cores = 1L)
[10:25:49.365]                   }
[10:25:49.365]                   options(future.plan = NULL)
[10:25:49.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.365]                 }
[10:25:49.365]                 ...future.workdir <- getwd()
[10:25:49.365]             }
[10:25:49.365]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.365]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.365]         }
[10:25:49.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.365]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.365]             base::names(...future.oldOptions))
[10:25:49.365]     }
[10:25:49.365]     if (FALSE) {
[10:25:49.365]     }
[10:25:49.365]     else {
[10:25:49.365]         if (TRUE) {
[10:25:49.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.365]                 open = "w")
[10:25:49.365]         }
[10:25:49.365]         else {
[10:25:49.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.365]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.365]         }
[10:25:49.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.365]             base::sink(type = "output", split = FALSE)
[10:25:49.365]             base::close(...future.stdout)
[10:25:49.365]         }, add = TRUE)
[10:25:49.365]     }
[10:25:49.365]     ...future.frame <- base::sys.nframe()
[10:25:49.365]     ...future.conditions <- base::list()
[10:25:49.365]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.365]     if (FALSE) {
[10:25:49.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.365]     }
[10:25:49.365]     ...future.result <- base::tryCatch({
[10:25:49.365]         base::withCallingHandlers({
[10:25:49.365]             ...future.value <- base::withVisible(base::local({
[10:25:49.365]                 ...future.makeSendCondition <- base::local({
[10:25:49.365]                   sendCondition <- NULL
[10:25:49.365]                   function(frame = 1L) {
[10:25:49.365]                     if (is.function(sendCondition)) 
[10:25:49.365]                       return(sendCondition)
[10:25:49.365]                     ns <- getNamespace("parallel")
[10:25:49.365]                     if (exists("sendData", mode = "function", 
[10:25:49.365]                       envir = ns)) {
[10:25:49.365]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.365]                         envir = ns)
[10:25:49.365]                       envir <- sys.frame(frame)
[10:25:49.365]                       master <- NULL
[10:25:49.365]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.365]                         !identical(envir, emptyenv())) {
[10:25:49.365]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.365]                           inherits = FALSE)) {
[10:25:49.365]                           master <- get("master", mode = "list", 
[10:25:49.365]                             envir = envir, inherits = FALSE)
[10:25:49.365]                           if (inherits(master, c("SOCKnode", 
[10:25:49.365]                             "SOCK0node"))) {
[10:25:49.365]                             sendCondition <<- function(cond) {
[10:25:49.365]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.365]                                 success = TRUE)
[10:25:49.365]                               parallel_sendData(master, data)
[10:25:49.365]                             }
[10:25:49.365]                             return(sendCondition)
[10:25:49.365]                           }
[10:25:49.365]                         }
[10:25:49.365]                         frame <- frame + 1L
[10:25:49.365]                         envir <- sys.frame(frame)
[10:25:49.365]                       }
[10:25:49.365]                     }
[10:25:49.365]                     sendCondition <<- function(cond) NULL
[10:25:49.365]                   }
[10:25:49.365]                 })
[10:25:49.365]                 withCallingHandlers({
[10:25:49.365]                   2
[10:25:49.365]                 }, immediateCondition = function(cond) {
[10:25:49.365]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.365]                   sendCondition(cond)
[10:25:49.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.365]                   {
[10:25:49.365]                     inherits <- base::inherits
[10:25:49.365]                     invokeRestart <- base::invokeRestart
[10:25:49.365]                     is.null <- base::is.null
[10:25:49.365]                     muffled <- FALSE
[10:25:49.365]                     if (inherits(cond, "message")) {
[10:25:49.365]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.365]                       if (muffled) 
[10:25:49.365]                         invokeRestart("muffleMessage")
[10:25:49.365]                     }
[10:25:49.365]                     else if (inherits(cond, "warning")) {
[10:25:49.365]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.365]                       if (muffled) 
[10:25:49.365]                         invokeRestart("muffleWarning")
[10:25:49.365]                     }
[10:25:49.365]                     else if (inherits(cond, "condition")) {
[10:25:49.365]                       if (!is.null(pattern)) {
[10:25:49.365]                         computeRestarts <- base::computeRestarts
[10:25:49.365]                         grepl <- base::grepl
[10:25:49.365]                         restarts <- computeRestarts(cond)
[10:25:49.365]                         for (restart in restarts) {
[10:25:49.365]                           name <- restart$name
[10:25:49.365]                           if (is.null(name)) 
[10:25:49.365]                             next
[10:25:49.365]                           if (!grepl(pattern, name)) 
[10:25:49.365]                             next
[10:25:49.365]                           invokeRestart(restart)
[10:25:49.365]                           muffled <- TRUE
[10:25:49.365]                           break
[10:25:49.365]                         }
[10:25:49.365]                       }
[10:25:49.365]                     }
[10:25:49.365]                     invisible(muffled)
[10:25:49.365]                   }
[10:25:49.365]                   muffleCondition(cond)
[10:25:49.365]                 })
[10:25:49.365]             }))
[10:25:49.365]             future::FutureResult(value = ...future.value$value, 
[10:25:49.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.365]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.365]                     ...future.globalenv.names))
[10:25:49.365]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.365]         }, condition = base::local({
[10:25:49.365]             c <- base::c
[10:25:49.365]             inherits <- base::inherits
[10:25:49.365]             invokeRestart <- base::invokeRestart
[10:25:49.365]             length <- base::length
[10:25:49.365]             list <- base::list
[10:25:49.365]             seq.int <- base::seq.int
[10:25:49.365]             signalCondition <- base::signalCondition
[10:25:49.365]             sys.calls <- base::sys.calls
[10:25:49.365]             `[[` <- base::`[[`
[10:25:49.365]             `+` <- base::`+`
[10:25:49.365]             `<<-` <- base::`<<-`
[10:25:49.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.365]                   3L)]
[10:25:49.365]             }
[10:25:49.365]             function(cond) {
[10:25:49.365]                 is_error <- inherits(cond, "error")
[10:25:49.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.365]                   NULL)
[10:25:49.365]                 if (is_error) {
[10:25:49.365]                   sessionInformation <- function() {
[10:25:49.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.365]                       search = base::search(), system = base::Sys.info())
[10:25:49.365]                   }
[10:25:49.365]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.365]                     cond$call), session = sessionInformation(), 
[10:25:49.365]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.365]                   signalCondition(cond)
[10:25:49.365]                 }
[10:25:49.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.365]                 "immediateCondition"))) {
[10:25:49.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.365]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.365]                   if (TRUE && !signal) {
[10:25:49.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.365]                     {
[10:25:49.365]                       inherits <- base::inherits
[10:25:49.365]                       invokeRestart <- base::invokeRestart
[10:25:49.365]                       is.null <- base::is.null
[10:25:49.365]                       muffled <- FALSE
[10:25:49.365]                       if (inherits(cond, "message")) {
[10:25:49.365]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.365]                         if (muffled) 
[10:25:49.365]                           invokeRestart("muffleMessage")
[10:25:49.365]                       }
[10:25:49.365]                       else if (inherits(cond, "warning")) {
[10:25:49.365]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.365]                         if (muffled) 
[10:25:49.365]                           invokeRestart("muffleWarning")
[10:25:49.365]                       }
[10:25:49.365]                       else if (inherits(cond, "condition")) {
[10:25:49.365]                         if (!is.null(pattern)) {
[10:25:49.365]                           computeRestarts <- base::computeRestarts
[10:25:49.365]                           grepl <- base::grepl
[10:25:49.365]                           restarts <- computeRestarts(cond)
[10:25:49.365]                           for (restart in restarts) {
[10:25:49.365]                             name <- restart$name
[10:25:49.365]                             if (is.null(name)) 
[10:25:49.365]                               next
[10:25:49.365]                             if (!grepl(pattern, name)) 
[10:25:49.365]                               next
[10:25:49.365]                             invokeRestart(restart)
[10:25:49.365]                             muffled <- TRUE
[10:25:49.365]                             break
[10:25:49.365]                           }
[10:25:49.365]                         }
[10:25:49.365]                       }
[10:25:49.365]                       invisible(muffled)
[10:25:49.365]                     }
[10:25:49.365]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.365]                   }
[10:25:49.365]                 }
[10:25:49.365]                 else {
[10:25:49.365]                   if (TRUE) {
[10:25:49.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.365]                     {
[10:25:49.365]                       inherits <- base::inherits
[10:25:49.365]                       invokeRestart <- base::invokeRestart
[10:25:49.365]                       is.null <- base::is.null
[10:25:49.365]                       muffled <- FALSE
[10:25:49.365]                       if (inherits(cond, "message")) {
[10:25:49.365]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.365]                         if (muffled) 
[10:25:49.365]                           invokeRestart("muffleMessage")
[10:25:49.365]                       }
[10:25:49.365]                       else if (inherits(cond, "warning")) {
[10:25:49.365]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.365]                         if (muffled) 
[10:25:49.365]                           invokeRestart("muffleWarning")
[10:25:49.365]                       }
[10:25:49.365]                       else if (inherits(cond, "condition")) {
[10:25:49.365]                         if (!is.null(pattern)) {
[10:25:49.365]                           computeRestarts <- base::computeRestarts
[10:25:49.365]                           grepl <- base::grepl
[10:25:49.365]                           restarts <- computeRestarts(cond)
[10:25:49.365]                           for (restart in restarts) {
[10:25:49.365]                             name <- restart$name
[10:25:49.365]                             if (is.null(name)) 
[10:25:49.365]                               next
[10:25:49.365]                             if (!grepl(pattern, name)) 
[10:25:49.365]                               next
[10:25:49.365]                             invokeRestart(restart)
[10:25:49.365]                             muffled <- TRUE
[10:25:49.365]                             break
[10:25:49.365]                           }
[10:25:49.365]                         }
[10:25:49.365]                       }
[10:25:49.365]                       invisible(muffled)
[10:25:49.365]                     }
[10:25:49.365]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.365]                   }
[10:25:49.365]                 }
[10:25:49.365]             }
[10:25:49.365]         }))
[10:25:49.365]     }, error = function(ex) {
[10:25:49.365]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.365]                 ...future.rng), started = ...future.startTime, 
[10:25:49.365]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.365]             version = "1.8"), class = "FutureResult")
[10:25:49.365]     }, finally = {
[10:25:49.365]         if (!identical(...future.workdir, getwd())) 
[10:25:49.365]             setwd(...future.workdir)
[10:25:49.365]         {
[10:25:49.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.365]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.365]             }
[10:25:49.365]             base::options(...future.oldOptions)
[10:25:49.365]             if (.Platform$OS.type == "windows") {
[10:25:49.365]                 old_names <- names(...future.oldEnvVars)
[10:25:49.365]                 envs <- base::Sys.getenv()
[10:25:49.365]                 names <- names(envs)
[10:25:49.365]                 common <- intersect(names, old_names)
[10:25:49.365]                 added <- setdiff(names, old_names)
[10:25:49.365]                 removed <- setdiff(old_names, names)
[10:25:49.365]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.365]                   envs[common]]
[10:25:49.365]                 NAMES <- toupper(changed)
[10:25:49.365]                 args <- list()
[10:25:49.365]                 for (kk in seq_along(NAMES)) {
[10:25:49.365]                   name <- changed[[kk]]
[10:25:49.365]                   NAME <- NAMES[[kk]]
[10:25:49.365]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.365]                     next
[10:25:49.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.365]                 }
[10:25:49.365]                 NAMES <- toupper(added)
[10:25:49.365]                 for (kk in seq_along(NAMES)) {
[10:25:49.365]                   name <- added[[kk]]
[10:25:49.365]                   NAME <- NAMES[[kk]]
[10:25:49.365]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.365]                     next
[10:25:49.365]                   args[[name]] <- ""
[10:25:49.365]                 }
[10:25:49.365]                 NAMES <- toupper(removed)
[10:25:49.365]                 for (kk in seq_along(NAMES)) {
[10:25:49.365]                   name <- removed[[kk]]
[10:25:49.365]                   NAME <- NAMES[[kk]]
[10:25:49.365]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.365]                     next
[10:25:49.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.365]                 }
[10:25:49.365]                 if (length(args) > 0) 
[10:25:49.365]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.365]             }
[10:25:49.365]             else {
[10:25:49.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.365]             }
[10:25:49.365]             {
[10:25:49.365]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.365]                   0L) {
[10:25:49.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.365]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.365]                   base::options(opts)
[10:25:49.365]                 }
[10:25:49.365]                 {
[10:25:49.365]                   {
[10:25:49.365]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.365]                     NULL
[10:25:49.365]                   }
[10:25:49.365]                   options(future.plan = NULL)
[10:25:49.365]                   if (is.na(NA_character_)) 
[10:25:49.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.365]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.365]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.365]                     envir = parent.frame()) 
[10:25:49.365]                   {
[10:25:49.365]                     if (is.function(workers)) 
[10:25:49.365]                       workers <- workers()
[10:25:49.365]                     workers <- structure(as.integer(workers), 
[10:25:49.365]                       class = class(workers))
[10:25:49.365]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.365]                       workers >= 1)
[10:25:49.365]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.365]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.365]                     }
[10:25:49.365]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.365]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.365]                       envir = envir)
[10:25:49.365]                     if (!future$lazy) 
[10:25:49.365]                       future <- run(future)
[10:25:49.365]                     invisible(future)
[10:25:49.365]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.365]                 }
[10:25:49.365]             }
[10:25:49.365]         }
[10:25:49.365]     })
[10:25:49.365]     if (TRUE) {
[10:25:49.365]         base::sink(type = "output", split = FALSE)
[10:25:49.365]         if (TRUE) {
[10:25:49.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.365]         }
[10:25:49.365]         else {
[10:25:49.365]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.365]         }
[10:25:49.365]         base::close(...future.stdout)
[10:25:49.365]         ...future.stdout <- NULL
[10:25:49.365]     }
[10:25:49.365]     ...future.result$conditions <- ...future.conditions
[10:25:49.365]     ...future.result$finished <- base::Sys.time()
[10:25:49.365]     ...future.result
[10:25:49.365] }
[10:25:49.371] MultisessionFuture started
[10:25:49.371] - Launch lazy future ... done
[10:25:49.371] run() for ‘MultisessionFuture’ ... done
[10:25:49.371] getGlobalsAndPackages() ...
[10:25:49.371] Searching for globals...
[10:25:49.372] 
[10:25:49.372] Searching for globals ... DONE
[10:25:49.372] - globals: [0] <none>
[10:25:49.372] getGlobalsAndPackages() ... DONE
[10:25:49.372] run() for ‘Future’ ...
[10:25:49.372] - state: ‘created’
[10:25:49.372] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.387] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.387]   - Field: ‘node’
[10:25:49.387]   - Field: ‘label’
[10:25:49.387]   - Field: ‘local’
[10:25:49.387]   - Field: ‘owner’
[10:25:49.387]   - Field: ‘envir’
[10:25:49.387]   - Field: ‘workers’
[10:25:49.388]   - Field: ‘packages’
[10:25:49.388]   - Field: ‘gc’
[10:25:49.388]   - Field: ‘conditions’
[10:25:49.388]   - Field: ‘persistent’
[10:25:49.388]   - Field: ‘expr’
[10:25:49.388]   - Field: ‘uuid’
[10:25:49.388]   - Field: ‘seed’
[10:25:49.388]   - Field: ‘version’
[10:25:49.388]   - Field: ‘result’
[10:25:49.388]   - Field: ‘asynchronous’
[10:25:49.388]   - Field: ‘calls’
[10:25:49.388]   - Field: ‘globals’
[10:25:49.389]   - Field: ‘stdout’
[10:25:49.389]   - Field: ‘earlySignal’
[10:25:49.389]   - Field: ‘lazy’
[10:25:49.389]   - Field: ‘state’
[10:25:49.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.389] - Launch lazy future ...
[10:25:49.389] Packages needed by the future expression (n = 0): <none>
[10:25:49.389] Packages needed by future strategies (n = 0): <none>
[10:25:49.390] {
[10:25:49.390]     {
[10:25:49.390]         {
[10:25:49.390]             ...future.startTime <- base::Sys.time()
[10:25:49.390]             {
[10:25:49.390]                 {
[10:25:49.390]                   {
[10:25:49.390]                     {
[10:25:49.390]                       base::local({
[10:25:49.390]                         has_future <- base::requireNamespace("future", 
[10:25:49.390]                           quietly = TRUE)
[10:25:49.390]                         if (has_future) {
[10:25:49.390]                           ns <- base::getNamespace("future")
[10:25:49.390]                           version <- ns[[".package"]][["version"]]
[10:25:49.390]                           if (is.null(version)) 
[10:25:49.390]                             version <- utils::packageVersion("future")
[10:25:49.390]                         }
[10:25:49.390]                         else {
[10:25:49.390]                           version <- NULL
[10:25:49.390]                         }
[10:25:49.390]                         if (!has_future || version < "1.8.0") {
[10:25:49.390]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.390]                             "", base::R.version$version.string), 
[10:25:49.390]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.390]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.390]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.390]                               "release", "version")], collapse = " "), 
[10:25:49.390]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.390]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.390]                             info)
[10:25:49.390]                           info <- base::paste(info, collapse = "; ")
[10:25:49.390]                           if (!has_future) {
[10:25:49.390]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.390]                               info)
[10:25:49.390]                           }
[10:25:49.390]                           else {
[10:25:49.390]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.390]                               info, version)
[10:25:49.390]                           }
[10:25:49.390]                           base::stop(msg)
[10:25:49.390]                         }
[10:25:49.390]                       })
[10:25:49.390]                     }
[10:25:49.390]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.390]                     base::options(mc.cores = 1L)
[10:25:49.390]                   }
[10:25:49.390]                   options(future.plan = NULL)
[10:25:49.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.390]                 }
[10:25:49.390]                 ...future.workdir <- getwd()
[10:25:49.390]             }
[10:25:49.390]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.390]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.390]         }
[10:25:49.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.390]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.390]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.390]             base::names(...future.oldOptions))
[10:25:49.390]     }
[10:25:49.390]     if (FALSE) {
[10:25:49.390]     }
[10:25:49.390]     else {
[10:25:49.390]         if (TRUE) {
[10:25:49.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.390]                 open = "w")
[10:25:49.390]         }
[10:25:49.390]         else {
[10:25:49.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.390]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.390]         }
[10:25:49.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.390]             base::sink(type = "output", split = FALSE)
[10:25:49.390]             base::close(...future.stdout)
[10:25:49.390]         }, add = TRUE)
[10:25:49.390]     }
[10:25:49.390]     ...future.frame <- base::sys.nframe()
[10:25:49.390]     ...future.conditions <- base::list()
[10:25:49.390]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.390]     if (FALSE) {
[10:25:49.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.390]     }
[10:25:49.390]     ...future.result <- base::tryCatch({
[10:25:49.390]         base::withCallingHandlers({
[10:25:49.390]             ...future.value <- base::withVisible(base::local({
[10:25:49.390]                 ...future.makeSendCondition <- base::local({
[10:25:49.390]                   sendCondition <- NULL
[10:25:49.390]                   function(frame = 1L) {
[10:25:49.390]                     if (is.function(sendCondition)) 
[10:25:49.390]                       return(sendCondition)
[10:25:49.390]                     ns <- getNamespace("parallel")
[10:25:49.390]                     if (exists("sendData", mode = "function", 
[10:25:49.390]                       envir = ns)) {
[10:25:49.390]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.390]                         envir = ns)
[10:25:49.390]                       envir <- sys.frame(frame)
[10:25:49.390]                       master <- NULL
[10:25:49.390]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.390]                         !identical(envir, emptyenv())) {
[10:25:49.390]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.390]                           inherits = FALSE)) {
[10:25:49.390]                           master <- get("master", mode = "list", 
[10:25:49.390]                             envir = envir, inherits = FALSE)
[10:25:49.390]                           if (inherits(master, c("SOCKnode", 
[10:25:49.390]                             "SOCK0node"))) {
[10:25:49.390]                             sendCondition <<- function(cond) {
[10:25:49.390]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.390]                                 success = TRUE)
[10:25:49.390]                               parallel_sendData(master, data)
[10:25:49.390]                             }
[10:25:49.390]                             return(sendCondition)
[10:25:49.390]                           }
[10:25:49.390]                         }
[10:25:49.390]                         frame <- frame + 1L
[10:25:49.390]                         envir <- sys.frame(frame)
[10:25:49.390]                       }
[10:25:49.390]                     }
[10:25:49.390]                     sendCondition <<- function(cond) NULL
[10:25:49.390]                   }
[10:25:49.390]                 })
[10:25:49.390]                 withCallingHandlers({
[10:25:49.390]                   NULL
[10:25:49.390]                 }, immediateCondition = function(cond) {
[10:25:49.390]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.390]                   sendCondition(cond)
[10:25:49.390]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.390]                   {
[10:25:49.390]                     inherits <- base::inherits
[10:25:49.390]                     invokeRestart <- base::invokeRestart
[10:25:49.390]                     is.null <- base::is.null
[10:25:49.390]                     muffled <- FALSE
[10:25:49.390]                     if (inherits(cond, "message")) {
[10:25:49.390]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.390]                       if (muffled) 
[10:25:49.390]                         invokeRestart("muffleMessage")
[10:25:49.390]                     }
[10:25:49.390]                     else if (inherits(cond, "warning")) {
[10:25:49.390]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.390]                       if (muffled) 
[10:25:49.390]                         invokeRestart("muffleWarning")
[10:25:49.390]                     }
[10:25:49.390]                     else if (inherits(cond, "condition")) {
[10:25:49.390]                       if (!is.null(pattern)) {
[10:25:49.390]                         computeRestarts <- base::computeRestarts
[10:25:49.390]                         grepl <- base::grepl
[10:25:49.390]                         restarts <- computeRestarts(cond)
[10:25:49.390]                         for (restart in restarts) {
[10:25:49.390]                           name <- restart$name
[10:25:49.390]                           if (is.null(name)) 
[10:25:49.390]                             next
[10:25:49.390]                           if (!grepl(pattern, name)) 
[10:25:49.390]                             next
[10:25:49.390]                           invokeRestart(restart)
[10:25:49.390]                           muffled <- TRUE
[10:25:49.390]                           break
[10:25:49.390]                         }
[10:25:49.390]                       }
[10:25:49.390]                     }
[10:25:49.390]                     invisible(muffled)
[10:25:49.390]                   }
[10:25:49.390]                   muffleCondition(cond)
[10:25:49.390]                 })
[10:25:49.390]             }))
[10:25:49.390]             future::FutureResult(value = ...future.value$value, 
[10:25:49.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.390]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.390]                     ...future.globalenv.names))
[10:25:49.390]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.390]         }, condition = base::local({
[10:25:49.390]             c <- base::c
[10:25:49.390]             inherits <- base::inherits
[10:25:49.390]             invokeRestart <- base::invokeRestart
[10:25:49.390]             length <- base::length
[10:25:49.390]             list <- base::list
[10:25:49.390]             seq.int <- base::seq.int
[10:25:49.390]             signalCondition <- base::signalCondition
[10:25:49.390]             sys.calls <- base::sys.calls
[10:25:49.390]             `[[` <- base::`[[`
[10:25:49.390]             `+` <- base::`+`
[10:25:49.390]             `<<-` <- base::`<<-`
[10:25:49.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.390]                   3L)]
[10:25:49.390]             }
[10:25:49.390]             function(cond) {
[10:25:49.390]                 is_error <- inherits(cond, "error")
[10:25:49.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.390]                   NULL)
[10:25:49.390]                 if (is_error) {
[10:25:49.390]                   sessionInformation <- function() {
[10:25:49.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.390]                       search = base::search(), system = base::Sys.info())
[10:25:49.390]                   }
[10:25:49.390]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.390]                     cond$call), session = sessionInformation(), 
[10:25:49.390]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.390]                   signalCondition(cond)
[10:25:49.390]                 }
[10:25:49.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.390]                 "immediateCondition"))) {
[10:25:49.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.390]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.390]                   if (TRUE && !signal) {
[10:25:49.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.390]                     {
[10:25:49.390]                       inherits <- base::inherits
[10:25:49.390]                       invokeRestart <- base::invokeRestart
[10:25:49.390]                       is.null <- base::is.null
[10:25:49.390]                       muffled <- FALSE
[10:25:49.390]                       if (inherits(cond, "message")) {
[10:25:49.390]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.390]                         if (muffled) 
[10:25:49.390]                           invokeRestart("muffleMessage")
[10:25:49.390]                       }
[10:25:49.390]                       else if (inherits(cond, "warning")) {
[10:25:49.390]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.390]                         if (muffled) 
[10:25:49.390]                           invokeRestart("muffleWarning")
[10:25:49.390]                       }
[10:25:49.390]                       else if (inherits(cond, "condition")) {
[10:25:49.390]                         if (!is.null(pattern)) {
[10:25:49.390]                           computeRestarts <- base::computeRestarts
[10:25:49.390]                           grepl <- base::grepl
[10:25:49.390]                           restarts <- computeRestarts(cond)
[10:25:49.390]                           for (restart in restarts) {
[10:25:49.390]                             name <- restart$name
[10:25:49.390]                             if (is.null(name)) 
[10:25:49.390]                               next
[10:25:49.390]                             if (!grepl(pattern, name)) 
[10:25:49.390]                               next
[10:25:49.390]                             invokeRestart(restart)
[10:25:49.390]                             muffled <- TRUE
[10:25:49.390]                             break
[10:25:49.390]                           }
[10:25:49.390]                         }
[10:25:49.390]                       }
[10:25:49.390]                       invisible(muffled)
[10:25:49.390]                     }
[10:25:49.390]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.390]                   }
[10:25:49.390]                 }
[10:25:49.390]                 else {
[10:25:49.390]                   if (TRUE) {
[10:25:49.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.390]                     {
[10:25:49.390]                       inherits <- base::inherits
[10:25:49.390]                       invokeRestart <- base::invokeRestart
[10:25:49.390]                       is.null <- base::is.null
[10:25:49.390]                       muffled <- FALSE
[10:25:49.390]                       if (inherits(cond, "message")) {
[10:25:49.390]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.390]                         if (muffled) 
[10:25:49.390]                           invokeRestart("muffleMessage")
[10:25:49.390]                       }
[10:25:49.390]                       else if (inherits(cond, "warning")) {
[10:25:49.390]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.390]                         if (muffled) 
[10:25:49.390]                           invokeRestart("muffleWarning")
[10:25:49.390]                       }
[10:25:49.390]                       else if (inherits(cond, "condition")) {
[10:25:49.390]                         if (!is.null(pattern)) {
[10:25:49.390]                           computeRestarts <- base::computeRestarts
[10:25:49.390]                           grepl <- base::grepl
[10:25:49.390]                           restarts <- computeRestarts(cond)
[10:25:49.390]                           for (restart in restarts) {
[10:25:49.390]                             name <- restart$name
[10:25:49.390]                             if (is.null(name)) 
[10:25:49.390]                               next
[10:25:49.390]                             if (!grepl(pattern, name)) 
[10:25:49.390]                               next
[10:25:49.390]                             invokeRestart(restart)
[10:25:49.390]                             muffled <- TRUE
[10:25:49.390]                             break
[10:25:49.390]                           }
[10:25:49.390]                         }
[10:25:49.390]                       }
[10:25:49.390]                       invisible(muffled)
[10:25:49.390]                     }
[10:25:49.390]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.390]                   }
[10:25:49.390]                 }
[10:25:49.390]             }
[10:25:49.390]         }))
[10:25:49.390]     }, error = function(ex) {
[10:25:49.390]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.390]                 ...future.rng), started = ...future.startTime, 
[10:25:49.390]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.390]             version = "1.8"), class = "FutureResult")
[10:25:49.390]     }, finally = {
[10:25:49.390]         if (!identical(...future.workdir, getwd())) 
[10:25:49.390]             setwd(...future.workdir)
[10:25:49.390]         {
[10:25:49.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.390]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.390]             }
[10:25:49.390]             base::options(...future.oldOptions)
[10:25:49.390]             if (.Platform$OS.type == "windows") {
[10:25:49.390]                 old_names <- names(...future.oldEnvVars)
[10:25:49.390]                 envs <- base::Sys.getenv()
[10:25:49.390]                 names <- names(envs)
[10:25:49.390]                 common <- intersect(names, old_names)
[10:25:49.390]                 added <- setdiff(names, old_names)
[10:25:49.390]                 removed <- setdiff(old_names, names)
[10:25:49.390]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.390]                   envs[common]]
[10:25:49.390]                 NAMES <- toupper(changed)
[10:25:49.390]                 args <- list()
[10:25:49.390]                 for (kk in seq_along(NAMES)) {
[10:25:49.390]                   name <- changed[[kk]]
[10:25:49.390]                   NAME <- NAMES[[kk]]
[10:25:49.390]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.390]                     next
[10:25:49.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.390]                 }
[10:25:49.390]                 NAMES <- toupper(added)
[10:25:49.390]                 for (kk in seq_along(NAMES)) {
[10:25:49.390]                   name <- added[[kk]]
[10:25:49.390]                   NAME <- NAMES[[kk]]
[10:25:49.390]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.390]                     next
[10:25:49.390]                   args[[name]] <- ""
[10:25:49.390]                 }
[10:25:49.390]                 NAMES <- toupper(removed)
[10:25:49.390]                 for (kk in seq_along(NAMES)) {
[10:25:49.390]                   name <- removed[[kk]]
[10:25:49.390]                   NAME <- NAMES[[kk]]
[10:25:49.390]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.390]                     next
[10:25:49.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.390]                 }
[10:25:49.390]                 if (length(args) > 0) 
[10:25:49.390]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.390]             }
[10:25:49.390]             else {
[10:25:49.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.390]             }
[10:25:49.390]             {
[10:25:49.390]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.390]                   0L) {
[10:25:49.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.390]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.390]                   base::options(opts)
[10:25:49.390]                 }
[10:25:49.390]                 {
[10:25:49.390]                   {
[10:25:49.390]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.390]                     NULL
[10:25:49.390]                   }
[10:25:49.390]                   options(future.plan = NULL)
[10:25:49.390]                   if (is.na(NA_character_)) 
[10:25:49.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.390]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.390]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.390]                     envir = parent.frame()) 
[10:25:49.390]                   {
[10:25:49.390]                     if (is.function(workers)) 
[10:25:49.390]                       workers <- workers()
[10:25:49.390]                     workers <- structure(as.integer(workers), 
[10:25:49.390]                       class = class(workers))
[10:25:49.390]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.390]                       workers >= 1)
[10:25:49.390]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.390]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.390]                     }
[10:25:49.390]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.390]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.390]                       envir = envir)
[10:25:49.390]                     if (!future$lazy) 
[10:25:49.390]                       future <- run(future)
[10:25:49.390]                     invisible(future)
[10:25:49.390]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.390]                 }
[10:25:49.390]             }
[10:25:49.390]         }
[10:25:49.390]     })
[10:25:49.390]     if (TRUE) {
[10:25:49.390]         base::sink(type = "output", split = FALSE)
[10:25:49.390]         if (TRUE) {
[10:25:49.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.390]         }
[10:25:49.390]         else {
[10:25:49.390]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.390]         }
[10:25:49.390]         base::close(...future.stdout)
[10:25:49.390]         ...future.stdout <- NULL
[10:25:49.390]     }
[10:25:49.390]     ...future.result$conditions <- ...future.conditions
[10:25:49.390]     ...future.result$finished <- base::Sys.time()
[10:25:49.390]     ...future.result
[10:25:49.390] }
[10:25:49.393] MultisessionFuture started
[10:25:49.393] - Launch lazy future ... done
[10:25:49.393] run() for ‘MultisessionFuture’ ... done
[10:25:49.394] getGlobalsAndPackages() ...
[10:25:49.394] Searching for globals...
[10:25:49.394] - globals found: [1] ‘{’
[10:25:49.394] Searching for globals ... DONE
[10:25:49.394] Resolving globals: FALSE
[10:25:49.395] 
[10:25:49.395] 
[10:25:49.395] getGlobalsAndPackages() ... DONE
[10:25:49.395] run() for ‘Future’ ...
[10:25:49.395] - state: ‘created’
[10:25:49.395] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.409] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.409] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.409]   - Field: ‘node’
[10:25:49.409]   - Field: ‘label’
[10:25:49.409]   - Field: ‘local’
[10:25:49.409]   - Field: ‘owner’
[10:25:49.409]   - Field: ‘envir’
[10:25:49.409]   - Field: ‘workers’
[10:25:49.409]   - Field: ‘packages’
[10:25:49.410]   - Field: ‘gc’
[10:25:49.410]   - Field: ‘conditions’
[10:25:49.410]   - Field: ‘persistent’
[10:25:49.410]   - Field: ‘expr’
[10:25:49.410]   - Field: ‘uuid’
[10:25:49.410]   - Field: ‘seed’
[10:25:49.410]   - Field: ‘version’
[10:25:49.410]   - Field: ‘result’
[10:25:49.410]   - Field: ‘asynchronous’
[10:25:49.410]   - Field: ‘calls’
[10:25:49.410]   - Field: ‘globals’
[10:25:49.411]   - Field: ‘stdout’
[10:25:49.411]   - Field: ‘earlySignal’
[10:25:49.411]   - Field: ‘lazy’
[10:25:49.411]   - Field: ‘state’
[10:25:49.411] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.411] - Launch lazy future ...
[10:25:49.411] Packages needed by the future expression (n = 0): <none>
[10:25:49.411] Packages needed by future strategies (n = 0): <none>
[10:25:49.412] {
[10:25:49.412]     {
[10:25:49.412]         {
[10:25:49.412]             ...future.startTime <- base::Sys.time()
[10:25:49.412]             {
[10:25:49.412]                 {
[10:25:49.412]                   {
[10:25:49.412]                     {
[10:25:49.412]                       base::local({
[10:25:49.412]                         has_future <- base::requireNamespace("future", 
[10:25:49.412]                           quietly = TRUE)
[10:25:49.412]                         if (has_future) {
[10:25:49.412]                           ns <- base::getNamespace("future")
[10:25:49.412]                           version <- ns[[".package"]][["version"]]
[10:25:49.412]                           if (is.null(version)) 
[10:25:49.412]                             version <- utils::packageVersion("future")
[10:25:49.412]                         }
[10:25:49.412]                         else {
[10:25:49.412]                           version <- NULL
[10:25:49.412]                         }
[10:25:49.412]                         if (!has_future || version < "1.8.0") {
[10:25:49.412]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.412]                             "", base::R.version$version.string), 
[10:25:49.412]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.412]                               "release", "version")], collapse = " "), 
[10:25:49.412]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.412]                             info)
[10:25:49.412]                           info <- base::paste(info, collapse = "; ")
[10:25:49.412]                           if (!has_future) {
[10:25:49.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.412]                               info)
[10:25:49.412]                           }
[10:25:49.412]                           else {
[10:25:49.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.412]                               info, version)
[10:25:49.412]                           }
[10:25:49.412]                           base::stop(msg)
[10:25:49.412]                         }
[10:25:49.412]                       })
[10:25:49.412]                     }
[10:25:49.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.412]                     base::options(mc.cores = 1L)
[10:25:49.412]                   }
[10:25:49.412]                   options(future.plan = NULL)
[10:25:49.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.412]                 }
[10:25:49.412]                 ...future.workdir <- getwd()
[10:25:49.412]             }
[10:25:49.412]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.412]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.412]         }
[10:25:49.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.412]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.412]             base::names(...future.oldOptions))
[10:25:49.412]     }
[10:25:49.412]     if (FALSE) {
[10:25:49.412]     }
[10:25:49.412]     else {
[10:25:49.412]         if (TRUE) {
[10:25:49.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.412]                 open = "w")
[10:25:49.412]         }
[10:25:49.412]         else {
[10:25:49.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.412]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.412]         }
[10:25:49.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.412]             base::sink(type = "output", split = FALSE)
[10:25:49.412]             base::close(...future.stdout)
[10:25:49.412]         }, add = TRUE)
[10:25:49.412]     }
[10:25:49.412]     ...future.frame <- base::sys.nframe()
[10:25:49.412]     ...future.conditions <- base::list()
[10:25:49.412]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.412]     if (FALSE) {
[10:25:49.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.412]     }
[10:25:49.412]     ...future.result <- base::tryCatch({
[10:25:49.412]         base::withCallingHandlers({
[10:25:49.412]             ...future.value <- base::withVisible(base::local({
[10:25:49.412]                 ...future.makeSendCondition <- base::local({
[10:25:49.412]                   sendCondition <- NULL
[10:25:49.412]                   function(frame = 1L) {
[10:25:49.412]                     if (is.function(sendCondition)) 
[10:25:49.412]                       return(sendCondition)
[10:25:49.412]                     ns <- getNamespace("parallel")
[10:25:49.412]                     if (exists("sendData", mode = "function", 
[10:25:49.412]                       envir = ns)) {
[10:25:49.412]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.412]                         envir = ns)
[10:25:49.412]                       envir <- sys.frame(frame)
[10:25:49.412]                       master <- NULL
[10:25:49.412]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.412]                         !identical(envir, emptyenv())) {
[10:25:49.412]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.412]                           inherits = FALSE)) {
[10:25:49.412]                           master <- get("master", mode = "list", 
[10:25:49.412]                             envir = envir, inherits = FALSE)
[10:25:49.412]                           if (inherits(master, c("SOCKnode", 
[10:25:49.412]                             "SOCK0node"))) {
[10:25:49.412]                             sendCondition <<- function(cond) {
[10:25:49.412]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.412]                                 success = TRUE)
[10:25:49.412]                               parallel_sendData(master, data)
[10:25:49.412]                             }
[10:25:49.412]                             return(sendCondition)
[10:25:49.412]                           }
[10:25:49.412]                         }
[10:25:49.412]                         frame <- frame + 1L
[10:25:49.412]                         envir <- sys.frame(frame)
[10:25:49.412]                       }
[10:25:49.412]                     }
[10:25:49.412]                     sendCondition <<- function(cond) NULL
[10:25:49.412]                   }
[10:25:49.412]                 })
[10:25:49.412]                 withCallingHandlers({
[10:25:49.412]                   {
[10:25:49.412]                     4
[10:25:49.412]                   }
[10:25:49.412]                 }, immediateCondition = function(cond) {
[10:25:49.412]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.412]                   sendCondition(cond)
[10:25:49.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.412]                   {
[10:25:49.412]                     inherits <- base::inherits
[10:25:49.412]                     invokeRestart <- base::invokeRestart
[10:25:49.412]                     is.null <- base::is.null
[10:25:49.412]                     muffled <- FALSE
[10:25:49.412]                     if (inherits(cond, "message")) {
[10:25:49.412]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.412]                       if (muffled) 
[10:25:49.412]                         invokeRestart("muffleMessage")
[10:25:49.412]                     }
[10:25:49.412]                     else if (inherits(cond, "warning")) {
[10:25:49.412]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.412]                       if (muffled) 
[10:25:49.412]                         invokeRestart("muffleWarning")
[10:25:49.412]                     }
[10:25:49.412]                     else if (inherits(cond, "condition")) {
[10:25:49.412]                       if (!is.null(pattern)) {
[10:25:49.412]                         computeRestarts <- base::computeRestarts
[10:25:49.412]                         grepl <- base::grepl
[10:25:49.412]                         restarts <- computeRestarts(cond)
[10:25:49.412]                         for (restart in restarts) {
[10:25:49.412]                           name <- restart$name
[10:25:49.412]                           if (is.null(name)) 
[10:25:49.412]                             next
[10:25:49.412]                           if (!grepl(pattern, name)) 
[10:25:49.412]                             next
[10:25:49.412]                           invokeRestart(restart)
[10:25:49.412]                           muffled <- TRUE
[10:25:49.412]                           break
[10:25:49.412]                         }
[10:25:49.412]                       }
[10:25:49.412]                     }
[10:25:49.412]                     invisible(muffled)
[10:25:49.412]                   }
[10:25:49.412]                   muffleCondition(cond)
[10:25:49.412]                 })
[10:25:49.412]             }))
[10:25:49.412]             future::FutureResult(value = ...future.value$value, 
[10:25:49.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.412]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.412]                     ...future.globalenv.names))
[10:25:49.412]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.412]         }, condition = base::local({
[10:25:49.412]             c <- base::c
[10:25:49.412]             inherits <- base::inherits
[10:25:49.412]             invokeRestart <- base::invokeRestart
[10:25:49.412]             length <- base::length
[10:25:49.412]             list <- base::list
[10:25:49.412]             seq.int <- base::seq.int
[10:25:49.412]             signalCondition <- base::signalCondition
[10:25:49.412]             sys.calls <- base::sys.calls
[10:25:49.412]             `[[` <- base::`[[`
[10:25:49.412]             `+` <- base::`+`
[10:25:49.412]             `<<-` <- base::`<<-`
[10:25:49.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.412]                   3L)]
[10:25:49.412]             }
[10:25:49.412]             function(cond) {
[10:25:49.412]                 is_error <- inherits(cond, "error")
[10:25:49.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.412]                   NULL)
[10:25:49.412]                 if (is_error) {
[10:25:49.412]                   sessionInformation <- function() {
[10:25:49.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.412]                       search = base::search(), system = base::Sys.info())
[10:25:49.412]                   }
[10:25:49.412]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.412]                     cond$call), session = sessionInformation(), 
[10:25:49.412]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.412]                   signalCondition(cond)
[10:25:49.412]                 }
[10:25:49.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.412]                 "immediateCondition"))) {
[10:25:49.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.412]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.412]                   if (TRUE && !signal) {
[10:25:49.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.412]                     {
[10:25:49.412]                       inherits <- base::inherits
[10:25:49.412]                       invokeRestart <- base::invokeRestart
[10:25:49.412]                       is.null <- base::is.null
[10:25:49.412]                       muffled <- FALSE
[10:25:49.412]                       if (inherits(cond, "message")) {
[10:25:49.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.412]                         if (muffled) 
[10:25:49.412]                           invokeRestart("muffleMessage")
[10:25:49.412]                       }
[10:25:49.412]                       else if (inherits(cond, "warning")) {
[10:25:49.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.412]                         if (muffled) 
[10:25:49.412]                           invokeRestart("muffleWarning")
[10:25:49.412]                       }
[10:25:49.412]                       else if (inherits(cond, "condition")) {
[10:25:49.412]                         if (!is.null(pattern)) {
[10:25:49.412]                           computeRestarts <- base::computeRestarts
[10:25:49.412]                           grepl <- base::grepl
[10:25:49.412]                           restarts <- computeRestarts(cond)
[10:25:49.412]                           for (restart in restarts) {
[10:25:49.412]                             name <- restart$name
[10:25:49.412]                             if (is.null(name)) 
[10:25:49.412]                               next
[10:25:49.412]                             if (!grepl(pattern, name)) 
[10:25:49.412]                               next
[10:25:49.412]                             invokeRestart(restart)
[10:25:49.412]                             muffled <- TRUE
[10:25:49.412]                             break
[10:25:49.412]                           }
[10:25:49.412]                         }
[10:25:49.412]                       }
[10:25:49.412]                       invisible(muffled)
[10:25:49.412]                     }
[10:25:49.412]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.412]                   }
[10:25:49.412]                 }
[10:25:49.412]                 else {
[10:25:49.412]                   if (TRUE) {
[10:25:49.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.412]                     {
[10:25:49.412]                       inherits <- base::inherits
[10:25:49.412]                       invokeRestart <- base::invokeRestart
[10:25:49.412]                       is.null <- base::is.null
[10:25:49.412]                       muffled <- FALSE
[10:25:49.412]                       if (inherits(cond, "message")) {
[10:25:49.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.412]                         if (muffled) 
[10:25:49.412]                           invokeRestart("muffleMessage")
[10:25:49.412]                       }
[10:25:49.412]                       else if (inherits(cond, "warning")) {
[10:25:49.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.412]                         if (muffled) 
[10:25:49.412]                           invokeRestart("muffleWarning")
[10:25:49.412]                       }
[10:25:49.412]                       else if (inherits(cond, "condition")) {
[10:25:49.412]                         if (!is.null(pattern)) {
[10:25:49.412]                           computeRestarts <- base::computeRestarts
[10:25:49.412]                           grepl <- base::grepl
[10:25:49.412]                           restarts <- computeRestarts(cond)
[10:25:49.412]                           for (restart in restarts) {
[10:25:49.412]                             name <- restart$name
[10:25:49.412]                             if (is.null(name)) 
[10:25:49.412]                               next
[10:25:49.412]                             if (!grepl(pattern, name)) 
[10:25:49.412]                               next
[10:25:49.412]                             invokeRestart(restart)
[10:25:49.412]                             muffled <- TRUE
[10:25:49.412]                             break
[10:25:49.412]                           }
[10:25:49.412]                         }
[10:25:49.412]                       }
[10:25:49.412]                       invisible(muffled)
[10:25:49.412]                     }
[10:25:49.412]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.412]                   }
[10:25:49.412]                 }
[10:25:49.412]             }
[10:25:49.412]         }))
[10:25:49.412]     }, error = function(ex) {
[10:25:49.412]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.412]                 ...future.rng), started = ...future.startTime, 
[10:25:49.412]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.412]             version = "1.8"), class = "FutureResult")
[10:25:49.412]     }, finally = {
[10:25:49.412]         if (!identical(...future.workdir, getwd())) 
[10:25:49.412]             setwd(...future.workdir)
[10:25:49.412]         {
[10:25:49.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.412]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.412]             }
[10:25:49.412]             base::options(...future.oldOptions)
[10:25:49.412]             if (.Platform$OS.type == "windows") {
[10:25:49.412]                 old_names <- names(...future.oldEnvVars)
[10:25:49.412]                 envs <- base::Sys.getenv()
[10:25:49.412]                 names <- names(envs)
[10:25:49.412]                 common <- intersect(names, old_names)
[10:25:49.412]                 added <- setdiff(names, old_names)
[10:25:49.412]                 removed <- setdiff(old_names, names)
[10:25:49.412]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.412]                   envs[common]]
[10:25:49.412]                 NAMES <- toupper(changed)
[10:25:49.412]                 args <- list()
[10:25:49.412]                 for (kk in seq_along(NAMES)) {
[10:25:49.412]                   name <- changed[[kk]]
[10:25:49.412]                   NAME <- NAMES[[kk]]
[10:25:49.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.412]                     next
[10:25:49.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.412]                 }
[10:25:49.412]                 NAMES <- toupper(added)
[10:25:49.412]                 for (kk in seq_along(NAMES)) {
[10:25:49.412]                   name <- added[[kk]]
[10:25:49.412]                   NAME <- NAMES[[kk]]
[10:25:49.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.412]                     next
[10:25:49.412]                   args[[name]] <- ""
[10:25:49.412]                 }
[10:25:49.412]                 NAMES <- toupper(removed)
[10:25:49.412]                 for (kk in seq_along(NAMES)) {
[10:25:49.412]                   name <- removed[[kk]]
[10:25:49.412]                   NAME <- NAMES[[kk]]
[10:25:49.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.412]                     next
[10:25:49.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.412]                 }
[10:25:49.412]                 if (length(args) > 0) 
[10:25:49.412]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.412]             }
[10:25:49.412]             else {
[10:25:49.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.412]             }
[10:25:49.412]             {
[10:25:49.412]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.412]                   0L) {
[10:25:49.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.412]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.412]                   base::options(opts)
[10:25:49.412]                 }
[10:25:49.412]                 {
[10:25:49.412]                   {
[10:25:49.412]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.412]                     NULL
[10:25:49.412]                   }
[10:25:49.412]                   options(future.plan = NULL)
[10:25:49.412]                   if (is.na(NA_character_)) 
[10:25:49.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.412]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.412]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.412]                     envir = parent.frame()) 
[10:25:49.412]                   {
[10:25:49.412]                     if (is.function(workers)) 
[10:25:49.412]                       workers <- workers()
[10:25:49.412]                     workers <- structure(as.integer(workers), 
[10:25:49.412]                       class = class(workers))
[10:25:49.412]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.412]                       workers >= 1)
[10:25:49.412]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.412]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.412]                     }
[10:25:49.412]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.412]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.412]                       envir = envir)
[10:25:49.412]                     if (!future$lazy) 
[10:25:49.412]                       future <- run(future)
[10:25:49.412]                     invisible(future)
[10:25:49.412]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.412]                 }
[10:25:49.412]             }
[10:25:49.412]         }
[10:25:49.412]     })
[10:25:49.412]     if (TRUE) {
[10:25:49.412]         base::sink(type = "output", split = FALSE)
[10:25:49.412]         if (TRUE) {
[10:25:49.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.412]         }
[10:25:49.412]         else {
[10:25:49.412]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.412]         }
[10:25:49.412]         base::close(...future.stdout)
[10:25:49.412]         ...future.stdout <- NULL
[10:25:49.412]     }
[10:25:49.412]     ...future.result$conditions <- ...future.conditions
[10:25:49.412]     ...future.result$finished <- base::Sys.time()
[10:25:49.412]     ...future.result
[10:25:49.412] }
[10:25:49.414] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:49.425] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.425] - Validating connection of MultisessionFuture
[10:25:49.425] - received message: FutureResult
[10:25:49.425] - Received FutureResult
[10:25:49.426] - Erased future from FutureRegistry
[10:25:49.426] result() for ClusterFuture ...
[10:25:49.426] - result already collected: FutureResult
[10:25:49.426] result() for ClusterFuture ... done
[10:25:49.426] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.426] result() for ClusterFuture ...
[10:25:49.426] - result already collected: FutureResult
[10:25:49.426] result() for ClusterFuture ... done
[10:25:49.426] result() for ClusterFuture ...
[10:25:49.426] - result already collected: FutureResult
[10:25:49.427] result() for ClusterFuture ... done
[10:25:49.428] MultisessionFuture started
[10:25:49.428] - Launch lazy future ... done
[10:25:49.428] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c0f6f3e2e0> 
<environment: 0x55c0f39c02d8> 
[10:25:49.438] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.438] - Validating connection of MultisessionFuture
[10:25:49.439] - received message: FutureResult
[10:25:49.439] - Received FutureResult
[10:25:49.439] - Erased future from FutureRegistry
[10:25:49.439] result() for ClusterFuture ...
[10:25:49.439] - result already collected: FutureResult
[10:25:49.439] result() for ClusterFuture ... done
[10:25:49.439] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:49.451] resolve() on environment ...
[10:25:49.451]  recursive: 0
[10:25:49.451]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:49.452] signalConditionsASAP(numeric, pos=1) ...
[10:25:49.452] - nx: 4
[10:25:49.452] - relay: TRUE
[10:25:49.452] - stdout: TRUE
[10:25:49.452] - signal: TRUE
[10:25:49.452] - resignal: FALSE
[10:25:49.452] - force: TRUE
[10:25:49.452] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.452] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.452]  - until=2
[10:25:49.452]  - relaying element #2
[10:25:49.453] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.453] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.453] signalConditionsASAP(NULL, pos=1) ... done
[10:25:49.453]  length: 3 (resolved future 1)
[10:25:49.453] Future #2
[10:25:49.453] result() for ClusterFuture ...
[10:25:49.453] - result already collected: FutureResult
[10:25:49.453] result() for ClusterFuture ... done
[10:25:49.453] result() for ClusterFuture ...
[10:25:49.454] - result already collected: FutureResult
[10:25:49.454] result() for ClusterFuture ... done
[10:25:49.454] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:49.454] - nx: 4
[10:25:49.454] - relay: TRUE
[10:25:49.454] - stdout: TRUE
[10:25:49.454] - signal: TRUE
[10:25:49.454] - resignal: FALSE
[10:25:49.454] - force: TRUE
[10:25:49.454] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.454] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.455]  - until=2
[10:25:49.455]  - relaying element #2
[10:25:49.455] result() for ClusterFuture ...
[10:25:49.455] - result already collected: FutureResult
[10:25:49.455] result() for ClusterFuture ... done
[10:25:49.455] result() for ClusterFuture ...
[10:25:49.455] - result already collected: FutureResult
[10:25:49.455] result() for ClusterFuture ... done
[10:25:49.455] result() for ClusterFuture ...
[10:25:49.455] - result already collected: FutureResult
[10:25:49.455] result() for ClusterFuture ... done
[10:25:49.456] result() for ClusterFuture ...
[10:25:49.456] - result already collected: FutureResult
[10:25:49.456] result() for ClusterFuture ... done
[10:25:49.456] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.456] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.456] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:49.456]  length: 2 (resolved future 2)
[10:25:49.456] Future #3
[10:25:49.456] result() for ClusterFuture ...
[10:25:49.456] - result already collected: FutureResult
[10:25:49.456] result() for ClusterFuture ... done
[10:25:49.457] result() for ClusterFuture ...
[10:25:49.457] - result already collected: FutureResult
[10:25:49.457] result() for ClusterFuture ... done
[10:25:49.457] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:49.457] - nx: 4
[10:25:49.457] - relay: TRUE
[10:25:49.457] - stdout: TRUE
[10:25:49.457] - signal: TRUE
[10:25:49.457] - resignal: FALSE
[10:25:49.457] - force: TRUE
[10:25:49.457] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.457] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.458]  - until=3
[10:25:49.458]  - relaying element #3
[10:25:49.458] result() for ClusterFuture ...
[10:25:49.458] - result already collected: FutureResult
[10:25:49.458] result() for ClusterFuture ... done
[10:25:49.458] result() for ClusterFuture ...
[10:25:49.458] - result already collected: FutureResult
[10:25:49.458] result() for ClusterFuture ... done
[10:25:49.458] result() for ClusterFuture ...
[10:25:49.458] - result already collected: FutureResult
[10:25:49.458] result() for ClusterFuture ... done
[10:25:49.459] result() for ClusterFuture ...
[10:25:49.459] - result already collected: FutureResult
[10:25:49.459] result() for ClusterFuture ... done
[10:25:49.459] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.459] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.459] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:49.459]  length: 1 (resolved future 3)
[10:25:49.480] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.480] - Validating connection of MultisessionFuture
[10:25:49.481] - received message: FutureResult
[10:25:49.481] - Received FutureResult
[10:25:49.481] - Erased future from FutureRegistry
[10:25:49.481] result() for ClusterFuture ...
[10:25:49.481] - result already collected: FutureResult
[10:25:49.481] result() for ClusterFuture ... done
[10:25:49.481] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.481] Future #4
[10:25:49.481] result() for ClusterFuture ...
[10:25:49.482] - result already collected: FutureResult
[10:25:49.482] result() for ClusterFuture ... done
[10:25:49.482] result() for ClusterFuture ...
[10:25:49.482] - result already collected: FutureResult
[10:25:49.482] result() for ClusterFuture ... done
[10:25:49.482] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:49.482] - nx: 4
[10:25:49.482] - relay: TRUE
[10:25:49.482] - stdout: TRUE
[10:25:49.482] - signal: TRUE
[10:25:49.482] - resignal: FALSE
[10:25:49.482] - force: TRUE
[10:25:49.483] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.483] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.483]  - until=4
[10:25:49.483]  - relaying element #4
[10:25:49.483] result() for ClusterFuture ...
[10:25:49.483] - result already collected: FutureResult
[10:25:49.483] result() for ClusterFuture ... done
[10:25:49.483] result() for ClusterFuture ...
[10:25:49.483] - result already collected: FutureResult
[10:25:49.483] result() for ClusterFuture ... done
[10:25:49.483] result() for ClusterFuture ...
[10:25:49.484] - result already collected: FutureResult
[10:25:49.484] result() for ClusterFuture ... done
[10:25:49.484] result() for ClusterFuture ...
[10:25:49.484] - result already collected: FutureResult
[10:25:49.484] result() for ClusterFuture ... done
[10:25:49.484] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.484] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.484] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:49.484]  length: 0 (resolved future 4)
[10:25:49.484] Relaying remaining futures
[10:25:49.484] signalConditionsASAP(NULL, pos=0) ...
[10:25:49.484] - nx: 4
[10:25:49.485] - relay: TRUE
[10:25:49.485] - stdout: TRUE
[10:25:49.485] - signal: TRUE
[10:25:49.485] - resignal: FALSE
[10:25:49.485] - force: TRUE
[10:25:49.485] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.485] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:49.485] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.485] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.485] signalConditionsASAP(NULL, pos=0) ... done
[10:25:49.485] resolve() on environment ... DONE
[10:25:49.486] result() for ClusterFuture ...
[10:25:49.486] - result already collected: FutureResult
[10:25:49.486] result() for ClusterFuture ... done
[10:25:49.486] result() for ClusterFuture ...
[10:25:49.486] - result already collected: FutureResult
[10:25:49.486] result() for ClusterFuture ... done
[10:25:49.486] result() for ClusterFuture ...
[10:25:49.486] - result already collected: FutureResult
[10:25:49.486] result() for ClusterFuture ... done
[10:25:49.486] result() for ClusterFuture ...
[10:25:49.486] - result already collected: FutureResult
[10:25:49.487] result() for ClusterFuture ... done
[10:25:49.487] result() for ClusterFuture ...
[10:25:49.487] - result already collected: FutureResult
[10:25:49.487] result() for ClusterFuture ... done
[10:25:49.487] result() for ClusterFuture ...
[10:25:49.487] - result already collected: FutureResult
[10:25:49.487] result() for ClusterFuture ... done
<environment: 0x55c0f473a7a0> 
Dimensions: c(2, 3)
[10:25:49.487] getGlobalsAndPackages() ...
[10:25:49.488] Searching for globals...
[10:25:49.488] 
[10:25:49.488] Searching for globals ... DONE
[10:25:49.488] - globals: [0] <none>
[10:25:49.488] getGlobalsAndPackages() ... DONE
[10:25:49.488] run() for ‘Future’ ...
[10:25:49.489] - state: ‘created’
[10:25:49.489] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.502] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.502] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.502]   - Field: ‘node’
[10:25:49.503]   - Field: ‘label’
[10:25:49.503]   - Field: ‘local’
[10:25:49.503]   - Field: ‘owner’
[10:25:49.503]   - Field: ‘envir’
[10:25:49.503]   - Field: ‘workers’
[10:25:49.503]   - Field: ‘packages’
[10:25:49.503]   - Field: ‘gc’
[10:25:49.503]   - Field: ‘conditions’
[10:25:49.503]   - Field: ‘persistent’
[10:25:49.503]   - Field: ‘expr’
[10:25:49.503]   - Field: ‘uuid’
[10:25:49.504]   - Field: ‘seed’
[10:25:49.504]   - Field: ‘version’
[10:25:49.504]   - Field: ‘result’
[10:25:49.504]   - Field: ‘asynchronous’
[10:25:49.504]   - Field: ‘calls’
[10:25:49.504]   - Field: ‘globals’
[10:25:49.504]   - Field: ‘stdout’
[10:25:49.504]   - Field: ‘earlySignal’
[10:25:49.504]   - Field: ‘lazy’
[10:25:49.504]   - Field: ‘state’
[10:25:49.504] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.505] - Launch lazy future ...
[10:25:49.505] Packages needed by the future expression (n = 0): <none>
[10:25:49.505] Packages needed by future strategies (n = 0): <none>
[10:25:49.505] {
[10:25:49.505]     {
[10:25:49.505]         {
[10:25:49.505]             ...future.startTime <- base::Sys.time()
[10:25:49.505]             {
[10:25:49.505]                 {
[10:25:49.505]                   {
[10:25:49.505]                     {
[10:25:49.505]                       base::local({
[10:25:49.505]                         has_future <- base::requireNamespace("future", 
[10:25:49.505]                           quietly = TRUE)
[10:25:49.505]                         if (has_future) {
[10:25:49.505]                           ns <- base::getNamespace("future")
[10:25:49.505]                           version <- ns[[".package"]][["version"]]
[10:25:49.505]                           if (is.null(version)) 
[10:25:49.505]                             version <- utils::packageVersion("future")
[10:25:49.505]                         }
[10:25:49.505]                         else {
[10:25:49.505]                           version <- NULL
[10:25:49.505]                         }
[10:25:49.505]                         if (!has_future || version < "1.8.0") {
[10:25:49.505]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.505]                             "", base::R.version$version.string), 
[10:25:49.505]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.505]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.505]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.505]                               "release", "version")], collapse = " "), 
[10:25:49.505]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.505]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.505]                             info)
[10:25:49.505]                           info <- base::paste(info, collapse = "; ")
[10:25:49.505]                           if (!has_future) {
[10:25:49.505]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.505]                               info)
[10:25:49.505]                           }
[10:25:49.505]                           else {
[10:25:49.505]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.505]                               info, version)
[10:25:49.505]                           }
[10:25:49.505]                           base::stop(msg)
[10:25:49.505]                         }
[10:25:49.505]                       })
[10:25:49.505]                     }
[10:25:49.505]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.505]                     base::options(mc.cores = 1L)
[10:25:49.505]                   }
[10:25:49.505]                   options(future.plan = NULL)
[10:25:49.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.505]                 }
[10:25:49.505]                 ...future.workdir <- getwd()
[10:25:49.505]             }
[10:25:49.505]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.505]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.505]         }
[10:25:49.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.505]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.505]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.505]             base::names(...future.oldOptions))
[10:25:49.505]     }
[10:25:49.505]     if (FALSE) {
[10:25:49.505]     }
[10:25:49.505]     else {
[10:25:49.505]         if (TRUE) {
[10:25:49.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.505]                 open = "w")
[10:25:49.505]         }
[10:25:49.505]         else {
[10:25:49.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.505]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.505]         }
[10:25:49.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.505]             base::sink(type = "output", split = FALSE)
[10:25:49.505]             base::close(...future.stdout)
[10:25:49.505]         }, add = TRUE)
[10:25:49.505]     }
[10:25:49.505]     ...future.frame <- base::sys.nframe()
[10:25:49.505]     ...future.conditions <- base::list()
[10:25:49.505]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.505]     if (FALSE) {
[10:25:49.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.505]     }
[10:25:49.505]     ...future.result <- base::tryCatch({
[10:25:49.505]         base::withCallingHandlers({
[10:25:49.505]             ...future.value <- base::withVisible(base::local({
[10:25:49.505]                 ...future.makeSendCondition <- base::local({
[10:25:49.505]                   sendCondition <- NULL
[10:25:49.505]                   function(frame = 1L) {
[10:25:49.505]                     if (is.function(sendCondition)) 
[10:25:49.505]                       return(sendCondition)
[10:25:49.505]                     ns <- getNamespace("parallel")
[10:25:49.505]                     if (exists("sendData", mode = "function", 
[10:25:49.505]                       envir = ns)) {
[10:25:49.505]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.505]                         envir = ns)
[10:25:49.505]                       envir <- sys.frame(frame)
[10:25:49.505]                       master <- NULL
[10:25:49.505]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.505]                         !identical(envir, emptyenv())) {
[10:25:49.505]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.505]                           inherits = FALSE)) {
[10:25:49.505]                           master <- get("master", mode = "list", 
[10:25:49.505]                             envir = envir, inherits = FALSE)
[10:25:49.505]                           if (inherits(master, c("SOCKnode", 
[10:25:49.505]                             "SOCK0node"))) {
[10:25:49.505]                             sendCondition <<- function(cond) {
[10:25:49.505]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.505]                                 success = TRUE)
[10:25:49.505]                               parallel_sendData(master, data)
[10:25:49.505]                             }
[10:25:49.505]                             return(sendCondition)
[10:25:49.505]                           }
[10:25:49.505]                         }
[10:25:49.505]                         frame <- frame + 1L
[10:25:49.505]                         envir <- sys.frame(frame)
[10:25:49.505]                       }
[10:25:49.505]                     }
[10:25:49.505]                     sendCondition <<- function(cond) NULL
[10:25:49.505]                   }
[10:25:49.505]                 })
[10:25:49.505]                 withCallingHandlers({
[10:25:49.505]                   2
[10:25:49.505]                 }, immediateCondition = function(cond) {
[10:25:49.505]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.505]                   sendCondition(cond)
[10:25:49.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.505]                   {
[10:25:49.505]                     inherits <- base::inherits
[10:25:49.505]                     invokeRestart <- base::invokeRestart
[10:25:49.505]                     is.null <- base::is.null
[10:25:49.505]                     muffled <- FALSE
[10:25:49.505]                     if (inherits(cond, "message")) {
[10:25:49.505]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.505]                       if (muffled) 
[10:25:49.505]                         invokeRestart("muffleMessage")
[10:25:49.505]                     }
[10:25:49.505]                     else if (inherits(cond, "warning")) {
[10:25:49.505]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.505]                       if (muffled) 
[10:25:49.505]                         invokeRestart("muffleWarning")
[10:25:49.505]                     }
[10:25:49.505]                     else if (inherits(cond, "condition")) {
[10:25:49.505]                       if (!is.null(pattern)) {
[10:25:49.505]                         computeRestarts <- base::computeRestarts
[10:25:49.505]                         grepl <- base::grepl
[10:25:49.505]                         restarts <- computeRestarts(cond)
[10:25:49.505]                         for (restart in restarts) {
[10:25:49.505]                           name <- restart$name
[10:25:49.505]                           if (is.null(name)) 
[10:25:49.505]                             next
[10:25:49.505]                           if (!grepl(pattern, name)) 
[10:25:49.505]                             next
[10:25:49.505]                           invokeRestart(restart)
[10:25:49.505]                           muffled <- TRUE
[10:25:49.505]                           break
[10:25:49.505]                         }
[10:25:49.505]                       }
[10:25:49.505]                     }
[10:25:49.505]                     invisible(muffled)
[10:25:49.505]                   }
[10:25:49.505]                   muffleCondition(cond)
[10:25:49.505]                 })
[10:25:49.505]             }))
[10:25:49.505]             future::FutureResult(value = ...future.value$value, 
[10:25:49.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.505]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.505]                     ...future.globalenv.names))
[10:25:49.505]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.505]         }, condition = base::local({
[10:25:49.505]             c <- base::c
[10:25:49.505]             inherits <- base::inherits
[10:25:49.505]             invokeRestart <- base::invokeRestart
[10:25:49.505]             length <- base::length
[10:25:49.505]             list <- base::list
[10:25:49.505]             seq.int <- base::seq.int
[10:25:49.505]             signalCondition <- base::signalCondition
[10:25:49.505]             sys.calls <- base::sys.calls
[10:25:49.505]             `[[` <- base::`[[`
[10:25:49.505]             `+` <- base::`+`
[10:25:49.505]             `<<-` <- base::`<<-`
[10:25:49.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.505]                   3L)]
[10:25:49.505]             }
[10:25:49.505]             function(cond) {
[10:25:49.505]                 is_error <- inherits(cond, "error")
[10:25:49.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.505]                   NULL)
[10:25:49.505]                 if (is_error) {
[10:25:49.505]                   sessionInformation <- function() {
[10:25:49.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.505]                       search = base::search(), system = base::Sys.info())
[10:25:49.505]                   }
[10:25:49.505]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.505]                     cond$call), session = sessionInformation(), 
[10:25:49.505]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.505]                   signalCondition(cond)
[10:25:49.505]                 }
[10:25:49.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.505]                 "immediateCondition"))) {
[10:25:49.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.505]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.505]                   if (TRUE && !signal) {
[10:25:49.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.505]                     {
[10:25:49.505]                       inherits <- base::inherits
[10:25:49.505]                       invokeRestart <- base::invokeRestart
[10:25:49.505]                       is.null <- base::is.null
[10:25:49.505]                       muffled <- FALSE
[10:25:49.505]                       if (inherits(cond, "message")) {
[10:25:49.505]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.505]                         if (muffled) 
[10:25:49.505]                           invokeRestart("muffleMessage")
[10:25:49.505]                       }
[10:25:49.505]                       else if (inherits(cond, "warning")) {
[10:25:49.505]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.505]                         if (muffled) 
[10:25:49.505]                           invokeRestart("muffleWarning")
[10:25:49.505]                       }
[10:25:49.505]                       else if (inherits(cond, "condition")) {
[10:25:49.505]                         if (!is.null(pattern)) {
[10:25:49.505]                           computeRestarts <- base::computeRestarts
[10:25:49.505]                           grepl <- base::grepl
[10:25:49.505]                           restarts <- computeRestarts(cond)
[10:25:49.505]                           for (restart in restarts) {
[10:25:49.505]                             name <- restart$name
[10:25:49.505]                             if (is.null(name)) 
[10:25:49.505]                               next
[10:25:49.505]                             if (!grepl(pattern, name)) 
[10:25:49.505]                               next
[10:25:49.505]                             invokeRestart(restart)
[10:25:49.505]                             muffled <- TRUE
[10:25:49.505]                             break
[10:25:49.505]                           }
[10:25:49.505]                         }
[10:25:49.505]                       }
[10:25:49.505]                       invisible(muffled)
[10:25:49.505]                     }
[10:25:49.505]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.505]                   }
[10:25:49.505]                 }
[10:25:49.505]                 else {
[10:25:49.505]                   if (TRUE) {
[10:25:49.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.505]                     {
[10:25:49.505]                       inherits <- base::inherits
[10:25:49.505]                       invokeRestart <- base::invokeRestart
[10:25:49.505]                       is.null <- base::is.null
[10:25:49.505]                       muffled <- FALSE
[10:25:49.505]                       if (inherits(cond, "message")) {
[10:25:49.505]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.505]                         if (muffled) 
[10:25:49.505]                           invokeRestart("muffleMessage")
[10:25:49.505]                       }
[10:25:49.505]                       else if (inherits(cond, "warning")) {
[10:25:49.505]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.505]                         if (muffled) 
[10:25:49.505]                           invokeRestart("muffleWarning")
[10:25:49.505]                       }
[10:25:49.505]                       else if (inherits(cond, "condition")) {
[10:25:49.505]                         if (!is.null(pattern)) {
[10:25:49.505]                           computeRestarts <- base::computeRestarts
[10:25:49.505]                           grepl <- base::grepl
[10:25:49.505]                           restarts <- computeRestarts(cond)
[10:25:49.505]                           for (restart in restarts) {
[10:25:49.505]                             name <- restart$name
[10:25:49.505]                             if (is.null(name)) 
[10:25:49.505]                               next
[10:25:49.505]                             if (!grepl(pattern, name)) 
[10:25:49.505]                               next
[10:25:49.505]                             invokeRestart(restart)
[10:25:49.505]                             muffled <- TRUE
[10:25:49.505]                             break
[10:25:49.505]                           }
[10:25:49.505]                         }
[10:25:49.505]                       }
[10:25:49.505]                       invisible(muffled)
[10:25:49.505]                     }
[10:25:49.505]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.505]                   }
[10:25:49.505]                 }
[10:25:49.505]             }
[10:25:49.505]         }))
[10:25:49.505]     }, error = function(ex) {
[10:25:49.505]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.505]                 ...future.rng), started = ...future.startTime, 
[10:25:49.505]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.505]             version = "1.8"), class = "FutureResult")
[10:25:49.505]     }, finally = {
[10:25:49.505]         if (!identical(...future.workdir, getwd())) 
[10:25:49.505]             setwd(...future.workdir)
[10:25:49.505]         {
[10:25:49.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.505]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.505]             }
[10:25:49.505]             base::options(...future.oldOptions)
[10:25:49.505]             if (.Platform$OS.type == "windows") {
[10:25:49.505]                 old_names <- names(...future.oldEnvVars)
[10:25:49.505]                 envs <- base::Sys.getenv()
[10:25:49.505]                 names <- names(envs)
[10:25:49.505]                 common <- intersect(names, old_names)
[10:25:49.505]                 added <- setdiff(names, old_names)
[10:25:49.505]                 removed <- setdiff(old_names, names)
[10:25:49.505]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.505]                   envs[common]]
[10:25:49.505]                 NAMES <- toupper(changed)
[10:25:49.505]                 args <- list()
[10:25:49.505]                 for (kk in seq_along(NAMES)) {
[10:25:49.505]                   name <- changed[[kk]]
[10:25:49.505]                   NAME <- NAMES[[kk]]
[10:25:49.505]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.505]                     next
[10:25:49.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.505]                 }
[10:25:49.505]                 NAMES <- toupper(added)
[10:25:49.505]                 for (kk in seq_along(NAMES)) {
[10:25:49.505]                   name <- added[[kk]]
[10:25:49.505]                   NAME <- NAMES[[kk]]
[10:25:49.505]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.505]                     next
[10:25:49.505]                   args[[name]] <- ""
[10:25:49.505]                 }
[10:25:49.505]                 NAMES <- toupper(removed)
[10:25:49.505]                 for (kk in seq_along(NAMES)) {
[10:25:49.505]                   name <- removed[[kk]]
[10:25:49.505]                   NAME <- NAMES[[kk]]
[10:25:49.505]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.505]                     next
[10:25:49.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.505]                 }
[10:25:49.505]                 if (length(args) > 0) 
[10:25:49.505]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.505]             }
[10:25:49.505]             else {
[10:25:49.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.505]             }
[10:25:49.505]             {
[10:25:49.505]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.505]                   0L) {
[10:25:49.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.505]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.505]                   base::options(opts)
[10:25:49.505]                 }
[10:25:49.505]                 {
[10:25:49.505]                   {
[10:25:49.505]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.505]                     NULL
[10:25:49.505]                   }
[10:25:49.505]                   options(future.plan = NULL)
[10:25:49.505]                   if (is.na(NA_character_)) 
[10:25:49.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.505]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.505]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.505]                     envir = parent.frame()) 
[10:25:49.505]                   {
[10:25:49.505]                     if (is.function(workers)) 
[10:25:49.505]                       workers <- workers()
[10:25:49.505]                     workers <- structure(as.integer(workers), 
[10:25:49.505]                       class = class(workers))
[10:25:49.505]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.505]                       workers >= 1)
[10:25:49.505]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.505]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.505]                     }
[10:25:49.505]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.505]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.505]                       envir = envir)
[10:25:49.505]                     if (!future$lazy) 
[10:25:49.505]                       future <- run(future)
[10:25:49.505]                     invisible(future)
[10:25:49.505]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.505]                 }
[10:25:49.505]             }
[10:25:49.505]         }
[10:25:49.505]     })
[10:25:49.505]     if (TRUE) {
[10:25:49.505]         base::sink(type = "output", split = FALSE)
[10:25:49.505]         if (TRUE) {
[10:25:49.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.505]         }
[10:25:49.505]         else {
[10:25:49.505]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.505]         }
[10:25:49.505]         base::close(...future.stdout)
[10:25:49.505]         ...future.stdout <- NULL
[10:25:49.505]     }
[10:25:49.505]     ...future.result$conditions <- ...future.conditions
[10:25:49.505]     ...future.result$finished <- base::Sys.time()
[10:25:49.505]     ...future.result
[10:25:49.505] }
[10:25:49.508] MultisessionFuture started
[10:25:49.508] - Launch lazy future ... done
[10:25:49.509] run() for ‘MultisessionFuture’ ... done
[10:25:49.509] getGlobalsAndPackages() ...
[10:25:49.509] Searching for globals...
[10:25:49.509] 
[10:25:49.509] Searching for globals ... DONE
[10:25:49.509] - globals: [0] <none>
[10:25:49.509] getGlobalsAndPackages() ... DONE
[10:25:49.510] run() for ‘Future’ ...
[10:25:49.510] - state: ‘created’
[10:25:49.510] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.523] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.523]   - Field: ‘node’
[10:25:49.523]   - Field: ‘label’
[10:25:49.523]   - Field: ‘local’
[10:25:49.524]   - Field: ‘owner’
[10:25:49.524]   - Field: ‘envir’
[10:25:49.524]   - Field: ‘workers’
[10:25:49.524]   - Field: ‘packages’
[10:25:49.524]   - Field: ‘gc’
[10:25:49.524]   - Field: ‘conditions’
[10:25:49.524]   - Field: ‘persistent’
[10:25:49.524]   - Field: ‘expr’
[10:25:49.524]   - Field: ‘uuid’
[10:25:49.524]   - Field: ‘seed’
[10:25:49.525]   - Field: ‘version’
[10:25:49.525]   - Field: ‘result’
[10:25:49.525]   - Field: ‘asynchronous’
[10:25:49.525]   - Field: ‘calls’
[10:25:49.525]   - Field: ‘globals’
[10:25:49.525]   - Field: ‘stdout’
[10:25:49.525]   - Field: ‘earlySignal’
[10:25:49.525]   - Field: ‘lazy’
[10:25:49.525]   - Field: ‘state’
[10:25:49.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.526] - Launch lazy future ...
[10:25:49.526] Packages needed by the future expression (n = 0): <none>
[10:25:49.526] Packages needed by future strategies (n = 0): <none>
[10:25:49.526] {
[10:25:49.526]     {
[10:25:49.526]         {
[10:25:49.526]             ...future.startTime <- base::Sys.time()
[10:25:49.526]             {
[10:25:49.526]                 {
[10:25:49.526]                   {
[10:25:49.526]                     {
[10:25:49.526]                       base::local({
[10:25:49.526]                         has_future <- base::requireNamespace("future", 
[10:25:49.526]                           quietly = TRUE)
[10:25:49.526]                         if (has_future) {
[10:25:49.526]                           ns <- base::getNamespace("future")
[10:25:49.526]                           version <- ns[[".package"]][["version"]]
[10:25:49.526]                           if (is.null(version)) 
[10:25:49.526]                             version <- utils::packageVersion("future")
[10:25:49.526]                         }
[10:25:49.526]                         else {
[10:25:49.526]                           version <- NULL
[10:25:49.526]                         }
[10:25:49.526]                         if (!has_future || version < "1.8.0") {
[10:25:49.526]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.526]                             "", base::R.version$version.string), 
[10:25:49.526]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.526]                               "release", "version")], collapse = " "), 
[10:25:49.526]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.526]                             info)
[10:25:49.526]                           info <- base::paste(info, collapse = "; ")
[10:25:49.526]                           if (!has_future) {
[10:25:49.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.526]                               info)
[10:25:49.526]                           }
[10:25:49.526]                           else {
[10:25:49.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.526]                               info, version)
[10:25:49.526]                           }
[10:25:49.526]                           base::stop(msg)
[10:25:49.526]                         }
[10:25:49.526]                       })
[10:25:49.526]                     }
[10:25:49.526]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.526]                     base::options(mc.cores = 1L)
[10:25:49.526]                   }
[10:25:49.526]                   options(future.plan = NULL)
[10:25:49.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.526]                 }
[10:25:49.526]                 ...future.workdir <- getwd()
[10:25:49.526]             }
[10:25:49.526]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.526]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.526]         }
[10:25:49.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.526]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.526]             base::names(...future.oldOptions))
[10:25:49.526]     }
[10:25:49.526]     if (FALSE) {
[10:25:49.526]     }
[10:25:49.526]     else {
[10:25:49.526]         if (TRUE) {
[10:25:49.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.526]                 open = "w")
[10:25:49.526]         }
[10:25:49.526]         else {
[10:25:49.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.526]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.526]         }
[10:25:49.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.526]             base::sink(type = "output", split = FALSE)
[10:25:49.526]             base::close(...future.stdout)
[10:25:49.526]         }, add = TRUE)
[10:25:49.526]     }
[10:25:49.526]     ...future.frame <- base::sys.nframe()
[10:25:49.526]     ...future.conditions <- base::list()
[10:25:49.526]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.526]     if (FALSE) {
[10:25:49.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.526]     }
[10:25:49.526]     ...future.result <- base::tryCatch({
[10:25:49.526]         base::withCallingHandlers({
[10:25:49.526]             ...future.value <- base::withVisible(base::local({
[10:25:49.526]                 ...future.makeSendCondition <- base::local({
[10:25:49.526]                   sendCondition <- NULL
[10:25:49.526]                   function(frame = 1L) {
[10:25:49.526]                     if (is.function(sendCondition)) 
[10:25:49.526]                       return(sendCondition)
[10:25:49.526]                     ns <- getNamespace("parallel")
[10:25:49.526]                     if (exists("sendData", mode = "function", 
[10:25:49.526]                       envir = ns)) {
[10:25:49.526]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.526]                         envir = ns)
[10:25:49.526]                       envir <- sys.frame(frame)
[10:25:49.526]                       master <- NULL
[10:25:49.526]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.526]                         !identical(envir, emptyenv())) {
[10:25:49.526]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.526]                           inherits = FALSE)) {
[10:25:49.526]                           master <- get("master", mode = "list", 
[10:25:49.526]                             envir = envir, inherits = FALSE)
[10:25:49.526]                           if (inherits(master, c("SOCKnode", 
[10:25:49.526]                             "SOCK0node"))) {
[10:25:49.526]                             sendCondition <<- function(cond) {
[10:25:49.526]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.526]                                 success = TRUE)
[10:25:49.526]                               parallel_sendData(master, data)
[10:25:49.526]                             }
[10:25:49.526]                             return(sendCondition)
[10:25:49.526]                           }
[10:25:49.526]                         }
[10:25:49.526]                         frame <- frame + 1L
[10:25:49.526]                         envir <- sys.frame(frame)
[10:25:49.526]                       }
[10:25:49.526]                     }
[10:25:49.526]                     sendCondition <<- function(cond) NULL
[10:25:49.526]                   }
[10:25:49.526]                 })
[10:25:49.526]                 withCallingHandlers({
[10:25:49.526]                   NULL
[10:25:49.526]                 }, immediateCondition = function(cond) {
[10:25:49.526]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.526]                   sendCondition(cond)
[10:25:49.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.526]                   {
[10:25:49.526]                     inherits <- base::inherits
[10:25:49.526]                     invokeRestart <- base::invokeRestart
[10:25:49.526]                     is.null <- base::is.null
[10:25:49.526]                     muffled <- FALSE
[10:25:49.526]                     if (inherits(cond, "message")) {
[10:25:49.526]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.526]                       if (muffled) 
[10:25:49.526]                         invokeRestart("muffleMessage")
[10:25:49.526]                     }
[10:25:49.526]                     else if (inherits(cond, "warning")) {
[10:25:49.526]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.526]                       if (muffled) 
[10:25:49.526]                         invokeRestart("muffleWarning")
[10:25:49.526]                     }
[10:25:49.526]                     else if (inherits(cond, "condition")) {
[10:25:49.526]                       if (!is.null(pattern)) {
[10:25:49.526]                         computeRestarts <- base::computeRestarts
[10:25:49.526]                         grepl <- base::grepl
[10:25:49.526]                         restarts <- computeRestarts(cond)
[10:25:49.526]                         for (restart in restarts) {
[10:25:49.526]                           name <- restart$name
[10:25:49.526]                           if (is.null(name)) 
[10:25:49.526]                             next
[10:25:49.526]                           if (!grepl(pattern, name)) 
[10:25:49.526]                             next
[10:25:49.526]                           invokeRestart(restart)
[10:25:49.526]                           muffled <- TRUE
[10:25:49.526]                           break
[10:25:49.526]                         }
[10:25:49.526]                       }
[10:25:49.526]                     }
[10:25:49.526]                     invisible(muffled)
[10:25:49.526]                   }
[10:25:49.526]                   muffleCondition(cond)
[10:25:49.526]                 })
[10:25:49.526]             }))
[10:25:49.526]             future::FutureResult(value = ...future.value$value, 
[10:25:49.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.526]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.526]                     ...future.globalenv.names))
[10:25:49.526]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.526]         }, condition = base::local({
[10:25:49.526]             c <- base::c
[10:25:49.526]             inherits <- base::inherits
[10:25:49.526]             invokeRestart <- base::invokeRestart
[10:25:49.526]             length <- base::length
[10:25:49.526]             list <- base::list
[10:25:49.526]             seq.int <- base::seq.int
[10:25:49.526]             signalCondition <- base::signalCondition
[10:25:49.526]             sys.calls <- base::sys.calls
[10:25:49.526]             `[[` <- base::`[[`
[10:25:49.526]             `+` <- base::`+`
[10:25:49.526]             `<<-` <- base::`<<-`
[10:25:49.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.526]                   3L)]
[10:25:49.526]             }
[10:25:49.526]             function(cond) {
[10:25:49.526]                 is_error <- inherits(cond, "error")
[10:25:49.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.526]                   NULL)
[10:25:49.526]                 if (is_error) {
[10:25:49.526]                   sessionInformation <- function() {
[10:25:49.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.526]                       search = base::search(), system = base::Sys.info())
[10:25:49.526]                   }
[10:25:49.526]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.526]                     cond$call), session = sessionInformation(), 
[10:25:49.526]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.526]                   signalCondition(cond)
[10:25:49.526]                 }
[10:25:49.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.526]                 "immediateCondition"))) {
[10:25:49.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.526]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.526]                   if (TRUE && !signal) {
[10:25:49.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.526]                     {
[10:25:49.526]                       inherits <- base::inherits
[10:25:49.526]                       invokeRestart <- base::invokeRestart
[10:25:49.526]                       is.null <- base::is.null
[10:25:49.526]                       muffled <- FALSE
[10:25:49.526]                       if (inherits(cond, "message")) {
[10:25:49.526]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.526]                         if (muffled) 
[10:25:49.526]                           invokeRestart("muffleMessage")
[10:25:49.526]                       }
[10:25:49.526]                       else if (inherits(cond, "warning")) {
[10:25:49.526]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.526]                         if (muffled) 
[10:25:49.526]                           invokeRestart("muffleWarning")
[10:25:49.526]                       }
[10:25:49.526]                       else if (inherits(cond, "condition")) {
[10:25:49.526]                         if (!is.null(pattern)) {
[10:25:49.526]                           computeRestarts <- base::computeRestarts
[10:25:49.526]                           grepl <- base::grepl
[10:25:49.526]                           restarts <- computeRestarts(cond)
[10:25:49.526]                           for (restart in restarts) {
[10:25:49.526]                             name <- restart$name
[10:25:49.526]                             if (is.null(name)) 
[10:25:49.526]                               next
[10:25:49.526]                             if (!grepl(pattern, name)) 
[10:25:49.526]                               next
[10:25:49.526]                             invokeRestart(restart)
[10:25:49.526]                             muffled <- TRUE
[10:25:49.526]                             break
[10:25:49.526]                           }
[10:25:49.526]                         }
[10:25:49.526]                       }
[10:25:49.526]                       invisible(muffled)
[10:25:49.526]                     }
[10:25:49.526]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.526]                   }
[10:25:49.526]                 }
[10:25:49.526]                 else {
[10:25:49.526]                   if (TRUE) {
[10:25:49.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.526]                     {
[10:25:49.526]                       inherits <- base::inherits
[10:25:49.526]                       invokeRestart <- base::invokeRestart
[10:25:49.526]                       is.null <- base::is.null
[10:25:49.526]                       muffled <- FALSE
[10:25:49.526]                       if (inherits(cond, "message")) {
[10:25:49.526]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.526]                         if (muffled) 
[10:25:49.526]                           invokeRestart("muffleMessage")
[10:25:49.526]                       }
[10:25:49.526]                       else if (inherits(cond, "warning")) {
[10:25:49.526]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.526]                         if (muffled) 
[10:25:49.526]                           invokeRestart("muffleWarning")
[10:25:49.526]                       }
[10:25:49.526]                       else if (inherits(cond, "condition")) {
[10:25:49.526]                         if (!is.null(pattern)) {
[10:25:49.526]                           computeRestarts <- base::computeRestarts
[10:25:49.526]                           grepl <- base::grepl
[10:25:49.526]                           restarts <- computeRestarts(cond)
[10:25:49.526]                           for (restart in restarts) {
[10:25:49.526]                             name <- restart$name
[10:25:49.526]                             if (is.null(name)) 
[10:25:49.526]                               next
[10:25:49.526]                             if (!grepl(pattern, name)) 
[10:25:49.526]                               next
[10:25:49.526]                             invokeRestart(restart)
[10:25:49.526]                             muffled <- TRUE
[10:25:49.526]                             break
[10:25:49.526]                           }
[10:25:49.526]                         }
[10:25:49.526]                       }
[10:25:49.526]                       invisible(muffled)
[10:25:49.526]                     }
[10:25:49.526]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.526]                   }
[10:25:49.526]                 }
[10:25:49.526]             }
[10:25:49.526]         }))
[10:25:49.526]     }, error = function(ex) {
[10:25:49.526]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.526]                 ...future.rng), started = ...future.startTime, 
[10:25:49.526]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.526]             version = "1.8"), class = "FutureResult")
[10:25:49.526]     }, finally = {
[10:25:49.526]         if (!identical(...future.workdir, getwd())) 
[10:25:49.526]             setwd(...future.workdir)
[10:25:49.526]         {
[10:25:49.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.526]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.526]             }
[10:25:49.526]             base::options(...future.oldOptions)
[10:25:49.526]             if (.Platform$OS.type == "windows") {
[10:25:49.526]                 old_names <- names(...future.oldEnvVars)
[10:25:49.526]                 envs <- base::Sys.getenv()
[10:25:49.526]                 names <- names(envs)
[10:25:49.526]                 common <- intersect(names, old_names)
[10:25:49.526]                 added <- setdiff(names, old_names)
[10:25:49.526]                 removed <- setdiff(old_names, names)
[10:25:49.526]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.526]                   envs[common]]
[10:25:49.526]                 NAMES <- toupper(changed)
[10:25:49.526]                 args <- list()
[10:25:49.526]                 for (kk in seq_along(NAMES)) {
[10:25:49.526]                   name <- changed[[kk]]
[10:25:49.526]                   NAME <- NAMES[[kk]]
[10:25:49.526]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.526]                     next
[10:25:49.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.526]                 }
[10:25:49.526]                 NAMES <- toupper(added)
[10:25:49.526]                 for (kk in seq_along(NAMES)) {
[10:25:49.526]                   name <- added[[kk]]
[10:25:49.526]                   NAME <- NAMES[[kk]]
[10:25:49.526]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.526]                     next
[10:25:49.526]                   args[[name]] <- ""
[10:25:49.526]                 }
[10:25:49.526]                 NAMES <- toupper(removed)
[10:25:49.526]                 for (kk in seq_along(NAMES)) {
[10:25:49.526]                   name <- removed[[kk]]
[10:25:49.526]                   NAME <- NAMES[[kk]]
[10:25:49.526]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.526]                     next
[10:25:49.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.526]                 }
[10:25:49.526]                 if (length(args) > 0) 
[10:25:49.526]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.526]             }
[10:25:49.526]             else {
[10:25:49.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.526]             }
[10:25:49.526]             {
[10:25:49.526]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.526]                   0L) {
[10:25:49.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.526]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.526]                   base::options(opts)
[10:25:49.526]                 }
[10:25:49.526]                 {
[10:25:49.526]                   {
[10:25:49.526]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.526]                     NULL
[10:25:49.526]                   }
[10:25:49.526]                   options(future.plan = NULL)
[10:25:49.526]                   if (is.na(NA_character_)) 
[10:25:49.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.526]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.526]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.526]                     envir = parent.frame()) 
[10:25:49.526]                   {
[10:25:49.526]                     if (is.function(workers)) 
[10:25:49.526]                       workers <- workers()
[10:25:49.526]                     workers <- structure(as.integer(workers), 
[10:25:49.526]                       class = class(workers))
[10:25:49.526]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.526]                       workers >= 1)
[10:25:49.526]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.526]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.526]                     }
[10:25:49.526]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.526]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.526]                       envir = envir)
[10:25:49.526]                     if (!future$lazy) 
[10:25:49.526]                       future <- run(future)
[10:25:49.526]                     invisible(future)
[10:25:49.526]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.526]                 }
[10:25:49.526]             }
[10:25:49.526]         }
[10:25:49.526]     })
[10:25:49.526]     if (TRUE) {
[10:25:49.526]         base::sink(type = "output", split = FALSE)
[10:25:49.526]         if (TRUE) {
[10:25:49.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.526]         }
[10:25:49.526]         else {
[10:25:49.526]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.526]         }
[10:25:49.526]         base::close(...future.stdout)
[10:25:49.526]         ...future.stdout <- NULL
[10:25:49.526]     }
[10:25:49.526]     ...future.result$conditions <- ...future.conditions
[10:25:49.526]     ...future.result$finished <- base::Sys.time()
[10:25:49.526]     ...future.result
[10:25:49.526] }
[10:25:49.529] MultisessionFuture started
[10:25:49.529] - Launch lazy future ... done
[10:25:49.530] run() for ‘MultisessionFuture’ ... done
[10:25:49.530] getGlobalsAndPackages() ...
[10:25:49.530] Searching for globals...
[10:25:49.531] - globals found: [1] ‘{’
[10:25:49.531] Searching for globals ... DONE
[10:25:49.531] Resolving globals: FALSE
[10:25:49.531] 
[10:25:49.531] 
[10:25:49.531] getGlobalsAndPackages() ... DONE
[10:25:49.531] run() for ‘Future’ ...
[10:25:49.532] - state: ‘created’
[10:25:49.532] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.545] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.546]   - Field: ‘node’
[10:25:49.546]   - Field: ‘label’
[10:25:49.546]   - Field: ‘local’
[10:25:49.546]   - Field: ‘owner’
[10:25:49.546]   - Field: ‘envir’
[10:25:49.546]   - Field: ‘workers’
[10:25:49.546]   - Field: ‘packages’
[10:25:49.546]   - Field: ‘gc’
[10:25:49.546]   - Field: ‘conditions’
[10:25:49.546]   - Field: ‘persistent’
[10:25:49.546]   - Field: ‘expr’
[10:25:49.547]   - Field: ‘uuid’
[10:25:49.547]   - Field: ‘seed’
[10:25:49.547]   - Field: ‘version’
[10:25:49.547]   - Field: ‘result’
[10:25:49.547]   - Field: ‘asynchronous’
[10:25:49.547]   - Field: ‘calls’
[10:25:49.547]   - Field: ‘globals’
[10:25:49.547]   - Field: ‘stdout’
[10:25:49.547]   - Field: ‘earlySignal’
[10:25:49.547]   - Field: ‘lazy’
[10:25:49.547]   - Field: ‘state’
[10:25:49.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.548] - Launch lazy future ...
[10:25:49.548] Packages needed by the future expression (n = 0): <none>
[10:25:49.548] Packages needed by future strategies (n = 0): <none>
[10:25:49.548] {
[10:25:49.548]     {
[10:25:49.548]         {
[10:25:49.548]             ...future.startTime <- base::Sys.time()
[10:25:49.548]             {
[10:25:49.548]                 {
[10:25:49.548]                   {
[10:25:49.548]                     {
[10:25:49.548]                       base::local({
[10:25:49.548]                         has_future <- base::requireNamespace("future", 
[10:25:49.548]                           quietly = TRUE)
[10:25:49.548]                         if (has_future) {
[10:25:49.548]                           ns <- base::getNamespace("future")
[10:25:49.548]                           version <- ns[[".package"]][["version"]]
[10:25:49.548]                           if (is.null(version)) 
[10:25:49.548]                             version <- utils::packageVersion("future")
[10:25:49.548]                         }
[10:25:49.548]                         else {
[10:25:49.548]                           version <- NULL
[10:25:49.548]                         }
[10:25:49.548]                         if (!has_future || version < "1.8.0") {
[10:25:49.548]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.548]                             "", base::R.version$version.string), 
[10:25:49.548]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.548]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.548]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.548]                               "release", "version")], collapse = " "), 
[10:25:49.548]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.548]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.548]                             info)
[10:25:49.548]                           info <- base::paste(info, collapse = "; ")
[10:25:49.548]                           if (!has_future) {
[10:25:49.548]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.548]                               info)
[10:25:49.548]                           }
[10:25:49.548]                           else {
[10:25:49.548]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.548]                               info, version)
[10:25:49.548]                           }
[10:25:49.548]                           base::stop(msg)
[10:25:49.548]                         }
[10:25:49.548]                       })
[10:25:49.548]                     }
[10:25:49.548]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.548]                     base::options(mc.cores = 1L)
[10:25:49.548]                   }
[10:25:49.548]                   options(future.plan = NULL)
[10:25:49.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.548]                 }
[10:25:49.548]                 ...future.workdir <- getwd()
[10:25:49.548]             }
[10:25:49.548]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.548]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.548]         }
[10:25:49.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.548]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.548]             base::names(...future.oldOptions))
[10:25:49.548]     }
[10:25:49.548]     if (FALSE) {
[10:25:49.548]     }
[10:25:49.548]     else {
[10:25:49.548]         if (TRUE) {
[10:25:49.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.548]                 open = "w")
[10:25:49.548]         }
[10:25:49.548]         else {
[10:25:49.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.548]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.548]         }
[10:25:49.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.548]             base::sink(type = "output", split = FALSE)
[10:25:49.548]             base::close(...future.stdout)
[10:25:49.548]         }, add = TRUE)
[10:25:49.548]     }
[10:25:49.548]     ...future.frame <- base::sys.nframe()
[10:25:49.548]     ...future.conditions <- base::list()
[10:25:49.548]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.548]     if (FALSE) {
[10:25:49.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.548]     }
[10:25:49.548]     ...future.result <- base::tryCatch({
[10:25:49.548]         base::withCallingHandlers({
[10:25:49.548]             ...future.value <- base::withVisible(base::local({
[10:25:49.548]                 ...future.makeSendCondition <- base::local({
[10:25:49.548]                   sendCondition <- NULL
[10:25:49.548]                   function(frame = 1L) {
[10:25:49.548]                     if (is.function(sendCondition)) 
[10:25:49.548]                       return(sendCondition)
[10:25:49.548]                     ns <- getNamespace("parallel")
[10:25:49.548]                     if (exists("sendData", mode = "function", 
[10:25:49.548]                       envir = ns)) {
[10:25:49.548]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.548]                         envir = ns)
[10:25:49.548]                       envir <- sys.frame(frame)
[10:25:49.548]                       master <- NULL
[10:25:49.548]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.548]                         !identical(envir, emptyenv())) {
[10:25:49.548]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.548]                           inherits = FALSE)) {
[10:25:49.548]                           master <- get("master", mode = "list", 
[10:25:49.548]                             envir = envir, inherits = FALSE)
[10:25:49.548]                           if (inherits(master, c("SOCKnode", 
[10:25:49.548]                             "SOCK0node"))) {
[10:25:49.548]                             sendCondition <<- function(cond) {
[10:25:49.548]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.548]                                 success = TRUE)
[10:25:49.548]                               parallel_sendData(master, data)
[10:25:49.548]                             }
[10:25:49.548]                             return(sendCondition)
[10:25:49.548]                           }
[10:25:49.548]                         }
[10:25:49.548]                         frame <- frame + 1L
[10:25:49.548]                         envir <- sys.frame(frame)
[10:25:49.548]                       }
[10:25:49.548]                     }
[10:25:49.548]                     sendCondition <<- function(cond) NULL
[10:25:49.548]                   }
[10:25:49.548]                 })
[10:25:49.548]                 withCallingHandlers({
[10:25:49.548]                   {
[10:25:49.548]                     4
[10:25:49.548]                   }
[10:25:49.548]                 }, immediateCondition = function(cond) {
[10:25:49.548]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.548]                   sendCondition(cond)
[10:25:49.548]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.548]                   {
[10:25:49.548]                     inherits <- base::inherits
[10:25:49.548]                     invokeRestart <- base::invokeRestart
[10:25:49.548]                     is.null <- base::is.null
[10:25:49.548]                     muffled <- FALSE
[10:25:49.548]                     if (inherits(cond, "message")) {
[10:25:49.548]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.548]                       if (muffled) 
[10:25:49.548]                         invokeRestart("muffleMessage")
[10:25:49.548]                     }
[10:25:49.548]                     else if (inherits(cond, "warning")) {
[10:25:49.548]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.548]                       if (muffled) 
[10:25:49.548]                         invokeRestart("muffleWarning")
[10:25:49.548]                     }
[10:25:49.548]                     else if (inherits(cond, "condition")) {
[10:25:49.548]                       if (!is.null(pattern)) {
[10:25:49.548]                         computeRestarts <- base::computeRestarts
[10:25:49.548]                         grepl <- base::grepl
[10:25:49.548]                         restarts <- computeRestarts(cond)
[10:25:49.548]                         for (restart in restarts) {
[10:25:49.548]                           name <- restart$name
[10:25:49.548]                           if (is.null(name)) 
[10:25:49.548]                             next
[10:25:49.548]                           if (!grepl(pattern, name)) 
[10:25:49.548]                             next
[10:25:49.548]                           invokeRestart(restart)
[10:25:49.548]                           muffled <- TRUE
[10:25:49.548]                           break
[10:25:49.548]                         }
[10:25:49.548]                       }
[10:25:49.548]                     }
[10:25:49.548]                     invisible(muffled)
[10:25:49.548]                   }
[10:25:49.548]                   muffleCondition(cond)
[10:25:49.548]                 })
[10:25:49.548]             }))
[10:25:49.548]             future::FutureResult(value = ...future.value$value, 
[10:25:49.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.548]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.548]                     ...future.globalenv.names))
[10:25:49.548]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.548]         }, condition = base::local({
[10:25:49.548]             c <- base::c
[10:25:49.548]             inherits <- base::inherits
[10:25:49.548]             invokeRestart <- base::invokeRestart
[10:25:49.548]             length <- base::length
[10:25:49.548]             list <- base::list
[10:25:49.548]             seq.int <- base::seq.int
[10:25:49.548]             signalCondition <- base::signalCondition
[10:25:49.548]             sys.calls <- base::sys.calls
[10:25:49.548]             `[[` <- base::`[[`
[10:25:49.548]             `+` <- base::`+`
[10:25:49.548]             `<<-` <- base::`<<-`
[10:25:49.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.548]                   3L)]
[10:25:49.548]             }
[10:25:49.548]             function(cond) {
[10:25:49.548]                 is_error <- inherits(cond, "error")
[10:25:49.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.548]                   NULL)
[10:25:49.548]                 if (is_error) {
[10:25:49.548]                   sessionInformation <- function() {
[10:25:49.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.548]                       search = base::search(), system = base::Sys.info())
[10:25:49.548]                   }
[10:25:49.548]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.548]                     cond$call), session = sessionInformation(), 
[10:25:49.548]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.548]                   signalCondition(cond)
[10:25:49.548]                 }
[10:25:49.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.548]                 "immediateCondition"))) {
[10:25:49.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.548]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.548]                   if (TRUE && !signal) {
[10:25:49.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.548]                     {
[10:25:49.548]                       inherits <- base::inherits
[10:25:49.548]                       invokeRestart <- base::invokeRestart
[10:25:49.548]                       is.null <- base::is.null
[10:25:49.548]                       muffled <- FALSE
[10:25:49.548]                       if (inherits(cond, "message")) {
[10:25:49.548]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.548]                         if (muffled) 
[10:25:49.548]                           invokeRestart("muffleMessage")
[10:25:49.548]                       }
[10:25:49.548]                       else if (inherits(cond, "warning")) {
[10:25:49.548]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.548]                         if (muffled) 
[10:25:49.548]                           invokeRestart("muffleWarning")
[10:25:49.548]                       }
[10:25:49.548]                       else if (inherits(cond, "condition")) {
[10:25:49.548]                         if (!is.null(pattern)) {
[10:25:49.548]                           computeRestarts <- base::computeRestarts
[10:25:49.548]                           grepl <- base::grepl
[10:25:49.548]                           restarts <- computeRestarts(cond)
[10:25:49.548]                           for (restart in restarts) {
[10:25:49.548]                             name <- restart$name
[10:25:49.548]                             if (is.null(name)) 
[10:25:49.548]                               next
[10:25:49.548]                             if (!grepl(pattern, name)) 
[10:25:49.548]                               next
[10:25:49.548]                             invokeRestart(restart)
[10:25:49.548]                             muffled <- TRUE
[10:25:49.548]                             break
[10:25:49.548]                           }
[10:25:49.548]                         }
[10:25:49.548]                       }
[10:25:49.548]                       invisible(muffled)
[10:25:49.548]                     }
[10:25:49.548]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.548]                   }
[10:25:49.548]                 }
[10:25:49.548]                 else {
[10:25:49.548]                   if (TRUE) {
[10:25:49.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.548]                     {
[10:25:49.548]                       inherits <- base::inherits
[10:25:49.548]                       invokeRestart <- base::invokeRestart
[10:25:49.548]                       is.null <- base::is.null
[10:25:49.548]                       muffled <- FALSE
[10:25:49.548]                       if (inherits(cond, "message")) {
[10:25:49.548]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.548]                         if (muffled) 
[10:25:49.548]                           invokeRestart("muffleMessage")
[10:25:49.548]                       }
[10:25:49.548]                       else if (inherits(cond, "warning")) {
[10:25:49.548]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.548]                         if (muffled) 
[10:25:49.548]                           invokeRestart("muffleWarning")
[10:25:49.548]                       }
[10:25:49.548]                       else if (inherits(cond, "condition")) {
[10:25:49.548]                         if (!is.null(pattern)) {
[10:25:49.548]                           computeRestarts <- base::computeRestarts
[10:25:49.548]                           grepl <- base::grepl
[10:25:49.548]                           restarts <- computeRestarts(cond)
[10:25:49.548]                           for (restart in restarts) {
[10:25:49.548]                             name <- restart$name
[10:25:49.548]                             if (is.null(name)) 
[10:25:49.548]                               next
[10:25:49.548]                             if (!grepl(pattern, name)) 
[10:25:49.548]                               next
[10:25:49.548]                             invokeRestart(restart)
[10:25:49.548]                             muffled <- TRUE
[10:25:49.548]                             break
[10:25:49.548]                           }
[10:25:49.548]                         }
[10:25:49.548]                       }
[10:25:49.548]                       invisible(muffled)
[10:25:49.548]                     }
[10:25:49.548]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.548]                   }
[10:25:49.548]                 }
[10:25:49.548]             }
[10:25:49.548]         }))
[10:25:49.548]     }, error = function(ex) {
[10:25:49.548]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.548]                 ...future.rng), started = ...future.startTime, 
[10:25:49.548]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.548]             version = "1.8"), class = "FutureResult")
[10:25:49.548]     }, finally = {
[10:25:49.548]         if (!identical(...future.workdir, getwd())) 
[10:25:49.548]             setwd(...future.workdir)
[10:25:49.548]         {
[10:25:49.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.548]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.548]             }
[10:25:49.548]             base::options(...future.oldOptions)
[10:25:49.548]             if (.Platform$OS.type == "windows") {
[10:25:49.548]                 old_names <- names(...future.oldEnvVars)
[10:25:49.548]                 envs <- base::Sys.getenv()
[10:25:49.548]                 names <- names(envs)
[10:25:49.548]                 common <- intersect(names, old_names)
[10:25:49.548]                 added <- setdiff(names, old_names)
[10:25:49.548]                 removed <- setdiff(old_names, names)
[10:25:49.548]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.548]                   envs[common]]
[10:25:49.548]                 NAMES <- toupper(changed)
[10:25:49.548]                 args <- list()
[10:25:49.548]                 for (kk in seq_along(NAMES)) {
[10:25:49.548]                   name <- changed[[kk]]
[10:25:49.548]                   NAME <- NAMES[[kk]]
[10:25:49.548]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.548]                     next
[10:25:49.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.548]                 }
[10:25:49.548]                 NAMES <- toupper(added)
[10:25:49.548]                 for (kk in seq_along(NAMES)) {
[10:25:49.548]                   name <- added[[kk]]
[10:25:49.548]                   NAME <- NAMES[[kk]]
[10:25:49.548]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.548]                     next
[10:25:49.548]                   args[[name]] <- ""
[10:25:49.548]                 }
[10:25:49.548]                 NAMES <- toupper(removed)
[10:25:49.548]                 for (kk in seq_along(NAMES)) {
[10:25:49.548]                   name <- removed[[kk]]
[10:25:49.548]                   NAME <- NAMES[[kk]]
[10:25:49.548]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.548]                     next
[10:25:49.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.548]                 }
[10:25:49.548]                 if (length(args) > 0) 
[10:25:49.548]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.548]             }
[10:25:49.548]             else {
[10:25:49.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.548]             }
[10:25:49.548]             {
[10:25:49.548]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.548]                   0L) {
[10:25:49.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.548]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.548]                   base::options(opts)
[10:25:49.548]                 }
[10:25:49.548]                 {
[10:25:49.548]                   {
[10:25:49.548]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.548]                     NULL
[10:25:49.548]                   }
[10:25:49.548]                   options(future.plan = NULL)
[10:25:49.548]                   if (is.na(NA_character_)) 
[10:25:49.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.548]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.548]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.548]                     envir = parent.frame()) 
[10:25:49.548]                   {
[10:25:49.548]                     if (is.function(workers)) 
[10:25:49.548]                       workers <- workers()
[10:25:49.548]                     workers <- structure(as.integer(workers), 
[10:25:49.548]                       class = class(workers))
[10:25:49.548]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.548]                       workers >= 1)
[10:25:49.548]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.548]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.548]                     }
[10:25:49.548]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.548]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.548]                       envir = envir)
[10:25:49.548]                     if (!future$lazy) 
[10:25:49.548]                       future <- run(future)
[10:25:49.548]                     invisible(future)
[10:25:49.548]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.548]                 }
[10:25:49.548]             }
[10:25:49.548]         }
[10:25:49.548]     })
[10:25:49.548]     if (TRUE) {
[10:25:49.548]         base::sink(type = "output", split = FALSE)
[10:25:49.548]         if (TRUE) {
[10:25:49.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.548]         }
[10:25:49.548]         else {
[10:25:49.548]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.548]         }
[10:25:49.548]         base::close(...future.stdout)
[10:25:49.548]         ...future.stdout <- NULL
[10:25:49.548]     }
[10:25:49.548]     ...future.result$conditions <- ...future.conditions
[10:25:49.548]     ...future.result$finished <- base::Sys.time()
[10:25:49.548]     ...future.result
[10:25:49.548] }
[10:25:49.551] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:49.561] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.562] - Validating connection of MultisessionFuture
[10:25:49.562] - received message: FutureResult
[10:25:49.562] - Received FutureResult
[10:25:49.562] - Erased future from FutureRegistry
[10:25:49.562] result() for ClusterFuture ...
[10:25:49.562] - result already collected: FutureResult
[10:25:49.562] result() for ClusterFuture ... done
[10:25:49.562] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.563] result() for ClusterFuture ...
[10:25:49.563] - result already collected: FutureResult
[10:25:49.563] result() for ClusterFuture ... done
[10:25:49.563] result() for ClusterFuture ...
[10:25:49.563] - result already collected: FutureResult
[10:25:49.563] result() for ClusterFuture ... done
[10:25:49.564] MultisessionFuture started
[10:25:49.564] - Launch lazy future ... done
[10:25:49.564] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c0f64f4728> 
<environment: 0x55c0f700b1c8> 
[10:25:49.574] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.575] - Validating connection of MultisessionFuture
[10:25:49.575] - received message: FutureResult
[10:25:49.575] - Received FutureResult
[10:25:49.575] - Erased future from FutureRegistry
[10:25:49.575] result() for ClusterFuture ...
[10:25:49.575] - result already collected: FutureResult
[10:25:49.575] result() for ClusterFuture ... done
[10:25:49.575] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:49.587] resolve() on environment ...
[10:25:49.587]  recursive: 0
[10:25:49.588]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:49.588] signalConditionsASAP(numeric, pos=1) ...
[10:25:49.588] - nx: 4
[10:25:49.588] - relay: TRUE
[10:25:49.588] - stdout: TRUE
[10:25:49.588] - signal: TRUE
[10:25:49.588] - resignal: FALSE
[10:25:49.588] - force: TRUE
[10:25:49.588] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.589] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.589]  - until=2
[10:25:49.589]  - relaying element #2
[10:25:49.589] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.589] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.589] signalConditionsASAP(NULL, pos=1) ... done
[10:25:49.589]  length: 3 (resolved future 1)
[10:25:49.589] Future #2
[10:25:49.589] result() for ClusterFuture ...
[10:25:49.589] - result already collected: FutureResult
[10:25:49.590] result() for ClusterFuture ... done
[10:25:49.590] result() for ClusterFuture ...
[10:25:49.590] - result already collected: FutureResult
[10:25:49.590] result() for ClusterFuture ... done
[10:25:49.590] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:49.590] - nx: 4
[10:25:49.590] - relay: TRUE
[10:25:49.590] - stdout: TRUE
[10:25:49.590] - signal: TRUE
[10:25:49.590] - resignal: FALSE
[10:25:49.590] - force: TRUE
[10:25:49.590] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.591] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.591]  - until=2
[10:25:49.591]  - relaying element #2
[10:25:49.591] result() for ClusterFuture ...
[10:25:49.591] - result already collected: FutureResult
[10:25:49.591] result() for ClusterFuture ... done
[10:25:49.591] result() for ClusterFuture ...
[10:25:49.591] - result already collected: FutureResult
[10:25:49.591] result() for ClusterFuture ... done
[10:25:49.591] result() for ClusterFuture ...
[10:25:49.591] - result already collected: FutureResult
[10:25:49.592] result() for ClusterFuture ... done
[10:25:49.592] result() for ClusterFuture ...
[10:25:49.592] - result already collected: FutureResult
[10:25:49.592] result() for ClusterFuture ... done
[10:25:49.592] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.592] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.592] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:49.592]  length: 2 (resolved future 2)
[10:25:49.592] Future #3
[10:25:49.592] result() for ClusterFuture ...
[10:25:49.592] - result already collected: FutureResult
[10:25:49.593] result() for ClusterFuture ... done
[10:25:49.593] result() for ClusterFuture ...
[10:25:49.593] - result already collected: FutureResult
[10:25:49.593] result() for ClusterFuture ... done
[10:25:49.593] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:49.593] - nx: 4
[10:25:49.593] - relay: TRUE
[10:25:49.593] - stdout: TRUE
[10:25:49.593] - signal: TRUE
[10:25:49.593] - resignal: FALSE
[10:25:49.593] - force: TRUE
[10:25:49.593] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.594] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.594]  - until=3
[10:25:49.594]  - relaying element #3
[10:25:49.594] result() for ClusterFuture ...
[10:25:49.594] - result already collected: FutureResult
[10:25:49.594] result() for ClusterFuture ... done
[10:25:49.594] result() for ClusterFuture ...
[10:25:49.594] - result already collected: FutureResult
[10:25:49.594] result() for ClusterFuture ... done
[10:25:49.594] result() for ClusterFuture ...
[10:25:49.594] - result already collected: FutureResult
[10:25:49.595] result() for ClusterFuture ... done
[10:25:49.595] result() for ClusterFuture ...
[10:25:49.595] - result already collected: FutureResult
[10:25:49.595] result() for ClusterFuture ... done
[10:25:49.595] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.595] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.595] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:49.595]  length: 1 (resolved future 3)
[10:25:49.616] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.616] - Validating connection of MultisessionFuture
[10:25:49.617] - received message: FutureResult
[10:25:49.617] - Received FutureResult
[10:25:49.617] - Erased future from FutureRegistry
[10:25:49.617] result() for ClusterFuture ...
[10:25:49.617] - result already collected: FutureResult
[10:25:49.617] result() for ClusterFuture ... done
[10:25:49.617] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.617] Future #4
[10:25:49.617] result() for ClusterFuture ...
[10:25:49.617] - result already collected: FutureResult
[10:25:49.618] result() for ClusterFuture ... done
[10:25:49.618] result() for ClusterFuture ...
[10:25:49.618] - result already collected: FutureResult
[10:25:49.618] result() for ClusterFuture ... done
[10:25:49.618] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:49.618] - nx: 4
[10:25:49.618] - relay: TRUE
[10:25:49.618] - stdout: TRUE
[10:25:49.618] - signal: TRUE
[10:25:49.618] - resignal: FALSE
[10:25:49.618] - force: TRUE
[10:25:49.618] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.619] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.619]  - until=4
[10:25:49.619]  - relaying element #4
[10:25:49.619] result() for ClusterFuture ...
[10:25:49.619] - result already collected: FutureResult
[10:25:49.619] result() for ClusterFuture ... done
[10:25:49.619] result() for ClusterFuture ...
[10:25:49.619] - result already collected: FutureResult
[10:25:49.619] result() for ClusterFuture ... done
[10:25:49.619] result() for ClusterFuture ...
[10:25:49.619] - result already collected: FutureResult
[10:25:49.620] result() for ClusterFuture ... done
[10:25:49.620] result() for ClusterFuture ...
[10:25:49.620] - result already collected: FutureResult
[10:25:49.620] result() for ClusterFuture ... done
[10:25:49.620] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.620] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.620] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:49.620]  length: 0 (resolved future 4)
[10:25:49.620] Relaying remaining futures
[10:25:49.620] signalConditionsASAP(NULL, pos=0) ...
[10:25:49.620] - nx: 4
[10:25:49.620] - relay: TRUE
[10:25:49.621] - stdout: TRUE
[10:25:49.621] - signal: TRUE
[10:25:49.621] - resignal: FALSE
[10:25:49.621] - force: TRUE
[10:25:49.621] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.621] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:49.621] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.621] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.621] signalConditionsASAP(NULL, pos=0) ... done
[10:25:49.621] resolve() on environment ... DONE
[10:25:49.622] result() for ClusterFuture ...
[10:25:49.622] - result already collected: FutureResult
[10:25:49.622] result() for ClusterFuture ... done
[10:25:49.622] result() for ClusterFuture ...
[10:25:49.622] - result already collected: FutureResult
[10:25:49.622] result() for ClusterFuture ... done
[10:25:49.622] result() for ClusterFuture ...
[10:25:49.622] - result already collected: FutureResult
[10:25:49.622] result() for ClusterFuture ... done
[10:25:49.622] result() for ClusterFuture ...
[10:25:49.622] - result already collected: FutureResult
[10:25:49.622] result() for ClusterFuture ... done
[10:25:49.623] result() for ClusterFuture ...
[10:25:49.623] - result already collected: FutureResult
[10:25:49.623] result() for ClusterFuture ... done
[10:25:49.623] result() for ClusterFuture ...
[10:25:49.623] - result already collected: FutureResult
[10:25:49.623] result() for ClusterFuture ... done
<environment: 0x55c0f5817a40> 
Dimensions: c(2, 3, 1)
[10:25:49.623] getGlobalsAndPackages() ...
[10:25:49.624] Searching for globals...
[10:25:49.624] 
[10:25:49.624] Searching for globals ... DONE
[10:25:49.624] - globals: [0] <none>
[10:25:49.624] getGlobalsAndPackages() ... DONE
[10:25:49.624] run() for ‘Future’ ...
[10:25:49.624] - state: ‘created’
[10:25:49.625] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.639] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.640]   - Field: ‘node’
[10:25:49.640]   - Field: ‘label’
[10:25:49.640]   - Field: ‘local’
[10:25:49.640]   - Field: ‘owner’
[10:25:49.640]   - Field: ‘envir’
[10:25:49.640]   - Field: ‘workers’
[10:25:49.640]   - Field: ‘packages’
[10:25:49.640]   - Field: ‘gc’
[10:25:49.640]   - Field: ‘conditions’
[10:25:49.641]   - Field: ‘persistent’
[10:25:49.641]   - Field: ‘expr’
[10:25:49.641]   - Field: ‘uuid’
[10:25:49.641]   - Field: ‘seed’
[10:25:49.641]   - Field: ‘version’
[10:25:49.641]   - Field: ‘result’
[10:25:49.641]   - Field: ‘asynchronous’
[10:25:49.641]   - Field: ‘calls’
[10:25:49.641]   - Field: ‘globals’
[10:25:49.641]   - Field: ‘stdout’
[10:25:49.641]   - Field: ‘earlySignal’
[10:25:49.642]   - Field: ‘lazy’
[10:25:49.642]   - Field: ‘state’
[10:25:49.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.642] - Launch lazy future ...
[10:25:49.642] Packages needed by the future expression (n = 0): <none>
[10:25:49.642] Packages needed by future strategies (n = 0): <none>
[10:25:49.643] {
[10:25:49.643]     {
[10:25:49.643]         {
[10:25:49.643]             ...future.startTime <- base::Sys.time()
[10:25:49.643]             {
[10:25:49.643]                 {
[10:25:49.643]                   {
[10:25:49.643]                     {
[10:25:49.643]                       base::local({
[10:25:49.643]                         has_future <- base::requireNamespace("future", 
[10:25:49.643]                           quietly = TRUE)
[10:25:49.643]                         if (has_future) {
[10:25:49.643]                           ns <- base::getNamespace("future")
[10:25:49.643]                           version <- ns[[".package"]][["version"]]
[10:25:49.643]                           if (is.null(version)) 
[10:25:49.643]                             version <- utils::packageVersion("future")
[10:25:49.643]                         }
[10:25:49.643]                         else {
[10:25:49.643]                           version <- NULL
[10:25:49.643]                         }
[10:25:49.643]                         if (!has_future || version < "1.8.0") {
[10:25:49.643]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.643]                             "", base::R.version$version.string), 
[10:25:49.643]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.643]                               "release", "version")], collapse = " "), 
[10:25:49.643]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.643]                             info)
[10:25:49.643]                           info <- base::paste(info, collapse = "; ")
[10:25:49.643]                           if (!has_future) {
[10:25:49.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.643]                               info)
[10:25:49.643]                           }
[10:25:49.643]                           else {
[10:25:49.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.643]                               info, version)
[10:25:49.643]                           }
[10:25:49.643]                           base::stop(msg)
[10:25:49.643]                         }
[10:25:49.643]                       })
[10:25:49.643]                     }
[10:25:49.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.643]                     base::options(mc.cores = 1L)
[10:25:49.643]                   }
[10:25:49.643]                   options(future.plan = NULL)
[10:25:49.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.643]                 }
[10:25:49.643]                 ...future.workdir <- getwd()
[10:25:49.643]             }
[10:25:49.643]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.643]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.643]         }
[10:25:49.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.643]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.643]             base::names(...future.oldOptions))
[10:25:49.643]     }
[10:25:49.643]     if (FALSE) {
[10:25:49.643]     }
[10:25:49.643]     else {
[10:25:49.643]         if (TRUE) {
[10:25:49.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.643]                 open = "w")
[10:25:49.643]         }
[10:25:49.643]         else {
[10:25:49.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.643]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.643]         }
[10:25:49.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.643]             base::sink(type = "output", split = FALSE)
[10:25:49.643]             base::close(...future.stdout)
[10:25:49.643]         }, add = TRUE)
[10:25:49.643]     }
[10:25:49.643]     ...future.frame <- base::sys.nframe()
[10:25:49.643]     ...future.conditions <- base::list()
[10:25:49.643]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.643]     if (FALSE) {
[10:25:49.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.643]     }
[10:25:49.643]     ...future.result <- base::tryCatch({
[10:25:49.643]         base::withCallingHandlers({
[10:25:49.643]             ...future.value <- base::withVisible(base::local({
[10:25:49.643]                 ...future.makeSendCondition <- base::local({
[10:25:49.643]                   sendCondition <- NULL
[10:25:49.643]                   function(frame = 1L) {
[10:25:49.643]                     if (is.function(sendCondition)) 
[10:25:49.643]                       return(sendCondition)
[10:25:49.643]                     ns <- getNamespace("parallel")
[10:25:49.643]                     if (exists("sendData", mode = "function", 
[10:25:49.643]                       envir = ns)) {
[10:25:49.643]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.643]                         envir = ns)
[10:25:49.643]                       envir <- sys.frame(frame)
[10:25:49.643]                       master <- NULL
[10:25:49.643]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.643]                         !identical(envir, emptyenv())) {
[10:25:49.643]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.643]                           inherits = FALSE)) {
[10:25:49.643]                           master <- get("master", mode = "list", 
[10:25:49.643]                             envir = envir, inherits = FALSE)
[10:25:49.643]                           if (inherits(master, c("SOCKnode", 
[10:25:49.643]                             "SOCK0node"))) {
[10:25:49.643]                             sendCondition <<- function(cond) {
[10:25:49.643]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.643]                                 success = TRUE)
[10:25:49.643]                               parallel_sendData(master, data)
[10:25:49.643]                             }
[10:25:49.643]                             return(sendCondition)
[10:25:49.643]                           }
[10:25:49.643]                         }
[10:25:49.643]                         frame <- frame + 1L
[10:25:49.643]                         envir <- sys.frame(frame)
[10:25:49.643]                       }
[10:25:49.643]                     }
[10:25:49.643]                     sendCondition <<- function(cond) NULL
[10:25:49.643]                   }
[10:25:49.643]                 })
[10:25:49.643]                 withCallingHandlers({
[10:25:49.643]                   2
[10:25:49.643]                 }, immediateCondition = function(cond) {
[10:25:49.643]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.643]                   sendCondition(cond)
[10:25:49.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.643]                   {
[10:25:49.643]                     inherits <- base::inherits
[10:25:49.643]                     invokeRestart <- base::invokeRestart
[10:25:49.643]                     is.null <- base::is.null
[10:25:49.643]                     muffled <- FALSE
[10:25:49.643]                     if (inherits(cond, "message")) {
[10:25:49.643]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.643]                       if (muffled) 
[10:25:49.643]                         invokeRestart("muffleMessage")
[10:25:49.643]                     }
[10:25:49.643]                     else if (inherits(cond, "warning")) {
[10:25:49.643]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.643]                       if (muffled) 
[10:25:49.643]                         invokeRestart("muffleWarning")
[10:25:49.643]                     }
[10:25:49.643]                     else if (inherits(cond, "condition")) {
[10:25:49.643]                       if (!is.null(pattern)) {
[10:25:49.643]                         computeRestarts <- base::computeRestarts
[10:25:49.643]                         grepl <- base::grepl
[10:25:49.643]                         restarts <- computeRestarts(cond)
[10:25:49.643]                         for (restart in restarts) {
[10:25:49.643]                           name <- restart$name
[10:25:49.643]                           if (is.null(name)) 
[10:25:49.643]                             next
[10:25:49.643]                           if (!grepl(pattern, name)) 
[10:25:49.643]                             next
[10:25:49.643]                           invokeRestart(restart)
[10:25:49.643]                           muffled <- TRUE
[10:25:49.643]                           break
[10:25:49.643]                         }
[10:25:49.643]                       }
[10:25:49.643]                     }
[10:25:49.643]                     invisible(muffled)
[10:25:49.643]                   }
[10:25:49.643]                   muffleCondition(cond)
[10:25:49.643]                 })
[10:25:49.643]             }))
[10:25:49.643]             future::FutureResult(value = ...future.value$value, 
[10:25:49.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.643]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.643]                     ...future.globalenv.names))
[10:25:49.643]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.643]         }, condition = base::local({
[10:25:49.643]             c <- base::c
[10:25:49.643]             inherits <- base::inherits
[10:25:49.643]             invokeRestart <- base::invokeRestart
[10:25:49.643]             length <- base::length
[10:25:49.643]             list <- base::list
[10:25:49.643]             seq.int <- base::seq.int
[10:25:49.643]             signalCondition <- base::signalCondition
[10:25:49.643]             sys.calls <- base::sys.calls
[10:25:49.643]             `[[` <- base::`[[`
[10:25:49.643]             `+` <- base::`+`
[10:25:49.643]             `<<-` <- base::`<<-`
[10:25:49.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.643]                   3L)]
[10:25:49.643]             }
[10:25:49.643]             function(cond) {
[10:25:49.643]                 is_error <- inherits(cond, "error")
[10:25:49.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.643]                   NULL)
[10:25:49.643]                 if (is_error) {
[10:25:49.643]                   sessionInformation <- function() {
[10:25:49.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.643]                       search = base::search(), system = base::Sys.info())
[10:25:49.643]                   }
[10:25:49.643]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.643]                     cond$call), session = sessionInformation(), 
[10:25:49.643]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.643]                   signalCondition(cond)
[10:25:49.643]                 }
[10:25:49.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.643]                 "immediateCondition"))) {
[10:25:49.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.643]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.643]                   if (TRUE && !signal) {
[10:25:49.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.643]                     {
[10:25:49.643]                       inherits <- base::inherits
[10:25:49.643]                       invokeRestart <- base::invokeRestart
[10:25:49.643]                       is.null <- base::is.null
[10:25:49.643]                       muffled <- FALSE
[10:25:49.643]                       if (inherits(cond, "message")) {
[10:25:49.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.643]                         if (muffled) 
[10:25:49.643]                           invokeRestart("muffleMessage")
[10:25:49.643]                       }
[10:25:49.643]                       else if (inherits(cond, "warning")) {
[10:25:49.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.643]                         if (muffled) 
[10:25:49.643]                           invokeRestart("muffleWarning")
[10:25:49.643]                       }
[10:25:49.643]                       else if (inherits(cond, "condition")) {
[10:25:49.643]                         if (!is.null(pattern)) {
[10:25:49.643]                           computeRestarts <- base::computeRestarts
[10:25:49.643]                           grepl <- base::grepl
[10:25:49.643]                           restarts <- computeRestarts(cond)
[10:25:49.643]                           for (restart in restarts) {
[10:25:49.643]                             name <- restart$name
[10:25:49.643]                             if (is.null(name)) 
[10:25:49.643]                               next
[10:25:49.643]                             if (!grepl(pattern, name)) 
[10:25:49.643]                               next
[10:25:49.643]                             invokeRestart(restart)
[10:25:49.643]                             muffled <- TRUE
[10:25:49.643]                             break
[10:25:49.643]                           }
[10:25:49.643]                         }
[10:25:49.643]                       }
[10:25:49.643]                       invisible(muffled)
[10:25:49.643]                     }
[10:25:49.643]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.643]                   }
[10:25:49.643]                 }
[10:25:49.643]                 else {
[10:25:49.643]                   if (TRUE) {
[10:25:49.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.643]                     {
[10:25:49.643]                       inherits <- base::inherits
[10:25:49.643]                       invokeRestart <- base::invokeRestart
[10:25:49.643]                       is.null <- base::is.null
[10:25:49.643]                       muffled <- FALSE
[10:25:49.643]                       if (inherits(cond, "message")) {
[10:25:49.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.643]                         if (muffled) 
[10:25:49.643]                           invokeRestart("muffleMessage")
[10:25:49.643]                       }
[10:25:49.643]                       else if (inherits(cond, "warning")) {
[10:25:49.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.643]                         if (muffled) 
[10:25:49.643]                           invokeRestart("muffleWarning")
[10:25:49.643]                       }
[10:25:49.643]                       else if (inherits(cond, "condition")) {
[10:25:49.643]                         if (!is.null(pattern)) {
[10:25:49.643]                           computeRestarts <- base::computeRestarts
[10:25:49.643]                           grepl <- base::grepl
[10:25:49.643]                           restarts <- computeRestarts(cond)
[10:25:49.643]                           for (restart in restarts) {
[10:25:49.643]                             name <- restart$name
[10:25:49.643]                             if (is.null(name)) 
[10:25:49.643]                               next
[10:25:49.643]                             if (!grepl(pattern, name)) 
[10:25:49.643]                               next
[10:25:49.643]                             invokeRestart(restart)
[10:25:49.643]                             muffled <- TRUE
[10:25:49.643]                             break
[10:25:49.643]                           }
[10:25:49.643]                         }
[10:25:49.643]                       }
[10:25:49.643]                       invisible(muffled)
[10:25:49.643]                     }
[10:25:49.643]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.643]                   }
[10:25:49.643]                 }
[10:25:49.643]             }
[10:25:49.643]         }))
[10:25:49.643]     }, error = function(ex) {
[10:25:49.643]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.643]                 ...future.rng), started = ...future.startTime, 
[10:25:49.643]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.643]             version = "1.8"), class = "FutureResult")
[10:25:49.643]     }, finally = {
[10:25:49.643]         if (!identical(...future.workdir, getwd())) 
[10:25:49.643]             setwd(...future.workdir)
[10:25:49.643]         {
[10:25:49.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.643]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.643]             }
[10:25:49.643]             base::options(...future.oldOptions)
[10:25:49.643]             if (.Platform$OS.type == "windows") {
[10:25:49.643]                 old_names <- names(...future.oldEnvVars)
[10:25:49.643]                 envs <- base::Sys.getenv()
[10:25:49.643]                 names <- names(envs)
[10:25:49.643]                 common <- intersect(names, old_names)
[10:25:49.643]                 added <- setdiff(names, old_names)
[10:25:49.643]                 removed <- setdiff(old_names, names)
[10:25:49.643]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.643]                   envs[common]]
[10:25:49.643]                 NAMES <- toupper(changed)
[10:25:49.643]                 args <- list()
[10:25:49.643]                 for (kk in seq_along(NAMES)) {
[10:25:49.643]                   name <- changed[[kk]]
[10:25:49.643]                   NAME <- NAMES[[kk]]
[10:25:49.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.643]                     next
[10:25:49.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.643]                 }
[10:25:49.643]                 NAMES <- toupper(added)
[10:25:49.643]                 for (kk in seq_along(NAMES)) {
[10:25:49.643]                   name <- added[[kk]]
[10:25:49.643]                   NAME <- NAMES[[kk]]
[10:25:49.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.643]                     next
[10:25:49.643]                   args[[name]] <- ""
[10:25:49.643]                 }
[10:25:49.643]                 NAMES <- toupper(removed)
[10:25:49.643]                 for (kk in seq_along(NAMES)) {
[10:25:49.643]                   name <- removed[[kk]]
[10:25:49.643]                   NAME <- NAMES[[kk]]
[10:25:49.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.643]                     next
[10:25:49.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.643]                 }
[10:25:49.643]                 if (length(args) > 0) 
[10:25:49.643]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.643]             }
[10:25:49.643]             else {
[10:25:49.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.643]             }
[10:25:49.643]             {
[10:25:49.643]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.643]                   0L) {
[10:25:49.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.643]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.643]                   base::options(opts)
[10:25:49.643]                 }
[10:25:49.643]                 {
[10:25:49.643]                   {
[10:25:49.643]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.643]                     NULL
[10:25:49.643]                   }
[10:25:49.643]                   options(future.plan = NULL)
[10:25:49.643]                   if (is.na(NA_character_)) 
[10:25:49.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.643]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.643]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.643]                     envir = parent.frame()) 
[10:25:49.643]                   {
[10:25:49.643]                     if (is.function(workers)) 
[10:25:49.643]                       workers <- workers()
[10:25:49.643]                     workers <- structure(as.integer(workers), 
[10:25:49.643]                       class = class(workers))
[10:25:49.643]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.643]                       workers >= 1)
[10:25:49.643]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.643]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.643]                     }
[10:25:49.643]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.643]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.643]                       envir = envir)
[10:25:49.643]                     if (!future$lazy) 
[10:25:49.643]                       future <- run(future)
[10:25:49.643]                     invisible(future)
[10:25:49.643]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.643]                 }
[10:25:49.643]             }
[10:25:49.643]         }
[10:25:49.643]     })
[10:25:49.643]     if (TRUE) {
[10:25:49.643]         base::sink(type = "output", split = FALSE)
[10:25:49.643]         if (TRUE) {
[10:25:49.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.643]         }
[10:25:49.643]         else {
[10:25:49.643]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.643]         }
[10:25:49.643]         base::close(...future.stdout)
[10:25:49.643]         ...future.stdout <- NULL
[10:25:49.643]     }
[10:25:49.643]     ...future.result$conditions <- ...future.conditions
[10:25:49.643]     ...future.result$finished <- base::Sys.time()
[10:25:49.643]     ...future.result
[10:25:49.643] }
[10:25:49.646] MultisessionFuture started
[10:25:49.646] - Launch lazy future ... done
[10:25:49.646] run() for ‘MultisessionFuture’ ... done
[10:25:49.646] getGlobalsAndPackages() ...
[10:25:49.646] Searching for globals...
[10:25:49.647] 
[10:25:49.647] Searching for globals ... DONE
[10:25:49.647] - globals: [0] <none>
[10:25:49.647] getGlobalsAndPackages() ... DONE
[10:25:49.647] run() for ‘Future’ ...
[10:25:49.647] - state: ‘created’
[10:25:49.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.661] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.662]   - Field: ‘node’
[10:25:49.662]   - Field: ‘label’
[10:25:49.662]   - Field: ‘local’
[10:25:49.662]   - Field: ‘owner’
[10:25:49.662]   - Field: ‘envir’
[10:25:49.662]   - Field: ‘workers’
[10:25:49.662]   - Field: ‘packages’
[10:25:49.662]   - Field: ‘gc’
[10:25:49.662]   - Field: ‘conditions’
[10:25:49.662]   - Field: ‘persistent’
[10:25:49.662]   - Field: ‘expr’
[10:25:49.663]   - Field: ‘uuid’
[10:25:49.663]   - Field: ‘seed’
[10:25:49.663]   - Field: ‘version’
[10:25:49.663]   - Field: ‘result’
[10:25:49.663]   - Field: ‘asynchronous’
[10:25:49.663]   - Field: ‘calls’
[10:25:49.663]   - Field: ‘globals’
[10:25:49.663]   - Field: ‘stdout’
[10:25:49.663]   - Field: ‘earlySignal’
[10:25:49.663]   - Field: ‘lazy’
[10:25:49.663]   - Field: ‘state’
[10:25:49.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.664] - Launch lazy future ...
[10:25:49.664] Packages needed by the future expression (n = 0): <none>
[10:25:49.664] Packages needed by future strategies (n = 0): <none>
[10:25:49.664] {
[10:25:49.664]     {
[10:25:49.664]         {
[10:25:49.664]             ...future.startTime <- base::Sys.time()
[10:25:49.664]             {
[10:25:49.664]                 {
[10:25:49.664]                   {
[10:25:49.664]                     {
[10:25:49.664]                       base::local({
[10:25:49.664]                         has_future <- base::requireNamespace("future", 
[10:25:49.664]                           quietly = TRUE)
[10:25:49.664]                         if (has_future) {
[10:25:49.664]                           ns <- base::getNamespace("future")
[10:25:49.664]                           version <- ns[[".package"]][["version"]]
[10:25:49.664]                           if (is.null(version)) 
[10:25:49.664]                             version <- utils::packageVersion("future")
[10:25:49.664]                         }
[10:25:49.664]                         else {
[10:25:49.664]                           version <- NULL
[10:25:49.664]                         }
[10:25:49.664]                         if (!has_future || version < "1.8.0") {
[10:25:49.664]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.664]                             "", base::R.version$version.string), 
[10:25:49.664]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.664]                               "release", "version")], collapse = " "), 
[10:25:49.664]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.664]                             info)
[10:25:49.664]                           info <- base::paste(info, collapse = "; ")
[10:25:49.664]                           if (!has_future) {
[10:25:49.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.664]                               info)
[10:25:49.664]                           }
[10:25:49.664]                           else {
[10:25:49.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.664]                               info, version)
[10:25:49.664]                           }
[10:25:49.664]                           base::stop(msg)
[10:25:49.664]                         }
[10:25:49.664]                       })
[10:25:49.664]                     }
[10:25:49.664]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.664]                     base::options(mc.cores = 1L)
[10:25:49.664]                   }
[10:25:49.664]                   options(future.plan = NULL)
[10:25:49.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.664]                 }
[10:25:49.664]                 ...future.workdir <- getwd()
[10:25:49.664]             }
[10:25:49.664]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.664]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.664]         }
[10:25:49.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.664]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.664]             base::names(...future.oldOptions))
[10:25:49.664]     }
[10:25:49.664]     if (FALSE) {
[10:25:49.664]     }
[10:25:49.664]     else {
[10:25:49.664]         if (TRUE) {
[10:25:49.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.664]                 open = "w")
[10:25:49.664]         }
[10:25:49.664]         else {
[10:25:49.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.664]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.664]         }
[10:25:49.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.664]             base::sink(type = "output", split = FALSE)
[10:25:49.664]             base::close(...future.stdout)
[10:25:49.664]         }, add = TRUE)
[10:25:49.664]     }
[10:25:49.664]     ...future.frame <- base::sys.nframe()
[10:25:49.664]     ...future.conditions <- base::list()
[10:25:49.664]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.664]     if (FALSE) {
[10:25:49.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.664]     }
[10:25:49.664]     ...future.result <- base::tryCatch({
[10:25:49.664]         base::withCallingHandlers({
[10:25:49.664]             ...future.value <- base::withVisible(base::local({
[10:25:49.664]                 ...future.makeSendCondition <- base::local({
[10:25:49.664]                   sendCondition <- NULL
[10:25:49.664]                   function(frame = 1L) {
[10:25:49.664]                     if (is.function(sendCondition)) 
[10:25:49.664]                       return(sendCondition)
[10:25:49.664]                     ns <- getNamespace("parallel")
[10:25:49.664]                     if (exists("sendData", mode = "function", 
[10:25:49.664]                       envir = ns)) {
[10:25:49.664]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.664]                         envir = ns)
[10:25:49.664]                       envir <- sys.frame(frame)
[10:25:49.664]                       master <- NULL
[10:25:49.664]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.664]                         !identical(envir, emptyenv())) {
[10:25:49.664]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.664]                           inherits = FALSE)) {
[10:25:49.664]                           master <- get("master", mode = "list", 
[10:25:49.664]                             envir = envir, inherits = FALSE)
[10:25:49.664]                           if (inherits(master, c("SOCKnode", 
[10:25:49.664]                             "SOCK0node"))) {
[10:25:49.664]                             sendCondition <<- function(cond) {
[10:25:49.664]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.664]                                 success = TRUE)
[10:25:49.664]                               parallel_sendData(master, data)
[10:25:49.664]                             }
[10:25:49.664]                             return(sendCondition)
[10:25:49.664]                           }
[10:25:49.664]                         }
[10:25:49.664]                         frame <- frame + 1L
[10:25:49.664]                         envir <- sys.frame(frame)
[10:25:49.664]                       }
[10:25:49.664]                     }
[10:25:49.664]                     sendCondition <<- function(cond) NULL
[10:25:49.664]                   }
[10:25:49.664]                 })
[10:25:49.664]                 withCallingHandlers({
[10:25:49.664]                   NULL
[10:25:49.664]                 }, immediateCondition = function(cond) {
[10:25:49.664]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.664]                   sendCondition(cond)
[10:25:49.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.664]                   {
[10:25:49.664]                     inherits <- base::inherits
[10:25:49.664]                     invokeRestart <- base::invokeRestart
[10:25:49.664]                     is.null <- base::is.null
[10:25:49.664]                     muffled <- FALSE
[10:25:49.664]                     if (inherits(cond, "message")) {
[10:25:49.664]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.664]                       if (muffled) 
[10:25:49.664]                         invokeRestart("muffleMessage")
[10:25:49.664]                     }
[10:25:49.664]                     else if (inherits(cond, "warning")) {
[10:25:49.664]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.664]                       if (muffled) 
[10:25:49.664]                         invokeRestart("muffleWarning")
[10:25:49.664]                     }
[10:25:49.664]                     else if (inherits(cond, "condition")) {
[10:25:49.664]                       if (!is.null(pattern)) {
[10:25:49.664]                         computeRestarts <- base::computeRestarts
[10:25:49.664]                         grepl <- base::grepl
[10:25:49.664]                         restarts <- computeRestarts(cond)
[10:25:49.664]                         for (restart in restarts) {
[10:25:49.664]                           name <- restart$name
[10:25:49.664]                           if (is.null(name)) 
[10:25:49.664]                             next
[10:25:49.664]                           if (!grepl(pattern, name)) 
[10:25:49.664]                             next
[10:25:49.664]                           invokeRestart(restart)
[10:25:49.664]                           muffled <- TRUE
[10:25:49.664]                           break
[10:25:49.664]                         }
[10:25:49.664]                       }
[10:25:49.664]                     }
[10:25:49.664]                     invisible(muffled)
[10:25:49.664]                   }
[10:25:49.664]                   muffleCondition(cond)
[10:25:49.664]                 })
[10:25:49.664]             }))
[10:25:49.664]             future::FutureResult(value = ...future.value$value, 
[10:25:49.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.664]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.664]                     ...future.globalenv.names))
[10:25:49.664]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.664]         }, condition = base::local({
[10:25:49.664]             c <- base::c
[10:25:49.664]             inherits <- base::inherits
[10:25:49.664]             invokeRestart <- base::invokeRestart
[10:25:49.664]             length <- base::length
[10:25:49.664]             list <- base::list
[10:25:49.664]             seq.int <- base::seq.int
[10:25:49.664]             signalCondition <- base::signalCondition
[10:25:49.664]             sys.calls <- base::sys.calls
[10:25:49.664]             `[[` <- base::`[[`
[10:25:49.664]             `+` <- base::`+`
[10:25:49.664]             `<<-` <- base::`<<-`
[10:25:49.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.664]                   3L)]
[10:25:49.664]             }
[10:25:49.664]             function(cond) {
[10:25:49.664]                 is_error <- inherits(cond, "error")
[10:25:49.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.664]                   NULL)
[10:25:49.664]                 if (is_error) {
[10:25:49.664]                   sessionInformation <- function() {
[10:25:49.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.664]                       search = base::search(), system = base::Sys.info())
[10:25:49.664]                   }
[10:25:49.664]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.664]                     cond$call), session = sessionInformation(), 
[10:25:49.664]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.664]                   signalCondition(cond)
[10:25:49.664]                 }
[10:25:49.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.664]                 "immediateCondition"))) {
[10:25:49.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.664]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.664]                   if (TRUE && !signal) {
[10:25:49.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.664]                     {
[10:25:49.664]                       inherits <- base::inherits
[10:25:49.664]                       invokeRestart <- base::invokeRestart
[10:25:49.664]                       is.null <- base::is.null
[10:25:49.664]                       muffled <- FALSE
[10:25:49.664]                       if (inherits(cond, "message")) {
[10:25:49.664]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.664]                         if (muffled) 
[10:25:49.664]                           invokeRestart("muffleMessage")
[10:25:49.664]                       }
[10:25:49.664]                       else if (inherits(cond, "warning")) {
[10:25:49.664]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.664]                         if (muffled) 
[10:25:49.664]                           invokeRestart("muffleWarning")
[10:25:49.664]                       }
[10:25:49.664]                       else if (inherits(cond, "condition")) {
[10:25:49.664]                         if (!is.null(pattern)) {
[10:25:49.664]                           computeRestarts <- base::computeRestarts
[10:25:49.664]                           grepl <- base::grepl
[10:25:49.664]                           restarts <- computeRestarts(cond)
[10:25:49.664]                           for (restart in restarts) {
[10:25:49.664]                             name <- restart$name
[10:25:49.664]                             if (is.null(name)) 
[10:25:49.664]                               next
[10:25:49.664]                             if (!grepl(pattern, name)) 
[10:25:49.664]                               next
[10:25:49.664]                             invokeRestart(restart)
[10:25:49.664]                             muffled <- TRUE
[10:25:49.664]                             break
[10:25:49.664]                           }
[10:25:49.664]                         }
[10:25:49.664]                       }
[10:25:49.664]                       invisible(muffled)
[10:25:49.664]                     }
[10:25:49.664]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.664]                   }
[10:25:49.664]                 }
[10:25:49.664]                 else {
[10:25:49.664]                   if (TRUE) {
[10:25:49.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.664]                     {
[10:25:49.664]                       inherits <- base::inherits
[10:25:49.664]                       invokeRestart <- base::invokeRestart
[10:25:49.664]                       is.null <- base::is.null
[10:25:49.664]                       muffled <- FALSE
[10:25:49.664]                       if (inherits(cond, "message")) {
[10:25:49.664]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.664]                         if (muffled) 
[10:25:49.664]                           invokeRestart("muffleMessage")
[10:25:49.664]                       }
[10:25:49.664]                       else if (inherits(cond, "warning")) {
[10:25:49.664]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.664]                         if (muffled) 
[10:25:49.664]                           invokeRestart("muffleWarning")
[10:25:49.664]                       }
[10:25:49.664]                       else if (inherits(cond, "condition")) {
[10:25:49.664]                         if (!is.null(pattern)) {
[10:25:49.664]                           computeRestarts <- base::computeRestarts
[10:25:49.664]                           grepl <- base::grepl
[10:25:49.664]                           restarts <- computeRestarts(cond)
[10:25:49.664]                           for (restart in restarts) {
[10:25:49.664]                             name <- restart$name
[10:25:49.664]                             if (is.null(name)) 
[10:25:49.664]                               next
[10:25:49.664]                             if (!grepl(pattern, name)) 
[10:25:49.664]                               next
[10:25:49.664]                             invokeRestart(restart)
[10:25:49.664]                             muffled <- TRUE
[10:25:49.664]                             break
[10:25:49.664]                           }
[10:25:49.664]                         }
[10:25:49.664]                       }
[10:25:49.664]                       invisible(muffled)
[10:25:49.664]                     }
[10:25:49.664]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.664]                   }
[10:25:49.664]                 }
[10:25:49.664]             }
[10:25:49.664]         }))
[10:25:49.664]     }, error = function(ex) {
[10:25:49.664]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.664]                 ...future.rng), started = ...future.startTime, 
[10:25:49.664]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.664]             version = "1.8"), class = "FutureResult")
[10:25:49.664]     }, finally = {
[10:25:49.664]         if (!identical(...future.workdir, getwd())) 
[10:25:49.664]             setwd(...future.workdir)
[10:25:49.664]         {
[10:25:49.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.664]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.664]             }
[10:25:49.664]             base::options(...future.oldOptions)
[10:25:49.664]             if (.Platform$OS.type == "windows") {
[10:25:49.664]                 old_names <- names(...future.oldEnvVars)
[10:25:49.664]                 envs <- base::Sys.getenv()
[10:25:49.664]                 names <- names(envs)
[10:25:49.664]                 common <- intersect(names, old_names)
[10:25:49.664]                 added <- setdiff(names, old_names)
[10:25:49.664]                 removed <- setdiff(old_names, names)
[10:25:49.664]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.664]                   envs[common]]
[10:25:49.664]                 NAMES <- toupper(changed)
[10:25:49.664]                 args <- list()
[10:25:49.664]                 for (kk in seq_along(NAMES)) {
[10:25:49.664]                   name <- changed[[kk]]
[10:25:49.664]                   NAME <- NAMES[[kk]]
[10:25:49.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.664]                     next
[10:25:49.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.664]                 }
[10:25:49.664]                 NAMES <- toupper(added)
[10:25:49.664]                 for (kk in seq_along(NAMES)) {
[10:25:49.664]                   name <- added[[kk]]
[10:25:49.664]                   NAME <- NAMES[[kk]]
[10:25:49.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.664]                     next
[10:25:49.664]                   args[[name]] <- ""
[10:25:49.664]                 }
[10:25:49.664]                 NAMES <- toupper(removed)
[10:25:49.664]                 for (kk in seq_along(NAMES)) {
[10:25:49.664]                   name <- removed[[kk]]
[10:25:49.664]                   NAME <- NAMES[[kk]]
[10:25:49.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.664]                     next
[10:25:49.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.664]                 }
[10:25:49.664]                 if (length(args) > 0) 
[10:25:49.664]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.664]             }
[10:25:49.664]             else {
[10:25:49.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.664]             }
[10:25:49.664]             {
[10:25:49.664]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.664]                   0L) {
[10:25:49.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.664]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.664]                   base::options(opts)
[10:25:49.664]                 }
[10:25:49.664]                 {
[10:25:49.664]                   {
[10:25:49.664]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.664]                     NULL
[10:25:49.664]                   }
[10:25:49.664]                   options(future.plan = NULL)
[10:25:49.664]                   if (is.na(NA_character_)) 
[10:25:49.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.664]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.664]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.664]                     envir = parent.frame()) 
[10:25:49.664]                   {
[10:25:49.664]                     if (is.function(workers)) 
[10:25:49.664]                       workers <- workers()
[10:25:49.664]                     workers <- structure(as.integer(workers), 
[10:25:49.664]                       class = class(workers))
[10:25:49.664]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.664]                       workers >= 1)
[10:25:49.664]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.664]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.664]                     }
[10:25:49.664]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.664]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.664]                       envir = envir)
[10:25:49.664]                     if (!future$lazy) 
[10:25:49.664]                       future <- run(future)
[10:25:49.664]                     invisible(future)
[10:25:49.664]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.664]                 }
[10:25:49.664]             }
[10:25:49.664]         }
[10:25:49.664]     })
[10:25:49.664]     if (TRUE) {
[10:25:49.664]         base::sink(type = "output", split = FALSE)
[10:25:49.664]         if (TRUE) {
[10:25:49.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.664]         }
[10:25:49.664]         else {
[10:25:49.664]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.664]         }
[10:25:49.664]         base::close(...future.stdout)
[10:25:49.664]         ...future.stdout <- NULL
[10:25:49.664]     }
[10:25:49.664]     ...future.result$conditions <- ...future.conditions
[10:25:49.664]     ...future.result$finished <- base::Sys.time()
[10:25:49.664]     ...future.result
[10:25:49.664] }
[10:25:49.667] MultisessionFuture started
[10:25:49.668] - Launch lazy future ... done
[10:25:49.668] run() for ‘MultisessionFuture’ ... done
[10:25:49.668] getGlobalsAndPackages() ...
[10:25:49.668] Searching for globals...
[10:25:49.669] - globals found: [1] ‘{’
[10:25:49.669] Searching for globals ... DONE
[10:25:49.669] Resolving globals: FALSE
[10:25:49.669] 
[10:25:49.669] 
[10:25:49.669] getGlobalsAndPackages() ... DONE
[10:25:49.670] run() for ‘Future’ ...
[10:25:49.670] - state: ‘created’
[10:25:49.670] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.683]   - Field: ‘node’
[10:25:49.683]   - Field: ‘label’
[10:25:49.683]   - Field: ‘local’
[10:25:49.683]   - Field: ‘owner’
[10:25:49.683]   - Field: ‘envir’
[10:25:49.684]   - Field: ‘workers’
[10:25:49.684]   - Field: ‘packages’
[10:25:49.684]   - Field: ‘gc’
[10:25:49.684]   - Field: ‘conditions’
[10:25:49.684]   - Field: ‘persistent’
[10:25:49.684]   - Field: ‘expr’
[10:25:49.684]   - Field: ‘uuid’
[10:25:49.684]   - Field: ‘seed’
[10:25:49.684]   - Field: ‘version’
[10:25:49.684]   - Field: ‘result’
[10:25:49.684]   - Field: ‘asynchronous’
[10:25:49.685]   - Field: ‘calls’
[10:25:49.685]   - Field: ‘globals’
[10:25:49.685]   - Field: ‘stdout’
[10:25:49.685]   - Field: ‘earlySignal’
[10:25:49.685]   - Field: ‘lazy’
[10:25:49.685]   - Field: ‘state’
[10:25:49.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.685] - Launch lazy future ...
[10:25:49.685] Packages needed by the future expression (n = 0): <none>
[10:25:49.686] Packages needed by future strategies (n = 0): <none>
[10:25:49.686] {
[10:25:49.686]     {
[10:25:49.686]         {
[10:25:49.686]             ...future.startTime <- base::Sys.time()
[10:25:49.686]             {
[10:25:49.686]                 {
[10:25:49.686]                   {
[10:25:49.686]                     {
[10:25:49.686]                       base::local({
[10:25:49.686]                         has_future <- base::requireNamespace("future", 
[10:25:49.686]                           quietly = TRUE)
[10:25:49.686]                         if (has_future) {
[10:25:49.686]                           ns <- base::getNamespace("future")
[10:25:49.686]                           version <- ns[[".package"]][["version"]]
[10:25:49.686]                           if (is.null(version)) 
[10:25:49.686]                             version <- utils::packageVersion("future")
[10:25:49.686]                         }
[10:25:49.686]                         else {
[10:25:49.686]                           version <- NULL
[10:25:49.686]                         }
[10:25:49.686]                         if (!has_future || version < "1.8.0") {
[10:25:49.686]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.686]                             "", base::R.version$version.string), 
[10:25:49.686]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.686]                               "release", "version")], collapse = " "), 
[10:25:49.686]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.686]                             info)
[10:25:49.686]                           info <- base::paste(info, collapse = "; ")
[10:25:49.686]                           if (!has_future) {
[10:25:49.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.686]                               info)
[10:25:49.686]                           }
[10:25:49.686]                           else {
[10:25:49.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.686]                               info, version)
[10:25:49.686]                           }
[10:25:49.686]                           base::stop(msg)
[10:25:49.686]                         }
[10:25:49.686]                       })
[10:25:49.686]                     }
[10:25:49.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.686]                     base::options(mc.cores = 1L)
[10:25:49.686]                   }
[10:25:49.686]                   options(future.plan = NULL)
[10:25:49.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.686]                 }
[10:25:49.686]                 ...future.workdir <- getwd()
[10:25:49.686]             }
[10:25:49.686]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.686]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.686]         }
[10:25:49.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.686]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.686]             base::names(...future.oldOptions))
[10:25:49.686]     }
[10:25:49.686]     if (FALSE) {
[10:25:49.686]     }
[10:25:49.686]     else {
[10:25:49.686]         if (TRUE) {
[10:25:49.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.686]                 open = "w")
[10:25:49.686]         }
[10:25:49.686]         else {
[10:25:49.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.686]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.686]         }
[10:25:49.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.686]             base::sink(type = "output", split = FALSE)
[10:25:49.686]             base::close(...future.stdout)
[10:25:49.686]         }, add = TRUE)
[10:25:49.686]     }
[10:25:49.686]     ...future.frame <- base::sys.nframe()
[10:25:49.686]     ...future.conditions <- base::list()
[10:25:49.686]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.686]     if (FALSE) {
[10:25:49.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.686]     }
[10:25:49.686]     ...future.result <- base::tryCatch({
[10:25:49.686]         base::withCallingHandlers({
[10:25:49.686]             ...future.value <- base::withVisible(base::local({
[10:25:49.686]                 ...future.makeSendCondition <- base::local({
[10:25:49.686]                   sendCondition <- NULL
[10:25:49.686]                   function(frame = 1L) {
[10:25:49.686]                     if (is.function(sendCondition)) 
[10:25:49.686]                       return(sendCondition)
[10:25:49.686]                     ns <- getNamespace("parallel")
[10:25:49.686]                     if (exists("sendData", mode = "function", 
[10:25:49.686]                       envir = ns)) {
[10:25:49.686]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.686]                         envir = ns)
[10:25:49.686]                       envir <- sys.frame(frame)
[10:25:49.686]                       master <- NULL
[10:25:49.686]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.686]                         !identical(envir, emptyenv())) {
[10:25:49.686]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.686]                           inherits = FALSE)) {
[10:25:49.686]                           master <- get("master", mode = "list", 
[10:25:49.686]                             envir = envir, inherits = FALSE)
[10:25:49.686]                           if (inherits(master, c("SOCKnode", 
[10:25:49.686]                             "SOCK0node"))) {
[10:25:49.686]                             sendCondition <<- function(cond) {
[10:25:49.686]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.686]                                 success = TRUE)
[10:25:49.686]                               parallel_sendData(master, data)
[10:25:49.686]                             }
[10:25:49.686]                             return(sendCondition)
[10:25:49.686]                           }
[10:25:49.686]                         }
[10:25:49.686]                         frame <- frame + 1L
[10:25:49.686]                         envir <- sys.frame(frame)
[10:25:49.686]                       }
[10:25:49.686]                     }
[10:25:49.686]                     sendCondition <<- function(cond) NULL
[10:25:49.686]                   }
[10:25:49.686]                 })
[10:25:49.686]                 withCallingHandlers({
[10:25:49.686]                   {
[10:25:49.686]                     4
[10:25:49.686]                   }
[10:25:49.686]                 }, immediateCondition = function(cond) {
[10:25:49.686]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.686]                   sendCondition(cond)
[10:25:49.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.686]                   {
[10:25:49.686]                     inherits <- base::inherits
[10:25:49.686]                     invokeRestart <- base::invokeRestart
[10:25:49.686]                     is.null <- base::is.null
[10:25:49.686]                     muffled <- FALSE
[10:25:49.686]                     if (inherits(cond, "message")) {
[10:25:49.686]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.686]                       if (muffled) 
[10:25:49.686]                         invokeRestart("muffleMessage")
[10:25:49.686]                     }
[10:25:49.686]                     else if (inherits(cond, "warning")) {
[10:25:49.686]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.686]                       if (muffled) 
[10:25:49.686]                         invokeRestart("muffleWarning")
[10:25:49.686]                     }
[10:25:49.686]                     else if (inherits(cond, "condition")) {
[10:25:49.686]                       if (!is.null(pattern)) {
[10:25:49.686]                         computeRestarts <- base::computeRestarts
[10:25:49.686]                         grepl <- base::grepl
[10:25:49.686]                         restarts <- computeRestarts(cond)
[10:25:49.686]                         for (restart in restarts) {
[10:25:49.686]                           name <- restart$name
[10:25:49.686]                           if (is.null(name)) 
[10:25:49.686]                             next
[10:25:49.686]                           if (!grepl(pattern, name)) 
[10:25:49.686]                             next
[10:25:49.686]                           invokeRestart(restart)
[10:25:49.686]                           muffled <- TRUE
[10:25:49.686]                           break
[10:25:49.686]                         }
[10:25:49.686]                       }
[10:25:49.686]                     }
[10:25:49.686]                     invisible(muffled)
[10:25:49.686]                   }
[10:25:49.686]                   muffleCondition(cond)
[10:25:49.686]                 })
[10:25:49.686]             }))
[10:25:49.686]             future::FutureResult(value = ...future.value$value, 
[10:25:49.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.686]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.686]                     ...future.globalenv.names))
[10:25:49.686]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.686]         }, condition = base::local({
[10:25:49.686]             c <- base::c
[10:25:49.686]             inherits <- base::inherits
[10:25:49.686]             invokeRestart <- base::invokeRestart
[10:25:49.686]             length <- base::length
[10:25:49.686]             list <- base::list
[10:25:49.686]             seq.int <- base::seq.int
[10:25:49.686]             signalCondition <- base::signalCondition
[10:25:49.686]             sys.calls <- base::sys.calls
[10:25:49.686]             `[[` <- base::`[[`
[10:25:49.686]             `+` <- base::`+`
[10:25:49.686]             `<<-` <- base::`<<-`
[10:25:49.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.686]                   3L)]
[10:25:49.686]             }
[10:25:49.686]             function(cond) {
[10:25:49.686]                 is_error <- inherits(cond, "error")
[10:25:49.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.686]                   NULL)
[10:25:49.686]                 if (is_error) {
[10:25:49.686]                   sessionInformation <- function() {
[10:25:49.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.686]                       search = base::search(), system = base::Sys.info())
[10:25:49.686]                   }
[10:25:49.686]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.686]                     cond$call), session = sessionInformation(), 
[10:25:49.686]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.686]                   signalCondition(cond)
[10:25:49.686]                 }
[10:25:49.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.686]                 "immediateCondition"))) {
[10:25:49.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.686]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.686]                   if (TRUE && !signal) {
[10:25:49.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.686]                     {
[10:25:49.686]                       inherits <- base::inherits
[10:25:49.686]                       invokeRestart <- base::invokeRestart
[10:25:49.686]                       is.null <- base::is.null
[10:25:49.686]                       muffled <- FALSE
[10:25:49.686]                       if (inherits(cond, "message")) {
[10:25:49.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.686]                         if (muffled) 
[10:25:49.686]                           invokeRestart("muffleMessage")
[10:25:49.686]                       }
[10:25:49.686]                       else if (inherits(cond, "warning")) {
[10:25:49.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.686]                         if (muffled) 
[10:25:49.686]                           invokeRestart("muffleWarning")
[10:25:49.686]                       }
[10:25:49.686]                       else if (inherits(cond, "condition")) {
[10:25:49.686]                         if (!is.null(pattern)) {
[10:25:49.686]                           computeRestarts <- base::computeRestarts
[10:25:49.686]                           grepl <- base::grepl
[10:25:49.686]                           restarts <- computeRestarts(cond)
[10:25:49.686]                           for (restart in restarts) {
[10:25:49.686]                             name <- restart$name
[10:25:49.686]                             if (is.null(name)) 
[10:25:49.686]                               next
[10:25:49.686]                             if (!grepl(pattern, name)) 
[10:25:49.686]                               next
[10:25:49.686]                             invokeRestart(restart)
[10:25:49.686]                             muffled <- TRUE
[10:25:49.686]                             break
[10:25:49.686]                           }
[10:25:49.686]                         }
[10:25:49.686]                       }
[10:25:49.686]                       invisible(muffled)
[10:25:49.686]                     }
[10:25:49.686]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.686]                   }
[10:25:49.686]                 }
[10:25:49.686]                 else {
[10:25:49.686]                   if (TRUE) {
[10:25:49.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.686]                     {
[10:25:49.686]                       inherits <- base::inherits
[10:25:49.686]                       invokeRestart <- base::invokeRestart
[10:25:49.686]                       is.null <- base::is.null
[10:25:49.686]                       muffled <- FALSE
[10:25:49.686]                       if (inherits(cond, "message")) {
[10:25:49.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.686]                         if (muffled) 
[10:25:49.686]                           invokeRestart("muffleMessage")
[10:25:49.686]                       }
[10:25:49.686]                       else if (inherits(cond, "warning")) {
[10:25:49.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.686]                         if (muffled) 
[10:25:49.686]                           invokeRestart("muffleWarning")
[10:25:49.686]                       }
[10:25:49.686]                       else if (inherits(cond, "condition")) {
[10:25:49.686]                         if (!is.null(pattern)) {
[10:25:49.686]                           computeRestarts <- base::computeRestarts
[10:25:49.686]                           grepl <- base::grepl
[10:25:49.686]                           restarts <- computeRestarts(cond)
[10:25:49.686]                           for (restart in restarts) {
[10:25:49.686]                             name <- restart$name
[10:25:49.686]                             if (is.null(name)) 
[10:25:49.686]                               next
[10:25:49.686]                             if (!grepl(pattern, name)) 
[10:25:49.686]                               next
[10:25:49.686]                             invokeRestart(restart)
[10:25:49.686]                             muffled <- TRUE
[10:25:49.686]                             break
[10:25:49.686]                           }
[10:25:49.686]                         }
[10:25:49.686]                       }
[10:25:49.686]                       invisible(muffled)
[10:25:49.686]                     }
[10:25:49.686]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.686]                   }
[10:25:49.686]                 }
[10:25:49.686]             }
[10:25:49.686]         }))
[10:25:49.686]     }, error = function(ex) {
[10:25:49.686]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.686]                 ...future.rng), started = ...future.startTime, 
[10:25:49.686]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.686]             version = "1.8"), class = "FutureResult")
[10:25:49.686]     }, finally = {
[10:25:49.686]         if (!identical(...future.workdir, getwd())) 
[10:25:49.686]             setwd(...future.workdir)
[10:25:49.686]         {
[10:25:49.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.686]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.686]             }
[10:25:49.686]             base::options(...future.oldOptions)
[10:25:49.686]             if (.Platform$OS.type == "windows") {
[10:25:49.686]                 old_names <- names(...future.oldEnvVars)
[10:25:49.686]                 envs <- base::Sys.getenv()
[10:25:49.686]                 names <- names(envs)
[10:25:49.686]                 common <- intersect(names, old_names)
[10:25:49.686]                 added <- setdiff(names, old_names)
[10:25:49.686]                 removed <- setdiff(old_names, names)
[10:25:49.686]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.686]                   envs[common]]
[10:25:49.686]                 NAMES <- toupper(changed)
[10:25:49.686]                 args <- list()
[10:25:49.686]                 for (kk in seq_along(NAMES)) {
[10:25:49.686]                   name <- changed[[kk]]
[10:25:49.686]                   NAME <- NAMES[[kk]]
[10:25:49.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.686]                     next
[10:25:49.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.686]                 }
[10:25:49.686]                 NAMES <- toupper(added)
[10:25:49.686]                 for (kk in seq_along(NAMES)) {
[10:25:49.686]                   name <- added[[kk]]
[10:25:49.686]                   NAME <- NAMES[[kk]]
[10:25:49.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.686]                     next
[10:25:49.686]                   args[[name]] <- ""
[10:25:49.686]                 }
[10:25:49.686]                 NAMES <- toupper(removed)
[10:25:49.686]                 for (kk in seq_along(NAMES)) {
[10:25:49.686]                   name <- removed[[kk]]
[10:25:49.686]                   NAME <- NAMES[[kk]]
[10:25:49.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.686]                     next
[10:25:49.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.686]                 }
[10:25:49.686]                 if (length(args) > 0) 
[10:25:49.686]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.686]             }
[10:25:49.686]             else {
[10:25:49.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.686]             }
[10:25:49.686]             {
[10:25:49.686]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.686]                   0L) {
[10:25:49.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.686]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.686]                   base::options(opts)
[10:25:49.686]                 }
[10:25:49.686]                 {
[10:25:49.686]                   {
[10:25:49.686]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.686]                     NULL
[10:25:49.686]                   }
[10:25:49.686]                   options(future.plan = NULL)
[10:25:49.686]                   if (is.na(NA_character_)) 
[10:25:49.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.686]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.686]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.686]                     envir = parent.frame()) 
[10:25:49.686]                   {
[10:25:49.686]                     if (is.function(workers)) 
[10:25:49.686]                       workers <- workers()
[10:25:49.686]                     workers <- structure(as.integer(workers), 
[10:25:49.686]                       class = class(workers))
[10:25:49.686]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.686]                       workers >= 1)
[10:25:49.686]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.686]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.686]                     }
[10:25:49.686]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.686]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.686]                       envir = envir)
[10:25:49.686]                     if (!future$lazy) 
[10:25:49.686]                       future <- run(future)
[10:25:49.686]                     invisible(future)
[10:25:49.686]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.686]                 }
[10:25:49.686]             }
[10:25:49.686]         }
[10:25:49.686]     })
[10:25:49.686]     if (TRUE) {
[10:25:49.686]         base::sink(type = "output", split = FALSE)
[10:25:49.686]         if (TRUE) {
[10:25:49.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.686]         }
[10:25:49.686]         else {
[10:25:49.686]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.686]         }
[10:25:49.686]         base::close(...future.stdout)
[10:25:49.686]         ...future.stdout <- NULL
[10:25:49.686]     }
[10:25:49.686]     ...future.result$conditions <- ...future.conditions
[10:25:49.686]     ...future.result$finished <- base::Sys.time()
[10:25:49.686]     ...future.result
[10:25:49.686] }
[10:25:49.688] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:49.699] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.699] - Validating connection of MultisessionFuture
[10:25:49.699] - received message: FutureResult
[10:25:49.699] - Received FutureResult
[10:25:49.699] - Erased future from FutureRegistry
[10:25:49.699] result() for ClusterFuture ...
[10:25:49.700] - result already collected: FutureResult
[10:25:49.700] result() for ClusterFuture ... done
[10:25:49.700] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.700] result() for ClusterFuture ...
[10:25:49.700] - result already collected: FutureResult
[10:25:49.700] result() for ClusterFuture ... done
[10:25:49.700] result() for ClusterFuture ...
[10:25:49.700] - result already collected: FutureResult
[10:25:49.700] result() for ClusterFuture ... done
[10:25:49.701] MultisessionFuture started
[10:25:49.701] - Launch lazy future ... done
[10:25:49.702] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c0f3dfae00> 
<environment: 0x55c0f698fef8> 
 Named logi [1:4] TRUE TRUE FALSE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:49.725] resolve() on environment ...
[10:25:49.725]  recursive: 0
[10:25:49.726]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:49.726] signalConditionsASAP(numeric, pos=1) ...
[10:25:49.726] - nx: 4
[10:25:49.726] - relay: TRUE
[10:25:49.726] - stdout: TRUE
[10:25:49.726] - signal: TRUE
[10:25:49.726] - resignal: FALSE
[10:25:49.726] - force: TRUE
[10:25:49.726] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.727] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.727]  - until=2
[10:25:49.727]  - relaying element #2
[10:25:49.727] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.727] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.727] signalConditionsASAP(NULL, pos=1) ... done
[10:25:49.727]  length: 3 (resolved future 1)
[10:25:49.727] Future #2
[10:25:49.727] result() for ClusterFuture ...
[10:25:49.727] - result already collected: FutureResult
[10:25:49.727] result() for ClusterFuture ... done
[10:25:49.728] result() for ClusterFuture ...
[10:25:49.728] - result already collected: FutureResult
[10:25:49.728] result() for ClusterFuture ... done
[10:25:49.728] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:49.728] - nx: 4
[10:25:49.728] - relay: TRUE
[10:25:49.728] - stdout: TRUE
[10:25:49.728] - signal: TRUE
[10:25:49.728] - resignal: FALSE
[10:25:49.728] - force: TRUE
[10:25:49.728] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.728] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.729]  - until=2
[10:25:49.729]  - relaying element #2
[10:25:49.729] result() for ClusterFuture ...
[10:25:49.729] - result already collected: FutureResult
[10:25:49.729] result() for ClusterFuture ... done
[10:25:49.729] result() for ClusterFuture ...
[10:25:49.729] - result already collected: FutureResult
[10:25:49.729] result() for ClusterFuture ... done
[10:25:49.729] result() for ClusterFuture ...
[10:25:49.729] - result already collected: FutureResult
[10:25:49.729] result() for ClusterFuture ... done
[10:25:49.730] result() for ClusterFuture ...
[10:25:49.730] - result already collected: FutureResult
[10:25:49.730] result() for ClusterFuture ... done
[10:25:49.730] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.730] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.730] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:49.730]  length: 2 (resolved future 2)
[10:25:49.731] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.731] - Validating connection of MultisessionFuture
[10:25:49.731] - received message: FutureResult
[10:25:49.731] - Received FutureResult
[10:25:49.731] - Erased future from FutureRegistry
[10:25:49.731] result() for ClusterFuture ...
[10:25:49.731] - result already collected: FutureResult
[10:25:49.731] result() for ClusterFuture ... done
[10:25:49.731] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.732] Future #3
[10:25:49.732] result() for ClusterFuture ...
[10:25:49.732] - result already collected: FutureResult
[10:25:49.732] result() for ClusterFuture ... done
[10:25:49.732] result() for ClusterFuture ...
[10:25:49.732] - result already collected: FutureResult
[10:25:49.732] result() for ClusterFuture ... done
[10:25:49.732] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:49.732] - nx: 4
[10:25:49.732] - relay: TRUE
[10:25:49.732] - stdout: TRUE
[10:25:49.732] - signal: TRUE
[10:25:49.733] - resignal: FALSE
[10:25:49.733] - force: TRUE
[10:25:49.733] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.733] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.733]  - until=3
[10:25:49.733]  - relaying element #3
[10:25:49.733] result() for ClusterFuture ...
[10:25:49.733] - result already collected: FutureResult
[10:25:49.733] result() for ClusterFuture ... done
[10:25:49.733] result() for ClusterFuture ...
[10:25:49.733] - result already collected: FutureResult
[10:25:49.734] result() for ClusterFuture ... done
[10:25:49.734] result() for ClusterFuture ...
[10:25:49.734] - result already collected: FutureResult
[10:25:49.734] result() for ClusterFuture ... done
[10:25:49.734] result() for ClusterFuture ...
[10:25:49.734] - result already collected: FutureResult
[10:25:49.734] result() for ClusterFuture ... done
[10:25:49.734] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.734] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.734] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:49.734]  length: 1 (resolved future 3)
[10:25:49.755] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.755] - Validating connection of MultisessionFuture
[10:25:49.756] - received message: FutureResult
[10:25:49.756] - Received FutureResult
[10:25:49.756] - Erased future from FutureRegistry
[10:25:49.756] result() for ClusterFuture ...
[10:25:49.756] - result already collected: FutureResult
[10:25:49.756] result() for ClusterFuture ... done
[10:25:49.756] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.756] Future #4
[10:25:49.756] result() for ClusterFuture ...
[10:25:49.756] - result already collected: FutureResult
[10:25:49.757] result() for ClusterFuture ... done
[10:25:49.757] result() for ClusterFuture ...
[10:25:49.757] - result already collected: FutureResult
[10:25:49.757] result() for ClusterFuture ... done
[10:25:49.757] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:49.757] - nx: 4
[10:25:49.757] - relay: TRUE
[10:25:49.757] - stdout: TRUE
[10:25:49.757] - signal: TRUE
[10:25:49.757] - resignal: FALSE
[10:25:49.757] - force: TRUE
[10:25:49.758] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.758] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.758]  - until=4
[10:25:49.758]  - relaying element #4
[10:25:49.758] result() for ClusterFuture ...
[10:25:49.758] - result already collected: FutureResult
[10:25:49.758] result() for ClusterFuture ... done
[10:25:49.758] result() for ClusterFuture ...
[10:25:49.758] - result already collected: FutureResult
[10:25:49.758] result() for ClusterFuture ... done
[10:25:49.759] result() for ClusterFuture ...
[10:25:49.759] - result already collected: FutureResult
[10:25:49.759] result() for ClusterFuture ... done
[10:25:49.759] result() for ClusterFuture ...
[10:25:49.759] - result already collected: FutureResult
[10:25:49.759] result() for ClusterFuture ... done
[10:25:49.759] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.759] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.759] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:49.759]  length: 0 (resolved future 4)
[10:25:49.759] Relaying remaining futures
[10:25:49.759] signalConditionsASAP(NULL, pos=0) ...
[10:25:49.760] - nx: 4
[10:25:49.760] - relay: TRUE
[10:25:49.760] - stdout: TRUE
[10:25:49.760] - signal: TRUE
[10:25:49.760] - resignal: FALSE
[10:25:49.760] - force: TRUE
[10:25:49.760] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.760] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:49.760] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.760] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.760] signalConditionsASAP(NULL, pos=0) ... done
[10:25:49.761] resolve() on environment ... DONE
[10:25:49.763] result() for ClusterFuture ...
[10:25:49.763] - result already collected: FutureResult
[10:25:49.763] result() for ClusterFuture ... done
[10:25:49.763] result() for ClusterFuture ...
[10:25:49.764] - result already collected: FutureResult
[10:25:49.764] result() for ClusterFuture ... done
[10:25:49.764] result() for ClusterFuture ...
[10:25:49.764] - result already collected: FutureResult
[10:25:49.764] result() for ClusterFuture ... done
[10:25:49.764] result() for ClusterFuture ...
[10:25:49.764] - result already collected: FutureResult
[10:25:49.764] result() for ClusterFuture ... done
[10:25:49.764] result() for ClusterFuture ...
[10:25:49.764] - result already collected: FutureResult
[10:25:49.764] result() for ClusterFuture ... done
[10:25:49.765] result() for ClusterFuture ...
[10:25:49.765] - result already collected: FutureResult
[10:25:49.765] result() for ClusterFuture ... done
<environment: 0x55c0f6b36d78> 
Dimensions: c(2, 1, 3, 1)
[10:25:49.765] getGlobalsAndPackages() ...
[10:25:49.765] Searching for globals...
[10:25:49.766] 
[10:25:49.766] Searching for globals ... DONE
[10:25:49.766] - globals: [0] <none>
[10:25:49.766] getGlobalsAndPackages() ... DONE
[10:25:49.766] run() for ‘Future’ ...
[10:25:49.766] - state: ‘created’
[10:25:49.766] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.780] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.780] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.780]   - Field: ‘node’
[10:25:49.780]   - Field: ‘label’
[10:25:49.780]   - Field: ‘local’
[10:25:49.780]   - Field: ‘owner’
[10:25:49.780]   - Field: ‘envir’
[10:25:49.780]   - Field: ‘workers’
[10:25:49.781]   - Field: ‘packages’
[10:25:49.781]   - Field: ‘gc’
[10:25:49.781]   - Field: ‘conditions’
[10:25:49.781]   - Field: ‘persistent’
[10:25:49.781]   - Field: ‘expr’
[10:25:49.781]   - Field: ‘uuid’
[10:25:49.781]   - Field: ‘seed’
[10:25:49.781]   - Field: ‘version’
[10:25:49.781]   - Field: ‘result’
[10:25:49.781]   - Field: ‘asynchronous’
[10:25:49.781]   - Field: ‘calls’
[10:25:49.782]   - Field: ‘globals’
[10:25:49.782]   - Field: ‘stdout’
[10:25:49.782]   - Field: ‘earlySignal’
[10:25:49.782]   - Field: ‘lazy’
[10:25:49.782]   - Field: ‘state’
[10:25:49.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.782] - Launch lazy future ...
[10:25:49.782] Packages needed by the future expression (n = 0): <none>
[10:25:49.782] Packages needed by future strategies (n = 0): <none>
[10:25:49.783] {
[10:25:49.783]     {
[10:25:49.783]         {
[10:25:49.783]             ...future.startTime <- base::Sys.time()
[10:25:49.783]             {
[10:25:49.783]                 {
[10:25:49.783]                   {
[10:25:49.783]                     {
[10:25:49.783]                       base::local({
[10:25:49.783]                         has_future <- base::requireNamespace("future", 
[10:25:49.783]                           quietly = TRUE)
[10:25:49.783]                         if (has_future) {
[10:25:49.783]                           ns <- base::getNamespace("future")
[10:25:49.783]                           version <- ns[[".package"]][["version"]]
[10:25:49.783]                           if (is.null(version)) 
[10:25:49.783]                             version <- utils::packageVersion("future")
[10:25:49.783]                         }
[10:25:49.783]                         else {
[10:25:49.783]                           version <- NULL
[10:25:49.783]                         }
[10:25:49.783]                         if (!has_future || version < "1.8.0") {
[10:25:49.783]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.783]                             "", base::R.version$version.string), 
[10:25:49.783]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.783]                               "release", "version")], collapse = " "), 
[10:25:49.783]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.783]                             info)
[10:25:49.783]                           info <- base::paste(info, collapse = "; ")
[10:25:49.783]                           if (!has_future) {
[10:25:49.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.783]                               info)
[10:25:49.783]                           }
[10:25:49.783]                           else {
[10:25:49.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.783]                               info, version)
[10:25:49.783]                           }
[10:25:49.783]                           base::stop(msg)
[10:25:49.783]                         }
[10:25:49.783]                       })
[10:25:49.783]                     }
[10:25:49.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.783]                     base::options(mc.cores = 1L)
[10:25:49.783]                   }
[10:25:49.783]                   options(future.plan = NULL)
[10:25:49.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.783]                 }
[10:25:49.783]                 ...future.workdir <- getwd()
[10:25:49.783]             }
[10:25:49.783]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.783]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.783]         }
[10:25:49.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.783]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.783]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.783]             base::names(...future.oldOptions))
[10:25:49.783]     }
[10:25:49.783]     if (FALSE) {
[10:25:49.783]     }
[10:25:49.783]     else {
[10:25:49.783]         if (TRUE) {
[10:25:49.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.783]                 open = "w")
[10:25:49.783]         }
[10:25:49.783]         else {
[10:25:49.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.783]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.783]         }
[10:25:49.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.783]             base::sink(type = "output", split = FALSE)
[10:25:49.783]             base::close(...future.stdout)
[10:25:49.783]         }, add = TRUE)
[10:25:49.783]     }
[10:25:49.783]     ...future.frame <- base::sys.nframe()
[10:25:49.783]     ...future.conditions <- base::list()
[10:25:49.783]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.783]     if (FALSE) {
[10:25:49.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.783]     }
[10:25:49.783]     ...future.result <- base::tryCatch({
[10:25:49.783]         base::withCallingHandlers({
[10:25:49.783]             ...future.value <- base::withVisible(base::local({
[10:25:49.783]                 ...future.makeSendCondition <- base::local({
[10:25:49.783]                   sendCondition <- NULL
[10:25:49.783]                   function(frame = 1L) {
[10:25:49.783]                     if (is.function(sendCondition)) 
[10:25:49.783]                       return(sendCondition)
[10:25:49.783]                     ns <- getNamespace("parallel")
[10:25:49.783]                     if (exists("sendData", mode = "function", 
[10:25:49.783]                       envir = ns)) {
[10:25:49.783]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.783]                         envir = ns)
[10:25:49.783]                       envir <- sys.frame(frame)
[10:25:49.783]                       master <- NULL
[10:25:49.783]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.783]                         !identical(envir, emptyenv())) {
[10:25:49.783]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.783]                           inherits = FALSE)) {
[10:25:49.783]                           master <- get("master", mode = "list", 
[10:25:49.783]                             envir = envir, inherits = FALSE)
[10:25:49.783]                           if (inherits(master, c("SOCKnode", 
[10:25:49.783]                             "SOCK0node"))) {
[10:25:49.783]                             sendCondition <<- function(cond) {
[10:25:49.783]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.783]                                 success = TRUE)
[10:25:49.783]                               parallel_sendData(master, data)
[10:25:49.783]                             }
[10:25:49.783]                             return(sendCondition)
[10:25:49.783]                           }
[10:25:49.783]                         }
[10:25:49.783]                         frame <- frame + 1L
[10:25:49.783]                         envir <- sys.frame(frame)
[10:25:49.783]                       }
[10:25:49.783]                     }
[10:25:49.783]                     sendCondition <<- function(cond) NULL
[10:25:49.783]                   }
[10:25:49.783]                 })
[10:25:49.783]                 withCallingHandlers({
[10:25:49.783]                   2
[10:25:49.783]                 }, immediateCondition = function(cond) {
[10:25:49.783]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.783]                   sendCondition(cond)
[10:25:49.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.783]                   {
[10:25:49.783]                     inherits <- base::inherits
[10:25:49.783]                     invokeRestart <- base::invokeRestart
[10:25:49.783]                     is.null <- base::is.null
[10:25:49.783]                     muffled <- FALSE
[10:25:49.783]                     if (inherits(cond, "message")) {
[10:25:49.783]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.783]                       if (muffled) 
[10:25:49.783]                         invokeRestart("muffleMessage")
[10:25:49.783]                     }
[10:25:49.783]                     else if (inherits(cond, "warning")) {
[10:25:49.783]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.783]                       if (muffled) 
[10:25:49.783]                         invokeRestart("muffleWarning")
[10:25:49.783]                     }
[10:25:49.783]                     else if (inherits(cond, "condition")) {
[10:25:49.783]                       if (!is.null(pattern)) {
[10:25:49.783]                         computeRestarts <- base::computeRestarts
[10:25:49.783]                         grepl <- base::grepl
[10:25:49.783]                         restarts <- computeRestarts(cond)
[10:25:49.783]                         for (restart in restarts) {
[10:25:49.783]                           name <- restart$name
[10:25:49.783]                           if (is.null(name)) 
[10:25:49.783]                             next
[10:25:49.783]                           if (!grepl(pattern, name)) 
[10:25:49.783]                             next
[10:25:49.783]                           invokeRestart(restart)
[10:25:49.783]                           muffled <- TRUE
[10:25:49.783]                           break
[10:25:49.783]                         }
[10:25:49.783]                       }
[10:25:49.783]                     }
[10:25:49.783]                     invisible(muffled)
[10:25:49.783]                   }
[10:25:49.783]                   muffleCondition(cond)
[10:25:49.783]                 })
[10:25:49.783]             }))
[10:25:49.783]             future::FutureResult(value = ...future.value$value, 
[10:25:49.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.783]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.783]                     ...future.globalenv.names))
[10:25:49.783]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.783]         }, condition = base::local({
[10:25:49.783]             c <- base::c
[10:25:49.783]             inherits <- base::inherits
[10:25:49.783]             invokeRestart <- base::invokeRestart
[10:25:49.783]             length <- base::length
[10:25:49.783]             list <- base::list
[10:25:49.783]             seq.int <- base::seq.int
[10:25:49.783]             signalCondition <- base::signalCondition
[10:25:49.783]             sys.calls <- base::sys.calls
[10:25:49.783]             `[[` <- base::`[[`
[10:25:49.783]             `+` <- base::`+`
[10:25:49.783]             `<<-` <- base::`<<-`
[10:25:49.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.783]                   3L)]
[10:25:49.783]             }
[10:25:49.783]             function(cond) {
[10:25:49.783]                 is_error <- inherits(cond, "error")
[10:25:49.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.783]                   NULL)
[10:25:49.783]                 if (is_error) {
[10:25:49.783]                   sessionInformation <- function() {
[10:25:49.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.783]                       search = base::search(), system = base::Sys.info())
[10:25:49.783]                   }
[10:25:49.783]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.783]                     cond$call), session = sessionInformation(), 
[10:25:49.783]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.783]                   signalCondition(cond)
[10:25:49.783]                 }
[10:25:49.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.783]                 "immediateCondition"))) {
[10:25:49.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.783]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.783]                   if (TRUE && !signal) {
[10:25:49.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.783]                     {
[10:25:49.783]                       inherits <- base::inherits
[10:25:49.783]                       invokeRestart <- base::invokeRestart
[10:25:49.783]                       is.null <- base::is.null
[10:25:49.783]                       muffled <- FALSE
[10:25:49.783]                       if (inherits(cond, "message")) {
[10:25:49.783]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.783]                         if (muffled) 
[10:25:49.783]                           invokeRestart("muffleMessage")
[10:25:49.783]                       }
[10:25:49.783]                       else if (inherits(cond, "warning")) {
[10:25:49.783]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.783]                         if (muffled) 
[10:25:49.783]                           invokeRestart("muffleWarning")
[10:25:49.783]                       }
[10:25:49.783]                       else if (inherits(cond, "condition")) {
[10:25:49.783]                         if (!is.null(pattern)) {
[10:25:49.783]                           computeRestarts <- base::computeRestarts
[10:25:49.783]                           grepl <- base::grepl
[10:25:49.783]                           restarts <- computeRestarts(cond)
[10:25:49.783]                           for (restart in restarts) {
[10:25:49.783]                             name <- restart$name
[10:25:49.783]                             if (is.null(name)) 
[10:25:49.783]                               next
[10:25:49.783]                             if (!grepl(pattern, name)) 
[10:25:49.783]                               next
[10:25:49.783]                             invokeRestart(restart)
[10:25:49.783]                             muffled <- TRUE
[10:25:49.783]                             break
[10:25:49.783]                           }
[10:25:49.783]                         }
[10:25:49.783]                       }
[10:25:49.783]                       invisible(muffled)
[10:25:49.783]                     }
[10:25:49.783]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.783]                   }
[10:25:49.783]                 }
[10:25:49.783]                 else {
[10:25:49.783]                   if (TRUE) {
[10:25:49.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.783]                     {
[10:25:49.783]                       inherits <- base::inherits
[10:25:49.783]                       invokeRestart <- base::invokeRestart
[10:25:49.783]                       is.null <- base::is.null
[10:25:49.783]                       muffled <- FALSE
[10:25:49.783]                       if (inherits(cond, "message")) {
[10:25:49.783]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.783]                         if (muffled) 
[10:25:49.783]                           invokeRestart("muffleMessage")
[10:25:49.783]                       }
[10:25:49.783]                       else if (inherits(cond, "warning")) {
[10:25:49.783]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.783]                         if (muffled) 
[10:25:49.783]                           invokeRestart("muffleWarning")
[10:25:49.783]                       }
[10:25:49.783]                       else if (inherits(cond, "condition")) {
[10:25:49.783]                         if (!is.null(pattern)) {
[10:25:49.783]                           computeRestarts <- base::computeRestarts
[10:25:49.783]                           grepl <- base::grepl
[10:25:49.783]                           restarts <- computeRestarts(cond)
[10:25:49.783]                           for (restart in restarts) {
[10:25:49.783]                             name <- restart$name
[10:25:49.783]                             if (is.null(name)) 
[10:25:49.783]                               next
[10:25:49.783]                             if (!grepl(pattern, name)) 
[10:25:49.783]                               next
[10:25:49.783]                             invokeRestart(restart)
[10:25:49.783]                             muffled <- TRUE
[10:25:49.783]                             break
[10:25:49.783]                           }
[10:25:49.783]                         }
[10:25:49.783]                       }
[10:25:49.783]                       invisible(muffled)
[10:25:49.783]                     }
[10:25:49.783]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.783]                   }
[10:25:49.783]                 }
[10:25:49.783]             }
[10:25:49.783]         }))
[10:25:49.783]     }, error = function(ex) {
[10:25:49.783]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.783]                 ...future.rng), started = ...future.startTime, 
[10:25:49.783]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.783]             version = "1.8"), class = "FutureResult")
[10:25:49.783]     }, finally = {
[10:25:49.783]         if (!identical(...future.workdir, getwd())) 
[10:25:49.783]             setwd(...future.workdir)
[10:25:49.783]         {
[10:25:49.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.783]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.783]             }
[10:25:49.783]             base::options(...future.oldOptions)
[10:25:49.783]             if (.Platform$OS.type == "windows") {
[10:25:49.783]                 old_names <- names(...future.oldEnvVars)
[10:25:49.783]                 envs <- base::Sys.getenv()
[10:25:49.783]                 names <- names(envs)
[10:25:49.783]                 common <- intersect(names, old_names)
[10:25:49.783]                 added <- setdiff(names, old_names)
[10:25:49.783]                 removed <- setdiff(old_names, names)
[10:25:49.783]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.783]                   envs[common]]
[10:25:49.783]                 NAMES <- toupper(changed)
[10:25:49.783]                 args <- list()
[10:25:49.783]                 for (kk in seq_along(NAMES)) {
[10:25:49.783]                   name <- changed[[kk]]
[10:25:49.783]                   NAME <- NAMES[[kk]]
[10:25:49.783]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.783]                     next
[10:25:49.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.783]                 }
[10:25:49.783]                 NAMES <- toupper(added)
[10:25:49.783]                 for (kk in seq_along(NAMES)) {
[10:25:49.783]                   name <- added[[kk]]
[10:25:49.783]                   NAME <- NAMES[[kk]]
[10:25:49.783]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.783]                     next
[10:25:49.783]                   args[[name]] <- ""
[10:25:49.783]                 }
[10:25:49.783]                 NAMES <- toupper(removed)
[10:25:49.783]                 for (kk in seq_along(NAMES)) {
[10:25:49.783]                   name <- removed[[kk]]
[10:25:49.783]                   NAME <- NAMES[[kk]]
[10:25:49.783]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.783]                     next
[10:25:49.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.783]                 }
[10:25:49.783]                 if (length(args) > 0) 
[10:25:49.783]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.783]             }
[10:25:49.783]             else {
[10:25:49.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.783]             }
[10:25:49.783]             {
[10:25:49.783]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.783]                   0L) {
[10:25:49.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.783]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.783]                   base::options(opts)
[10:25:49.783]                 }
[10:25:49.783]                 {
[10:25:49.783]                   {
[10:25:49.783]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.783]                     NULL
[10:25:49.783]                   }
[10:25:49.783]                   options(future.plan = NULL)
[10:25:49.783]                   if (is.na(NA_character_)) 
[10:25:49.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.783]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.783]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.783]                     envir = parent.frame()) 
[10:25:49.783]                   {
[10:25:49.783]                     if (is.function(workers)) 
[10:25:49.783]                       workers <- workers()
[10:25:49.783]                     workers <- structure(as.integer(workers), 
[10:25:49.783]                       class = class(workers))
[10:25:49.783]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.783]                       workers >= 1)
[10:25:49.783]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.783]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.783]                     }
[10:25:49.783]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.783]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.783]                       envir = envir)
[10:25:49.783]                     if (!future$lazy) 
[10:25:49.783]                       future <- run(future)
[10:25:49.783]                     invisible(future)
[10:25:49.783]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.783]                 }
[10:25:49.783]             }
[10:25:49.783]         }
[10:25:49.783]     })
[10:25:49.783]     if (TRUE) {
[10:25:49.783]         base::sink(type = "output", split = FALSE)
[10:25:49.783]         if (TRUE) {
[10:25:49.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.783]         }
[10:25:49.783]         else {
[10:25:49.783]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.783]         }
[10:25:49.783]         base::close(...future.stdout)
[10:25:49.783]         ...future.stdout <- NULL
[10:25:49.783]     }
[10:25:49.783]     ...future.result$conditions <- ...future.conditions
[10:25:49.783]     ...future.result$finished <- base::Sys.time()
[10:25:49.783]     ...future.result
[10:25:49.783] }
[10:25:49.786] MultisessionFuture started
[10:25:49.786] - Launch lazy future ... done
[10:25:49.786] run() for ‘MultisessionFuture’ ... done
[10:25:49.786] getGlobalsAndPackages() ...
[10:25:49.786] Searching for globals...
[10:25:49.787] 
[10:25:49.787] Searching for globals ... DONE
[10:25:49.787] - globals: [0] <none>
[10:25:49.787] getGlobalsAndPackages() ... DONE
[10:25:49.787] run() for ‘Future’ ...
[10:25:49.787] - state: ‘created’
[10:25:49.787] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.801] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.801]   - Field: ‘node’
[10:25:49.801]   - Field: ‘label’
[10:25:49.801]   - Field: ‘local’
[10:25:49.801]   - Field: ‘owner’
[10:25:49.802]   - Field: ‘envir’
[10:25:49.802]   - Field: ‘workers’
[10:25:49.802]   - Field: ‘packages’
[10:25:49.802]   - Field: ‘gc’
[10:25:49.802]   - Field: ‘conditions’
[10:25:49.802]   - Field: ‘persistent’
[10:25:49.802]   - Field: ‘expr’
[10:25:49.802]   - Field: ‘uuid’
[10:25:49.802]   - Field: ‘seed’
[10:25:49.802]   - Field: ‘version’
[10:25:49.802]   - Field: ‘result’
[10:25:49.803]   - Field: ‘asynchronous’
[10:25:49.803]   - Field: ‘calls’
[10:25:49.803]   - Field: ‘globals’
[10:25:49.803]   - Field: ‘stdout’
[10:25:49.803]   - Field: ‘earlySignal’
[10:25:49.803]   - Field: ‘lazy’
[10:25:49.803]   - Field: ‘state’
[10:25:49.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.803] - Launch lazy future ...
[10:25:49.803] Packages needed by the future expression (n = 0): <none>
[10:25:49.804] Packages needed by future strategies (n = 0): <none>
[10:25:49.804] {
[10:25:49.804]     {
[10:25:49.804]         {
[10:25:49.804]             ...future.startTime <- base::Sys.time()
[10:25:49.804]             {
[10:25:49.804]                 {
[10:25:49.804]                   {
[10:25:49.804]                     {
[10:25:49.804]                       base::local({
[10:25:49.804]                         has_future <- base::requireNamespace("future", 
[10:25:49.804]                           quietly = TRUE)
[10:25:49.804]                         if (has_future) {
[10:25:49.804]                           ns <- base::getNamespace("future")
[10:25:49.804]                           version <- ns[[".package"]][["version"]]
[10:25:49.804]                           if (is.null(version)) 
[10:25:49.804]                             version <- utils::packageVersion("future")
[10:25:49.804]                         }
[10:25:49.804]                         else {
[10:25:49.804]                           version <- NULL
[10:25:49.804]                         }
[10:25:49.804]                         if (!has_future || version < "1.8.0") {
[10:25:49.804]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.804]                             "", base::R.version$version.string), 
[10:25:49.804]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.804]                               "release", "version")], collapse = " "), 
[10:25:49.804]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.804]                             info)
[10:25:49.804]                           info <- base::paste(info, collapse = "; ")
[10:25:49.804]                           if (!has_future) {
[10:25:49.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.804]                               info)
[10:25:49.804]                           }
[10:25:49.804]                           else {
[10:25:49.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.804]                               info, version)
[10:25:49.804]                           }
[10:25:49.804]                           base::stop(msg)
[10:25:49.804]                         }
[10:25:49.804]                       })
[10:25:49.804]                     }
[10:25:49.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.804]                     base::options(mc.cores = 1L)
[10:25:49.804]                   }
[10:25:49.804]                   options(future.plan = NULL)
[10:25:49.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.804]                 }
[10:25:49.804]                 ...future.workdir <- getwd()
[10:25:49.804]             }
[10:25:49.804]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.804]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.804]         }
[10:25:49.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.804]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.804]             base::names(...future.oldOptions))
[10:25:49.804]     }
[10:25:49.804]     if (FALSE) {
[10:25:49.804]     }
[10:25:49.804]     else {
[10:25:49.804]         if (TRUE) {
[10:25:49.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.804]                 open = "w")
[10:25:49.804]         }
[10:25:49.804]         else {
[10:25:49.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.804]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.804]         }
[10:25:49.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.804]             base::sink(type = "output", split = FALSE)
[10:25:49.804]             base::close(...future.stdout)
[10:25:49.804]         }, add = TRUE)
[10:25:49.804]     }
[10:25:49.804]     ...future.frame <- base::sys.nframe()
[10:25:49.804]     ...future.conditions <- base::list()
[10:25:49.804]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.804]     if (FALSE) {
[10:25:49.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.804]     }
[10:25:49.804]     ...future.result <- base::tryCatch({
[10:25:49.804]         base::withCallingHandlers({
[10:25:49.804]             ...future.value <- base::withVisible(base::local({
[10:25:49.804]                 ...future.makeSendCondition <- base::local({
[10:25:49.804]                   sendCondition <- NULL
[10:25:49.804]                   function(frame = 1L) {
[10:25:49.804]                     if (is.function(sendCondition)) 
[10:25:49.804]                       return(sendCondition)
[10:25:49.804]                     ns <- getNamespace("parallel")
[10:25:49.804]                     if (exists("sendData", mode = "function", 
[10:25:49.804]                       envir = ns)) {
[10:25:49.804]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.804]                         envir = ns)
[10:25:49.804]                       envir <- sys.frame(frame)
[10:25:49.804]                       master <- NULL
[10:25:49.804]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.804]                         !identical(envir, emptyenv())) {
[10:25:49.804]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.804]                           inherits = FALSE)) {
[10:25:49.804]                           master <- get("master", mode = "list", 
[10:25:49.804]                             envir = envir, inherits = FALSE)
[10:25:49.804]                           if (inherits(master, c("SOCKnode", 
[10:25:49.804]                             "SOCK0node"))) {
[10:25:49.804]                             sendCondition <<- function(cond) {
[10:25:49.804]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.804]                                 success = TRUE)
[10:25:49.804]                               parallel_sendData(master, data)
[10:25:49.804]                             }
[10:25:49.804]                             return(sendCondition)
[10:25:49.804]                           }
[10:25:49.804]                         }
[10:25:49.804]                         frame <- frame + 1L
[10:25:49.804]                         envir <- sys.frame(frame)
[10:25:49.804]                       }
[10:25:49.804]                     }
[10:25:49.804]                     sendCondition <<- function(cond) NULL
[10:25:49.804]                   }
[10:25:49.804]                 })
[10:25:49.804]                 withCallingHandlers({
[10:25:49.804]                   NULL
[10:25:49.804]                 }, immediateCondition = function(cond) {
[10:25:49.804]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.804]                   sendCondition(cond)
[10:25:49.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.804]                   {
[10:25:49.804]                     inherits <- base::inherits
[10:25:49.804]                     invokeRestart <- base::invokeRestart
[10:25:49.804]                     is.null <- base::is.null
[10:25:49.804]                     muffled <- FALSE
[10:25:49.804]                     if (inherits(cond, "message")) {
[10:25:49.804]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.804]                       if (muffled) 
[10:25:49.804]                         invokeRestart("muffleMessage")
[10:25:49.804]                     }
[10:25:49.804]                     else if (inherits(cond, "warning")) {
[10:25:49.804]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.804]                       if (muffled) 
[10:25:49.804]                         invokeRestart("muffleWarning")
[10:25:49.804]                     }
[10:25:49.804]                     else if (inherits(cond, "condition")) {
[10:25:49.804]                       if (!is.null(pattern)) {
[10:25:49.804]                         computeRestarts <- base::computeRestarts
[10:25:49.804]                         grepl <- base::grepl
[10:25:49.804]                         restarts <- computeRestarts(cond)
[10:25:49.804]                         for (restart in restarts) {
[10:25:49.804]                           name <- restart$name
[10:25:49.804]                           if (is.null(name)) 
[10:25:49.804]                             next
[10:25:49.804]                           if (!grepl(pattern, name)) 
[10:25:49.804]                             next
[10:25:49.804]                           invokeRestart(restart)
[10:25:49.804]                           muffled <- TRUE
[10:25:49.804]                           break
[10:25:49.804]                         }
[10:25:49.804]                       }
[10:25:49.804]                     }
[10:25:49.804]                     invisible(muffled)
[10:25:49.804]                   }
[10:25:49.804]                   muffleCondition(cond)
[10:25:49.804]                 })
[10:25:49.804]             }))
[10:25:49.804]             future::FutureResult(value = ...future.value$value, 
[10:25:49.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.804]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.804]                     ...future.globalenv.names))
[10:25:49.804]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.804]         }, condition = base::local({
[10:25:49.804]             c <- base::c
[10:25:49.804]             inherits <- base::inherits
[10:25:49.804]             invokeRestart <- base::invokeRestart
[10:25:49.804]             length <- base::length
[10:25:49.804]             list <- base::list
[10:25:49.804]             seq.int <- base::seq.int
[10:25:49.804]             signalCondition <- base::signalCondition
[10:25:49.804]             sys.calls <- base::sys.calls
[10:25:49.804]             `[[` <- base::`[[`
[10:25:49.804]             `+` <- base::`+`
[10:25:49.804]             `<<-` <- base::`<<-`
[10:25:49.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.804]                   3L)]
[10:25:49.804]             }
[10:25:49.804]             function(cond) {
[10:25:49.804]                 is_error <- inherits(cond, "error")
[10:25:49.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.804]                   NULL)
[10:25:49.804]                 if (is_error) {
[10:25:49.804]                   sessionInformation <- function() {
[10:25:49.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.804]                       search = base::search(), system = base::Sys.info())
[10:25:49.804]                   }
[10:25:49.804]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.804]                     cond$call), session = sessionInformation(), 
[10:25:49.804]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.804]                   signalCondition(cond)
[10:25:49.804]                 }
[10:25:49.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.804]                 "immediateCondition"))) {
[10:25:49.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.804]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.804]                   if (TRUE && !signal) {
[10:25:49.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.804]                     {
[10:25:49.804]                       inherits <- base::inherits
[10:25:49.804]                       invokeRestart <- base::invokeRestart
[10:25:49.804]                       is.null <- base::is.null
[10:25:49.804]                       muffled <- FALSE
[10:25:49.804]                       if (inherits(cond, "message")) {
[10:25:49.804]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.804]                         if (muffled) 
[10:25:49.804]                           invokeRestart("muffleMessage")
[10:25:49.804]                       }
[10:25:49.804]                       else if (inherits(cond, "warning")) {
[10:25:49.804]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.804]                         if (muffled) 
[10:25:49.804]                           invokeRestart("muffleWarning")
[10:25:49.804]                       }
[10:25:49.804]                       else if (inherits(cond, "condition")) {
[10:25:49.804]                         if (!is.null(pattern)) {
[10:25:49.804]                           computeRestarts <- base::computeRestarts
[10:25:49.804]                           grepl <- base::grepl
[10:25:49.804]                           restarts <- computeRestarts(cond)
[10:25:49.804]                           for (restart in restarts) {
[10:25:49.804]                             name <- restart$name
[10:25:49.804]                             if (is.null(name)) 
[10:25:49.804]                               next
[10:25:49.804]                             if (!grepl(pattern, name)) 
[10:25:49.804]                               next
[10:25:49.804]                             invokeRestart(restart)
[10:25:49.804]                             muffled <- TRUE
[10:25:49.804]                             break
[10:25:49.804]                           }
[10:25:49.804]                         }
[10:25:49.804]                       }
[10:25:49.804]                       invisible(muffled)
[10:25:49.804]                     }
[10:25:49.804]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.804]                   }
[10:25:49.804]                 }
[10:25:49.804]                 else {
[10:25:49.804]                   if (TRUE) {
[10:25:49.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.804]                     {
[10:25:49.804]                       inherits <- base::inherits
[10:25:49.804]                       invokeRestart <- base::invokeRestart
[10:25:49.804]                       is.null <- base::is.null
[10:25:49.804]                       muffled <- FALSE
[10:25:49.804]                       if (inherits(cond, "message")) {
[10:25:49.804]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.804]                         if (muffled) 
[10:25:49.804]                           invokeRestart("muffleMessage")
[10:25:49.804]                       }
[10:25:49.804]                       else if (inherits(cond, "warning")) {
[10:25:49.804]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.804]                         if (muffled) 
[10:25:49.804]                           invokeRestart("muffleWarning")
[10:25:49.804]                       }
[10:25:49.804]                       else if (inherits(cond, "condition")) {
[10:25:49.804]                         if (!is.null(pattern)) {
[10:25:49.804]                           computeRestarts <- base::computeRestarts
[10:25:49.804]                           grepl <- base::grepl
[10:25:49.804]                           restarts <- computeRestarts(cond)
[10:25:49.804]                           for (restart in restarts) {
[10:25:49.804]                             name <- restart$name
[10:25:49.804]                             if (is.null(name)) 
[10:25:49.804]                               next
[10:25:49.804]                             if (!grepl(pattern, name)) 
[10:25:49.804]                               next
[10:25:49.804]                             invokeRestart(restart)
[10:25:49.804]                             muffled <- TRUE
[10:25:49.804]                             break
[10:25:49.804]                           }
[10:25:49.804]                         }
[10:25:49.804]                       }
[10:25:49.804]                       invisible(muffled)
[10:25:49.804]                     }
[10:25:49.804]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.804]                   }
[10:25:49.804]                 }
[10:25:49.804]             }
[10:25:49.804]         }))
[10:25:49.804]     }, error = function(ex) {
[10:25:49.804]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.804]                 ...future.rng), started = ...future.startTime, 
[10:25:49.804]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.804]             version = "1.8"), class = "FutureResult")
[10:25:49.804]     }, finally = {
[10:25:49.804]         if (!identical(...future.workdir, getwd())) 
[10:25:49.804]             setwd(...future.workdir)
[10:25:49.804]         {
[10:25:49.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.804]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.804]             }
[10:25:49.804]             base::options(...future.oldOptions)
[10:25:49.804]             if (.Platform$OS.type == "windows") {
[10:25:49.804]                 old_names <- names(...future.oldEnvVars)
[10:25:49.804]                 envs <- base::Sys.getenv()
[10:25:49.804]                 names <- names(envs)
[10:25:49.804]                 common <- intersect(names, old_names)
[10:25:49.804]                 added <- setdiff(names, old_names)
[10:25:49.804]                 removed <- setdiff(old_names, names)
[10:25:49.804]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.804]                   envs[common]]
[10:25:49.804]                 NAMES <- toupper(changed)
[10:25:49.804]                 args <- list()
[10:25:49.804]                 for (kk in seq_along(NAMES)) {
[10:25:49.804]                   name <- changed[[kk]]
[10:25:49.804]                   NAME <- NAMES[[kk]]
[10:25:49.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.804]                     next
[10:25:49.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.804]                 }
[10:25:49.804]                 NAMES <- toupper(added)
[10:25:49.804]                 for (kk in seq_along(NAMES)) {
[10:25:49.804]                   name <- added[[kk]]
[10:25:49.804]                   NAME <- NAMES[[kk]]
[10:25:49.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.804]                     next
[10:25:49.804]                   args[[name]] <- ""
[10:25:49.804]                 }
[10:25:49.804]                 NAMES <- toupper(removed)
[10:25:49.804]                 for (kk in seq_along(NAMES)) {
[10:25:49.804]                   name <- removed[[kk]]
[10:25:49.804]                   NAME <- NAMES[[kk]]
[10:25:49.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.804]                     next
[10:25:49.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.804]                 }
[10:25:49.804]                 if (length(args) > 0) 
[10:25:49.804]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.804]             }
[10:25:49.804]             else {
[10:25:49.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.804]             }
[10:25:49.804]             {
[10:25:49.804]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.804]                   0L) {
[10:25:49.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.804]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.804]                   base::options(opts)
[10:25:49.804]                 }
[10:25:49.804]                 {
[10:25:49.804]                   {
[10:25:49.804]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.804]                     NULL
[10:25:49.804]                   }
[10:25:49.804]                   options(future.plan = NULL)
[10:25:49.804]                   if (is.na(NA_character_)) 
[10:25:49.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.804]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.804]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.804]                     envir = parent.frame()) 
[10:25:49.804]                   {
[10:25:49.804]                     if (is.function(workers)) 
[10:25:49.804]                       workers <- workers()
[10:25:49.804]                     workers <- structure(as.integer(workers), 
[10:25:49.804]                       class = class(workers))
[10:25:49.804]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.804]                       workers >= 1)
[10:25:49.804]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.804]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.804]                     }
[10:25:49.804]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.804]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.804]                       envir = envir)
[10:25:49.804]                     if (!future$lazy) 
[10:25:49.804]                       future <- run(future)
[10:25:49.804]                     invisible(future)
[10:25:49.804]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.804]                 }
[10:25:49.804]             }
[10:25:49.804]         }
[10:25:49.804]     })
[10:25:49.804]     if (TRUE) {
[10:25:49.804]         base::sink(type = "output", split = FALSE)
[10:25:49.804]         if (TRUE) {
[10:25:49.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.804]         }
[10:25:49.804]         else {
[10:25:49.804]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.804]         }
[10:25:49.804]         base::close(...future.stdout)
[10:25:49.804]         ...future.stdout <- NULL
[10:25:49.804]     }
[10:25:49.804]     ...future.result$conditions <- ...future.conditions
[10:25:49.804]     ...future.result$finished <- base::Sys.time()
[10:25:49.804]     ...future.result
[10:25:49.804] }
[10:25:49.807] MultisessionFuture started
[10:25:49.807] - Launch lazy future ... done
[10:25:49.807] run() for ‘MultisessionFuture’ ... done
[10:25:49.808] getGlobalsAndPackages() ...
[10:25:49.808] Searching for globals...
[10:25:49.808] - globals found: [1] ‘{’
[10:25:49.808] Searching for globals ... DONE
[10:25:49.808] Resolving globals: FALSE
[10:25:49.809] 
[10:25:49.809] 
[10:25:49.809] getGlobalsAndPackages() ... DONE
[10:25:49.809] run() for ‘Future’ ...
[10:25:49.809] - state: ‘created’
[10:25:49.809] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.823] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:49.823]   - Field: ‘node’
[10:25:49.823]   - Field: ‘label’
[10:25:49.823]   - Field: ‘local’
[10:25:49.823]   - Field: ‘owner’
[10:25:49.823]   - Field: ‘envir’
[10:25:49.824]   - Field: ‘workers’
[10:25:49.824]   - Field: ‘packages’
[10:25:49.824]   - Field: ‘gc’
[10:25:49.824]   - Field: ‘conditions’
[10:25:49.824]   - Field: ‘persistent’
[10:25:49.824]   - Field: ‘expr’
[10:25:49.824]   - Field: ‘uuid’
[10:25:49.824]   - Field: ‘seed’
[10:25:49.824]   - Field: ‘version’
[10:25:49.824]   - Field: ‘result’
[10:25:49.824]   - Field: ‘asynchronous’
[10:25:49.825]   - Field: ‘calls’
[10:25:49.825]   - Field: ‘globals’
[10:25:49.825]   - Field: ‘stdout’
[10:25:49.825]   - Field: ‘earlySignal’
[10:25:49.825]   - Field: ‘lazy’
[10:25:49.825]   - Field: ‘state’
[10:25:49.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:49.825] - Launch lazy future ...
[10:25:49.825] Packages needed by the future expression (n = 0): <none>
[10:25:49.826] Packages needed by future strategies (n = 0): <none>
[10:25:49.826] {
[10:25:49.826]     {
[10:25:49.826]         {
[10:25:49.826]             ...future.startTime <- base::Sys.time()
[10:25:49.826]             {
[10:25:49.826]                 {
[10:25:49.826]                   {
[10:25:49.826]                     {
[10:25:49.826]                       base::local({
[10:25:49.826]                         has_future <- base::requireNamespace("future", 
[10:25:49.826]                           quietly = TRUE)
[10:25:49.826]                         if (has_future) {
[10:25:49.826]                           ns <- base::getNamespace("future")
[10:25:49.826]                           version <- ns[[".package"]][["version"]]
[10:25:49.826]                           if (is.null(version)) 
[10:25:49.826]                             version <- utils::packageVersion("future")
[10:25:49.826]                         }
[10:25:49.826]                         else {
[10:25:49.826]                           version <- NULL
[10:25:49.826]                         }
[10:25:49.826]                         if (!has_future || version < "1.8.0") {
[10:25:49.826]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.826]                             "", base::R.version$version.string), 
[10:25:49.826]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.826]                               "release", "version")], collapse = " "), 
[10:25:49.826]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.826]                             info)
[10:25:49.826]                           info <- base::paste(info, collapse = "; ")
[10:25:49.826]                           if (!has_future) {
[10:25:49.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.826]                               info)
[10:25:49.826]                           }
[10:25:49.826]                           else {
[10:25:49.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.826]                               info, version)
[10:25:49.826]                           }
[10:25:49.826]                           base::stop(msg)
[10:25:49.826]                         }
[10:25:49.826]                       })
[10:25:49.826]                     }
[10:25:49.826]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.826]                     base::options(mc.cores = 1L)
[10:25:49.826]                   }
[10:25:49.826]                   options(future.plan = NULL)
[10:25:49.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.826]                 }
[10:25:49.826]                 ...future.workdir <- getwd()
[10:25:49.826]             }
[10:25:49.826]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.826]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.826]         }
[10:25:49.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.826]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.826]             base::names(...future.oldOptions))
[10:25:49.826]     }
[10:25:49.826]     if (FALSE) {
[10:25:49.826]     }
[10:25:49.826]     else {
[10:25:49.826]         if (TRUE) {
[10:25:49.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.826]                 open = "w")
[10:25:49.826]         }
[10:25:49.826]         else {
[10:25:49.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.826]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.826]         }
[10:25:49.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.826]             base::sink(type = "output", split = FALSE)
[10:25:49.826]             base::close(...future.stdout)
[10:25:49.826]         }, add = TRUE)
[10:25:49.826]     }
[10:25:49.826]     ...future.frame <- base::sys.nframe()
[10:25:49.826]     ...future.conditions <- base::list()
[10:25:49.826]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.826]     if (FALSE) {
[10:25:49.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.826]     }
[10:25:49.826]     ...future.result <- base::tryCatch({
[10:25:49.826]         base::withCallingHandlers({
[10:25:49.826]             ...future.value <- base::withVisible(base::local({
[10:25:49.826]                 ...future.makeSendCondition <- base::local({
[10:25:49.826]                   sendCondition <- NULL
[10:25:49.826]                   function(frame = 1L) {
[10:25:49.826]                     if (is.function(sendCondition)) 
[10:25:49.826]                       return(sendCondition)
[10:25:49.826]                     ns <- getNamespace("parallel")
[10:25:49.826]                     if (exists("sendData", mode = "function", 
[10:25:49.826]                       envir = ns)) {
[10:25:49.826]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:49.826]                         envir = ns)
[10:25:49.826]                       envir <- sys.frame(frame)
[10:25:49.826]                       master <- NULL
[10:25:49.826]                       while (!identical(envir, .GlobalEnv) && 
[10:25:49.826]                         !identical(envir, emptyenv())) {
[10:25:49.826]                         if (exists("master", mode = "list", envir = envir, 
[10:25:49.826]                           inherits = FALSE)) {
[10:25:49.826]                           master <- get("master", mode = "list", 
[10:25:49.826]                             envir = envir, inherits = FALSE)
[10:25:49.826]                           if (inherits(master, c("SOCKnode", 
[10:25:49.826]                             "SOCK0node"))) {
[10:25:49.826]                             sendCondition <<- function(cond) {
[10:25:49.826]                               data <- list(type = "VALUE", value = cond, 
[10:25:49.826]                                 success = TRUE)
[10:25:49.826]                               parallel_sendData(master, data)
[10:25:49.826]                             }
[10:25:49.826]                             return(sendCondition)
[10:25:49.826]                           }
[10:25:49.826]                         }
[10:25:49.826]                         frame <- frame + 1L
[10:25:49.826]                         envir <- sys.frame(frame)
[10:25:49.826]                       }
[10:25:49.826]                     }
[10:25:49.826]                     sendCondition <<- function(cond) NULL
[10:25:49.826]                   }
[10:25:49.826]                 })
[10:25:49.826]                 withCallingHandlers({
[10:25:49.826]                   {
[10:25:49.826]                     4
[10:25:49.826]                   }
[10:25:49.826]                 }, immediateCondition = function(cond) {
[10:25:49.826]                   sendCondition <- ...future.makeSendCondition()
[10:25:49.826]                   sendCondition(cond)
[10:25:49.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.826]                   {
[10:25:49.826]                     inherits <- base::inherits
[10:25:49.826]                     invokeRestart <- base::invokeRestart
[10:25:49.826]                     is.null <- base::is.null
[10:25:49.826]                     muffled <- FALSE
[10:25:49.826]                     if (inherits(cond, "message")) {
[10:25:49.826]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.826]                       if (muffled) 
[10:25:49.826]                         invokeRestart("muffleMessage")
[10:25:49.826]                     }
[10:25:49.826]                     else if (inherits(cond, "warning")) {
[10:25:49.826]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.826]                       if (muffled) 
[10:25:49.826]                         invokeRestart("muffleWarning")
[10:25:49.826]                     }
[10:25:49.826]                     else if (inherits(cond, "condition")) {
[10:25:49.826]                       if (!is.null(pattern)) {
[10:25:49.826]                         computeRestarts <- base::computeRestarts
[10:25:49.826]                         grepl <- base::grepl
[10:25:49.826]                         restarts <- computeRestarts(cond)
[10:25:49.826]                         for (restart in restarts) {
[10:25:49.826]                           name <- restart$name
[10:25:49.826]                           if (is.null(name)) 
[10:25:49.826]                             next
[10:25:49.826]                           if (!grepl(pattern, name)) 
[10:25:49.826]                             next
[10:25:49.826]                           invokeRestart(restart)
[10:25:49.826]                           muffled <- TRUE
[10:25:49.826]                           break
[10:25:49.826]                         }
[10:25:49.826]                       }
[10:25:49.826]                     }
[10:25:49.826]                     invisible(muffled)
[10:25:49.826]                   }
[10:25:49.826]                   muffleCondition(cond)
[10:25:49.826]                 })
[10:25:49.826]             }))
[10:25:49.826]             future::FutureResult(value = ...future.value$value, 
[10:25:49.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.826]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.826]                     ...future.globalenv.names))
[10:25:49.826]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.826]         }, condition = base::local({
[10:25:49.826]             c <- base::c
[10:25:49.826]             inherits <- base::inherits
[10:25:49.826]             invokeRestart <- base::invokeRestart
[10:25:49.826]             length <- base::length
[10:25:49.826]             list <- base::list
[10:25:49.826]             seq.int <- base::seq.int
[10:25:49.826]             signalCondition <- base::signalCondition
[10:25:49.826]             sys.calls <- base::sys.calls
[10:25:49.826]             `[[` <- base::`[[`
[10:25:49.826]             `+` <- base::`+`
[10:25:49.826]             `<<-` <- base::`<<-`
[10:25:49.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.826]                   3L)]
[10:25:49.826]             }
[10:25:49.826]             function(cond) {
[10:25:49.826]                 is_error <- inherits(cond, "error")
[10:25:49.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.826]                   NULL)
[10:25:49.826]                 if (is_error) {
[10:25:49.826]                   sessionInformation <- function() {
[10:25:49.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.826]                       search = base::search(), system = base::Sys.info())
[10:25:49.826]                   }
[10:25:49.826]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.826]                     cond$call), session = sessionInformation(), 
[10:25:49.826]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.826]                   signalCondition(cond)
[10:25:49.826]                 }
[10:25:49.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.826]                 "immediateCondition"))) {
[10:25:49.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.826]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.826]                   if (TRUE && !signal) {
[10:25:49.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.826]                     {
[10:25:49.826]                       inherits <- base::inherits
[10:25:49.826]                       invokeRestart <- base::invokeRestart
[10:25:49.826]                       is.null <- base::is.null
[10:25:49.826]                       muffled <- FALSE
[10:25:49.826]                       if (inherits(cond, "message")) {
[10:25:49.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.826]                         if (muffled) 
[10:25:49.826]                           invokeRestart("muffleMessage")
[10:25:49.826]                       }
[10:25:49.826]                       else if (inherits(cond, "warning")) {
[10:25:49.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.826]                         if (muffled) 
[10:25:49.826]                           invokeRestart("muffleWarning")
[10:25:49.826]                       }
[10:25:49.826]                       else if (inherits(cond, "condition")) {
[10:25:49.826]                         if (!is.null(pattern)) {
[10:25:49.826]                           computeRestarts <- base::computeRestarts
[10:25:49.826]                           grepl <- base::grepl
[10:25:49.826]                           restarts <- computeRestarts(cond)
[10:25:49.826]                           for (restart in restarts) {
[10:25:49.826]                             name <- restart$name
[10:25:49.826]                             if (is.null(name)) 
[10:25:49.826]                               next
[10:25:49.826]                             if (!grepl(pattern, name)) 
[10:25:49.826]                               next
[10:25:49.826]                             invokeRestart(restart)
[10:25:49.826]                             muffled <- TRUE
[10:25:49.826]                             break
[10:25:49.826]                           }
[10:25:49.826]                         }
[10:25:49.826]                       }
[10:25:49.826]                       invisible(muffled)
[10:25:49.826]                     }
[10:25:49.826]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.826]                   }
[10:25:49.826]                 }
[10:25:49.826]                 else {
[10:25:49.826]                   if (TRUE) {
[10:25:49.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.826]                     {
[10:25:49.826]                       inherits <- base::inherits
[10:25:49.826]                       invokeRestart <- base::invokeRestart
[10:25:49.826]                       is.null <- base::is.null
[10:25:49.826]                       muffled <- FALSE
[10:25:49.826]                       if (inherits(cond, "message")) {
[10:25:49.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.826]                         if (muffled) 
[10:25:49.826]                           invokeRestart("muffleMessage")
[10:25:49.826]                       }
[10:25:49.826]                       else if (inherits(cond, "warning")) {
[10:25:49.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.826]                         if (muffled) 
[10:25:49.826]                           invokeRestart("muffleWarning")
[10:25:49.826]                       }
[10:25:49.826]                       else if (inherits(cond, "condition")) {
[10:25:49.826]                         if (!is.null(pattern)) {
[10:25:49.826]                           computeRestarts <- base::computeRestarts
[10:25:49.826]                           grepl <- base::grepl
[10:25:49.826]                           restarts <- computeRestarts(cond)
[10:25:49.826]                           for (restart in restarts) {
[10:25:49.826]                             name <- restart$name
[10:25:49.826]                             if (is.null(name)) 
[10:25:49.826]                               next
[10:25:49.826]                             if (!grepl(pattern, name)) 
[10:25:49.826]                               next
[10:25:49.826]                             invokeRestart(restart)
[10:25:49.826]                             muffled <- TRUE
[10:25:49.826]                             break
[10:25:49.826]                           }
[10:25:49.826]                         }
[10:25:49.826]                       }
[10:25:49.826]                       invisible(muffled)
[10:25:49.826]                     }
[10:25:49.826]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.826]                   }
[10:25:49.826]                 }
[10:25:49.826]             }
[10:25:49.826]         }))
[10:25:49.826]     }, error = function(ex) {
[10:25:49.826]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.826]                 ...future.rng), started = ...future.startTime, 
[10:25:49.826]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.826]             version = "1.8"), class = "FutureResult")
[10:25:49.826]     }, finally = {
[10:25:49.826]         if (!identical(...future.workdir, getwd())) 
[10:25:49.826]             setwd(...future.workdir)
[10:25:49.826]         {
[10:25:49.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.826]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.826]             }
[10:25:49.826]             base::options(...future.oldOptions)
[10:25:49.826]             if (.Platform$OS.type == "windows") {
[10:25:49.826]                 old_names <- names(...future.oldEnvVars)
[10:25:49.826]                 envs <- base::Sys.getenv()
[10:25:49.826]                 names <- names(envs)
[10:25:49.826]                 common <- intersect(names, old_names)
[10:25:49.826]                 added <- setdiff(names, old_names)
[10:25:49.826]                 removed <- setdiff(old_names, names)
[10:25:49.826]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.826]                   envs[common]]
[10:25:49.826]                 NAMES <- toupper(changed)
[10:25:49.826]                 args <- list()
[10:25:49.826]                 for (kk in seq_along(NAMES)) {
[10:25:49.826]                   name <- changed[[kk]]
[10:25:49.826]                   NAME <- NAMES[[kk]]
[10:25:49.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.826]                     next
[10:25:49.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.826]                 }
[10:25:49.826]                 NAMES <- toupper(added)
[10:25:49.826]                 for (kk in seq_along(NAMES)) {
[10:25:49.826]                   name <- added[[kk]]
[10:25:49.826]                   NAME <- NAMES[[kk]]
[10:25:49.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.826]                     next
[10:25:49.826]                   args[[name]] <- ""
[10:25:49.826]                 }
[10:25:49.826]                 NAMES <- toupper(removed)
[10:25:49.826]                 for (kk in seq_along(NAMES)) {
[10:25:49.826]                   name <- removed[[kk]]
[10:25:49.826]                   NAME <- NAMES[[kk]]
[10:25:49.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.826]                     next
[10:25:49.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.826]                 }
[10:25:49.826]                 if (length(args) > 0) 
[10:25:49.826]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.826]             }
[10:25:49.826]             else {
[10:25:49.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.826]             }
[10:25:49.826]             {
[10:25:49.826]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.826]                   0L) {
[10:25:49.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.826]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.826]                   base::options(opts)
[10:25:49.826]                 }
[10:25:49.826]                 {
[10:25:49.826]                   {
[10:25:49.826]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.826]                     NULL
[10:25:49.826]                   }
[10:25:49.826]                   options(future.plan = NULL)
[10:25:49.826]                   if (is.na(NA_character_)) 
[10:25:49.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.826]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:49.826]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:49.826]                     envir = parent.frame()) 
[10:25:49.826]                   {
[10:25:49.826]                     if (is.function(workers)) 
[10:25:49.826]                       workers <- workers()
[10:25:49.826]                     workers <- structure(as.integer(workers), 
[10:25:49.826]                       class = class(workers))
[10:25:49.826]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:49.826]                       workers >= 1)
[10:25:49.826]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:49.826]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:49.826]                     }
[10:25:49.826]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:49.826]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:49.826]                       envir = envir)
[10:25:49.826]                     if (!future$lazy) 
[10:25:49.826]                       future <- run(future)
[10:25:49.826]                     invisible(future)
[10:25:49.826]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.826]                 }
[10:25:49.826]             }
[10:25:49.826]         }
[10:25:49.826]     })
[10:25:49.826]     if (TRUE) {
[10:25:49.826]         base::sink(type = "output", split = FALSE)
[10:25:49.826]         if (TRUE) {
[10:25:49.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.826]         }
[10:25:49.826]         else {
[10:25:49.826]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.826]         }
[10:25:49.826]         base::close(...future.stdout)
[10:25:49.826]         ...future.stdout <- NULL
[10:25:49.826]     }
[10:25:49.826]     ...future.result$conditions <- ...future.conditions
[10:25:49.826]     ...future.result$finished <- base::Sys.time()
[10:25:49.826]     ...future.result
[10:25:49.826] }
[10:25:49.828] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:49.839] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.839] - Validating connection of MultisessionFuture
[10:25:49.839] - received message: FutureResult
[10:25:49.839] - Received FutureResult
[10:25:49.839] - Erased future from FutureRegistry
[10:25:49.840] result() for ClusterFuture ...
[10:25:49.840] - result already collected: FutureResult
[10:25:49.840] result() for ClusterFuture ... done
[10:25:49.840] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.840] result() for ClusterFuture ...
[10:25:49.840] - result already collected: FutureResult
[10:25:49.840] result() for ClusterFuture ... done
[10:25:49.840] result() for ClusterFuture ...
[10:25:49.840] - result already collected: FutureResult
[10:25:49.840] result() for ClusterFuture ... done
[10:25:49.841] MultisessionFuture started
[10:25:49.842] - Launch lazy future ... done
[10:25:49.842] run() for ‘MultisessionFuture’ ... done
<environment: 0x55c0f59b4478> 
<environment: 0x55c0f5bf4190> 
 Named logi [1:4] TRUE TRUE FALSE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:25:49.865] resolve() on environment ...
[10:25:49.865]  recursive: 0
[10:25:49.866]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:25:49.866] signalConditionsASAP(numeric, pos=1) ...
[10:25:49.866] - nx: 4
[10:25:49.866] - relay: TRUE
[10:25:49.866] - stdout: TRUE
[10:25:49.866] - signal: TRUE
[10:25:49.866] - resignal: FALSE
[10:25:49.866] - force: TRUE
[10:25:49.866] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.867] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.867]  - until=2
[10:25:49.867]  - relaying element #2
[10:25:49.867] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.867] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.867] signalConditionsASAP(NULL, pos=1) ... done
[10:25:49.867]  length: 3 (resolved future 1)
[10:25:49.867] Future #2
[10:25:49.867] result() for ClusterFuture ...
[10:25:49.867] - result already collected: FutureResult
[10:25:49.867] result() for ClusterFuture ... done
[10:25:49.868] result() for ClusterFuture ...
[10:25:49.868] - result already collected: FutureResult
[10:25:49.868] result() for ClusterFuture ... done
[10:25:49.868] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:49.868] - nx: 4
[10:25:49.868] - relay: TRUE
[10:25:49.868] - stdout: TRUE
[10:25:49.868] - signal: TRUE
[10:25:49.868] - resignal: FALSE
[10:25:49.868] - force: TRUE
[10:25:49.868] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:25:49.869] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:25:49.869]  - until=2
[10:25:49.869]  - relaying element #2
[10:25:49.869] result() for ClusterFuture ...
[10:25:49.869] - result already collected: FutureResult
[10:25:49.869] result() for ClusterFuture ... done
[10:25:49.869] result() for ClusterFuture ...
[10:25:49.869] - result already collected: FutureResult
[10:25:49.869] result() for ClusterFuture ... done
[10:25:49.870] result() for ClusterFuture ...
[10:25:49.870] - result already collected: FutureResult
[10:25:49.870] result() for ClusterFuture ... done
[10:25:49.870] result() for ClusterFuture ...
[10:25:49.870] - result already collected: FutureResult
[10:25:49.870] result() for ClusterFuture ... done
[10:25:49.870] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.870] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.870] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:49.870]  length: 2 (resolved future 2)
[10:25:49.871] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.871] - Validating connection of MultisessionFuture
[10:25:49.871] - received message: FutureResult
[10:25:49.871] - Received FutureResult
[10:25:49.871] - Erased future from FutureRegistry
[10:25:49.871] result() for ClusterFuture ...
[10:25:49.871] - result already collected: FutureResult
[10:25:49.872] result() for ClusterFuture ... done
[10:25:49.872] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.872] Future #3
[10:25:49.872] result() for ClusterFuture ...
[10:25:49.872] - result already collected: FutureResult
[10:25:49.872] result() for ClusterFuture ... done
[10:25:49.872] result() for ClusterFuture ...
[10:25:49.872] - result already collected: FutureResult
[10:25:49.872] result() for ClusterFuture ... done
[10:25:49.872] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:49.872] - nx: 4
[10:25:49.872] - relay: TRUE
[10:25:49.873] - stdout: TRUE
[10:25:49.873] - signal: TRUE
[10:25:49.873] - resignal: FALSE
[10:25:49.873] - force: TRUE
[10:25:49.873] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:25:49.873] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:25:49.873]  - until=3
[10:25:49.873]  - relaying element #3
[10:25:49.873] result() for ClusterFuture ...
[10:25:49.873] - result already collected: FutureResult
[10:25:49.873] result() for ClusterFuture ... done
[10:25:49.874] result() for ClusterFuture ...
[10:25:49.874] - result already collected: FutureResult
[10:25:49.874] result() for ClusterFuture ... done
[10:25:49.874] result() for ClusterFuture ...
[10:25:49.874] - result already collected: FutureResult
[10:25:49.874] result() for ClusterFuture ... done
[10:25:49.874] result() for ClusterFuture ...
[10:25:49.874] - result already collected: FutureResult
[10:25:49.874] result() for ClusterFuture ... done
[10:25:49.874] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.874] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.875] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:49.875]  length: 1 (resolved future 3)
[10:25:49.896] receiveMessageFromWorker() for ClusterFuture ...
[10:25:49.896] - Validating connection of MultisessionFuture
[10:25:49.896] - received message: FutureResult
[10:25:49.896] - Received FutureResult
[10:25:49.896] - Erased future from FutureRegistry
[10:25:49.896] result() for ClusterFuture ...
[10:25:49.896] - result already collected: FutureResult
[10:25:49.896] result() for ClusterFuture ... done
[10:25:49.897] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:49.897] Future #4
[10:25:49.897] result() for ClusterFuture ...
[10:25:49.897] - result already collected: FutureResult
[10:25:49.897] result() for ClusterFuture ... done
[10:25:49.897] result() for ClusterFuture ...
[10:25:49.897] - result already collected: FutureResult
[10:25:49.897] result() for ClusterFuture ... done
[10:25:49.897] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:49.897] - nx: 4
[10:25:49.898] - relay: TRUE
[10:25:49.898] - stdout: TRUE
[10:25:49.898] - signal: TRUE
[10:25:49.898] - resignal: FALSE
[10:25:49.898] - force: TRUE
[10:25:49.898] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:25:49.898] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:25:49.898]  - until=4
[10:25:49.898]  - relaying element #4
[10:25:49.898] result() for ClusterFuture ...
[10:25:49.898] - result already collected: FutureResult
[10:25:49.898] result() for ClusterFuture ... done
[10:25:49.899] result() for ClusterFuture ...
[10:25:49.899] - result already collected: FutureResult
[10:25:49.899] result() for ClusterFuture ... done
[10:25:49.899] result() for ClusterFuture ...
[10:25:49.899] - result already collected: FutureResult
[10:25:49.899] result() for ClusterFuture ... done
[10:25:49.899] result() for ClusterFuture ...
[10:25:49.899] - result already collected: FutureResult
[10:25:49.899] result() for ClusterFuture ... done
[10:25:49.899] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.899] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.900] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:49.900]  length: 0 (resolved future 4)
[10:25:49.900] Relaying remaining futures
[10:25:49.900] signalConditionsASAP(NULL, pos=0) ...
[10:25:49.900] - nx: 4
[10:25:49.900] - relay: TRUE
[10:25:49.900] - stdout: TRUE
[10:25:49.900] - signal: TRUE
[10:25:49.900] - resignal: FALSE
[10:25:49.900] - force: TRUE
[10:25:49.900] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.900] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:25:49.901] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:25:49.901] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:25:49.901] signalConditionsASAP(NULL, pos=0) ... done
[10:25:49.901] resolve() on environment ... DONE
[10:25:49.901] result() for ClusterFuture ...
[10:25:49.901] - result already collected: FutureResult
[10:25:49.901] result() for ClusterFuture ... done
[10:25:49.901] result() for ClusterFuture ...
[10:25:49.901] - result already collected: FutureResult
[10:25:49.901] result() for ClusterFuture ... done
[10:25:49.902] result() for ClusterFuture ...
[10:25:49.902] - result already collected: FutureResult
[10:25:49.902] result() for ClusterFuture ... done
[10:25:49.902] result() for ClusterFuture ...
[10:25:49.902] - result already collected: FutureResult
[10:25:49.902] result() for ClusterFuture ... done
[10:25:49.902] result() for ClusterFuture ...
[10:25:49.902] - result already collected: FutureResult
[10:25:49.902] result() for ClusterFuture ... done
[10:25:49.902] result() for ClusterFuture ...
[10:25:49.902] - result already collected: FutureResult
[10:25:49.903] result() for ClusterFuture ... done
<environment: 0x55c0f603bee8> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[10:25:49.903] plan(): Setting new future strategy stack:
[10:25:49.903] List of future strategies:
[10:25:49.903] 1. multicore:
[10:25:49.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:49.903]    - tweaked: FALSE
[10:25:49.903]    - call: plan(strategy)
[10:25:49.908] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:25:49.908] getGlobalsAndPackages() ...
[10:25:49.908] Searching for globals...
[10:25:49.909] 
[10:25:49.909] Searching for globals ... DONE
[10:25:49.909] - globals: [0] <none>
[10:25:49.909] getGlobalsAndPackages() ... DONE
[10:25:49.909] run() for ‘Future’ ...
[10:25:49.909] - state: ‘created’
[10:25:49.909] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.913] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:49.913]   - Field: ‘label’
[10:25:49.913]   - Field: ‘local’
[10:25:49.913]   - Field: ‘owner’
[10:25:49.913]   - Field: ‘envir’
[10:25:49.913]   - Field: ‘workers’
[10:25:49.914]   - Field: ‘packages’
[10:25:49.914]   - Field: ‘gc’
[10:25:49.914]   - Field: ‘job’
[10:25:49.914]   - Field: ‘conditions’
[10:25:49.914]   - Field: ‘expr’
[10:25:49.914]   - Field: ‘uuid’
[10:25:49.914]   - Field: ‘seed’
[10:25:49.914]   - Field: ‘version’
[10:25:49.914]   - Field: ‘result’
[10:25:49.914]   - Field: ‘asynchronous’
[10:25:49.915]   - Field: ‘calls’
[10:25:49.915]   - Field: ‘globals’
[10:25:49.915]   - Field: ‘stdout’
[10:25:49.915]   - Field: ‘earlySignal’
[10:25:49.915]   - Field: ‘lazy’
[10:25:49.915]   - Field: ‘state’
[10:25:49.915] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:49.915] - Launch lazy future ...
[10:25:49.915] Packages needed by the future expression (n = 0): <none>
[10:25:49.916] Packages needed by future strategies (n = 0): <none>
[10:25:49.916] {
[10:25:49.916]     {
[10:25:49.916]         {
[10:25:49.916]             ...future.startTime <- base::Sys.time()
[10:25:49.916]             {
[10:25:49.916]                 {
[10:25:49.916]                   {
[10:25:49.916]                     {
[10:25:49.916]                       base::local({
[10:25:49.916]                         has_future <- base::requireNamespace("future", 
[10:25:49.916]                           quietly = TRUE)
[10:25:49.916]                         if (has_future) {
[10:25:49.916]                           ns <- base::getNamespace("future")
[10:25:49.916]                           version <- ns[[".package"]][["version"]]
[10:25:49.916]                           if (is.null(version)) 
[10:25:49.916]                             version <- utils::packageVersion("future")
[10:25:49.916]                         }
[10:25:49.916]                         else {
[10:25:49.916]                           version <- NULL
[10:25:49.916]                         }
[10:25:49.916]                         if (!has_future || version < "1.8.0") {
[10:25:49.916]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.916]                             "", base::R.version$version.string), 
[10:25:49.916]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.916]                               "release", "version")], collapse = " "), 
[10:25:49.916]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.916]                             info)
[10:25:49.916]                           info <- base::paste(info, collapse = "; ")
[10:25:49.916]                           if (!has_future) {
[10:25:49.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.916]                               info)
[10:25:49.916]                           }
[10:25:49.916]                           else {
[10:25:49.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.916]                               info, version)
[10:25:49.916]                           }
[10:25:49.916]                           base::stop(msg)
[10:25:49.916]                         }
[10:25:49.916]                       })
[10:25:49.916]                     }
[10:25:49.916]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.916]                     base::options(mc.cores = 1L)
[10:25:49.916]                   }
[10:25:49.916]                   options(future.plan = NULL)
[10:25:49.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.916]                 }
[10:25:49.916]                 ...future.workdir <- getwd()
[10:25:49.916]             }
[10:25:49.916]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.916]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.916]         }
[10:25:49.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.916]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.916]             base::names(...future.oldOptions))
[10:25:49.916]     }
[10:25:49.916]     if (FALSE) {
[10:25:49.916]     }
[10:25:49.916]     else {
[10:25:49.916]         if (TRUE) {
[10:25:49.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.916]                 open = "w")
[10:25:49.916]         }
[10:25:49.916]         else {
[10:25:49.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.916]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.916]         }
[10:25:49.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.916]             base::sink(type = "output", split = FALSE)
[10:25:49.916]             base::close(...future.stdout)
[10:25:49.916]         }, add = TRUE)
[10:25:49.916]     }
[10:25:49.916]     ...future.frame <- base::sys.nframe()
[10:25:49.916]     ...future.conditions <- base::list()
[10:25:49.916]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.916]     if (FALSE) {
[10:25:49.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.916]     }
[10:25:49.916]     ...future.result <- base::tryCatch({
[10:25:49.916]         base::withCallingHandlers({
[10:25:49.916]             ...future.value <- base::withVisible(base::local({
[10:25:49.916]                 withCallingHandlers({
[10:25:49.916]                   2
[10:25:49.916]                 }, immediateCondition = function(cond) {
[10:25:49.916]                   save_rds <- function (object, pathname, ...) 
[10:25:49.916]                   {
[10:25:49.916]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:49.916]                     if (file_test("-f", pathname_tmp)) {
[10:25:49.916]                       fi_tmp <- file.info(pathname_tmp)
[10:25:49.916]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:49.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:49.916]                         fi_tmp[["mtime"]])
[10:25:49.916]                     }
[10:25:49.916]                     tryCatch({
[10:25:49.916]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:49.916]                     }, error = function(ex) {
[10:25:49.916]                       msg <- conditionMessage(ex)
[10:25:49.916]                       fi_tmp <- file.info(pathname_tmp)
[10:25:49.916]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:49.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:49.916]                         fi_tmp[["mtime"]], msg)
[10:25:49.916]                       ex$message <- msg
[10:25:49.916]                       stop(ex)
[10:25:49.916]                     })
[10:25:49.916]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:49.916]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:49.916]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:49.916]                       fi_tmp <- file.info(pathname_tmp)
[10:25:49.916]                       fi <- file.info(pathname)
[10:25:49.916]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:49.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:49.916]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:49.916]                         fi[["size"]], fi[["mtime"]])
[10:25:49.916]                       stop(msg)
[10:25:49.916]                     }
[10:25:49.916]                     invisible(pathname)
[10:25:49.916]                   }
[10:25:49.916]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:49.916]                     rootPath = tempdir()) 
[10:25:49.916]                   {
[10:25:49.916]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:49.916]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:49.916]                       tmpdir = path, fileext = ".rds")
[10:25:49.916]                     save_rds(obj, file)
[10:25:49.916]                   }
[10:25:49.916]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:49.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.916]                   {
[10:25:49.916]                     inherits <- base::inherits
[10:25:49.916]                     invokeRestart <- base::invokeRestart
[10:25:49.916]                     is.null <- base::is.null
[10:25:49.916]                     muffled <- FALSE
[10:25:49.916]                     if (inherits(cond, "message")) {
[10:25:49.916]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.916]                       if (muffled) 
[10:25:49.916]                         invokeRestart("muffleMessage")
[10:25:49.916]                     }
[10:25:49.916]                     else if (inherits(cond, "warning")) {
[10:25:49.916]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.916]                       if (muffled) 
[10:25:49.916]                         invokeRestart("muffleWarning")
[10:25:49.916]                     }
[10:25:49.916]                     else if (inherits(cond, "condition")) {
[10:25:49.916]                       if (!is.null(pattern)) {
[10:25:49.916]                         computeRestarts <- base::computeRestarts
[10:25:49.916]                         grepl <- base::grepl
[10:25:49.916]                         restarts <- computeRestarts(cond)
[10:25:49.916]                         for (restart in restarts) {
[10:25:49.916]                           name <- restart$name
[10:25:49.916]                           if (is.null(name)) 
[10:25:49.916]                             next
[10:25:49.916]                           if (!grepl(pattern, name)) 
[10:25:49.916]                             next
[10:25:49.916]                           invokeRestart(restart)
[10:25:49.916]                           muffled <- TRUE
[10:25:49.916]                           break
[10:25:49.916]                         }
[10:25:49.916]                       }
[10:25:49.916]                     }
[10:25:49.916]                     invisible(muffled)
[10:25:49.916]                   }
[10:25:49.916]                   muffleCondition(cond)
[10:25:49.916]                 })
[10:25:49.916]             }))
[10:25:49.916]             future::FutureResult(value = ...future.value$value, 
[10:25:49.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.916]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.916]                     ...future.globalenv.names))
[10:25:49.916]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.916]         }, condition = base::local({
[10:25:49.916]             c <- base::c
[10:25:49.916]             inherits <- base::inherits
[10:25:49.916]             invokeRestart <- base::invokeRestart
[10:25:49.916]             length <- base::length
[10:25:49.916]             list <- base::list
[10:25:49.916]             seq.int <- base::seq.int
[10:25:49.916]             signalCondition <- base::signalCondition
[10:25:49.916]             sys.calls <- base::sys.calls
[10:25:49.916]             `[[` <- base::`[[`
[10:25:49.916]             `+` <- base::`+`
[10:25:49.916]             `<<-` <- base::`<<-`
[10:25:49.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.916]                   3L)]
[10:25:49.916]             }
[10:25:49.916]             function(cond) {
[10:25:49.916]                 is_error <- inherits(cond, "error")
[10:25:49.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.916]                   NULL)
[10:25:49.916]                 if (is_error) {
[10:25:49.916]                   sessionInformation <- function() {
[10:25:49.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.916]                       search = base::search(), system = base::Sys.info())
[10:25:49.916]                   }
[10:25:49.916]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.916]                     cond$call), session = sessionInformation(), 
[10:25:49.916]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.916]                   signalCondition(cond)
[10:25:49.916]                 }
[10:25:49.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.916]                 "immediateCondition"))) {
[10:25:49.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.916]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.916]                   if (TRUE && !signal) {
[10:25:49.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.916]                     {
[10:25:49.916]                       inherits <- base::inherits
[10:25:49.916]                       invokeRestart <- base::invokeRestart
[10:25:49.916]                       is.null <- base::is.null
[10:25:49.916]                       muffled <- FALSE
[10:25:49.916]                       if (inherits(cond, "message")) {
[10:25:49.916]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.916]                         if (muffled) 
[10:25:49.916]                           invokeRestart("muffleMessage")
[10:25:49.916]                       }
[10:25:49.916]                       else if (inherits(cond, "warning")) {
[10:25:49.916]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.916]                         if (muffled) 
[10:25:49.916]                           invokeRestart("muffleWarning")
[10:25:49.916]                       }
[10:25:49.916]                       else if (inherits(cond, "condition")) {
[10:25:49.916]                         if (!is.null(pattern)) {
[10:25:49.916]                           computeRestarts <- base::computeRestarts
[10:25:49.916]                           grepl <- base::grepl
[10:25:49.916]                           restarts <- computeRestarts(cond)
[10:25:49.916]                           for (restart in restarts) {
[10:25:49.916]                             name <- restart$name
[10:25:49.916]                             if (is.null(name)) 
[10:25:49.916]                               next
[10:25:49.916]                             if (!grepl(pattern, name)) 
[10:25:49.916]                               next
[10:25:49.916]                             invokeRestart(restart)
[10:25:49.916]                             muffled <- TRUE
[10:25:49.916]                             break
[10:25:49.916]                           }
[10:25:49.916]                         }
[10:25:49.916]                       }
[10:25:49.916]                       invisible(muffled)
[10:25:49.916]                     }
[10:25:49.916]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.916]                   }
[10:25:49.916]                 }
[10:25:49.916]                 else {
[10:25:49.916]                   if (TRUE) {
[10:25:49.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.916]                     {
[10:25:49.916]                       inherits <- base::inherits
[10:25:49.916]                       invokeRestart <- base::invokeRestart
[10:25:49.916]                       is.null <- base::is.null
[10:25:49.916]                       muffled <- FALSE
[10:25:49.916]                       if (inherits(cond, "message")) {
[10:25:49.916]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.916]                         if (muffled) 
[10:25:49.916]                           invokeRestart("muffleMessage")
[10:25:49.916]                       }
[10:25:49.916]                       else if (inherits(cond, "warning")) {
[10:25:49.916]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.916]                         if (muffled) 
[10:25:49.916]                           invokeRestart("muffleWarning")
[10:25:49.916]                       }
[10:25:49.916]                       else if (inherits(cond, "condition")) {
[10:25:49.916]                         if (!is.null(pattern)) {
[10:25:49.916]                           computeRestarts <- base::computeRestarts
[10:25:49.916]                           grepl <- base::grepl
[10:25:49.916]                           restarts <- computeRestarts(cond)
[10:25:49.916]                           for (restart in restarts) {
[10:25:49.916]                             name <- restart$name
[10:25:49.916]                             if (is.null(name)) 
[10:25:49.916]                               next
[10:25:49.916]                             if (!grepl(pattern, name)) 
[10:25:49.916]                               next
[10:25:49.916]                             invokeRestart(restart)
[10:25:49.916]                             muffled <- TRUE
[10:25:49.916]                             break
[10:25:49.916]                           }
[10:25:49.916]                         }
[10:25:49.916]                       }
[10:25:49.916]                       invisible(muffled)
[10:25:49.916]                     }
[10:25:49.916]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.916]                   }
[10:25:49.916]                 }
[10:25:49.916]             }
[10:25:49.916]         }))
[10:25:49.916]     }, error = function(ex) {
[10:25:49.916]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.916]                 ...future.rng), started = ...future.startTime, 
[10:25:49.916]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.916]             version = "1.8"), class = "FutureResult")
[10:25:49.916]     }, finally = {
[10:25:49.916]         if (!identical(...future.workdir, getwd())) 
[10:25:49.916]             setwd(...future.workdir)
[10:25:49.916]         {
[10:25:49.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.916]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.916]             }
[10:25:49.916]             base::options(...future.oldOptions)
[10:25:49.916]             if (.Platform$OS.type == "windows") {
[10:25:49.916]                 old_names <- names(...future.oldEnvVars)
[10:25:49.916]                 envs <- base::Sys.getenv()
[10:25:49.916]                 names <- names(envs)
[10:25:49.916]                 common <- intersect(names, old_names)
[10:25:49.916]                 added <- setdiff(names, old_names)
[10:25:49.916]                 removed <- setdiff(old_names, names)
[10:25:49.916]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.916]                   envs[common]]
[10:25:49.916]                 NAMES <- toupper(changed)
[10:25:49.916]                 args <- list()
[10:25:49.916]                 for (kk in seq_along(NAMES)) {
[10:25:49.916]                   name <- changed[[kk]]
[10:25:49.916]                   NAME <- NAMES[[kk]]
[10:25:49.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.916]                     next
[10:25:49.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.916]                 }
[10:25:49.916]                 NAMES <- toupper(added)
[10:25:49.916]                 for (kk in seq_along(NAMES)) {
[10:25:49.916]                   name <- added[[kk]]
[10:25:49.916]                   NAME <- NAMES[[kk]]
[10:25:49.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.916]                     next
[10:25:49.916]                   args[[name]] <- ""
[10:25:49.916]                 }
[10:25:49.916]                 NAMES <- toupper(removed)
[10:25:49.916]                 for (kk in seq_along(NAMES)) {
[10:25:49.916]                   name <- removed[[kk]]
[10:25:49.916]                   NAME <- NAMES[[kk]]
[10:25:49.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.916]                     next
[10:25:49.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.916]                 }
[10:25:49.916]                 if (length(args) > 0) 
[10:25:49.916]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.916]             }
[10:25:49.916]             else {
[10:25:49.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.916]             }
[10:25:49.916]             {
[10:25:49.916]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.916]                   0L) {
[10:25:49.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.916]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.916]                   base::options(opts)
[10:25:49.916]                 }
[10:25:49.916]                 {
[10:25:49.916]                   {
[10:25:49.916]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.916]                     NULL
[10:25:49.916]                   }
[10:25:49.916]                   options(future.plan = NULL)
[10:25:49.916]                   if (is.na(NA_character_)) 
[10:25:49.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.916]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:49.916]                     envir = parent.frame()) 
[10:25:49.916]                   {
[10:25:49.916]                     default_workers <- missing(workers)
[10:25:49.916]                     if (is.function(workers)) 
[10:25:49.916]                       workers <- workers()
[10:25:49.916]                     workers <- structure(as.integer(workers), 
[10:25:49.916]                       class = class(workers))
[10:25:49.916]                     stop_if_not(is.finite(workers), workers >= 
[10:25:49.916]                       1L)
[10:25:49.916]                     if ((workers == 1L && !inherits(workers, 
[10:25:49.916]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:49.916]                       if (default_workers) 
[10:25:49.916]                         supportsMulticore(warn = TRUE)
[10:25:49.916]                       return(sequential(..., envir = envir))
[10:25:49.916]                     }
[10:25:49.916]                     oopts <- options(mc.cores = workers)
[10:25:49.916]                     on.exit(options(oopts))
[10:25:49.916]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:49.916]                       envir = envir)
[10:25:49.916]                     if (!future$lazy) 
[10:25:49.916]                       future <- run(future)
[10:25:49.916]                     invisible(future)
[10:25:49.916]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.916]                 }
[10:25:49.916]             }
[10:25:49.916]         }
[10:25:49.916]     })
[10:25:49.916]     if (TRUE) {
[10:25:49.916]         base::sink(type = "output", split = FALSE)
[10:25:49.916]         if (TRUE) {
[10:25:49.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.916]         }
[10:25:49.916]         else {
[10:25:49.916]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.916]         }
[10:25:49.916]         base::close(...future.stdout)
[10:25:49.916]         ...future.stdout <- NULL
[10:25:49.916]     }
[10:25:49.916]     ...future.result$conditions <- ...future.conditions
[10:25:49.916]     ...future.result$finished <- base::Sys.time()
[10:25:49.916]     ...future.result
[10:25:49.916] }
[10:25:49.918] requestCore(): workers = 2
[10:25:49.921] MulticoreFuture started
[10:25:49.921] - Launch lazy future ... done
[10:25:49.922] run() for ‘MulticoreFuture’ ... done
[10:25:49.922] getGlobalsAndPackages() ...
[10:25:49.922] Searching for globals...
[10:25:49.922] plan(): Setting new future strategy stack:
[10:25:49.923] 
[10:25:49.923] List of future strategies:
[10:25:49.923] 1. sequential:
[10:25:49.923]    - args: function (..., envir = parent.frame())
[10:25:49.923]    - tweaked: FALSE
[10:25:49.923]    - call: NULL
[10:25:49.923] Searching for globals ... DONE
[10:25:49.923] - globals: [0] <none>
[10:25:49.923] plan(): nbrOfWorkers() = 1
[10:25:49.923] getGlobalsAndPackages() ... DONE
[10:25:49.924] run() for ‘Future’ ...
[10:25:49.924] - state: ‘created’
[10:25:49.924] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.925] plan(): Setting new future strategy stack:
[10:25:49.925] List of future strategies:
[10:25:49.925] 1. multicore:
[10:25:49.925]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:49.925]    - tweaked: FALSE
[10:25:49.925]    - call: plan(strategy)
[10:25:49.930] plan(): nbrOfWorkers() = 2
[10:25:49.930] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.930] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:49.930]   - Field: ‘label’
[10:25:49.930]   - Field: ‘local’
[10:25:49.930]   - Field: ‘owner’
[10:25:49.931]   - Field: ‘envir’
[10:25:49.931]   - Field: ‘workers’
[10:25:49.931]   - Field: ‘packages’
[10:25:49.931]   - Field: ‘gc’
[10:25:49.931]   - Field: ‘job’
[10:25:49.931]   - Field: ‘conditions’
[10:25:49.932]   - Field: ‘expr’
[10:25:49.932]   - Field: ‘uuid’
[10:25:49.932]   - Field: ‘seed’
[10:25:49.932]   - Field: ‘version’
[10:25:49.932]   - Field: ‘result’
[10:25:49.932]   - Field: ‘asynchronous’
[10:25:49.933]   - Field: ‘calls’
[10:25:49.933]   - Field: ‘globals’
[10:25:49.933]   - Field: ‘stdout’
[10:25:49.933]   - Field: ‘earlySignal’
[10:25:49.933]   - Field: ‘lazy’
[10:25:49.933]   - Field: ‘state’
[10:25:49.934] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:49.934] - Launch lazy future ...
[10:25:49.934] Packages needed by the future expression (n = 0): <none>
[10:25:49.935] Packages needed by future strategies (n = 0): <none>
[10:25:49.935] {
[10:25:49.935]     {
[10:25:49.935]         {
[10:25:49.935]             ...future.startTime <- base::Sys.time()
[10:25:49.935]             {
[10:25:49.935]                 {
[10:25:49.935]                   {
[10:25:49.935]                     {
[10:25:49.935]                       base::local({
[10:25:49.935]                         has_future <- base::requireNamespace("future", 
[10:25:49.935]                           quietly = TRUE)
[10:25:49.935]                         if (has_future) {
[10:25:49.935]                           ns <- base::getNamespace("future")
[10:25:49.935]                           version <- ns[[".package"]][["version"]]
[10:25:49.935]                           if (is.null(version)) 
[10:25:49.935]                             version <- utils::packageVersion("future")
[10:25:49.935]                         }
[10:25:49.935]                         else {
[10:25:49.935]                           version <- NULL
[10:25:49.935]                         }
[10:25:49.935]                         if (!has_future || version < "1.8.0") {
[10:25:49.935]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.935]                             "", base::R.version$version.string), 
[10:25:49.935]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.935]                               "release", "version")], collapse = " "), 
[10:25:49.935]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.935]                             info)
[10:25:49.935]                           info <- base::paste(info, collapse = "; ")
[10:25:49.935]                           if (!has_future) {
[10:25:49.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.935]                               info)
[10:25:49.935]                           }
[10:25:49.935]                           else {
[10:25:49.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.935]                               info, version)
[10:25:49.935]                           }
[10:25:49.935]                           base::stop(msg)
[10:25:49.935]                         }
[10:25:49.935]                       })
[10:25:49.935]                     }
[10:25:49.935]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.935]                     base::options(mc.cores = 1L)
[10:25:49.935]                   }
[10:25:49.935]                   options(future.plan = NULL)
[10:25:49.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.935]                 }
[10:25:49.935]                 ...future.workdir <- getwd()
[10:25:49.935]             }
[10:25:49.935]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.935]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.935]         }
[10:25:49.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.935]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.935]             base::names(...future.oldOptions))
[10:25:49.935]     }
[10:25:49.935]     if (FALSE) {
[10:25:49.935]     }
[10:25:49.935]     else {
[10:25:49.935]         if (TRUE) {
[10:25:49.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.935]                 open = "w")
[10:25:49.935]         }
[10:25:49.935]         else {
[10:25:49.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.935]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.935]         }
[10:25:49.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.935]             base::sink(type = "output", split = FALSE)
[10:25:49.935]             base::close(...future.stdout)
[10:25:49.935]         }, add = TRUE)
[10:25:49.935]     }
[10:25:49.935]     ...future.frame <- base::sys.nframe()
[10:25:49.935]     ...future.conditions <- base::list()
[10:25:49.935]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.935]     if (FALSE) {
[10:25:49.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.935]     }
[10:25:49.935]     ...future.result <- base::tryCatch({
[10:25:49.935]         base::withCallingHandlers({
[10:25:49.935]             ...future.value <- base::withVisible(base::local({
[10:25:49.935]                 withCallingHandlers({
[10:25:49.935]                   NULL
[10:25:49.935]                 }, immediateCondition = function(cond) {
[10:25:49.935]                   save_rds <- function (object, pathname, ...) 
[10:25:49.935]                   {
[10:25:49.935]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:49.935]                     if (file_test("-f", pathname_tmp)) {
[10:25:49.935]                       fi_tmp <- file.info(pathname_tmp)
[10:25:49.935]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:49.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:49.935]                         fi_tmp[["mtime"]])
[10:25:49.935]                     }
[10:25:49.935]                     tryCatch({
[10:25:49.935]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:49.935]                     }, error = function(ex) {
[10:25:49.935]                       msg <- conditionMessage(ex)
[10:25:49.935]                       fi_tmp <- file.info(pathname_tmp)
[10:25:49.935]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:49.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:49.935]                         fi_tmp[["mtime"]], msg)
[10:25:49.935]                       ex$message <- msg
[10:25:49.935]                       stop(ex)
[10:25:49.935]                     })
[10:25:49.935]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:49.935]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:49.935]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:49.935]                       fi_tmp <- file.info(pathname_tmp)
[10:25:49.935]                       fi <- file.info(pathname)
[10:25:49.935]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:49.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:49.935]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:49.935]                         fi[["size"]], fi[["mtime"]])
[10:25:49.935]                       stop(msg)
[10:25:49.935]                     }
[10:25:49.935]                     invisible(pathname)
[10:25:49.935]                   }
[10:25:49.935]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:49.935]                     rootPath = tempdir()) 
[10:25:49.935]                   {
[10:25:49.935]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:49.935]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:49.935]                       tmpdir = path, fileext = ".rds")
[10:25:49.935]                     save_rds(obj, file)
[10:25:49.935]                   }
[10:25:49.935]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:49.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.935]                   {
[10:25:49.935]                     inherits <- base::inherits
[10:25:49.935]                     invokeRestart <- base::invokeRestart
[10:25:49.935]                     is.null <- base::is.null
[10:25:49.935]                     muffled <- FALSE
[10:25:49.935]                     if (inherits(cond, "message")) {
[10:25:49.935]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.935]                       if (muffled) 
[10:25:49.935]                         invokeRestart("muffleMessage")
[10:25:49.935]                     }
[10:25:49.935]                     else if (inherits(cond, "warning")) {
[10:25:49.935]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.935]                       if (muffled) 
[10:25:49.935]                         invokeRestart("muffleWarning")
[10:25:49.935]                     }
[10:25:49.935]                     else if (inherits(cond, "condition")) {
[10:25:49.935]                       if (!is.null(pattern)) {
[10:25:49.935]                         computeRestarts <- base::computeRestarts
[10:25:49.935]                         grepl <- base::grepl
[10:25:49.935]                         restarts <- computeRestarts(cond)
[10:25:49.935]                         for (restart in restarts) {
[10:25:49.935]                           name <- restart$name
[10:25:49.935]                           if (is.null(name)) 
[10:25:49.935]                             next
[10:25:49.935]                           if (!grepl(pattern, name)) 
[10:25:49.935]                             next
[10:25:49.935]                           invokeRestart(restart)
[10:25:49.935]                           muffled <- TRUE
[10:25:49.935]                           break
[10:25:49.935]                         }
[10:25:49.935]                       }
[10:25:49.935]                     }
[10:25:49.935]                     invisible(muffled)
[10:25:49.935]                   }
[10:25:49.935]                   muffleCondition(cond)
[10:25:49.935]                 })
[10:25:49.935]             }))
[10:25:49.935]             future::FutureResult(value = ...future.value$value, 
[10:25:49.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.935]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.935]                     ...future.globalenv.names))
[10:25:49.935]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.935]         }, condition = base::local({
[10:25:49.935]             c <- base::c
[10:25:49.935]             inherits <- base::inherits
[10:25:49.935]             invokeRestart <- base::invokeRestart
[10:25:49.935]             length <- base::length
[10:25:49.935]             list <- base::list
[10:25:49.935]             seq.int <- base::seq.int
[10:25:49.935]             signalCondition <- base::signalCondition
[10:25:49.935]             sys.calls <- base::sys.calls
[10:25:49.935]             `[[` <- base::`[[`
[10:25:49.935]             `+` <- base::`+`
[10:25:49.935]             `<<-` <- base::`<<-`
[10:25:49.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.935]                   3L)]
[10:25:49.935]             }
[10:25:49.935]             function(cond) {
[10:25:49.935]                 is_error <- inherits(cond, "error")
[10:25:49.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.935]                   NULL)
[10:25:49.935]                 if (is_error) {
[10:25:49.935]                   sessionInformation <- function() {
[10:25:49.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.935]                       search = base::search(), system = base::Sys.info())
[10:25:49.935]                   }
[10:25:49.935]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.935]                     cond$call), session = sessionInformation(), 
[10:25:49.935]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.935]                   signalCondition(cond)
[10:25:49.935]                 }
[10:25:49.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.935]                 "immediateCondition"))) {
[10:25:49.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.935]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.935]                   if (TRUE && !signal) {
[10:25:49.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.935]                     {
[10:25:49.935]                       inherits <- base::inherits
[10:25:49.935]                       invokeRestart <- base::invokeRestart
[10:25:49.935]                       is.null <- base::is.null
[10:25:49.935]                       muffled <- FALSE
[10:25:49.935]                       if (inherits(cond, "message")) {
[10:25:49.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.935]                         if (muffled) 
[10:25:49.935]                           invokeRestart("muffleMessage")
[10:25:49.935]                       }
[10:25:49.935]                       else if (inherits(cond, "warning")) {
[10:25:49.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.935]                         if (muffled) 
[10:25:49.935]                           invokeRestart("muffleWarning")
[10:25:49.935]                       }
[10:25:49.935]                       else if (inherits(cond, "condition")) {
[10:25:49.935]                         if (!is.null(pattern)) {
[10:25:49.935]                           computeRestarts <- base::computeRestarts
[10:25:49.935]                           grepl <- base::grepl
[10:25:49.935]                           restarts <- computeRestarts(cond)
[10:25:49.935]                           for (restart in restarts) {
[10:25:49.935]                             name <- restart$name
[10:25:49.935]                             if (is.null(name)) 
[10:25:49.935]                               next
[10:25:49.935]                             if (!grepl(pattern, name)) 
[10:25:49.935]                               next
[10:25:49.935]                             invokeRestart(restart)
[10:25:49.935]                             muffled <- TRUE
[10:25:49.935]                             break
[10:25:49.935]                           }
[10:25:49.935]                         }
[10:25:49.935]                       }
[10:25:49.935]                       invisible(muffled)
[10:25:49.935]                     }
[10:25:49.935]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.935]                   }
[10:25:49.935]                 }
[10:25:49.935]                 else {
[10:25:49.935]                   if (TRUE) {
[10:25:49.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.935]                     {
[10:25:49.935]                       inherits <- base::inherits
[10:25:49.935]                       invokeRestart <- base::invokeRestart
[10:25:49.935]                       is.null <- base::is.null
[10:25:49.935]                       muffled <- FALSE
[10:25:49.935]                       if (inherits(cond, "message")) {
[10:25:49.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.935]                         if (muffled) 
[10:25:49.935]                           invokeRestart("muffleMessage")
[10:25:49.935]                       }
[10:25:49.935]                       else if (inherits(cond, "warning")) {
[10:25:49.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.935]                         if (muffled) 
[10:25:49.935]                           invokeRestart("muffleWarning")
[10:25:49.935]                       }
[10:25:49.935]                       else if (inherits(cond, "condition")) {
[10:25:49.935]                         if (!is.null(pattern)) {
[10:25:49.935]                           computeRestarts <- base::computeRestarts
[10:25:49.935]                           grepl <- base::grepl
[10:25:49.935]                           restarts <- computeRestarts(cond)
[10:25:49.935]                           for (restart in restarts) {
[10:25:49.935]                             name <- restart$name
[10:25:49.935]                             if (is.null(name)) 
[10:25:49.935]                               next
[10:25:49.935]                             if (!grepl(pattern, name)) 
[10:25:49.935]                               next
[10:25:49.935]                             invokeRestart(restart)
[10:25:49.935]                             muffled <- TRUE
[10:25:49.935]                             break
[10:25:49.935]                           }
[10:25:49.935]                         }
[10:25:49.935]                       }
[10:25:49.935]                       invisible(muffled)
[10:25:49.935]                     }
[10:25:49.935]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.935]                   }
[10:25:49.935]                 }
[10:25:49.935]             }
[10:25:49.935]         }))
[10:25:49.935]     }, error = function(ex) {
[10:25:49.935]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.935]                 ...future.rng), started = ...future.startTime, 
[10:25:49.935]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.935]             version = "1.8"), class = "FutureResult")
[10:25:49.935]     }, finally = {
[10:25:49.935]         if (!identical(...future.workdir, getwd())) 
[10:25:49.935]             setwd(...future.workdir)
[10:25:49.935]         {
[10:25:49.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.935]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.935]             }
[10:25:49.935]             base::options(...future.oldOptions)
[10:25:49.935]             if (.Platform$OS.type == "windows") {
[10:25:49.935]                 old_names <- names(...future.oldEnvVars)
[10:25:49.935]                 envs <- base::Sys.getenv()
[10:25:49.935]                 names <- names(envs)
[10:25:49.935]                 common <- intersect(names, old_names)
[10:25:49.935]                 added <- setdiff(names, old_names)
[10:25:49.935]                 removed <- setdiff(old_names, names)
[10:25:49.935]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.935]                   envs[common]]
[10:25:49.935]                 NAMES <- toupper(changed)
[10:25:49.935]                 args <- list()
[10:25:49.935]                 for (kk in seq_along(NAMES)) {
[10:25:49.935]                   name <- changed[[kk]]
[10:25:49.935]                   NAME <- NAMES[[kk]]
[10:25:49.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.935]                     next
[10:25:49.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.935]                 }
[10:25:49.935]                 NAMES <- toupper(added)
[10:25:49.935]                 for (kk in seq_along(NAMES)) {
[10:25:49.935]                   name <- added[[kk]]
[10:25:49.935]                   NAME <- NAMES[[kk]]
[10:25:49.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.935]                     next
[10:25:49.935]                   args[[name]] <- ""
[10:25:49.935]                 }
[10:25:49.935]                 NAMES <- toupper(removed)
[10:25:49.935]                 for (kk in seq_along(NAMES)) {
[10:25:49.935]                   name <- removed[[kk]]
[10:25:49.935]                   NAME <- NAMES[[kk]]
[10:25:49.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.935]                     next
[10:25:49.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.935]                 }
[10:25:49.935]                 if (length(args) > 0) 
[10:25:49.935]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.935]             }
[10:25:49.935]             else {
[10:25:49.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.935]             }
[10:25:49.935]             {
[10:25:49.935]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.935]                   0L) {
[10:25:49.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.935]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.935]                   base::options(opts)
[10:25:49.935]                 }
[10:25:49.935]                 {
[10:25:49.935]                   {
[10:25:49.935]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.935]                     NULL
[10:25:49.935]                   }
[10:25:49.935]                   options(future.plan = NULL)
[10:25:49.935]                   if (is.na(NA_character_)) 
[10:25:49.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.935]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:49.935]                     envir = parent.frame()) 
[10:25:49.935]                   {
[10:25:49.935]                     default_workers <- missing(workers)
[10:25:49.935]                     if (is.function(workers)) 
[10:25:49.935]                       workers <- workers()
[10:25:49.935]                     workers <- structure(as.integer(workers), 
[10:25:49.935]                       class = class(workers))
[10:25:49.935]                     stop_if_not(is.finite(workers), workers >= 
[10:25:49.935]                       1L)
[10:25:49.935]                     if ((workers == 1L && !inherits(workers, 
[10:25:49.935]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:49.935]                       if (default_workers) 
[10:25:49.935]                         supportsMulticore(warn = TRUE)
[10:25:49.935]                       return(sequential(..., envir = envir))
[10:25:49.935]                     }
[10:25:49.935]                     oopts <- options(mc.cores = workers)
[10:25:49.935]                     on.exit(options(oopts))
[10:25:49.935]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:49.935]                       envir = envir)
[10:25:49.935]                     if (!future$lazy) 
[10:25:49.935]                       future <- run(future)
[10:25:49.935]                     invisible(future)
[10:25:49.935]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.935]                 }
[10:25:49.935]             }
[10:25:49.935]         }
[10:25:49.935]     })
[10:25:49.935]     if (TRUE) {
[10:25:49.935]         base::sink(type = "output", split = FALSE)
[10:25:49.935]         if (TRUE) {
[10:25:49.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.935]         }
[10:25:49.935]         else {
[10:25:49.935]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.935]         }
[10:25:49.935]         base::close(...future.stdout)
[10:25:49.935]         ...future.stdout <- NULL
[10:25:49.935]     }
[10:25:49.935]     ...future.result$conditions <- ...future.conditions
[10:25:49.935]     ...future.result$finished <- base::Sys.time()
[10:25:49.935]     ...future.result
[10:25:49.935] }
[10:25:49.939] requestCore(): workers = 2
[10:25:49.942] MulticoreFuture started
[10:25:49.942] - Launch lazy future ... done
[10:25:49.942] run() for ‘MulticoreFuture’ ... done
[10:25:49.943] plan(): Setting new future strategy stack:
[10:25:49.943] getGlobalsAndPackages() ...
[10:25:49.943] Searching for globals...
[10:25:49.943] List of future strategies:
[10:25:49.943] 1. sequential:
[10:25:49.943]    - args: function (..., envir = parent.frame())
[10:25:49.943]    - tweaked: FALSE
[10:25:49.943]    - call: NULL
[10:25:49.944] plan(): nbrOfWorkers() = 1
[10:25:49.944] - globals found: [1] ‘{’
[10:25:49.945] Searching for globals ... DONE
[10:25:49.945] Resolving globals: FALSE
[10:25:49.946] plan(): Setting new future strategy stack:
[10:25:49.946] List of future strategies:
[10:25:49.946] 1. multicore:
[10:25:49.946]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:49.946]    - tweaked: FALSE
[10:25:49.946]    - call: plan(strategy)
[10:25:49.954] 
[10:25:49.954] 
[10:25:49.955] getGlobalsAndPackages() ... DONE
[10:25:49.956] run() for ‘Future’ ...
[10:25:49.956] - state: ‘created’
[10:25:49.957] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:49.959] plan(): nbrOfWorkers() = 2
[10:25:49.962] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:49.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:49.962]   - Field: ‘label’
[10:25:49.963]   - Field: ‘local’
[10:25:49.963]   - Field: ‘owner’
[10:25:49.963]   - Field: ‘envir’
[10:25:49.963]   - Field: ‘workers’
[10:25:49.963]   - Field: ‘packages’
[10:25:49.963]   - Field: ‘gc’
[10:25:49.963]   - Field: ‘job’
[10:25:49.964]   - Field: ‘conditions’
[10:25:49.964]   - Field: ‘expr’
[10:25:49.964]   - Field: ‘uuid’
[10:25:49.964]   - Field: ‘seed’
[10:25:49.964]   - Field: ‘version’
[10:25:49.964]   - Field: ‘result’
[10:25:49.964]   - Field: ‘asynchronous’
[10:25:49.965]   - Field: ‘calls’
[10:25:49.965]   - Field: ‘globals’
[10:25:49.965]   - Field: ‘stdout’
[10:25:49.965]   - Field: ‘earlySignal’
[10:25:49.965]   - Field: ‘lazy’
[10:25:49.965]   - Field: ‘state’
[10:25:49.966] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:49.966] - Launch lazy future ...
[10:25:49.966] Packages needed by the future expression (n = 0): <none>
[10:25:49.966] Packages needed by future strategies (n = 0): <none>
[10:25:49.967] {
[10:25:49.967]     {
[10:25:49.967]         {
[10:25:49.967]             ...future.startTime <- base::Sys.time()
[10:25:49.967]             {
[10:25:49.967]                 {
[10:25:49.967]                   {
[10:25:49.967]                     {
[10:25:49.967]                       base::local({
[10:25:49.967]                         has_future <- base::requireNamespace("future", 
[10:25:49.967]                           quietly = TRUE)
[10:25:49.967]                         if (has_future) {
[10:25:49.967]                           ns <- base::getNamespace("future")
[10:25:49.967]                           version <- ns[[".package"]][["version"]]
[10:25:49.967]                           if (is.null(version)) 
[10:25:49.967]                             version <- utils::packageVersion("future")
[10:25:49.967]                         }
[10:25:49.967]                         else {
[10:25:49.967]                           version <- NULL
[10:25:49.967]                         }
[10:25:49.967]                         if (!has_future || version < "1.8.0") {
[10:25:49.967]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:49.967]                             "", base::R.version$version.string), 
[10:25:49.967]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:49.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:49.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:49.967]                               "release", "version")], collapse = " "), 
[10:25:49.967]                             hostname = base::Sys.info()[["nodename"]])
[10:25:49.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:49.967]                             info)
[10:25:49.967]                           info <- base::paste(info, collapse = "; ")
[10:25:49.967]                           if (!has_future) {
[10:25:49.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:49.967]                               info)
[10:25:49.967]                           }
[10:25:49.967]                           else {
[10:25:49.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:49.967]                               info, version)
[10:25:49.967]                           }
[10:25:49.967]                           base::stop(msg)
[10:25:49.967]                         }
[10:25:49.967]                       })
[10:25:49.967]                     }
[10:25:49.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:49.967]                     base::options(mc.cores = 1L)
[10:25:49.967]                   }
[10:25:49.967]                   options(future.plan = NULL)
[10:25:49.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:49.967]                 }
[10:25:49.967]                 ...future.workdir <- getwd()
[10:25:49.967]             }
[10:25:49.967]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:49.967]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:49.967]         }
[10:25:49.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:49.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:49.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:49.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:49.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:49.967]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:49.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:49.967]             base::names(...future.oldOptions))
[10:25:49.967]     }
[10:25:49.967]     if (FALSE) {
[10:25:49.967]     }
[10:25:49.967]     else {
[10:25:49.967]         if (TRUE) {
[10:25:49.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:49.967]                 open = "w")
[10:25:49.967]         }
[10:25:49.967]         else {
[10:25:49.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:49.967]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:49.967]         }
[10:25:49.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:49.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:49.967]             base::sink(type = "output", split = FALSE)
[10:25:49.967]             base::close(...future.stdout)
[10:25:49.967]         }, add = TRUE)
[10:25:49.967]     }
[10:25:49.967]     ...future.frame <- base::sys.nframe()
[10:25:49.967]     ...future.conditions <- base::list()
[10:25:49.967]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:49.967]     if (FALSE) {
[10:25:49.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:49.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:49.967]     }
[10:25:49.967]     ...future.result <- base::tryCatch({
[10:25:49.967]         base::withCallingHandlers({
[10:25:49.967]             ...future.value <- base::withVisible(base::local({
[10:25:49.967]                 withCallingHandlers({
[10:25:49.967]                   {
[10:25:49.967]                     4
[10:25:49.967]                   }
[10:25:49.967]                 }, immediateCondition = function(cond) {
[10:25:49.967]                   save_rds <- function (object, pathname, ...) 
[10:25:49.967]                   {
[10:25:49.967]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:49.967]                     if (file_test("-f", pathname_tmp)) {
[10:25:49.967]                       fi_tmp <- file.info(pathname_tmp)
[10:25:49.967]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:49.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:49.967]                         fi_tmp[["mtime"]])
[10:25:49.967]                     }
[10:25:49.967]                     tryCatch({
[10:25:49.967]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:49.967]                     }, error = function(ex) {
[10:25:49.967]                       msg <- conditionMessage(ex)
[10:25:49.967]                       fi_tmp <- file.info(pathname_tmp)
[10:25:49.967]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:49.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:49.967]                         fi_tmp[["mtime"]], msg)
[10:25:49.967]                       ex$message <- msg
[10:25:49.967]                       stop(ex)
[10:25:49.967]                     })
[10:25:49.967]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:49.967]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:49.967]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:49.967]                       fi_tmp <- file.info(pathname_tmp)
[10:25:49.967]                       fi <- file.info(pathname)
[10:25:49.967]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:49.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:49.967]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:49.967]                         fi[["size"]], fi[["mtime"]])
[10:25:49.967]                       stop(msg)
[10:25:49.967]                     }
[10:25:49.967]                     invisible(pathname)
[10:25:49.967]                   }
[10:25:49.967]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:49.967]                     rootPath = tempdir()) 
[10:25:49.967]                   {
[10:25:49.967]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:49.967]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:49.967]                       tmpdir = path, fileext = ".rds")
[10:25:49.967]                     save_rds(obj, file)
[10:25:49.967]                   }
[10:25:49.967]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:49.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.967]                   {
[10:25:49.967]                     inherits <- base::inherits
[10:25:49.967]                     invokeRestart <- base::invokeRestart
[10:25:49.967]                     is.null <- base::is.null
[10:25:49.967]                     muffled <- FALSE
[10:25:49.967]                     if (inherits(cond, "message")) {
[10:25:49.967]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:49.967]                       if (muffled) 
[10:25:49.967]                         invokeRestart("muffleMessage")
[10:25:49.967]                     }
[10:25:49.967]                     else if (inherits(cond, "warning")) {
[10:25:49.967]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:49.967]                       if (muffled) 
[10:25:49.967]                         invokeRestart("muffleWarning")
[10:25:49.967]                     }
[10:25:49.967]                     else if (inherits(cond, "condition")) {
[10:25:49.967]                       if (!is.null(pattern)) {
[10:25:49.967]                         computeRestarts <- base::computeRestarts
[10:25:49.967]                         grepl <- base::grepl
[10:25:49.967]                         restarts <- computeRestarts(cond)
[10:25:49.967]                         for (restart in restarts) {
[10:25:49.967]                           name <- restart$name
[10:25:49.967]                           if (is.null(name)) 
[10:25:49.967]                             next
[10:25:49.967]                           if (!grepl(pattern, name)) 
[10:25:49.967]                             next
[10:25:49.967]                           invokeRestart(restart)
[10:25:49.967]                           muffled <- TRUE
[10:25:49.967]                           break
[10:25:49.967]                         }
[10:25:49.967]                       }
[10:25:49.967]                     }
[10:25:49.967]                     invisible(muffled)
[10:25:49.967]                   }
[10:25:49.967]                   muffleCondition(cond)
[10:25:49.967]                 })
[10:25:49.967]             }))
[10:25:49.967]             future::FutureResult(value = ...future.value$value, 
[10:25:49.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.967]                   ...future.rng), globalenv = if (FALSE) 
[10:25:49.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:49.967]                     ...future.globalenv.names))
[10:25:49.967]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:49.967]         }, condition = base::local({
[10:25:49.967]             c <- base::c
[10:25:49.967]             inherits <- base::inherits
[10:25:49.967]             invokeRestart <- base::invokeRestart
[10:25:49.967]             length <- base::length
[10:25:49.967]             list <- base::list
[10:25:49.967]             seq.int <- base::seq.int
[10:25:49.967]             signalCondition <- base::signalCondition
[10:25:49.967]             sys.calls <- base::sys.calls
[10:25:49.967]             `[[` <- base::`[[`
[10:25:49.967]             `+` <- base::`+`
[10:25:49.967]             `<<-` <- base::`<<-`
[10:25:49.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:49.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:49.967]                   3L)]
[10:25:49.967]             }
[10:25:49.967]             function(cond) {
[10:25:49.967]                 is_error <- inherits(cond, "error")
[10:25:49.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:49.967]                   NULL)
[10:25:49.967]                 if (is_error) {
[10:25:49.967]                   sessionInformation <- function() {
[10:25:49.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:49.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:49.967]                       search = base::search(), system = base::Sys.info())
[10:25:49.967]                   }
[10:25:49.967]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:49.967]                     cond$call), session = sessionInformation(), 
[10:25:49.967]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:49.967]                   signalCondition(cond)
[10:25:49.967]                 }
[10:25:49.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:49.967]                 "immediateCondition"))) {
[10:25:49.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:49.967]                   ...future.conditions[[length(...future.conditions) + 
[10:25:49.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:49.967]                   if (TRUE && !signal) {
[10:25:49.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.967]                     {
[10:25:49.967]                       inherits <- base::inherits
[10:25:49.967]                       invokeRestart <- base::invokeRestart
[10:25:49.967]                       is.null <- base::is.null
[10:25:49.967]                       muffled <- FALSE
[10:25:49.967]                       if (inherits(cond, "message")) {
[10:25:49.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.967]                         if (muffled) 
[10:25:49.967]                           invokeRestart("muffleMessage")
[10:25:49.967]                       }
[10:25:49.967]                       else if (inherits(cond, "warning")) {
[10:25:49.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.967]                         if (muffled) 
[10:25:49.967]                           invokeRestart("muffleWarning")
[10:25:49.967]                       }
[10:25:49.967]                       else if (inherits(cond, "condition")) {
[10:25:49.967]                         if (!is.null(pattern)) {
[10:25:49.967]                           computeRestarts <- base::computeRestarts
[10:25:49.967]                           grepl <- base::grepl
[10:25:49.967]                           restarts <- computeRestarts(cond)
[10:25:49.967]                           for (restart in restarts) {
[10:25:49.967]                             name <- restart$name
[10:25:49.967]                             if (is.null(name)) 
[10:25:49.967]                               next
[10:25:49.967]                             if (!grepl(pattern, name)) 
[10:25:49.967]                               next
[10:25:49.967]                             invokeRestart(restart)
[10:25:49.967]                             muffled <- TRUE
[10:25:49.967]                             break
[10:25:49.967]                           }
[10:25:49.967]                         }
[10:25:49.967]                       }
[10:25:49.967]                       invisible(muffled)
[10:25:49.967]                     }
[10:25:49.967]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.967]                   }
[10:25:49.967]                 }
[10:25:49.967]                 else {
[10:25:49.967]                   if (TRUE) {
[10:25:49.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:49.967]                     {
[10:25:49.967]                       inherits <- base::inherits
[10:25:49.967]                       invokeRestart <- base::invokeRestart
[10:25:49.967]                       is.null <- base::is.null
[10:25:49.967]                       muffled <- FALSE
[10:25:49.967]                       if (inherits(cond, "message")) {
[10:25:49.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:49.967]                         if (muffled) 
[10:25:49.967]                           invokeRestart("muffleMessage")
[10:25:49.967]                       }
[10:25:49.967]                       else if (inherits(cond, "warning")) {
[10:25:49.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:49.967]                         if (muffled) 
[10:25:49.967]                           invokeRestart("muffleWarning")
[10:25:49.967]                       }
[10:25:49.967]                       else if (inherits(cond, "condition")) {
[10:25:49.967]                         if (!is.null(pattern)) {
[10:25:49.967]                           computeRestarts <- base::computeRestarts
[10:25:49.967]                           grepl <- base::grepl
[10:25:49.967]                           restarts <- computeRestarts(cond)
[10:25:49.967]                           for (restart in restarts) {
[10:25:49.967]                             name <- restart$name
[10:25:49.967]                             if (is.null(name)) 
[10:25:49.967]                               next
[10:25:49.967]                             if (!grepl(pattern, name)) 
[10:25:49.967]                               next
[10:25:49.967]                             invokeRestart(restart)
[10:25:49.967]                             muffled <- TRUE
[10:25:49.967]                             break
[10:25:49.967]                           }
[10:25:49.967]                         }
[10:25:49.967]                       }
[10:25:49.967]                       invisible(muffled)
[10:25:49.967]                     }
[10:25:49.967]                     muffleCondition(cond, pattern = "^muffle")
[10:25:49.967]                   }
[10:25:49.967]                 }
[10:25:49.967]             }
[10:25:49.967]         }))
[10:25:49.967]     }, error = function(ex) {
[10:25:49.967]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:49.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:49.967]                 ...future.rng), started = ...future.startTime, 
[10:25:49.967]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:49.967]             version = "1.8"), class = "FutureResult")
[10:25:49.967]     }, finally = {
[10:25:49.967]         if (!identical(...future.workdir, getwd())) 
[10:25:49.967]             setwd(...future.workdir)
[10:25:49.967]         {
[10:25:49.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:49.967]                 ...future.oldOptions$nwarnings <- NULL
[10:25:49.967]             }
[10:25:49.967]             base::options(...future.oldOptions)
[10:25:49.967]             if (.Platform$OS.type == "windows") {
[10:25:49.967]                 old_names <- names(...future.oldEnvVars)
[10:25:49.967]                 envs <- base::Sys.getenv()
[10:25:49.967]                 names <- names(envs)
[10:25:49.967]                 common <- intersect(names, old_names)
[10:25:49.967]                 added <- setdiff(names, old_names)
[10:25:49.967]                 removed <- setdiff(old_names, names)
[10:25:49.967]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:49.967]                   envs[common]]
[10:25:49.967]                 NAMES <- toupper(changed)
[10:25:49.967]                 args <- list()
[10:25:49.967]                 for (kk in seq_along(NAMES)) {
[10:25:49.967]                   name <- changed[[kk]]
[10:25:49.967]                   NAME <- NAMES[[kk]]
[10:25:49.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.967]                     next
[10:25:49.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.967]                 }
[10:25:49.967]                 NAMES <- toupper(added)
[10:25:49.967]                 for (kk in seq_along(NAMES)) {
[10:25:49.967]                   name <- added[[kk]]
[10:25:49.967]                   NAME <- NAMES[[kk]]
[10:25:49.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.967]                     next
[10:25:49.967]                   args[[name]] <- ""
[10:25:49.967]                 }
[10:25:49.967]                 NAMES <- toupper(removed)
[10:25:49.967]                 for (kk in seq_along(NAMES)) {
[10:25:49.967]                   name <- removed[[kk]]
[10:25:49.967]                   NAME <- NAMES[[kk]]
[10:25:49.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:49.967]                     next
[10:25:49.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:49.967]                 }
[10:25:49.967]                 if (length(args) > 0) 
[10:25:49.967]                   base::do.call(base::Sys.setenv, args = args)
[10:25:49.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:49.967]             }
[10:25:49.967]             else {
[10:25:49.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:49.967]             }
[10:25:49.967]             {
[10:25:49.967]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:49.967]                   0L) {
[10:25:49.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:49.967]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:49.967]                   base::options(opts)
[10:25:49.967]                 }
[10:25:49.967]                 {
[10:25:49.967]                   {
[10:25:49.967]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:49.967]                     NULL
[10:25:49.967]                   }
[10:25:49.967]                   options(future.plan = NULL)
[10:25:49.967]                   if (is.na(NA_character_)) 
[10:25:49.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:49.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:49.967]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:49.967]                     envir = parent.frame()) 
[10:25:49.967]                   {
[10:25:49.967]                     default_workers <- missing(workers)
[10:25:49.967]                     if (is.function(workers)) 
[10:25:49.967]                       workers <- workers()
[10:25:49.967]                     workers <- structure(as.integer(workers), 
[10:25:49.967]                       class = class(workers))
[10:25:49.967]                     stop_if_not(is.finite(workers), workers >= 
[10:25:49.967]                       1L)
[10:25:49.967]                     if ((workers == 1L && !inherits(workers, 
[10:25:49.967]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:49.967]                       if (default_workers) 
[10:25:49.967]                         supportsMulticore(warn = TRUE)
[10:25:49.967]                       return(sequential(..., envir = envir))
[10:25:49.967]                     }
[10:25:49.967]                     oopts <- options(mc.cores = workers)
[10:25:49.967]                     on.exit(options(oopts))
[10:25:49.967]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:49.967]                       envir = envir)
[10:25:49.967]                     if (!future$lazy) 
[10:25:49.967]                       future <- run(future)
[10:25:49.967]                     invisible(future)
[10:25:49.967]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:49.967]                 }
[10:25:49.967]             }
[10:25:49.967]         }
[10:25:49.967]     })
[10:25:49.967]     if (TRUE) {
[10:25:49.967]         base::sink(type = "output", split = FALSE)
[10:25:49.967]         if (TRUE) {
[10:25:49.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:49.967]         }
[10:25:49.967]         else {
[10:25:49.967]             ...future.result["stdout"] <- base::list(NULL)
[10:25:49.967]         }
[10:25:49.967]         base::close(...future.stdout)
[10:25:49.967]         ...future.stdout <- NULL
[10:25:49.967]     }
[10:25:49.967]     ...future.result$conditions <- ...future.conditions
[10:25:49.967]     ...future.result$finished <- base::Sys.time()
[10:25:49.967]     ...future.result
[10:25:49.967] }
[10:25:49.970] requestCore(): workers = 2
[10:25:49.971] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:49.981] result() for MulticoreFuture ...
[10:25:49.982] result() for MulticoreFuture ...
[10:25:49.982] result() for MulticoreFuture ... done
[10:25:49.982] result() for MulticoreFuture ... done
[10:25:49.983] result() for MulticoreFuture ...
[10:25:49.983] result() for MulticoreFuture ... done
[10:25:49.987] MulticoreFuture started
[10:25:49.987] - Launch lazy future ... done
[10:25:49.987] run() for ‘MulticoreFuture’ ... done
[10:25:49.988] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c0f6bd1da8> 
[10:25:49.988] List of future strategies:
[10:25:49.988] 1. sequential:
[10:25:49.988]    - args: function (..., envir = parent.frame())
[10:25:49.988]    - tweaked: FALSE
[10:25:49.988]    - call: NULL
[10:25:49.989] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55c0f53e7948> 
[10:25:49.991] plan(): Setting new future strategy stack:
[10:25:49.991] List of future strategies:
[10:25:49.991] 1. multicore:
[10:25:49.991]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:49.991]    - tweaked: FALSE
[10:25:49.991]    - call: plan(strategy)
[10:25:49.996] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:49.999] resolve() on list environment ...
[10:25:49.999]  recursive: 0
[10:25:50.001]  length: 6
[10:25:50.001]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:50.001] signalConditionsASAP(numeric, pos=1) ...
[10:25:50.001] - nx: 6
[10:25:50.002] - relay: TRUE
[10:25:50.002] - stdout: TRUE
[10:25:50.002] - signal: TRUE
[10:25:50.002] - resignal: FALSE
[10:25:50.002] - force: TRUE
[10:25:50.002] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.002] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.003]  - until=2
[10:25:50.003]  - relaying element #2
[10:25:50.003] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.003] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.003] signalConditionsASAP(NULL, pos=1) ... done
[10:25:50.003]  length: 5 (resolved future 1)
[10:25:50.003] Future #2
[10:25:50.004] result() for MulticoreFuture ...
[10:25:50.004] result() for MulticoreFuture ... done
[10:25:50.004] result() for MulticoreFuture ...
[10:25:50.004] result() for MulticoreFuture ... done
[10:25:50.004] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:50.004] - nx: 6
[10:25:50.004] - relay: TRUE
[10:25:50.005] - stdout: TRUE
[10:25:50.005] - signal: TRUE
[10:25:50.005] - resignal: FALSE
[10:25:50.005] - force: TRUE
[10:25:50.005] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.005] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.005]  - until=2
[10:25:50.005]  - relaying element #2
[10:25:50.006] result() for MulticoreFuture ...
[10:25:50.006] result() for MulticoreFuture ... done
[10:25:50.006] result() for MulticoreFuture ...
[10:25:50.006] result() for MulticoreFuture ... done
[10:25:50.006] result() for MulticoreFuture ...
[10:25:50.006] result() for MulticoreFuture ... done
[10:25:50.006] result() for MulticoreFuture ...
[10:25:50.007] result() for MulticoreFuture ... done
[10:25:50.007] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.007] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.007] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:50.007]  length: 4 (resolved future 2)
[10:25:50.008] Future #3
[10:25:50.008] result() for MulticoreFuture ...
[10:25:50.009] result() for MulticoreFuture ...
[10:25:50.009] result() for MulticoreFuture ... done
[10:25:50.009] result() for MulticoreFuture ... done
[10:25:50.009] result() for MulticoreFuture ...
[10:25:50.010] result() for MulticoreFuture ... done
[10:25:50.010] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:50.010] - nx: 6
[10:25:50.010] - relay: TRUE
[10:25:50.010] - stdout: TRUE
[10:25:50.011] - signal: TRUE
[10:25:50.011] - resignal: FALSE
[10:25:50.011] - force: TRUE
[10:25:50.011] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.011] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.011]  - until=3
[10:25:50.012]  - relaying element #3
[10:25:50.012] result() for MulticoreFuture ...
[10:25:50.012] result() for MulticoreFuture ... done
[10:25:50.012] result() for MulticoreFuture ...
[10:25:50.012] result() for MulticoreFuture ... done
[10:25:50.013] result() for MulticoreFuture ...
[10:25:50.013] result() for MulticoreFuture ... done
[10:25:50.013] result() for MulticoreFuture ...
[10:25:50.013] result() for MulticoreFuture ... done
[10:25:50.013] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.014] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.014] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:50.014]  length: 3 (resolved future 3)
[10:25:50.014] Future #4
[10:25:50.015] result() for MulticoreFuture ...
[10:25:50.015] result() for MulticoreFuture ...
[10:25:50.016] result() for MulticoreFuture ... done
[10:25:50.016] result() for MulticoreFuture ... done
[10:25:50.016] result() for MulticoreFuture ...
[10:25:50.016] result() for MulticoreFuture ... done
[10:25:50.016] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:50.016] - nx: 6
[10:25:50.016] - relay: TRUE
[10:25:50.017] - stdout: TRUE
[10:25:50.017] - signal: TRUE
[10:25:50.017] - resignal: FALSE
[10:25:50.017] - force: TRUE
[10:25:50.017] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.017] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.017]  - until=4
[10:25:50.017]  - relaying element #4
[10:25:50.018] result() for MulticoreFuture ...
[10:25:50.018] result() for MulticoreFuture ... done
[10:25:50.018] result() for MulticoreFuture ...
[10:25:50.018] result() for MulticoreFuture ... done
[10:25:50.018] result() for MulticoreFuture ...
[10:25:50.018] result() for MulticoreFuture ... done
[10:25:50.019] result() for MulticoreFuture ...
[10:25:50.019] result() for MulticoreFuture ... done
[10:25:50.019] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.019] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.019] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:50.019]  length: 2 (resolved future 4)
[10:25:50.019] signalConditionsASAP(NULL, pos=5) ...
[10:25:50.019] - nx: 6
[10:25:50.020] - relay: TRUE
[10:25:50.020] - stdout: TRUE
[10:25:50.020] - signal: TRUE
[10:25:50.020] - resignal: FALSE
[10:25:50.020] - force: TRUE
[10:25:50.020] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.020] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.020]  - until=6
[10:25:50.020]  - relaying element #6
[10:25:50.021] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.021] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.021] signalConditionsASAP(NULL, pos=5) ... done
[10:25:50.021]  length: 1 (resolved future 5)
[10:25:50.021] signalConditionsASAP(numeric, pos=6) ...
[10:25:50.021] - nx: 6
[10:25:50.021] - relay: TRUE
[10:25:50.021] - stdout: TRUE
[10:25:50.022] - signal: TRUE
[10:25:50.022] - resignal: FALSE
[10:25:50.022] - force: TRUE
[10:25:50.022] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.022] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.022]  - until=6
[10:25:50.022] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.022] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.022] signalConditionsASAP(numeric, pos=6) ... done
[10:25:50.022]  length: 0 (resolved future 6)
[10:25:50.023] Relaying remaining futures
[10:25:50.023] signalConditionsASAP(NULL, pos=0) ...
[10:25:50.023] - nx: 6
[10:25:50.023] - relay: TRUE
[10:25:50.023] - stdout: TRUE
[10:25:50.023] - signal: TRUE
[10:25:50.023] - resignal: FALSE
[10:25:50.023] - force: TRUE
[10:25:50.023] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.024] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:50.024] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.024] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.024] signalConditionsASAP(NULL, pos=0) ... done
[10:25:50.024] resolve() on list environment ... DONE
[10:25:50.024] result() for MulticoreFuture ...
[10:25:50.024] result() for MulticoreFuture ... done
[10:25:50.024] result() for MulticoreFuture ...
[10:25:50.025] result() for MulticoreFuture ... done
[10:25:50.025] result() for MulticoreFuture ...
[10:25:50.025] result() for MulticoreFuture ... done
[10:25:50.025] result() for MulticoreFuture ...
[10:25:50.025] result() for MulticoreFuture ... done
[10:25:50.025] result() for MulticoreFuture ...
[10:25:50.025] result() for MulticoreFuture ... done
[10:25:50.026] result() for MulticoreFuture ...
[10:25:50.026] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f517d900> 
Dimensions: c(1, 6)
[10:25:50.026] getGlobalsAndPackages() ...
[10:25:50.026] Searching for globals...
[10:25:50.027] 
[10:25:50.027] Searching for globals ... DONE
[10:25:50.027] - globals: [0] <none>
[10:25:50.027] getGlobalsAndPackages() ... DONE
[10:25:50.027] run() for ‘Future’ ...
[10:25:50.028] - state: ‘created’
[10:25:50.028] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.032] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.032] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.032]   - Field: ‘label’
[10:25:50.032]   - Field: ‘local’
[10:25:50.032]   - Field: ‘owner’
[10:25:50.033]   - Field: ‘envir’
[10:25:50.033]   - Field: ‘workers’
[10:25:50.033]   - Field: ‘packages’
[10:25:50.033]   - Field: ‘gc’
[10:25:50.033]   - Field: ‘job’
[10:25:50.033]   - Field: ‘conditions’
[10:25:50.033]   - Field: ‘expr’
[10:25:50.033]   - Field: ‘uuid’
[10:25:50.034]   - Field: ‘seed’
[10:25:50.034]   - Field: ‘version’
[10:25:50.034]   - Field: ‘result’
[10:25:50.034]   - Field: ‘asynchronous’
[10:25:50.034]   - Field: ‘calls’
[10:25:50.034]   - Field: ‘globals’
[10:25:50.034]   - Field: ‘stdout’
[10:25:50.034]   - Field: ‘earlySignal’
[10:25:50.034]   - Field: ‘lazy’
[10:25:50.034]   - Field: ‘state’
[10:25:50.035] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.035] - Launch lazy future ...
[10:25:50.035] Packages needed by the future expression (n = 0): <none>
[10:25:50.035] Packages needed by future strategies (n = 0): <none>
[10:25:50.036] {
[10:25:50.036]     {
[10:25:50.036]         {
[10:25:50.036]             ...future.startTime <- base::Sys.time()
[10:25:50.036]             {
[10:25:50.036]                 {
[10:25:50.036]                   {
[10:25:50.036]                     {
[10:25:50.036]                       base::local({
[10:25:50.036]                         has_future <- base::requireNamespace("future", 
[10:25:50.036]                           quietly = TRUE)
[10:25:50.036]                         if (has_future) {
[10:25:50.036]                           ns <- base::getNamespace("future")
[10:25:50.036]                           version <- ns[[".package"]][["version"]]
[10:25:50.036]                           if (is.null(version)) 
[10:25:50.036]                             version <- utils::packageVersion("future")
[10:25:50.036]                         }
[10:25:50.036]                         else {
[10:25:50.036]                           version <- NULL
[10:25:50.036]                         }
[10:25:50.036]                         if (!has_future || version < "1.8.0") {
[10:25:50.036]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.036]                             "", base::R.version$version.string), 
[10:25:50.036]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.036]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.036]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.036]                               "release", "version")], collapse = " "), 
[10:25:50.036]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.036]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.036]                             info)
[10:25:50.036]                           info <- base::paste(info, collapse = "; ")
[10:25:50.036]                           if (!has_future) {
[10:25:50.036]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.036]                               info)
[10:25:50.036]                           }
[10:25:50.036]                           else {
[10:25:50.036]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.036]                               info, version)
[10:25:50.036]                           }
[10:25:50.036]                           base::stop(msg)
[10:25:50.036]                         }
[10:25:50.036]                       })
[10:25:50.036]                     }
[10:25:50.036]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.036]                     base::options(mc.cores = 1L)
[10:25:50.036]                   }
[10:25:50.036]                   options(future.plan = NULL)
[10:25:50.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.036]                 }
[10:25:50.036]                 ...future.workdir <- getwd()
[10:25:50.036]             }
[10:25:50.036]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.036]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.036]         }
[10:25:50.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.036]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.036]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.036]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.036]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.036]             base::names(...future.oldOptions))
[10:25:50.036]     }
[10:25:50.036]     if (FALSE) {
[10:25:50.036]     }
[10:25:50.036]     else {
[10:25:50.036]         if (TRUE) {
[10:25:50.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.036]                 open = "w")
[10:25:50.036]         }
[10:25:50.036]         else {
[10:25:50.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.036]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.036]         }
[10:25:50.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.036]             base::sink(type = "output", split = FALSE)
[10:25:50.036]             base::close(...future.stdout)
[10:25:50.036]         }, add = TRUE)
[10:25:50.036]     }
[10:25:50.036]     ...future.frame <- base::sys.nframe()
[10:25:50.036]     ...future.conditions <- base::list()
[10:25:50.036]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.036]     if (FALSE) {
[10:25:50.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.036]     }
[10:25:50.036]     ...future.result <- base::tryCatch({
[10:25:50.036]         base::withCallingHandlers({
[10:25:50.036]             ...future.value <- base::withVisible(base::local({
[10:25:50.036]                 withCallingHandlers({
[10:25:50.036]                   2
[10:25:50.036]                 }, immediateCondition = function(cond) {
[10:25:50.036]                   save_rds <- function (object, pathname, ...) 
[10:25:50.036]                   {
[10:25:50.036]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.036]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.036]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.036]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.036]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.036]                         fi_tmp[["mtime"]])
[10:25:50.036]                     }
[10:25:50.036]                     tryCatch({
[10:25:50.036]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.036]                     }, error = function(ex) {
[10:25:50.036]                       msg <- conditionMessage(ex)
[10:25:50.036]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.036]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.036]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.036]                         fi_tmp[["mtime"]], msg)
[10:25:50.036]                       ex$message <- msg
[10:25:50.036]                       stop(ex)
[10:25:50.036]                     })
[10:25:50.036]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.036]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.036]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.036]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.036]                       fi <- file.info(pathname)
[10:25:50.036]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.036]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.036]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.036]                         fi[["size"]], fi[["mtime"]])
[10:25:50.036]                       stop(msg)
[10:25:50.036]                     }
[10:25:50.036]                     invisible(pathname)
[10:25:50.036]                   }
[10:25:50.036]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.036]                     rootPath = tempdir()) 
[10:25:50.036]                   {
[10:25:50.036]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.036]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.036]                       tmpdir = path, fileext = ".rds")
[10:25:50.036]                     save_rds(obj, file)
[10:25:50.036]                   }
[10:25:50.036]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.036]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.036]                   {
[10:25:50.036]                     inherits <- base::inherits
[10:25:50.036]                     invokeRestart <- base::invokeRestart
[10:25:50.036]                     is.null <- base::is.null
[10:25:50.036]                     muffled <- FALSE
[10:25:50.036]                     if (inherits(cond, "message")) {
[10:25:50.036]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.036]                       if (muffled) 
[10:25:50.036]                         invokeRestart("muffleMessage")
[10:25:50.036]                     }
[10:25:50.036]                     else if (inherits(cond, "warning")) {
[10:25:50.036]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.036]                       if (muffled) 
[10:25:50.036]                         invokeRestart("muffleWarning")
[10:25:50.036]                     }
[10:25:50.036]                     else if (inherits(cond, "condition")) {
[10:25:50.036]                       if (!is.null(pattern)) {
[10:25:50.036]                         computeRestarts <- base::computeRestarts
[10:25:50.036]                         grepl <- base::grepl
[10:25:50.036]                         restarts <- computeRestarts(cond)
[10:25:50.036]                         for (restart in restarts) {
[10:25:50.036]                           name <- restart$name
[10:25:50.036]                           if (is.null(name)) 
[10:25:50.036]                             next
[10:25:50.036]                           if (!grepl(pattern, name)) 
[10:25:50.036]                             next
[10:25:50.036]                           invokeRestart(restart)
[10:25:50.036]                           muffled <- TRUE
[10:25:50.036]                           break
[10:25:50.036]                         }
[10:25:50.036]                       }
[10:25:50.036]                     }
[10:25:50.036]                     invisible(muffled)
[10:25:50.036]                   }
[10:25:50.036]                   muffleCondition(cond)
[10:25:50.036]                 })
[10:25:50.036]             }))
[10:25:50.036]             future::FutureResult(value = ...future.value$value, 
[10:25:50.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.036]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.036]                     ...future.globalenv.names))
[10:25:50.036]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.036]         }, condition = base::local({
[10:25:50.036]             c <- base::c
[10:25:50.036]             inherits <- base::inherits
[10:25:50.036]             invokeRestart <- base::invokeRestart
[10:25:50.036]             length <- base::length
[10:25:50.036]             list <- base::list
[10:25:50.036]             seq.int <- base::seq.int
[10:25:50.036]             signalCondition <- base::signalCondition
[10:25:50.036]             sys.calls <- base::sys.calls
[10:25:50.036]             `[[` <- base::`[[`
[10:25:50.036]             `+` <- base::`+`
[10:25:50.036]             `<<-` <- base::`<<-`
[10:25:50.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.036]                   3L)]
[10:25:50.036]             }
[10:25:50.036]             function(cond) {
[10:25:50.036]                 is_error <- inherits(cond, "error")
[10:25:50.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.036]                   NULL)
[10:25:50.036]                 if (is_error) {
[10:25:50.036]                   sessionInformation <- function() {
[10:25:50.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.036]                       search = base::search(), system = base::Sys.info())
[10:25:50.036]                   }
[10:25:50.036]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.036]                     cond$call), session = sessionInformation(), 
[10:25:50.036]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.036]                   signalCondition(cond)
[10:25:50.036]                 }
[10:25:50.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.036]                 "immediateCondition"))) {
[10:25:50.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.036]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.036]                   if (TRUE && !signal) {
[10:25:50.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.036]                     {
[10:25:50.036]                       inherits <- base::inherits
[10:25:50.036]                       invokeRestart <- base::invokeRestart
[10:25:50.036]                       is.null <- base::is.null
[10:25:50.036]                       muffled <- FALSE
[10:25:50.036]                       if (inherits(cond, "message")) {
[10:25:50.036]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.036]                         if (muffled) 
[10:25:50.036]                           invokeRestart("muffleMessage")
[10:25:50.036]                       }
[10:25:50.036]                       else if (inherits(cond, "warning")) {
[10:25:50.036]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.036]                         if (muffled) 
[10:25:50.036]                           invokeRestart("muffleWarning")
[10:25:50.036]                       }
[10:25:50.036]                       else if (inherits(cond, "condition")) {
[10:25:50.036]                         if (!is.null(pattern)) {
[10:25:50.036]                           computeRestarts <- base::computeRestarts
[10:25:50.036]                           grepl <- base::grepl
[10:25:50.036]                           restarts <- computeRestarts(cond)
[10:25:50.036]                           for (restart in restarts) {
[10:25:50.036]                             name <- restart$name
[10:25:50.036]                             if (is.null(name)) 
[10:25:50.036]                               next
[10:25:50.036]                             if (!grepl(pattern, name)) 
[10:25:50.036]                               next
[10:25:50.036]                             invokeRestart(restart)
[10:25:50.036]                             muffled <- TRUE
[10:25:50.036]                             break
[10:25:50.036]                           }
[10:25:50.036]                         }
[10:25:50.036]                       }
[10:25:50.036]                       invisible(muffled)
[10:25:50.036]                     }
[10:25:50.036]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.036]                   }
[10:25:50.036]                 }
[10:25:50.036]                 else {
[10:25:50.036]                   if (TRUE) {
[10:25:50.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.036]                     {
[10:25:50.036]                       inherits <- base::inherits
[10:25:50.036]                       invokeRestart <- base::invokeRestart
[10:25:50.036]                       is.null <- base::is.null
[10:25:50.036]                       muffled <- FALSE
[10:25:50.036]                       if (inherits(cond, "message")) {
[10:25:50.036]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.036]                         if (muffled) 
[10:25:50.036]                           invokeRestart("muffleMessage")
[10:25:50.036]                       }
[10:25:50.036]                       else if (inherits(cond, "warning")) {
[10:25:50.036]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.036]                         if (muffled) 
[10:25:50.036]                           invokeRestart("muffleWarning")
[10:25:50.036]                       }
[10:25:50.036]                       else if (inherits(cond, "condition")) {
[10:25:50.036]                         if (!is.null(pattern)) {
[10:25:50.036]                           computeRestarts <- base::computeRestarts
[10:25:50.036]                           grepl <- base::grepl
[10:25:50.036]                           restarts <- computeRestarts(cond)
[10:25:50.036]                           for (restart in restarts) {
[10:25:50.036]                             name <- restart$name
[10:25:50.036]                             if (is.null(name)) 
[10:25:50.036]                               next
[10:25:50.036]                             if (!grepl(pattern, name)) 
[10:25:50.036]                               next
[10:25:50.036]                             invokeRestart(restart)
[10:25:50.036]                             muffled <- TRUE
[10:25:50.036]                             break
[10:25:50.036]                           }
[10:25:50.036]                         }
[10:25:50.036]                       }
[10:25:50.036]                       invisible(muffled)
[10:25:50.036]                     }
[10:25:50.036]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.036]                   }
[10:25:50.036]                 }
[10:25:50.036]             }
[10:25:50.036]         }))
[10:25:50.036]     }, error = function(ex) {
[10:25:50.036]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.036]                 ...future.rng), started = ...future.startTime, 
[10:25:50.036]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.036]             version = "1.8"), class = "FutureResult")
[10:25:50.036]     }, finally = {
[10:25:50.036]         if (!identical(...future.workdir, getwd())) 
[10:25:50.036]             setwd(...future.workdir)
[10:25:50.036]         {
[10:25:50.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.036]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.036]             }
[10:25:50.036]             base::options(...future.oldOptions)
[10:25:50.036]             if (.Platform$OS.type == "windows") {
[10:25:50.036]                 old_names <- names(...future.oldEnvVars)
[10:25:50.036]                 envs <- base::Sys.getenv()
[10:25:50.036]                 names <- names(envs)
[10:25:50.036]                 common <- intersect(names, old_names)
[10:25:50.036]                 added <- setdiff(names, old_names)
[10:25:50.036]                 removed <- setdiff(old_names, names)
[10:25:50.036]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.036]                   envs[common]]
[10:25:50.036]                 NAMES <- toupper(changed)
[10:25:50.036]                 args <- list()
[10:25:50.036]                 for (kk in seq_along(NAMES)) {
[10:25:50.036]                   name <- changed[[kk]]
[10:25:50.036]                   NAME <- NAMES[[kk]]
[10:25:50.036]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.036]                     next
[10:25:50.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.036]                 }
[10:25:50.036]                 NAMES <- toupper(added)
[10:25:50.036]                 for (kk in seq_along(NAMES)) {
[10:25:50.036]                   name <- added[[kk]]
[10:25:50.036]                   NAME <- NAMES[[kk]]
[10:25:50.036]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.036]                     next
[10:25:50.036]                   args[[name]] <- ""
[10:25:50.036]                 }
[10:25:50.036]                 NAMES <- toupper(removed)
[10:25:50.036]                 for (kk in seq_along(NAMES)) {
[10:25:50.036]                   name <- removed[[kk]]
[10:25:50.036]                   NAME <- NAMES[[kk]]
[10:25:50.036]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.036]                     next
[10:25:50.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.036]                 }
[10:25:50.036]                 if (length(args) > 0) 
[10:25:50.036]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.036]             }
[10:25:50.036]             else {
[10:25:50.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.036]             }
[10:25:50.036]             {
[10:25:50.036]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.036]                   0L) {
[10:25:50.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.036]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.036]                   base::options(opts)
[10:25:50.036]                 }
[10:25:50.036]                 {
[10:25:50.036]                   {
[10:25:50.036]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.036]                     NULL
[10:25:50.036]                   }
[10:25:50.036]                   options(future.plan = NULL)
[10:25:50.036]                   if (is.na(NA_character_)) 
[10:25:50.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.036]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.036]                     envir = parent.frame()) 
[10:25:50.036]                   {
[10:25:50.036]                     default_workers <- missing(workers)
[10:25:50.036]                     if (is.function(workers)) 
[10:25:50.036]                       workers <- workers()
[10:25:50.036]                     workers <- structure(as.integer(workers), 
[10:25:50.036]                       class = class(workers))
[10:25:50.036]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.036]                       1L)
[10:25:50.036]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.036]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.036]                       if (default_workers) 
[10:25:50.036]                         supportsMulticore(warn = TRUE)
[10:25:50.036]                       return(sequential(..., envir = envir))
[10:25:50.036]                     }
[10:25:50.036]                     oopts <- options(mc.cores = workers)
[10:25:50.036]                     on.exit(options(oopts))
[10:25:50.036]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.036]                       envir = envir)
[10:25:50.036]                     if (!future$lazy) 
[10:25:50.036]                       future <- run(future)
[10:25:50.036]                     invisible(future)
[10:25:50.036]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.036]                 }
[10:25:50.036]             }
[10:25:50.036]         }
[10:25:50.036]     })
[10:25:50.036]     if (TRUE) {
[10:25:50.036]         base::sink(type = "output", split = FALSE)
[10:25:50.036]         if (TRUE) {
[10:25:50.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.036]         }
[10:25:50.036]         else {
[10:25:50.036]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.036]         }
[10:25:50.036]         base::close(...future.stdout)
[10:25:50.036]         ...future.stdout <- NULL
[10:25:50.036]     }
[10:25:50.036]     ...future.result$conditions <- ...future.conditions
[10:25:50.036]     ...future.result$finished <- base::Sys.time()
[10:25:50.036]     ...future.result
[10:25:50.036] }
[10:25:50.039] requestCore(): workers = 2
[10:25:50.041] MulticoreFuture started
[10:25:50.041] - Launch lazy future ... done
[10:25:50.041] run() for ‘MulticoreFuture’ ... done
[10:25:50.042] getGlobalsAndPackages() ...
[10:25:50.042] Searching for globals...
[10:25:50.042] plan(): Setting new future strategy stack:
[10:25:50.043] 
[10:25:50.043] Searching for globals ... DONE
[10:25:50.042] List of future strategies:
[10:25:50.042] 1. sequential:
[10:25:50.042]    - args: function (..., envir = parent.frame())
[10:25:50.042]    - tweaked: FALSE
[10:25:50.042]    - call: NULL
[10:25:50.043] - globals: [0] <none>
[10:25:50.043] plan(): nbrOfWorkers() = 1
[10:25:50.043] getGlobalsAndPackages() ... DONE
[10:25:50.043] run() for ‘Future’ ...
[10:25:50.044] - state: ‘created’
[10:25:50.044] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.045] plan(): Setting new future strategy stack:
[10:25:50.045] List of future strategies:
[10:25:50.045] 1. multicore:
[10:25:50.045]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.045]    - tweaked: FALSE
[10:25:50.045]    - call: plan(strategy)
[10:25:50.049] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.050]   - Field: ‘label’
[10:25:50.050] plan(): nbrOfWorkers() = 2
[10:25:50.050]   - Field: ‘local’
[10:25:50.050]   - Field: ‘owner’
[10:25:50.051]   - Field: ‘envir’
[10:25:50.051]   - Field: ‘workers’
[10:25:50.051]   - Field: ‘packages’
[10:25:50.051]   - Field: ‘gc’
[10:25:50.051]   - Field: ‘job’
[10:25:50.051]   - Field: ‘conditions’
[10:25:50.051]   - Field: ‘expr’
[10:25:50.052]   - Field: ‘uuid’
[10:25:50.052]   - Field: ‘seed’
[10:25:50.052]   - Field: ‘version’
[10:25:50.052]   - Field: ‘result’
[10:25:50.052]   - Field: ‘asynchronous’
[10:25:50.052]   - Field: ‘calls’
[10:25:50.052]   - Field: ‘globals’
[10:25:50.052]   - Field: ‘stdout’
[10:25:50.053]   - Field: ‘earlySignal’
[10:25:50.053]   - Field: ‘lazy’
[10:25:50.053]   - Field: ‘state’
[10:25:50.053] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.053] - Launch lazy future ...
[10:25:50.054] Packages needed by the future expression (n = 0): <none>
[10:25:50.054] Packages needed by future strategies (n = 0): <none>
[10:25:50.055] {
[10:25:50.055]     {
[10:25:50.055]         {
[10:25:50.055]             ...future.startTime <- base::Sys.time()
[10:25:50.055]             {
[10:25:50.055]                 {
[10:25:50.055]                   {
[10:25:50.055]                     {
[10:25:50.055]                       base::local({
[10:25:50.055]                         has_future <- base::requireNamespace("future", 
[10:25:50.055]                           quietly = TRUE)
[10:25:50.055]                         if (has_future) {
[10:25:50.055]                           ns <- base::getNamespace("future")
[10:25:50.055]                           version <- ns[[".package"]][["version"]]
[10:25:50.055]                           if (is.null(version)) 
[10:25:50.055]                             version <- utils::packageVersion("future")
[10:25:50.055]                         }
[10:25:50.055]                         else {
[10:25:50.055]                           version <- NULL
[10:25:50.055]                         }
[10:25:50.055]                         if (!has_future || version < "1.8.0") {
[10:25:50.055]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.055]                             "", base::R.version$version.string), 
[10:25:50.055]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.055]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.055]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.055]                               "release", "version")], collapse = " "), 
[10:25:50.055]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.055]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.055]                             info)
[10:25:50.055]                           info <- base::paste(info, collapse = "; ")
[10:25:50.055]                           if (!has_future) {
[10:25:50.055]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.055]                               info)
[10:25:50.055]                           }
[10:25:50.055]                           else {
[10:25:50.055]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.055]                               info, version)
[10:25:50.055]                           }
[10:25:50.055]                           base::stop(msg)
[10:25:50.055]                         }
[10:25:50.055]                       })
[10:25:50.055]                     }
[10:25:50.055]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.055]                     base::options(mc.cores = 1L)
[10:25:50.055]                   }
[10:25:50.055]                   options(future.plan = NULL)
[10:25:50.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.055]                 }
[10:25:50.055]                 ...future.workdir <- getwd()
[10:25:50.055]             }
[10:25:50.055]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.055]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.055]         }
[10:25:50.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.055]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.055]             base::names(...future.oldOptions))
[10:25:50.055]     }
[10:25:50.055]     if (FALSE) {
[10:25:50.055]     }
[10:25:50.055]     else {
[10:25:50.055]         if (TRUE) {
[10:25:50.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.055]                 open = "w")
[10:25:50.055]         }
[10:25:50.055]         else {
[10:25:50.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.055]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.055]         }
[10:25:50.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.055]             base::sink(type = "output", split = FALSE)
[10:25:50.055]             base::close(...future.stdout)
[10:25:50.055]         }, add = TRUE)
[10:25:50.055]     }
[10:25:50.055]     ...future.frame <- base::sys.nframe()
[10:25:50.055]     ...future.conditions <- base::list()
[10:25:50.055]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.055]     if (FALSE) {
[10:25:50.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.055]     }
[10:25:50.055]     ...future.result <- base::tryCatch({
[10:25:50.055]         base::withCallingHandlers({
[10:25:50.055]             ...future.value <- base::withVisible(base::local({
[10:25:50.055]                 withCallingHandlers({
[10:25:50.055]                   NULL
[10:25:50.055]                 }, immediateCondition = function(cond) {
[10:25:50.055]                   save_rds <- function (object, pathname, ...) 
[10:25:50.055]                   {
[10:25:50.055]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.055]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.055]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.055]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.055]                         fi_tmp[["mtime"]])
[10:25:50.055]                     }
[10:25:50.055]                     tryCatch({
[10:25:50.055]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.055]                     }, error = function(ex) {
[10:25:50.055]                       msg <- conditionMessage(ex)
[10:25:50.055]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.055]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.055]                         fi_tmp[["mtime"]], msg)
[10:25:50.055]                       ex$message <- msg
[10:25:50.055]                       stop(ex)
[10:25:50.055]                     })
[10:25:50.055]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.055]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.055]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.055]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.055]                       fi <- file.info(pathname)
[10:25:50.055]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.055]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.055]                         fi[["size"]], fi[["mtime"]])
[10:25:50.055]                       stop(msg)
[10:25:50.055]                     }
[10:25:50.055]                     invisible(pathname)
[10:25:50.055]                   }
[10:25:50.055]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.055]                     rootPath = tempdir()) 
[10:25:50.055]                   {
[10:25:50.055]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.055]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.055]                       tmpdir = path, fileext = ".rds")
[10:25:50.055]                     save_rds(obj, file)
[10:25:50.055]                   }
[10:25:50.055]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.055]                   {
[10:25:50.055]                     inherits <- base::inherits
[10:25:50.055]                     invokeRestart <- base::invokeRestart
[10:25:50.055]                     is.null <- base::is.null
[10:25:50.055]                     muffled <- FALSE
[10:25:50.055]                     if (inherits(cond, "message")) {
[10:25:50.055]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.055]                       if (muffled) 
[10:25:50.055]                         invokeRestart("muffleMessage")
[10:25:50.055]                     }
[10:25:50.055]                     else if (inherits(cond, "warning")) {
[10:25:50.055]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.055]                       if (muffled) 
[10:25:50.055]                         invokeRestart("muffleWarning")
[10:25:50.055]                     }
[10:25:50.055]                     else if (inherits(cond, "condition")) {
[10:25:50.055]                       if (!is.null(pattern)) {
[10:25:50.055]                         computeRestarts <- base::computeRestarts
[10:25:50.055]                         grepl <- base::grepl
[10:25:50.055]                         restarts <- computeRestarts(cond)
[10:25:50.055]                         for (restart in restarts) {
[10:25:50.055]                           name <- restart$name
[10:25:50.055]                           if (is.null(name)) 
[10:25:50.055]                             next
[10:25:50.055]                           if (!grepl(pattern, name)) 
[10:25:50.055]                             next
[10:25:50.055]                           invokeRestart(restart)
[10:25:50.055]                           muffled <- TRUE
[10:25:50.055]                           break
[10:25:50.055]                         }
[10:25:50.055]                       }
[10:25:50.055]                     }
[10:25:50.055]                     invisible(muffled)
[10:25:50.055]                   }
[10:25:50.055]                   muffleCondition(cond)
[10:25:50.055]                 })
[10:25:50.055]             }))
[10:25:50.055]             future::FutureResult(value = ...future.value$value, 
[10:25:50.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.055]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.055]                     ...future.globalenv.names))
[10:25:50.055]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.055]         }, condition = base::local({
[10:25:50.055]             c <- base::c
[10:25:50.055]             inherits <- base::inherits
[10:25:50.055]             invokeRestart <- base::invokeRestart
[10:25:50.055]             length <- base::length
[10:25:50.055]             list <- base::list
[10:25:50.055]             seq.int <- base::seq.int
[10:25:50.055]             signalCondition <- base::signalCondition
[10:25:50.055]             sys.calls <- base::sys.calls
[10:25:50.055]             `[[` <- base::`[[`
[10:25:50.055]             `+` <- base::`+`
[10:25:50.055]             `<<-` <- base::`<<-`
[10:25:50.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.055]                   3L)]
[10:25:50.055]             }
[10:25:50.055]             function(cond) {
[10:25:50.055]                 is_error <- inherits(cond, "error")
[10:25:50.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.055]                   NULL)
[10:25:50.055]                 if (is_error) {
[10:25:50.055]                   sessionInformation <- function() {
[10:25:50.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.055]                       search = base::search(), system = base::Sys.info())
[10:25:50.055]                   }
[10:25:50.055]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.055]                     cond$call), session = sessionInformation(), 
[10:25:50.055]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.055]                   signalCondition(cond)
[10:25:50.055]                 }
[10:25:50.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.055]                 "immediateCondition"))) {
[10:25:50.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.055]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.055]                   if (TRUE && !signal) {
[10:25:50.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.055]                     {
[10:25:50.055]                       inherits <- base::inherits
[10:25:50.055]                       invokeRestart <- base::invokeRestart
[10:25:50.055]                       is.null <- base::is.null
[10:25:50.055]                       muffled <- FALSE
[10:25:50.055]                       if (inherits(cond, "message")) {
[10:25:50.055]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.055]                         if (muffled) 
[10:25:50.055]                           invokeRestart("muffleMessage")
[10:25:50.055]                       }
[10:25:50.055]                       else if (inherits(cond, "warning")) {
[10:25:50.055]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.055]                         if (muffled) 
[10:25:50.055]                           invokeRestart("muffleWarning")
[10:25:50.055]                       }
[10:25:50.055]                       else if (inherits(cond, "condition")) {
[10:25:50.055]                         if (!is.null(pattern)) {
[10:25:50.055]                           computeRestarts <- base::computeRestarts
[10:25:50.055]                           grepl <- base::grepl
[10:25:50.055]                           restarts <- computeRestarts(cond)
[10:25:50.055]                           for (restart in restarts) {
[10:25:50.055]                             name <- restart$name
[10:25:50.055]                             if (is.null(name)) 
[10:25:50.055]                               next
[10:25:50.055]                             if (!grepl(pattern, name)) 
[10:25:50.055]                               next
[10:25:50.055]                             invokeRestart(restart)
[10:25:50.055]                             muffled <- TRUE
[10:25:50.055]                             break
[10:25:50.055]                           }
[10:25:50.055]                         }
[10:25:50.055]                       }
[10:25:50.055]                       invisible(muffled)
[10:25:50.055]                     }
[10:25:50.055]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.055]                   }
[10:25:50.055]                 }
[10:25:50.055]                 else {
[10:25:50.055]                   if (TRUE) {
[10:25:50.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.055]                     {
[10:25:50.055]                       inherits <- base::inherits
[10:25:50.055]                       invokeRestart <- base::invokeRestart
[10:25:50.055]                       is.null <- base::is.null
[10:25:50.055]                       muffled <- FALSE
[10:25:50.055]                       if (inherits(cond, "message")) {
[10:25:50.055]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.055]                         if (muffled) 
[10:25:50.055]                           invokeRestart("muffleMessage")
[10:25:50.055]                       }
[10:25:50.055]                       else if (inherits(cond, "warning")) {
[10:25:50.055]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.055]                         if (muffled) 
[10:25:50.055]                           invokeRestart("muffleWarning")
[10:25:50.055]                       }
[10:25:50.055]                       else if (inherits(cond, "condition")) {
[10:25:50.055]                         if (!is.null(pattern)) {
[10:25:50.055]                           computeRestarts <- base::computeRestarts
[10:25:50.055]                           grepl <- base::grepl
[10:25:50.055]                           restarts <- computeRestarts(cond)
[10:25:50.055]                           for (restart in restarts) {
[10:25:50.055]                             name <- restart$name
[10:25:50.055]                             if (is.null(name)) 
[10:25:50.055]                               next
[10:25:50.055]                             if (!grepl(pattern, name)) 
[10:25:50.055]                               next
[10:25:50.055]                             invokeRestart(restart)
[10:25:50.055]                             muffled <- TRUE
[10:25:50.055]                             break
[10:25:50.055]                           }
[10:25:50.055]                         }
[10:25:50.055]                       }
[10:25:50.055]                       invisible(muffled)
[10:25:50.055]                     }
[10:25:50.055]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.055]                   }
[10:25:50.055]                 }
[10:25:50.055]             }
[10:25:50.055]         }))
[10:25:50.055]     }, error = function(ex) {
[10:25:50.055]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.055]                 ...future.rng), started = ...future.startTime, 
[10:25:50.055]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.055]             version = "1.8"), class = "FutureResult")
[10:25:50.055]     }, finally = {
[10:25:50.055]         if (!identical(...future.workdir, getwd())) 
[10:25:50.055]             setwd(...future.workdir)
[10:25:50.055]         {
[10:25:50.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.055]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.055]             }
[10:25:50.055]             base::options(...future.oldOptions)
[10:25:50.055]             if (.Platform$OS.type == "windows") {
[10:25:50.055]                 old_names <- names(...future.oldEnvVars)
[10:25:50.055]                 envs <- base::Sys.getenv()
[10:25:50.055]                 names <- names(envs)
[10:25:50.055]                 common <- intersect(names, old_names)
[10:25:50.055]                 added <- setdiff(names, old_names)
[10:25:50.055]                 removed <- setdiff(old_names, names)
[10:25:50.055]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.055]                   envs[common]]
[10:25:50.055]                 NAMES <- toupper(changed)
[10:25:50.055]                 args <- list()
[10:25:50.055]                 for (kk in seq_along(NAMES)) {
[10:25:50.055]                   name <- changed[[kk]]
[10:25:50.055]                   NAME <- NAMES[[kk]]
[10:25:50.055]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.055]                     next
[10:25:50.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.055]                 }
[10:25:50.055]                 NAMES <- toupper(added)
[10:25:50.055]                 for (kk in seq_along(NAMES)) {
[10:25:50.055]                   name <- added[[kk]]
[10:25:50.055]                   NAME <- NAMES[[kk]]
[10:25:50.055]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.055]                     next
[10:25:50.055]                   args[[name]] <- ""
[10:25:50.055]                 }
[10:25:50.055]                 NAMES <- toupper(removed)
[10:25:50.055]                 for (kk in seq_along(NAMES)) {
[10:25:50.055]                   name <- removed[[kk]]
[10:25:50.055]                   NAME <- NAMES[[kk]]
[10:25:50.055]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.055]                     next
[10:25:50.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.055]                 }
[10:25:50.055]                 if (length(args) > 0) 
[10:25:50.055]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.055]             }
[10:25:50.055]             else {
[10:25:50.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.055]             }
[10:25:50.055]             {
[10:25:50.055]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.055]                   0L) {
[10:25:50.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.055]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.055]                   base::options(opts)
[10:25:50.055]                 }
[10:25:50.055]                 {
[10:25:50.055]                   {
[10:25:50.055]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.055]                     NULL
[10:25:50.055]                   }
[10:25:50.055]                   options(future.plan = NULL)
[10:25:50.055]                   if (is.na(NA_character_)) 
[10:25:50.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.055]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.055]                     envir = parent.frame()) 
[10:25:50.055]                   {
[10:25:50.055]                     default_workers <- missing(workers)
[10:25:50.055]                     if (is.function(workers)) 
[10:25:50.055]                       workers <- workers()
[10:25:50.055]                     workers <- structure(as.integer(workers), 
[10:25:50.055]                       class = class(workers))
[10:25:50.055]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.055]                       1L)
[10:25:50.055]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.055]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.055]                       if (default_workers) 
[10:25:50.055]                         supportsMulticore(warn = TRUE)
[10:25:50.055]                       return(sequential(..., envir = envir))
[10:25:50.055]                     }
[10:25:50.055]                     oopts <- options(mc.cores = workers)
[10:25:50.055]                     on.exit(options(oopts))
[10:25:50.055]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.055]                       envir = envir)
[10:25:50.055]                     if (!future$lazy) 
[10:25:50.055]                       future <- run(future)
[10:25:50.055]                     invisible(future)
[10:25:50.055]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.055]                 }
[10:25:50.055]             }
[10:25:50.055]         }
[10:25:50.055]     })
[10:25:50.055]     if (TRUE) {
[10:25:50.055]         base::sink(type = "output", split = FALSE)
[10:25:50.055]         if (TRUE) {
[10:25:50.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.055]         }
[10:25:50.055]         else {
[10:25:50.055]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.055]         }
[10:25:50.055]         base::close(...future.stdout)
[10:25:50.055]         ...future.stdout <- NULL
[10:25:50.055]     }
[10:25:50.055]     ...future.result$conditions <- ...future.conditions
[10:25:50.055]     ...future.result$finished <- base::Sys.time()
[10:25:50.055]     ...future.result
[10:25:50.055] }
[10:25:50.058] requestCore(): workers = 2
[10:25:50.061] MulticoreFuture started
[10:25:50.061] - Launch lazy future ... done
[10:25:50.062] run() for ‘MulticoreFuture’ ... done
[10:25:50.062] plan(): Setting new future strategy stack:
[10:25:50.063] getGlobalsAndPackages() ...
[10:25:50.063] Searching for globals...
[10:25:50.063] List of future strategies:
[10:25:50.063] 1. sequential:
[10:25:50.063]    - args: function (..., envir = parent.frame())
[10:25:50.063]    - tweaked: FALSE
[10:25:50.063]    - call: NULL
[10:25:50.063] plan(): nbrOfWorkers() = 1
[10:25:50.064] - globals found: [1] ‘{’
[10:25:50.064] Searching for globals ... DONE
[10:25:50.065] Resolving globals: FALSE
[10:25:50.065] 
[10:25:50.065] 
[10:25:50.065] getGlobalsAndPackages() ... DONE
[10:25:50.065] plan(): Setting new future strategy stack:
[10:25:50.066] run() for ‘Future’ ...
[10:25:50.066] - state: ‘created’
[10:25:50.066] List of future strategies:
[10:25:50.066] 1. multicore:
[10:25:50.066]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.066]    - tweaked: FALSE
[10:25:50.066]    - call: plan(strategy)
[10:25:50.066] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.071] plan(): nbrOfWorkers() = 2
[10:25:50.071] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.072] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.072]   - Field: ‘label’
[10:25:50.072]   - Field: ‘local’
[10:25:50.072]   - Field: ‘owner’
[10:25:50.072]   - Field: ‘envir’
[10:25:50.073]   - Field: ‘workers’
[10:25:50.073]   - Field: ‘packages’
[10:25:50.073]   - Field: ‘gc’
[10:25:50.073]   - Field: ‘job’
[10:25:50.073]   - Field: ‘conditions’
[10:25:50.073]   - Field: ‘expr’
[10:25:50.073]   - Field: ‘uuid’
[10:25:50.074]   - Field: ‘seed’
[10:25:50.074]   - Field: ‘version’
[10:25:50.074]   - Field: ‘result’
[10:25:50.074]   - Field: ‘asynchronous’
[10:25:50.074]   - Field: ‘calls’
[10:25:50.074]   - Field: ‘globals’
[10:25:50.074]   - Field: ‘stdout’
[10:25:50.075]   - Field: ‘earlySignal’
[10:25:50.075]   - Field: ‘lazy’
[10:25:50.075]   - Field: ‘state’
[10:25:50.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.075] - Launch lazy future ...
[10:25:50.076] Packages needed by the future expression (n = 0): <none>
[10:25:50.076] Packages needed by future strategies (n = 0): <none>
[10:25:50.076] {
[10:25:50.076]     {
[10:25:50.076]         {
[10:25:50.076]             ...future.startTime <- base::Sys.time()
[10:25:50.076]             {
[10:25:50.076]                 {
[10:25:50.076]                   {
[10:25:50.076]                     {
[10:25:50.076]                       base::local({
[10:25:50.076]                         has_future <- base::requireNamespace("future", 
[10:25:50.076]                           quietly = TRUE)
[10:25:50.076]                         if (has_future) {
[10:25:50.076]                           ns <- base::getNamespace("future")
[10:25:50.076]                           version <- ns[[".package"]][["version"]]
[10:25:50.076]                           if (is.null(version)) 
[10:25:50.076]                             version <- utils::packageVersion("future")
[10:25:50.076]                         }
[10:25:50.076]                         else {
[10:25:50.076]                           version <- NULL
[10:25:50.076]                         }
[10:25:50.076]                         if (!has_future || version < "1.8.0") {
[10:25:50.076]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.076]                             "", base::R.version$version.string), 
[10:25:50.076]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.076]                               "release", "version")], collapse = " "), 
[10:25:50.076]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.076]                             info)
[10:25:50.076]                           info <- base::paste(info, collapse = "; ")
[10:25:50.076]                           if (!has_future) {
[10:25:50.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.076]                               info)
[10:25:50.076]                           }
[10:25:50.076]                           else {
[10:25:50.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.076]                               info, version)
[10:25:50.076]                           }
[10:25:50.076]                           base::stop(msg)
[10:25:50.076]                         }
[10:25:50.076]                       })
[10:25:50.076]                     }
[10:25:50.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.076]                     base::options(mc.cores = 1L)
[10:25:50.076]                   }
[10:25:50.076]                   options(future.plan = NULL)
[10:25:50.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.076]                 }
[10:25:50.076]                 ...future.workdir <- getwd()
[10:25:50.076]             }
[10:25:50.076]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.076]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.076]         }
[10:25:50.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.076]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.076]             base::names(...future.oldOptions))
[10:25:50.076]     }
[10:25:50.076]     if (FALSE) {
[10:25:50.076]     }
[10:25:50.076]     else {
[10:25:50.076]         if (TRUE) {
[10:25:50.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.076]                 open = "w")
[10:25:50.076]         }
[10:25:50.076]         else {
[10:25:50.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.076]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.076]         }
[10:25:50.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.076]             base::sink(type = "output", split = FALSE)
[10:25:50.076]             base::close(...future.stdout)
[10:25:50.076]         }, add = TRUE)
[10:25:50.076]     }
[10:25:50.076]     ...future.frame <- base::sys.nframe()
[10:25:50.076]     ...future.conditions <- base::list()
[10:25:50.076]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.076]     if (FALSE) {
[10:25:50.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.076]     }
[10:25:50.076]     ...future.result <- base::tryCatch({
[10:25:50.076]         base::withCallingHandlers({
[10:25:50.076]             ...future.value <- base::withVisible(base::local({
[10:25:50.076]                 withCallingHandlers({
[10:25:50.076]                   {
[10:25:50.076]                     4
[10:25:50.076]                   }
[10:25:50.076]                 }, immediateCondition = function(cond) {
[10:25:50.076]                   save_rds <- function (object, pathname, ...) 
[10:25:50.076]                   {
[10:25:50.076]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.076]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.076]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.076]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.076]                         fi_tmp[["mtime"]])
[10:25:50.076]                     }
[10:25:50.076]                     tryCatch({
[10:25:50.076]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.076]                     }, error = function(ex) {
[10:25:50.076]                       msg <- conditionMessage(ex)
[10:25:50.076]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.076]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.076]                         fi_tmp[["mtime"]], msg)
[10:25:50.076]                       ex$message <- msg
[10:25:50.076]                       stop(ex)
[10:25:50.076]                     })
[10:25:50.076]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.076]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.076]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.076]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.076]                       fi <- file.info(pathname)
[10:25:50.076]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.076]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.076]                         fi[["size"]], fi[["mtime"]])
[10:25:50.076]                       stop(msg)
[10:25:50.076]                     }
[10:25:50.076]                     invisible(pathname)
[10:25:50.076]                   }
[10:25:50.076]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.076]                     rootPath = tempdir()) 
[10:25:50.076]                   {
[10:25:50.076]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.076]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.076]                       tmpdir = path, fileext = ".rds")
[10:25:50.076]                     save_rds(obj, file)
[10:25:50.076]                   }
[10:25:50.076]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.076]                   {
[10:25:50.076]                     inherits <- base::inherits
[10:25:50.076]                     invokeRestart <- base::invokeRestart
[10:25:50.076]                     is.null <- base::is.null
[10:25:50.076]                     muffled <- FALSE
[10:25:50.076]                     if (inherits(cond, "message")) {
[10:25:50.076]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.076]                       if (muffled) 
[10:25:50.076]                         invokeRestart("muffleMessage")
[10:25:50.076]                     }
[10:25:50.076]                     else if (inherits(cond, "warning")) {
[10:25:50.076]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.076]                       if (muffled) 
[10:25:50.076]                         invokeRestart("muffleWarning")
[10:25:50.076]                     }
[10:25:50.076]                     else if (inherits(cond, "condition")) {
[10:25:50.076]                       if (!is.null(pattern)) {
[10:25:50.076]                         computeRestarts <- base::computeRestarts
[10:25:50.076]                         grepl <- base::grepl
[10:25:50.076]                         restarts <- computeRestarts(cond)
[10:25:50.076]                         for (restart in restarts) {
[10:25:50.076]                           name <- restart$name
[10:25:50.076]                           if (is.null(name)) 
[10:25:50.076]                             next
[10:25:50.076]                           if (!grepl(pattern, name)) 
[10:25:50.076]                             next
[10:25:50.076]                           invokeRestart(restart)
[10:25:50.076]                           muffled <- TRUE
[10:25:50.076]                           break
[10:25:50.076]                         }
[10:25:50.076]                       }
[10:25:50.076]                     }
[10:25:50.076]                     invisible(muffled)
[10:25:50.076]                   }
[10:25:50.076]                   muffleCondition(cond)
[10:25:50.076]                 })
[10:25:50.076]             }))
[10:25:50.076]             future::FutureResult(value = ...future.value$value, 
[10:25:50.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.076]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.076]                     ...future.globalenv.names))
[10:25:50.076]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.076]         }, condition = base::local({
[10:25:50.076]             c <- base::c
[10:25:50.076]             inherits <- base::inherits
[10:25:50.076]             invokeRestart <- base::invokeRestart
[10:25:50.076]             length <- base::length
[10:25:50.076]             list <- base::list
[10:25:50.076]             seq.int <- base::seq.int
[10:25:50.076]             signalCondition <- base::signalCondition
[10:25:50.076]             sys.calls <- base::sys.calls
[10:25:50.076]             `[[` <- base::`[[`
[10:25:50.076]             `+` <- base::`+`
[10:25:50.076]             `<<-` <- base::`<<-`
[10:25:50.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.076]                   3L)]
[10:25:50.076]             }
[10:25:50.076]             function(cond) {
[10:25:50.076]                 is_error <- inherits(cond, "error")
[10:25:50.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.076]                   NULL)
[10:25:50.076]                 if (is_error) {
[10:25:50.076]                   sessionInformation <- function() {
[10:25:50.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.076]                       search = base::search(), system = base::Sys.info())
[10:25:50.076]                   }
[10:25:50.076]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.076]                     cond$call), session = sessionInformation(), 
[10:25:50.076]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.076]                   signalCondition(cond)
[10:25:50.076]                 }
[10:25:50.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.076]                 "immediateCondition"))) {
[10:25:50.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.076]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.076]                   if (TRUE && !signal) {
[10:25:50.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.076]                     {
[10:25:50.076]                       inherits <- base::inherits
[10:25:50.076]                       invokeRestart <- base::invokeRestart
[10:25:50.076]                       is.null <- base::is.null
[10:25:50.076]                       muffled <- FALSE
[10:25:50.076]                       if (inherits(cond, "message")) {
[10:25:50.076]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.076]                         if (muffled) 
[10:25:50.076]                           invokeRestart("muffleMessage")
[10:25:50.076]                       }
[10:25:50.076]                       else if (inherits(cond, "warning")) {
[10:25:50.076]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.076]                         if (muffled) 
[10:25:50.076]                           invokeRestart("muffleWarning")
[10:25:50.076]                       }
[10:25:50.076]                       else if (inherits(cond, "condition")) {
[10:25:50.076]                         if (!is.null(pattern)) {
[10:25:50.076]                           computeRestarts <- base::computeRestarts
[10:25:50.076]                           grepl <- base::grepl
[10:25:50.076]                           restarts <- computeRestarts(cond)
[10:25:50.076]                           for (restart in restarts) {
[10:25:50.076]                             name <- restart$name
[10:25:50.076]                             if (is.null(name)) 
[10:25:50.076]                               next
[10:25:50.076]                             if (!grepl(pattern, name)) 
[10:25:50.076]                               next
[10:25:50.076]                             invokeRestart(restart)
[10:25:50.076]                             muffled <- TRUE
[10:25:50.076]                             break
[10:25:50.076]                           }
[10:25:50.076]                         }
[10:25:50.076]                       }
[10:25:50.076]                       invisible(muffled)
[10:25:50.076]                     }
[10:25:50.076]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.076]                   }
[10:25:50.076]                 }
[10:25:50.076]                 else {
[10:25:50.076]                   if (TRUE) {
[10:25:50.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.076]                     {
[10:25:50.076]                       inherits <- base::inherits
[10:25:50.076]                       invokeRestart <- base::invokeRestart
[10:25:50.076]                       is.null <- base::is.null
[10:25:50.076]                       muffled <- FALSE
[10:25:50.076]                       if (inherits(cond, "message")) {
[10:25:50.076]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.076]                         if (muffled) 
[10:25:50.076]                           invokeRestart("muffleMessage")
[10:25:50.076]                       }
[10:25:50.076]                       else if (inherits(cond, "warning")) {
[10:25:50.076]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.076]                         if (muffled) 
[10:25:50.076]                           invokeRestart("muffleWarning")
[10:25:50.076]                       }
[10:25:50.076]                       else if (inherits(cond, "condition")) {
[10:25:50.076]                         if (!is.null(pattern)) {
[10:25:50.076]                           computeRestarts <- base::computeRestarts
[10:25:50.076]                           grepl <- base::grepl
[10:25:50.076]                           restarts <- computeRestarts(cond)
[10:25:50.076]                           for (restart in restarts) {
[10:25:50.076]                             name <- restart$name
[10:25:50.076]                             if (is.null(name)) 
[10:25:50.076]                               next
[10:25:50.076]                             if (!grepl(pattern, name)) 
[10:25:50.076]                               next
[10:25:50.076]                             invokeRestart(restart)
[10:25:50.076]                             muffled <- TRUE
[10:25:50.076]                             break
[10:25:50.076]                           }
[10:25:50.076]                         }
[10:25:50.076]                       }
[10:25:50.076]                       invisible(muffled)
[10:25:50.076]                     }
[10:25:50.076]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.076]                   }
[10:25:50.076]                 }
[10:25:50.076]             }
[10:25:50.076]         }))
[10:25:50.076]     }, error = function(ex) {
[10:25:50.076]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.076]                 ...future.rng), started = ...future.startTime, 
[10:25:50.076]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.076]             version = "1.8"), class = "FutureResult")
[10:25:50.076]     }, finally = {
[10:25:50.076]         if (!identical(...future.workdir, getwd())) 
[10:25:50.076]             setwd(...future.workdir)
[10:25:50.076]         {
[10:25:50.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.076]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.076]             }
[10:25:50.076]             base::options(...future.oldOptions)
[10:25:50.076]             if (.Platform$OS.type == "windows") {
[10:25:50.076]                 old_names <- names(...future.oldEnvVars)
[10:25:50.076]                 envs <- base::Sys.getenv()
[10:25:50.076]                 names <- names(envs)
[10:25:50.076]                 common <- intersect(names, old_names)
[10:25:50.076]                 added <- setdiff(names, old_names)
[10:25:50.076]                 removed <- setdiff(old_names, names)
[10:25:50.076]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.076]                   envs[common]]
[10:25:50.076]                 NAMES <- toupper(changed)
[10:25:50.076]                 args <- list()
[10:25:50.076]                 for (kk in seq_along(NAMES)) {
[10:25:50.076]                   name <- changed[[kk]]
[10:25:50.076]                   NAME <- NAMES[[kk]]
[10:25:50.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.076]                     next
[10:25:50.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.076]                 }
[10:25:50.076]                 NAMES <- toupper(added)
[10:25:50.076]                 for (kk in seq_along(NAMES)) {
[10:25:50.076]                   name <- added[[kk]]
[10:25:50.076]                   NAME <- NAMES[[kk]]
[10:25:50.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.076]                     next
[10:25:50.076]                   args[[name]] <- ""
[10:25:50.076]                 }
[10:25:50.076]                 NAMES <- toupper(removed)
[10:25:50.076]                 for (kk in seq_along(NAMES)) {
[10:25:50.076]                   name <- removed[[kk]]
[10:25:50.076]                   NAME <- NAMES[[kk]]
[10:25:50.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.076]                     next
[10:25:50.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.076]                 }
[10:25:50.076]                 if (length(args) > 0) 
[10:25:50.076]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.076]             }
[10:25:50.076]             else {
[10:25:50.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.076]             }
[10:25:50.076]             {
[10:25:50.076]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.076]                   0L) {
[10:25:50.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.076]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.076]                   base::options(opts)
[10:25:50.076]                 }
[10:25:50.076]                 {
[10:25:50.076]                   {
[10:25:50.076]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.076]                     NULL
[10:25:50.076]                   }
[10:25:50.076]                   options(future.plan = NULL)
[10:25:50.076]                   if (is.na(NA_character_)) 
[10:25:50.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.076]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.076]                     envir = parent.frame()) 
[10:25:50.076]                   {
[10:25:50.076]                     default_workers <- missing(workers)
[10:25:50.076]                     if (is.function(workers)) 
[10:25:50.076]                       workers <- workers()
[10:25:50.076]                     workers <- structure(as.integer(workers), 
[10:25:50.076]                       class = class(workers))
[10:25:50.076]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.076]                       1L)
[10:25:50.076]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.076]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.076]                       if (default_workers) 
[10:25:50.076]                         supportsMulticore(warn = TRUE)
[10:25:50.076]                       return(sequential(..., envir = envir))
[10:25:50.076]                     }
[10:25:50.076]                     oopts <- options(mc.cores = workers)
[10:25:50.076]                     on.exit(options(oopts))
[10:25:50.076]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.076]                       envir = envir)
[10:25:50.076]                     if (!future$lazy) 
[10:25:50.076]                       future <- run(future)
[10:25:50.076]                     invisible(future)
[10:25:50.076]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.076]                 }
[10:25:50.076]             }
[10:25:50.076]         }
[10:25:50.076]     })
[10:25:50.076]     if (TRUE) {
[10:25:50.076]         base::sink(type = "output", split = FALSE)
[10:25:50.076]         if (TRUE) {
[10:25:50.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.076]         }
[10:25:50.076]         else {
[10:25:50.076]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.076]         }
[10:25:50.076]         base::close(...future.stdout)
[10:25:50.076]         ...future.stdout <- NULL
[10:25:50.076]     }
[10:25:50.076]     ...future.result$conditions <- ...future.conditions
[10:25:50.076]     ...future.result$finished <- base::Sys.time()
[10:25:50.076]     ...future.result
[10:25:50.076] }
[10:25:50.080] requestCore(): workers = 2
[10:25:50.081] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:50.091] result() for MulticoreFuture ...
[10:25:50.093] result() for MulticoreFuture ...
[10:25:50.093] result() for MulticoreFuture ... done
[10:25:50.093] result() for MulticoreFuture ... done
[10:25:50.093] result() for MulticoreFuture ...
[10:25:50.093] result() for MulticoreFuture ... done
[10:25:50.096] MulticoreFuture started
[10:25:50.097] - Launch lazy future ... done
[10:25:50.097] run() for ‘MulticoreFuture’ ... done
[10:25:50.098] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c0f5fc5060> 
[10:25:50.098] List of future strategies:
[10:25:50.098] 1. sequential:
[10:25:50.098]    - args: function (..., envir = parent.frame())
[10:25:50.098]    - tweaked: FALSE
[10:25:50.098]    - call: NULL
[10:25:50.099] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55c0f6c6a460> 
 - attr(*, "dim.")= int [1:2] [10:25:50.102] plan(): Setting new future strategy stack:
1 6
 - attr(*, "dimnames.")=List of 2
  ..$ :[10:25:50.102] List of future strategies:
[10:25:50.102] 1. multicore:
[10:25:50.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.102]    - tweaked: FALSE
[10:25:50.102]    - call: plan(strategy)
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:25:50.108] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:50.112] resolve() on list environment ...
[10:25:50.112]  recursive: 0
[10:25:50.113]  length: 6
[10:25:50.113]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:50.114] signalConditionsASAP(numeric, pos=1) ...
[10:25:50.114] - nx: 6
[10:25:50.114] - relay: TRUE
[10:25:50.114] - stdout: TRUE
[10:25:50.114] - signal: TRUE
[10:25:50.114] - resignal: FALSE
[10:25:50.114] - force: TRUE
[10:25:50.115] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.115] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.115]  - until=2
[10:25:50.115]  - relaying element #2
[10:25:50.115] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.115] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.115] signalConditionsASAP(NULL, pos=1) ... done
[10:25:50.116]  length: 5 (resolved future 1)
[10:25:50.116] Future #2
[10:25:50.116] result() for MulticoreFuture ...
[10:25:50.116] result() for MulticoreFuture ... done
[10:25:50.116] result() for MulticoreFuture ...
[10:25:50.116] result() for MulticoreFuture ... done
[10:25:50.116] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:50.117] - nx: 6
[10:25:50.117] - relay: TRUE
[10:25:50.117] - stdout: TRUE
[10:25:50.117] - signal: TRUE
[10:25:50.117] - resignal: FALSE
[10:25:50.117] - force: TRUE
[10:25:50.117] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.117] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.118]  - until=2
[10:25:50.118]  - relaying element #2
[10:25:50.118] result() for MulticoreFuture ...
[10:25:50.118] result() for MulticoreFuture ... done
[10:25:50.118] result() for MulticoreFuture ...
[10:25:50.118] result() for MulticoreFuture ... done
[10:25:50.118] result() for MulticoreFuture ...
[10:25:50.119] result() for MulticoreFuture ... done
[10:25:50.119] result() for MulticoreFuture ...
[10:25:50.119] result() for MulticoreFuture ... done
[10:25:50.119] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.119] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.119] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:50.119]  length: 4 (resolved future 2)
[10:25:50.120] Future #3
[10:25:50.120] result() for MulticoreFuture ...
[10:25:50.121] result() for MulticoreFuture ...
[10:25:50.121] result() for MulticoreFuture ... done
[10:25:50.121] result() for MulticoreFuture ... done
[10:25:50.121] result() for MulticoreFuture ...
[10:25:50.121] result() for MulticoreFuture ... done
[10:25:50.121] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:50.122] - nx: 6
[10:25:50.122] - relay: TRUE
[10:25:50.122] - stdout: TRUE
[10:25:50.122] - signal: TRUE
[10:25:50.122] - resignal: FALSE
[10:25:50.122] - force: TRUE
[10:25:50.129] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.130] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.130]  - until=3
[10:25:50.131]  - relaying element #3
[10:25:50.131] result() for MulticoreFuture ...
[10:25:50.131] result() for MulticoreFuture ... done
[10:25:50.132] result() for MulticoreFuture ...
[10:25:50.132] result() for MulticoreFuture ... done
[10:25:50.132] result() for MulticoreFuture ...
[10:25:50.132] result() for MulticoreFuture ... done
[10:25:50.132] result() for MulticoreFuture ...
[10:25:50.132] result() for MulticoreFuture ... done
[10:25:50.133] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.133] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.133] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:50.133]  length: 3 (resolved future 3)
[10:25:50.133] Future #4
[10:25:50.134] result() for MulticoreFuture ...
[10:25:50.134] result() for MulticoreFuture ...
[10:25:50.134] result() for MulticoreFuture ... done
[10:25:50.135] result() for MulticoreFuture ... done
[10:25:50.135] result() for MulticoreFuture ...
[10:25:50.135] result() for MulticoreFuture ... done
[10:25:50.135] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:50.135] - nx: 6
[10:25:50.135] - relay: TRUE
[10:25:50.135] - stdout: TRUE
[10:25:50.136] - signal: TRUE
[10:25:50.136] - resignal: FALSE
[10:25:50.136] - force: TRUE
[10:25:50.136] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.136] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.136]  - until=4
[10:25:50.136]  - relaying element #4
[10:25:50.136] result() for MulticoreFuture ...
[10:25:50.136] result() for MulticoreFuture ... done
[10:25:50.137] result() for MulticoreFuture ...
[10:25:50.137] result() for MulticoreFuture ... done
[10:25:50.137] result() for MulticoreFuture ...
[10:25:50.137] result() for MulticoreFuture ... done
[10:25:50.137] result() for MulticoreFuture ...
[10:25:50.137] result() for MulticoreFuture ... done
[10:25:50.137] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.137] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.138] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:50.138]  length: 2 (resolved future 4)
[10:25:50.138] signalConditionsASAP(NULL, pos=5) ...
[10:25:50.138] - nx: 6
[10:25:50.138] - relay: TRUE
[10:25:50.138] - stdout: TRUE
[10:25:50.138] - signal: TRUE
[10:25:50.138] - resignal: FALSE
[10:25:50.138] - force: TRUE
[10:25:50.138] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.139] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.139]  - until=6
[10:25:50.139]  - relaying element #6
[10:25:50.139] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.139] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.139] signalConditionsASAP(NULL, pos=5) ... done
[10:25:50.139]  length: 1 (resolved future 5)
[10:25:50.139] signalConditionsASAP(numeric, pos=6) ...
[10:25:50.139] - nx: 6
[10:25:50.140] - relay: TRUE
[10:25:50.140] - stdout: TRUE
[10:25:50.140] - signal: TRUE
[10:25:50.140] - resignal: FALSE
[10:25:50.140] - force: TRUE
[10:25:50.140] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.140] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.140]  - until=6
[10:25:50.140] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.140] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.141] signalConditionsASAP(numeric, pos=6) ... done
[10:25:50.141]  length: 0 (resolved future 6)
[10:25:50.141] Relaying remaining futures
[10:25:50.141] signalConditionsASAP(NULL, pos=0) ...
[10:25:50.141] - nx: 6
[10:25:50.141] - relay: TRUE
[10:25:50.141] - stdout: TRUE
[10:25:50.141] - signal: TRUE
[10:25:50.141] - resignal: FALSE
[10:25:50.141] - force: TRUE
[10:25:50.142] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.142] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:50.142] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.142] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.142] signalConditionsASAP(NULL, pos=0) ... done
[10:25:50.142] resolve() on list environment ... DONE
[10:25:50.142] result() for MulticoreFuture ...
[10:25:50.142] result() for MulticoreFuture ... done
[10:25:50.142] result() for MulticoreFuture ...
[10:25:50.143] result() for MulticoreFuture ... done
[10:25:50.143] result() for MulticoreFuture ...
[10:25:50.143] result() for MulticoreFuture ... done
[10:25:50.143] result() for MulticoreFuture ...
[10:25:50.143] result() for MulticoreFuture ... done
[10:25:50.143] result() for MulticoreFuture ...
[10:25:50.143] result() for MulticoreFuture ... done
[10:25:50.144] result() for MulticoreFuture ...
[10:25:50.144] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f6ece138> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:25:50.146] getGlobalsAndPackages() ...
[10:25:50.146] Searching for globals...
[10:25:50.146] 
[10:25:50.146] Searching for globals ... DONE
[10:25:50.146] - globals: [0] <none>
[10:25:50.146] getGlobalsAndPackages() ... DONE
[10:25:50.147] run() for ‘Future’ ...
[10:25:50.147] - state: ‘created’
[10:25:50.147] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.152] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.152] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.152]   - Field: ‘label’
[10:25:50.152]   - Field: ‘local’
[10:25:50.152]   - Field: ‘owner’
[10:25:50.152]   - Field: ‘envir’
[10:25:50.153]   - Field: ‘workers’
[10:25:50.153]   - Field: ‘packages’
[10:25:50.153]   - Field: ‘gc’
[10:25:50.153]   - Field: ‘job’
[10:25:50.153]   - Field: ‘conditions’
[10:25:50.153]   - Field: ‘expr’
[10:25:50.153]   - Field: ‘uuid’
[10:25:50.153]   - Field: ‘seed’
[10:25:50.153]   - Field: ‘version’
[10:25:50.154]   - Field: ‘result’
[10:25:50.154]   - Field: ‘asynchronous’
[10:25:50.154]   - Field: ‘calls’
[10:25:50.154]   - Field: ‘globals’
[10:25:50.154]   - Field: ‘stdout’
[10:25:50.154]   - Field: ‘earlySignal’
[10:25:50.154]   - Field: ‘lazy’
[10:25:50.154]   - Field: ‘state’
[10:25:50.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.155] - Launch lazy future ...
[10:25:50.155] Packages needed by the future expression (n = 0): <none>
[10:25:50.155] Packages needed by future strategies (n = 0): <none>
[10:25:50.156] {
[10:25:50.156]     {
[10:25:50.156]         {
[10:25:50.156]             ...future.startTime <- base::Sys.time()
[10:25:50.156]             {
[10:25:50.156]                 {
[10:25:50.156]                   {
[10:25:50.156]                     {
[10:25:50.156]                       base::local({
[10:25:50.156]                         has_future <- base::requireNamespace("future", 
[10:25:50.156]                           quietly = TRUE)
[10:25:50.156]                         if (has_future) {
[10:25:50.156]                           ns <- base::getNamespace("future")
[10:25:50.156]                           version <- ns[[".package"]][["version"]]
[10:25:50.156]                           if (is.null(version)) 
[10:25:50.156]                             version <- utils::packageVersion("future")
[10:25:50.156]                         }
[10:25:50.156]                         else {
[10:25:50.156]                           version <- NULL
[10:25:50.156]                         }
[10:25:50.156]                         if (!has_future || version < "1.8.0") {
[10:25:50.156]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.156]                             "", base::R.version$version.string), 
[10:25:50.156]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.156]                               "release", "version")], collapse = " "), 
[10:25:50.156]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.156]                             info)
[10:25:50.156]                           info <- base::paste(info, collapse = "; ")
[10:25:50.156]                           if (!has_future) {
[10:25:50.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.156]                               info)
[10:25:50.156]                           }
[10:25:50.156]                           else {
[10:25:50.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.156]                               info, version)
[10:25:50.156]                           }
[10:25:50.156]                           base::stop(msg)
[10:25:50.156]                         }
[10:25:50.156]                       })
[10:25:50.156]                     }
[10:25:50.156]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.156]                     base::options(mc.cores = 1L)
[10:25:50.156]                   }
[10:25:50.156]                   options(future.plan = NULL)
[10:25:50.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.156]                 }
[10:25:50.156]                 ...future.workdir <- getwd()
[10:25:50.156]             }
[10:25:50.156]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.156]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.156]         }
[10:25:50.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.156]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.156]             base::names(...future.oldOptions))
[10:25:50.156]     }
[10:25:50.156]     if (FALSE) {
[10:25:50.156]     }
[10:25:50.156]     else {
[10:25:50.156]         if (TRUE) {
[10:25:50.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.156]                 open = "w")
[10:25:50.156]         }
[10:25:50.156]         else {
[10:25:50.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.156]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.156]         }
[10:25:50.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.156]             base::sink(type = "output", split = FALSE)
[10:25:50.156]             base::close(...future.stdout)
[10:25:50.156]         }, add = TRUE)
[10:25:50.156]     }
[10:25:50.156]     ...future.frame <- base::sys.nframe()
[10:25:50.156]     ...future.conditions <- base::list()
[10:25:50.156]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.156]     if (FALSE) {
[10:25:50.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.156]     }
[10:25:50.156]     ...future.result <- base::tryCatch({
[10:25:50.156]         base::withCallingHandlers({
[10:25:50.156]             ...future.value <- base::withVisible(base::local({
[10:25:50.156]                 withCallingHandlers({
[10:25:50.156]                   2
[10:25:50.156]                 }, immediateCondition = function(cond) {
[10:25:50.156]                   save_rds <- function (object, pathname, ...) 
[10:25:50.156]                   {
[10:25:50.156]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.156]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.156]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.156]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.156]                         fi_tmp[["mtime"]])
[10:25:50.156]                     }
[10:25:50.156]                     tryCatch({
[10:25:50.156]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.156]                     }, error = function(ex) {
[10:25:50.156]                       msg <- conditionMessage(ex)
[10:25:50.156]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.156]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.156]                         fi_tmp[["mtime"]], msg)
[10:25:50.156]                       ex$message <- msg
[10:25:50.156]                       stop(ex)
[10:25:50.156]                     })
[10:25:50.156]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.156]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.156]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.156]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.156]                       fi <- file.info(pathname)
[10:25:50.156]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.156]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.156]                         fi[["size"]], fi[["mtime"]])
[10:25:50.156]                       stop(msg)
[10:25:50.156]                     }
[10:25:50.156]                     invisible(pathname)
[10:25:50.156]                   }
[10:25:50.156]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.156]                     rootPath = tempdir()) 
[10:25:50.156]                   {
[10:25:50.156]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.156]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.156]                       tmpdir = path, fileext = ".rds")
[10:25:50.156]                     save_rds(obj, file)
[10:25:50.156]                   }
[10:25:50.156]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.156]                   {
[10:25:50.156]                     inherits <- base::inherits
[10:25:50.156]                     invokeRestart <- base::invokeRestart
[10:25:50.156]                     is.null <- base::is.null
[10:25:50.156]                     muffled <- FALSE
[10:25:50.156]                     if (inherits(cond, "message")) {
[10:25:50.156]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.156]                       if (muffled) 
[10:25:50.156]                         invokeRestart("muffleMessage")
[10:25:50.156]                     }
[10:25:50.156]                     else if (inherits(cond, "warning")) {
[10:25:50.156]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.156]                       if (muffled) 
[10:25:50.156]                         invokeRestart("muffleWarning")
[10:25:50.156]                     }
[10:25:50.156]                     else if (inherits(cond, "condition")) {
[10:25:50.156]                       if (!is.null(pattern)) {
[10:25:50.156]                         computeRestarts <- base::computeRestarts
[10:25:50.156]                         grepl <- base::grepl
[10:25:50.156]                         restarts <- computeRestarts(cond)
[10:25:50.156]                         for (restart in restarts) {
[10:25:50.156]                           name <- restart$name
[10:25:50.156]                           if (is.null(name)) 
[10:25:50.156]                             next
[10:25:50.156]                           if (!grepl(pattern, name)) 
[10:25:50.156]                             next
[10:25:50.156]                           invokeRestart(restart)
[10:25:50.156]                           muffled <- TRUE
[10:25:50.156]                           break
[10:25:50.156]                         }
[10:25:50.156]                       }
[10:25:50.156]                     }
[10:25:50.156]                     invisible(muffled)
[10:25:50.156]                   }
[10:25:50.156]                   muffleCondition(cond)
[10:25:50.156]                 })
[10:25:50.156]             }))
[10:25:50.156]             future::FutureResult(value = ...future.value$value, 
[10:25:50.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.156]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.156]                     ...future.globalenv.names))
[10:25:50.156]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.156]         }, condition = base::local({
[10:25:50.156]             c <- base::c
[10:25:50.156]             inherits <- base::inherits
[10:25:50.156]             invokeRestart <- base::invokeRestart
[10:25:50.156]             length <- base::length
[10:25:50.156]             list <- base::list
[10:25:50.156]             seq.int <- base::seq.int
[10:25:50.156]             signalCondition <- base::signalCondition
[10:25:50.156]             sys.calls <- base::sys.calls
[10:25:50.156]             `[[` <- base::`[[`
[10:25:50.156]             `+` <- base::`+`
[10:25:50.156]             `<<-` <- base::`<<-`
[10:25:50.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.156]                   3L)]
[10:25:50.156]             }
[10:25:50.156]             function(cond) {
[10:25:50.156]                 is_error <- inherits(cond, "error")
[10:25:50.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.156]                   NULL)
[10:25:50.156]                 if (is_error) {
[10:25:50.156]                   sessionInformation <- function() {
[10:25:50.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.156]                       search = base::search(), system = base::Sys.info())
[10:25:50.156]                   }
[10:25:50.156]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.156]                     cond$call), session = sessionInformation(), 
[10:25:50.156]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.156]                   signalCondition(cond)
[10:25:50.156]                 }
[10:25:50.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.156]                 "immediateCondition"))) {
[10:25:50.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.156]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.156]                   if (TRUE && !signal) {
[10:25:50.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.156]                     {
[10:25:50.156]                       inherits <- base::inherits
[10:25:50.156]                       invokeRestart <- base::invokeRestart
[10:25:50.156]                       is.null <- base::is.null
[10:25:50.156]                       muffled <- FALSE
[10:25:50.156]                       if (inherits(cond, "message")) {
[10:25:50.156]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.156]                         if (muffled) 
[10:25:50.156]                           invokeRestart("muffleMessage")
[10:25:50.156]                       }
[10:25:50.156]                       else if (inherits(cond, "warning")) {
[10:25:50.156]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.156]                         if (muffled) 
[10:25:50.156]                           invokeRestart("muffleWarning")
[10:25:50.156]                       }
[10:25:50.156]                       else if (inherits(cond, "condition")) {
[10:25:50.156]                         if (!is.null(pattern)) {
[10:25:50.156]                           computeRestarts <- base::computeRestarts
[10:25:50.156]                           grepl <- base::grepl
[10:25:50.156]                           restarts <- computeRestarts(cond)
[10:25:50.156]                           for (restart in restarts) {
[10:25:50.156]                             name <- restart$name
[10:25:50.156]                             if (is.null(name)) 
[10:25:50.156]                               next
[10:25:50.156]                             if (!grepl(pattern, name)) 
[10:25:50.156]                               next
[10:25:50.156]                             invokeRestart(restart)
[10:25:50.156]                             muffled <- TRUE
[10:25:50.156]                             break
[10:25:50.156]                           }
[10:25:50.156]                         }
[10:25:50.156]                       }
[10:25:50.156]                       invisible(muffled)
[10:25:50.156]                     }
[10:25:50.156]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.156]                   }
[10:25:50.156]                 }
[10:25:50.156]                 else {
[10:25:50.156]                   if (TRUE) {
[10:25:50.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.156]                     {
[10:25:50.156]                       inherits <- base::inherits
[10:25:50.156]                       invokeRestart <- base::invokeRestart
[10:25:50.156]                       is.null <- base::is.null
[10:25:50.156]                       muffled <- FALSE
[10:25:50.156]                       if (inherits(cond, "message")) {
[10:25:50.156]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.156]                         if (muffled) 
[10:25:50.156]                           invokeRestart("muffleMessage")
[10:25:50.156]                       }
[10:25:50.156]                       else if (inherits(cond, "warning")) {
[10:25:50.156]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.156]                         if (muffled) 
[10:25:50.156]                           invokeRestart("muffleWarning")
[10:25:50.156]                       }
[10:25:50.156]                       else if (inherits(cond, "condition")) {
[10:25:50.156]                         if (!is.null(pattern)) {
[10:25:50.156]                           computeRestarts <- base::computeRestarts
[10:25:50.156]                           grepl <- base::grepl
[10:25:50.156]                           restarts <- computeRestarts(cond)
[10:25:50.156]                           for (restart in restarts) {
[10:25:50.156]                             name <- restart$name
[10:25:50.156]                             if (is.null(name)) 
[10:25:50.156]                               next
[10:25:50.156]                             if (!grepl(pattern, name)) 
[10:25:50.156]                               next
[10:25:50.156]                             invokeRestart(restart)
[10:25:50.156]                             muffled <- TRUE
[10:25:50.156]                             break
[10:25:50.156]                           }
[10:25:50.156]                         }
[10:25:50.156]                       }
[10:25:50.156]                       invisible(muffled)
[10:25:50.156]                     }
[10:25:50.156]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.156]                   }
[10:25:50.156]                 }
[10:25:50.156]             }
[10:25:50.156]         }))
[10:25:50.156]     }, error = function(ex) {
[10:25:50.156]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.156]                 ...future.rng), started = ...future.startTime, 
[10:25:50.156]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.156]             version = "1.8"), class = "FutureResult")
[10:25:50.156]     }, finally = {
[10:25:50.156]         if (!identical(...future.workdir, getwd())) 
[10:25:50.156]             setwd(...future.workdir)
[10:25:50.156]         {
[10:25:50.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.156]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.156]             }
[10:25:50.156]             base::options(...future.oldOptions)
[10:25:50.156]             if (.Platform$OS.type == "windows") {
[10:25:50.156]                 old_names <- names(...future.oldEnvVars)
[10:25:50.156]                 envs <- base::Sys.getenv()
[10:25:50.156]                 names <- names(envs)
[10:25:50.156]                 common <- intersect(names, old_names)
[10:25:50.156]                 added <- setdiff(names, old_names)
[10:25:50.156]                 removed <- setdiff(old_names, names)
[10:25:50.156]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.156]                   envs[common]]
[10:25:50.156]                 NAMES <- toupper(changed)
[10:25:50.156]                 args <- list()
[10:25:50.156]                 for (kk in seq_along(NAMES)) {
[10:25:50.156]                   name <- changed[[kk]]
[10:25:50.156]                   NAME <- NAMES[[kk]]
[10:25:50.156]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.156]                     next
[10:25:50.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.156]                 }
[10:25:50.156]                 NAMES <- toupper(added)
[10:25:50.156]                 for (kk in seq_along(NAMES)) {
[10:25:50.156]                   name <- added[[kk]]
[10:25:50.156]                   NAME <- NAMES[[kk]]
[10:25:50.156]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.156]                     next
[10:25:50.156]                   args[[name]] <- ""
[10:25:50.156]                 }
[10:25:50.156]                 NAMES <- toupper(removed)
[10:25:50.156]                 for (kk in seq_along(NAMES)) {
[10:25:50.156]                   name <- removed[[kk]]
[10:25:50.156]                   NAME <- NAMES[[kk]]
[10:25:50.156]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.156]                     next
[10:25:50.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.156]                 }
[10:25:50.156]                 if (length(args) > 0) 
[10:25:50.156]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.156]             }
[10:25:50.156]             else {
[10:25:50.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.156]             }
[10:25:50.156]             {
[10:25:50.156]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.156]                   0L) {
[10:25:50.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.156]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.156]                   base::options(opts)
[10:25:50.156]                 }
[10:25:50.156]                 {
[10:25:50.156]                   {
[10:25:50.156]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.156]                     NULL
[10:25:50.156]                   }
[10:25:50.156]                   options(future.plan = NULL)
[10:25:50.156]                   if (is.na(NA_character_)) 
[10:25:50.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.156]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.156]                     envir = parent.frame()) 
[10:25:50.156]                   {
[10:25:50.156]                     default_workers <- missing(workers)
[10:25:50.156]                     if (is.function(workers)) 
[10:25:50.156]                       workers <- workers()
[10:25:50.156]                     workers <- structure(as.integer(workers), 
[10:25:50.156]                       class = class(workers))
[10:25:50.156]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.156]                       1L)
[10:25:50.156]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.156]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.156]                       if (default_workers) 
[10:25:50.156]                         supportsMulticore(warn = TRUE)
[10:25:50.156]                       return(sequential(..., envir = envir))
[10:25:50.156]                     }
[10:25:50.156]                     oopts <- options(mc.cores = workers)
[10:25:50.156]                     on.exit(options(oopts))
[10:25:50.156]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.156]                       envir = envir)
[10:25:50.156]                     if (!future$lazy) 
[10:25:50.156]                       future <- run(future)
[10:25:50.156]                     invisible(future)
[10:25:50.156]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.156]                 }
[10:25:50.156]             }
[10:25:50.156]         }
[10:25:50.156]     })
[10:25:50.156]     if (TRUE) {
[10:25:50.156]         base::sink(type = "output", split = FALSE)
[10:25:50.156]         if (TRUE) {
[10:25:50.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.156]         }
[10:25:50.156]         else {
[10:25:50.156]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.156]         }
[10:25:50.156]         base::close(...future.stdout)
[10:25:50.156]         ...future.stdout <- NULL
[10:25:50.156]     }
[10:25:50.156]     ...future.result$conditions <- ...future.conditions
[10:25:50.156]     ...future.result$finished <- base::Sys.time()
[10:25:50.156]     ...future.result
[10:25:50.156] }
[10:25:50.158] requestCore(): workers = 2
[10:25:50.160] MulticoreFuture started
[10:25:50.161] - Launch lazy future ... done
[10:25:50.161] run() for ‘MulticoreFuture’ ... done
[10:25:50.161] getGlobalsAndPackages() ...
[10:25:50.162] Searching for globals...
[10:25:50.162] plan(): Setting new future strategy stack:
[10:25:50.163] 
[10:25:50.162] List of future strategies:
[10:25:50.162] 1. sequential:
[10:25:50.162]    - args: function (..., envir = parent.frame())
[10:25:50.162]    - tweaked: FALSE
[10:25:50.162]    - call: NULL
[10:25:50.163] Searching for globals ... DONE
[10:25:50.163] - globals: [0] <none>
[10:25:50.163] plan(): nbrOfWorkers() = 1
[10:25:50.163] getGlobalsAndPackages() ... DONE
[10:25:50.164] run() for ‘Future’ ...
[10:25:50.164] - state: ‘created’
[10:25:50.164] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.165] plan(): Setting new future strategy stack:
[10:25:50.165] List of future strategies:
[10:25:50.165] 1. multicore:
[10:25:50.165]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.165]    - tweaked: FALSE
[10:25:50.165]    - call: plan(strategy)
[10:25:50.169] plan(): nbrOfWorkers() = 2
[10:25:50.169] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.169] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.170]   - Field: ‘label’
[10:25:50.170]   - Field: ‘local’
[10:25:50.170]   - Field: ‘owner’
[10:25:50.170]   - Field: ‘envir’
[10:25:50.170]   - Field: ‘workers’
[10:25:50.171]   - Field: ‘packages’
[10:25:50.171]   - Field: ‘gc’
[10:25:50.171]   - Field: ‘job’
[10:25:50.171]   - Field: ‘conditions’
[10:25:50.171]   - Field: ‘expr’
[10:25:50.172]   - Field: ‘uuid’
[10:25:50.172]   - Field: ‘seed’
[10:25:50.172]   - Field: ‘version’
[10:25:50.172]   - Field: ‘result’
[10:25:50.172]   - Field: ‘asynchronous’
[10:25:50.172]   - Field: ‘calls’
[10:25:50.173]   - Field: ‘globals’
[10:25:50.173]   - Field: ‘stdout’
[10:25:50.173]   - Field: ‘earlySignal’
[10:25:50.173]   - Field: ‘lazy’
[10:25:50.173]   - Field: ‘state’
[10:25:50.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.174] - Launch lazy future ...
[10:25:50.174] Packages needed by the future expression (n = 0): <none>
[10:25:50.175] Packages needed by future strategies (n = 0): <none>
[10:25:50.175] {
[10:25:50.175]     {
[10:25:50.175]         {
[10:25:50.175]             ...future.startTime <- base::Sys.time()
[10:25:50.175]             {
[10:25:50.175]                 {
[10:25:50.175]                   {
[10:25:50.175]                     {
[10:25:50.175]                       base::local({
[10:25:50.175]                         has_future <- base::requireNamespace("future", 
[10:25:50.175]                           quietly = TRUE)
[10:25:50.175]                         if (has_future) {
[10:25:50.175]                           ns <- base::getNamespace("future")
[10:25:50.175]                           version <- ns[[".package"]][["version"]]
[10:25:50.175]                           if (is.null(version)) 
[10:25:50.175]                             version <- utils::packageVersion("future")
[10:25:50.175]                         }
[10:25:50.175]                         else {
[10:25:50.175]                           version <- NULL
[10:25:50.175]                         }
[10:25:50.175]                         if (!has_future || version < "1.8.0") {
[10:25:50.175]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.175]                             "", base::R.version$version.string), 
[10:25:50.175]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.175]                               "release", "version")], collapse = " "), 
[10:25:50.175]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.175]                             info)
[10:25:50.175]                           info <- base::paste(info, collapse = "; ")
[10:25:50.175]                           if (!has_future) {
[10:25:50.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.175]                               info)
[10:25:50.175]                           }
[10:25:50.175]                           else {
[10:25:50.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.175]                               info, version)
[10:25:50.175]                           }
[10:25:50.175]                           base::stop(msg)
[10:25:50.175]                         }
[10:25:50.175]                       })
[10:25:50.175]                     }
[10:25:50.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.175]                     base::options(mc.cores = 1L)
[10:25:50.175]                   }
[10:25:50.175]                   options(future.plan = NULL)
[10:25:50.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.175]                 }
[10:25:50.175]                 ...future.workdir <- getwd()
[10:25:50.175]             }
[10:25:50.175]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.175]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.175]         }
[10:25:50.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.175]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.175]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.175]             base::names(...future.oldOptions))
[10:25:50.175]     }
[10:25:50.175]     if (FALSE) {
[10:25:50.175]     }
[10:25:50.175]     else {
[10:25:50.175]         if (TRUE) {
[10:25:50.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.175]                 open = "w")
[10:25:50.175]         }
[10:25:50.175]         else {
[10:25:50.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.175]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.175]         }
[10:25:50.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.175]             base::sink(type = "output", split = FALSE)
[10:25:50.175]             base::close(...future.stdout)
[10:25:50.175]         }, add = TRUE)
[10:25:50.175]     }
[10:25:50.175]     ...future.frame <- base::sys.nframe()
[10:25:50.175]     ...future.conditions <- base::list()
[10:25:50.175]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.175]     if (FALSE) {
[10:25:50.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.175]     }
[10:25:50.175]     ...future.result <- base::tryCatch({
[10:25:50.175]         base::withCallingHandlers({
[10:25:50.175]             ...future.value <- base::withVisible(base::local({
[10:25:50.175]                 withCallingHandlers({
[10:25:50.175]                   NULL
[10:25:50.175]                 }, immediateCondition = function(cond) {
[10:25:50.175]                   save_rds <- function (object, pathname, ...) 
[10:25:50.175]                   {
[10:25:50.175]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.175]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.175]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.175]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.175]                         fi_tmp[["mtime"]])
[10:25:50.175]                     }
[10:25:50.175]                     tryCatch({
[10:25:50.175]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.175]                     }, error = function(ex) {
[10:25:50.175]                       msg <- conditionMessage(ex)
[10:25:50.175]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.175]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.175]                         fi_tmp[["mtime"]], msg)
[10:25:50.175]                       ex$message <- msg
[10:25:50.175]                       stop(ex)
[10:25:50.175]                     })
[10:25:50.175]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.175]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.175]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.175]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.175]                       fi <- file.info(pathname)
[10:25:50.175]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.175]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.175]                         fi[["size"]], fi[["mtime"]])
[10:25:50.175]                       stop(msg)
[10:25:50.175]                     }
[10:25:50.175]                     invisible(pathname)
[10:25:50.175]                   }
[10:25:50.175]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.175]                     rootPath = tempdir()) 
[10:25:50.175]                   {
[10:25:50.175]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.175]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.175]                       tmpdir = path, fileext = ".rds")
[10:25:50.175]                     save_rds(obj, file)
[10:25:50.175]                   }
[10:25:50.175]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.175]                   {
[10:25:50.175]                     inherits <- base::inherits
[10:25:50.175]                     invokeRestart <- base::invokeRestart
[10:25:50.175]                     is.null <- base::is.null
[10:25:50.175]                     muffled <- FALSE
[10:25:50.175]                     if (inherits(cond, "message")) {
[10:25:50.175]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.175]                       if (muffled) 
[10:25:50.175]                         invokeRestart("muffleMessage")
[10:25:50.175]                     }
[10:25:50.175]                     else if (inherits(cond, "warning")) {
[10:25:50.175]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.175]                       if (muffled) 
[10:25:50.175]                         invokeRestart("muffleWarning")
[10:25:50.175]                     }
[10:25:50.175]                     else if (inherits(cond, "condition")) {
[10:25:50.175]                       if (!is.null(pattern)) {
[10:25:50.175]                         computeRestarts <- base::computeRestarts
[10:25:50.175]                         grepl <- base::grepl
[10:25:50.175]                         restarts <- computeRestarts(cond)
[10:25:50.175]                         for (restart in restarts) {
[10:25:50.175]                           name <- restart$name
[10:25:50.175]                           if (is.null(name)) 
[10:25:50.175]                             next
[10:25:50.175]                           if (!grepl(pattern, name)) 
[10:25:50.175]                             next
[10:25:50.175]                           invokeRestart(restart)
[10:25:50.175]                           muffled <- TRUE
[10:25:50.175]                           break
[10:25:50.175]                         }
[10:25:50.175]                       }
[10:25:50.175]                     }
[10:25:50.175]                     invisible(muffled)
[10:25:50.175]                   }
[10:25:50.175]                   muffleCondition(cond)
[10:25:50.175]                 })
[10:25:50.175]             }))
[10:25:50.175]             future::FutureResult(value = ...future.value$value, 
[10:25:50.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.175]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.175]                     ...future.globalenv.names))
[10:25:50.175]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.175]         }, condition = base::local({
[10:25:50.175]             c <- base::c
[10:25:50.175]             inherits <- base::inherits
[10:25:50.175]             invokeRestart <- base::invokeRestart
[10:25:50.175]             length <- base::length
[10:25:50.175]             list <- base::list
[10:25:50.175]             seq.int <- base::seq.int
[10:25:50.175]             signalCondition <- base::signalCondition
[10:25:50.175]             sys.calls <- base::sys.calls
[10:25:50.175]             `[[` <- base::`[[`
[10:25:50.175]             `+` <- base::`+`
[10:25:50.175]             `<<-` <- base::`<<-`
[10:25:50.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.175]                   3L)]
[10:25:50.175]             }
[10:25:50.175]             function(cond) {
[10:25:50.175]                 is_error <- inherits(cond, "error")
[10:25:50.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.175]                   NULL)
[10:25:50.175]                 if (is_error) {
[10:25:50.175]                   sessionInformation <- function() {
[10:25:50.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.175]                       search = base::search(), system = base::Sys.info())
[10:25:50.175]                   }
[10:25:50.175]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.175]                     cond$call), session = sessionInformation(), 
[10:25:50.175]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.175]                   signalCondition(cond)
[10:25:50.175]                 }
[10:25:50.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.175]                 "immediateCondition"))) {
[10:25:50.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.175]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.175]                   if (TRUE && !signal) {
[10:25:50.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.175]                     {
[10:25:50.175]                       inherits <- base::inherits
[10:25:50.175]                       invokeRestart <- base::invokeRestart
[10:25:50.175]                       is.null <- base::is.null
[10:25:50.175]                       muffled <- FALSE
[10:25:50.175]                       if (inherits(cond, "message")) {
[10:25:50.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.175]                         if (muffled) 
[10:25:50.175]                           invokeRestart("muffleMessage")
[10:25:50.175]                       }
[10:25:50.175]                       else if (inherits(cond, "warning")) {
[10:25:50.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.175]                         if (muffled) 
[10:25:50.175]                           invokeRestart("muffleWarning")
[10:25:50.175]                       }
[10:25:50.175]                       else if (inherits(cond, "condition")) {
[10:25:50.175]                         if (!is.null(pattern)) {
[10:25:50.175]                           computeRestarts <- base::computeRestarts
[10:25:50.175]                           grepl <- base::grepl
[10:25:50.175]                           restarts <- computeRestarts(cond)
[10:25:50.175]                           for (restart in restarts) {
[10:25:50.175]                             name <- restart$name
[10:25:50.175]                             if (is.null(name)) 
[10:25:50.175]                               next
[10:25:50.175]                             if (!grepl(pattern, name)) 
[10:25:50.175]                               next
[10:25:50.175]                             invokeRestart(restart)
[10:25:50.175]                             muffled <- TRUE
[10:25:50.175]                             break
[10:25:50.175]                           }
[10:25:50.175]                         }
[10:25:50.175]                       }
[10:25:50.175]                       invisible(muffled)
[10:25:50.175]                     }
[10:25:50.175]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.175]                   }
[10:25:50.175]                 }
[10:25:50.175]                 else {
[10:25:50.175]                   if (TRUE) {
[10:25:50.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.175]                     {
[10:25:50.175]                       inherits <- base::inherits
[10:25:50.175]                       invokeRestart <- base::invokeRestart
[10:25:50.175]                       is.null <- base::is.null
[10:25:50.175]                       muffled <- FALSE
[10:25:50.175]                       if (inherits(cond, "message")) {
[10:25:50.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.175]                         if (muffled) 
[10:25:50.175]                           invokeRestart("muffleMessage")
[10:25:50.175]                       }
[10:25:50.175]                       else if (inherits(cond, "warning")) {
[10:25:50.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.175]                         if (muffled) 
[10:25:50.175]                           invokeRestart("muffleWarning")
[10:25:50.175]                       }
[10:25:50.175]                       else if (inherits(cond, "condition")) {
[10:25:50.175]                         if (!is.null(pattern)) {
[10:25:50.175]                           computeRestarts <- base::computeRestarts
[10:25:50.175]                           grepl <- base::grepl
[10:25:50.175]                           restarts <- computeRestarts(cond)
[10:25:50.175]                           for (restart in restarts) {
[10:25:50.175]                             name <- restart$name
[10:25:50.175]                             if (is.null(name)) 
[10:25:50.175]                               next
[10:25:50.175]                             if (!grepl(pattern, name)) 
[10:25:50.175]                               next
[10:25:50.175]                             invokeRestart(restart)
[10:25:50.175]                             muffled <- TRUE
[10:25:50.175]                             break
[10:25:50.175]                           }
[10:25:50.175]                         }
[10:25:50.175]                       }
[10:25:50.175]                       invisible(muffled)
[10:25:50.175]                     }
[10:25:50.175]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.175]                   }
[10:25:50.175]                 }
[10:25:50.175]             }
[10:25:50.175]         }))
[10:25:50.175]     }, error = function(ex) {
[10:25:50.175]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.175]                 ...future.rng), started = ...future.startTime, 
[10:25:50.175]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.175]             version = "1.8"), class = "FutureResult")
[10:25:50.175]     }, finally = {
[10:25:50.175]         if (!identical(...future.workdir, getwd())) 
[10:25:50.175]             setwd(...future.workdir)
[10:25:50.175]         {
[10:25:50.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.175]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.175]             }
[10:25:50.175]             base::options(...future.oldOptions)
[10:25:50.175]             if (.Platform$OS.type == "windows") {
[10:25:50.175]                 old_names <- names(...future.oldEnvVars)
[10:25:50.175]                 envs <- base::Sys.getenv()
[10:25:50.175]                 names <- names(envs)
[10:25:50.175]                 common <- intersect(names, old_names)
[10:25:50.175]                 added <- setdiff(names, old_names)
[10:25:50.175]                 removed <- setdiff(old_names, names)
[10:25:50.175]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.175]                   envs[common]]
[10:25:50.175]                 NAMES <- toupper(changed)
[10:25:50.175]                 args <- list()
[10:25:50.175]                 for (kk in seq_along(NAMES)) {
[10:25:50.175]                   name <- changed[[kk]]
[10:25:50.175]                   NAME <- NAMES[[kk]]
[10:25:50.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.175]                     next
[10:25:50.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.175]                 }
[10:25:50.175]                 NAMES <- toupper(added)
[10:25:50.175]                 for (kk in seq_along(NAMES)) {
[10:25:50.175]                   name <- added[[kk]]
[10:25:50.175]                   NAME <- NAMES[[kk]]
[10:25:50.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.175]                     next
[10:25:50.175]                   args[[name]] <- ""
[10:25:50.175]                 }
[10:25:50.175]                 NAMES <- toupper(removed)
[10:25:50.175]                 for (kk in seq_along(NAMES)) {
[10:25:50.175]                   name <- removed[[kk]]
[10:25:50.175]                   NAME <- NAMES[[kk]]
[10:25:50.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.175]                     next
[10:25:50.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.175]                 }
[10:25:50.175]                 if (length(args) > 0) 
[10:25:50.175]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.175]             }
[10:25:50.175]             else {
[10:25:50.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.175]             }
[10:25:50.175]             {
[10:25:50.175]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.175]                   0L) {
[10:25:50.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.175]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.175]                   base::options(opts)
[10:25:50.175]                 }
[10:25:50.175]                 {
[10:25:50.175]                   {
[10:25:50.175]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.175]                     NULL
[10:25:50.175]                   }
[10:25:50.175]                   options(future.plan = NULL)
[10:25:50.175]                   if (is.na(NA_character_)) 
[10:25:50.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.175]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.175]                     envir = parent.frame()) 
[10:25:50.175]                   {
[10:25:50.175]                     default_workers <- missing(workers)
[10:25:50.175]                     if (is.function(workers)) 
[10:25:50.175]                       workers <- workers()
[10:25:50.175]                     workers <- structure(as.integer(workers), 
[10:25:50.175]                       class = class(workers))
[10:25:50.175]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.175]                       1L)
[10:25:50.175]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.175]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.175]                       if (default_workers) 
[10:25:50.175]                         supportsMulticore(warn = TRUE)
[10:25:50.175]                       return(sequential(..., envir = envir))
[10:25:50.175]                     }
[10:25:50.175]                     oopts <- options(mc.cores = workers)
[10:25:50.175]                     on.exit(options(oopts))
[10:25:50.175]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.175]                       envir = envir)
[10:25:50.175]                     if (!future$lazy) 
[10:25:50.175]                       future <- run(future)
[10:25:50.175]                     invisible(future)
[10:25:50.175]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.175]                 }
[10:25:50.175]             }
[10:25:50.175]         }
[10:25:50.175]     })
[10:25:50.175]     if (TRUE) {
[10:25:50.175]         base::sink(type = "output", split = FALSE)
[10:25:50.175]         if (TRUE) {
[10:25:50.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.175]         }
[10:25:50.175]         else {
[10:25:50.175]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.175]         }
[10:25:50.175]         base::close(...future.stdout)
[10:25:50.175]         ...future.stdout <- NULL
[10:25:50.175]     }
[10:25:50.175]     ...future.result$conditions <- ...future.conditions
[10:25:50.175]     ...future.result$finished <- base::Sys.time()
[10:25:50.175]     ...future.result
[10:25:50.175] }
[10:25:50.179] requestCore(): workers = 2
[10:25:50.182] MulticoreFuture started
[10:25:50.183] - Launch lazy future ... done
[10:25:50.183] run() for ‘MulticoreFuture’ ... done
[10:25:50.183] plan(): Setting new future strategy stack:
[10:25:50.184] getGlobalsAndPackages() ...
[10:25:50.184] Searching for globals...
[10:25:50.184] List of future strategies:
[10:25:50.184] 1. sequential:
[10:25:50.184]    - args: function (..., envir = parent.frame())
[10:25:50.184]    - tweaked: FALSE
[10:25:50.184]    - call: NULL
[10:25:50.185] plan(): nbrOfWorkers() = 1
[10:25:50.186] - globals found: [1] ‘{’
[10:25:50.186] Searching for globals ... DONE
[10:25:50.186] Resolving globals: FALSE
[10:25:50.186] 
[10:25:50.187] plan(): Setting new future strategy stack:
[10:25:50.187] 
[10:25:50.187] getGlobalsAndPackages() ... DONE
[10:25:50.187] List of future strategies:
[10:25:50.187] 1. multicore:
[10:25:50.187]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.187]    - tweaked: FALSE
[10:25:50.187]    - call: plan(strategy)
[10:25:50.187] run() for ‘Future’ ...
[10:25:50.187] - state: ‘created’
[10:25:50.188] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.192] plan(): nbrOfWorkers() = 2
[10:25:50.192] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.193]   - Field: ‘label’
[10:25:50.193]   - Field: ‘local’
[10:25:50.193]   - Field: ‘owner’
[10:25:50.193]   - Field: ‘envir’
[10:25:50.193]   - Field: ‘workers’
[10:25:50.194]   - Field: ‘packages’
[10:25:50.194]   - Field: ‘gc’
[10:25:50.194]   - Field: ‘job’
[10:25:50.194]   - Field: ‘conditions’
[10:25:50.194]   - Field: ‘expr’
[10:25:50.194]   - Field: ‘uuid’
[10:25:50.194]   - Field: ‘seed’
[10:25:50.195]   - Field: ‘version’
[10:25:50.195]   - Field: ‘result’
[10:25:50.195]   - Field: ‘asynchronous’
[10:25:50.195]   - Field: ‘calls’
[10:25:50.195]   - Field: ‘globals’
[10:25:50.195]   - Field: ‘stdout’
[10:25:50.195]   - Field: ‘earlySignal’
[10:25:50.195]   - Field: ‘lazy’
[10:25:50.196]   - Field: ‘state’
[10:25:50.196] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.196] - Launch lazy future ...
[10:25:50.196] Packages needed by the future expression (n = 0): <none>
[10:25:50.197] Packages needed by future strategies (n = 0): <none>
[10:25:50.197] {
[10:25:50.197]     {
[10:25:50.197]         {
[10:25:50.197]             ...future.startTime <- base::Sys.time()
[10:25:50.197]             {
[10:25:50.197]                 {
[10:25:50.197]                   {
[10:25:50.197]                     {
[10:25:50.197]                       base::local({
[10:25:50.197]                         has_future <- base::requireNamespace("future", 
[10:25:50.197]                           quietly = TRUE)
[10:25:50.197]                         if (has_future) {
[10:25:50.197]                           ns <- base::getNamespace("future")
[10:25:50.197]                           version <- ns[[".package"]][["version"]]
[10:25:50.197]                           if (is.null(version)) 
[10:25:50.197]                             version <- utils::packageVersion("future")
[10:25:50.197]                         }
[10:25:50.197]                         else {
[10:25:50.197]                           version <- NULL
[10:25:50.197]                         }
[10:25:50.197]                         if (!has_future || version < "1.8.0") {
[10:25:50.197]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.197]                             "", base::R.version$version.string), 
[10:25:50.197]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.197]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.197]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.197]                               "release", "version")], collapse = " "), 
[10:25:50.197]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.197]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.197]                             info)
[10:25:50.197]                           info <- base::paste(info, collapse = "; ")
[10:25:50.197]                           if (!has_future) {
[10:25:50.197]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.197]                               info)
[10:25:50.197]                           }
[10:25:50.197]                           else {
[10:25:50.197]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.197]                               info, version)
[10:25:50.197]                           }
[10:25:50.197]                           base::stop(msg)
[10:25:50.197]                         }
[10:25:50.197]                       })
[10:25:50.197]                     }
[10:25:50.197]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.197]                     base::options(mc.cores = 1L)
[10:25:50.197]                   }
[10:25:50.197]                   options(future.plan = NULL)
[10:25:50.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.197]                 }
[10:25:50.197]                 ...future.workdir <- getwd()
[10:25:50.197]             }
[10:25:50.197]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.197]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.197]         }
[10:25:50.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.197]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.197]             base::names(...future.oldOptions))
[10:25:50.197]     }
[10:25:50.197]     if (FALSE) {
[10:25:50.197]     }
[10:25:50.197]     else {
[10:25:50.197]         if (TRUE) {
[10:25:50.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.197]                 open = "w")
[10:25:50.197]         }
[10:25:50.197]         else {
[10:25:50.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.197]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.197]         }
[10:25:50.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.197]             base::sink(type = "output", split = FALSE)
[10:25:50.197]             base::close(...future.stdout)
[10:25:50.197]         }, add = TRUE)
[10:25:50.197]     }
[10:25:50.197]     ...future.frame <- base::sys.nframe()
[10:25:50.197]     ...future.conditions <- base::list()
[10:25:50.197]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.197]     if (FALSE) {
[10:25:50.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.197]     }
[10:25:50.197]     ...future.result <- base::tryCatch({
[10:25:50.197]         base::withCallingHandlers({
[10:25:50.197]             ...future.value <- base::withVisible(base::local({
[10:25:50.197]                 withCallingHandlers({
[10:25:50.197]                   {
[10:25:50.197]                     4
[10:25:50.197]                   }
[10:25:50.197]                 }, immediateCondition = function(cond) {
[10:25:50.197]                   save_rds <- function (object, pathname, ...) 
[10:25:50.197]                   {
[10:25:50.197]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.197]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.197]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.197]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.197]                         fi_tmp[["mtime"]])
[10:25:50.197]                     }
[10:25:50.197]                     tryCatch({
[10:25:50.197]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.197]                     }, error = function(ex) {
[10:25:50.197]                       msg <- conditionMessage(ex)
[10:25:50.197]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.197]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.197]                         fi_tmp[["mtime"]], msg)
[10:25:50.197]                       ex$message <- msg
[10:25:50.197]                       stop(ex)
[10:25:50.197]                     })
[10:25:50.197]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.197]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.197]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.197]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.197]                       fi <- file.info(pathname)
[10:25:50.197]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.197]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.197]                         fi[["size"]], fi[["mtime"]])
[10:25:50.197]                       stop(msg)
[10:25:50.197]                     }
[10:25:50.197]                     invisible(pathname)
[10:25:50.197]                   }
[10:25:50.197]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.197]                     rootPath = tempdir()) 
[10:25:50.197]                   {
[10:25:50.197]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.197]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.197]                       tmpdir = path, fileext = ".rds")
[10:25:50.197]                     save_rds(obj, file)
[10:25:50.197]                   }
[10:25:50.197]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.197]                   {
[10:25:50.197]                     inherits <- base::inherits
[10:25:50.197]                     invokeRestart <- base::invokeRestart
[10:25:50.197]                     is.null <- base::is.null
[10:25:50.197]                     muffled <- FALSE
[10:25:50.197]                     if (inherits(cond, "message")) {
[10:25:50.197]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.197]                       if (muffled) 
[10:25:50.197]                         invokeRestart("muffleMessage")
[10:25:50.197]                     }
[10:25:50.197]                     else if (inherits(cond, "warning")) {
[10:25:50.197]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.197]                       if (muffled) 
[10:25:50.197]                         invokeRestart("muffleWarning")
[10:25:50.197]                     }
[10:25:50.197]                     else if (inherits(cond, "condition")) {
[10:25:50.197]                       if (!is.null(pattern)) {
[10:25:50.197]                         computeRestarts <- base::computeRestarts
[10:25:50.197]                         grepl <- base::grepl
[10:25:50.197]                         restarts <- computeRestarts(cond)
[10:25:50.197]                         for (restart in restarts) {
[10:25:50.197]                           name <- restart$name
[10:25:50.197]                           if (is.null(name)) 
[10:25:50.197]                             next
[10:25:50.197]                           if (!grepl(pattern, name)) 
[10:25:50.197]                             next
[10:25:50.197]                           invokeRestart(restart)
[10:25:50.197]                           muffled <- TRUE
[10:25:50.197]                           break
[10:25:50.197]                         }
[10:25:50.197]                       }
[10:25:50.197]                     }
[10:25:50.197]                     invisible(muffled)
[10:25:50.197]                   }
[10:25:50.197]                   muffleCondition(cond)
[10:25:50.197]                 })
[10:25:50.197]             }))
[10:25:50.197]             future::FutureResult(value = ...future.value$value, 
[10:25:50.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.197]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.197]                     ...future.globalenv.names))
[10:25:50.197]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.197]         }, condition = base::local({
[10:25:50.197]             c <- base::c
[10:25:50.197]             inherits <- base::inherits
[10:25:50.197]             invokeRestart <- base::invokeRestart
[10:25:50.197]             length <- base::length
[10:25:50.197]             list <- base::list
[10:25:50.197]             seq.int <- base::seq.int
[10:25:50.197]             signalCondition <- base::signalCondition
[10:25:50.197]             sys.calls <- base::sys.calls
[10:25:50.197]             `[[` <- base::`[[`
[10:25:50.197]             `+` <- base::`+`
[10:25:50.197]             `<<-` <- base::`<<-`
[10:25:50.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.197]                   3L)]
[10:25:50.197]             }
[10:25:50.197]             function(cond) {
[10:25:50.197]                 is_error <- inherits(cond, "error")
[10:25:50.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.197]                   NULL)
[10:25:50.197]                 if (is_error) {
[10:25:50.197]                   sessionInformation <- function() {
[10:25:50.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.197]                       search = base::search(), system = base::Sys.info())
[10:25:50.197]                   }
[10:25:50.197]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.197]                     cond$call), session = sessionInformation(), 
[10:25:50.197]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.197]                   signalCondition(cond)
[10:25:50.197]                 }
[10:25:50.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.197]                 "immediateCondition"))) {
[10:25:50.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.197]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.197]                   if (TRUE && !signal) {
[10:25:50.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.197]                     {
[10:25:50.197]                       inherits <- base::inherits
[10:25:50.197]                       invokeRestart <- base::invokeRestart
[10:25:50.197]                       is.null <- base::is.null
[10:25:50.197]                       muffled <- FALSE
[10:25:50.197]                       if (inherits(cond, "message")) {
[10:25:50.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.197]                         if (muffled) 
[10:25:50.197]                           invokeRestart("muffleMessage")
[10:25:50.197]                       }
[10:25:50.197]                       else if (inherits(cond, "warning")) {
[10:25:50.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.197]                         if (muffled) 
[10:25:50.197]                           invokeRestart("muffleWarning")
[10:25:50.197]                       }
[10:25:50.197]                       else if (inherits(cond, "condition")) {
[10:25:50.197]                         if (!is.null(pattern)) {
[10:25:50.197]                           computeRestarts <- base::computeRestarts
[10:25:50.197]                           grepl <- base::grepl
[10:25:50.197]                           restarts <- computeRestarts(cond)
[10:25:50.197]                           for (restart in restarts) {
[10:25:50.197]                             name <- restart$name
[10:25:50.197]                             if (is.null(name)) 
[10:25:50.197]                               next
[10:25:50.197]                             if (!grepl(pattern, name)) 
[10:25:50.197]                               next
[10:25:50.197]                             invokeRestart(restart)
[10:25:50.197]                             muffled <- TRUE
[10:25:50.197]                             break
[10:25:50.197]                           }
[10:25:50.197]                         }
[10:25:50.197]                       }
[10:25:50.197]                       invisible(muffled)
[10:25:50.197]                     }
[10:25:50.197]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.197]                   }
[10:25:50.197]                 }
[10:25:50.197]                 else {
[10:25:50.197]                   if (TRUE) {
[10:25:50.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.197]                     {
[10:25:50.197]                       inherits <- base::inherits
[10:25:50.197]                       invokeRestart <- base::invokeRestart
[10:25:50.197]                       is.null <- base::is.null
[10:25:50.197]                       muffled <- FALSE
[10:25:50.197]                       if (inherits(cond, "message")) {
[10:25:50.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.197]                         if (muffled) 
[10:25:50.197]                           invokeRestart("muffleMessage")
[10:25:50.197]                       }
[10:25:50.197]                       else if (inherits(cond, "warning")) {
[10:25:50.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.197]                         if (muffled) 
[10:25:50.197]                           invokeRestart("muffleWarning")
[10:25:50.197]                       }
[10:25:50.197]                       else if (inherits(cond, "condition")) {
[10:25:50.197]                         if (!is.null(pattern)) {
[10:25:50.197]                           computeRestarts <- base::computeRestarts
[10:25:50.197]                           grepl <- base::grepl
[10:25:50.197]                           restarts <- computeRestarts(cond)
[10:25:50.197]                           for (restart in restarts) {
[10:25:50.197]                             name <- restart$name
[10:25:50.197]                             if (is.null(name)) 
[10:25:50.197]                               next
[10:25:50.197]                             if (!grepl(pattern, name)) 
[10:25:50.197]                               next
[10:25:50.197]                             invokeRestart(restart)
[10:25:50.197]                             muffled <- TRUE
[10:25:50.197]                             break
[10:25:50.197]                           }
[10:25:50.197]                         }
[10:25:50.197]                       }
[10:25:50.197]                       invisible(muffled)
[10:25:50.197]                     }
[10:25:50.197]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.197]                   }
[10:25:50.197]                 }
[10:25:50.197]             }
[10:25:50.197]         }))
[10:25:50.197]     }, error = function(ex) {
[10:25:50.197]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.197]                 ...future.rng), started = ...future.startTime, 
[10:25:50.197]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.197]             version = "1.8"), class = "FutureResult")
[10:25:50.197]     }, finally = {
[10:25:50.197]         if (!identical(...future.workdir, getwd())) 
[10:25:50.197]             setwd(...future.workdir)
[10:25:50.197]         {
[10:25:50.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.197]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.197]             }
[10:25:50.197]             base::options(...future.oldOptions)
[10:25:50.197]             if (.Platform$OS.type == "windows") {
[10:25:50.197]                 old_names <- names(...future.oldEnvVars)
[10:25:50.197]                 envs <- base::Sys.getenv()
[10:25:50.197]                 names <- names(envs)
[10:25:50.197]                 common <- intersect(names, old_names)
[10:25:50.197]                 added <- setdiff(names, old_names)
[10:25:50.197]                 removed <- setdiff(old_names, names)
[10:25:50.197]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.197]                   envs[common]]
[10:25:50.197]                 NAMES <- toupper(changed)
[10:25:50.197]                 args <- list()
[10:25:50.197]                 for (kk in seq_along(NAMES)) {
[10:25:50.197]                   name <- changed[[kk]]
[10:25:50.197]                   NAME <- NAMES[[kk]]
[10:25:50.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.197]                     next
[10:25:50.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.197]                 }
[10:25:50.197]                 NAMES <- toupper(added)
[10:25:50.197]                 for (kk in seq_along(NAMES)) {
[10:25:50.197]                   name <- added[[kk]]
[10:25:50.197]                   NAME <- NAMES[[kk]]
[10:25:50.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.197]                     next
[10:25:50.197]                   args[[name]] <- ""
[10:25:50.197]                 }
[10:25:50.197]                 NAMES <- toupper(removed)
[10:25:50.197]                 for (kk in seq_along(NAMES)) {
[10:25:50.197]                   name <- removed[[kk]]
[10:25:50.197]                   NAME <- NAMES[[kk]]
[10:25:50.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.197]                     next
[10:25:50.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.197]                 }
[10:25:50.197]                 if (length(args) > 0) 
[10:25:50.197]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.197]             }
[10:25:50.197]             else {
[10:25:50.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.197]             }
[10:25:50.197]             {
[10:25:50.197]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.197]                   0L) {
[10:25:50.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.197]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.197]                   base::options(opts)
[10:25:50.197]                 }
[10:25:50.197]                 {
[10:25:50.197]                   {
[10:25:50.197]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.197]                     NULL
[10:25:50.197]                   }
[10:25:50.197]                   options(future.plan = NULL)
[10:25:50.197]                   if (is.na(NA_character_)) 
[10:25:50.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.197]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.197]                     envir = parent.frame()) 
[10:25:50.197]                   {
[10:25:50.197]                     default_workers <- missing(workers)
[10:25:50.197]                     if (is.function(workers)) 
[10:25:50.197]                       workers <- workers()
[10:25:50.197]                     workers <- structure(as.integer(workers), 
[10:25:50.197]                       class = class(workers))
[10:25:50.197]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.197]                       1L)
[10:25:50.197]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.197]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.197]                       if (default_workers) 
[10:25:50.197]                         supportsMulticore(warn = TRUE)
[10:25:50.197]                       return(sequential(..., envir = envir))
[10:25:50.197]                     }
[10:25:50.197]                     oopts <- options(mc.cores = workers)
[10:25:50.197]                     on.exit(options(oopts))
[10:25:50.197]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.197]                       envir = envir)
[10:25:50.197]                     if (!future$lazy) 
[10:25:50.197]                       future <- run(future)
[10:25:50.197]                     invisible(future)
[10:25:50.197]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.197]                 }
[10:25:50.197]             }
[10:25:50.197]         }
[10:25:50.197]     })
[10:25:50.197]     if (TRUE) {
[10:25:50.197]         base::sink(type = "output", split = FALSE)
[10:25:50.197]         if (TRUE) {
[10:25:50.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.197]         }
[10:25:50.197]         else {
[10:25:50.197]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.197]         }
[10:25:50.197]         base::close(...future.stdout)
[10:25:50.197]         ...future.stdout <- NULL
[10:25:50.197]     }
[10:25:50.197]     ...future.result$conditions <- ...future.conditions
[10:25:50.197]     ...future.result$finished <- base::Sys.time()
[10:25:50.197]     ...future.result
[10:25:50.197] }
[10:25:50.201] requestCore(): workers = 2
[10:25:50.201] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:50.212] result() for MulticoreFuture ...
[10:25:50.213] result() for MulticoreFuture ...
[10:25:50.213] result() for MulticoreFuture ... done
[10:25:50.214] result() for MulticoreFuture ... done
[10:25:50.214] result() for MulticoreFuture ...
[10:25:50.214] result() for MulticoreFuture ... done
[10:25:50.216] MulticoreFuture started
[10:25:50.217] - Launch lazy future ... done
[10:25:50.217] run() for ‘MulticoreFuture’ ... done
[10:25:50.218] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c0f50e4370> 
[10:25:50.218] List of future strategies:
[10:25:50.218] 1. sequential:
[10:25:50.218]    - args: function (..., envir = parent.frame())
[10:25:50.218]    - tweaked: FALSE
[10:25:50.218]    - call: NULL
[10:25:50.219] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55c0f627b230> 
 - attr(*, "dim.")=[10:25:50.222] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=[10:25:50.222] List of future strategies:
[10:25:50.222] 1. multicore:
[10:25:50.222]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.222]    - tweaked: FALSE
[10:25:50.222]    - call: plan(strategy)
List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:25:50.229] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:50.232] resolve() on list environment ...
[10:25:50.232]  recursive: 0
[10:25:50.234]  length: 6
[10:25:50.234]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:50.234] signalConditionsASAP(numeric, pos=1) ...
[10:25:50.234] - nx: 6
[10:25:50.234] - relay: TRUE
[10:25:50.235] - stdout: TRUE
[10:25:50.235] - signal: TRUE
[10:25:50.235] - resignal: FALSE
[10:25:50.235] - force: TRUE
[10:25:50.235] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.235] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.235]  - until=2
[10:25:50.235]  - relaying element #2
[10:25:50.236] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.236] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.236] signalConditionsASAP(NULL, pos=1) ... done
[10:25:50.236]  length: 5 (resolved future 1)
[10:25:50.236] Future #2
[10:25:50.236] result() for MulticoreFuture ...
[10:25:50.236] result() for MulticoreFuture ... done
[10:25:50.237] result() for MulticoreFuture ...
[10:25:50.237] result() for MulticoreFuture ... done
[10:25:50.237] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:50.237] - nx: 6
[10:25:50.237] - relay: TRUE
[10:25:50.237] - stdout: TRUE
[10:25:50.237] - signal: TRUE
[10:25:50.238] - resignal: FALSE
[10:25:50.238] - force: TRUE
[10:25:50.238] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.238] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.238]  - until=2
[10:25:50.238]  - relaying element #2
[10:25:50.238] result() for MulticoreFuture ...
[10:25:50.238] result() for MulticoreFuture ... done
[10:25:50.239] result() for MulticoreFuture ...
[10:25:50.239] result() for MulticoreFuture ... done
[10:25:50.239] result() for MulticoreFuture ...
[10:25:50.239] result() for MulticoreFuture ... done
[10:25:50.239] result() for MulticoreFuture ...
[10:25:50.239] result() for MulticoreFuture ... done
[10:25:50.239] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.240] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.240] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:50.240]  length: 4 (resolved future 2)
[10:25:50.240] Future #3
[10:25:50.240] result() for MulticoreFuture ...
[10:25:50.241] result() for MulticoreFuture ...
[10:25:50.241] result() for MulticoreFuture ... done
[10:25:50.242] result() for MulticoreFuture ... done
[10:25:50.242] result() for MulticoreFuture ...
[10:25:50.242] result() for MulticoreFuture ... done
[10:25:50.242] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:50.242] - nx: 6
[10:25:50.242] - relay: TRUE
[10:25:50.242] - stdout: TRUE
[10:25:50.242] - signal: TRUE
[10:25:50.243] - resignal: FALSE
[10:25:50.243] - force: TRUE
[10:25:50.243] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.243] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.243]  - until=3
[10:25:50.243]  - relaying element #3
[10:25:50.243] result() for MulticoreFuture ...
[10:25:50.243] result() for MulticoreFuture ... done
[10:25:50.244] result() for MulticoreFuture ...
[10:25:50.244] result() for MulticoreFuture ... done
[10:25:50.244] result() for MulticoreFuture ...
[10:25:50.244] result() for MulticoreFuture ... done
[10:25:50.244] result() for MulticoreFuture ...
[10:25:50.244] result() for MulticoreFuture ... done
[10:25:50.244] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.245] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.245] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:50.245]  length: 3 (resolved future 3)
[10:25:50.245] Future #4
[10:25:50.245] result() for MulticoreFuture ...
[10:25:50.246] result() for MulticoreFuture ...
[10:25:50.246] result() for MulticoreFuture ... done
[10:25:50.246] result() for MulticoreFuture ... done
[10:25:50.247] result() for MulticoreFuture ...
[10:25:50.247] result() for MulticoreFuture ... done
[10:25:50.247] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:50.247] - nx: 6
[10:25:50.247] - relay: TRUE
[10:25:50.247] - stdout: TRUE
[10:25:50.248] - signal: TRUE
[10:25:50.248] - resignal: FALSE
[10:25:50.248] - force: TRUE
[10:25:50.248] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.248] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.248]  - until=4
[10:25:50.249]  - relaying element #4
[10:25:50.249] result() for MulticoreFuture ...
[10:25:50.249] result() for MulticoreFuture ... done
[10:25:50.249] result() for MulticoreFuture ...
[10:25:50.249] result() for MulticoreFuture ... done
[10:25:50.249] result() for MulticoreFuture ...
[10:25:50.250] result() for MulticoreFuture ... done
[10:25:50.250] result() for MulticoreFuture ...
[10:25:50.250] result() for MulticoreFuture ... done
[10:25:50.250] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.250] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.250] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:50.250]  length: 2 (resolved future 4)
[10:25:50.250] signalConditionsASAP(NULL, pos=5) ...
[10:25:50.250] - nx: 6
[10:25:50.251] - relay: TRUE
[10:25:50.251] - stdout: TRUE
[10:25:50.251] - signal: TRUE
[10:25:50.251] - resignal: FALSE
[10:25:50.251] - force: TRUE
[10:25:50.251] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.251] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.251]  - until=6
[10:25:50.251]  - relaying element #6
[10:25:50.251] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.252] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.252] signalConditionsASAP(NULL, pos=5) ... done
[10:25:50.252]  length: 1 (resolved future 5)
[10:25:50.252] signalConditionsASAP(numeric, pos=6) ...
[10:25:50.252] - nx: 6
[10:25:50.252] - relay: TRUE
[10:25:50.252] - stdout: TRUE
[10:25:50.252] - signal: TRUE
[10:25:50.252] - resignal: FALSE
[10:25:50.252] - force: TRUE
[10:25:50.253] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.253] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.253]  - until=6
[10:25:50.253] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.253] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.253] signalConditionsASAP(numeric, pos=6) ... done
[10:25:50.253]  length: 0 (resolved future 6)
[10:25:50.253] Relaying remaining futures
[10:25:50.253] signalConditionsASAP(NULL, pos=0) ...
[10:25:50.253] - nx: 6
[10:25:50.254] - relay: TRUE
[10:25:50.254] - stdout: TRUE
[10:25:50.254] - signal: TRUE
[10:25:50.254] - resignal: FALSE
[10:25:50.254] - force: TRUE
[10:25:50.254] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.254] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:50.254] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.254] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.255] signalConditionsASAP(NULL, pos=0) ... done
[10:25:50.255] resolve() on list environment ... DONE
[10:25:50.255] result() for MulticoreFuture ...
[10:25:50.255] result() for MulticoreFuture ... done
[10:25:50.255] result() for MulticoreFuture ...
[10:25:50.255] result() for MulticoreFuture ... done
[10:25:50.255] result() for MulticoreFuture ...
[10:25:50.255] result() for MulticoreFuture ... done
[10:25:50.256] result() for MulticoreFuture ...
[10:25:50.256] result() for MulticoreFuture ... done
[10:25:50.256] result() for MulticoreFuture ...
[10:25:50.256] result() for MulticoreFuture ... done
[10:25:50.256] result() for MulticoreFuture ...
[10:25:50.256] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f6534930> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:25:50.258] getGlobalsAndPackages() ...
[10:25:50.258] Searching for globals...
[10:25:50.259] 
[10:25:50.259] Searching for globals ... DONE
[10:25:50.259] - globals: [0] <none>
[10:25:50.259] getGlobalsAndPackages() ... DONE
[10:25:50.260] run() for ‘Future’ ...
[10:25:50.260] - state: ‘created’
[10:25:50.260] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.264] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.265] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.265]   - Field: ‘label’
[10:25:50.265]   - Field: ‘local’
[10:25:50.265]   - Field: ‘owner’
[10:25:50.265]   - Field: ‘envir’
[10:25:50.265]   - Field: ‘workers’
[10:25:50.265]   - Field: ‘packages’
[10:25:50.265]   - Field: ‘gc’
[10:25:50.266]   - Field: ‘job’
[10:25:50.266]   - Field: ‘conditions’
[10:25:50.266]   - Field: ‘expr’
[10:25:50.266]   - Field: ‘uuid’
[10:25:50.266]   - Field: ‘seed’
[10:25:50.266]   - Field: ‘version’
[10:25:50.266]   - Field: ‘result’
[10:25:50.266]   - Field: ‘asynchronous’
[10:25:50.266]   - Field: ‘calls’
[10:25:50.267]   - Field: ‘globals’
[10:25:50.267]   - Field: ‘stdout’
[10:25:50.267]   - Field: ‘earlySignal’
[10:25:50.267]   - Field: ‘lazy’
[10:25:50.267]   - Field: ‘state’
[10:25:50.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.267] - Launch lazy future ...
[10:25:50.267] Packages needed by the future expression (n = 0): <none>
[10:25:50.268] Packages needed by future strategies (n = 0): <none>
[10:25:50.272] {
[10:25:50.272]     {
[10:25:50.272]         {
[10:25:50.272]             ...future.startTime <- base::Sys.time()
[10:25:50.272]             {
[10:25:50.272]                 {
[10:25:50.272]                   {
[10:25:50.272]                     {
[10:25:50.272]                       base::local({
[10:25:50.272]                         has_future <- base::requireNamespace("future", 
[10:25:50.272]                           quietly = TRUE)
[10:25:50.272]                         if (has_future) {
[10:25:50.272]                           ns <- base::getNamespace("future")
[10:25:50.272]                           version <- ns[[".package"]][["version"]]
[10:25:50.272]                           if (is.null(version)) 
[10:25:50.272]                             version <- utils::packageVersion("future")
[10:25:50.272]                         }
[10:25:50.272]                         else {
[10:25:50.272]                           version <- NULL
[10:25:50.272]                         }
[10:25:50.272]                         if (!has_future || version < "1.8.0") {
[10:25:50.272]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.272]                             "", base::R.version$version.string), 
[10:25:50.272]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.272]                               "release", "version")], collapse = " "), 
[10:25:50.272]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.272]                             info)
[10:25:50.272]                           info <- base::paste(info, collapse = "; ")
[10:25:50.272]                           if (!has_future) {
[10:25:50.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.272]                               info)
[10:25:50.272]                           }
[10:25:50.272]                           else {
[10:25:50.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.272]                               info, version)
[10:25:50.272]                           }
[10:25:50.272]                           base::stop(msg)
[10:25:50.272]                         }
[10:25:50.272]                       })
[10:25:50.272]                     }
[10:25:50.272]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.272]                     base::options(mc.cores = 1L)
[10:25:50.272]                   }
[10:25:50.272]                   options(future.plan = NULL)
[10:25:50.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.272]                 }
[10:25:50.272]                 ...future.workdir <- getwd()
[10:25:50.272]             }
[10:25:50.272]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.272]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.272]         }
[10:25:50.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.272]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.272]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.272]             base::names(...future.oldOptions))
[10:25:50.272]     }
[10:25:50.272]     if (FALSE) {
[10:25:50.272]     }
[10:25:50.272]     else {
[10:25:50.272]         if (TRUE) {
[10:25:50.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.272]                 open = "w")
[10:25:50.272]         }
[10:25:50.272]         else {
[10:25:50.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.272]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.272]         }
[10:25:50.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.272]             base::sink(type = "output", split = FALSE)
[10:25:50.272]             base::close(...future.stdout)
[10:25:50.272]         }, add = TRUE)
[10:25:50.272]     }
[10:25:50.272]     ...future.frame <- base::sys.nframe()
[10:25:50.272]     ...future.conditions <- base::list()
[10:25:50.272]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.272]     if (FALSE) {
[10:25:50.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.272]     }
[10:25:50.272]     ...future.result <- base::tryCatch({
[10:25:50.272]         base::withCallingHandlers({
[10:25:50.272]             ...future.value <- base::withVisible(base::local({
[10:25:50.272]                 withCallingHandlers({
[10:25:50.272]                   2
[10:25:50.272]                 }, immediateCondition = function(cond) {
[10:25:50.272]                   save_rds <- function (object, pathname, ...) 
[10:25:50.272]                   {
[10:25:50.272]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.272]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.272]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.272]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.272]                         fi_tmp[["mtime"]])
[10:25:50.272]                     }
[10:25:50.272]                     tryCatch({
[10:25:50.272]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.272]                     }, error = function(ex) {
[10:25:50.272]                       msg <- conditionMessage(ex)
[10:25:50.272]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.272]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.272]                         fi_tmp[["mtime"]], msg)
[10:25:50.272]                       ex$message <- msg
[10:25:50.272]                       stop(ex)
[10:25:50.272]                     })
[10:25:50.272]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.272]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.272]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.272]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.272]                       fi <- file.info(pathname)
[10:25:50.272]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.272]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.272]                         fi[["size"]], fi[["mtime"]])
[10:25:50.272]                       stop(msg)
[10:25:50.272]                     }
[10:25:50.272]                     invisible(pathname)
[10:25:50.272]                   }
[10:25:50.272]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.272]                     rootPath = tempdir()) 
[10:25:50.272]                   {
[10:25:50.272]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.272]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.272]                       tmpdir = path, fileext = ".rds")
[10:25:50.272]                     save_rds(obj, file)
[10:25:50.272]                   }
[10:25:50.272]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.272]                   {
[10:25:50.272]                     inherits <- base::inherits
[10:25:50.272]                     invokeRestart <- base::invokeRestart
[10:25:50.272]                     is.null <- base::is.null
[10:25:50.272]                     muffled <- FALSE
[10:25:50.272]                     if (inherits(cond, "message")) {
[10:25:50.272]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.272]                       if (muffled) 
[10:25:50.272]                         invokeRestart("muffleMessage")
[10:25:50.272]                     }
[10:25:50.272]                     else if (inherits(cond, "warning")) {
[10:25:50.272]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.272]                       if (muffled) 
[10:25:50.272]                         invokeRestart("muffleWarning")
[10:25:50.272]                     }
[10:25:50.272]                     else if (inherits(cond, "condition")) {
[10:25:50.272]                       if (!is.null(pattern)) {
[10:25:50.272]                         computeRestarts <- base::computeRestarts
[10:25:50.272]                         grepl <- base::grepl
[10:25:50.272]                         restarts <- computeRestarts(cond)
[10:25:50.272]                         for (restart in restarts) {
[10:25:50.272]                           name <- restart$name
[10:25:50.272]                           if (is.null(name)) 
[10:25:50.272]                             next
[10:25:50.272]                           if (!grepl(pattern, name)) 
[10:25:50.272]                             next
[10:25:50.272]                           invokeRestart(restart)
[10:25:50.272]                           muffled <- TRUE
[10:25:50.272]                           break
[10:25:50.272]                         }
[10:25:50.272]                       }
[10:25:50.272]                     }
[10:25:50.272]                     invisible(muffled)
[10:25:50.272]                   }
[10:25:50.272]                   muffleCondition(cond)
[10:25:50.272]                 })
[10:25:50.272]             }))
[10:25:50.272]             future::FutureResult(value = ...future.value$value, 
[10:25:50.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.272]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.272]                     ...future.globalenv.names))
[10:25:50.272]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.272]         }, condition = base::local({
[10:25:50.272]             c <- base::c
[10:25:50.272]             inherits <- base::inherits
[10:25:50.272]             invokeRestart <- base::invokeRestart
[10:25:50.272]             length <- base::length
[10:25:50.272]             list <- base::list
[10:25:50.272]             seq.int <- base::seq.int
[10:25:50.272]             signalCondition <- base::signalCondition
[10:25:50.272]             sys.calls <- base::sys.calls
[10:25:50.272]             `[[` <- base::`[[`
[10:25:50.272]             `+` <- base::`+`
[10:25:50.272]             `<<-` <- base::`<<-`
[10:25:50.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.272]                   3L)]
[10:25:50.272]             }
[10:25:50.272]             function(cond) {
[10:25:50.272]                 is_error <- inherits(cond, "error")
[10:25:50.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.272]                   NULL)
[10:25:50.272]                 if (is_error) {
[10:25:50.272]                   sessionInformation <- function() {
[10:25:50.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.272]                       search = base::search(), system = base::Sys.info())
[10:25:50.272]                   }
[10:25:50.272]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.272]                     cond$call), session = sessionInformation(), 
[10:25:50.272]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.272]                   signalCondition(cond)
[10:25:50.272]                 }
[10:25:50.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.272]                 "immediateCondition"))) {
[10:25:50.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.272]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.272]                   if (TRUE && !signal) {
[10:25:50.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.272]                     {
[10:25:50.272]                       inherits <- base::inherits
[10:25:50.272]                       invokeRestart <- base::invokeRestart
[10:25:50.272]                       is.null <- base::is.null
[10:25:50.272]                       muffled <- FALSE
[10:25:50.272]                       if (inherits(cond, "message")) {
[10:25:50.272]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.272]                         if (muffled) 
[10:25:50.272]                           invokeRestart("muffleMessage")
[10:25:50.272]                       }
[10:25:50.272]                       else if (inherits(cond, "warning")) {
[10:25:50.272]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.272]                         if (muffled) 
[10:25:50.272]                           invokeRestart("muffleWarning")
[10:25:50.272]                       }
[10:25:50.272]                       else if (inherits(cond, "condition")) {
[10:25:50.272]                         if (!is.null(pattern)) {
[10:25:50.272]                           computeRestarts <- base::computeRestarts
[10:25:50.272]                           grepl <- base::grepl
[10:25:50.272]                           restarts <- computeRestarts(cond)
[10:25:50.272]                           for (restart in restarts) {
[10:25:50.272]                             name <- restart$name
[10:25:50.272]                             if (is.null(name)) 
[10:25:50.272]                               next
[10:25:50.272]                             if (!grepl(pattern, name)) 
[10:25:50.272]                               next
[10:25:50.272]                             invokeRestart(restart)
[10:25:50.272]                             muffled <- TRUE
[10:25:50.272]                             break
[10:25:50.272]                           }
[10:25:50.272]                         }
[10:25:50.272]                       }
[10:25:50.272]                       invisible(muffled)
[10:25:50.272]                     }
[10:25:50.272]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.272]                   }
[10:25:50.272]                 }
[10:25:50.272]                 else {
[10:25:50.272]                   if (TRUE) {
[10:25:50.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.272]                     {
[10:25:50.272]                       inherits <- base::inherits
[10:25:50.272]                       invokeRestart <- base::invokeRestart
[10:25:50.272]                       is.null <- base::is.null
[10:25:50.272]                       muffled <- FALSE
[10:25:50.272]                       if (inherits(cond, "message")) {
[10:25:50.272]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.272]                         if (muffled) 
[10:25:50.272]                           invokeRestart("muffleMessage")
[10:25:50.272]                       }
[10:25:50.272]                       else if (inherits(cond, "warning")) {
[10:25:50.272]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.272]                         if (muffled) 
[10:25:50.272]                           invokeRestart("muffleWarning")
[10:25:50.272]                       }
[10:25:50.272]                       else if (inherits(cond, "condition")) {
[10:25:50.272]                         if (!is.null(pattern)) {
[10:25:50.272]                           computeRestarts <- base::computeRestarts
[10:25:50.272]                           grepl <- base::grepl
[10:25:50.272]                           restarts <- computeRestarts(cond)
[10:25:50.272]                           for (restart in restarts) {
[10:25:50.272]                             name <- restart$name
[10:25:50.272]                             if (is.null(name)) 
[10:25:50.272]                               next
[10:25:50.272]                             if (!grepl(pattern, name)) 
[10:25:50.272]                               next
[10:25:50.272]                             invokeRestart(restart)
[10:25:50.272]                             muffled <- TRUE
[10:25:50.272]                             break
[10:25:50.272]                           }
[10:25:50.272]                         }
[10:25:50.272]                       }
[10:25:50.272]                       invisible(muffled)
[10:25:50.272]                     }
[10:25:50.272]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.272]                   }
[10:25:50.272]                 }
[10:25:50.272]             }
[10:25:50.272]         }))
[10:25:50.272]     }, error = function(ex) {
[10:25:50.272]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.272]                 ...future.rng), started = ...future.startTime, 
[10:25:50.272]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.272]             version = "1.8"), class = "FutureResult")
[10:25:50.272]     }, finally = {
[10:25:50.272]         if (!identical(...future.workdir, getwd())) 
[10:25:50.272]             setwd(...future.workdir)
[10:25:50.272]         {
[10:25:50.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.272]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.272]             }
[10:25:50.272]             base::options(...future.oldOptions)
[10:25:50.272]             if (.Platform$OS.type == "windows") {
[10:25:50.272]                 old_names <- names(...future.oldEnvVars)
[10:25:50.272]                 envs <- base::Sys.getenv()
[10:25:50.272]                 names <- names(envs)
[10:25:50.272]                 common <- intersect(names, old_names)
[10:25:50.272]                 added <- setdiff(names, old_names)
[10:25:50.272]                 removed <- setdiff(old_names, names)
[10:25:50.272]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.272]                   envs[common]]
[10:25:50.272]                 NAMES <- toupper(changed)
[10:25:50.272]                 args <- list()
[10:25:50.272]                 for (kk in seq_along(NAMES)) {
[10:25:50.272]                   name <- changed[[kk]]
[10:25:50.272]                   NAME <- NAMES[[kk]]
[10:25:50.272]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.272]                     next
[10:25:50.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.272]                 }
[10:25:50.272]                 NAMES <- toupper(added)
[10:25:50.272]                 for (kk in seq_along(NAMES)) {
[10:25:50.272]                   name <- added[[kk]]
[10:25:50.272]                   NAME <- NAMES[[kk]]
[10:25:50.272]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.272]                     next
[10:25:50.272]                   args[[name]] <- ""
[10:25:50.272]                 }
[10:25:50.272]                 NAMES <- toupper(removed)
[10:25:50.272]                 for (kk in seq_along(NAMES)) {
[10:25:50.272]                   name <- removed[[kk]]
[10:25:50.272]                   NAME <- NAMES[[kk]]
[10:25:50.272]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.272]                     next
[10:25:50.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.272]                 }
[10:25:50.272]                 if (length(args) > 0) 
[10:25:50.272]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.272]             }
[10:25:50.272]             else {
[10:25:50.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.272]             }
[10:25:50.272]             {
[10:25:50.272]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.272]                   0L) {
[10:25:50.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.272]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.272]                   base::options(opts)
[10:25:50.272]                 }
[10:25:50.272]                 {
[10:25:50.272]                   {
[10:25:50.272]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.272]                     NULL
[10:25:50.272]                   }
[10:25:50.272]                   options(future.plan = NULL)
[10:25:50.272]                   if (is.na(NA_character_)) 
[10:25:50.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.272]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.272]                     envir = parent.frame()) 
[10:25:50.272]                   {
[10:25:50.272]                     default_workers <- missing(workers)
[10:25:50.272]                     if (is.function(workers)) 
[10:25:50.272]                       workers <- workers()
[10:25:50.272]                     workers <- structure(as.integer(workers), 
[10:25:50.272]                       class = class(workers))
[10:25:50.272]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.272]                       1L)
[10:25:50.272]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.272]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.272]                       if (default_workers) 
[10:25:50.272]                         supportsMulticore(warn = TRUE)
[10:25:50.272]                       return(sequential(..., envir = envir))
[10:25:50.272]                     }
[10:25:50.272]                     oopts <- options(mc.cores = workers)
[10:25:50.272]                     on.exit(options(oopts))
[10:25:50.272]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.272]                       envir = envir)
[10:25:50.272]                     if (!future$lazy) 
[10:25:50.272]                       future <- run(future)
[10:25:50.272]                     invisible(future)
[10:25:50.272]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.272]                 }
[10:25:50.272]             }
[10:25:50.272]         }
[10:25:50.272]     })
[10:25:50.272]     if (TRUE) {
[10:25:50.272]         base::sink(type = "output", split = FALSE)
[10:25:50.272]         if (TRUE) {
[10:25:50.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.272]         }
[10:25:50.272]         else {
[10:25:50.272]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.272]         }
[10:25:50.272]         base::close(...future.stdout)
[10:25:50.272]         ...future.stdout <- NULL
[10:25:50.272]     }
[10:25:50.272]     ...future.result$conditions <- ...future.conditions
[10:25:50.272]     ...future.result$finished <- base::Sys.time()
[10:25:50.272]     ...future.result
[10:25:50.272] }
[10:25:50.275] requestCore(): workers = 2
[10:25:50.277] MulticoreFuture started
[10:25:50.277] - Launch lazy future ... done
[10:25:50.278] run() for ‘MulticoreFuture’ ... done
[10:25:50.278] getGlobalsAndPackages() ...
[10:25:50.278] plan(): Setting new future strategy stack:
[10:25:50.278] Searching for globals...
[10:25:50.279] List of future strategies:
[10:25:50.279] 1. sequential:
[10:25:50.279]    - args: function (..., envir = parent.frame())
[10:25:50.279]    - tweaked: FALSE
[10:25:50.279]    - call: NULL
[10:25:50.279] 
[10:25:50.279] plan(): nbrOfWorkers() = 1
[10:25:50.279] Searching for globals ... DONE
[10:25:50.280] - globals: [0] <none>
[10:25:50.280] getGlobalsAndPackages() ... DONE
[10:25:50.280] run() for ‘Future’ ...
[10:25:50.280] - state: ‘created’
[10:25:50.281] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.281] plan(): Setting new future strategy stack:
[10:25:50.281] List of future strategies:
[10:25:50.281] 1. multicore:
[10:25:50.281]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.281]    - tweaked: FALSE
[10:25:50.281]    - call: plan(strategy)
[10:25:50.286] plan(): nbrOfWorkers() = 2
[10:25:50.287] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.287] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.287]   - Field: ‘label’
[10:25:50.287]   - Field: ‘local’
[10:25:50.287]   - Field: ‘owner’
[10:25:50.287]   - Field: ‘envir’
[10:25:50.288]   - Field: ‘workers’
[10:25:50.288]   - Field: ‘packages’
[10:25:50.288]   - Field: ‘gc’
[10:25:50.288]   - Field: ‘job’
[10:25:50.288]   - Field: ‘conditions’
[10:25:50.288]   - Field: ‘expr’
[10:25:50.288]   - Field: ‘uuid’
[10:25:50.289]   - Field: ‘seed’
[10:25:50.289]   - Field: ‘version’
[10:25:50.289]   - Field: ‘result’
[10:25:50.289]   - Field: ‘asynchronous’
[10:25:50.289]   - Field: ‘calls’
[10:25:50.289]   - Field: ‘globals’
[10:25:50.289]   - Field: ‘stdout’
[10:25:50.290]   - Field: ‘earlySignal’
[10:25:50.290]   - Field: ‘lazy’
[10:25:50.290]   - Field: ‘state’
[10:25:50.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.290] - Launch lazy future ...
[10:25:50.291] Packages needed by the future expression (n = 0): <none>
[10:25:50.291] Packages needed by future strategies (n = 0): <none>
[10:25:50.292] {
[10:25:50.292]     {
[10:25:50.292]         {
[10:25:50.292]             ...future.startTime <- base::Sys.time()
[10:25:50.292]             {
[10:25:50.292]                 {
[10:25:50.292]                   {
[10:25:50.292]                     {
[10:25:50.292]                       base::local({
[10:25:50.292]                         has_future <- base::requireNamespace("future", 
[10:25:50.292]                           quietly = TRUE)
[10:25:50.292]                         if (has_future) {
[10:25:50.292]                           ns <- base::getNamespace("future")
[10:25:50.292]                           version <- ns[[".package"]][["version"]]
[10:25:50.292]                           if (is.null(version)) 
[10:25:50.292]                             version <- utils::packageVersion("future")
[10:25:50.292]                         }
[10:25:50.292]                         else {
[10:25:50.292]                           version <- NULL
[10:25:50.292]                         }
[10:25:50.292]                         if (!has_future || version < "1.8.0") {
[10:25:50.292]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.292]                             "", base::R.version$version.string), 
[10:25:50.292]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.292]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.292]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.292]                               "release", "version")], collapse = " "), 
[10:25:50.292]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.292]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.292]                             info)
[10:25:50.292]                           info <- base::paste(info, collapse = "; ")
[10:25:50.292]                           if (!has_future) {
[10:25:50.292]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.292]                               info)
[10:25:50.292]                           }
[10:25:50.292]                           else {
[10:25:50.292]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.292]                               info, version)
[10:25:50.292]                           }
[10:25:50.292]                           base::stop(msg)
[10:25:50.292]                         }
[10:25:50.292]                       })
[10:25:50.292]                     }
[10:25:50.292]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.292]                     base::options(mc.cores = 1L)
[10:25:50.292]                   }
[10:25:50.292]                   options(future.plan = NULL)
[10:25:50.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.292]                 }
[10:25:50.292]                 ...future.workdir <- getwd()
[10:25:50.292]             }
[10:25:50.292]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.292]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.292]         }
[10:25:50.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.292]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.292]             base::names(...future.oldOptions))
[10:25:50.292]     }
[10:25:50.292]     if (FALSE) {
[10:25:50.292]     }
[10:25:50.292]     else {
[10:25:50.292]         if (TRUE) {
[10:25:50.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.292]                 open = "w")
[10:25:50.292]         }
[10:25:50.292]         else {
[10:25:50.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.292]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.292]         }
[10:25:50.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.292]             base::sink(type = "output", split = FALSE)
[10:25:50.292]             base::close(...future.stdout)
[10:25:50.292]         }, add = TRUE)
[10:25:50.292]     }
[10:25:50.292]     ...future.frame <- base::sys.nframe()
[10:25:50.292]     ...future.conditions <- base::list()
[10:25:50.292]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.292]     if (FALSE) {
[10:25:50.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.292]     }
[10:25:50.292]     ...future.result <- base::tryCatch({
[10:25:50.292]         base::withCallingHandlers({
[10:25:50.292]             ...future.value <- base::withVisible(base::local({
[10:25:50.292]                 withCallingHandlers({
[10:25:50.292]                   NULL
[10:25:50.292]                 }, immediateCondition = function(cond) {
[10:25:50.292]                   save_rds <- function (object, pathname, ...) 
[10:25:50.292]                   {
[10:25:50.292]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.292]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.292]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.292]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.292]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.292]                         fi_tmp[["mtime"]])
[10:25:50.292]                     }
[10:25:50.292]                     tryCatch({
[10:25:50.292]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.292]                     }, error = function(ex) {
[10:25:50.292]                       msg <- conditionMessage(ex)
[10:25:50.292]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.292]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.292]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.292]                         fi_tmp[["mtime"]], msg)
[10:25:50.292]                       ex$message <- msg
[10:25:50.292]                       stop(ex)
[10:25:50.292]                     })
[10:25:50.292]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.292]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.292]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.292]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.292]                       fi <- file.info(pathname)
[10:25:50.292]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.292]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.292]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.292]                         fi[["size"]], fi[["mtime"]])
[10:25:50.292]                       stop(msg)
[10:25:50.292]                     }
[10:25:50.292]                     invisible(pathname)
[10:25:50.292]                   }
[10:25:50.292]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.292]                     rootPath = tempdir()) 
[10:25:50.292]                   {
[10:25:50.292]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.292]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.292]                       tmpdir = path, fileext = ".rds")
[10:25:50.292]                     save_rds(obj, file)
[10:25:50.292]                   }
[10:25:50.292]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.292]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.292]                   {
[10:25:50.292]                     inherits <- base::inherits
[10:25:50.292]                     invokeRestart <- base::invokeRestart
[10:25:50.292]                     is.null <- base::is.null
[10:25:50.292]                     muffled <- FALSE
[10:25:50.292]                     if (inherits(cond, "message")) {
[10:25:50.292]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.292]                       if (muffled) 
[10:25:50.292]                         invokeRestart("muffleMessage")
[10:25:50.292]                     }
[10:25:50.292]                     else if (inherits(cond, "warning")) {
[10:25:50.292]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.292]                       if (muffled) 
[10:25:50.292]                         invokeRestart("muffleWarning")
[10:25:50.292]                     }
[10:25:50.292]                     else if (inherits(cond, "condition")) {
[10:25:50.292]                       if (!is.null(pattern)) {
[10:25:50.292]                         computeRestarts <- base::computeRestarts
[10:25:50.292]                         grepl <- base::grepl
[10:25:50.292]                         restarts <- computeRestarts(cond)
[10:25:50.292]                         for (restart in restarts) {
[10:25:50.292]                           name <- restart$name
[10:25:50.292]                           if (is.null(name)) 
[10:25:50.292]                             next
[10:25:50.292]                           if (!grepl(pattern, name)) 
[10:25:50.292]                             next
[10:25:50.292]                           invokeRestart(restart)
[10:25:50.292]                           muffled <- TRUE
[10:25:50.292]                           break
[10:25:50.292]                         }
[10:25:50.292]                       }
[10:25:50.292]                     }
[10:25:50.292]                     invisible(muffled)
[10:25:50.292]                   }
[10:25:50.292]                   muffleCondition(cond)
[10:25:50.292]                 })
[10:25:50.292]             }))
[10:25:50.292]             future::FutureResult(value = ...future.value$value, 
[10:25:50.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.292]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.292]                     ...future.globalenv.names))
[10:25:50.292]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.292]         }, condition = base::local({
[10:25:50.292]             c <- base::c
[10:25:50.292]             inherits <- base::inherits
[10:25:50.292]             invokeRestart <- base::invokeRestart
[10:25:50.292]             length <- base::length
[10:25:50.292]             list <- base::list
[10:25:50.292]             seq.int <- base::seq.int
[10:25:50.292]             signalCondition <- base::signalCondition
[10:25:50.292]             sys.calls <- base::sys.calls
[10:25:50.292]             `[[` <- base::`[[`
[10:25:50.292]             `+` <- base::`+`
[10:25:50.292]             `<<-` <- base::`<<-`
[10:25:50.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.292]                   3L)]
[10:25:50.292]             }
[10:25:50.292]             function(cond) {
[10:25:50.292]                 is_error <- inherits(cond, "error")
[10:25:50.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.292]                   NULL)
[10:25:50.292]                 if (is_error) {
[10:25:50.292]                   sessionInformation <- function() {
[10:25:50.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.292]                       search = base::search(), system = base::Sys.info())
[10:25:50.292]                   }
[10:25:50.292]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.292]                     cond$call), session = sessionInformation(), 
[10:25:50.292]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.292]                   signalCondition(cond)
[10:25:50.292]                 }
[10:25:50.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.292]                 "immediateCondition"))) {
[10:25:50.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.292]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.292]                   if (TRUE && !signal) {
[10:25:50.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.292]                     {
[10:25:50.292]                       inherits <- base::inherits
[10:25:50.292]                       invokeRestart <- base::invokeRestart
[10:25:50.292]                       is.null <- base::is.null
[10:25:50.292]                       muffled <- FALSE
[10:25:50.292]                       if (inherits(cond, "message")) {
[10:25:50.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.292]                         if (muffled) 
[10:25:50.292]                           invokeRestart("muffleMessage")
[10:25:50.292]                       }
[10:25:50.292]                       else if (inherits(cond, "warning")) {
[10:25:50.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.292]                         if (muffled) 
[10:25:50.292]                           invokeRestart("muffleWarning")
[10:25:50.292]                       }
[10:25:50.292]                       else if (inherits(cond, "condition")) {
[10:25:50.292]                         if (!is.null(pattern)) {
[10:25:50.292]                           computeRestarts <- base::computeRestarts
[10:25:50.292]                           grepl <- base::grepl
[10:25:50.292]                           restarts <- computeRestarts(cond)
[10:25:50.292]                           for (restart in restarts) {
[10:25:50.292]                             name <- restart$name
[10:25:50.292]                             if (is.null(name)) 
[10:25:50.292]                               next
[10:25:50.292]                             if (!grepl(pattern, name)) 
[10:25:50.292]                               next
[10:25:50.292]                             invokeRestart(restart)
[10:25:50.292]                             muffled <- TRUE
[10:25:50.292]                             break
[10:25:50.292]                           }
[10:25:50.292]                         }
[10:25:50.292]                       }
[10:25:50.292]                       invisible(muffled)
[10:25:50.292]                     }
[10:25:50.292]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.292]                   }
[10:25:50.292]                 }
[10:25:50.292]                 else {
[10:25:50.292]                   if (TRUE) {
[10:25:50.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.292]                     {
[10:25:50.292]                       inherits <- base::inherits
[10:25:50.292]                       invokeRestart <- base::invokeRestart
[10:25:50.292]                       is.null <- base::is.null
[10:25:50.292]                       muffled <- FALSE
[10:25:50.292]                       if (inherits(cond, "message")) {
[10:25:50.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.292]                         if (muffled) 
[10:25:50.292]                           invokeRestart("muffleMessage")
[10:25:50.292]                       }
[10:25:50.292]                       else if (inherits(cond, "warning")) {
[10:25:50.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.292]                         if (muffled) 
[10:25:50.292]                           invokeRestart("muffleWarning")
[10:25:50.292]                       }
[10:25:50.292]                       else if (inherits(cond, "condition")) {
[10:25:50.292]                         if (!is.null(pattern)) {
[10:25:50.292]                           computeRestarts <- base::computeRestarts
[10:25:50.292]                           grepl <- base::grepl
[10:25:50.292]                           restarts <- computeRestarts(cond)
[10:25:50.292]                           for (restart in restarts) {
[10:25:50.292]                             name <- restart$name
[10:25:50.292]                             if (is.null(name)) 
[10:25:50.292]                               next
[10:25:50.292]                             if (!grepl(pattern, name)) 
[10:25:50.292]                               next
[10:25:50.292]                             invokeRestart(restart)
[10:25:50.292]                             muffled <- TRUE
[10:25:50.292]                             break
[10:25:50.292]                           }
[10:25:50.292]                         }
[10:25:50.292]                       }
[10:25:50.292]                       invisible(muffled)
[10:25:50.292]                     }
[10:25:50.292]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.292]                   }
[10:25:50.292]                 }
[10:25:50.292]             }
[10:25:50.292]         }))
[10:25:50.292]     }, error = function(ex) {
[10:25:50.292]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.292]                 ...future.rng), started = ...future.startTime, 
[10:25:50.292]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.292]             version = "1.8"), class = "FutureResult")
[10:25:50.292]     }, finally = {
[10:25:50.292]         if (!identical(...future.workdir, getwd())) 
[10:25:50.292]             setwd(...future.workdir)
[10:25:50.292]         {
[10:25:50.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.292]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.292]             }
[10:25:50.292]             base::options(...future.oldOptions)
[10:25:50.292]             if (.Platform$OS.type == "windows") {
[10:25:50.292]                 old_names <- names(...future.oldEnvVars)
[10:25:50.292]                 envs <- base::Sys.getenv()
[10:25:50.292]                 names <- names(envs)
[10:25:50.292]                 common <- intersect(names, old_names)
[10:25:50.292]                 added <- setdiff(names, old_names)
[10:25:50.292]                 removed <- setdiff(old_names, names)
[10:25:50.292]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.292]                   envs[common]]
[10:25:50.292]                 NAMES <- toupper(changed)
[10:25:50.292]                 args <- list()
[10:25:50.292]                 for (kk in seq_along(NAMES)) {
[10:25:50.292]                   name <- changed[[kk]]
[10:25:50.292]                   NAME <- NAMES[[kk]]
[10:25:50.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.292]                     next
[10:25:50.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.292]                 }
[10:25:50.292]                 NAMES <- toupper(added)
[10:25:50.292]                 for (kk in seq_along(NAMES)) {
[10:25:50.292]                   name <- added[[kk]]
[10:25:50.292]                   NAME <- NAMES[[kk]]
[10:25:50.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.292]                     next
[10:25:50.292]                   args[[name]] <- ""
[10:25:50.292]                 }
[10:25:50.292]                 NAMES <- toupper(removed)
[10:25:50.292]                 for (kk in seq_along(NAMES)) {
[10:25:50.292]                   name <- removed[[kk]]
[10:25:50.292]                   NAME <- NAMES[[kk]]
[10:25:50.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.292]                     next
[10:25:50.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.292]                 }
[10:25:50.292]                 if (length(args) > 0) 
[10:25:50.292]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.292]             }
[10:25:50.292]             else {
[10:25:50.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.292]             }
[10:25:50.292]             {
[10:25:50.292]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.292]                   0L) {
[10:25:50.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.292]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.292]                   base::options(opts)
[10:25:50.292]                 }
[10:25:50.292]                 {
[10:25:50.292]                   {
[10:25:50.292]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.292]                     NULL
[10:25:50.292]                   }
[10:25:50.292]                   options(future.plan = NULL)
[10:25:50.292]                   if (is.na(NA_character_)) 
[10:25:50.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.292]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.292]                     envir = parent.frame()) 
[10:25:50.292]                   {
[10:25:50.292]                     default_workers <- missing(workers)
[10:25:50.292]                     if (is.function(workers)) 
[10:25:50.292]                       workers <- workers()
[10:25:50.292]                     workers <- structure(as.integer(workers), 
[10:25:50.292]                       class = class(workers))
[10:25:50.292]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.292]                       1L)
[10:25:50.292]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.292]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.292]                       if (default_workers) 
[10:25:50.292]                         supportsMulticore(warn = TRUE)
[10:25:50.292]                       return(sequential(..., envir = envir))
[10:25:50.292]                     }
[10:25:50.292]                     oopts <- options(mc.cores = workers)
[10:25:50.292]                     on.exit(options(oopts))
[10:25:50.292]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.292]                       envir = envir)
[10:25:50.292]                     if (!future$lazy) 
[10:25:50.292]                       future <- run(future)
[10:25:50.292]                     invisible(future)
[10:25:50.292]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.292]                 }
[10:25:50.292]             }
[10:25:50.292]         }
[10:25:50.292]     })
[10:25:50.292]     if (TRUE) {
[10:25:50.292]         base::sink(type = "output", split = FALSE)
[10:25:50.292]         if (TRUE) {
[10:25:50.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.292]         }
[10:25:50.292]         else {
[10:25:50.292]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.292]         }
[10:25:50.292]         base::close(...future.stdout)
[10:25:50.292]         ...future.stdout <- NULL
[10:25:50.292]     }
[10:25:50.292]     ...future.result$conditions <- ...future.conditions
[10:25:50.292]     ...future.result$finished <- base::Sys.time()
[10:25:50.292]     ...future.result
[10:25:50.292] }
[10:25:50.295] requestCore(): workers = 2
[10:25:50.298] MulticoreFuture started
[10:25:50.298] - Launch lazy future ... done
[10:25:50.298] run() for ‘MulticoreFuture’ ... done
[10:25:50.299] plan(): Setting new future strategy stack:
[10:25:50.299] getGlobalsAndPackages() ...
[10:25:50.299] Searching for globals...
[10:25:50.299] List of future strategies:
[10:25:50.299] 1. sequential:
[10:25:50.299]    - args: function (..., envir = parent.frame())
[10:25:50.299]    - tweaked: FALSE
[10:25:50.299]    - call: NULL
[10:25:50.300] plan(): nbrOfWorkers() = 1
[10:25:50.301] - globals found: [1] ‘{’
[10:25:50.301] Searching for globals ... DONE
[10:25:50.301] Resolving globals: FALSE
[10:25:50.302] 
[10:25:50.302] 
[10:25:50.302] getGlobalsAndPackages() ... DONE
[10:25:50.302] plan(): Setting new future strategy stack:
[10:25:50.302] run() for ‘Future’ ...
[10:25:50.303] - state: ‘created’
[10:25:50.302] List of future strategies:
[10:25:50.302] 1. multicore:
[10:25:50.302]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.302]    - tweaked: FALSE
[10:25:50.302]    - call: plan(strategy)
[10:25:50.303] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.308] plan(): nbrOfWorkers() = 2
[10:25:50.308] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.308]   - Field: ‘label’
[10:25:50.308]   - Field: ‘local’
[10:25:50.309]   - Field: ‘owner’
[10:25:50.309]   - Field: ‘envir’
[10:25:50.309]   - Field: ‘workers’
[10:25:50.309]   - Field: ‘packages’
[10:25:50.309]   - Field: ‘gc’
[10:25:50.309]   - Field: ‘job’
[10:25:50.309]   - Field: ‘conditions’
[10:25:50.310]   - Field: ‘expr’
[10:25:50.310]   - Field: ‘uuid’
[10:25:50.310]   - Field: ‘seed’
[10:25:50.310]   - Field: ‘version’
[10:25:50.310]   - Field: ‘result’
[10:25:50.310]   - Field: ‘asynchronous’
[10:25:50.310]   - Field: ‘calls’
[10:25:50.311]   - Field: ‘globals’
[10:25:50.311]   - Field: ‘stdout’
[10:25:50.311]   - Field: ‘earlySignal’
[10:25:50.311]   - Field: ‘lazy’
[10:25:50.311]   - Field: ‘state’
[10:25:50.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.312] - Launch lazy future ...
[10:25:50.312] Packages needed by the future expression (n = 0): <none>
[10:25:50.312] Packages needed by future strategies (n = 0): <none>
[10:25:50.313] {
[10:25:50.313]     {
[10:25:50.313]         {
[10:25:50.313]             ...future.startTime <- base::Sys.time()
[10:25:50.313]             {
[10:25:50.313]                 {
[10:25:50.313]                   {
[10:25:50.313]                     {
[10:25:50.313]                       base::local({
[10:25:50.313]                         has_future <- base::requireNamespace("future", 
[10:25:50.313]                           quietly = TRUE)
[10:25:50.313]                         if (has_future) {
[10:25:50.313]                           ns <- base::getNamespace("future")
[10:25:50.313]                           version <- ns[[".package"]][["version"]]
[10:25:50.313]                           if (is.null(version)) 
[10:25:50.313]                             version <- utils::packageVersion("future")
[10:25:50.313]                         }
[10:25:50.313]                         else {
[10:25:50.313]                           version <- NULL
[10:25:50.313]                         }
[10:25:50.313]                         if (!has_future || version < "1.8.0") {
[10:25:50.313]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.313]                             "", base::R.version$version.string), 
[10:25:50.313]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.313]                               "release", "version")], collapse = " "), 
[10:25:50.313]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.313]                             info)
[10:25:50.313]                           info <- base::paste(info, collapse = "; ")
[10:25:50.313]                           if (!has_future) {
[10:25:50.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.313]                               info)
[10:25:50.313]                           }
[10:25:50.313]                           else {
[10:25:50.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.313]                               info, version)
[10:25:50.313]                           }
[10:25:50.313]                           base::stop(msg)
[10:25:50.313]                         }
[10:25:50.313]                       })
[10:25:50.313]                     }
[10:25:50.313]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.313]                     base::options(mc.cores = 1L)
[10:25:50.313]                   }
[10:25:50.313]                   options(future.plan = NULL)
[10:25:50.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.313]                 }
[10:25:50.313]                 ...future.workdir <- getwd()
[10:25:50.313]             }
[10:25:50.313]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.313]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.313]         }
[10:25:50.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.313]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.313]             base::names(...future.oldOptions))
[10:25:50.313]     }
[10:25:50.313]     if (FALSE) {
[10:25:50.313]     }
[10:25:50.313]     else {
[10:25:50.313]         if (TRUE) {
[10:25:50.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.313]                 open = "w")
[10:25:50.313]         }
[10:25:50.313]         else {
[10:25:50.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.313]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.313]         }
[10:25:50.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.313]             base::sink(type = "output", split = FALSE)
[10:25:50.313]             base::close(...future.stdout)
[10:25:50.313]         }, add = TRUE)
[10:25:50.313]     }
[10:25:50.313]     ...future.frame <- base::sys.nframe()
[10:25:50.313]     ...future.conditions <- base::list()
[10:25:50.313]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.313]     if (FALSE) {
[10:25:50.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.313]     }
[10:25:50.313]     ...future.result <- base::tryCatch({
[10:25:50.313]         base::withCallingHandlers({
[10:25:50.313]             ...future.value <- base::withVisible(base::local({
[10:25:50.313]                 withCallingHandlers({
[10:25:50.313]                   {
[10:25:50.313]                     4
[10:25:50.313]                   }
[10:25:50.313]                 }, immediateCondition = function(cond) {
[10:25:50.313]                   save_rds <- function (object, pathname, ...) 
[10:25:50.313]                   {
[10:25:50.313]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.313]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.313]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.313]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.313]                         fi_tmp[["mtime"]])
[10:25:50.313]                     }
[10:25:50.313]                     tryCatch({
[10:25:50.313]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.313]                     }, error = function(ex) {
[10:25:50.313]                       msg <- conditionMessage(ex)
[10:25:50.313]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.313]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.313]                         fi_tmp[["mtime"]], msg)
[10:25:50.313]                       ex$message <- msg
[10:25:50.313]                       stop(ex)
[10:25:50.313]                     })
[10:25:50.313]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.313]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.313]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.313]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.313]                       fi <- file.info(pathname)
[10:25:50.313]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.313]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.313]                         fi[["size"]], fi[["mtime"]])
[10:25:50.313]                       stop(msg)
[10:25:50.313]                     }
[10:25:50.313]                     invisible(pathname)
[10:25:50.313]                   }
[10:25:50.313]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.313]                     rootPath = tempdir()) 
[10:25:50.313]                   {
[10:25:50.313]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.313]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.313]                       tmpdir = path, fileext = ".rds")
[10:25:50.313]                     save_rds(obj, file)
[10:25:50.313]                   }
[10:25:50.313]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.313]                   {
[10:25:50.313]                     inherits <- base::inherits
[10:25:50.313]                     invokeRestart <- base::invokeRestart
[10:25:50.313]                     is.null <- base::is.null
[10:25:50.313]                     muffled <- FALSE
[10:25:50.313]                     if (inherits(cond, "message")) {
[10:25:50.313]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.313]                       if (muffled) 
[10:25:50.313]                         invokeRestart("muffleMessage")
[10:25:50.313]                     }
[10:25:50.313]                     else if (inherits(cond, "warning")) {
[10:25:50.313]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.313]                       if (muffled) 
[10:25:50.313]                         invokeRestart("muffleWarning")
[10:25:50.313]                     }
[10:25:50.313]                     else if (inherits(cond, "condition")) {
[10:25:50.313]                       if (!is.null(pattern)) {
[10:25:50.313]                         computeRestarts <- base::computeRestarts
[10:25:50.313]                         grepl <- base::grepl
[10:25:50.313]                         restarts <- computeRestarts(cond)
[10:25:50.313]                         for (restart in restarts) {
[10:25:50.313]                           name <- restart$name
[10:25:50.313]                           if (is.null(name)) 
[10:25:50.313]                             next
[10:25:50.313]                           if (!grepl(pattern, name)) 
[10:25:50.313]                             next
[10:25:50.313]                           invokeRestart(restart)
[10:25:50.313]                           muffled <- TRUE
[10:25:50.313]                           break
[10:25:50.313]                         }
[10:25:50.313]                       }
[10:25:50.313]                     }
[10:25:50.313]                     invisible(muffled)
[10:25:50.313]                   }
[10:25:50.313]                   muffleCondition(cond)
[10:25:50.313]                 })
[10:25:50.313]             }))
[10:25:50.313]             future::FutureResult(value = ...future.value$value, 
[10:25:50.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.313]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.313]                     ...future.globalenv.names))
[10:25:50.313]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.313]         }, condition = base::local({
[10:25:50.313]             c <- base::c
[10:25:50.313]             inherits <- base::inherits
[10:25:50.313]             invokeRestart <- base::invokeRestart
[10:25:50.313]             length <- base::length
[10:25:50.313]             list <- base::list
[10:25:50.313]             seq.int <- base::seq.int
[10:25:50.313]             signalCondition <- base::signalCondition
[10:25:50.313]             sys.calls <- base::sys.calls
[10:25:50.313]             `[[` <- base::`[[`
[10:25:50.313]             `+` <- base::`+`
[10:25:50.313]             `<<-` <- base::`<<-`
[10:25:50.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.313]                   3L)]
[10:25:50.313]             }
[10:25:50.313]             function(cond) {
[10:25:50.313]                 is_error <- inherits(cond, "error")
[10:25:50.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.313]                   NULL)
[10:25:50.313]                 if (is_error) {
[10:25:50.313]                   sessionInformation <- function() {
[10:25:50.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.313]                       search = base::search(), system = base::Sys.info())
[10:25:50.313]                   }
[10:25:50.313]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.313]                     cond$call), session = sessionInformation(), 
[10:25:50.313]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.313]                   signalCondition(cond)
[10:25:50.313]                 }
[10:25:50.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.313]                 "immediateCondition"))) {
[10:25:50.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.313]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.313]                   if (TRUE && !signal) {
[10:25:50.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.313]                     {
[10:25:50.313]                       inherits <- base::inherits
[10:25:50.313]                       invokeRestart <- base::invokeRestart
[10:25:50.313]                       is.null <- base::is.null
[10:25:50.313]                       muffled <- FALSE
[10:25:50.313]                       if (inherits(cond, "message")) {
[10:25:50.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.313]                         if (muffled) 
[10:25:50.313]                           invokeRestart("muffleMessage")
[10:25:50.313]                       }
[10:25:50.313]                       else if (inherits(cond, "warning")) {
[10:25:50.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.313]                         if (muffled) 
[10:25:50.313]                           invokeRestart("muffleWarning")
[10:25:50.313]                       }
[10:25:50.313]                       else if (inherits(cond, "condition")) {
[10:25:50.313]                         if (!is.null(pattern)) {
[10:25:50.313]                           computeRestarts <- base::computeRestarts
[10:25:50.313]                           grepl <- base::grepl
[10:25:50.313]                           restarts <- computeRestarts(cond)
[10:25:50.313]                           for (restart in restarts) {
[10:25:50.313]                             name <- restart$name
[10:25:50.313]                             if (is.null(name)) 
[10:25:50.313]                               next
[10:25:50.313]                             if (!grepl(pattern, name)) 
[10:25:50.313]                               next
[10:25:50.313]                             invokeRestart(restart)
[10:25:50.313]                             muffled <- TRUE
[10:25:50.313]                             break
[10:25:50.313]                           }
[10:25:50.313]                         }
[10:25:50.313]                       }
[10:25:50.313]                       invisible(muffled)
[10:25:50.313]                     }
[10:25:50.313]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.313]                   }
[10:25:50.313]                 }
[10:25:50.313]                 else {
[10:25:50.313]                   if (TRUE) {
[10:25:50.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.313]                     {
[10:25:50.313]                       inherits <- base::inherits
[10:25:50.313]                       invokeRestart <- base::invokeRestart
[10:25:50.313]                       is.null <- base::is.null
[10:25:50.313]                       muffled <- FALSE
[10:25:50.313]                       if (inherits(cond, "message")) {
[10:25:50.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.313]                         if (muffled) 
[10:25:50.313]                           invokeRestart("muffleMessage")
[10:25:50.313]                       }
[10:25:50.313]                       else if (inherits(cond, "warning")) {
[10:25:50.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.313]                         if (muffled) 
[10:25:50.313]                           invokeRestart("muffleWarning")
[10:25:50.313]                       }
[10:25:50.313]                       else if (inherits(cond, "condition")) {
[10:25:50.313]                         if (!is.null(pattern)) {
[10:25:50.313]                           computeRestarts <- base::computeRestarts
[10:25:50.313]                           grepl <- base::grepl
[10:25:50.313]                           restarts <- computeRestarts(cond)
[10:25:50.313]                           for (restart in restarts) {
[10:25:50.313]                             name <- restart$name
[10:25:50.313]                             if (is.null(name)) 
[10:25:50.313]                               next
[10:25:50.313]                             if (!grepl(pattern, name)) 
[10:25:50.313]                               next
[10:25:50.313]                             invokeRestart(restart)
[10:25:50.313]                             muffled <- TRUE
[10:25:50.313]                             break
[10:25:50.313]                           }
[10:25:50.313]                         }
[10:25:50.313]                       }
[10:25:50.313]                       invisible(muffled)
[10:25:50.313]                     }
[10:25:50.313]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.313]                   }
[10:25:50.313]                 }
[10:25:50.313]             }
[10:25:50.313]         }))
[10:25:50.313]     }, error = function(ex) {
[10:25:50.313]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.313]                 ...future.rng), started = ...future.startTime, 
[10:25:50.313]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.313]             version = "1.8"), class = "FutureResult")
[10:25:50.313]     }, finally = {
[10:25:50.313]         if (!identical(...future.workdir, getwd())) 
[10:25:50.313]             setwd(...future.workdir)
[10:25:50.313]         {
[10:25:50.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.313]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.313]             }
[10:25:50.313]             base::options(...future.oldOptions)
[10:25:50.313]             if (.Platform$OS.type == "windows") {
[10:25:50.313]                 old_names <- names(...future.oldEnvVars)
[10:25:50.313]                 envs <- base::Sys.getenv()
[10:25:50.313]                 names <- names(envs)
[10:25:50.313]                 common <- intersect(names, old_names)
[10:25:50.313]                 added <- setdiff(names, old_names)
[10:25:50.313]                 removed <- setdiff(old_names, names)
[10:25:50.313]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.313]                   envs[common]]
[10:25:50.313]                 NAMES <- toupper(changed)
[10:25:50.313]                 args <- list()
[10:25:50.313]                 for (kk in seq_along(NAMES)) {
[10:25:50.313]                   name <- changed[[kk]]
[10:25:50.313]                   NAME <- NAMES[[kk]]
[10:25:50.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.313]                     next
[10:25:50.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.313]                 }
[10:25:50.313]                 NAMES <- toupper(added)
[10:25:50.313]                 for (kk in seq_along(NAMES)) {
[10:25:50.313]                   name <- added[[kk]]
[10:25:50.313]                   NAME <- NAMES[[kk]]
[10:25:50.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.313]                     next
[10:25:50.313]                   args[[name]] <- ""
[10:25:50.313]                 }
[10:25:50.313]                 NAMES <- toupper(removed)
[10:25:50.313]                 for (kk in seq_along(NAMES)) {
[10:25:50.313]                   name <- removed[[kk]]
[10:25:50.313]                   NAME <- NAMES[[kk]]
[10:25:50.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.313]                     next
[10:25:50.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.313]                 }
[10:25:50.313]                 if (length(args) > 0) 
[10:25:50.313]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.313]             }
[10:25:50.313]             else {
[10:25:50.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.313]             }
[10:25:50.313]             {
[10:25:50.313]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.313]                   0L) {
[10:25:50.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.313]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.313]                   base::options(opts)
[10:25:50.313]                 }
[10:25:50.313]                 {
[10:25:50.313]                   {
[10:25:50.313]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.313]                     NULL
[10:25:50.313]                   }
[10:25:50.313]                   options(future.plan = NULL)
[10:25:50.313]                   if (is.na(NA_character_)) 
[10:25:50.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.313]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.313]                     envir = parent.frame()) 
[10:25:50.313]                   {
[10:25:50.313]                     default_workers <- missing(workers)
[10:25:50.313]                     if (is.function(workers)) 
[10:25:50.313]                       workers <- workers()
[10:25:50.313]                     workers <- structure(as.integer(workers), 
[10:25:50.313]                       class = class(workers))
[10:25:50.313]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.313]                       1L)
[10:25:50.313]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.313]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.313]                       if (default_workers) 
[10:25:50.313]                         supportsMulticore(warn = TRUE)
[10:25:50.313]                       return(sequential(..., envir = envir))
[10:25:50.313]                     }
[10:25:50.313]                     oopts <- options(mc.cores = workers)
[10:25:50.313]                     on.exit(options(oopts))
[10:25:50.313]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.313]                       envir = envir)
[10:25:50.313]                     if (!future$lazy) 
[10:25:50.313]                       future <- run(future)
[10:25:50.313]                     invisible(future)
[10:25:50.313]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.313]                 }
[10:25:50.313]             }
[10:25:50.313]         }
[10:25:50.313]     })
[10:25:50.313]     if (TRUE) {
[10:25:50.313]         base::sink(type = "output", split = FALSE)
[10:25:50.313]         if (TRUE) {
[10:25:50.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.313]         }
[10:25:50.313]         else {
[10:25:50.313]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.313]         }
[10:25:50.313]         base::close(...future.stdout)
[10:25:50.313]         ...future.stdout <- NULL
[10:25:50.313]     }
[10:25:50.313]     ...future.result$conditions <- ...future.conditions
[10:25:50.313]     ...future.result$finished <- base::Sys.time()
[10:25:50.313]     ...future.result
[10:25:50.313] }
[10:25:50.317] requestCore(): workers = 2
[10:25:50.317] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:50.328] result() for MulticoreFuture ...
[10:25:50.329] result() for MulticoreFuture ...
[10:25:50.329] result() for MulticoreFuture ... done
[10:25:50.329] result() for MulticoreFuture ... done
[10:25:50.329] result() for MulticoreFuture ...
[10:25:50.330] result() for MulticoreFuture ... done
[10:25:50.332] MulticoreFuture started
[10:25:50.333] - Launch lazy future ... done
[10:25:50.333] run() for ‘MulticoreFuture’ ... done
[10:25:50.334] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c0f6fce140> 
[10:25:50.334] List of future strategies:
[10:25:50.334] 1. sequential:
[10:25:50.334]    - args: function (..., envir = parent.frame())
[10:25:50.334]    - tweaked: FALSE
[10:25:50.334]    - call: NULL
[10:25:50.335] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55c0f4ca6890> 
 - attr(*, "dim.")=[10:25:50.338] plan(): Setting new future strategy stack:
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=[10:25:50.338] List of future strategies:
[10:25:50.338] 1. multicore:
[10:25:50.338]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.338]    - tweaked: FALSE
[10:25:50.338]    - call: plan(strategy)
List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:25:50.344] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:50.350] resolve() on list environment ...
[10:25:50.350]  recursive: 0
[10:25:50.352]  length: 6
[10:25:50.352]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:50.352] signalConditionsASAP(numeric, pos=1) ...
[10:25:50.352] - nx: 6
[10:25:50.352] - relay: TRUE
[10:25:50.352] - stdout: TRUE
[10:25:50.352] - signal: TRUE
[10:25:50.353] - resignal: FALSE
[10:25:50.353] - force: TRUE
[10:25:50.353] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.353] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.353]  - until=2
[10:25:50.353]  - relaying element #2
[10:25:50.354] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.354] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.354] signalConditionsASAP(NULL, pos=1) ... done
[10:25:50.354]  length: 5 (resolved future 1)
[10:25:50.354] Future #2
[10:25:50.354] result() for MulticoreFuture ...
[10:25:50.355] result() for MulticoreFuture ... done
[10:25:50.355] result() for MulticoreFuture ...
[10:25:50.355] result() for MulticoreFuture ... done
[10:25:50.355] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:50.355] - nx: 6
[10:25:50.355] - relay: TRUE
[10:25:50.355] - stdout: TRUE
[10:25:50.356] - signal: TRUE
[10:25:50.356] - resignal: FALSE
[10:25:50.356] - force: TRUE
[10:25:50.356] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.356] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.356]  - until=2
[10:25:50.356]  - relaying element #2
[10:25:50.356] result() for MulticoreFuture ...
[10:25:50.357] result() for MulticoreFuture ... done
[10:25:50.357] result() for MulticoreFuture ...
[10:25:50.357] result() for MulticoreFuture ... done
[10:25:50.357] result() for MulticoreFuture ...
[10:25:50.357] result() for MulticoreFuture ... done
[10:25:50.357] result() for MulticoreFuture ...
[10:25:50.358] result() for MulticoreFuture ... done
[10:25:50.358] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.358] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.358] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:50.358]  length: 4 (resolved future 2)
[10:25:50.358] Future #3
[10:25:50.359] result() for MulticoreFuture ...
[10:25:50.359] result() for MulticoreFuture ...
[10:25:50.360] result() for MulticoreFuture ... done
[10:25:50.360] result() for MulticoreFuture ... done
[10:25:50.360] result() for MulticoreFuture ...
[10:25:50.360] result() for MulticoreFuture ... done
[10:25:50.360] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:50.360] - nx: 6
[10:25:50.360] - relay: TRUE
[10:25:50.360] - stdout: TRUE
[10:25:50.361] - signal: TRUE
[10:25:50.361] - resignal: FALSE
[10:25:50.361] - force: TRUE
[10:25:50.361] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.361] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.361]  - until=3
[10:25:50.361]  - relaying element #3
[10:25:50.362] result() for MulticoreFuture ...
[10:25:50.362] result() for MulticoreFuture ... done
[10:25:50.362] result() for MulticoreFuture ...
[10:25:50.362] result() for MulticoreFuture ... done
[10:25:50.362] result() for MulticoreFuture ...
[10:25:50.362] result() for MulticoreFuture ... done
[10:25:50.363] result() for MulticoreFuture ...
[10:25:50.363] result() for MulticoreFuture ... done
[10:25:50.363] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.363] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.363] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:50.363]  length: 3 (resolved future 3)
[10:25:50.363] Future #4
[10:25:50.364] result() for MulticoreFuture ...
[10:25:50.364] result() for MulticoreFuture ...
[10:25:50.365] result() for MulticoreFuture ... done
[10:25:50.365] result() for MulticoreFuture ... done
[10:25:50.365] result() for MulticoreFuture ...
[10:25:50.365] result() for MulticoreFuture ... done
[10:25:50.365] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:50.365] - nx: 6
[10:25:50.366] - relay: TRUE
[10:25:50.366] - stdout: TRUE
[10:25:50.366] - signal: TRUE
[10:25:50.366] - resignal: FALSE
[10:25:50.366] - force: TRUE
[10:25:50.366] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.367] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.367]  - until=4
[10:25:50.367]  - relaying element #4
[10:25:50.367] result() for MulticoreFuture ...
[10:25:50.367] result() for MulticoreFuture ... done
[10:25:50.367] result() for MulticoreFuture ...
[10:25:50.368] result() for MulticoreFuture ... done
[10:25:50.368] result() for MulticoreFuture ...
[10:25:50.368] result() for MulticoreFuture ... done
[10:25:50.368] result() for MulticoreFuture ...
[10:25:50.368] result() for MulticoreFuture ... done
[10:25:50.368] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.368] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.369] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:50.369]  length: 2 (resolved future 4)
[10:25:50.369] signalConditionsASAP(NULL, pos=5) ...
[10:25:50.369] - nx: 6
[10:25:50.369] - relay: TRUE
[10:25:50.369] - stdout: TRUE
[10:25:50.369] - signal: TRUE
[10:25:50.369] - resignal: FALSE
[10:25:50.369] - force: TRUE
[10:25:50.370] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.370] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.370]  - until=6
[10:25:50.370]  - relaying element #6
[10:25:50.370] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.370] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.370] signalConditionsASAP(NULL, pos=5) ... done
[10:25:50.370]  length: 1 (resolved future 5)
[10:25:50.370] signalConditionsASAP(numeric, pos=6) ...
[10:25:50.371] - nx: 6
[10:25:50.371] - relay: TRUE
[10:25:50.371] - stdout: TRUE
[10:25:50.371] - signal: TRUE
[10:25:50.371] - resignal: FALSE
[10:25:50.371] - force: TRUE
[10:25:50.371] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.371] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.371]  - until=6
[10:25:50.371] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.371] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.372] signalConditionsASAP(numeric, pos=6) ... done
[10:25:50.372]  length: 0 (resolved future 6)
[10:25:50.372] Relaying remaining futures
[10:25:50.372] signalConditionsASAP(NULL, pos=0) ...
[10:25:50.372] - nx: 6
[10:25:50.372] - relay: TRUE
[10:25:50.372] - stdout: TRUE
[10:25:50.372] - signal: TRUE
[10:25:50.372] - resignal: FALSE
[10:25:50.372] - force: TRUE
[10:25:50.373] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.373] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:50.373] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.373] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.373] signalConditionsASAP(NULL, pos=0) ... done
[10:25:50.373] resolve() on list environment ... DONE
[10:25:50.373] result() for MulticoreFuture ...
[10:25:50.373] result() for MulticoreFuture ... done
[10:25:50.374] result() for MulticoreFuture ...
[10:25:50.374] result() for MulticoreFuture ... done
[10:25:50.374] result() for MulticoreFuture ...
[10:25:50.374] result() for MulticoreFuture ... done
[10:25:50.374] result() for MulticoreFuture ...
[10:25:50.374] result() for MulticoreFuture ... done
[10:25:50.374] result() for MulticoreFuture ...
[10:25:50.374] result() for MulticoreFuture ... done
[10:25:50.375] result() for MulticoreFuture ...
[10:25:50.375] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f3e5b330> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:25:50.377] getGlobalsAndPackages() ...
[10:25:50.377] Searching for globals...
[10:25:50.377] 
[10:25:50.378] Searching for globals ... DONE
[10:25:50.378] - globals: [0] <none>
[10:25:50.378] getGlobalsAndPackages() ... DONE
[10:25:50.378] run() for ‘Future’ ...
[10:25:50.378] - state: ‘created’
[10:25:50.378] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.382] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.383]   - Field: ‘label’
[10:25:50.383]   - Field: ‘local’
[10:25:50.383]   - Field: ‘owner’
[10:25:50.383]   - Field: ‘envir’
[10:25:50.383]   - Field: ‘workers’
[10:25:50.383]   - Field: ‘packages’
[10:25:50.383]   - Field: ‘gc’
[10:25:50.384]   - Field: ‘job’
[10:25:50.384]   - Field: ‘conditions’
[10:25:50.384]   - Field: ‘expr’
[10:25:50.384]   - Field: ‘uuid’
[10:25:50.384]   - Field: ‘seed’
[10:25:50.384]   - Field: ‘version’
[10:25:50.384]   - Field: ‘result’
[10:25:50.384]   - Field: ‘asynchronous’
[10:25:50.384]   - Field: ‘calls’
[10:25:50.385]   - Field: ‘globals’
[10:25:50.385]   - Field: ‘stdout’
[10:25:50.385]   - Field: ‘earlySignal’
[10:25:50.385]   - Field: ‘lazy’
[10:25:50.385]   - Field: ‘state’
[10:25:50.385] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.385] - Launch lazy future ...
[10:25:50.386] Packages needed by the future expression (n = 0): <none>
[10:25:50.386] Packages needed by future strategies (n = 0): <none>
[10:25:50.386] {
[10:25:50.386]     {
[10:25:50.386]         {
[10:25:50.386]             ...future.startTime <- base::Sys.time()
[10:25:50.386]             {
[10:25:50.386]                 {
[10:25:50.386]                   {
[10:25:50.386]                     {
[10:25:50.386]                       base::local({
[10:25:50.386]                         has_future <- base::requireNamespace("future", 
[10:25:50.386]                           quietly = TRUE)
[10:25:50.386]                         if (has_future) {
[10:25:50.386]                           ns <- base::getNamespace("future")
[10:25:50.386]                           version <- ns[[".package"]][["version"]]
[10:25:50.386]                           if (is.null(version)) 
[10:25:50.386]                             version <- utils::packageVersion("future")
[10:25:50.386]                         }
[10:25:50.386]                         else {
[10:25:50.386]                           version <- NULL
[10:25:50.386]                         }
[10:25:50.386]                         if (!has_future || version < "1.8.0") {
[10:25:50.386]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.386]                             "", base::R.version$version.string), 
[10:25:50.386]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.386]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.386]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.386]                               "release", "version")], collapse = " "), 
[10:25:50.386]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.386]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.386]                             info)
[10:25:50.386]                           info <- base::paste(info, collapse = "; ")
[10:25:50.386]                           if (!has_future) {
[10:25:50.386]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.386]                               info)
[10:25:50.386]                           }
[10:25:50.386]                           else {
[10:25:50.386]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.386]                               info, version)
[10:25:50.386]                           }
[10:25:50.386]                           base::stop(msg)
[10:25:50.386]                         }
[10:25:50.386]                       })
[10:25:50.386]                     }
[10:25:50.386]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.386]                     base::options(mc.cores = 1L)
[10:25:50.386]                   }
[10:25:50.386]                   options(future.plan = NULL)
[10:25:50.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.386]                 }
[10:25:50.386]                 ...future.workdir <- getwd()
[10:25:50.386]             }
[10:25:50.386]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.386]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.386]         }
[10:25:50.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.386]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.386]             base::names(...future.oldOptions))
[10:25:50.386]     }
[10:25:50.386]     if (FALSE) {
[10:25:50.386]     }
[10:25:50.386]     else {
[10:25:50.386]         if (TRUE) {
[10:25:50.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.386]                 open = "w")
[10:25:50.386]         }
[10:25:50.386]         else {
[10:25:50.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.386]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.386]         }
[10:25:50.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.386]             base::sink(type = "output", split = FALSE)
[10:25:50.386]             base::close(...future.stdout)
[10:25:50.386]         }, add = TRUE)
[10:25:50.386]     }
[10:25:50.386]     ...future.frame <- base::sys.nframe()
[10:25:50.386]     ...future.conditions <- base::list()
[10:25:50.386]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.386]     if (FALSE) {
[10:25:50.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.386]     }
[10:25:50.386]     ...future.result <- base::tryCatch({
[10:25:50.386]         base::withCallingHandlers({
[10:25:50.386]             ...future.value <- base::withVisible(base::local({
[10:25:50.386]                 withCallingHandlers({
[10:25:50.386]                   2
[10:25:50.386]                 }, immediateCondition = function(cond) {
[10:25:50.386]                   save_rds <- function (object, pathname, ...) 
[10:25:50.386]                   {
[10:25:50.386]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.386]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.386]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.386]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.386]                         fi_tmp[["mtime"]])
[10:25:50.386]                     }
[10:25:50.386]                     tryCatch({
[10:25:50.386]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.386]                     }, error = function(ex) {
[10:25:50.386]                       msg <- conditionMessage(ex)
[10:25:50.386]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.386]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.386]                         fi_tmp[["mtime"]], msg)
[10:25:50.386]                       ex$message <- msg
[10:25:50.386]                       stop(ex)
[10:25:50.386]                     })
[10:25:50.386]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.386]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.386]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.386]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.386]                       fi <- file.info(pathname)
[10:25:50.386]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.386]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.386]                         fi[["size"]], fi[["mtime"]])
[10:25:50.386]                       stop(msg)
[10:25:50.386]                     }
[10:25:50.386]                     invisible(pathname)
[10:25:50.386]                   }
[10:25:50.386]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.386]                     rootPath = tempdir()) 
[10:25:50.386]                   {
[10:25:50.386]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.386]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.386]                       tmpdir = path, fileext = ".rds")
[10:25:50.386]                     save_rds(obj, file)
[10:25:50.386]                   }
[10:25:50.386]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.386]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.386]                   {
[10:25:50.386]                     inherits <- base::inherits
[10:25:50.386]                     invokeRestart <- base::invokeRestart
[10:25:50.386]                     is.null <- base::is.null
[10:25:50.386]                     muffled <- FALSE
[10:25:50.386]                     if (inherits(cond, "message")) {
[10:25:50.386]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.386]                       if (muffled) 
[10:25:50.386]                         invokeRestart("muffleMessage")
[10:25:50.386]                     }
[10:25:50.386]                     else if (inherits(cond, "warning")) {
[10:25:50.386]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.386]                       if (muffled) 
[10:25:50.386]                         invokeRestart("muffleWarning")
[10:25:50.386]                     }
[10:25:50.386]                     else if (inherits(cond, "condition")) {
[10:25:50.386]                       if (!is.null(pattern)) {
[10:25:50.386]                         computeRestarts <- base::computeRestarts
[10:25:50.386]                         grepl <- base::grepl
[10:25:50.386]                         restarts <- computeRestarts(cond)
[10:25:50.386]                         for (restart in restarts) {
[10:25:50.386]                           name <- restart$name
[10:25:50.386]                           if (is.null(name)) 
[10:25:50.386]                             next
[10:25:50.386]                           if (!grepl(pattern, name)) 
[10:25:50.386]                             next
[10:25:50.386]                           invokeRestart(restart)
[10:25:50.386]                           muffled <- TRUE
[10:25:50.386]                           break
[10:25:50.386]                         }
[10:25:50.386]                       }
[10:25:50.386]                     }
[10:25:50.386]                     invisible(muffled)
[10:25:50.386]                   }
[10:25:50.386]                   muffleCondition(cond)
[10:25:50.386]                 })
[10:25:50.386]             }))
[10:25:50.386]             future::FutureResult(value = ...future.value$value, 
[10:25:50.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.386]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.386]                     ...future.globalenv.names))
[10:25:50.386]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.386]         }, condition = base::local({
[10:25:50.386]             c <- base::c
[10:25:50.386]             inherits <- base::inherits
[10:25:50.386]             invokeRestart <- base::invokeRestart
[10:25:50.386]             length <- base::length
[10:25:50.386]             list <- base::list
[10:25:50.386]             seq.int <- base::seq.int
[10:25:50.386]             signalCondition <- base::signalCondition
[10:25:50.386]             sys.calls <- base::sys.calls
[10:25:50.386]             `[[` <- base::`[[`
[10:25:50.386]             `+` <- base::`+`
[10:25:50.386]             `<<-` <- base::`<<-`
[10:25:50.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.386]                   3L)]
[10:25:50.386]             }
[10:25:50.386]             function(cond) {
[10:25:50.386]                 is_error <- inherits(cond, "error")
[10:25:50.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.386]                   NULL)
[10:25:50.386]                 if (is_error) {
[10:25:50.386]                   sessionInformation <- function() {
[10:25:50.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.386]                       search = base::search(), system = base::Sys.info())
[10:25:50.386]                   }
[10:25:50.386]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.386]                     cond$call), session = sessionInformation(), 
[10:25:50.386]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.386]                   signalCondition(cond)
[10:25:50.386]                 }
[10:25:50.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.386]                 "immediateCondition"))) {
[10:25:50.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.386]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.386]                   if (TRUE && !signal) {
[10:25:50.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.386]                     {
[10:25:50.386]                       inherits <- base::inherits
[10:25:50.386]                       invokeRestart <- base::invokeRestart
[10:25:50.386]                       is.null <- base::is.null
[10:25:50.386]                       muffled <- FALSE
[10:25:50.386]                       if (inherits(cond, "message")) {
[10:25:50.386]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.386]                         if (muffled) 
[10:25:50.386]                           invokeRestart("muffleMessage")
[10:25:50.386]                       }
[10:25:50.386]                       else if (inherits(cond, "warning")) {
[10:25:50.386]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.386]                         if (muffled) 
[10:25:50.386]                           invokeRestart("muffleWarning")
[10:25:50.386]                       }
[10:25:50.386]                       else if (inherits(cond, "condition")) {
[10:25:50.386]                         if (!is.null(pattern)) {
[10:25:50.386]                           computeRestarts <- base::computeRestarts
[10:25:50.386]                           grepl <- base::grepl
[10:25:50.386]                           restarts <- computeRestarts(cond)
[10:25:50.386]                           for (restart in restarts) {
[10:25:50.386]                             name <- restart$name
[10:25:50.386]                             if (is.null(name)) 
[10:25:50.386]                               next
[10:25:50.386]                             if (!grepl(pattern, name)) 
[10:25:50.386]                               next
[10:25:50.386]                             invokeRestart(restart)
[10:25:50.386]                             muffled <- TRUE
[10:25:50.386]                             break
[10:25:50.386]                           }
[10:25:50.386]                         }
[10:25:50.386]                       }
[10:25:50.386]                       invisible(muffled)
[10:25:50.386]                     }
[10:25:50.386]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.386]                   }
[10:25:50.386]                 }
[10:25:50.386]                 else {
[10:25:50.386]                   if (TRUE) {
[10:25:50.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.386]                     {
[10:25:50.386]                       inherits <- base::inherits
[10:25:50.386]                       invokeRestart <- base::invokeRestart
[10:25:50.386]                       is.null <- base::is.null
[10:25:50.386]                       muffled <- FALSE
[10:25:50.386]                       if (inherits(cond, "message")) {
[10:25:50.386]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.386]                         if (muffled) 
[10:25:50.386]                           invokeRestart("muffleMessage")
[10:25:50.386]                       }
[10:25:50.386]                       else if (inherits(cond, "warning")) {
[10:25:50.386]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.386]                         if (muffled) 
[10:25:50.386]                           invokeRestart("muffleWarning")
[10:25:50.386]                       }
[10:25:50.386]                       else if (inherits(cond, "condition")) {
[10:25:50.386]                         if (!is.null(pattern)) {
[10:25:50.386]                           computeRestarts <- base::computeRestarts
[10:25:50.386]                           grepl <- base::grepl
[10:25:50.386]                           restarts <- computeRestarts(cond)
[10:25:50.386]                           for (restart in restarts) {
[10:25:50.386]                             name <- restart$name
[10:25:50.386]                             if (is.null(name)) 
[10:25:50.386]                               next
[10:25:50.386]                             if (!grepl(pattern, name)) 
[10:25:50.386]                               next
[10:25:50.386]                             invokeRestart(restart)
[10:25:50.386]                             muffled <- TRUE
[10:25:50.386]                             break
[10:25:50.386]                           }
[10:25:50.386]                         }
[10:25:50.386]                       }
[10:25:50.386]                       invisible(muffled)
[10:25:50.386]                     }
[10:25:50.386]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.386]                   }
[10:25:50.386]                 }
[10:25:50.386]             }
[10:25:50.386]         }))
[10:25:50.386]     }, error = function(ex) {
[10:25:50.386]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.386]                 ...future.rng), started = ...future.startTime, 
[10:25:50.386]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.386]             version = "1.8"), class = "FutureResult")
[10:25:50.386]     }, finally = {
[10:25:50.386]         if (!identical(...future.workdir, getwd())) 
[10:25:50.386]             setwd(...future.workdir)
[10:25:50.386]         {
[10:25:50.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.386]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.386]             }
[10:25:50.386]             base::options(...future.oldOptions)
[10:25:50.386]             if (.Platform$OS.type == "windows") {
[10:25:50.386]                 old_names <- names(...future.oldEnvVars)
[10:25:50.386]                 envs <- base::Sys.getenv()
[10:25:50.386]                 names <- names(envs)
[10:25:50.386]                 common <- intersect(names, old_names)
[10:25:50.386]                 added <- setdiff(names, old_names)
[10:25:50.386]                 removed <- setdiff(old_names, names)
[10:25:50.386]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.386]                   envs[common]]
[10:25:50.386]                 NAMES <- toupper(changed)
[10:25:50.386]                 args <- list()
[10:25:50.386]                 for (kk in seq_along(NAMES)) {
[10:25:50.386]                   name <- changed[[kk]]
[10:25:50.386]                   NAME <- NAMES[[kk]]
[10:25:50.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.386]                     next
[10:25:50.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.386]                 }
[10:25:50.386]                 NAMES <- toupper(added)
[10:25:50.386]                 for (kk in seq_along(NAMES)) {
[10:25:50.386]                   name <- added[[kk]]
[10:25:50.386]                   NAME <- NAMES[[kk]]
[10:25:50.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.386]                     next
[10:25:50.386]                   args[[name]] <- ""
[10:25:50.386]                 }
[10:25:50.386]                 NAMES <- toupper(removed)
[10:25:50.386]                 for (kk in seq_along(NAMES)) {
[10:25:50.386]                   name <- removed[[kk]]
[10:25:50.386]                   NAME <- NAMES[[kk]]
[10:25:50.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.386]                     next
[10:25:50.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.386]                 }
[10:25:50.386]                 if (length(args) > 0) 
[10:25:50.386]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.386]             }
[10:25:50.386]             else {
[10:25:50.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.386]             }
[10:25:50.386]             {
[10:25:50.386]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.386]                   0L) {
[10:25:50.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.386]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.386]                   base::options(opts)
[10:25:50.386]                 }
[10:25:50.386]                 {
[10:25:50.386]                   {
[10:25:50.386]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.386]                     NULL
[10:25:50.386]                   }
[10:25:50.386]                   options(future.plan = NULL)
[10:25:50.386]                   if (is.na(NA_character_)) 
[10:25:50.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.386]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.386]                     envir = parent.frame()) 
[10:25:50.386]                   {
[10:25:50.386]                     default_workers <- missing(workers)
[10:25:50.386]                     if (is.function(workers)) 
[10:25:50.386]                       workers <- workers()
[10:25:50.386]                     workers <- structure(as.integer(workers), 
[10:25:50.386]                       class = class(workers))
[10:25:50.386]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.386]                       1L)
[10:25:50.386]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.386]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.386]                       if (default_workers) 
[10:25:50.386]                         supportsMulticore(warn = TRUE)
[10:25:50.386]                       return(sequential(..., envir = envir))
[10:25:50.386]                     }
[10:25:50.386]                     oopts <- options(mc.cores = workers)
[10:25:50.386]                     on.exit(options(oopts))
[10:25:50.386]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.386]                       envir = envir)
[10:25:50.386]                     if (!future$lazy) 
[10:25:50.386]                       future <- run(future)
[10:25:50.386]                     invisible(future)
[10:25:50.386]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.386]                 }
[10:25:50.386]             }
[10:25:50.386]         }
[10:25:50.386]     })
[10:25:50.386]     if (TRUE) {
[10:25:50.386]         base::sink(type = "output", split = FALSE)
[10:25:50.386]         if (TRUE) {
[10:25:50.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.386]         }
[10:25:50.386]         else {
[10:25:50.386]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.386]         }
[10:25:50.386]         base::close(...future.stdout)
[10:25:50.386]         ...future.stdout <- NULL
[10:25:50.386]     }
[10:25:50.386]     ...future.result$conditions <- ...future.conditions
[10:25:50.386]     ...future.result$finished <- base::Sys.time()
[10:25:50.386]     ...future.result
[10:25:50.386] }
[10:25:50.389] requestCore(): workers = 2
[10:25:50.391] MulticoreFuture started
[10:25:50.392] - Launch lazy future ... done
[10:25:50.392] run() for ‘MulticoreFuture’ ... done
[10:25:50.392] getGlobalsAndPackages() ...
[10:25:50.392] Searching for globals...
[10:25:50.392] plan(): Setting new future strategy stack:
[10:25:50.392] List of future strategies:
[10:25:50.392] 1. sequential:
[10:25:50.392]    - args: function (..., envir = parent.frame())
[10:25:50.392]    - tweaked: FALSE
[10:25:50.392]    - call: NULL
[10:25:50.393] 
[10:25:50.393] Searching for globals ... DONE
[10:25:50.393] plan(): nbrOfWorkers() = 1
[10:25:50.393] - globals: [0] <none>
[10:25:50.394] getGlobalsAndPackages() ... DONE
[10:25:50.394] run() for ‘Future’ ...
[10:25:50.394] - state: ‘created’
[10:25:50.394] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.395] plan(): Setting new future strategy stack:
[10:25:50.395] List of future strategies:
[10:25:50.395] 1. multicore:
[10:25:50.395]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.395]    - tweaked: FALSE
[10:25:50.395]    - call: plan(strategy)
[10:25:50.400] plan(): nbrOfWorkers() = 2
[10:25:50.400] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.400]   - Field: ‘label’
[10:25:50.400]   - Field: ‘local’
[10:25:50.401]   - Field: ‘owner’
[10:25:50.401]   - Field: ‘envir’
[10:25:50.401]   - Field: ‘workers’
[10:25:50.401]   - Field: ‘packages’
[10:25:50.401]   - Field: ‘gc’
[10:25:50.401]   - Field: ‘job’
[10:25:50.402]   - Field: ‘conditions’
[10:25:50.402]   - Field: ‘expr’
[10:25:50.402]   - Field: ‘uuid’
[10:25:50.402]   - Field: ‘seed’
[10:25:50.402]   - Field: ‘version’
[10:25:50.402]   - Field: ‘result’
[10:25:50.403]   - Field: ‘asynchronous’
[10:25:50.403]   - Field: ‘calls’
[10:25:50.403]   - Field: ‘globals’
[10:25:50.403]   - Field: ‘stdout’
[10:25:50.403]   - Field: ‘earlySignal’
[10:25:50.403]   - Field: ‘lazy’
[10:25:50.403]   - Field: ‘state’
[10:25:50.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.404] - Launch lazy future ...
[10:25:50.404] Packages needed by the future expression (n = 0): <none>
[10:25:50.404] Packages needed by future strategies (n = 0): <none>
[10:25:50.405] {
[10:25:50.405]     {
[10:25:50.405]         {
[10:25:50.405]             ...future.startTime <- base::Sys.time()
[10:25:50.405]             {
[10:25:50.405]                 {
[10:25:50.405]                   {
[10:25:50.405]                     {
[10:25:50.405]                       base::local({
[10:25:50.405]                         has_future <- base::requireNamespace("future", 
[10:25:50.405]                           quietly = TRUE)
[10:25:50.405]                         if (has_future) {
[10:25:50.405]                           ns <- base::getNamespace("future")
[10:25:50.405]                           version <- ns[[".package"]][["version"]]
[10:25:50.405]                           if (is.null(version)) 
[10:25:50.405]                             version <- utils::packageVersion("future")
[10:25:50.405]                         }
[10:25:50.405]                         else {
[10:25:50.405]                           version <- NULL
[10:25:50.405]                         }
[10:25:50.405]                         if (!has_future || version < "1.8.0") {
[10:25:50.405]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.405]                             "", base::R.version$version.string), 
[10:25:50.405]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.405]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.405]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.405]                               "release", "version")], collapse = " "), 
[10:25:50.405]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.405]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.405]                             info)
[10:25:50.405]                           info <- base::paste(info, collapse = "; ")
[10:25:50.405]                           if (!has_future) {
[10:25:50.405]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.405]                               info)
[10:25:50.405]                           }
[10:25:50.405]                           else {
[10:25:50.405]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.405]                               info, version)
[10:25:50.405]                           }
[10:25:50.405]                           base::stop(msg)
[10:25:50.405]                         }
[10:25:50.405]                       })
[10:25:50.405]                     }
[10:25:50.405]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.405]                     base::options(mc.cores = 1L)
[10:25:50.405]                   }
[10:25:50.405]                   options(future.plan = NULL)
[10:25:50.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.405]                 }
[10:25:50.405]                 ...future.workdir <- getwd()
[10:25:50.405]             }
[10:25:50.405]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.405]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.405]         }
[10:25:50.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.405]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.405]             base::names(...future.oldOptions))
[10:25:50.405]     }
[10:25:50.405]     if (FALSE) {
[10:25:50.405]     }
[10:25:50.405]     else {
[10:25:50.405]         if (TRUE) {
[10:25:50.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.405]                 open = "w")
[10:25:50.405]         }
[10:25:50.405]         else {
[10:25:50.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.405]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.405]         }
[10:25:50.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.405]             base::sink(type = "output", split = FALSE)
[10:25:50.405]             base::close(...future.stdout)
[10:25:50.405]         }, add = TRUE)
[10:25:50.405]     }
[10:25:50.405]     ...future.frame <- base::sys.nframe()
[10:25:50.405]     ...future.conditions <- base::list()
[10:25:50.405]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.405]     if (FALSE) {
[10:25:50.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.405]     }
[10:25:50.405]     ...future.result <- base::tryCatch({
[10:25:50.405]         base::withCallingHandlers({
[10:25:50.405]             ...future.value <- base::withVisible(base::local({
[10:25:50.405]                 withCallingHandlers({
[10:25:50.405]                   NULL
[10:25:50.405]                 }, immediateCondition = function(cond) {
[10:25:50.405]                   save_rds <- function (object, pathname, ...) 
[10:25:50.405]                   {
[10:25:50.405]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.405]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.405]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.405]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.405]                         fi_tmp[["mtime"]])
[10:25:50.405]                     }
[10:25:50.405]                     tryCatch({
[10:25:50.405]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.405]                     }, error = function(ex) {
[10:25:50.405]                       msg <- conditionMessage(ex)
[10:25:50.405]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.405]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.405]                         fi_tmp[["mtime"]], msg)
[10:25:50.405]                       ex$message <- msg
[10:25:50.405]                       stop(ex)
[10:25:50.405]                     })
[10:25:50.405]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.405]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.405]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.405]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.405]                       fi <- file.info(pathname)
[10:25:50.405]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.405]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.405]                         fi[["size"]], fi[["mtime"]])
[10:25:50.405]                       stop(msg)
[10:25:50.405]                     }
[10:25:50.405]                     invisible(pathname)
[10:25:50.405]                   }
[10:25:50.405]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.405]                     rootPath = tempdir()) 
[10:25:50.405]                   {
[10:25:50.405]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.405]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.405]                       tmpdir = path, fileext = ".rds")
[10:25:50.405]                     save_rds(obj, file)
[10:25:50.405]                   }
[10:25:50.405]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.405]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.405]                   {
[10:25:50.405]                     inherits <- base::inherits
[10:25:50.405]                     invokeRestart <- base::invokeRestart
[10:25:50.405]                     is.null <- base::is.null
[10:25:50.405]                     muffled <- FALSE
[10:25:50.405]                     if (inherits(cond, "message")) {
[10:25:50.405]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.405]                       if (muffled) 
[10:25:50.405]                         invokeRestart("muffleMessage")
[10:25:50.405]                     }
[10:25:50.405]                     else if (inherits(cond, "warning")) {
[10:25:50.405]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.405]                       if (muffled) 
[10:25:50.405]                         invokeRestart("muffleWarning")
[10:25:50.405]                     }
[10:25:50.405]                     else if (inherits(cond, "condition")) {
[10:25:50.405]                       if (!is.null(pattern)) {
[10:25:50.405]                         computeRestarts <- base::computeRestarts
[10:25:50.405]                         grepl <- base::grepl
[10:25:50.405]                         restarts <- computeRestarts(cond)
[10:25:50.405]                         for (restart in restarts) {
[10:25:50.405]                           name <- restart$name
[10:25:50.405]                           if (is.null(name)) 
[10:25:50.405]                             next
[10:25:50.405]                           if (!grepl(pattern, name)) 
[10:25:50.405]                             next
[10:25:50.405]                           invokeRestart(restart)
[10:25:50.405]                           muffled <- TRUE
[10:25:50.405]                           break
[10:25:50.405]                         }
[10:25:50.405]                       }
[10:25:50.405]                     }
[10:25:50.405]                     invisible(muffled)
[10:25:50.405]                   }
[10:25:50.405]                   muffleCondition(cond)
[10:25:50.405]                 })
[10:25:50.405]             }))
[10:25:50.405]             future::FutureResult(value = ...future.value$value, 
[10:25:50.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.405]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.405]                     ...future.globalenv.names))
[10:25:50.405]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.405]         }, condition = base::local({
[10:25:50.405]             c <- base::c
[10:25:50.405]             inherits <- base::inherits
[10:25:50.405]             invokeRestart <- base::invokeRestart
[10:25:50.405]             length <- base::length
[10:25:50.405]             list <- base::list
[10:25:50.405]             seq.int <- base::seq.int
[10:25:50.405]             signalCondition <- base::signalCondition
[10:25:50.405]             sys.calls <- base::sys.calls
[10:25:50.405]             `[[` <- base::`[[`
[10:25:50.405]             `+` <- base::`+`
[10:25:50.405]             `<<-` <- base::`<<-`
[10:25:50.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.405]                   3L)]
[10:25:50.405]             }
[10:25:50.405]             function(cond) {
[10:25:50.405]                 is_error <- inherits(cond, "error")
[10:25:50.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.405]                   NULL)
[10:25:50.405]                 if (is_error) {
[10:25:50.405]                   sessionInformation <- function() {
[10:25:50.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.405]                       search = base::search(), system = base::Sys.info())
[10:25:50.405]                   }
[10:25:50.405]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.405]                     cond$call), session = sessionInformation(), 
[10:25:50.405]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.405]                   signalCondition(cond)
[10:25:50.405]                 }
[10:25:50.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.405]                 "immediateCondition"))) {
[10:25:50.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.405]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.405]                   if (TRUE && !signal) {
[10:25:50.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.405]                     {
[10:25:50.405]                       inherits <- base::inherits
[10:25:50.405]                       invokeRestart <- base::invokeRestart
[10:25:50.405]                       is.null <- base::is.null
[10:25:50.405]                       muffled <- FALSE
[10:25:50.405]                       if (inherits(cond, "message")) {
[10:25:50.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.405]                         if (muffled) 
[10:25:50.405]                           invokeRestart("muffleMessage")
[10:25:50.405]                       }
[10:25:50.405]                       else if (inherits(cond, "warning")) {
[10:25:50.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.405]                         if (muffled) 
[10:25:50.405]                           invokeRestart("muffleWarning")
[10:25:50.405]                       }
[10:25:50.405]                       else if (inherits(cond, "condition")) {
[10:25:50.405]                         if (!is.null(pattern)) {
[10:25:50.405]                           computeRestarts <- base::computeRestarts
[10:25:50.405]                           grepl <- base::grepl
[10:25:50.405]                           restarts <- computeRestarts(cond)
[10:25:50.405]                           for (restart in restarts) {
[10:25:50.405]                             name <- restart$name
[10:25:50.405]                             if (is.null(name)) 
[10:25:50.405]                               next
[10:25:50.405]                             if (!grepl(pattern, name)) 
[10:25:50.405]                               next
[10:25:50.405]                             invokeRestart(restart)
[10:25:50.405]                             muffled <- TRUE
[10:25:50.405]                             break
[10:25:50.405]                           }
[10:25:50.405]                         }
[10:25:50.405]                       }
[10:25:50.405]                       invisible(muffled)
[10:25:50.405]                     }
[10:25:50.405]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.405]                   }
[10:25:50.405]                 }
[10:25:50.405]                 else {
[10:25:50.405]                   if (TRUE) {
[10:25:50.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.405]                     {
[10:25:50.405]                       inherits <- base::inherits
[10:25:50.405]                       invokeRestart <- base::invokeRestart
[10:25:50.405]                       is.null <- base::is.null
[10:25:50.405]                       muffled <- FALSE
[10:25:50.405]                       if (inherits(cond, "message")) {
[10:25:50.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.405]                         if (muffled) 
[10:25:50.405]                           invokeRestart("muffleMessage")
[10:25:50.405]                       }
[10:25:50.405]                       else if (inherits(cond, "warning")) {
[10:25:50.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.405]                         if (muffled) 
[10:25:50.405]                           invokeRestart("muffleWarning")
[10:25:50.405]                       }
[10:25:50.405]                       else if (inherits(cond, "condition")) {
[10:25:50.405]                         if (!is.null(pattern)) {
[10:25:50.405]                           computeRestarts <- base::computeRestarts
[10:25:50.405]                           grepl <- base::grepl
[10:25:50.405]                           restarts <- computeRestarts(cond)
[10:25:50.405]                           for (restart in restarts) {
[10:25:50.405]                             name <- restart$name
[10:25:50.405]                             if (is.null(name)) 
[10:25:50.405]                               next
[10:25:50.405]                             if (!grepl(pattern, name)) 
[10:25:50.405]                               next
[10:25:50.405]                             invokeRestart(restart)
[10:25:50.405]                             muffled <- TRUE
[10:25:50.405]                             break
[10:25:50.405]                           }
[10:25:50.405]                         }
[10:25:50.405]                       }
[10:25:50.405]                       invisible(muffled)
[10:25:50.405]                     }
[10:25:50.405]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.405]                   }
[10:25:50.405]                 }
[10:25:50.405]             }
[10:25:50.405]         }))
[10:25:50.405]     }, error = function(ex) {
[10:25:50.405]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.405]                 ...future.rng), started = ...future.startTime, 
[10:25:50.405]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.405]             version = "1.8"), class = "FutureResult")
[10:25:50.405]     }, finally = {
[10:25:50.405]         if (!identical(...future.workdir, getwd())) 
[10:25:50.405]             setwd(...future.workdir)
[10:25:50.405]         {
[10:25:50.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.405]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.405]             }
[10:25:50.405]             base::options(...future.oldOptions)
[10:25:50.405]             if (.Platform$OS.type == "windows") {
[10:25:50.405]                 old_names <- names(...future.oldEnvVars)
[10:25:50.405]                 envs <- base::Sys.getenv()
[10:25:50.405]                 names <- names(envs)
[10:25:50.405]                 common <- intersect(names, old_names)
[10:25:50.405]                 added <- setdiff(names, old_names)
[10:25:50.405]                 removed <- setdiff(old_names, names)
[10:25:50.405]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.405]                   envs[common]]
[10:25:50.405]                 NAMES <- toupper(changed)
[10:25:50.405]                 args <- list()
[10:25:50.405]                 for (kk in seq_along(NAMES)) {
[10:25:50.405]                   name <- changed[[kk]]
[10:25:50.405]                   NAME <- NAMES[[kk]]
[10:25:50.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.405]                     next
[10:25:50.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.405]                 }
[10:25:50.405]                 NAMES <- toupper(added)
[10:25:50.405]                 for (kk in seq_along(NAMES)) {
[10:25:50.405]                   name <- added[[kk]]
[10:25:50.405]                   NAME <- NAMES[[kk]]
[10:25:50.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.405]                     next
[10:25:50.405]                   args[[name]] <- ""
[10:25:50.405]                 }
[10:25:50.405]                 NAMES <- toupper(removed)
[10:25:50.405]                 for (kk in seq_along(NAMES)) {
[10:25:50.405]                   name <- removed[[kk]]
[10:25:50.405]                   NAME <- NAMES[[kk]]
[10:25:50.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.405]                     next
[10:25:50.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.405]                 }
[10:25:50.405]                 if (length(args) > 0) 
[10:25:50.405]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.405]             }
[10:25:50.405]             else {
[10:25:50.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.405]             }
[10:25:50.405]             {
[10:25:50.405]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.405]                   0L) {
[10:25:50.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.405]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.405]                   base::options(opts)
[10:25:50.405]                 }
[10:25:50.405]                 {
[10:25:50.405]                   {
[10:25:50.405]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.405]                     NULL
[10:25:50.405]                   }
[10:25:50.405]                   options(future.plan = NULL)
[10:25:50.405]                   if (is.na(NA_character_)) 
[10:25:50.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.405]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.405]                     envir = parent.frame()) 
[10:25:50.405]                   {
[10:25:50.405]                     default_workers <- missing(workers)
[10:25:50.405]                     if (is.function(workers)) 
[10:25:50.405]                       workers <- workers()
[10:25:50.405]                     workers <- structure(as.integer(workers), 
[10:25:50.405]                       class = class(workers))
[10:25:50.405]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.405]                       1L)
[10:25:50.405]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.405]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.405]                       if (default_workers) 
[10:25:50.405]                         supportsMulticore(warn = TRUE)
[10:25:50.405]                       return(sequential(..., envir = envir))
[10:25:50.405]                     }
[10:25:50.405]                     oopts <- options(mc.cores = workers)
[10:25:50.405]                     on.exit(options(oopts))
[10:25:50.405]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.405]                       envir = envir)
[10:25:50.405]                     if (!future$lazy) 
[10:25:50.405]                       future <- run(future)
[10:25:50.405]                     invisible(future)
[10:25:50.405]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.405]                 }
[10:25:50.405]             }
[10:25:50.405]         }
[10:25:50.405]     })
[10:25:50.405]     if (TRUE) {
[10:25:50.405]         base::sink(type = "output", split = FALSE)
[10:25:50.405]         if (TRUE) {
[10:25:50.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.405]         }
[10:25:50.405]         else {
[10:25:50.405]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.405]         }
[10:25:50.405]         base::close(...future.stdout)
[10:25:50.405]         ...future.stdout <- NULL
[10:25:50.405]     }
[10:25:50.405]     ...future.result$conditions <- ...future.conditions
[10:25:50.405]     ...future.result$finished <- base::Sys.time()
[10:25:50.405]     ...future.result
[10:25:50.405] }
[10:25:50.409] requestCore(): workers = 2
[10:25:50.411] MulticoreFuture started
[10:25:50.411] - Launch lazy future ... done
[10:25:50.412] run() for ‘MulticoreFuture’ ... done
[10:25:50.412] plan(): Setting new future strategy stack:
[10:25:50.413] getGlobalsAndPackages() ...
[10:25:50.413] Searching for globals...
[10:25:50.412] List of future strategies:
[10:25:50.412] 1. sequential:
[10:25:50.412]    - args: function (..., envir = parent.frame())
[10:25:50.412]    - tweaked: FALSE
[10:25:50.412]    - call: NULL
[10:25:50.413] plan(): nbrOfWorkers() = 1
[10:25:50.414] - globals found: [1] ‘{’
[10:25:50.414] Searching for globals ... DONE
[10:25:50.415] Resolving globals: FALSE
[10:25:50.415] 
[10:25:50.415] plan(): Setting new future strategy stack:
[10:25:50.415] 
[10:25:50.415] getGlobalsAndPackages() ... DONE
[10:25:50.415] List of future strategies:
[10:25:50.415] 1. multicore:
[10:25:50.415]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.415]    - tweaked: FALSE
[10:25:50.415]    - call: plan(strategy)
[10:25:50.416] run() for ‘Future’ ...
[10:25:50.416] - state: ‘created’
[10:25:50.416] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.420] plan(): nbrOfWorkers() = 2
[10:25:50.421] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:50.421]   - Field: ‘label’
[10:25:50.421]   - Field: ‘local’
[10:25:50.421]   - Field: ‘owner’
[10:25:50.422]   - Field: ‘envir’
[10:25:50.422]   - Field: ‘workers’
[10:25:50.422]   - Field: ‘packages’
[10:25:50.422]   - Field: ‘gc’
[10:25:50.422]   - Field: ‘job’
[10:25:50.422]   - Field: ‘conditions’
[10:25:50.422]   - Field: ‘expr’
[10:25:50.423]   - Field: ‘uuid’
[10:25:50.423]   - Field: ‘seed’
[10:25:50.423]   - Field: ‘version’
[10:25:50.423]   - Field: ‘result’
[10:25:50.423]   - Field: ‘asynchronous’
[10:25:50.423]   - Field: ‘calls’
[10:25:50.423]   - Field: ‘globals’
[10:25:50.424]   - Field: ‘stdout’
[10:25:50.424]   - Field: ‘earlySignal’
[10:25:50.424]   - Field: ‘lazy’
[10:25:50.424]   - Field: ‘state’
[10:25:50.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:50.424] - Launch lazy future ...
[10:25:50.425] Packages needed by the future expression (n = 0): <none>
[10:25:50.425] Packages needed by future strategies (n = 0): <none>
[10:25:50.426] {
[10:25:50.426]     {
[10:25:50.426]         {
[10:25:50.426]             ...future.startTime <- base::Sys.time()
[10:25:50.426]             {
[10:25:50.426]                 {
[10:25:50.426]                   {
[10:25:50.426]                     {
[10:25:50.426]                       base::local({
[10:25:50.426]                         has_future <- base::requireNamespace("future", 
[10:25:50.426]                           quietly = TRUE)
[10:25:50.426]                         if (has_future) {
[10:25:50.426]                           ns <- base::getNamespace("future")
[10:25:50.426]                           version <- ns[[".package"]][["version"]]
[10:25:50.426]                           if (is.null(version)) 
[10:25:50.426]                             version <- utils::packageVersion("future")
[10:25:50.426]                         }
[10:25:50.426]                         else {
[10:25:50.426]                           version <- NULL
[10:25:50.426]                         }
[10:25:50.426]                         if (!has_future || version < "1.8.0") {
[10:25:50.426]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.426]                             "", base::R.version$version.string), 
[10:25:50.426]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.426]                               "release", "version")], collapse = " "), 
[10:25:50.426]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.426]                             info)
[10:25:50.426]                           info <- base::paste(info, collapse = "; ")
[10:25:50.426]                           if (!has_future) {
[10:25:50.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.426]                               info)
[10:25:50.426]                           }
[10:25:50.426]                           else {
[10:25:50.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.426]                               info, version)
[10:25:50.426]                           }
[10:25:50.426]                           base::stop(msg)
[10:25:50.426]                         }
[10:25:50.426]                       })
[10:25:50.426]                     }
[10:25:50.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.426]                     base::options(mc.cores = 1L)
[10:25:50.426]                   }
[10:25:50.426]                   options(future.plan = NULL)
[10:25:50.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.426]                 }
[10:25:50.426]                 ...future.workdir <- getwd()
[10:25:50.426]             }
[10:25:50.426]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.426]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.426]         }
[10:25:50.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.426]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.426]             base::names(...future.oldOptions))
[10:25:50.426]     }
[10:25:50.426]     if (FALSE) {
[10:25:50.426]     }
[10:25:50.426]     else {
[10:25:50.426]         if (TRUE) {
[10:25:50.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.426]                 open = "w")
[10:25:50.426]         }
[10:25:50.426]         else {
[10:25:50.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.426]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.426]         }
[10:25:50.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.426]             base::sink(type = "output", split = FALSE)
[10:25:50.426]             base::close(...future.stdout)
[10:25:50.426]         }, add = TRUE)
[10:25:50.426]     }
[10:25:50.426]     ...future.frame <- base::sys.nframe()
[10:25:50.426]     ...future.conditions <- base::list()
[10:25:50.426]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.426]     if (FALSE) {
[10:25:50.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.426]     }
[10:25:50.426]     ...future.result <- base::tryCatch({
[10:25:50.426]         base::withCallingHandlers({
[10:25:50.426]             ...future.value <- base::withVisible(base::local({
[10:25:50.426]                 withCallingHandlers({
[10:25:50.426]                   {
[10:25:50.426]                     4
[10:25:50.426]                   }
[10:25:50.426]                 }, immediateCondition = function(cond) {
[10:25:50.426]                   save_rds <- function (object, pathname, ...) 
[10:25:50.426]                   {
[10:25:50.426]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:50.426]                     if (file_test("-f", pathname_tmp)) {
[10:25:50.426]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.426]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:50.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.426]                         fi_tmp[["mtime"]])
[10:25:50.426]                     }
[10:25:50.426]                     tryCatch({
[10:25:50.426]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:50.426]                     }, error = function(ex) {
[10:25:50.426]                       msg <- conditionMessage(ex)
[10:25:50.426]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.426]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:50.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.426]                         fi_tmp[["mtime"]], msg)
[10:25:50.426]                       ex$message <- msg
[10:25:50.426]                       stop(ex)
[10:25:50.426]                     })
[10:25:50.426]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:50.426]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:50.426]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:50.426]                       fi_tmp <- file.info(pathname_tmp)
[10:25:50.426]                       fi <- file.info(pathname)
[10:25:50.426]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:50.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:50.426]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:50.426]                         fi[["size"]], fi[["mtime"]])
[10:25:50.426]                       stop(msg)
[10:25:50.426]                     }
[10:25:50.426]                     invisible(pathname)
[10:25:50.426]                   }
[10:25:50.426]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:50.426]                     rootPath = tempdir()) 
[10:25:50.426]                   {
[10:25:50.426]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:50.426]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:50.426]                       tmpdir = path, fileext = ".rds")
[10:25:50.426]                     save_rds(obj, file)
[10:25:50.426]                   }
[10:25:50.426]                   saveImmediateCondition(cond, path = "/tmp/Rtmpt2gjBk/.future/immediateConditions")
[10:25:50.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.426]                   {
[10:25:50.426]                     inherits <- base::inherits
[10:25:50.426]                     invokeRestart <- base::invokeRestart
[10:25:50.426]                     is.null <- base::is.null
[10:25:50.426]                     muffled <- FALSE
[10:25:50.426]                     if (inherits(cond, "message")) {
[10:25:50.426]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.426]                       if (muffled) 
[10:25:50.426]                         invokeRestart("muffleMessage")
[10:25:50.426]                     }
[10:25:50.426]                     else if (inherits(cond, "warning")) {
[10:25:50.426]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.426]                       if (muffled) 
[10:25:50.426]                         invokeRestart("muffleWarning")
[10:25:50.426]                     }
[10:25:50.426]                     else if (inherits(cond, "condition")) {
[10:25:50.426]                       if (!is.null(pattern)) {
[10:25:50.426]                         computeRestarts <- base::computeRestarts
[10:25:50.426]                         grepl <- base::grepl
[10:25:50.426]                         restarts <- computeRestarts(cond)
[10:25:50.426]                         for (restart in restarts) {
[10:25:50.426]                           name <- restart$name
[10:25:50.426]                           if (is.null(name)) 
[10:25:50.426]                             next
[10:25:50.426]                           if (!grepl(pattern, name)) 
[10:25:50.426]                             next
[10:25:50.426]                           invokeRestart(restart)
[10:25:50.426]                           muffled <- TRUE
[10:25:50.426]                           break
[10:25:50.426]                         }
[10:25:50.426]                       }
[10:25:50.426]                     }
[10:25:50.426]                     invisible(muffled)
[10:25:50.426]                   }
[10:25:50.426]                   muffleCondition(cond)
[10:25:50.426]                 })
[10:25:50.426]             }))
[10:25:50.426]             future::FutureResult(value = ...future.value$value, 
[10:25:50.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.426]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.426]                     ...future.globalenv.names))
[10:25:50.426]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.426]         }, condition = base::local({
[10:25:50.426]             c <- base::c
[10:25:50.426]             inherits <- base::inherits
[10:25:50.426]             invokeRestart <- base::invokeRestart
[10:25:50.426]             length <- base::length
[10:25:50.426]             list <- base::list
[10:25:50.426]             seq.int <- base::seq.int
[10:25:50.426]             signalCondition <- base::signalCondition
[10:25:50.426]             sys.calls <- base::sys.calls
[10:25:50.426]             `[[` <- base::`[[`
[10:25:50.426]             `+` <- base::`+`
[10:25:50.426]             `<<-` <- base::`<<-`
[10:25:50.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.426]                   3L)]
[10:25:50.426]             }
[10:25:50.426]             function(cond) {
[10:25:50.426]                 is_error <- inherits(cond, "error")
[10:25:50.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.426]                   NULL)
[10:25:50.426]                 if (is_error) {
[10:25:50.426]                   sessionInformation <- function() {
[10:25:50.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.426]                       search = base::search(), system = base::Sys.info())
[10:25:50.426]                   }
[10:25:50.426]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.426]                     cond$call), session = sessionInformation(), 
[10:25:50.426]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.426]                   signalCondition(cond)
[10:25:50.426]                 }
[10:25:50.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.426]                 "immediateCondition"))) {
[10:25:50.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.426]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.426]                   if (TRUE && !signal) {
[10:25:50.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.426]                     {
[10:25:50.426]                       inherits <- base::inherits
[10:25:50.426]                       invokeRestart <- base::invokeRestart
[10:25:50.426]                       is.null <- base::is.null
[10:25:50.426]                       muffled <- FALSE
[10:25:50.426]                       if (inherits(cond, "message")) {
[10:25:50.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.426]                         if (muffled) 
[10:25:50.426]                           invokeRestart("muffleMessage")
[10:25:50.426]                       }
[10:25:50.426]                       else if (inherits(cond, "warning")) {
[10:25:50.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.426]                         if (muffled) 
[10:25:50.426]                           invokeRestart("muffleWarning")
[10:25:50.426]                       }
[10:25:50.426]                       else if (inherits(cond, "condition")) {
[10:25:50.426]                         if (!is.null(pattern)) {
[10:25:50.426]                           computeRestarts <- base::computeRestarts
[10:25:50.426]                           grepl <- base::grepl
[10:25:50.426]                           restarts <- computeRestarts(cond)
[10:25:50.426]                           for (restart in restarts) {
[10:25:50.426]                             name <- restart$name
[10:25:50.426]                             if (is.null(name)) 
[10:25:50.426]                               next
[10:25:50.426]                             if (!grepl(pattern, name)) 
[10:25:50.426]                               next
[10:25:50.426]                             invokeRestart(restart)
[10:25:50.426]                             muffled <- TRUE
[10:25:50.426]                             break
[10:25:50.426]                           }
[10:25:50.426]                         }
[10:25:50.426]                       }
[10:25:50.426]                       invisible(muffled)
[10:25:50.426]                     }
[10:25:50.426]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.426]                   }
[10:25:50.426]                 }
[10:25:50.426]                 else {
[10:25:50.426]                   if (TRUE) {
[10:25:50.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.426]                     {
[10:25:50.426]                       inherits <- base::inherits
[10:25:50.426]                       invokeRestart <- base::invokeRestart
[10:25:50.426]                       is.null <- base::is.null
[10:25:50.426]                       muffled <- FALSE
[10:25:50.426]                       if (inherits(cond, "message")) {
[10:25:50.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.426]                         if (muffled) 
[10:25:50.426]                           invokeRestart("muffleMessage")
[10:25:50.426]                       }
[10:25:50.426]                       else if (inherits(cond, "warning")) {
[10:25:50.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.426]                         if (muffled) 
[10:25:50.426]                           invokeRestart("muffleWarning")
[10:25:50.426]                       }
[10:25:50.426]                       else if (inherits(cond, "condition")) {
[10:25:50.426]                         if (!is.null(pattern)) {
[10:25:50.426]                           computeRestarts <- base::computeRestarts
[10:25:50.426]                           grepl <- base::grepl
[10:25:50.426]                           restarts <- computeRestarts(cond)
[10:25:50.426]                           for (restart in restarts) {
[10:25:50.426]                             name <- restart$name
[10:25:50.426]                             if (is.null(name)) 
[10:25:50.426]                               next
[10:25:50.426]                             if (!grepl(pattern, name)) 
[10:25:50.426]                               next
[10:25:50.426]                             invokeRestart(restart)
[10:25:50.426]                             muffled <- TRUE
[10:25:50.426]                             break
[10:25:50.426]                           }
[10:25:50.426]                         }
[10:25:50.426]                       }
[10:25:50.426]                       invisible(muffled)
[10:25:50.426]                     }
[10:25:50.426]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.426]                   }
[10:25:50.426]                 }
[10:25:50.426]             }
[10:25:50.426]         }))
[10:25:50.426]     }, error = function(ex) {
[10:25:50.426]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.426]                 ...future.rng), started = ...future.startTime, 
[10:25:50.426]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.426]             version = "1.8"), class = "FutureResult")
[10:25:50.426]     }, finally = {
[10:25:50.426]         if (!identical(...future.workdir, getwd())) 
[10:25:50.426]             setwd(...future.workdir)
[10:25:50.426]         {
[10:25:50.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.426]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.426]             }
[10:25:50.426]             base::options(...future.oldOptions)
[10:25:50.426]             if (.Platform$OS.type == "windows") {
[10:25:50.426]                 old_names <- names(...future.oldEnvVars)
[10:25:50.426]                 envs <- base::Sys.getenv()
[10:25:50.426]                 names <- names(envs)
[10:25:50.426]                 common <- intersect(names, old_names)
[10:25:50.426]                 added <- setdiff(names, old_names)
[10:25:50.426]                 removed <- setdiff(old_names, names)
[10:25:50.426]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.426]                   envs[common]]
[10:25:50.426]                 NAMES <- toupper(changed)
[10:25:50.426]                 args <- list()
[10:25:50.426]                 for (kk in seq_along(NAMES)) {
[10:25:50.426]                   name <- changed[[kk]]
[10:25:50.426]                   NAME <- NAMES[[kk]]
[10:25:50.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.426]                     next
[10:25:50.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.426]                 }
[10:25:50.426]                 NAMES <- toupper(added)
[10:25:50.426]                 for (kk in seq_along(NAMES)) {
[10:25:50.426]                   name <- added[[kk]]
[10:25:50.426]                   NAME <- NAMES[[kk]]
[10:25:50.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.426]                     next
[10:25:50.426]                   args[[name]] <- ""
[10:25:50.426]                 }
[10:25:50.426]                 NAMES <- toupper(removed)
[10:25:50.426]                 for (kk in seq_along(NAMES)) {
[10:25:50.426]                   name <- removed[[kk]]
[10:25:50.426]                   NAME <- NAMES[[kk]]
[10:25:50.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.426]                     next
[10:25:50.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.426]                 }
[10:25:50.426]                 if (length(args) > 0) 
[10:25:50.426]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.426]             }
[10:25:50.426]             else {
[10:25:50.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.426]             }
[10:25:50.426]             {
[10:25:50.426]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.426]                   0L) {
[10:25:50.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.426]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.426]                   base::options(opts)
[10:25:50.426]                 }
[10:25:50.426]                 {
[10:25:50.426]                   {
[10:25:50.426]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.426]                     NULL
[10:25:50.426]                   }
[10:25:50.426]                   options(future.plan = NULL)
[10:25:50.426]                   if (is.na(NA_character_)) 
[10:25:50.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.426]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:50.426]                     envir = parent.frame()) 
[10:25:50.426]                   {
[10:25:50.426]                     default_workers <- missing(workers)
[10:25:50.426]                     if (is.function(workers)) 
[10:25:50.426]                       workers <- workers()
[10:25:50.426]                     workers <- structure(as.integer(workers), 
[10:25:50.426]                       class = class(workers))
[10:25:50.426]                     stop_if_not(is.finite(workers), workers >= 
[10:25:50.426]                       1L)
[10:25:50.426]                     if ((workers == 1L && !inherits(workers, 
[10:25:50.426]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:50.426]                       if (default_workers) 
[10:25:50.426]                         supportsMulticore(warn = TRUE)
[10:25:50.426]                       return(sequential(..., envir = envir))
[10:25:50.426]                     }
[10:25:50.426]                     oopts <- options(mc.cores = workers)
[10:25:50.426]                     on.exit(options(oopts))
[10:25:50.426]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:50.426]                       envir = envir)
[10:25:50.426]                     if (!future$lazy) 
[10:25:50.426]                       future <- run(future)
[10:25:50.426]                     invisible(future)
[10:25:50.426]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.426]                 }
[10:25:50.426]             }
[10:25:50.426]         }
[10:25:50.426]     })
[10:25:50.426]     if (TRUE) {
[10:25:50.426]         base::sink(type = "output", split = FALSE)
[10:25:50.426]         if (TRUE) {
[10:25:50.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.426]         }
[10:25:50.426]         else {
[10:25:50.426]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.426]         }
[10:25:50.426]         base::close(...future.stdout)
[10:25:50.426]         ...future.stdout <- NULL
[10:25:50.426]     }
[10:25:50.426]     ...future.result$conditions <- ...future.conditions
[10:25:50.426]     ...future.result$finished <- base::Sys.time()
[10:25:50.426]     ...future.result
[10:25:50.426] }
[10:25:50.429] requestCore(): workers = 2
[10:25:50.429] Poll #1 (0): usedCores() = 2, workers = 2
[10:25:50.440] result() for MulticoreFuture ...
[10:25:50.441] result() for MulticoreFuture ...
[10:25:50.441] result() for MulticoreFuture ... done
[10:25:50.442] result() for MulticoreFuture ... done
[10:25:50.442] result() for MulticoreFuture ...
[10:25:50.442] result() for MulticoreFuture ... done
[10:25:50.444] MulticoreFuture started
[10:25:50.445] - Launch lazy future ... done
[10:25:50.456] plan(): Setting new future strategy stack:
[10:25:50.457] run() for ‘MulticoreFuture’ ... done
Classes 'listenv', 'environment' [10:25:50.457] List of future strategies:
[10:25:50.457] 1. sequential:
[10:25:50.457]    - args: function (..., envir = parent.frame())
[10:25:50.457]    - tweaked: FALSE
[10:25:50.457]    - call: NULL
<environment: 0x55c0f6761f80> 
[10:25:50.459] plan(): nbrOfWorkers() = 1
[10:25:50.462] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55c0f5ac0af0> 
 - attr(*, "dim.")=[10:25:50.462] List of future strategies:
[10:25:50.462] 1. multicore:
[10:25:50.462]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:50.462]    - tweaked: FALSE
[10:25:50.462]    - call: plan(strategy)
 int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:25:50.469] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:50.473] resolve() on list environment ...
[10:25:50.473]  recursive: 0
[10:25:50.475]  length: 6
[10:25:50.475]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:50.475] signalConditionsASAP(numeric, pos=1) ...
[10:25:50.475] - nx: 6
[10:25:50.475] - relay: TRUE
[10:25:50.475] - stdout: TRUE
[10:25:50.475] - signal: TRUE
[10:25:50.476] - resignal: FALSE
[10:25:50.476] - force: TRUE
[10:25:50.476] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.476] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.476]  - until=2
[10:25:50.476]  - relaying element #2
[10:25:50.476] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.477] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.477] signalConditionsASAP(NULL, pos=1) ... done
[10:25:50.477]  length: 5 (resolved future 1)
[10:25:50.477] Future #2
[10:25:50.477] result() for MulticoreFuture ...
[10:25:50.477] result() for MulticoreFuture ... done
[10:25:50.477] result() for MulticoreFuture ...
[10:25:50.478] result() for MulticoreFuture ... done
[10:25:50.478] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:25:50.478] - nx: 6
[10:25:50.478] - relay: TRUE
[10:25:50.478] - stdout: TRUE
[10:25:50.478] - signal: TRUE
[10:25:50.478] - resignal: FALSE
[10:25:50.478] - force: TRUE
[10:25:50.479] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.479] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:50.479]  - until=2
[10:25:50.479]  - relaying element #2
[10:25:50.479] result() for MulticoreFuture ...
[10:25:50.479] result() for MulticoreFuture ... done
[10:25:50.479] result() for MulticoreFuture ...
[10:25:50.479] result() for MulticoreFuture ... done
[10:25:50.480] result() for MulticoreFuture ...
[10:25:50.480] result() for MulticoreFuture ... done
[10:25:50.480] result() for MulticoreFuture ...
[10:25:50.480] result() for MulticoreFuture ... done
[10:25:50.480] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.480] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.480] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:25:50.481]  length: 4 (resolved future 2)
[10:25:50.481] Future #3
[10:25:50.481] result() for MulticoreFuture ...
[10:25:50.482] result() for MulticoreFuture ...
[10:25:50.482] result() for MulticoreFuture ... done
[10:25:50.482] result() for MulticoreFuture ... done
[10:25:50.482] result() for MulticoreFuture ...
[10:25:50.482] result() for MulticoreFuture ... done
[10:25:50.482] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:25:50.483] - nx: 6
[10:25:50.483] - relay: TRUE
[10:25:50.483] - stdout: TRUE
[10:25:50.483] - signal: TRUE
[10:25:50.483] - resignal: FALSE
[10:25:50.483] - force: TRUE
[10:25:50.483] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.483] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:50.483]  - until=3
[10:25:50.484]  - relaying element #3
[10:25:50.484] result() for MulticoreFuture ...
[10:25:50.484] result() for MulticoreFuture ... done
[10:25:50.484] result() for MulticoreFuture ...
[10:25:50.484] result() for MulticoreFuture ... done
[10:25:50.484] result() for MulticoreFuture ...
[10:25:50.484] result() for MulticoreFuture ... done
[10:25:50.485] result() for MulticoreFuture ...
[10:25:50.485] result() for MulticoreFuture ... done
[10:25:50.485] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.485] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.485] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:25:50.485]  length: 3 (resolved future 3)
[10:25:50.485] Future #4
[10:25:50.486] result() for MulticoreFuture ...
[10:25:50.486] result() for MulticoreFuture ...
[10:25:50.487] result() for MulticoreFuture ... done
[10:25:50.487] result() for MulticoreFuture ... done
[10:25:50.487] result() for MulticoreFuture ...
[10:25:50.487] result() for MulticoreFuture ... done
[10:25:50.487] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:25:50.487] - nx: 6
[10:25:50.488] - relay: TRUE
[10:25:50.488] - stdout: TRUE
[10:25:50.488] - signal: TRUE
[10:25:50.488] - resignal: FALSE
[10:25:50.488] - force: TRUE
[10:25:50.488] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.488] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:50.489]  - until=4
[10:25:50.489]  - relaying element #4
[10:25:50.489] result() for MulticoreFuture ...
[10:25:50.489] result() for MulticoreFuture ... done
[10:25:50.489] result() for MulticoreFuture ...
[10:25:50.489] result() for MulticoreFuture ... done
[10:25:50.490] result() for MulticoreFuture ...
[10:25:50.490] result() for MulticoreFuture ... done
[10:25:50.490] result() for MulticoreFuture ...
[10:25:50.490] result() for MulticoreFuture ... done
[10:25:50.490] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.490] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.490] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:25:50.491]  length: 2 (resolved future 4)
[10:25:50.491] signalConditionsASAP(NULL, pos=5) ...
[10:25:50.491] - nx: 6
[10:25:50.491] - relay: TRUE
[10:25:50.491] - stdout: TRUE
[10:25:50.491] - signal: TRUE
[10:25:50.491] - resignal: FALSE
[10:25:50.492] - force: TRUE
[10:25:50.492] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.492] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.492]  - until=6
[10:25:50.492]  - relaying element #6
[10:25:50.492] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.492] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.492] signalConditionsASAP(NULL, pos=5) ... done
[10:25:50.492]  length: 1 (resolved future 5)
[10:25:50.493] signalConditionsASAP(numeric, pos=6) ...
[10:25:50.493] - nx: 6
[10:25:50.493] - relay: TRUE
[10:25:50.493] - stdout: TRUE
[10:25:50.493] - signal: TRUE
[10:25:50.493] - resignal: FALSE
[10:25:50.493] - force: TRUE
[10:25:50.493] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:50.493] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.494]  - until=6
[10:25:50.494] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.494] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.494] signalConditionsASAP(numeric, pos=6) ... done
[10:25:50.494]  length: 0 (resolved future 6)
[10:25:50.494] Relaying remaining futures
[10:25:50.494] signalConditionsASAP(NULL, pos=0) ...
[10:25:50.494] - nx: 6
[10:25:50.495] - relay: TRUE
[10:25:50.495] - stdout: TRUE
[10:25:50.495] - signal: TRUE
[10:25:50.495] - resignal: FALSE
[10:25:50.495] - force: TRUE
[10:25:50.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.495] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:50.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:50.495] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:50.496] signalConditionsASAP(NULL, pos=0) ... done
[10:25:50.496] resolve() on list environment ... DONE
[10:25:50.496] result() for MulticoreFuture ...
[10:25:50.496] result() for MulticoreFuture ... done
[10:25:50.496] result() for MulticoreFuture ...
[10:25:50.496] result() for MulticoreFuture ... done
[10:25:50.496] result() for MulticoreFuture ...
[10:25:50.497] result() for MulticoreFuture ... done
[10:25:50.497] result() for MulticoreFuture ...
[10:25:50.497] result() for MulticoreFuture ... done
[10:25:50.497] result() for MulticoreFuture ...
[10:25:50.497] result() for MulticoreFuture ... done
[10:25:50.497] result() for MulticoreFuture ...
[10:25:50.497] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f5443e08> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[10:25:50.500] plan(): Setting new future strategy stack:
[10:25:50.500] List of future strategies:
[10:25:50.500] 1. multisession:
[10:25:50.500]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:50.500]    - tweaked: FALSE
[10:25:50.500]    - call: plan(strategy)
[10:25:50.500] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:25:50.501] multisession:
[10:25:50.501] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:50.501] - tweaked: FALSE
[10:25:50.501] - call: plan(strategy)
[10:25:50.504] getGlobalsAndPackages() ...
[10:25:50.504] Not searching for globals
[10:25:50.505] - globals: [0] <none>
[10:25:50.505] getGlobalsAndPackages() ... DONE
[10:25:50.505] [local output] makeClusterPSOCK() ...
[10:25:50.508] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:25:50.509] [local output] Base port: 11912
[10:25:50.509] [local output] Getting setup options for 2 cluster nodes ...
[10:25:50.509] [local output]  - Node 1 of 2 ...
[10:25:50.510] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:50.510] [local output] Rscript port: 11912

[10:25:50.511] [local output]  - Node 2 of 2 ...
[10:25:50.511] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:50.512] [local output] Rscript port: 11912

[10:25:50.512] [local output] Getting setup options for 2 cluster nodes ... done
[10:25:50.512] [local output]  - Parallel setup requested for some PSOCK nodes
[10:25:50.512] [local output] Setting up PSOCK nodes in parallel
[10:25:50.513] List of 36
[10:25:50.513]  $ worker          : chr "localhost"
[10:25:50.513]   ..- attr(*, "localhost")= logi TRUE
[10:25:50.513]  $ master          : chr "localhost"
[10:25:50.513]  $ port            : int 11912
[10:25:50.513]  $ connectTimeout  : num 120
[10:25:50.513]  $ timeout         : num 2592000
[10:25:50.513]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:25:50.513]  $ homogeneous     : logi TRUE
[10:25:50.513]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:25:50.513]  $ rscript_envs    : NULL
[10:25:50.513]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:50.513]  $ rscript_startup : NULL
[10:25:50.513]  $ rscript_sh      : chr "sh"
[10:25:50.513]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:50.513]  $ methods         : logi TRUE
[10:25:50.513]  $ socketOptions   : chr "no-delay"
[10:25:50.513]  $ useXDR          : logi FALSE
[10:25:50.513]  $ outfile         : chr "/dev/null"
[10:25:50.513]  $ renice          : int NA
[10:25:50.513]  $ rshcmd          : NULL
[10:25:50.513]  $ user            : chr(0) 
[10:25:50.513]  $ revtunnel       : logi FALSE
[10:25:50.513]  $ rshlogfile      : NULL
[10:25:50.513]  $ rshopts         : chr(0) 
[10:25:50.513]  $ rank            : int 1
[10:25:50.513]  $ manual          : logi FALSE
[10:25:50.513]  $ dryrun          : logi FALSE
[10:25:50.513]  $ quiet           : logi FALSE
[10:25:50.513]  $ setup_strategy  : chr "parallel"
[10:25:50.513]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:50.513]  $ pidfile         : chr "/tmp/Rtmpt2gjBk/worker.rank=1.parallelly.parent=83526.146462d3a8d1d.pid"
[10:25:50.513]  $ rshcmd_label    : NULL
[10:25:50.513]  $ rsh_call        : NULL
[10:25:50.513]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:50.513]  $ localMachine    : logi TRUE
[10:25:50.513]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:25:50.513]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:25:50.513]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:25:50.513]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:25:50.513]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:25:50.513]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:25:50.513]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:25:50.513]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:25:50.513]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:25:50.513]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:25:50.513]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:25:50.513]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:25:50.513]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:25:50.513]  $ arguments       :List of 28
[10:25:50.513]   ..$ worker          : chr "localhost"
[10:25:50.513]   ..$ master          : NULL
[10:25:50.513]   ..$ port            : int 11912
[10:25:50.513]   ..$ connectTimeout  : num 120
[10:25:50.513]   ..$ timeout         : num 2592000
[10:25:50.513]   ..$ rscript         : NULL
[10:25:50.513]   ..$ homogeneous     : NULL
[10:25:50.513]   ..$ rscript_args    : NULL
[10:25:50.513]   ..$ rscript_envs    : NULL
[10:25:50.513]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:50.513]   ..$ rscript_startup : NULL
[10:25:50.513]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:25:50.513]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:50.513]   ..$ methods         : logi TRUE
[10:25:50.513]   ..$ socketOptions   : chr "no-delay"
[10:25:50.513]   ..$ useXDR          : logi FALSE
[10:25:50.513]   ..$ outfile         : chr "/dev/null"
[10:25:50.513]   ..$ renice          : int NA
[10:25:50.513]   ..$ rshcmd          : NULL
[10:25:50.513]   ..$ user            : NULL
[10:25:50.513]   ..$ revtunnel       : logi NA
[10:25:50.513]   ..$ rshlogfile      : NULL
[10:25:50.513]   ..$ rshopts         : NULL
[10:25:50.513]   ..$ rank            : int 1
[10:25:50.513]   ..$ manual          : logi FALSE
[10:25:50.513]   ..$ dryrun          : logi FALSE
[10:25:50.513]   ..$ quiet           : logi FALSE
[10:25:50.513]   ..$ setup_strategy  : chr "parallel"
[10:25:50.513]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:25:50.532] [local output] System call to launch all workers:
[10:25:50.532] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpt2gjBk/worker.rank=1.parallelly.parent=83526.146462d3a8d1d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11912 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:25:50.532] [local output] Starting PSOCK main server
[10:25:50.533] [local output] Workers launched
[10:25:50.534] [local output] Waiting for workers to connect back
[10:25:50.534]  - [local output] 0 workers out of 2 ready
[10:25:50.778]  - [local output] 0 workers out of 2 ready
[10:25:50.778]  - [local output] 1 workers out of 2 ready
[10:25:50.780]  - [local output] 1 workers out of 2 ready
[10:25:50.780]  - [local output] 2 workers out of 2 ready
[10:25:50.781] [local output] Launching of workers completed
[10:25:50.781] [local output] Collecting session information from workers
[10:25:50.781] [local output]  - Worker #1 of 2
[10:25:50.782] [local output]  - Worker #2 of 2
[10:25:50.782] [local output] makeClusterPSOCK() ... done
[10:25:50.793] Packages needed by the future expression (n = 0): <none>
[10:25:50.793] Packages needed by future strategies (n = 0): <none>
[10:25:50.794] {
[10:25:50.794]     {
[10:25:50.794]         {
[10:25:50.794]             ...future.startTime <- base::Sys.time()
[10:25:50.794]             {
[10:25:50.794]                 {
[10:25:50.794]                   {
[10:25:50.794]                     {
[10:25:50.794]                       base::local({
[10:25:50.794]                         has_future <- base::requireNamespace("future", 
[10:25:50.794]                           quietly = TRUE)
[10:25:50.794]                         if (has_future) {
[10:25:50.794]                           ns <- base::getNamespace("future")
[10:25:50.794]                           version <- ns[[".package"]][["version"]]
[10:25:50.794]                           if (is.null(version)) 
[10:25:50.794]                             version <- utils::packageVersion("future")
[10:25:50.794]                         }
[10:25:50.794]                         else {
[10:25:50.794]                           version <- NULL
[10:25:50.794]                         }
[10:25:50.794]                         if (!has_future || version < "1.8.0") {
[10:25:50.794]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.794]                             "", base::R.version$version.string), 
[10:25:50.794]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.794]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.794]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.794]                               "release", "version")], collapse = " "), 
[10:25:50.794]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.794]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.794]                             info)
[10:25:50.794]                           info <- base::paste(info, collapse = "; ")
[10:25:50.794]                           if (!has_future) {
[10:25:50.794]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.794]                               info)
[10:25:50.794]                           }
[10:25:50.794]                           else {
[10:25:50.794]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.794]                               info, version)
[10:25:50.794]                           }
[10:25:50.794]                           base::stop(msg)
[10:25:50.794]                         }
[10:25:50.794]                       })
[10:25:50.794]                     }
[10:25:50.794]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.794]                     base::options(mc.cores = 1L)
[10:25:50.794]                   }
[10:25:50.794]                   options(future.plan = NULL)
[10:25:50.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.794]                 }
[10:25:50.794]                 ...future.workdir <- getwd()
[10:25:50.794]             }
[10:25:50.794]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.794]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.794]         }
[10:25:50.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.794]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.794]             base::names(...future.oldOptions))
[10:25:50.794]     }
[10:25:50.794]     if (FALSE) {
[10:25:50.794]     }
[10:25:50.794]     else {
[10:25:50.794]         if (TRUE) {
[10:25:50.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.794]                 open = "w")
[10:25:50.794]         }
[10:25:50.794]         else {
[10:25:50.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.794]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.794]         }
[10:25:50.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.794]             base::sink(type = "output", split = FALSE)
[10:25:50.794]             base::close(...future.stdout)
[10:25:50.794]         }, add = TRUE)
[10:25:50.794]     }
[10:25:50.794]     ...future.frame <- base::sys.nframe()
[10:25:50.794]     ...future.conditions <- base::list()
[10:25:50.794]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.794]     if (FALSE) {
[10:25:50.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.794]     }
[10:25:50.794]     ...future.result <- base::tryCatch({
[10:25:50.794]         base::withCallingHandlers({
[10:25:50.794]             ...future.value <- base::withVisible(base::local({
[10:25:50.794]                 ...future.makeSendCondition <- base::local({
[10:25:50.794]                   sendCondition <- NULL
[10:25:50.794]                   function(frame = 1L) {
[10:25:50.794]                     if (is.function(sendCondition)) 
[10:25:50.794]                       return(sendCondition)
[10:25:50.794]                     ns <- getNamespace("parallel")
[10:25:50.794]                     if (exists("sendData", mode = "function", 
[10:25:50.794]                       envir = ns)) {
[10:25:50.794]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:50.794]                         envir = ns)
[10:25:50.794]                       envir <- sys.frame(frame)
[10:25:50.794]                       master <- NULL
[10:25:50.794]                       while (!identical(envir, .GlobalEnv) && 
[10:25:50.794]                         !identical(envir, emptyenv())) {
[10:25:50.794]                         if (exists("master", mode = "list", envir = envir, 
[10:25:50.794]                           inherits = FALSE)) {
[10:25:50.794]                           master <- get("master", mode = "list", 
[10:25:50.794]                             envir = envir, inherits = FALSE)
[10:25:50.794]                           if (inherits(master, c("SOCKnode", 
[10:25:50.794]                             "SOCK0node"))) {
[10:25:50.794]                             sendCondition <<- function(cond) {
[10:25:50.794]                               data <- list(type = "VALUE", value = cond, 
[10:25:50.794]                                 success = TRUE)
[10:25:50.794]                               parallel_sendData(master, data)
[10:25:50.794]                             }
[10:25:50.794]                             return(sendCondition)
[10:25:50.794]                           }
[10:25:50.794]                         }
[10:25:50.794]                         frame <- frame + 1L
[10:25:50.794]                         envir <- sys.frame(frame)
[10:25:50.794]                       }
[10:25:50.794]                     }
[10:25:50.794]                     sendCondition <<- function(cond) NULL
[10:25:50.794]                   }
[10:25:50.794]                 })
[10:25:50.794]                 withCallingHandlers({
[10:25:50.794]                   NA
[10:25:50.794]                 }, immediateCondition = function(cond) {
[10:25:50.794]                   sendCondition <- ...future.makeSendCondition()
[10:25:50.794]                   sendCondition(cond)
[10:25:50.794]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.794]                   {
[10:25:50.794]                     inherits <- base::inherits
[10:25:50.794]                     invokeRestart <- base::invokeRestart
[10:25:50.794]                     is.null <- base::is.null
[10:25:50.794]                     muffled <- FALSE
[10:25:50.794]                     if (inherits(cond, "message")) {
[10:25:50.794]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.794]                       if (muffled) 
[10:25:50.794]                         invokeRestart("muffleMessage")
[10:25:50.794]                     }
[10:25:50.794]                     else if (inherits(cond, "warning")) {
[10:25:50.794]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.794]                       if (muffled) 
[10:25:50.794]                         invokeRestart("muffleWarning")
[10:25:50.794]                     }
[10:25:50.794]                     else if (inherits(cond, "condition")) {
[10:25:50.794]                       if (!is.null(pattern)) {
[10:25:50.794]                         computeRestarts <- base::computeRestarts
[10:25:50.794]                         grepl <- base::grepl
[10:25:50.794]                         restarts <- computeRestarts(cond)
[10:25:50.794]                         for (restart in restarts) {
[10:25:50.794]                           name <- restart$name
[10:25:50.794]                           if (is.null(name)) 
[10:25:50.794]                             next
[10:25:50.794]                           if (!grepl(pattern, name)) 
[10:25:50.794]                             next
[10:25:50.794]                           invokeRestart(restart)
[10:25:50.794]                           muffled <- TRUE
[10:25:50.794]                           break
[10:25:50.794]                         }
[10:25:50.794]                       }
[10:25:50.794]                     }
[10:25:50.794]                     invisible(muffled)
[10:25:50.794]                   }
[10:25:50.794]                   muffleCondition(cond)
[10:25:50.794]                 })
[10:25:50.794]             }))
[10:25:50.794]             future::FutureResult(value = ...future.value$value, 
[10:25:50.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.794]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.794]                     ...future.globalenv.names))
[10:25:50.794]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.794]         }, condition = base::local({
[10:25:50.794]             c <- base::c
[10:25:50.794]             inherits <- base::inherits
[10:25:50.794]             invokeRestart <- base::invokeRestart
[10:25:50.794]             length <- base::length
[10:25:50.794]             list <- base::list
[10:25:50.794]             seq.int <- base::seq.int
[10:25:50.794]             signalCondition <- base::signalCondition
[10:25:50.794]             sys.calls <- base::sys.calls
[10:25:50.794]             `[[` <- base::`[[`
[10:25:50.794]             `+` <- base::`+`
[10:25:50.794]             `<<-` <- base::`<<-`
[10:25:50.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.794]                   3L)]
[10:25:50.794]             }
[10:25:50.794]             function(cond) {
[10:25:50.794]                 is_error <- inherits(cond, "error")
[10:25:50.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.794]                   NULL)
[10:25:50.794]                 if (is_error) {
[10:25:50.794]                   sessionInformation <- function() {
[10:25:50.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.794]                       search = base::search(), system = base::Sys.info())
[10:25:50.794]                   }
[10:25:50.794]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.794]                     cond$call), session = sessionInformation(), 
[10:25:50.794]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.794]                   signalCondition(cond)
[10:25:50.794]                 }
[10:25:50.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.794]                 "immediateCondition"))) {
[10:25:50.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.794]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.794]                   if (TRUE && !signal) {
[10:25:50.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.794]                     {
[10:25:50.794]                       inherits <- base::inherits
[10:25:50.794]                       invokeRestart <- base::invokeRestart
[10:25:50.794]                       is.null <- base::is.null
[10:25:50.794]                       muffled <- FALSE
[10:25:50.794]                       if (inherits(cond, "message")) {
[10:25:50.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.794]                         if (muffled) 
[10:25:50.794]                           invokeRestart("muffleMessage")
[10:25:50.794]                       }
[10:25:50.794]                       else if (inherits(cond, "warning")) {
[10:25:50.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.794]                         if (muffled) 
[10:25:50.794]                           invokeRestart("muffleWarning")
[10:25:50.794]                       }
[10:25:50.794]                       else if (inherits(cond, "condition")) {
[10:25:50.794]                         if (!is.null(pattern)) {
[10:25:50.794]                           computeRestarts <- base::computeRestarts
[10:25:50.794]                           grepl <- base::grepl
[10:25:50.794]                           restarts <- computeRestarts(cond)
[10:25:50.794]                           for (restart in restarts) {
[10:25:50.794]                             name <- restart$name
[10:25:50.794]                             if (is.null(name)) 
[10:25:50.794]                               next
[10:25:50.794]                             if (!grepl(pattern, name)) 
[10:25:50.794]                               next
[10:25:50.794]                             invokeRestart(restart)
[10:25:50.794]                             muffled <- TRUE
[10:25:50.794]                             break
[10:25:50.794]                           }
[10:25:50.794]                         }
[10:25:50.794]                       }
[10:25:50.794]                       invisible(muffled)
[10:25:50.794]                     }
[10:25:50.794]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.794]                   }
[10:25:50.794]                 }
[10:25:50.794]                 else {
[10:25:50.794]                   if (TRUE) {
[10:25:50.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.794]                     {
[10:25:50.794]                       inherits <- base::inherits
[10:25:50.794]                       invokeRestart <- base::invokeRestart
[10:25:50.794]                       is.null <- base::is.null
[10:25:50.794]                       muffled <- FALSE
[10:25:50.794]                       if (inherits(cond, "message")) {
[10:25:50.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.794]                         if (muffled) 
[10:25:50.794]                           invokeRestart("muffleMessage")
[10:25:50.794]                       }
[10:25:50.794]                       else if (inherits(cond, "warning")) {
[10:25:50.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.794]                         if (muffled) 
[10:25:50.794]                           invokeRestart("muffleWarning")
[10:25:50.794]                       }
[10:25:50.794]                       else if (inherits(cond, "condition")) {
[10:25:50.794]                         if (!is.null(pattern)) {
[10:25:50.794]                           computeRestarts <- base::computeRestarts
[10:25:50.794]                           grepl <- base::grepl
[10:25:50.794]                           restarts <- computeRestarts(cond)
[10:25:50.794]                           for (restart in restarts) {
[10:25:50.794]                             name <- restart$name
[10:25:50.794]                             if (is.null(name)) 
[10:25:50.794]                               next
[10:25:50.794]                             if (!grepl(pattern, name)) 
[10:25:50.794]                               next
[10:25:50.794]                             invokeRestart(restart)
[10:25:50.794]                             muffled <- TRUE
[10:25:50.794]                             break
[10:25:50.794]                           }
[10:25:50.794]                         }
[10:25:50.794]                       }
[10:25:50.794]                       invisible(muffled)
[10:25:50.794]                     }
[10:25:50.794]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.794]                   }
[10:25:50.794]                 }
[10:25:50.794]             }
[10:25:50.794]         }))
[10:25:50.794]     }, error = function(ex) {
[10:25:50.794]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.794]                 ...future.rng), started = ...future.startTime, 
[10:25:50.794]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.794]             version = "1.8"), class = "FutureResult")
[10:25:50.794]     }, finally = {
[10:25:50.794]         if (!identical(...future.workdir, getwd())) 
[10:25:50.794]             setwd(...future.workdir)
[10:25:50.794]         {
[10:25:50.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.794]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.794]             }
[10:25:50.794]             base::options(...future.oldOptions)
[10:25:50.794]             if (.Platform$OS.type == "windows") {
[10:25:50.794]                 old_names <- names(...future.oldEnvVars)
[10:25:50.794]                 envs <- base::Sys.getenv()
[10:25:50.794]                 names <- names(envs)
[10:25:50.794]                 common <- intersect(names, old_names)
[10:25:50.794]                 added <- setdiff(names, old_names)
[10:25:50.794]                 removed <- setdiff(old_names, names)
[10:25:50.794]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.794]                   envs[common]]
[10:25:50.794]                 NAMES <- toupper(changed)
[10:25:50.794]                 args <- list()
[10:25:50.794]                 for (kk in seq_along(NAMES)) {
[10:25:50.794]                   name <- changed[[kk]]
[10:25:50.794]                   NAME <- NAMES[[kk]]
[10:25:50.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.794]                     next
[10:25:50.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.794]                 }
[10:25:50.794]                 NAMES <- toupper(added)
[10:25:50.794]                 for (kk in seq_along(NAMES)) {
[10:25:50.794]                   name <- added[[kk]]
[10:25:50.794]                   NAME <- NAMES[[kk]]
[10:25:50.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.794]                     next
[10:25:50.794]                   args[[name]] <- ""
[10:25:50.794]                 }
[10:25:50.794]                 NAMES <- toupper(removed)
[10:25:50.794]                 for (kk in seq_along(NAMES)) {
[10:25:50.794]                   name <- removed[[kk]]
[10:25:50.794]                   NAME <- NAMES[[kk]]
[10:25:50.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.794]                     next
[10:25:50.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.794]                 }
[10:25:50.794]                 if (length(args) > 0) 
[10:25:50.794]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.794]             }
[10:25:50.794]             else {
[10:25:50.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.794]             }
[10:25:50.794]             {
[10:25:50.794]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.794]                   0L) {
[10:25:50.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.794]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.794]                   base::options(opts)
[10:25:50.794]                 }
[10:25:50.794]                 {
[10:25:50.794]                   {
[10:25:50.794]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.794]                     NULL
[10:25:50.794]                   }
[10:25:50.794]                   options(future.plan = NULL)
[10:25:50.794]                   if (is.na(NA_character_)) 
[10:25:50.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.794]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:50.794]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:50.794]                     envir = parent.frame()) 
[10:25:50.794]                   {
[10:25:50.794]                     if (is.function(workers)) 
[10:25:50.794]                       workers <- workers()
[10:25:50.794]                     workers <- structure(as.integer(workers), 
[10:25:50.794]                       class = class(workers))
[10:25:50.794]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:50.794]                       workers >= 1)
[10:25:50.794]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:50.794]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:50.794]                     }
[10:25:50.794]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:50.794]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:50.794]                       envir = envir)
[10:25:50.794]                     if (!future$lazy) 
[10:25:50.794]                       future <- run(future)
[10:25:50.794]                     invisible(future)
[10:25:50.794]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.794]                 }
[10:25:50.794]             }
[10:25:50.794]         }
[10:25:50.794]     })
[10:25:50.794]     if (TRUE) {
[10:25:50.794]         base::sink(type = "output", split = FALSE)
[10:25:50.794]         if (TRUE) {
[10:25:50.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.794]         }
[10:25:50.794]         else {
[10:25:50.794]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.794]         }
[10:25:50.794]         base::close(...future.stdout)
[10:25:50.794]         ...future.stdout <- NULL
[10:25:50.794]     }
[10:25:50.794]     ...future.result$conditions <- ...future.conditions
[10:25:50.794]     ...future.result$finished <- base::Sys.time()
[10:25:50.794]     ...future.result
[10:25:50.794] }
[10:25:50.847] MultisessionFuture started
[10:25:50.847] result() for ClusterFuture ...
[10:25:50.847] receiveMessageFromWorker() for ClusterFuture ...
[10:25:50.847] - Validating connection of MultisessionFuture
[10:25:50.891] - received message: FutureResult
[10:25:50.891] - Received FutureResult
[10:25:50.891] - Erased future from FutureRegistry
[10:25:50.891] result() for ClusterFuture ...
[10:25:50.891] - result already collected: FutureResult
[10:25:50.891] result() for ClusterFuture ... done
[10:25:50.892] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:50.892] result() for ClusterFuture ... done
[10:25:50.892] result() for ClusterFuture ...
[10:25:50.892] - result already collected: FutureResult
[10:25:50.892] result() for ClusterFuture ... done
[10:25:50.892] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:25:50.896] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:25:50.896] getGlobalsAndPackages() ...
[10:25:50.896] Searching for globals...
[10:25:50.897] 
[10:25:50.897] Searching for globals ... DONE
[10:25:50.897] - globals: [0] <none>
[10:25:50.897] getGlobalsAndPackages() ... DONE
[10:25:50.897] run() for ‘Future’ ...
[10:25:50.897] - state: ‘created’
[10:25:50.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.918] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.918] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:50.918]   - Field: ‘node’
[10:25:50.919]   - Field: ‘label’
[10:25:50.919]   - Field: ‘local’
[10:25:50.919]   - Field: ‘owner’
[10:25:50.919]   - Field: ‘envir’
[10:25:50.919]   - Field: ‘workers’
[10:25:50.919]   - Field: ‘packages’
[10:25:50.919]   - Field: ‘gc’
[10:25:50.919]   - Field: ‘conditions’
[10:25:50.919]   - Field: ‘persistent’
[10:25:50.919]   - Field: ‘expr’
[10:25:50.919]   - Field: ‘uuid’
[10:25:50.920]   - Field: ‘seed’
[10:25:50.920]   - Field: ‘version’
[10:25:50.920]   - Field: ‘result’
[10:25:50.920]   - Field: ‘asynchronous’
[10:25:50.920]   - Field: ‘calls’
[10:25:50.920]   - Field: ‘globals’
[10:25:50.920]   - Field: ‘stdout’
[10:25:50.920]   - Field: ‘earlySignal’
[10:25:50.920]   - Field: ‘lazy’
[10:25:50.920]   - Field: ‘state’
[10:25:50.920] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:50.921] - Launch lazy future ...
[10:25:50.921] Packages needed by the future expression (n = 0): <none>
[10:25:50.921] Packages needed by future strategies (n = 0): <none>
[10:25:50.921] {
[10:25:50.921]     {
[10:25:50.921]         {
[10:25:50.921]             ...future.startTime <- base::Sys.time()
[10:25:50.921]             {
[10:25:50.921]                 {
[10:25:50.921]                   {
[10:25:50.921]                     {
[10:25:50.921]                       base::local({
[10:25:50.921]                         has_future <- base::requireNamespace("future", 
[10:25:50.921]                           quietly = TRUE)
[10:25:50.921]                         if (has_future) {
[10:25:50.921]                           ns <- base::getNamespace("future")
[10:25:50.921]                           version <- ns[[".package"]][["version"]]
[10:25:50.921]                           if (is.null(version)) 
[10:25:50.921]                             version <- utils::packageVersion("future")
[10:25:50.921]                         }
[10:25:50.921]                         else {
[10:25:50.921]                           version <- NULL
[10:25:50.921]                         }
[10:25:50.921]                         if (!has_future || version < "1.8.0") {
[10:25:50.921]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.921]                             "", base::R.version$version.string), 
[10:25:50.921]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.921]                               "release", "version")], collapse = " "), 
[10:25:50.921]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.921]                             info)
[10:25:50.921]                           info <- base::paste(info, collapse = "; ")
[10:25:50.921]                           if (!has_future) {
[10:25:50.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.921]                               info)
[10:25:50.921]                           }
[10:25:50.921]                           else {
[10:25:50.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.921]                               info, version)
[10:25:50.921]                           }
[10:25:50.921]                           base::stop(msg)
[10:25:50.921]                         }
[10:25:50.921]                       })
[10:25:50.921]                     }
[10:25:50.921]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.921]                     base::options(mc.cores = 1L)
[10:25:50.921]                   }
[10:25:50.921]                   options(future.plan = NULL)
[10:25:50.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.921]                 }
[10:25:50.921]                 ...future.workdir <- getwd()
[10:25:50.921]             }
[10:25:50.921]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.921]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.921]         }
[10:25:50.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.921]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.921]             base::names(...future.oldOptions))
[10:25:50.921]     }
[10:25:50.921]     if (FALSE) {
[10:25:50.921]     }
[10:25:50.921]     else {
[10:25:50.921]         if (TRUE) {
[10:25:50.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.921]                 open = "w")
[10:25:50.921]         }
[10:25:50.921]         else {
[10:25:50.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.921]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.921]         }
[10:25:50.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.921]             base::sink(type = "output", split = FALSE)
[10:25:50.921]             base::close(...future.stdout)
[10:25:50.921]         }, add = TRUE)
[10:25:50.921]     }
[10:25:50.921]     ...future.frame <- base::sys.nframe()
[10:25:50.921]     ...future.conditions <- base::list()
[10:25:50.921]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.921]     if (FALSE) {
[10:25:50.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.921]     }
[10:25:50.921]     ...future.result <- base::tryCatch({
[10:25:50.921]         base::withCallingHandlers({
[10:25:50.921]             ...future.value <- base::withVisible(base::local({
[10:25:50.921]                 ...future.makeSendCondition <- base::local({
[10:25:50.921]                   sendCondition <- NULL
[10:25:50.921]                   function(frame = 1L) {
[10:25:50.921]                     if (is.function(sendCondition)) 
[10:25:50.921]                       return(sendCondition)
[10:25:50.921]                     ns <- getNamespace("parallel")
[10:25:50.921]                     if (exists("sendData", mode = "function", 
[10:25:50.921]                       envir = ns)) {
[10:25:50.921]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:50.921]                         envir = ns)
[10:25:50.921]                       envir <- sys.frame(frame)
[10:25:50.921]                       master <- NULL
[10:25:50.921]                       while (!identical(envir, .GlobalEnv) && 
[10:25:50.921]                         !identical(envir, emptyenv())) {
[10:25:50.921]                         if (exists("master", mode = "list", envir = envir, 
[10:25:50.921]                           inherits = FALSE)) {
[10:25:50.921]                           master <- get("master", mode = "list", 
[10:25:50.921]                             envir = envir, inherits = FALSE)
[10:25:50.921]                           if (inherits(master, c("SOCKnode", 
[10:25:50.921]                             "SOCK0node"))) {
[10:25:50.921]                             sendCondition <<- function(cond) {
[10:25:50.921]                               data <- list(type = "VALUE", value = cond, 
[10:25:50.921]                                 success = TRUE)
[10:25:50.921]                               parallel_sendData(master, data)
[10:25:50.921]                             }
[10:25:50.921]                             return(sendCondition)
[10:25:50.921]                           }
[10:25:50.921]                         }
[10:25:50.921]                         frame <- frame + 1L
[10:25:50.921]                         envir <- sys.frame(frame)
[10:25:50.921]                       }
[10:25:50.921]                     }
[10:25:50.921]                     sendCondition <<- function(cond) NULL
[10:25:50.921]                   }
[10:25:50.921]                 })
[10:25:50.921]                 withCallingHandlers({
[10:25:50.921]                   2
[10:25:50.921]                 }, immediateCondition = function(cond) {
[10:25:50.921]                   sendCondition <- ...future.makeSendCondition()
[10:25:50.921]                   sendCondition(cond)
[10:25:50.921]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.921]                   {
[10:25:50.921]                     inherits <- base::inherits
[10:25:50.921]                     invokeRestart <- base::invokeRestart
[10:25:50.921]                     is.null <- base::is.null
[10:25:50.921]                     muffled <- FALSE
[10:25:50.921]                     if (inherits(cond, "message")) {
[10:25:50.921]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.921]                       if (muffled) 
[10:25:50.921]                         invokeRestart("muffleMessage")
[10:25:50.921]                     }
[10:25:50.921]                     else if (inherits(cond, "warning")) {
[10:25:50.921]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.921]                       if (muffled) 
[10:25:50.921]                         invokeRestart("muffleWarning")
[10:25:50.921]                     }
[10:25:50.921]                     else if (inherits(cond, "condition")) {
[10:25:50.921]                       if (!is.null(pattern)) {
[10:25:50.921]                         computeRestarts <- base::computeRestarts
[10:25:50.921]                         grepl <- base::grepl
[10:25:50.921]                         restarts <- computeRestarts(cond)
[10:25:50.921]                         for (restart in restarts) {
[10:25:50.921]                           name <- restart$name
[10:25:50.921]                           if (is.null(name)) 
[10:25:50.921]                             next
[10:25:50.921]                           if (!grepl(pattern, name)) 
[10:25:50.921]                             next
[10:25:50.921]                           invokeRestart(restart)
[10:25:50.921]                           muffled <- TRUE
[10:25:50.921]                           break
[10:25:50.921]                         }
[10:25:50.921]                       }
[10:25:50.921]                     }
[10:25:50.921]                     invisible(muffled)
[10:25:50.921]                   }
[10:25:50.921]                   muffleCondition(cond)
[10:25:50.921]                 })
[10:25:50.921]             }))
[10:25:50.921]             future::FutureResult(value = ...future.value$value, 
[10:25:50.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.921]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.921]                     ...future.globalenv.names))
[10:25:50.921]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.921]         }, condition = base::local({
[10:25:50.921]             c <- base::c
[10:25:50.921]             inherits <- base::inherits
[10:25:50.921]             invokeRestart <- base::invokeRestart
[10:25:50.921]             length <- base::length
[10:25:50.921]             list <- base::list
[10:25:50.921]             seq.int <- base::seq.int
[10:25:50.921]             signalCondition <- base::signalCondition
[10:25:50.921]             sys.calls <- base::sys.calls
[10:25:50.921]             `[[` <- base::`[[`
[10:25:50.921]             `+` <- base::`+`
[10:25:50.921]             `<<-` <- base::`<<-`
[10:25:50.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.921]                   3L)]
[10:25:50.921]             }
[10:25:50.921]             function(cond) {
[10:25:50.921]                 is_error <- inherits(cond, "error")
[10:25:50.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.921]                   NULL)
[10:25:50.921]                 if (is_error) {
[10:25:50.921]                   sessionInformation <- function() {
[10:25:50.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.921]                       search = base::search(), system = base::Sys.info())
[10:25:50.921]                   }
[10:25:50.921]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.921]                     cond$call), session = sessionInformation(), 
[10:25:50.921]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.921]                   signalCondition(cond)
[10:25:50.921]                 }
[10:25:50.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.921]                 "immediateCondition"))) {
[10:25:50.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.921]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.921]                   if (TRUE && !signal) {
[10:25:50.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.921]                     {
[10:25:50.921]                       inherits <- base::inherits
[10:25:50.921]                       invokeRestart <- base::invokeRestart
[10:25:50.921]                       is.null <- base::is.null
[10:25:50.921]                       muffled <- FALSE
[10:25:50.921]                       if (inherits(cond, "message")) {
[10:25:50.921]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.921]                         if (muffled) 
[10:25:50.921]                           invokeRestart("muffleMessage")
[10:25:50.921]                       }
[10:25:50.921]                       else if (inherits(cond, "warning")) {
[10:25:50.921]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.921]                         if (muffled) 
[10:25:50.921]                           invokeRestart("muffleWarning")
[10:25:50.921]                       }
[10:25:50.921]                       else if (inherits(cond, "condition")) {
[10:25:50.921]                         if (!is.null(pattern)) {
[10:25:50.921]                           computeRestarts <- base::computeRestarts
[10:25:50.921]                           grepl <- base::grepl
[10:25:50.921]                           restarts <- computeRestarts(cond)
[10:25:50.921]                           for (restart in restarts) {
[10:25:50.921]                             name <- restart$name
[10:25:50.921]                             if (is.null(name)) 
[10:25:50.921]                               next
[10:25:50.921]                             if (!grepl(pattern, name)) 
[10:25:50.921]                               next
[10:25:50.921]                             invokeRestart(restart)
[10:25:50.921]                             muffled <- TRUE
[10:25:50.921]                             break
[10:25:50.921]                           }
[10:25:50.921]                         }
[10:25:50.921]                       }
[10:25:50.921]                       invisible(muffled)
[10:25:50.921]                     }
[10:25:50.921]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.921]                   }
[10:25:50.921]                 }
[10:25:50.921]                 else {
[10:25:50.921]                   if (TRUE) {
[10:25:50.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.921]                     {
[10:25:50.921]                       inherits <- base::inherits
[10:25:50.921]                       invokeRestart <- base::invokeRestart
[10:25:50.921]                       is.null <- base::is.null
[10:25:50.921]                       muffled <- FALSE
[10:25:50.921]                       if (inherits(cond, "message")) {
[10:25:50.921]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.921]                         if (muffled) 
[10:25:50.921]                           invokeRestart("muffleMessage")
[10:25:50.921]                       }
[10:25:50.921]                       else if (inherits(cond, "warning")) {
[10:25:50.921]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.921]                         if (muffled) 
[10:25:50.921]                           invokeRestart("muffleWarning")
[10:25:50.921]                       }
[10:25:50.921]                       else if (inherits(cond, "condition")) {
[10:25:50.921]                         if (!is.null(pattern)) {
[10:25:50.921]                           computeRestarts <- base::computeRestarts
[10:25:50.921]                           grepl <- base::grepl
[10:25:50.921]                           restarts <- computeRestarts(cond)
[10:25:50.921]                           for (restart in restarts) {
[10:25:50.921]                             name <- restart$name
[10:25:50.921]                             if (is.null(name)) 
[10:25:50.921]                               next
[10:25:50.921]                             if (!grepl(pattern, name)) 
[10:25:50.921]                               next
[10:25:50.921]                             invokeRestart(restart)
[10:25:50.921]                             muffled <- TRUE
[10:25:50.921]                             break
[10:25:50.921]                           }
[10:25:50.921]                         }
[10:25:50.921]                       }
[10:25:50.921]                       invisible(muffled)
[10:25:50.921]                     }
[10:25:50.921]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.921]                   }
[10:25:50.921]                 }
[10:25:50.921]             }
[10:25:50.921]         }))
[10:25:50.921]     }, error = function(ex) {
[10:25:50.921]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.921]                 ...future.rng), started = ...future.startTime, 
[10:25:50.921]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.921]             version = "1.8"), class = "FutureResult")
[10:25:50.921]     }, finally = {
[10:25:50.921]         if (!identical(...future.workdir, getwd())) 
[10:25:50.921]             setwd(...future.workdir)
[10:25:50.921]         {
[10:25:50.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.921]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.921]             }
[10:25:50.921]             base::options(...future.oldOptions)
[10:25:50.921]             if (.Platform$OS.type == "windows") {
[10:25:50.921]                 old_names <- names(...future.oldEnvVars)
[10:25:50.921]                 envs <- base::Sys.getenv()
[10:25:50.921]                 names <- names(envs)
[10:25:50.921]                 common <- intersect(names, old_names)
[10:25:50.921]                 added <- setdiff(names, old_names)
[10:25:50.921]                 removed <- setdiff(old_names, names)
[10:25:50.921]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.921]                   envs[common]]
[10:25:50.921]                 NAMES <- toupper(changed)
[10:25:50.921]                 args <- list()
[10:25:50.921]                 for (kk in seq_along(NAMES)) {
[10:25:50.921]                   name <- changed[[kk]]
[10:25:50.921]                   NAME <- NAMES[[kk]]
[10:25:50.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.921]                     next
[10:25:50.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.921]                 }
[10:25:50.921]                 NAMES <- toupper(added)
[10:25:50.921]                 for (kk in seq_along(NAMES)) {
[10:25:50.921]                   name <- added[[kk]]
[10:25:50.921]                   NAME <- NAMES[[kk]]
[10:25:50.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.921]                     next
[10:25:50.921]                   args[[name]] <- ""
[10:25:50.921]                 }
[10:25:50.921]                 NAMES <- toupper(removed)
[10:25:50.921]                 for (kk in seq_along(NAMES)) {
[10:25:50.921]                   name <- removed[[kk]]
[10:25:50.921]                   NAME <- NAMES[[kk]]
[10:25:50.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.921]                     next
[10:25:50.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.921]                 }
[10:25:50.921]                 if (length(args) > 0) 
[10:25:50.921]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.921]             }
[10:25:50.921]             else {
[10:25:50.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.921]             }
[10:25:50.921]             {
[10:25:50.921]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.921]                   0L) {
[10:25:50.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.921]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.921]                   base::options(opts)
[10:25:50.921]                 }
[10:25:50.921]                 {
[10:25:50.921]                   {
[10:25:50.921]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.921]                     NULL
[10:25:50.921]                   }
[10:25:50.921]                   options(future.plan = NULL)
[10:25:50.921]                   if (is.na(NA_character_)) 
[10:25:50.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.921]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:50.921]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:50.921]                     envir = parent.frame()) 
[10:25:50.921]                   {
[10:25:50.921]                     if (is.function(workers)) 
[10:25:50.921]                       workers <- workers()
[10:25:50.921]                     workers <- structure(as.integer(workers), 
[10:25:50.921]                       class = class(workers))
[10:25:50.921]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:50.921]                       workers >= 1)
[10:25:50.921]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:50.921]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:50.921]                     }
[10:25:50.921]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:50.921]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:50.921]                       envir = envir)
[10:25:50.921]                     if (!future$lazy) 
[10:25:50.921]                       future <- run(future)
[10:25:50.921]                     invisible(future)
[10:25:50.921]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.921]                 }
[10:25:50.921]             }
[10:25:50.921]         }
[10:25:50.921]     })
[10:25:50.921]     if (TRUE) {
[10:25:50.921]         base::sink(type = "output", split = FALSE)
[10:25:50.921]         if (TRUE) {
[10:25:50.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.921]         }
[10:25:50.921]         else {
[10:25:50.921]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.921]         }
[10:25:50.921]         base::close(...future.stdout)
[10:25:50.921]         ...future.stdout <- NULL
[10:25:50.921]     }
[10:25:50.921]     ...future.result$conditions <- ...future.conditions
[10:25:50.921]     ...future.result$finished <- base::Sys.time()
[10:25:50.921]     ...future.result
[10:25:50.921] }
[10:25:50.925] MultisessionFuture started
[10:25:50.925] - Launch lazy future ... done
[10:25:50.925] run() for ‘MultisessionFuture’ ... done
[10:25:50.925] getGlobalsAndPackages() ...
[10:25:50.925] Searching for globals...
[10:25:50.926] 
[10:25:50.926] Searching for globals ... DONE
[10:25:50.926] - globals: [0] <none>
[10:25:50.926] getGlobalsAndPackages() ... DONE
[10:25:50.926] run() for ‘Future’ ...
[10:25:50.926] - state: ‘created’
[10:25:50.926] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:50.940] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:50.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:50.940]   - Field: ‘node’
[10:25:50.940]   - Field: ‘label’
[10:25:50.940]   - Field: ‘local’
[10:25:50.940]   - Field: ‘owner’
[10:25:50.940]   - Field: ‘envir’
[10:25:50.940]   - Field: ‘workers’
[10:25:50.940]   - Field: ‘packages’
[10:25:50.941]   - Field: ‘gc’
[10:25:50.941]   - Field: ‘conditions’
[10:25:50.941]   - Field: ‘persistent’
[10:25:50.941]   - Field: ‘expr’
[10:25:50.941]   - Field: ‘uuid’
[10:25:50.941]   - Field: ‘seed’
[10:25:50.941]   - Field: ‘version’
[10:25:50.941]   - Field: ‘result’
[10:25:50.941]   - Field: ‘asynchronous’
[10:25:50.941]   - Field: ‘calls’
[10:25:50.941]   - Field: ‘globals’
[10:25:50.942]   - Field: ‘stdout’
[10:25:50.942]   - Field: ‘earlySignal’
[10:25:50.942]   - Field: ‘lazy’
[10:25:50.942]   - Field: ‘state’
[10:25:50.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:50.942] - Launch lazy future ...
[10:25:50.942] Packages needed by the future expression (n = 0): <none>
[10:25:50.942] Packages needed by future strategies (n = 0): <none>
[10:25:50.943] {
[10:25:50.943]     {
[10:25:50.943]         {
[10:25:50.943]             ...future.startTime <- base::Sys.time()
[10:25:50.943]             {
[10:25:50.943]                 {
[10:25:50.943]                   {
[10:25:50.943]                     {
[10:25:50.943]                       base::local({
[10:25:50.943]                         has_future <- base::requireNamespace("future", 
[10:25:50.943]                           quietly = TRUE)
[10:25:50.943]                         if (has_future) {
[10:25:50.943]                           ns <- base::getNamespace("future")
[10:25:50.943]                           version <- ns[[".package"]][["version"]]
[10:25:50.943]                           if (is.null(version)) 
[10:25:50.943]                             version <- utils::packageVersion("future")
[10:25:50.943]                         }
[10:25:50.943]                         else {
[10:25:50.943]                           version <- NULL
[10:25:50.943]                         }
[10:25:50.943]                         if (!has_future || version < "1.8.0") {
[10:25:50.943]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:50.943]                             "", base::R.version$version.string), 
[10:25:50.943]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:50.943]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:50.943]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:50.943]                               "release", "version")], collapse = " "), 
[10:25:50.943]                             hostname = base::Sys.info()[["nodename"]])
[10:25:50.943]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:50.943]                             info)
[10:25:50.943]                           info <- base::paste(info, collapse = "; ")
[10:25:50.943]                           if (!has_future) {
[10:25:50.943]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:50.943]                               info)
[10:25:50.943]                           }
[10:25:50.943]                           else {
[10:25:50.943]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:50.943]                               info, version)
[10:25:50.943]                           }
[10:25:50.943]                           base::stop(msg)
[10:25:50.943]                         }
[10:25:50.943]                       })
[10:25:50.943]                     }
[10:25:50.943]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:50.943]                     base::options(mc.cores = 1L)
[10:25:50.943]                   }
[10:25:50.943]                   options(future.plan = NULL)
[10:25:50.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:50.943]                 }
[10:25:50.943]                 ...future.workdir <- getwd()
[10:25:50.943]             }
[10:25:50.943]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:50.943]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:50.943]         }
[10:25:50.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:50.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:50.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:50.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:50.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:50.943]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:50.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:50.943]             base::names(...future.oldOptions))
[10:25:50.943]     }
[10:25:50.943]     if (FALSE) {
[10:25:50.943]     }
[10:25:50.943]     else {
[10:25:50.943]         if (TRUE) {
[10:25:50.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:50.943]                 open = "w")
[10:25:50.943]         }
[10:25:50.943]         else {
[10:25:50.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:50.943]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:50.943]         }
[10:25:50.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:50.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:50.943]             base::sink(type = "output", split = FALSE)
[10:25:50.943]             base::close(...future.stdout)
[10:25:50.943]         }, add = TRUE)
[10:25:50.943]     }
[10:25:50.943]     ...future.frame <- base::sys.nframe()
[10:25:50.943]     ...future.conditions <- base::list()
[10:25:50.943]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:50.943]     if (FALSE) {
[10:25:50.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:50.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:50.943]     }
[10:25:50.943]     ...future.result <- base::tryCatch({
[10:25:50.943]         base::withCallingHandlers({
[10:25:50.943]             ...future.value <- base::withVisible(base::local({
[10:25:50.943]                 ...future.makeSendCondition <- base::local({
[10:25:50.943]                   sendCondition <- NULL
[10:25:50.943]                   function(frame = 1L) {
[10:25:50.943]                     if (is.function(sendCondition)) 
[10:25:50.943]                       return(sendCondition)
[10:25:50.943]                     ns <- getNamespace("parallel")
[10:25:50.943]                     if (exists("sendData", mode = "function", 
[10:25:50.943]                       envir = ns)) {
[10:25:50.943]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:50.943]                         envir = ns)
[10:25:50.943]                       envir <- sys.frame(frame)
[10:25:50.943]                       master <- NULL
[10:25:50.943]                       while (!identical(envir, .GlobalEnv) && 
[10:25:50.943]                         !identical(envir, emptyenv())) {
[10:25:50.943]                         if (exists("master", mode = "list", envir = envir, 
[10:25:50.943]                           inherits = FALSE)) {
[10:25:50.943]                           master <- get("master", mode = "list", 
[10:25:50.943]                             envir = envir, inherits = FALSE)
[10:25:50.943]                           if (inherits(master, c("SOCKnode", 
[10:25:50.943]                             "SOCK0node"))) {
[10:25:50.943]                             sendCondition <<- function(cond) {
[10:25:50.943]                               data <- list(type = "VALUE", value = cond, 
[10:25:50.943]                                 success = TRUE)
[10:25:50.943]                               parallel_sendData(master, data)
[10:25:50.943]                             }
[10:25:50.943]                             return(sendCondition)
[10:25:50.943]                           }
[10:25:50.943]                         }
[10:25:50.943]                         frame <- frame + 1L
[10:25:50.943]                         envir <- sys.frame(frame)
[10:25:50.943]                       }
[10:25:50.943]                     }
[10:25:50.943]                     sendCondition <<- function(cond) NULL
[10:25:50.943]                   }
[10:25:50.943]                 })
[10:25:50.943]                 withCallingHandlers({
[10:25:50.943]                   NULL
[10:25:50.943]                 }, immediateCondition = function(cond) {
[10:25:50.943]                   sendCondition <- ...future.makeSendCondition()
[10:25:50.943]                   sendCondition(cond)
[10:25:50.943]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.943]                   {
[10:25:50.943]                     inherits <- base::inherits
[10:25:50.943]                     invokeRestart <- base::invokeRestart
[10:25:50.943]                     is.null <- base::is.null
[10:25:50.943]                     muffled <- FALSE
[10:25:50.943]                     if (inherits(cond, "message")) {
[10:25:50.943]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:50.943]                       if (muffled) 
[10:25:50.943]                         invokeRestart("muffleMessage")
[10:25:50.943]                     }
[10:25:50.943]                     else if (inherits(cond, "warning")) {
[10:25:50.943]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:50.943]                       if (muffled) 
[10:25:50.943]                         invokeRestart("muffleWarning")
[10:25:50.943]                     }
[10:25:50.943]                     else if (inherits(cond, "condition")) {
[10:25:50.943]                       if (!is.null(pattern)) {
[10:25:50.943]                         computeRestarts <- base::computeRestarts
[10:25:50.943]                         grepl <- base::grepl
[10:25:50.943]                         restarts <- computeRestarts(cond)
[10:25:50.943]                         for (restart in restarts) {
[10:25:50.943]                           name <- restart$name
[10:25:50.943]                           if (is.null(name)) 
[10:25:50.943]                             next
[10:25:50.943]                           if (!grepl(pattern, name)) 
[10:25:50.943]                             next
[10:25:50.943]                           invokeRestart(restart)
[10:25:50.943]                           muffled <- TRUE
[10:25:50.943]                           break
[10:25:50.943]                         }
[10:25:50.943]                       }
[10:25:50.943]                     }
[10:25:50.943]                     invisible(muffled)
[10:25:50.943]                   }
[10:25:50.943]                   muffleCondition(cond)
[10:25:50.943]                 })
[10:25:50.943]             }))
[10:25:50.943]             future::FutureResult(value = ...future.value$value, 
[10:25:50.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.943]                   ...future.rng), globalenv = if (FALSE) 
[10:25:50.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:50.943]                     ...future.globalenv.names))
[10:25:50.943]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:50.943]         }, condition = base::local({
[10:25:50.943]             c <- base::c
[10:25:50.943]             inherits <- base::inherits
[10:25:50.943]             invokeRestart <- base::invokeRestart
[10:25:50.943]             length <- base::length
[10:25:50.943]             list <- base::list
[10:25:50.943]             seq.int <- base::seq.int
[10:25:50.943]             signalCondition <- base::signalCondition
[10:25:50.943]             sys.calls <- base::sys.calls
[10:25:50.943]             `[[` <- base::`[[`
[10:25:50.943]             `+` <- base::`+`
[10:25:50.943]             `<<-` <- base::`<<-`
[10:25:50.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:50.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:50.943]                   3L)]
[10:25:50.943]             }
[10:25:50.943]             function(cond) {
[10:25:50.943]                 is_error <- inherits(cond, "error")
[10:25:50.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:50.943]                   NULL)
[10:25:50.943]                 if (is_error) {
[10:25:50.943]                   sessionInformation <- function() {
[10:25:50.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:50.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:50.943]                       search = base::search(), system = base::Sys.info())
[10:25:50.943]                   }
[10:25:50.943]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:50.943]                     cond$call), session = sessionInformation(), 
[10:25:50.943]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:50.943]                   signalCondition(cond)
[10:25:50.943]                 }
[10:25:50.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:50.943]                 "immediateCondition"))) {
[10:25:50.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:50.943]                   ...future.conditions[[length(...future.conditions) + 
[10:25:50.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:50.943]                   if (TRUE && !signal) {
[10:25:50.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.943]                     {
[10:25:50.943]                       inherits <- base::inherits
[10:25:50.943]                       invokeRestart <- base::invokeRestart
[10:25:50.943]                       is.null <- base::is.null
[10:25:50.943]                       muffled <- FALSE
[10:25:50.943]                       if (inherits(cond, "message")) {
[10:25:50.943]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.943]                         if (muffled) 
[10:25:50.943]                           invokeRestart("muffleMessage")
[10:25:50.943]                       }
[10:25:50.943]                       else if (inherits(cond, "warning")) {
[10:25:50.943]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.943]                         if (muffled) 
[10:25:50.943]                           invokeRestart("muffleWarning")
[10:25:50.943]                       }
[10:25:50.943]                       else if (inherits(cond, "condition")) {
[10:25:50.943]                         if (!is.null(pattern)) {
[10:25:50.943]                           computeRestarts <- base::computeRestarts
[10:25:50.943]                           grepl <- base::grepl
[10:25:50.943]                           restarts <- computeRestarts(cond)
[10:25:50.943]                           for (restart in restarts) {
[10:25:50.943]                             name <- restart$name
[10:25:50.943]                             if (is.null(name)) 
[10:25:50.943]                               next
[10:25:50.943]                             if (!grepl(pattern, name)) 
[10:25:50.943]                               next
[10:25:50.943]                             invokeRestart(restart)
[10:25:50.943]                             muffled <- TRUE
[10:25:50.943]                             break
[10:25:50.943]                           }
[10:25:50.943]                         }
[10:25:50.943]                       }
[10:25:50.943]                       invisible(muffled)
[10:25:50.943]                     }
[10:25:50.943]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.943]                   }
[10:25:50.943]                 }
[10:25:50.943]                 else {
[10:25:50.943]                   if (TRUE) {
[10:25:50.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:50.943]                     {
[10:25:50.943]                       inherits <- base::inherits
[10:25:50.943]                       invokeRestart <- base::invokeRestart
[10:25:50.943]                       is.null <- base::is.null
[10:25:50.943]                       muffled <- FALSE
[10:25:50.943]                       if (inherits(cond, "message")) {
[10:25:50.943]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:50.943]                         if (muffled) 
[10:25:50.943]                           invokeRestart("muffleMessage")
[10:25:50.943]                       }
[10:25:50.943]                       else if (inherits(cond, "warning")) {
[10:25:50.943]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:50.943]                         if (muffled) 
[10:25:50.943]                           invokeRestart("muffleWarning")
[10:25:50.943]                       }
[10:25:50.943]                       else if (inherits(cond, "condition")) {
[10:25:50.943]                         if (!is.null(pattern)) {
[10:25:50.943]                           computeRestarts <- base::computeRestarts
[10:25:50.943]                           grepl <- base::grepl
[10:25:50.943]                           restarts <- computeRestarts(cond)
[10:25:50.943]                           for (restart in restarts) {
[10:25:50.943]                             name <- restart$name
[10:25:50.943]                             if (is.null(name)) 
[10:25:50.943]                               next
[10:25:50.943]                             if (!grepl(pattern, name)) 
[10:25:50.943]                               next
[10:25:50.943]                             invokeRestart(restart)
[10:25:50.943]                             muffled <- TRUE
[10:25:50.943]                             break
[10:25:50.943]                           }
[10:25:50.943]                         }
[10:25:50.943]                       }
[10:25:50.943]                       invisible(muffled)
[10:25:50.943]                     }
[10:25:50.943]                     muffleCondition(cond, pattern = "^muffle")
[10:25:50.943]                   }
[10:25:50.943]                 }
[10:25:50.943]             }
[10:25:50.943]         }))
[10:25:50.943]     }, error = function(ex) {
[10:25:50.943]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:50.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:50.943]                 ...future.rng), started = ...future.startTime, 
[10:25:50.943]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:50.943]             version = "1.8"), class = "FutureResult")
[10:25:50.943]     }, finally = {
[10:25:50.943]         if (!identical(...future.workdir, getwd())) 
[10:25:50.943]             setwd(...future.workdir)
[10:25:50.943]         {
[10:25:50.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:50.943]                 ...future.oldOptions$nwarnings <- NULL
[10:25:50.943]             }
[10:25:50.943]             base::options(...future.oldOptions)
[10:25:50.943]             if (.Platform$OS.type == "windows") {
[10:25:50.943]                 old_names <- names(...future.oldEnvVars)
[10:25:50.943]                 envs <- base::Sys.getenv()
[10:25:50.943]                 names <- names(envs)
[10:25:50.943]                 common <- intersect(names, old_names)
[10:25:50.943]                 added <- setdiff(names, old_names)
[10:25:50.943]                 removed <- setdiff(old_names, names)
[10:25:50.943]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:50.943]                   envs[common]]
[10:25:50.943]                 NAMES <- toupper(changed)
[10:25:50.943]                 args <- list()
[10:25:50.943]                 for (kk in seq_along(NAMES)) {
[10:25:50.943]                   name <- changed[[kk]]
[10:25:50.943]                   NAME <- NAMES[[kk]]
[10:25:50.943]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.943]                     next
[10:25:50.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.943]                 }
[10:25:50.943]                 NAMES <- toupper(added)
[10:25:50.943]                 for (kk in seq_along(NAMES)) {
[10:25:50.943]                   name <- added[[kk]]
[10:25:50.943]                   NAME <- NAMES[[kk]]
[10:25:50.943]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.943]                     next
[10:25:50.943]                   args[[name]] <- ""
[10:25:50.943]                 }
[10:25:50.943]                 NAMES <- toupper(removed)
[10:25:50.943]                 for (kk in seq_along(NAMES)) {
[10:25:50.943]                   name <- removed[[kk]]
[10:25:50.943]                   NAME <- NAMES[[kk]]
[10:25:50.943]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:50.943]                     next
[10:25:50.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:50.943]                 }
[10:25:50.943]                 if (length(args) > 0) 
[10:25:50.943]                   base::do.call(base::Sys.setenv, args = args)
[10:25:50.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:50.943]             }
[10:25:50.943]             else {
[10:25:50.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:50.943]             }
[10:25:50.943]             {
[10:25:50.943]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:50.943]                   0L) {
[10:25:50.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:50.943]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:50.943]                   base::options(opts)
[10:25:50.943]                 }
[10:25:50.943]                 {
[10:25:50.943]                   {
[10:25:50.943]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:50.943]                     NULL
[10:25:50.943]                   }
[10:25:50.943]                   options(future.plan = NULL)
[10:25:50.943]                   if (is.na(NA_character_)) 
[10:25:50.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:50.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:50.943]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:50.943]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:50.943]                     envir = parent.frame()) 
[10:25:50.943]                   {
[10:25:50.943]                     if (is.function(workers)) 
[10:25:50.943]                       workers <- workers()
[10:25:50.943]                     workers <- structure(as.integer(workers), 
[10:25:50.943]                       class = class(workers))
[10:25:50.943]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:50.943]                       workers >= 1)
[10:25:50.943]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:50.943]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:50.943]                     }
[10:25:50.943]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:50.943]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:50.943]                       envir = envir)
[10:25:50.943]                     if (!future$lazy) 
[10:25:50.943]                       future <- run(future)
[10:25:50.943]                     invisible(future)
[10:25:50.943]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:50.943]                 }
[10:25:50.943]             }
[10:25:50.943]         }
[10:25:50.943]     })
[10:25:50.943]     if (TRUE) {
[10:25:50.943]         base::sink(type = "output", split = FALSE)
[10:25:50.943]         if (TRUE) {
[10:25:50.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:50.943]         }
[10:25:50.943]         else {
[10:25:50.943]             ...future.result["stdout"] <- base::list(NULL)
[10:25:50.943]         }
[10:25:50.943]         base::close(...future.stdout)
[10:25:50.943]         ...future.stdout <- NULL
[10:25:50.943]     }
[10:25:50.943]     ...future.result$conditions <- ...future.conditions
[10:25:50.943]     ...future.result$finished <- base::Sys.time()
[10:25:50.943]     ...future.result
[10:25:50.943] }
[10:25:50.997] MultisessionFuture started
[10:25:50.998] - Launch lazy future ... done
[10:25:50.998] run() for ‘MultisessionFuture’ ... done
[10:25:50.999] getGlobalsAndPackages() ...
[10:25:50.999] Searching for globals...
[10:25:51.000] - globals found: [1] ‘{’
[10:25:51.000] Searching for globals ... DONE
[10:25:51.000] Resolving globals: FALSE
[10:25:51.000] 
[10:25:51.001] 
[10:25:51.001] getGlobalsAndPackages() ... DONE
[10:25:51.001] run() for ‘Future’ ...
[10:25:51.001] - state: ‘created’
[10:25:51.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.017] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.018]   - Field: ‘node’
[10:25:51.018]   - Field: ‘label’
[10:25:51.018]   - Field: ‘local’
[10:25:51.018]   - Field: ‘owner’
[10:25:51.018]   - Field: ‘envir’
[10:25:51.018]   - Field: ‘workers’
[10:25:51.018]   - Field: ‘packages’
[10:25:51.018]   - Field: ‘gc’
[10:25:51.018]   - Field: ‘conditions’
[10:25:51.019]   - Field: ‘persistent’
[10:25:51.019]   - Field: ‘expr’
[10:25:51.019]   - Field: ‘uuid’
[10:25:51.019]   - Field: ‘seed’
[10:25:51.019]   - Field: ‘version’
[10:25:51.019]   - Field: ‘result’
[10:25:51.019]   - Field: ‘asynchronous’
[10:25:51.019]   - Field: ‘calls’
[10:25:51.019]   - Field: ‘globals’
[10:25:51.019]   - Field: ‘stdout’
[10:25:51.020]   - Field: ‘earlySignal’
[10:25:51.020]   - Field: ‘lazy’
[10:25:51.020]   - Field: ‘state’
[10:25:51.020] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.020] - Launch lazy future ...
[10:25:51.020] Packages needed by the future expression (n = 0): <none>
[10:25:51.020] Packages needed by future strategies (n = 0): <none>
[10:25:51.021] {
[10:25:51.021]     {
[10:25:51.021]         {
[10:25:51.021]             ...future.startTime <- base::Sys.time()
[10:25:51.021]             {
[10:25:51.021]                 {
[10:25:51.021]                   {
[10:25:51.021]                     {
[10:25:51.021]                       base::local({
[10:25:51.021]                         has_future <- base::requireNamespace("future", 
[10:25:51.021]                           quietly = TRUE)
[10:25:51.021]                         if (has_future) {
[10:25:51.021]                           ns <- base::getNamespace("future")
[10:25:51.021]                           version <- ns[[".package"]][["version"]]
[10:25:51.021]                           if (is.null(version)) 
[10:25:51.021]                             version <- utils::packageVersion("future")
[10:25:51.021]                         }
[10:25:51.021]                         else {
[10:25:51.021]                           version <- NULL
[10:25:51.021]                         }
[10:25:51.021]                         if (!has_future || version < "1.8.0") {
[10:25:51.021]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.021]                             "", base::R.version$version.string), 
[10:25:51.021]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.021]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.021]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.021]                               "release", "version")], collapse = " "), 
[10:25:51.021]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.021]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.021]                             info)
[10:25:51.021]                           info <- base::paste(info, collapse = "; ")
[10:25:51.021]                           if (!has_future) {
[10:25:51.021]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.021]                               info)
[10:25:51.021]                           }
[10:25:51.021]                           else {
[10:25:51.021]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.021]                               info, version)
[10:25:51.021]                           }
[10:25:51.021]                           base::stop(msg)
[10:25:51.021]                         }
[10:25:51.021]                       })
[10:25:51.021]                     }
[10:25:51.021]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.021]                     base::options(mc.cores = 1L)
[10:25:51.021]                   }
[10:25:51.021]                   options(future.plan = NULL)
[10:25:51.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.021]                 }
[10:25:51.021]                 ...future.workdir <- getwd()
[10:25:51.021]             }
[10:25:51.021]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.021]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.021]         }
[10:25:51.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.021]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.021]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.021]             base::names(...future.oldOptions))
[10:25:51.021]     }
[10:25:51.021]     if (FALSE) {
[10:25:51.021]     }
[10:25:51.021]     else {
[10:25:51.021]         if (TRUE) {
[10:25:51.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.021]                 open = "w")
[10:25:51.021]         }
[10:25:51.021]         else {
[10:25:51.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.021]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.021]         }
[10:25:51.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.021]             base::sink(type = "output", split = FALSE)
[10:25:51.021]             base::close(...future.stdout)
[10:25:51.021]         }, add = TRUE)
[10:25:51.021]     }
[10:25:51.021]     ...future.frame <- base::sys.nframe()
[10:25:51.021]     ...future.conditions <- base::list()
[10:25:51.021]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.021]     if (FALSE) {
[10:25:51.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.021]     }
[10:25:51.021]     ...future.result <- base::tryCatch({
[10:25:51.021]         base::withCallingHandlers({
[10:25:51.021]             ...future.value <- base::withVisible(base::local({
[10:25:51.021]                 ...future.makeSendCondition <- base::local({
[10:25:51.021]                   sendCondition <- NULL
[10:25:51.021]                   function(frame = 1L) {
[10:25:51.021]                     if (is.function(sendCondition)) 
[10:25:51.021]                       return(sendCondition)
[10:25:51.021]                     ns <- getNamespace("parallel")
[10:25:51.021]                     if (exists("sendData", mode = "function", 
[10:25:51.021]                       envir = ns)) {
[10:25:51.021]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.021]                         envir = ns)
[10:25:51.021]                       envir <- sys.frame(frame)
[10:25:51.021]                       master <- NULL
[10:25:51.021]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.021]                         !identical(envir, emptyenv())) {
[10:25:51.021]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.021]                           inherits = FALSE)) {
[10:25:51.021]                           master <- get("master", mode = "list", 
[10:25:51.021]                             envir = envir, inherits = FALSE)
[10:25:51.021]                           if (inherits(master, c("SOCKnode", 
[10:25:51.021]                             "SOCK0node"))) {
[10:25:51.021]                             sendCondition <<- function(cond) {
[10:25:51.021]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.021]                                 success = TRUE)
[10:25:51.021]                               parallel_sendData(master, data)
[10:25:51.021]                             }
[10:25:51.021]                             return(sendCondition)
[10:25:51.021]                           }
[10:25:51.021]                         }
[10:25:51.021]                         frame <- frame + 1L
[10:25:51.021]                         envir <- sys.frame(frame)
[10:25:51.021]                       }
[10:25:51.021]                     }
[10:25:51.021]                     sendCondition <<- function(cond) NULL
[10:25:51.021]                   }
[10:25:51.021]                 })
[10:25:51.021]                 withCallingHandlers({
[10:25:51.021]                   {
[10:25:51.021]                     4
[10:25:51.021]                   }
[10:25:51.021]                 }, immediateCondition = function(cond) {
[10:25:51.021]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.021]                   sendCondition(cond)
[10:25:51.021]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.021]                   {
[10:25:51.021]                     inherits <- base::inherits
[10:25:51.021]                     invokeRestart <- base::invokeRestart
[10:25:51.021]                     is.null <- base::is.null
[10:25:51.021]                     muffled <- FALSE
[10:25:51.021]                     if (inherits(cond, "message")) {
[10:25:51.021]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.021]                       if (muffled) 
[10:25:51.021]                         invokeRestart("muffleMessage")
[10:25:51.021]                     }
[10:25:51.021]                     else if (inherits(cond, "warning")) {
[10:25:51.021]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.021]                       if (muffled) 
[10:25:51.021]                         invokeRestart("muffleWarning")
[10:25:51.021]                     }
[10:25:51.021]                     else if (inherits(cond, "condition")) {
[10:25:51.021]                       if (!is.null(pattern)) {
[10:25:51.021]                         computeRestarts <- base::computeRestarts
[10:25:51.021]                         grepl <- base::grepl
[10:25:51.021]                         restarts <- computeRestarts(cond)
[10:25:51.021]                         for (restart in restarts) {
[10:25:51.021]                           name <- restart$name
[10:25:51.021]                           if (is.null(name)) 
[10:25:51.021]                             next
[10:25:51.021]                           if (!grepl(pattern, name)) 
[10:25:51.021]                             next
[10:25:51.021]                           invokeRestart(restart)
[10:25:51.021]                           muffled <- TRUE
[10:25:51.021]                           break
[10:25:51.021]                         }
[10:25:51.021]                       }
[10:25:51.021]                     }
[10:25:51.021]                     invisible(muffled)
[10:25:51.021]                   }
[10:25:51.021]                   muffleCondition(cond)
[10:25:51.021]                 })
[10:25:51.021]             }))
[10:25:51.021]             future::FutureResult(value = ...future.value$value, 
[10:25:51.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.021]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.021]                     ...future.globalenv.names))
[10:25:51.021]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.021]         }, condition = base::local({
[10:25:51.021]             c <- base::c
[10:25:51.021]             inherits <- base::inherits
[10:25:51.021]             invokeRestart <- base::invokeRestart
[10:25:51.021]             length <- base::length
[10:25:51.021]             list <- base::list
[10:25:51.021]             seq.int <- base::seq.int
[10:25:51.021]             signalCondition <- base::signalCondition
[10:25:51.021]             sys.calls <- base::sys.calls
[10:25:51.021]             `[[` <- base::`[[`
[10:25:51.021]             `+` <- base::`+`
[10:25:51.021]             `<<-` <- base::`<<-`
[10:25:51.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.021]                   3L)]
[10:25:51.021]             }
[10:25:51.021]             function(cond) {
[10:25:51.021]                 is_error <- inherits(cond, "error")
[10:25:51.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.021]                   NULL)
[10:25:51.021]                 if (is_error) {
[10:25:51.021]                   sessionInformation <- function() {
[10:25:51.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.021]                       search = base::search(), system = base::Sys.info())
[10:25:51.021]                   }
[10:25:51.021]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.021]                     cond$call), session = sessionInformation(), 
[10:25:51.021]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.021]                   signalCondition(cond)
[10:25:51.021]                 }
[10:25:51.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.021]                 "immediateCondition"))) {
[10:25:51.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.021]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.021]                   if (TRUE && !signal) {
[10:25:51.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.021]                     {
[10:25:51.021]                       inherits <- base::inherits
[10:25:51.021]                       invokeRestart <- base::invokeRestart
[10:25:51.021]                       is.null <- base::is.null
[10:25:51.021]                       muffled <- FALSE
[10:25:51.021]                       if (inherits(cond, "message")) {
[10:25:51.021]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.021]                         if (muffled) 
[10:25:51.021]                           invokeRestart("muffleMessage")
[10:25:51.021]                       }
[10:25:51.021]                       else if (inherits(cond, "warning")) {
[10:25:51.021]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.021]                         if (muffled) 
[10:25:51.021]                           invokeRestart("muffleWarning")
[10:25:51.021]                       }
[10:25:51.021]                       else if (inherits(cond, "condition")) {
[10:25:51.021]                         if (!is.null(pattern)) {
[10:25:51.021]                           computeRestarts <- base::computeRestarts
[10:25:51.021]                           grepl <- base::grepl
[10:25:51.021]                           restarts <- computeRestarts(cond)
[10:25:51.021]                           for (restart in restarts) {
[10:25:51.021]                             name <- restart$name
[10:25:51.021]                             if (is.null(name)) 
[10:25:51.021]                               next
[10:25:51.021]                             if (!grepl(pattern, name)) 
[10:25:51.021]                               next
[10:25:51.021]                             invokeRestart(restart)
[10:25:51.021]                             muffled <- TRUE
[10:25:51.021]                             break
[10:25:51.021]                           }
[10:25:51.021]                         }
[10:25:51.021]                       }
[10:25:51.021]                       invisible(muffled)
[10:25:51.021]                     }
[10:25:51.021]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.021]                   }
[10:25:51.021]                 }
[10:25:51.021]                 else {
[10:25:51.021]                   if (TRUE) {
[10:25:51.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.021]                     {
[10:25:51.021]                       inherits <- base::inherits
[10:25:51.021]                       invokeRestart <- base::invokeRestart
[10:25:51.021]                       is.null <- base::is.null
[10:25:51.021]                       muffled <- FALSE
[10:25:51.021]                       if (inherits(cond, "message")) {
[10:25:51.021]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.021]                         if (muffled) 
[10:25:51.021]                           invokeRestart("muffleMessage")
[10:25:51.021]                       }
[10:25:51.021]                       else if (inherits(cond, "warning")) {
[10:25:51.021]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.021]                         if (muffled) 
[10:25:51.021]                           invokeRestart("muffleWarning")
[10:25:51.021]                       }
[10:25:51.021]                       else if (inherits(cond, "condition")) {
[10:25:51.021]                         if (!is.null(pattern)) {
[10:25:51.021]                           computeRestarts <- base::computeRestarts
[10:25:51.021]                           grepl <- base::grepl
[10:25:51.021]                           restarts <- computeRestarts(cond)
[10:25:51.021]                           for (restart in restarts) {
[10:25:51.021]                             name <- restart$name
[10:25:51.021]                             if (is.null(name)) 
[10:25:51.021]                               next
[10:25:51.021]                             if (!grepl(pattern, name)) 
[10:25:51.021]                               next
[10:25:51.021]                             invokeRestart(restart)
[10:25:51.021]                             muffled <- TRUE
[10:25:51.021]                             break
[10:25:51.021]                           }
[10:25:51.021]                         }
[10:25:51.021]                       }
[10:25:51.021]                       invisible(muffled)
[10:25:51.021]                     }
[10:25:51.021]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.021]                   }
[10:25:51.021]                 }
[10:25:51.021]             }
[10:25:51.021]         }))
[10:25:51.021]     }, error = function(ex) {
[10:25:51.021]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.021]                 ...future.rng), started = ...future.startTime, 
[10:25:51.021]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.021]             version = "1.8"), class = "FutureResult")
[10:25:51.021]     }, finally = {
[10:25:51.021]         if (!identical(...future.workdir, getwd())) 
[10:25:51.021]             setwd(...future.workdir)
[10:25:51.021]         {
[10:25:51.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.021]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.021]             }
[10:25:51.021]             base::options(...future.oldOptions)
[10:25:51.021]             if (.Platform$OS.type == "windows") {
[10:25:51.021]                 old_names <- names(...future.oldEnvVars)
[10:25:51.021]                 envs <- base::Sys.getenv()
[10:25:51.021]                 names <- names(envs)
[10:25:51.021]                 common <- intersect(names, old_names)
[10:25:51.021]                 added <- setdiff(names, old_names)
[10:25:51.021]                 removed <- setdiff(old_names, names)
[10:25:51.021]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.021]                   envs[common]]
[10:25:51.021]                 NAMES <- toupper(changed)
[10:25:51.021]                 args <- list()
[10:25:51.021]                 for (kk in seq_along(NAMES)) {
[10:25:51.021]                   name <- changed[[kk]]
[10:25:51.021]                   NAME <- NAMES[[kk]]
[10:25:51.021]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.021]                     next
[10:25:51.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.021]                 }
[10:25:51.021]                 NAMES <- toupper(added)
[10:25:51.021]                 for (kk in seq_along(NAMES)) {
[10:25:51.021]                   name <- added[[kk]]
[10:25:51.021]                   NAME <- NAMES[[kk]]
[10:25:51.021]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.021]                     next
[10:25:51.021]                   args[[name]] <- ""
[10:25:51.021]                 }
[10:25:51.021]                 NAMES <- toupper(removed)
[10:25:51.021]                 for (kk in seq_along(NAMES)) {
[10:25:51.021]                   name <- removed[[kk]]
[10:25:51.021]                   NAME <- NAMES[[kk]]
[10:25:51.021]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.021]                     next
[10:25:51.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.021]                 }
[10:25:51.021]                 if (length(args) > 0) 
[10:25:51.021]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.021]             }
[10:25:51.021]             else {
[10:25:51.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.021]             }
[10:25:51.021]             {
[10:25:51.021]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.021]                   0L) {
[10:25:51.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.021]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.021]                   base::options(opts)
[10:25:51.021]                 }
[10:25:51.021]                 {
[10:25:51.021]                   {
[10:25:51.021]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.021]                     NULL
[10:25:51.021]                   }
[10:25:51.021]                   options(future.plan = NULL)
[10:25:51.021]                   if (is.na(NA_character_)) 
[10:25:51.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.021]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.021]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.021]                     envir = parent.frame()) 
[10:25:51.021]                   {
[10:25:51.021]                     if (is.function(workers)) 
[10:25:51.021]                       workers <- workers()
[10:25:51.021]                     workers <- structure(as.integer(workers), 
[10:25:51.021]                       class = class(workers))
[10:25:51.021]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.021]                       workers >= 1)
[10:25:51.021]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.021]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.021]                     }
[10:25:51.021]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.021]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.021]                       envir = envir)
[10:25:51.021]                     if (!future$lazy) 
[10:25:51.021]                       future <- run(future)
[10:25:51.021]                     invisible(future)
[10:25:51.021]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.021]                 }
[10:25:51.021]             }
[10:25:51.021]         }
[10:25:51.021]     })
[10:25:51.021]     if (TRUE) {
[10:25:51.021]         base::sink(type = "output", split = FALSE)
[10:25:51.021]         if (TRUE) {
[10:25:51.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.021]         }
[10:25:51.021]         else {
[10:25:51.021]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.021]         }
[10:25:51.021]         base::close(...future.stdout)
[10:25:51.021]         ...future.stdout <- NULL
[10:25:51.021]     }
[10:25:51.021]     ...future.result$conditions <- ...future.conditions
[10:25:51.021]     ...future.result$finished <- base::Sys.time()
[10:25:51.021]     ...future.result
[10:25:51.021] }
[10:25:51.023] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:51.034] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.034] - Validating connection of MultisessionFuture
[10:25:51.034] - received message: FutureResult
[10:25:51.034] - Received FutureResult
[10:25:51.034] - Erased future from FutureRegistry
[10:25:51.035] result() for ClusterFuture ...
[10:25:51.035] - result already collected: FutureResult
[10:25:51.035] result() for ClusterFuture ... done
[10:25:51.035] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.035] result() for ClusterFuture ...
[10:25:51.035] - result already collected: FutureResult
[10:25:51.035] result() for ClusterFuture ... done
[10:25:51.035] result() for ClusterFuture ...
[10:25:51.035] - result already collected: FutureResult
[10:25:51.035] result() for ClusterFuture ... done
[10:25:51.037] MultisessionFuture started
[10:25:51.037] - Launch lazy future ... done
[10:25:51.037] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f7100350> 
Classes 'listenv', 'environment' <environment: 0x55c0f34c8fe8> 
[10:25:51.046] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.046] - Validating connection of MultisessionFuture
[10:25:51.046] - received message: FutureResult
[10:25:51.046] - Received FutureResult
[10:25:51.046] - Erased future from FutureRegistry
[10:25:51.047] result() for ClusterFuture ...
[10:25:51.047] - result already collected: FutureResult
[10:25:51.047] result() for ClusterFuture ... done
[10:25:51.047] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:51.059] resolve() on list environment ...
[10:25:51.059]  recursive: 0
[10:25:51.060]  length: 6
[10:25:51.060]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:51.060] signalConditionsASAP(numeric, pos=1) ...
[10:25:51.060] - nx: 6
[10:25:51.060] - relay: TRUE
[10:25:51.061] - stdout: TRUE
[10:25:51.061] - signal: TRUE
[10:25:51.061] - resignal: FALSE
[10:25:51.061] - force: TRUE
[10:25:51.061] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.061] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.061]  - until=2
[10:25:51.061]  - relaying element #2
[10:25:51.061] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.061] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.061] signalConditionsASAP(NULL, pos=1) ... done
[10:25:51.062]  length: 5 (resolved future 1)
[10:25:51.062] Future #2
[10:25:51.062] result() for ClusterFuture ...
[10:25:51.062] - result already collected: FutureResult
[10:25:51.062] result() for ClusterFuture ... done
[10:25:51.062] result() for ClusterFuture ...
[10:25:51.062] - result already collected: FutureResult
[10:25:51.062] result() for ClusterFuture ... done
[10:25:51.062] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:51.062] - nx: 6
[10:25:51.063] - relay: TRUE
[10:25:51.063] - stdout: TRUE
[10:25:51.063] - signal: TRUE
[10:25:51.063] - resignal: FALSE
[10:25:51.063] - force: TRUE
[10:25:51.063] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.063] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.063]  - until=2
[10:25:51.063]  - relaying element #2
[10:25:51.063] result() for ClusterFuture ...
[10:25:51.063] - result already collected: FutureResult
[10:25:51.063] result() for ClusterFuture ... done
[10:25:51.064] result() for ClusterFuture ...
[10:25:51.064] - result already collected: FutureResult
[10:25:51.064] result() for ClusterFuture ... done
[10:25:51.064] result() for ClusterFuture ...
[10:25:51.064] - result already collected: FutureResult
[10:25:51.064] result() for ClusterFuture ... done
[10:25:51.064] result() for ClusterFuture ...
[10:25:51.064] - result already collected: FutureResult
[10:25:51.064] result() for ClusterFuture ... done
[10:25:51.064] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.064] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.065] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:51.065]  length: 4 (resolved future 2)
[10:25:51.065] Future #3
[10:25:51.065] result() for ClusterFuture ...
[10:25:51.065] - result already collected: FutureResult
[10:25:51.065] result() for ClusterFuture ... done
[10:25:51.065] result() for ClusterFuture ...
[10:25:51.065] - result already collected: FutureResult
[10:25:51.065] result() for ClusterFuture ... done
[10:25:51.065] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:51.066] - nx: 6
[10:25:51.066] - relay: TRUE
[10:25:51.066] - stdout: TRUE
[10:25:51.066] - signal: TRUE
[10:25:51.066] - resignal: FALSE
[10:25:51.066] - force: TRUE
[10:25:51.066] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.066] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.066]  - until=3
[10:25:51.066]  - relaying element #3
[10:25:51.066] result() for ClusterFuture ...
[10:25:51.066] - result already collected: FutureResult
[10:25:51.067] result() for ClusterFuture ... done
[10:25:51.067] result() for ClusterFuture ...
[10:25:51.067] - result already collected: FutureResult
[10:25:51.067] result() for ClusterFuture ... done
[10:25:51.067] result() for ClusterFuture ...
[10:25:51.067] - result already collected: FutureResult
[10:25:51.067] result() for ClusterFuture ... done
[10:25:51.067] result() for ClusterFuture ...
[10:25:51.067] - result already collected: FutureResult
[10:25:51.067] result() for ClusterFuture ... done
[10:25:51.067] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.068] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.068] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:51.068]  length: 3 (resolved future 3)
[10:25:51.078] signalConditionsASAP(NULL, pos=5) ...
[10:25:51.078] - nx: 6
[10:25:51.079] - relay: TRUE
[10:25:51.079] - stdout: TRUE
[10:25:51.079] - signal: TRUE
[10:25:51.079] - resignal: FALSE
[10:25:51.079] - force: TRUE
[10:25:51.079] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.080] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.080]  - until=6
[10:25:51.080]  - relaying element #4
[10:25:51.080]  - relaying element #6
[10:25:51.080] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:25:51.080] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.080] signalConditionsASAP(NULL, pos=5) ... done
[10:25:51.080]  length: 2 (resolved future 5)
[10:25:51.081] signalConditionsASAP(numeric, pos=6) ...
[10:25:51.081] - nx: 6
[10:25:51.081] - relay: TRUE
[10:25:51.081] - stdout: TRUE
[10:25:51.081] - signal: TRUE
[10:25:51.081] - resignal: FALSE
[10:25:51.081] - force: TRUE
[10:25:51.081] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:25:51.081] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.081]  - until=6
[10:25:51.081]  - relaying element #4
[10:25:51.082] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:25:51.082] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.082] signalConditionsASAP(NULL, pos=6) ... done
[10:25:51.082]  length: 1 (resolved future 6)
[10:25:51.093] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.093] - Validating connection of MultisessionFuture
[10:25:51.093] - received message: FutureResult
[10:25:51.093] - Received FutureResult
[10:25:51.093] - Erased future from FutureRegistry
[10:25:51.093] result() for ClusterFuture ...
[10:25:51.094] - result already collected: FutureResult
[10:25:51.094] result() for ClusterFuture ... done
[10:25:51.094] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.094] Future #4
[10:25:51.094] result() for ClusterFuture ...
[10:25:51.094] - result already collected: FutureResult
[10:25:51.094] result() for ClusterFuture ... done
[10:25:51.094] result() for ClusterFuture ...
[10:25:51.094] - result already collected: FutureResult
[10:25:51.094] result() for ClusterFuture ... done
[10:25:51.094] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:51.095] - nx: 6
[10:25:51.095] - relay: TRUE
[10:25:51.095] - stdout: TRUE
[10:25:51.095] - signal: TRUE
[10:25:51.095] - resignal: FALSE
[10:25:51.095] - force: TRUE
[10:25:51.095] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:25:51.095] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.095]  - until=6
[10:25:51.095]  - relaying element #4
[10:25:51.095] result() for ClusterFuture ...
[10:25:51.095] - result already collected: FutureResult
[10:25:51.096] result() for ClusterFuture ... done
[10:25:51.096] result() for ClusterFuture ...
[10:25:51.096] - result already collected: FutureResult
[10:25:51.096] result() for ClusterFuture ... done
[10:25:51.096] result() for ClusterFuture ...
[10:25:51.096] - result already collected: FutureResult
[10:25:51.096] result() for ClusterFuture ... done
[10:25:51.096] result() for ClusterFuture ...
[10:25:51.096] - result already collected: FutureResult
[10:25:51.096] result() for ClusterFuture ... done
[10:25:51.096] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.097] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.097] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:51.097]  length: 0 (resolved future 4)
[10:25:51.097] Relaying remaining futures
[10:25:51.097] signalConditionsASAP(NULL, pos=0) ...
[10:25:51.097] - nx: 6
[10:25:51.097] - relay: TRUE
[10:25:51.097] - stdout: TRUE
[10:25:51.097] - signal: TRUE
[10:25:51.097] - resignal: FALSE
[10:25:51.097] - force: TRUE
[10:25:51.097] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.098] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:51.098] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.098] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.098] signalConditionsASAP(NULL, pos=0) ... done
[10:25:51.098] resolve() on list environment ... DONE
[10:25:51.098] result() for ClusterFuture ...
[10:25:51.098] - result already collected: FutureResult
[10:25:51.098] result() for ClusterFuture ... done
[10:25:51.098] result() for ClusterFuture ...
[10:25:51.098] - result already collected: FutureResult
[10:25:51.099] result() for ClusterFuture ... done
[10:25:51.099] result() for ClusterFuture ...
[10:25:51.099] - result already collected: FutureResult
[10:25:51.099] result() for ClusterFuture ... done
[10:25:51.099] result() for ClusterFuture ...
[10:25:51.099] - result already collected: FutureResult
[10:25:51.099] result() for ClusterFuture ... done
[10:25:51.099] result() for ClusterFuture ...
[10:25:51.099] - result already collected: FutureResult
[10:25:51.099] result() for ClusterFuture ... done
[10:25:51.100] result() for ClusterFuture ...
[10:25:51.100] - result already collected: FutureResult
[10:25:51.100] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f5c6eaf8> 
Dimensions: c(1, 6)
[10:25:51.100] getGlobalsAndPackages() ...
[10:25:51.100] Searching for globals...
[10:25:51.101] 
[10:25:51.101] Searching for globals ... DONE
[10:25:51.101] - globals: [0] <none>
[10:25:51.101] getGlobalsAndPackages() ... DONE
[10:25:51.101] run() for ‘Future’ ...
[10:25:51.101] - state: ‘created’
[10:25:51.102] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.115] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.116] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.116]   - Field: ‘node’
[10:25:51.116]   - Field: ‘label’
[10:25:51.116]   - Field: ‘local’
[10:25:51.116]   - Field: ‘owner’
[10:25:51.116]   - Field: ‘envir’
[10:25:51.116]   - Field: ‘workers’
[10:25:51.116]   - Field: ‘packages’
[10:25:51.116]   - Field: ‘gc’
[10:25:51.116]   - Field: ‘conditions’
[10:25:51.117]   - Field: ‘persistent’
[10:25:51.117]   - Field: ‘expr’
[10:25:51.117]   - Field: ‘uuid’
[10:25:51.117]   - Field: ‘seed’
[10:25:51.117]   - Field: ‘version’
[10:25:51.117]   - Field: ‘result’
[10:25:51.117]   - Field: ‘asynchronous’
[10:25:51.117]   - Field: ‘calls’
[10:25:51.117]   - Field: ‘globals’
[10:25:51.117]   - Field: ‘stdout’
[10:25:51.118]   - Field: ‘earlySignal’
[10:25:51.118]   - Field: ‘lazy’
[10:25:51.118]   - Field: ‘state’
[10:25:51.118] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.118] - Launch lazy future ...
[10:25:51.118] Packages needed by the future expression (n = 0): <none>
[10:25:51.118] Packages needed by future strategies (n = 0): <none>
[10:25:51.119] {
[10:25:51.119]     {
[10:25:51.119]         {
[10:25:51.119]             ...future.startTime <- base::Sys.time()
[10:25:51.119]             {
[10:25:51.119]                 {
[10:25:51.119]                   {
[10:25:51.119]                     {
[10:25:51.119]                       base::local({
[10:25:51.119]                         has_future <- base::requireNamespace("future", 
[10:25:51.119]                           quietly = TRUE)
[10:25:51.119]                         if (has_future) {
[10:25:51.119]                           ns <- base::getNamespace("future")
[10:25:51.119]                           version <- ns[[".package"]][["version"]]
[10:25:51.119]                           if (is.null(version)) 
[10:25:51.119]                             version <- utils::packageVersion("future")
[10:25:51.119]                         }
[10:25:51.119]                         else {
[10:25:51.119]                           version <- NULL
[10:25:51.119]                         }
[10:25:51.119]                         if (!has_future || version < "1.8.0") {
[10:25:51.119]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.119]                             "", base::R.version$version.string), 
[10:25:51.119]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.119]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.119]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.119]                               "release", "version")], collapse = " "), 
[10:25:51.119]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.119]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.119]                             info)
[10:25:51.119]                           info <- base::paste(info, collapse = "; ")
[10:25:51.119]                           if (!has_future) {
[10:25:51.119]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.119]                               info)
[10:25:51.119]                           }
[10:25:51.119]                           else {
[10:25:51.119]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.119]                               info, version)
[10:25:51.119]                           }
[10:25:51.119]                           base::stop(msg)
[10:25:51.119]                         }
[10:25:51.119]                       })
[10:25:51.119]                     }
[10:25:51.119]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.119]                     base::options(mc.cores = 1L)
[10:25:51.119]                   }
[10:25:51.119]                   options(future.plan = NULL)
[10:25:51.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.119]                 }
[10:25:51.119]                 ...future.workdir <- getwd()
[10:25:51.119]             }
[10:25:51.119]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.119]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.119]         }
[10:25:51.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.119]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.119]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.119]             base::names(...future.oldOptions))
[10:25:51.119]     }
[10:25:51.119]     if (FALSE) {
[10:25:51.119]     }
[10:25:51.119]     else {
[10:25:51.119]         if (TRUE) {
[10:25:51.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.119]                 open = "w")
[10:25:51.119]         }
[10:25:51.119]         else {
[10:25:51.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.119]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.119]         }
[10:25:51.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.119]             base::sink(type = "output", split = FALSE)
[10:25:51.119]             base::close(...future.stdout)
[10:25:51.119]         }, add = TRUE)
[10:25:51.119]     }
[10:25:51.119]     ...future.frame <- base::sys.nframe()
[10:25:51.119]     ...future.conditions <- base::list()
[10:25:51.119]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.119]     if (FALSE) {
[10:25:51.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.119]     }
[10:25:51.119]     ...future.result <- base::tryCatch({
[10:25:51.119]         base::withCallingHandlers({
[10:25:51.119]             ...future.value <- base::withVisible(base::local({
[10:25:51.119]                 ...future.makeSendCondition <- base::local({
[10:25:51.119]                   sendCondition <- NULL
[10:25:51.119]                   function(frame = 1L) {
[10:25:51.119]                     if (is.function(sendCondition)) 
[10:25:51.119]                       return(sendCondition)
[10:25:51.119]                     ns <- getNamespace("parallel")
[10:25:51.119]                     if (exists("sendData", mode = "function", 
[10:25:51.119]                       envir = ns)) {
[10:25:51.119]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.119]                         envir = ns)
[10:25:51.119]                       envir <- sys.frame(frame)
[10:25:51.119]                       master <- NULL
[10:25:51.119]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.119]                         !identical(envir, emptyenv())) {
[10:25:51.119]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.119]                           inherits = FALSE)) {
[10:25:51.119]                           master <- get("master", mode = "list", 
[10:25:51.119]                             envir = envir, inherits = FALSE)
[10:25:51.119]                           if (inherits(master, c("SOCKnode", 
[10:25:51.119]                             "SOCK0node"))) {
[10:25:51.119]                             sendCondition <<- function(cond) {
[10:25:51.119]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.119]                                 success = TRUE)
[10:25:51.119]                               parallel_sendData(master, data)
[10:25:51.119]                             }
[10:25:51.119]                             return(sendCondition)
[10:25:51.119]                           }
[10:25:51.119]                         }
[10:25:51.119]                         frame <- frame + 1L
[10:25:51.119]                         envir <- sys.frame(frame)
[10:25:51.119]                       }
[10:25:51.119]                     }
[10:25:51.119]                     sendCondition <<- function(cond) NULL
[10:25:51.119]                   }
[10:25:51.119]                 })
[10:25:51.119]                 withCallingHandlers({
[10:25:51.119]                   2
[10:25:51.119]                 }, immediateCondition = function(cond) {
[10:25:51.119]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.119]                   sendCondition(cond)
[10:25:51.119]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.119]                   {
[10:25:51.119]                     inherits <- base::inherits
[10:25:51.119]                     invokeRestart <- base::invokeRestart
[10:25:51.119]                     is.null <- base::is.null
[10:25:51.119]                     muffled <- FALSE
[10:25:51.119]                     if (inherits(cond, "message")) {
[10:25:51.119]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.119]                       if (muffled) 
[10:25:51.119]                         invokeRestart("muffleMessage")
[10:25:51.119]                     }
[10:25:51.119]                     else if (inherits(cond, "warning")) {
[10:25:51.119]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.119]                       if (muffled) 
[10:25:51.119]                         invokeRestart("muffleWarning")
[10:25:51.119]                     }
[10:25:51.119]                     else if (inherits(cond, "condition")) {
[10:25:51.119]                       if (!is.null(pattern)) {
[10:25:51.119]                         computeRestarts <- base::computeRestarts
[10:25:51.119]                         grepl <- base::grepl
[10:25:51.119]                         restarts <- computeRestarts(cond)
[10:25:51.119]                         for (restart in restarts) {
[10:25:51.119]                           name <- restart$name
[10:25:51.119]                           if (is.null(name)) 
[10:25:51.119]                             next
[10:25:51.119]                           if (!grepl(pattern, name)) 
[10:25:51.119]                             next
[10:25:51.119]                           invokeRestart(restart)
[10:25:51.119]                           muffled <- TRUE
[10:25:51.119]                           break
[10:25:51.119]                         }
[10:25:51.119]                       }
[10:25:51.119]                     }
[10:25:51.119]                     invisible(muffled)
[10:25:51.119]                   }
[10:25:51.119]                   muffleCondition(cond)
[10:25:51.119]                 })
[10:25:51.119]             }))
[10:25:51.119]             future::FutureResult(value = ...future.value$value, 
[10:25:51.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.119]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.119]                     ...future.globalenv.names))
[10:25:51.119]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.119]         }, condition = base::local({
[10:25:51.119]             c <- base::c
[10:25:51.119]             inherits <- base::inherits
[10:25:51.119]             invokeRestart <- base::invokeRestart
[10:25:51.119]             length <- base::length
[10:25:51.119]             list <- base::list
[10:25:51.119]             seq.int <- base::seq.int
[10:25:51.119]             signalCondition <- base::signalCondition
[10:25:51.119]             sys.calls <- base::sys.calls
[10:25:51.119]             `[[` <- base::`[[`
[10:25:51.119]             `+` <- base::`+`
[10:25:51.119]             `<<-` <- base::`<<-`
[10:25:51.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.119]                   3L)]
[10:25:51.119]             }
[10:25:51.119]             function(cond) {
[10:25:51.119]                 is_error <- inherits(cond, "error")
[10:25:51.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.119]                   NULL)
[10:25:51.119]                 if (is_error) {
[10:25:51.119]                   sessionInformation <- function() {
[10:25:51.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.119]                       search = base::search(), system = base::Sys.info())
[10:25:51.119]                   }
[10:25:51.119]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.119]                     cond$call), session = sessionInformation(), 
[10:25:51.119]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.119]                   signalCondition(cond)
[10:25:51.119]                 }
[10:25:51.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.119]                 "immediateCondition"))) {
[10:25:51.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.119]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.119]                   if (TRUE && !signal) {
[10:25:51.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.119]                     {
[10:25:51.119]                       inherits <- base::inherits
[10:25:51.119]                       invokeRestart <- base::invokeRestart
[10:25:51.119]                       is.null <- base::is.null
[10:25:51.119]                       muffled <- FALSE
[10:25:51.119]                       if (inherits(cond, "message")) {
[10:25:51.119]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.119]                         if (muffled) 
[10:25:51.119]                           invokeRestart("muffleMessage")
[10:25:51.119]                       }
[10:25:51.119]                       else if (inherits(cond, "warning")) {
[10:25:51.119]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.119]                         if (muffled) 
[10:25:51.119]                           invokeRestart("muffleWarning")
[10:25:51.119]                       }
[10:25:51.119]                       else if (inherits(cond, "condition")) {
[10:25:51.119]                         if (!is.null(pattern)) {
[10:25:51.119]                           computeRestarts <- base::computeRestarts
[10:25:51.119]                           grepl <- base::grepl
[10:25:51.119]                           restarts <- computeRestarts(cond)
[10:25:51.119]                           for (restart in restarts) {
[10:25:51.119]                             name <- restart$name
[10:25:51.119]                             if (is.null(name)) 
[10:25:51.119]                               next
[10:25:51.119]                             if (!grepl(pattern, name)) 
[10:25:51.119]                               next
[10:25:51.119]                             invokeRestart(restart)
[10:25:51.119]                             muffled <- TRUE
[10:25:51.119]                             break
[10:25:51.119]                           }
[10:25:51.119]                         }
[10:25:51.119]                       }
[10:25:51.119]                       invisible(muffled)
[10:25:51.119]                     }
[10:25:51.119]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.119]                   }
[10:25:51.119]                 }
[10:25:51.119]                 else {
[10:25:51.119]                   if (TRUE) {
[10:25:51.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.119]                     {
[10:25:51.119]                       inherits <- base::inherits
[10:25:51.119]                       invokeRestart <- base::invokeRestart
[10:25:51.119]                       is.null <- base::is.null
[10:25:51.119]                       muffled <- FALSE
[10:25:51.119]                       if (inherits(cond, "message")) {
[10:25:51.119]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.119]                         if (muffled) 
[10:25:51.119]                           invokeRestart("muffleMessage")
[10:25:51.119]                       }
[10:25:51.119]                       else if (inherits(cond, "warning")) {
[10:25:51.119]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.119]                         if (muffled) 
[10:25:51.119]                           invokeRestart("muffleWarning")
[10:25:51.119]                       }
[10:25:51.119]                       else if (inherits(cond, "condition")) {
[10:25:51.119]                         if (!is.null(pattern)) {
[10:25:51.119]                           computeRestarts <- base::computeRestarts
[10:25:51.119]                           grepl <- base::grepl
[10:25:51.119]                           restarts <- computeRestarts(cond)
[10:25:51.119]                           for (restart in restarts) {
[10:25:51.119]                             name <- restart$name
[10:25:51.119]                             if (is.null(name)) 
[10:25:51.119]                               next
[10:25:51.119]                             if (!grepl(pattern, name)) 
[10:25:51.119]                               next
[10:25:51.119]                             invokeRestart(restart)
[10:25:51.119]                             muffled <- TRUE
[10:25:51.119]                             break
[10:25:51.119]                           }
[10:25:51.119]                         }
[10:25:51.119]                       }
[10:25:51.119]                       invisible(muffled)
[10:25:51.119]                     }
[10:25:51.119]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.119]                   }
[10:25:51.119]                 }
[10:25:51.119]             }
[10:25:51.119]         }))
[10:25:51.119]     }, error = function(ex) {
[10:25:51.119]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.119]                 ...future.rng), started = ...future.startTime, 
[10:25:51.119]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.119]             version = "1.8"), class = "FutureResult")
[10:25:51.119]     }, finally = {
[10:25:51.119]         if (!identical(...future.workdir, getwd())) 
[10:25:51.119]             setwd(...future.workdir)
[10:25:51.119]         {
[10:25:51.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.119]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.119]             }
[10:25:51.119]             base::options(...future.oldOptions)
[10:25:51.119]             if (.Platform$OS.type == "windows") {
[10:25:51.119]                 old_names <- names(...future.oldEnvVars)
[10:25:51.119]                 envs <- base::Sys.getenv()
[10:25:51.119]                 names <- names(envs)
[10:25:51.119]                 common <- intersect(names, old_names)
[10:25:51.119]                 added <- setdiff(names, old_names)
[10:25:51.119]                 removed <- setdiff(old_names, names)
[10:25:51.119]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.119]                   envs[common]]
[10:25:51.119]                 NAMES <- toupper(changed)
[10:25:51.119]                 args <- list()
[10:25:51.119]                 for (kk in seq_along(NAMES)) {
[10:25:51.119]                   name <- changed[[kk]]
[10:25:51.119]                   NAME <- NAMES[[kk]]
[10:25:51.119]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.119]                     next
[10:25:51.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.119]                 }
[10:25:51.119]                 NAMES <- toupper(added)
[10:25:51.119]                 for (kk in seq_along(NAMES)) {
[10:25:51.119]                   name <- added[[kk]]
[10:25:51.119]                   NAME <- NAMES[[kk]]
[10:25:51.119]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.119]                     next
[10:25:51.119]                   args[[name]] <- ""
[10:25:51.119]                 }
[10:25:51.119]                 NAMES <- toupper(removed)
[10:25:51.119]                 for (kk in seq_along(NAMES)) {
[10:25:51.119]                   name <- removed[[kk]]
[10:25:51.119]                   NAME <- NAMES[[kk]]
[10:25:51.119]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.119]                     next
[10:25:51.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.119]                 }
[10:25:51.119]                 if (length(args) > 0) 
[10:25:51.119]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.119]             }
[10:25:51.119]             else {
[10:25:51.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.119]             }
[10:25:51.119]             {
[10:25:51.119]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.119]                   0L) {
[10:25:51.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.119]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.119]                   base::options(opts)
[10:25:51.119]                 }
[10:25:51.119]                 {
[10:25:51.119]                   {
[10:25:51.119]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.119]                     NULL
[10:25:51.119]                   }
[10:25:51.119]                   options(future.plan = NULL)
[10:25:51.119]                   if (is.na(NA_character_)) 
[10:25:51.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.119]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.119]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.119]                     envir = parent.frame()) 
[10:25:51.119]                   {
[10:25:51.119]                     if (is.function(workers)) 
[10:25:51.119]                       workers <- workers()
[10:25:51.119]                     workers <- structure(as.integer(workers), 
[10:25:51.119]                       class = class(workers))
[10:25:51.119]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.119]                       workers >= 1)
[10:25:51.119]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.119]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.119]                     }
[10:25:51.119]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.119]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.119]                       envir = envir)
[10:25:51.119]                     if (!future$lazy) 
[10:25:51.119]                       future <- run(future)
[10:25:51.119]                     invisible(future)
[10:25:51.119]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.119]                 }
[10:25:51.119]             }
[10:25:51.119]         }
[10:25:51.119]     })
[10:25:51.119]     if (TRUE) {
[10:25:51.119]         base::sink(type = "output", split = FALSE)
[10:25:51.119]         if (TRUE) {
[10:25:51.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.119]         }
[10:25:51.119]         else {
[10:25:51.119]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.119]         }
[10:25:51.119]         base::close(...future.stdout)
[10:25:51.119]         ...future.stdout <- NULL
[10:25:51.119]     }
[10:25:51.119]     ...future.result$conditions <- ...future.conditions
[10:25:51.119]     ...future.result$finished <- base::Sys.time()
[10:25:51.119]     ...future.result
[10:25:51.119] }
[10:25:51.122] MultisessionFuture started
[10:25:51.122] - Launch lazy future ... done
[10:25:51.122] run() for ‘MultisessionFuture’ ... done
[10:25:51.122] getGlobalsAndPackages() ...
[10:25:51.123] Searching for globals...
[10:25:51.123] 
[10:25:51.123] Searching for globals ... DONE
[10:25:51.123] - globals: [0] <none>
[10:25:51.123] getGlobalsAndPackages() ... DONE
[10:25:51.123] run() for ‘Future’ ...
[10:25:51.123] - state: ‘created’
[10:25:51.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.137] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.138]   - Field: ‘node’
[10:25:51.138]   - Field: ‘label’
[10:25:51.138]   - Field: ‘local’
[10:25:51.138]   - Field: ‘owner’
[10:25:51.138]   - Field: ‘envir’
[10:25:51.138]   - Field: ‘workers’
[10:25:51.138]   - Field: ‘packages’
[10:25:51.138]   - Field: ‘gc’
[10:25:51.138]   - Field: ‘conditions’
[10:25:51.139]   - Field: ‘persistent’
[10:25:51.139]   - Field: ‘expr’
[10:25:51.139]   - Field: ‘uuid’
[10:25:51.139]   - Field: ‘seed’
[10:25:51.142]   - Field: ‘version’
[10:25:51.142]   - Field: ‘result’
[10:25:51.142]   - Field: ‘asynchronous’
[10:25:51.142]   - Field: ‘calls’
[10:25:51.142]   - Field: ‘globals’
[10:25:51.142]   - Field: ‘stdout’
[10:25:51.142]   - Field: ‘earlySignal’
[10:25:51.143]   - Field: ‘lazy’
[10:25:51.143]   - Field: ‘state’
[10:25:51.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.143] - Launch lazy future ...
[10:25:51.143] Packages needed by the future expression (n = 0): <none>
[10:25:51.143] Packages needed by future strategies (n = 0): <none>
[10:25:51.144] {
[10:25:51.144]     {
[10:25:51.144]         {
[10:25:51.144]             ...future.startTime <- base::Sys.time()
[10:25:51.144]             {
[10:25:51.144]                 {
[10:25:51.144]                   {
[10:25:51.144]                     {
[10:25:51.144]                       base::local({
[10:25:51.144]                         has_future <- base::requireNamespace("future", 
[10:25:51.144]                           quietly = TRUE)
[10:25:51.144]                         if (has_future) {
[10:25:51.144]                           ns <- base::getNamespace("future")
[10:25:51.144]                           version <- ns[[".package"]][["version"]]
[10:25:51.144]                           if (is.null(version)) 
[10:25:51.144]                             version <- utils::packageVersion("future")
[10:25:51.144]                         }
[10:25:51.144]                         else {
[10:25:51.144]                           version <- NULL
[10:25:51.144]                         }
[10:25:51.144]                         if (!has_future || version < "1.8.0") {
[10:25:51.144]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.144]                             "", base::R.version$version.string), 
[10:25:51.144]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.144]                               "release", "version")], collapse = " "), 
[10:25:51.144]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.144]                             info)
[10:25:51.144]                           info <- base::paste(info, collapse = "; ")
[10:25:51.144]                           if (!has_future) {
[10:25:51.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.144]                               info)
[10:25:51.144]                           }
[10:25:51.144]                           else {
[10:25:51.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.144]                               info, version)
[10:25:51.144]                           }
[10:25:51.144]                           base::stop(msg)
[10:25:51.144]                         }
[10:25:51.144]                       })
[10:25:51.144]                     }
[10:25:51.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.144]                     base::options(mc.cores = 1L)
[10:25:51.144]                   }
[10:25:51.144]                   options(future.plan = NULL)
[10:25:51.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.144]                 }
[10:25:51.144]                 ...future.workdir <- getwd()
[10:25:51.144]             }
[10:25:51.144]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.144]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.144]         }
[10:25:51.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.144]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.144]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.144]             base::names(...future.oldOptions))
[10:25:51.144]     }
[10:25:51.144]     if (FALSE) {
[10:25:51.144]     }
[10:25:51.144]     else {
[10:25:51.144]         if (TRUE) {
[10:25:51.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.144]                 open = "w")
[10:25:51.144]         }
[10:25:51.144]         else {
[10:25:51.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.144]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.144]         }
[10:25:51.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.144]             base::sink(type = "output", split = FALSE)
[10:25:51.144]             base::close(...future.stdout)
[10:25:51.144]         }, add = TRUE)
[10:25:51.144]     }
[10:25:51.144]     ...future.frame <- base::sys.nframe()
[10:25:51.144]     ...future.conditions <- base::list()
[10:25:51.144]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.144]     if (FALSE) {
[10:25:51.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.144]     }
[10:25:51.144]     ...future.result <- base::tryCatch({
[10:25:51.144]         base::withCallingHandlers({
[10:25:51.144]             ...future.value <- base::withVisible(base::local({
[10:25:51.144]                 ...future.makeSendCondition <- base::local({
[10:25:51.144]                   sendCondition <- NULL
[10:25:51.144]                   function(frame = 1L) {
[10:25:51.144]                     if (is.function(sendCondition)) 
[10:25:51.144]                       return(sendCondition)
[10:25:51.144]                     ns <- getNamespace("parallel")
[10:25:51.144]                     if (exists("sendData", mode = "function", 
[10:25:51.144]                       envir = ns)) {
[10:25:51.144]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.144]                         envir = ns)
[10:25:51.144]                       envir <- sys.frame(frame)
[10:25:51.144]                       master <- NULL
[10:25:51.144]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.144]                         !identical(envir, emptyenv())) {
[10:25:51.144]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.144]                           inherits = FALSE)) {
[10:25:51.144]                           master <- get("master", mode = "list", 
[10:25:51.144]                             envir = envir, inherits = FALSE)
[10:25:51.144]                           if (inherits(master, c("SOCKnode", 
[10:25:51.144]                             "SOCK0node"))) {
[10:25:51.144]                             sendCondition <<- function(cond) {
[10:25:51.144]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.144]                                 success = TRUE)
[10:25:51.144]                               parallel_sendData(master, data)
[10:25:51.144]                             }
[10:25:51.144]                             return(sendCondition)
[10:25:51.144]                           }
[10:25:51.144]                         }
[10:25:51.144]                         frame <- frame + 1L
[10:25:51.144]                         envir <- sys.frame(frame)
[10:25:51.144]                       }
[10:25:51.144]                     }
[10:25:51.144]                     sendCondition <<- function(cond) NULL
[10:25:51.144]                   }
[10:25:51.144]                 })
[10:25:51.144]                 withCallingHandlers({
[10:25:51.144]                   NULL
[10:25:51.144]                 }, immediateCondition = function(cond) {
[10:25:51.144]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.144]                   sendCondition(cond)
[10:25:51.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.144]                   {
[10:25:51.144]                     inherits <- base::inherits
[10:25:51.144]                     invokeRestart <- base::invokeRestart
[10:25:51.144]                     is.null <- base::is.null
[10:25:51.144]                     muffled <- FALSE
[10:25:51.144]                     if (inherits(cond, "message")) {
[10:25:51.144]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.144]                       if (muffled) 
[10:25:51.144]                         invokeRestart("muffleMessage")
[10:25:51.144]                     }
[10:25:51.144]                     else if (inherits(cond, "warning")) {
[10:25:51.144]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.144]                       if (muffled) 
[10:25:51.144]                         invokeRestart("muffleWarning")
[10:25:51.144]                     }
[10:25:51.144]                     else if (inherits(cond, "condition")) {
[10:25:51.144]                       if (!is.null(pattern)) {
[10:25:51.144]                         computeRestarts <- base::computeRestarts
[10:25:51.144]                         grepl <- base::grepl
[10:25:51.144]                         restarts <- computeRestarts(cond)
[10:25:51.144]                         for (restart in restarts) {
[10:25:51.144]                           name <- restart$name
[10:25:51.144]                           if (is.null(name)) 
[10:25:51.144]                             next
[10:25:51.144]                           if (!grepl(pattern, name)) 
[10:25:51.144]                             next
[10:25:51.144]                           invokeRestart(restart)
[10:25:51.144]                           muffled <- TRUE
[10:25:51.144]                           break
[10:25:51.144]                         }
[10:25:51.144]                       }
[10:25:51.144]                     }
[10:25:51.144]                     invisible(muffled)
[10:25:51.144]                   }
[10:25:51.144]                   muffleCondition(cond)
[10:25:51.144]                 })
[10:25:51.144]             }))
[10:25:51.144]             future::FutureResult(value = ...future.value$value, 
[10:25:51.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.144]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.144]                     ...future.globalenv.names))
[10:25:51.144]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.144]         }, condition = base::local({
[10:25:51.144]             c <- base::c
[10:25:51.144]             inherits <- base::inherits
[10:25:51.144]             invokeRestart <- base::invokeRestart
[10:25:51.144]             length <- base::length
[10:25:51.144]             list <- base::list
[10:25:51.144]             seq.int <- base::seq.int
[10:25:51.144]             signalCondition <- base::signalCondition
[10:25:51.144]             sys.calls <- base::sys.calls
[10:25:51.144]             `[[` <- base::`[[`
[10:25:51.144]             `+` <- base::`+`
[10:25:51.144]             `<<-` <- base::`<<-`
[10:25:51.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.144]                   3L)]
[10:25:51.144]             }
[10:25:51.144]             function(cond) {
[10:25:51.144]                 is_error <- inherits(cond, "error")
[10:25:51.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.144]                   NULL)
[10:25:51.144]                 if (is_error) {
[10:25:51.144]                   sessionInformation <- function() {
[10:25:51.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.144]                       search = base::search(), system = base::Sys.info())
[10:25:51.144]                   }
[10:25:51.144]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.144]                     cond$call), session = sessionInformation(), 
[10:25:51.144]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.144]                   signalCondition(cond)
[10:25:51.144]                 }
[10:25:51.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.144]                 "immediateCondition"))) {
[10:25:51.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.144]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.144]                   if (TRUE && !signal) {
[10:25:51.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.144]                     {
[10:25:51.144]                       inherits <- base::inherits
[10:25:51.144]                       invokeRestart <- base::invokeRestart
[10:25:51.144]                       is.null <- base::is.null
[10:25:51.144]                       muffled <- FALSE
[10:25:51.144]                       if (inherits(cond, "message")) {
[10:25:51.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.144]                         if (muffled) 
[10:25:51.144]                           invokeRestart("muffleMessage")
[10:25:51.144]                       }
[10:25:51.144]                       else if (inherits(cond, "warning")) {
[10:25:51.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.144]                         if (muffled) 
[10:25:51.144]                           invokeRestart("muffleWarning")
[10:25:51.144]                       }
[10:25:51.144]                       else if (inherits(cond, "condition")) {
[10:25:51.144]                         if (!is.null(pattern)) {
[10:25:51.144]                           computeRestarts <- base::computeRestarts
[10:25:51.144]                           grepl <- base::grepl
[10:25:51.144]                           restarts <- computeRestarts(cond)
[10:25:51.144]                           for (restart in restarts) {
[10:25:51.144]                             name <- restart$name
[10:25:51.144]                             if (is.null(name)) 
[10:25:51.144]                               next
[10:25:51.144]                             if (!grepl(pattern, name)) 
[10:25:51.144]                               next
[10:25:51.144]                             invokeRestart(restart)
[10:25:51.144]                             muffled <- TRUE
[10:25:51.144]                             break
[10:25:51.144]                           }
[10:25:51.144]                         }
[10:25:51.144]                       }
[10:25:51.144]                       invisible(muffled)
[10:25:51.144]                     }
[10:25:51.144]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.144]                   }
[10:25:51.144]                 }
[10:25:51.144]                 else {
[10:25:51.144]                   if (TRUE) {
[10:25:51.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.144]                     {
[10:25:51.144]                       inherits <- base::inherits
[10:25:51.144]                       invokeRestart <- base::invokeRestart
[10:25:51.144]                       is.null <- base::is.null
[10:25:51.144]                       muffled <- FALSE
[10:25:51.144]                       if (inherits(cond, "message")) {
[10:25:51.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.144]                         if (muffled) 
[10:25:51.144]                           invokeRestart("muffleMessage")
[10:25:51.144]                       }
[10:25:51.144]                       else if (inherits(cond, "warning")) {
[10:25:51.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.144]                         if (muffled) 
[10:25:51.144]                           invokeRestart("muffleWarning")
[10:25:51.144]                       }
[10:25:51.144]                       else if (inherits(cond, "condition")) {
[10:25:51.144]                         if (!is.null(pattern)) {
[10:25:51.144]                           computeRestarts <- base::computeRestarts
[10:25:51.144]                           grepl <- base::grepl
[10:25:51.144]                           restarts <- computeRestarts(cond)
[10:25:51.144]                           for (restart in restarts) {
[10:25:51.144]                             name <- restart$name
[10:25:51.144]                             if (is.null(name)) 
[10:25:51.144]                               next
[10:25:51.144]                             if (!grepl(pattern, name)) 
[10:25:51.144]                               next
[10:25:51.144]                             invokeRestart(restart)
[10:25:51.144]                             muffled <- TRUE
[10:25:51.144]                             break
[10:25:51.144]                           }
[10:25:51.144]                         }
[10:25:51.144]                       }
[10:25:51.144]                       invisible(muffled)
[10:25:51.144]                     }
[10:25:51.144]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.144]                   }
[10:25:51.144]                 }
[10:25:51.144]             }
[10:25:51.144]         }))
[10:25:51.144]     }, error = function(ex) {
[10:25:51.144]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.144]                 ...future.rng), started = ...future.startTime, 
[10:25:51.144]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.144]             version = "1.8"), class = "FutureResult")
[10:25:51.144]     }, finally = {
[10:25:51.144]         if (!identical(...future.workdir, getwd())) 
[10:25:51.144]             setwd(...future.workdir)
[10:25:51.144]         {
[10:25:51.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.144]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.144]             }
[10:25:51.144]             base::options(...future.oldOptions)
[10:25:51.144]             if (.Platform$OS.type == "windows") {
[10:25:51.144]                 old_names <- names(...future.oldEnvVars)
[10:25:51.144]                 envs <- base::Sys.getenv()
[10:25:51.144]                 names <- names(envs)
[10:25:51.144]                 common <- intersect(names, old_names)
[10:25:51.144]                 added <- setdiff(names, old_names)
[10:25:51.144]                 removed <- setdiff(old_names, names)
[10:25:51.144]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.144]                   envs[common]]
[10:25:51.144]                 NAMES <- toupper(changed)
[10:25:51.144]                 args <- list()
[10:25:51.144]                 for (kk in seq_along(NAMES)) {
[10:25:51.144]                   name <- changed[[kk]]
[10:25:51.144]                   NAME <- NAMES[[kk]]
[10:25:51.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.144]                     next
[10:25:51.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.144]                 }
[10:25:51.144]                 NAMES <- toupper(added)
[10:25:51.144]                 for (kk in seq_along(NAMES)) {
[10:25:51.144]                   name <- added[[kk]]
[10:25:51.144]                   NAME <- NAMES[[kk]]
[10:25:51.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.144]                     next
[10:25:51.144]                   args[[name]] <- ""
[10:25:51.144]                 }
[10:25:51.144]                 NAMES <- toupper(removed)
[10:25:51.144]                 for (kk in seq_along(NAMES)) {
[10:25:51.144]                   name <- removed[[kk]]
[10:25:51.144]                   NAME <- NAMES[[kk]]
[10:25:51.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.144]                     next
[10:25:51.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.144]                 }
[10:25:51.144]                 if (length(args) > 0) 
[10:25:51.144]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.144]             }
[10:25:51.144]             else {
[10:25:51.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.144]             }
[10:25:51.144]             {
[10:25:51.144]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.144]                   0L) {
[10:25:51.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.144]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.144]                   base::options(opts)
[10:25:51.144]                 }
[10:25:51.144]                 {
[10:25:51.144]                   {
[10:25:51.144]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.144]                     NULL
[10:25:51.144]                   }
[10:25:51.144]                   options(future.plan = NULL)
[10:25:51.144]                   if (is.na(NA_character_)) 
[10:25:51.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.144]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.144]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.144]                     envir = parent.frame()) 
[10:25:51.144]                   {
[10:25:51.144]                     if (is.function(workers)) 
[10:25:51.144]                       workers <- workers()
[10:25:51.144]                     workers <- structure(as.integer(workers), 
[10:25:51.144]                       class = class(workers))
[10:25:51.144]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.144]                       workers >= 1)
[10:25:51.144]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.144]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.144]                     }
[10:25:51.144]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.144]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.144]                       envir = envir)
[10:25:51.144]                     if (!future$lazy) 
[10:25:51.144]                       future <- run(future)
[10:25:51.144]                     invisible(future)
[10:25:51.144]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.144]                 }
[10:25:51.144]             }
[10:25:51.144]         }
[10:25:51.144]     })
[10:25:51.144]     if (TRUE) {
[10:25:51.144]         base::sink(type = "output", split = FALSE)
[10:25:51.144]         if (TRUE) {
[10:25:51.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.144]         }
[10:25:51.144]         else {
[10:25:51.144]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.144]         }
[10:25:51.144]         base::close(...future.stdout)
[10:25:51.144]         ...future.stdout <- NULL
[10:25:51.144]     }
[10:25:51.144]     ...future.result$conditions <- ...future.conditions
[10:25:51.144]     ...future.result$finished <- base::Sys.time()
[10:25:51.144]     ...future.result
[10:25:51.144] }
[10:25:51.147] MultisessionFuture started
[10:25:51.147] - Launch lazy future ... done
[10:25:51.147] run() for ‘MultisessionFuture’ ... done
[10:25:51.148] getGlobalsAndPackages() ...
[10:25:51.148] Searching for globals...
[10:25:51.148] - globals found: [1] ‘{’
[10:25:51.148] Searching for globals ... DONE
[10:25:51.148] Resolving globals: FALSE
[10:25:51.149] 
[10:25:51.149] 
[10:25:51.149] getGlobalsAndPackages() ... DONE
[10:25:51.149] run() for ‘Future’ ...
[10:25:51.149] - state: ‘created’
[10:25:51.149] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.163] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.163]   - Field: ‘node’
[10:25:51.163]   - Field: ‘label’
[10:25:51.163]   - Field: ‘local’
[10:25:51.164]   - Field: ‘owner’
[10:25:51.164]   - Field: ‘envir’
[10:25:51.164]   - Field: ‘workers’
[10:25:51.164]   - Field: ‘packages’
[10:25:51.164]   - Field: ‘gc’
[10:25:51.164]   - Field: ‘conditions’
[10:25:51.164]   - Field: ‘persistent’
[10:25:51.164]   - Field: ‘expr’
[10:25:51.164]   - Field: ‘uuid’
[10:25:51.164]   - Field: ‘seed’
[10:25:51.164]   - Field: ‘version’
[10:25:51.165]   - Field: ‘result’
[10:25:51.165]   - Field: ‘asynchronous’
[10:25:51.165]   - Field: ‘calls’
[10:25:51.165]   - Field: ‘globals’
[10:25:51.165]   - Field: ‘stdout’
[10:25:51.165]   - Field: ‘earlySignal’
[10:25:51.165]   - Field: ‘lazy’
[10:25:51.165]   - Field: ‘state’
[10:25:51.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.165] - Launch lazy future ...
[10:25:51.166] Packages needed by the future expression (n = 0): <none>
[10:25:51.166] Packages needed by future strategies (n = 0): <none>
[10:25:51.166] {
[10:25:51.166]     {
[10:25:51.166]         {
[10:25:51.166]             ...future.startTime <- base::Sys.time()
[10:25:51.166]             {
[10:25:51.166]                 {
[10:25:51.166]                   {
[10:25:51.166]                     {
[10:25:51.166]                       base::local({
[10:25:51.166]                         has_future <- base::requireNamespace("future", 
[10:25:51.166]                           quietly = TRUE)
[10:25:51.166]                         if (has_future) {
[10:25:51.166]                           ns <- base::getNamespace("future")
[10:25:51.166]                           version <- ns[[".package"]][["version"]]
[10:25:51.166]                           if (is.null(version)) 
[10:25:51.166]                             version <- utils::packageVersion("future")
[10:25:51.166]                         }
[10:25:51.166]                         else {
[10:25:51.166]                           version <- NULL
[10:25:51.166]                         }
[10:25:51.166]                         if (!has_future || version < "1.8.0") {
[10:25:51.166]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.166]                             "", base::R.version$version.string), 
[10:25:51.166]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.166]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.166]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.166]                               "release", "version")], collapse = " "), 
[10:25:51.166]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.166]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.166]                             info)
[10:25:51.166]                           info <- base::paste(info, collapse = "; ")
[10:25:51.166]                           if (!has_future) {
[10:25:51.166]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.166]                               info)
[10:25:51.166]                           }
[10:25:51.166]                           else {
[10:25:51.166]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.166]                               info, version)
[10:25:51.166]                           }
[10:25:51.166]                           base::stop(msg)
[10:25:51.166]                         }
[10:25:51.166]                       })
[10:25:51.166]                     }
[10:25:51.166]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.166]                     base::options(mc.cores = 1L)
[10:25:51.166]                   }
[10:25:51.166]                   options(future.plan = NULL)
[10:25:51.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.166]                 }
[10:25:51.166]                 ...future.workdir <- getwd()
[10:25:51.166]             }
[10:25:51.166]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.166]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.166]         }
[10:25:51.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.166]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.166]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.166]             base::names(...future.oldOptions))
[10:25:51.166]     }
[10:25:51.166]     if (FALSE) {
[10:25:51.166]     }
[10:25:51.166]     else {
[10:25:51.166]         if (TRUE) {
[10:25:51.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.166]                 open = "w")
[10:25:51.166]         }
[10:25:51.166]         else {
[10:25:51.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.166]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.166]         }
[10:25:51.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.166]             base::sink(type = "output", split = FALSE)
[10:25:51.166]             base::close(...future.stdout)
[10:25:51.166]         }, add = TRUE)
[10:25:51.166]     }
[10:25:51.166]     ...future.frame <- base::sys.nframe()
[10:25:51.166]     ...future.conditions <- base::list()
[10:25:51.166]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.166]     if (FALSE) {
[10:25:51.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.166]     }
[10:25:51.166]     ...future.result <- base::tryCatch({
[10:25:51.166]         base::withCallingHandlers({
[10:25:51.166]             ...future.value <- base::withVisible(base::local({
[10:25:51.166]                 ...future.makeSendCondition <- base::local({
[10:25:51.166]                   sendCondition <- NULL
[10:25:51.166]                   function(frame = 1L) {
[10:25:51.166]                     if (is.function(sendCondition)) 
[10:25:51.166]                       return(sendCondition)
[10:25:51.166]                     ns <- getNamespace("parallel")
[10:25:51.166]                     if (exists("sendData", mode = "function", 
[10:25:51.166]                       envir = ns)) {
[10:25:51.166]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.166]                         envir = ns)
[10:25:51.166]                       envir <- sys.frame(frame)
[10:25:51.166]                       master <- NULL
[10:25:51.166]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.166]                         !identical(envir, emptyenv())) {
[10:25:51.166]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.166]                           inherits = FALSE)) {
[10:25:51.166]                           master <- get("master", mode = "list", 
[10:25:51.166]                             envir = envir, inherits = FALSE)
[10:25:51.166]                           if (inherits(master, c("SOCKnode", 
[10:25:51.166]                             "SOCK0node"))) {
[10:25:51.166]                             sendCondition <<- function(cond) {
[10:25:51.166]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.166]                                 success = TRUE)
[10:25:51.166]                               parallel_sendData(master, data)
[10:25:51.166]                             }
[10:25:51.166]                             return(sendCondition)
[10:25:51.166]                           }
[10:25:51.166]                         }
[10:25:51.166]                         frame <- frame + 1L
[10:25:51.166]                         envir <- sys.frame(frame)
[10:25:51.166]                       }
[10:25:51.166]                     }
[10:25:51.166]                     sendCondition <<- function(cond) NULL
[10:25:51.166]                   }
[10:25:51.166]                 })
[10:25:51.166]                 withCallingHandlers({
[10:25:51.166]                   {
[10:25:51.166]                     4
[10:25:51.166]                   }
[10:25:51.166]                 }, immediateCondition = function(cond) {
[10:25:51.166]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.166]                   sendCondition(cond)
[10:25:51.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.166]                   {
[10:25:51.166]                     inherits <- base::inherits
[10:25:51.166]                     invokeRestart <- base::invokeRestart
[10:25:51.166]                     is.null <- base::is.null
[10:25:51.166]                     muffled <- FALSE
[10:25:51.166]                     if (inherits(cond, "message")) {
[10:25:51.166]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.166]                       if (muffled) 
[10:25:51.166]                         invokeRestart("muffleMessage")
[10:25:51.166]                     }
[10:25:51.166]                     else if (inherits(cond, "warning")) {
[10:25:51.166]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.166]                       if (muffled) 
[10:25:51.166]                         invokeRestart("muffleWarning")
[10:25:51.166]                     }
[10:25:51.166]                     else if (inherits(cond, "condition")) {
[10:25:51.166]                       if (!is.null(pattern)) {
[10:25:51.166]                         computeRestarts <- base::computeRestarts
[10:25:51.166]                         grepl <- base::grepl
[10:25:51.166]                         restarts <- computeRestarts(cond)
[10:25:51.166]                         for (restart in restarts) {
[10:25:51.166]                           name <- restart$name
[10:25:51.166]                           if (is.null(name)) 
[10:25:51.166]                             next
[10:25:51.166]                           if (!grepl(pattern, name)) 
[10:25:51.166]                             next
[10:25:51.166]                           invokeRestart(restart)
[10:25:51.166]                           muffled <- TRUE
[10:25:51.166]                           break
[10:25:51.166]                         }
[10:25:51.166]                       }
[10:25:51.166]                     }
[10:25:51.166]                     invisible(muffled)
[10:25:51.166]                   }
[10:25:51.166]                   muffleCondition(cond)
[10:25:51.166]                 })
[10:25:51.166]             }))
[10:25:51.166]             future::FutureResult(value = ...future.value$value, 
[10:25:51.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.166]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.166]                     ...future.globalenv.names))
[10:25:51.166]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.166]         }, condition = base::local({
[10:25:51.166]             c <- base::c
[10:25:51.166]             inherits <- base::inherits
[10:25:51.166]             invokeRestart <- base::invokeRestart
[10:25:51.166]             length <- base::length
[10:25:51.166]             list <- base::list
[10:25:51.166]             seq.int <- base::seq.int
[10:25:51.166]             signalCondition <- base::signalCondition
[10:25:51.166]             sys.calls <- base::sys.calls
[10:25:51.166]             `[[` <- base::`[[`
[10:25:51.166]             `+` <- base::`+`
[10:25:51.166]             `<<-` <- base::`<<-`
[10:25:51.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.166]                   3L)]
[10:25:51.166]             }
[10:25:51.166]             function(cond) {
[10:25:51.166]                 is_error <- inherits(cond, "error")
[10:25:51.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.166]                   NULL)
[10:25:51.166]                 if (is_error) {
[10:25:51.166]                   sessionInformation <- function() {
[10:25:51.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.166]                       search = base::search(), system = base::Sys.info())
[10:25:51.166]                   }
[10:25:51.166]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.166]                     cond$call), session = sessionInformation(), 
[10:25:51.166]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.166]                   signalCondition(cond)
[10:25:51.166]                 }
[10:25:51.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.166]                 "immediateCondition"))) {
[10:25:51.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.166]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.166]                   if (TRUE && !signal) {
[10:25:51.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.166]                     {
[10:25:51.166]                       inherits <- base::inherits
[10:25:51.166]                       invokeRestart <- base::invokeRestart
[10:25:51.166]                       is.null <- base::is.null
[10:25:51.166]                       muffled <- FALSE
[10:25:51.166]                       if (inherits(cond, "message")) {
[10:25:51.166]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.166]                         if (muffled) 
[10:25:51.166]                           invokeRestart("muffleMessage")
[10:25:51.166]                       }
[10:25:51.166]                       else if (inherits(cond, "warning")) {
[10:25:51.166]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.166]                         if (muffled) 
[10:25:51.166]                           invokeRestart("muffleWarning")
[10:25:51.166]                       }
[10:25:51.166]                       else if (inherits(cond, "condition")) {
[10:25:51.166]                         if (!is.null(pattern)) {
[10:25:51.166]                           computeRestarts <- base::computeRestarts
[10:25:51.166]                           grepl <- base::grepl
[10:25:51.166]                           restarts <- computeRestarts(cond)
[10:25:51.166]                           for (restart in restarts) {
[10:25:51.166]                             name <- restart$name
[10:25:51.166]                             if (is.null(name)) 
[10:25:51.166]                               next
[10:25:51.166]                             if (!grepl(pattern, name)) 
[10:25:51.166]                               next
[10:25:51.166]                             invokeRestart(restart)
[10:25:51.166]                             muffled <- TRUE
[10:25:51.166]                             break
[10:25:51.166]                           }
[10:25:51.166]                         }
[10:25:51.166]                       }
[10:25:51.166]                       invisible(muffled)
[10:25:51.166]                     }
[10:25:51.166]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.166]                   }
[10:25:51.166]                 }
[10:25:51.166]                 else {
[10:25:51.166]                   if (TRUE) {
[10:25:51.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.166]                     {
[10:25:51.166]                       inherits <- base::inherits
[10:25:51.166]                       invokeRestart <- base::invokeRestart
[10:25:51.166]                       is.null <- base::is.null
[10:25:51.166]                       muffled <- FALSE
[10:25:51.166]                       if (inherits(cond, "message")) {
[10:25:51.166]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.166]                         if (muffled) 
[10:25:51.166]                           invokeRestart("muffleMessage")
[10:25:51.166]                       }
[10:25:51.166]                       else if (inherits(cond, "warning")) {
[10:25:51.166]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.166]                         if (muffled) 
[10:25:51.166]                           invokeRestart("muffleWarning")
[10:25:51.166]                       }
[10:25:51.166]                       else if (inherits(cond, "condition")) {
[10:25:51.166]                         if (!is.null(pattern)) {
[10:25:51.166]                           computeRestarts <- base::computeRestarts
[10:25:51.166]                           grepl <- base::grepl
[10:25:51.166]                           restarts <- computeRestarts(cond)
[10:25:51.166]                           for (restart in restarts) {
[10:25:51.166]                             name <- restart$name
[10:25:51.166]                             if (is.null(name)) 
[10:25:51.166]                               next
[10:25:51.166]                             if (!grepl(pattern, name)) 
[10:25:51.166]                               next
[10:25:51.166]                             invokeRestart(restart)
[10:25:51.166]                             muffled <- TRUE
[10:25:51.166]                             break
[10:25:51.166]                           }
[10:25:51.166]                         }
[10:25:51.166]                       }
[10:25:51.166]                       invisible(muffled)
[10:25:51.166]                     }
[10:25:51.166]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.166]                   }
[10:25:51.166]                 }
[10:25:51.166]             }
[10:25:51.166]         }))
[10:25:51.166]     }, error = function(ex) {
[10:25:51.166]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.166]                 ...future.rng), started = ...future.startTime, 
[10:25:51.166]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.166]             version = "1.8"), class = "FutureResult")
[10:25:51.166]     }, finally = {
[10:25:51.166]         if (!identical(...future.workdir, getwd())) 
[10:25:51.166]             setwd(...future.workdir)
[10:25:51.166]         {
[10:25:51.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.166]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.166]             }
[10:25:51.166]             base::options(...future.oldOptions)
[10:25:51.166]             if (.Platform$OS.type == "windows") {
[10:25:51.166]                 old_names <- names(...future.oldEnvVars)
[10:25:51.166]                 envs <- base::Sys.getenv()
[10:25:51.166]                 names <- names(envs)
[10:25:51.166]                 common <- intersect(names, old_names)
[10:25:51.166]                 added <- setdiff(names, old_names)
[10:25:51.166]                 removed <- setdiff(old_names, names)
[10:25:51.166]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.166]                   envs[common]]
[10:25:51.166]                 NAMES <- toupper(changed)
[10:25:51.166]                 args <- list()
[10:25:51.166]                 for (kk in seq_along(NAMES)) {
[10:25:51.166]                   name <- changed[[kk]]
[10:25:51.166]                   NAME <- NAMES[[kk]]
[10:25:51.166]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.166]                     next
[10:25:51.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.166]                 }
[10:25:51.166]                 NAMES <- toupper(added)
[10:25:51.166]                 for (kk in seq_along(NAMES)) {
[10:25:51.166]                   name <- added[[kk]]
[10:25:51.166]                   NAME <- NAMES[[kk]]
[10:25:51.166]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.166]                     next
[10:25:51.166]                   args[[name]] <- ""
[10:25:51.166]                 }
[10:25:51.166]                 NAMES <- toupper(removed)
[10:25:51.166]                 for (kk in seq_along(NAMES)) {
[10:25:51.166]                   name <- removed[[kk]]
[10:25:51.166]                   NAME <- NAMES[[kk]]
[10:25:51.166]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.166]                     next
[10:25:51.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.166]                 }
[10:25:51.166]                 if (length(args) > 0) 
[10:25:51.166]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.166]             }
[10:25:51.166]             else {
[10:25:51.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.166]             }
[10:25:51.166]             {
[10:25:51.166]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.166]                   0L) {
[10:25:51.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.166]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.166]                   base::options(opts)
[10:25:51.166]                 }
[10:25:51.166]                 {
[10:25:51.166]                   {
[10:25:51.166]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.166]                     NULL
[10:25:51.166]                   }
[10:25:51.166]                   options(future.plan = NULL)
[10:25:51.166]                   if (is.na(NA_character_)) 
[10:25:51.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.166]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.166]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.166]                     envir = parent.frame()) 
[10:25:51.166]                   {
[10:25:51.166]                     if (is.function(workers)) 
[10:25:51.166]                       workers <- workers()
[10:25:51.166]                     workers <- structure(as.integer(workers), 
[10:25:51.166]                       class = class(workers))
[10:25:51.166]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.166]                       workers >= 1)
[10:25:51.166]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.166]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.166]                     }
[10:25:51.166]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.166]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.166]                       envir = envir)
[10:25:51.166]                     if (!future$lazy) 
[10:25:51.166]                       future <- run(future)
[10:25:51.166]                     invisible(future)
[10:25:51.166]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.166]                 }
[10:25:51.166]             }
[10:25:51.166]         }
[10:25:51.166]     })
[10:25:51.166]     if (TRUE) {
[10:25:51.166]         base::sink(type = "output", split = FALSE)
[10:25:51.166]         if (TRUE) {
[10:25:51.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.166]         }
[10:25:51.166]         else {
[10:25:51.166]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.166]         }
[10:25:51.166]         base::close(...future.stdout)
[10:25:51.166]         ...future.stdout <- NULL
[10:25:51.166]     }
[10:25:51.166]     ...future.result$conditions <- ...future.conditions
[10:25:51.166]     ...future.result$finished <- base::Sys.time()
[10:25:51.166]     ...future.result
[10:25:51.166] }
[10:25:51.168] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:51.179] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.179] - Validating connection of MultisessionFuture
[10:25:51.179] - received message: FutureResult
[10:25:51.179] - Received FutureResult
[10:25:51.180] - Erased future from FutureRegistry
[10:25:51.180] result() for ClusterFuture ...
[10:25:51.180] - result already collected: FutureResult
[10:25:51.180] result() for ClusterFuture ... done
[10:25:51.180] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.180] result() for ClusterFuture ...
[10:25:51.180] - result already collected: FutureResult
[10:25:51.180] result() for ClusterFuture ... done
[10:25:51.180] result() for ClusterFuture ...
[10:25:51.180] - result already collected: FutureResult
[10:25:51.181] result() for ClusterFuture ... done
[10:25:51.182] MultisessionFuture started
[10:25:51.182] - Launch lazy future ... done
[10:25:51.182] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f6ba5040> 
Classes 'listenv', 'environment' <environment: 0x55c0f4f559c8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:25:51.194] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.194] - Validating connection of MultisessionFuture
[10:25:51.194] - received message: FutureResult
[10:25:51.194] - Received FutureResult
[10:25:51.195] - Erased future from FutureRegistry
[10:25:51.195] result() for ClusterFuture ...
[10:25:51.195] - result already collected: FutureResult
[10:25:51.195] result() for ClusterFuture ... done
[10:25:51.195] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:51.208] resolve() on list environment ...
[10:25:51.208]  recursive: 0
[10:25:51.209]  length: 6
[10:25:51.209]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:51.209] signalConditionsASAP(numeric, pos=1) ...
[10:25:51.209] - nx: 6
[10:25:51.209] - relay: TRUE
[10:25:51.209] - stdout: TRUE
[10:25:51.210] - signal: TRUE
[10:25:51.210] - resignal: FALSE
[10:25:51.210] - force: TRUE
[10:25:51.210] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.210] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.210]  - until=2
[10:25:51.210]  - relaying element #2
[10:25:51.210] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.210] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.210] signalConditionsASAP(NULL, pos=1) ... done
[10:25:51.211]  length: 5 (resolved future 1)
[10:25:51.211] Future #2
[10:25:51.211] result() for ClusterFuture ...
[10:25:51.211] - result already collected: FutureResult
[10:25:51.211] result() for ClusterFuture ... done
[10:25:51.211] result() for ClusterFuture ...
[10:25:51.211] - result already collected: FutureResult
[10:25:51.211] result() for ClusterFuture ... done
[10:25:51.211] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:51.211] - nx: 6
[10:25:51.211] - relay: TRUE
[10:25:51.212] - stdout: TRUE
[10:25:51.212] - signal: TRUE
[10:25:51.212] - resignal: FALSE
[10:25:51.212] - force: TRUE
[10:25:51.212] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.212] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.212]  - until=2
[10:25:51.212]  - relaying element #2
[10:25:51.212] result() for ClusterFuture ...
[10:25:51.212] - result already collected: FutureResult
[10:25:51.212] result() for ClusterFuture ... done
[10:25:51.213] result() for ClusterFuture ...
[10:25:51.213] - result already collected: FutureResult
[10:25:51.213] result() for ClusterFuture ... done
[10:25:51.213] result() for ClusterFuture ...
[10:25:51.213] - result already collected: FutureResult
[10:25:51.213] result() for ClusterFuture ... done
[10:25:51.213] result() for ClusterFuture ...
[10:25:51.213] - result already collected: FutureResult
[10:25:51.213] result() for ClusterFuture ... done
[10:25:51.213] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.213] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.214] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:51.214]  length: 4 (resolved future 2)
[10:25:51.214] Future #3
[10:25:51.214] result() for ClusterFuture ...
[10:25:51.214] - result already collected: FutureResult
[10:25:51.214] result() for ClusterFuture ... done
[10:25:51.214] result() for ClusterFuture ...
[10:25:51.214] - result already collected: FutureResult
[10:25:51.214] result() for ClusterFuture ... done
[10:25:51.214] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:51.215] - nx: 6
[10:25:51.215] - relay: TRUE
[10:25:51.215] - stdout: TRUE
[10:25:51.215] - signal: TRUE
[10:25:51.215] - resignal: FALSE
[10:25:51.215] - force: TRUE
[10:25:51.215] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.215] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.215]  - until=3
[10:25:51.215]  - relaying element #3
[10:25:51.215] result() for ClusterFuture ...
[10:25:51.215] - result already collected: FutureResult
[10:25:51.216] result() for ClusterFuture ... done
[10:25:51.216] result() for ClusterFuture ...
[10:25:51.216] - result already collected: FutureResult
[10:25:51.216] result() for ClusterFuture ... done
[10:25:51.216] result() for ClusterFuture ...
[10:25:51.216] - result already collected: FutureResult
[10:25:51.216] result() for ClusterFuture ... done
[10:25:51.216] result() for ClusterFuture ...
[10:25:51.216] - result already collected: FutureResult
[10:25:51.216] result() for ClusterFuture ... done
[10:25:51.216] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.216] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.217] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:51.217]  length: 3 (resolved future 3)
[10:25:51.227] signalConditionsASAP(NULL, pos=5) ...
[10:25:51.227] - nx: 6
[10:25:51.228] - relay: TRUE
[10:25:51.228] - stdout: TRUE
[10:25:51.228] - signal: TRUE
[10:25:51.228] - resignal: FALSE
[10:25:51.228] - force: TRUE
[10:25:51.228] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.228] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.228]  - until=6
[10:25:51.228]  - relaying element #4
[10:25:51.228]  - relaying element #6
[10:25:51.228] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:25:51.229] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.229] signalConditionsASAP(NULL, pos=5) ... done
[10:25:51.229]  length: 2 (resolved future 5)
[10:25:51.229] signalConditionsASAP(numeric, pos=6) ...
[10:25:51.229] - nx: 6
[10:25:51.229] - relay: TRUE
[10:25:51.229] - stdout: TRUE
[10:25:51.229] - signal: TRUE
[10:25:51.230] - resignal: FALSE
[10:25:51.230] - force: TRUE
[10:25:51.230] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:25:51.230] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.230]  - until=6
[10:25:51.230]  - relaying element #4
[10:25:51.231] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:25:51.231] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.231] signalConditionsASAP(NULL, pos=6) ... done
[10:25:51.231]  length: 1 (resolved future 6)
[10:25:51.242] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.242] - Validating connection of MultisessionFuture
[10:25:51.242] - received message: FutureResult
[10:25:51.242] - Received FutureResult
[10:25:51.242] - Erased future from FutureRegistry
[10:25:51.242] result() for ClusterFuture ...
[10:25:51.242] - result already collected: FutureResult
[10:25:51.243] result() for ClusterFuture ... done
[10:25:51.243] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.243] Future #4
[10:25:51.243] result() for ClusterFuture ...
[10:25:51.243] - result already collected: FutureResult
[10:25:51.243] result() for ClusterFuture ... done
[10:25:51.243] result() for ClusterFuture ...
[10:25:51.243] - result already collected: FutureResult
[10:25:51.243] result() for ClusterFuture ... done
[10:25:51.243] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:51.243] - nx: 6
[10:25:51.243] - relay: TRUE
[10:25:51.244] - stdout: TRUE
[10:25:51.244] - signal: TRUE
[10:25:51.244] - resignal: FALSE
[10:25:51.244] - force: TRUE
[10:25:51.244] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:25:51.244] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.244]  - until=6
[10:25:51.244]  - relaying element #4
[10:25:51.244] result() for ClusterFuture ...
[10:25:51.244] - result already collected: FutureResult
[10:25:51.244] result() for ClusterFuture ... done
[10:25:51.245] result() for ClusterFuture ...
[10:25:51.245] - result already collected: FutureResult
[10:25:51.245] result() for ClusterFuture ... done
[10:25:51.245] result() for ClusterFuture ...
[10:25:51.245] - result already collected: FutureResult
[10:25:51.245] result() for ClusterFuture ... done
[10:25:51.245] result() for ClusterFuture ...
[10:25:51.245] - result already collected: FutureResult
[10:25:51.245] result() for ClusterFuture ... done
[10:25:51.245] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.245] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.246] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:51.246]  length: 0 (resolved future 4)
[10:25:51.246] Relaying remaining futures
[10:25:51.246] signalConditionsASAP(NULL, pos=0) ...
[10:25:51.246] - nx: 6
[10:25:51.246] - relay: TRUE
[10:25:51.246] - stdout: TRUE
[10:25:51.246] - signal: TRUE
[10:25:51.246] - resignal: FALSE
[10:25:51.246] - force: TRUE
[10:25:51.246] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.246] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:51.247] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.247] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.247] signalConditionsASAP(NULL, pos=0) ... done
[10:25:51.247] resolve() on list environment ... DONE
[10:25:51.247] result() for ClusterFuture ...
[10:25:51.247] - result already collected: FutureResult
[10:25:51.247] result() for ClusterFuture ... done
[10:25:51.247] result() for ClusterFuture ...
[10:25:51.247] - result already collected: FutureResult
[10:25:51.247] result() for ClusterFuture ... done
[10:25:51.248] result() for ClusterFuture ...
[10:25:51.248] - result already collected: FutureResult
[10:25:51.248] result() for ClusterFuture ... done
[10:25:51.248] result() for ClusterFuture ...
[10:25:51.248] - result already collected: FutureResult
[10:25:51.248] result() for ClusterFuture ... done
[10:25:51.248] result() for ClusterFuture ...
[10:25:51.248] - result already collected: FutureResult
[10:25:51.248] result() for ClusterFuture ... done
[10:25:51.248] result() for ClusterFuture ...
[10:25:51.249] - result already collected: FutureResult
[10:25:51.249] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f3da35d0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:25:51.250] getGlobalsAndPackages() ...
[10:25:51.250] Searching for globals...
[10:25:51.251] 
[10:25:51.251] Searching for globals ... DONE
[10:25:51.251] - globals: [0] <none>
[10:25:51.251] getGlobalsAndPackages() ... DONE
[10:25:51.251] run() for ‘Future’ ...
[10:25:51.251] - state: ‘created’
[10:25:51.252] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.265] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.266]   - Field: ‘node’
[10:25:51.266]   - Field: ‘label’
[10:25:51.266]   - Field: ‘local’
[10:25:51.266]   - Field: ‘owner’
[10:25:51.266]   - Field: ‘envir’
[10:25:51.266]   - Field: ‘workers’
[10:25:51.266]   - Field: ‘packages’
[10:25:51.266]   - Field: ‘gc’
[10:25:51.267]   - Field: ‘conditions’
[10:25:51.267]   - Field: ‘persistent’
[10:25:51.267]   - Field: ‘expr’
[10:25:51.267]   - Field: ‘uuid’
[10:25:51.267]   - Field: ‘seed’
[10:25:51.267]   - Field: ‘version’
[10:25:51.267]   - Field: ‘result’
[10:25:51.267]   - Field: ‘asynchronous’
[10:25:51.267]   - Field: ‘calls’
[10:25:51.267]   - Field: ‘globals’
[10:25:51.267]   - Field: ‘stdout’
[10:25:51.268]   - Field: ‘earlySignal’
[10:25:51.268]   - Field: ‘lazy’
[10:25:51.268]   - Field: ‘state’
[10:25:51.268] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.268] - Launch lazy future ...
[10:25:51.268] Packages needed by the future expression (n = 0): <none>
[10:25:51.268] Packages needed by future strategies (n = 0): <none>
[10:25:51.269] {
[10:25:51.269]     {
[10:25:51.269]         {
[10:25:51.269]             ...future.startTime <- base::Sys.time()
[10:25:51.269]             {
[10:25:51.269]                 {
[10:25:51.269]                   {
[10:25:51.269]                     {
[10:25:51.269]                       base::local({
[10:25:51.269]                         has_future <- base::requireNamespace("future", 
[10:25:51.269]                           quietly = TRUE)
[10:25:51.269]                         if (has_future) {
[10:25:51.269]                           ns <- base::getNamespace("future")
[10:25:51.269]                           version <- ns[[".package"]][["version"]]
[10:25:51.269]                           if (is.null(version)) 
[10:25:51.269]                             version <- utils::packageVersion("future")
[10:25:51.269]                         }
[10:25:51.269]                         else {
[10:25:51.269]                           version <- NULL
[10:25:51.269]                         }
[10:25:51.269]                         if (!has_future || version < "1.8.0") {
[10:25:51.269]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.269]                             "", base::R.version$version.string), 
[10:25:51.269]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.269]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.269]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.269]                               "release", "version")], collapse = " "), 
[10:25:51.269]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.269]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.269]                             info)
[10:25:51.269]                           info <- base::paste(info, collapse = "; ")
[10:25:51.269]                           if (!has_future) {
[10:25:51.269]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.269]                               info)
[10:25:51.269]                           }
[10:25:51.269]                           else {
[10:25:51.269]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.269]                               info, version)
[10:25:51.269]                           }
[10:25:51.269]                           base::stop(msg)
[10:25:51.269]                         }
[10:25:51.269]                       })
[10:25:51.269]                     }
[10:25:51.269]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.269]                     base::options(mc.cores = 1L)
[10:25:51.269]                   }
[10:25:51.269]                   options(future.plan = NULL)
[10:25:51.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.269]                 }
[10:25:51.269]                 ...future.workdir <- getwd()
[10:25:51.269]             }
[10:25:51.269]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.269]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.269]         }
[10:25:51.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.269]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.269]             base::names(...future.oldOptions))
[10:25:51.269]     }
[10:25:51.269]     if (FALSE) {
[10:25:51.269]     }
[10:25:51.269]     else {
[10:25:51.269]         if (TRUE) {
[10:25:51.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.269]                 open = "w")
[10:25:51.269]         }
[10:25:51.269]         else {
[10:25:51.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.269]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.269]         }
[10:25:51.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.269]             base::sink(type = "output", split = FALSE)
[10:25:51.269]             base::close(...future.stdout)
[10:25:51.269]         }, add = TRUE)
[10:25:51.269]     }
[10:25:51.269]     ...future.frame <- base::sys.nframe()
[10:25:51.269]     ...future.conditions <- base::list()
[10:25:51.269]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.269]     if (FALSE) {
[10:25:51.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.269]     }
[10:25:51.269]     ...future.result <- base::tryCatch({
[10:25:51.269]         base::withCallingHandlers({
[10:25:51.269]             ...future.value <- base::withVisible(base::local({
[10:25:51.269]                 ...future.makeSendCondition <- base::local({
[10:25:51.269]                   sendCondition <- NULL
[10:25:51.269]                   function(frame = 1L) {
[10:25:51.269]                     if (is.function(sendCondition)) 
[10:25:51.269]                       return(sendCondition)
[10:25:51.269]                     ns <- getNamespace("parallel")
[10:25:51.269]                     if (exists("sendData", mode = "function", 
[10:25:51.269]                       envir = ns)) {
[10:25:51.269]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.269]                         envir = ns)
[10:25:51.269]                       envir <- sys.frame(frame)
[10:25:51.269]                       master <- NULL
[10:25:51.269]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.269]                         !identical(envir, emptyenv())) {
[10:25:51.269]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.269]                           inherits = FALSE)) {
[10:25:51.269]                           master <- get("master", mode = "list", 
[10:25:51.269]                             envir = envir, inherits = FALSE)
[10:25:51.269]                           if (inherits(master, c("SOCKnode", 
[10:25:51.269]                             "SOCK0node"))) {
[10:25:51.269]                             sendCondition <<- function(cond) {
[10:25:51.269]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.269]                                 success = TRUE)
[10:25:51.269]                               parallel_sendData(master, data)
[10:25:51.269]                             }
[10:25:51.269]                             return(sendCondition)
[10:25:51.269]                           }
[10:25:51.269]                         }
[10:25:51.269]                         frame <- frame + 1L
[10:25:51.269]                         envir <- sys.frame(frame)
[10:25:51.269]                       }
[10:25:51.269]                     }
[10:25:51.269]                     sendCondition <<- function(cond) NULL
[10:25:51.269]                   }
[10:25:51.269]                 })
[10:25:51.269]                 withCallingHandlers({
[10:25:51.269]                   2
[10:25:51.269]                 }, immediateCondition = function(cond) {
[10:25:51.269]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.269]                   sendCondition(cond)
[10:25:51.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.269]                   {
[10:25:51.269]                     inherits <- base::inherits
[10:25:51.269]                     invokeRestart <- base::invokeRestart
[10:25:51.269]                     is.null <- base::is.null
[10:25:51.269]                     muffled <- FALSE
[10:25:51.269]                     if (inherits(cond, "message")) {
[10:25:51.269]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.269]                       if (muffled) 
[10:25:51.269]                         invokeRestart("muffleMessage")
[10:25:51.269]                     }
[10:25:51.269]                     else if (inherits(cond, "warning")) {
[10:25:51.269]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.269]                       if (muffled) 
[10:25:51.269]                         invokeRestart("muffleWarning")
[10:25:51.269]                     }
[10:25:51.269]                     else if (inherits(cond, "condition")) {
[10:25:51.269]                       if (!is.null(pattern)) {
[10:25:51.269]                         computeRestarts <- base::computeRestarts
[10:25:51.269]                         grepl <- base::grepl
[10:25:51.269]                         restarts <- computeRestarts(cond)
[10:25:51.269]                         for (restart in restarts) {
[10:25:51.269]                           name <- restart$name
[10:25:51.269]                           if (is.null(name)) 
[10:25:51.269]                             next
[10:25:51.269]                           if (!grepl(pattern, name)) 
[10:25:51.269]                             next
[10:25:51.269]                           invokeRestart(restart)
[10:25:51.269]                           muffled <- TRUE
[10:25:51.269]                           break
[10:25:51.269]                         }
[10:25:51.269]                       }
[10:25:51.269]                     }
[10:25:51.269]                     invisible(muffled)
[10:25:51.269]                   }
[10:25:51.269]                   muffleCondition(cond)
[10:25:51.269]                 })
[10:25:51.269]             }))
[10:25:51.269]             future::FutureResult(value = ...future.value$value, 
[10:25:51.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.269]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.269]                     ...future.globalenv.names))
[10:25:51.269]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.269]         }, condition = base::local({
[10:25:51.269]             c <- base::c
[10:25:51.269]             inherits <- base::inherits
[10:25:51.269]             invokeRestart <- base::invokeRestart
[10:25:51.269]             length <- base::length
[10:25:51.269]             list <- base::list
[10:25:51.269]             seq.int <- base::seq.int
[10:25:51.269]             signalCondition <- base::signalCondition
[10:25:51.269]             sys.calls <- base::sys.calls
[10:25:51.269]             `[[` <- base::`[[`
[10:25:51.269]             `+` <- base::`+`
[10:25:51.269]             `<<-` <- base::`<<-`
[10:25:51.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.269]                   3L)]
[10:25:51.269]             }
[10:25:51.269]             function(cond) {
[10:25:51.269]                 is_error <- inherits(cond, "error")
[10:25:51.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.269]                   NULL)
[10:25:51.269]                 if (is_error) {
[10:25:51.269]                   sessionInformation <- function() {
[10:25:51.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.269]                       search = base::search(), system = base::Sys.info())
[10:25:51.269]                   }
[10:25:51.269]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.269]                     cond$call), session = sessionInformation(), 
[10:25:51.269]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.269]                   signalCondition(cond)
[10:25:51.269]                 }
[10:25:51.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.269]                 "immediateCondition"))) {
[10:25:51.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.269]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.269]                   if (TRUE && !signal) {
[10:25:51.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.269]                     {
[10:25:51.269]                       inherits <- base::inherits
[10:25:51.269]                       invokeRestart <- base::invokeRestart
[10:25:51.269]                       is.null <- base::is.null
[10:25:51.269]                       muffled <- FALSE
[10:25:51.269]                       if (inherits(cond, "message")) {
[10:25:51.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.269]                         if (muffled) 
[10:25:51.269]                           invokeRestart("muffleMessage")
[10:25:51.269]                       }
[10:25:51.269]                       else if (inherits(cond, "warning")) {
[10:25:51.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.269]                         if (muffled) 
[10:25:51.269]                           invokeRestart("muffleWarning")
[10:25:51.269]                       }
[10:25:51.269]                       else if (inherits(cond, "condition")) {
[10:25:51.269]                         if (!is.null(pattern)) {
[10:25:51.269]                           computeRestarts <- base::computeRestarts
[10:25:51.269]                           grepl <- base::grepl
[10:25:51.269]                           restarts <- computeRestarts(cond)
[10:25:51.269]                           for (restart in restarts) {
[10:25:51.269]                             name <- restart$name
[10:25:51.269]                             if (is.null(name)) 
[10:25:51.269]                               next
[10:25:51.269]                             if (!grepl(pattern, name)) 
[10:25:51.269]                               next
[10:25:51.269]                             invokeRestart(restart)
[10:25:51.269]                             muffled <- TRUE
[10:25:51.269]                             break
[10:25:51.269]                           }
[10:25:51.269]                         }
[10:25:51.269]                       }
[10:25:51.269]                       invisible(muffled)
[10:25:51.269]                     }
[10:25:51.269]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.269]                   }
[10:25:51.269]                 }
[10:25:51.269]                 else {
[10:25:51.269]                   if (TRUE) {
[10:25:51.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.269]                     {
[10:25:51.269]                       inherits <- base::inherits
[10:25:51.269]                       invokeRestart <- base::invokeRestart
[10:25:51.269]                       is.null <- base::is.null
[10:25:51.269]                       muffled <- FALSE
[10:25:51.269]                       if (inherits(cond, "message")) {
[10:25:51.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.269]                         if (muffled) 
[10:25:51.269]                           invokeRestart("muffleMessage")
[10:25:51.269]                       }
[10:25:51.269]                       else if (inherits(cond, "warning")) {
[10:25:51.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.269]                         if (muffled) 
[10:25:51.269]                           invokeRestart("muffleWarning")
[10:25:51.269]                       }
[10:25:51.269]                       else if (inherits(cond, "condition")) {
[10:25:51.269]                         if (!is.null(pattern)) {
[10:25:51.269]                           computeRestarts <- base::computeRestarts
[10:25:51.269]                           grepl <- base::grepl
[10:25:51.269]                           restarts <- computeRestarts(cond)
[10:25:51.269]                           for (restart in restarts) {
[10:25:51.269]                             name <- restart$name
[10:25:51.269]                             if (is.null(name)) 
[10:25:51.269]                               next
[10:25:51.269]                             if (!grepl(pattern, name)) 
[10:25:51.269]                               next
[10:25:51.269]                             invokeRestart(restart)
[10:25:51.269]                             muffled <- TRUE
[10:25:51.269]                             break
[10:25:51.269]                           }
[10:25:51.269]                         }
[10:25:51.269]                       }
[10:25:51.269]                       invisible(muffled)
[10:25:51.269]                     }
[10:25:51.269]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.269]                   }
[10:25:51.269]                 }
[10:25:51.269]             }
[10:25:51.269]         }))
[10:25:51.269]     }, error = function(ex) {
[10:25:51.269]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.269]                 ...future.rng), started = ...future.startTime, 
[10:25:51.269]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.269]             version = "1.8"), class = "FutureResult")
[10:25:51.269]     }, finally = {
[10:25:51.269]         if (!identical(...future.workdir, getwd())) 
[10:25:51.269]             setwd(...future.workdir)
[10:25:51.269]         {
[10:25:51.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.269]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.269]             }
[10:25:51.269]             base::options(...future.oldOptions)
[10:25:51.269]             if (.Platform$OS.type == "windows") {
[10:25:51.269]                 old_names <- names(...future.oldEnvVars)
[10:25:51.269]                 envs <- base::Sys.getenv()
[10:25:51.269]                 names <- names(envs)
[10:25:51.269]                 common <- intersect(names, old_names)
[10:25:51.269]                 added <- setdiff(names, old_names)
[10:25:51.269]                 removed <- setdiff(old_names, names)
[10:25:51.269]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.269]                   envs[common]]
[10:25:51.269]                 NAMES <- toupper(changed)
[10:25:51.269]                 args <- list()
[10:25:51.269]                 for (kk in seq_along(NAMES)) {
[10:25:51.269]                   name <- changed[[kk]]
[10:25:51.269]                   NAME <- NAMES[[kk]]
[10:25:51.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.269]                     next
[10:25:51.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.269]                 }
[10:25:51.269]                 NAMES <- toupper(added)
[10:25:51.269]                 for (kk in seq_along(NAMES)) {
[10:25:51.269]                   name <- added[[kk]]
[10:25:51.269]                   NAME <- NAMES[[kk]]
[10:25:51.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.269]                     next
[10:25:51.269]                   args[[name]] <- ""
[10:25:51.269]                 }
[10:25:51.269]                 NAMES <- toupper(removed)
[10:25:51.269]                 for (kk in seq_along(NAMES)) {
[10:25:51.269]                   name <- removed[[kk]]
[10:25:51.269]                   NAME <- NAMES[[kk]]
[10:25:51.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.269]                     next
[10:25:51.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.269]                 }
[10:25:51.269]                 if (length(args) > 0) 
[10:25:51.269]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.269]             }
[10:25:51.269]             else {
[10:25:51.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.269]             }
[10:25:51.269]             {
[10:25:51.269]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.269]                   0L) {
[10:25:51.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.269]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.269]                   base::options(opts)
[10:25:51.269]                 }
[10:25:51.269]                 {
[10:25:51.269]                   {
[10:25:51.269]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.269]                     NULL
[10:25:51.269]                   }
[10:25:51.269]                   options(future.plan = NULL)
[10:25:51.269]                   if (is.na(NA_character_)) 
[10:25:51.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.269]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.269]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.269]                     envir = parent.frame()) 
[10:25:51.269]                   {
[10:25:51.269]                     if (is.function(workers)) 
[10:25:51.269]                       workers <- workers()
[10:25:51.269]                     workers <- structure(as.integer(workers), 
[10:25:51.269]                       class = class(workers))
[10:25:51.269]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.269]                       workers >= 1)
[10:25:51.269]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.269]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.269]                     }
[10:25:51.269]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.269]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.269]                       envir = envir)
[10:25:51.269]                     if (!future$lazy) 
[10:25:51.269]                       future <- run(future)
[10:25:51.269]                     invisible(future)
[10:25:51.269]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.269]                 }
[10:25:51.269]             }
[10:25:51.269]         }
[10:25:51.269]     })
[10:25:51.269]     if (TRUE) {
[10:25:51.269]         base::sink(type = "output", split = FALSE)
[10:25:51.269]         if (TRUE) {
[10:25:51.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.269]         }
[10:25:51.269]         else {
[10:25:51.269]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.269]         }
[10:25:51.269]         base::close(...future.stdout)
[10:25:51.269]         ...future.stdout <- NULL
[10:25:51.269]     }
[10:25:51.269]     ...future.result$conditions <- ...future.conditions
[10:25:51.269]     ...future.result$finished <- base::Sys.time()
[10:25:51.269]     ...future.result
[10:25:51.269] }
[10:25:51.272] MultisessionFuture started
[10:25:51.272] - Launch lazy future ... done
[10:25:51.272] run() for ‘MultisessionFuture’ ... done
[10:25:51.272] getGlobalsAndPackages() ...
[10:25:51.273] Searching for globals...
[10:25:51.273] 
[10:25:51.273] Searching for globals ... DONE
[10:25:51.273] - globals: [0] <none>
[10:25:51.273] getGlobalsAndPackages() ... DONE
[10:25:51.273] run() for ‘Future’ ...
[10:25:51.273] - state: ‘created’
[10:25:51.274] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.287] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.287]   - Field: ‘node’
[10:25:51.287]   - Field: ‘label’
[10:25:51.287]   - Field: ‘local’
[10:25:51.288]   - Field: ‘owner’
[10:25:51.288]   - Field: ‘envir’
[10:25:51.288]   - Field: ‘workers’
[10:25:51.288]   - Field: ‘packages’
[10:25:51.288]   - Field: ‘gc’
[10:25:51.288]   - Field: ‘conditions’
[10:25:51.288]   - Field: ‘persistent’
[10:25:51.288]   - Field: ‘expr’
[10:25:51.288]   - Field: ‘uuid’
[10:25:51.288]   - Field: ‘seed’
[10:25:51.289]   - Field: ‘version’
[10:25:51.289]   - Field: ‘result’
[10:25:51.289]   - Field: ‘asynchronous’
[10:25:51.289]   - Field: ‘calls’
[10:25:51.289]   - Field: ‘globals’
[10:25:51.289]   - Field: ‘stdout’
[10:25:51.289]   - Field: ‘earlySignal’
[10:25:51.289]   - Field: ‘lazy’
[10:25:51.289]   - Field: ‘state’
[10:25:51.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.289] - Launch lazy future ...
[10:25:51.290] Packages needed by the future expression (n = 0): <none>
[10:25:51.290] Packages needed by future strategies (n = 0): <none>
[10:25:51.290] {
[10:25:51.290]     {
[10:25:51.290]         {
[10:25:51.290]             ...future.startTime <- base::Sys.time()
[10:25:51.290]             {
[10:25:51.290]                 {
[10:25:51.290]                   {
[10:25:51.290]                     {
[10:25:51.290]                       base::local({
[10:25:51.290]                         has_future <- base::requireNamespace("future", 
[10:25:51.290]                           quietly = TRUE)
[10:25:51.290]                         if (has_future) {
[10:25:51.290]                           ns <- base::getNamespace("future")
[10:25:51.290]                           version <- ns[[".package"]][["version"]]
[10:25:51.290]                           if (is.null(version)) 
[10:25:51.290]                             version <- utils::packageVersion("future")
[10:25:51.290]                         }
[10:25:51.290]                         else {
[10:25:51.290]                           version <- NULL
[10:25:51.290]                         }
[10:25:51.290]                         if (!has_future || version < "1.8.0") {
[10:25:51.290]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.290]                             "", base::R.version$version.string), 
[10:25:51.290]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.290]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.290]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.290]                               "release", "version")], collapse = " "), 
[10:25:51.290]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.290]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.290]                             info)
[10:25:51.290]                           info <- base::paste(info, collapse = "; ")
[10:25:51.290]                           if (!has_future) {
[10:25:51.290]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.290]                               info)
[10:25:51.290]                           }
[10:25:51.290]                           else {
[10:25:51.290]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.290]                               info, version)
[10:25:51.290]                           }
[10:25:51.290]                           base::stop(msg)
[10:25:51.290]                         }
[10:25:51.290]                       })
[10:25:51.290]                     }
[10:25:51.290]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.290]                     base::options(mc.cores = 1L)
[10:25:51.290]                   }
[10:25:51.290]                   options(future.plan = NULL)
[10:25:51.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.290]                 }
[10:25:51.290]                 ...future.workdir <- getwd()
[10:25:51.290]             }
[10:25:51.290]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.290]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.290]         }
[10:25:51.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.290]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.290]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.290]             base::names(...future.oldOptions))
[10:25:51.290]     }
[10:25:51.290]     if (FALSE) {
[10:25:51.290]     }
[10:25:51.290]     else {
[10:25:51.290]         if (TRUE) {
[10:25:51.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.290]                 open = "w")
[10:25:51.290]         }
[10:25:51.290]         else {
[10:25:51.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.290]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.290]         }
[10:25:51.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.290]             base::sink(type = "output", split = FALSE)
[10:25:51.290]             base::close(...future.stdout)
[10:25:51.290]         }, add = TRUE)
[10:25:51.290]     }
[10:25:51.290]     ...future.frame <- base::sys.nframe()
[10:25:51.290]     ...future.conditions <- base::list()
[10:25:51.290]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.290]     if (FALSE) {
[10:25:51.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.290]     }
[10:25:51.290]     ...future.result <- base::tryCatch({
[10:25:51.290]         base::withCallingHandlers({
[10:25:51.290]             ...future.value <- base::withVisible(base::local({
[10:25:51.290]                 ...future.makeSendCondition <- base::local({
[10:25:51.290]                   sendCondition <- NULL
[10:25:51.290]                   function(frame = 1L) {
[10:25:51.290]                     if (is.function(sendCondition)) 
[10:25:51.290]                       return(sendCondition)
[10:25:51.290]                     ns <- getNamespace("parallel")
[10:25:51.290]                     if (exists("sendData", mode = "function", 
[10:25:51.290]                       envir = ns)) {
[10:25:51.290]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.290]                         envir = ns)
[10:25:51.290]                       envir <- sys.frame(frame)
[10:25:51.290]                       master <- NULL
[10:25:51.290]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.290]                         !identical(envir, emptyenv())) {
[10:25:51.290]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.290]                           inherits = FALSE)) {
[10:25:51.290]                           master <- get("master", mode = "list", 
[10:25:51.290]                             envir = envir, inherits = FALSE)
[10:25:51.290]                           if (inherits(master, c("SOCKnode", 
[10:25:51.290]                             "SOCK0node"))) {
[10:25:51.290]                             sendCondition <<- function(cond) {
[10:25:51.290]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.290]                                 success = TRUE)
[10:25:51.290]                               parallel_sendData(master, data)
[10:25:51.290]                             }
[10:25:51.290]                             return(sendCondition)
[10:25:51.290]                           }
[10:25:51.290]                         }
[10:25:51.290]                         frame <- frame + 1L
[10:25:51.290]                         envir <- sys.frame(frame)
[10:25:51.290]                       }
[10:25:51.290]                     }
[10:25:51.290]                     sendCondition <<- function(cond) NULL
[10:25:51.290]                   }
[10:25:51.290]                 })
[10:25:51.290]                 withCallingHandlers({
[10:25:51.290]                   NULL
[10:25:51.290]                 }, immediateCondition = function(cond) {
[10:25:51.290]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.290]                   sendCondition(cond)
[10:25:51.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.290]                   {
[10:25:51.290]                     inherits <- base::inherits
[10:25:51.290]                     invokeRestart <- base::invokeRestart
[10:25:51.290]                     is.null <- base::is.null
[10:25:51.290]                     muffled <- FALSE
[10:25:51.290]                     if (inherits(cond, "message")) {
[10:25:51.290]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.290]                       if (muffled) 
[10:25:51.290]                         invokeRestart("muffleMessage")
[10:25:51.290]                     }
[10:25:51.290]                     else if (inherits(cond, "warning")) {
[10:25:51.290]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.290]                       if (muffled) 
[10:25:51.290]                         invokeRestart("muffleWarning")
[10:25:51.290]                     }
[10:25:51.290]                     else if (inherits(cond, "condition")) {
[10:25:51.290]                       if (!is.null(pattern)) {
[10:25:51.290]                         computeRestarts <- base::computeRestarts
[10:25:51.290]                         grepl <- base::grepl
[10:25:51.290]                         restarts <- computeRestarts(cond)
[10:25:51.290]                         for (restart in restarts) {
[10:25:51.290]                           name <- restart$name
[10:25:51.290]                           if (is.null(name)) 
[10:25:51.290]                             next
[10:25:51.290]                           if (!grepl(pattern, name)) 
[10:25:51.290]                             next
[10:25:51.290]                           invokeRestart(restart)
[10:25:51.290]                           muffled <- TRUE
[10:25:51.290]                           break
[10:25:51.290]                         }
[10:25:51.290]                       }
[10:25:51.290]                     }
[10:25:51.290]                     invisible(muffled)
[10:25:51.290]                   }
[10:25:51.290]                   muffleCondition(cond)
[10:25:51.290]                 })
[10:25:51.290]             }))
[10:25:51.290]             future::FutureResult(value = ...future.value$value, 
[10:25:51.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.290]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.290]                     ...future.globalenv.names))
[10:25:51.290]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.290]         }, condition = base::local({
[10:25:51.290]             c <- base::c
[10:25:51.290]             inherits <- base::inherits
[10:25:51.290]             invokeRestart <- base::invokeRestart
[10:25:51.290]             length <- base::length
[10:25:51.290]             list <- base::list
[10:25:51.290]             seq.int <- base::seq.int
[10:25:51.290]             signalCondition <- base::signalCondition
[10:25:51.290]             sys.calls <- base::sys.calls
[10:25:51.290]             `[[` <- base::`[[`
[10:25:51.290]             `+` <- base::`+`
[10:25:51.290]             `<<-` <- base::`<<-`
[10:25:51.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.290]                   3L)]
[10:25:51.290]             }
[10:25:51.290]             function(cond) {
[10:25:51.290]                 is_error <- inherits(cond, "error")
[10:25:51.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.290]                   NULL)
[10:25:51.290]                 if (is_error) {
[10:25:51.290]                   sessionInformation <- function() {
[10:25:51.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.290]                       search = base::search(), system = base::Sys.info())
[10:25:51.290]                   }
[10:25:51.290]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.290]                     cond$call), session = sessionInformation(), 
[10:25:51.290]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.290]                   signalCondition(cond)
[10:25:51.290]                 }
[10:25:51.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.290]                 "immediateCondition"))) {
[10:25:51.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.290]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.290]                   if (TRUE && !signal) {
[10:25:51.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.290]                     {
[10:25:51.290]                       inherits <- base::inherits
[10:25:51.290]                       invokeRestart <- base::invokeRestart
[10:25:51.290]                       is.null <- base::is.null
[10:25:51.290]                       muffled <- FALSE
[10:25:51.290]                       if (inherits(cond, "message")) {
[10:25:51.290]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.290]                         if (muffled) 
[10:25:51.290]                           invokeRestart("muffleMessage")
[10:25:51.290]                       }
[10:25:51.290]                       else if (inherits(cond, "warning")) {
[10:25:51.290]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.290]                         if (muffled) 
[10:25:51.290]                           invokeRestart("muffleWarning")
[10:25:51.290]                       }
[10:25:51.290]                       else if (inherits(cond, "condition")) {
[10:25:51.290]                         if (!is.null(pattern)) {
[10:25:51.290]                           computeRestarts <- base::computeRestarts
[10:25:51.290]                           grepl <- base::grepl
[10:25:51.290]                           restarts <- computeRestarts(cond)
[10:25:51.290]                           for (restart in restarts) {
[10:25:51.290]                             name <- restart$name
[10:25:51.290]                             if (is.null(name)) 
[10:25:51.290]                               next
[10:25:51.290]                             if (!grepl(pattern, name)) 
[10:25:51.290]                               next
[10:25:51.290]                             invokeRestart(restart)
[10:25:51.290]                             muffled <- TRUE
[10:25:51.290]                             break
[10:25:51.290]                           }
[10:25:51.290]                         }
[10:25:51.290]                       }
[10:25:51.290]                       invisible(muffled)
[10:25:51.290]                     }
[10:25:51.290]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.290]                   }
[10:25:51.290]                 }
[10:25:51.290]                 else {
[10:25:51.290]                   if (TRUE) {
[10:25:51.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.290]                     {
[10:25:51.290]                       inherits <- base::inherits
[10:25:51.290]                       invokeRestart <- base::invokeRestart
[10:25:51.290]                       is.null <- base::is.null
[10:25:51.290]                       muffled <- FALSE
[10:25:51.290]                       if (inherits(cond, "message")) {
[10:25:51.290]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.290]                         if (muffled) 
[10:25:51.290]                           invokeRestart("muffleMessage")
[10:25:51.290]                       }
[10:25:51.290]                       else if (inherits(cond, "warning")) {
[10:25:51.290]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.290]                         if (muffled) 
[10:25:51.290]                           invokeRestart("muffleWarning")
[10:25:51.290]                       }
[10:25:51.290]                       else if (inherits(cond, "condition")) {
[10:25:51.290]                         if (!is.null(pattern)) {
[10:25:51.290]                           computeRestarts <- base::computeRestarts
[10:25:51.290]                           grepl <- base::grepl
[10:25:51.290]                           restarts <- computeRestarts(cond)
[10:25:51.290]                           for (restart in restarts) {
[10:25:51.290]                             name <- restart$name
[10:25:51.290]                             if (is.null(name)) 
[10:25:51.290]                               next
[10:25:51.290]                             if (!grepl(pattern, name)) 
[10:25:51.290]                               next
[10:25:51.290]                             invokeRestart(restart)
[10:25:51.290]                             muffled <- TRUE
[10:25:51.290]                             break
[10:25:51.290]                           }
[10:25:51.290]                         }
[10:25:51.290]                       }
[10:25:51.290]                       invisible(muffled)
[10:25:51.290]                     }
[10:25:51.290]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.290]                   }
[10:25:51.290]                 }
[10:25:51.290]             }
[10:25:51.290]         }))
[10:25:51.290]     }, error = function(ex) {
[10:25:51.290]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.290]                 ...future.rng), started = ...future.startTime, 
[10:25:51.290]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.290]             version = "1.8"), class = "FutureResult")
[10:25:51.290]     }, finally = {
[10:25:51.290]         if (!identical(...future.workdir, getwd())) 
[10:25:51.290]             setwd(...future.workdir)
[10:25:51.290]         {
[10:25:51.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.290]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.290]             }
[10:25:51.290]             base::options(...future.oldOptions)
[10:25:51.290]             if (.Platform$OS.type == "windows") {
[10:25:51.290]                 old_names <- names(...future.oldEnvVars)
[10:25:51.290]                 envs <- base::Sys.getenv()
[10:25:51.290]                 names <- names(envs)
[10:25:51.290]                 common <- intersect(names, old_names)
[10:25:51.290]                 added <- setdiff(names, old_names)
[10:25:51.290]                 removed <- setdiff(old_names, names)
[10:25:51.290]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.290]                   envs[common]]
[10:25:51.290]                 NAMES <- toupper(changed)
[10:25:51.290]                 args <- list()
[10:25:51.290]                 for (kk in seq_along(NAMES)) {
[10:25:51.290]                   name <- changed[[kk]]
[10:25:51.290]                   NAME <- NAMES[[kk]]
[10:25:51.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.290]                     next
[10:25:51.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.290]                 }
[10:25:51.290]                 NAMES <- toupper(added)
[10:25:51.290]                 for (kk in seq_along(NAMES)) {
[10:25:51.290]                   name <- added[[kk]]
[10:25:51.290]                   NAME <- NAMES[[kk]]
[10:25:51.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.290]                     next
[10:25:51.290]                   args[[name]] <- ""
[10:25:51.290]                 }
[10:25:51.290]                 NAMES <- toupper(removed)
[10:25:51.290]                 for (kk in seq_along(NAMES)) {
[10:25:51.290]                   name <- removed[[kk]]
[10:25:51.290]                   NAME <- NAMES[[kk]]
[10:25:51.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.290]                     next
[10:25:51.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.290]                 }
[10:25:51.290]                 if (length(args) > 0) 
[10:25:51.290]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.290]             }
[10:25:51.290]             else {
[10:25:51.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.290]             }
[10:25:51.290]             {
[10:25:51.290]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.290]                   0L) {
[10:25:51.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.290]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.290]                   base::options(opts)
[10:25:51.290]                 }
[10:25:51.290]                 {
[10:25:51.290]                   {
[10:25:51.290]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.290]                     NULL
[10:25:51.290]                   }
[10:25:51.290]                   options(future.plan = NULL)
[10:25:51.290]                   if (is.na(NA_character_)) 
[10:25:51.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.290]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.290]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.290]                     envir = parent.frame()) 
[10:25:51.290]                   {
[10:25:51.290]                     if (is.function(workers)) 
[10:25:51.290]                       workers <- workers()
[10:25:51.290]                     workers <- structure(as.integer(workers), 
[10:25:51.290]                       class = class(workers))
[10:25:51.290]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.290]                       workers >= 1)
[10:25:51.290]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.290]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.290]                     }
[10:25:51.290]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.290]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.290]                       envir = envir)
[10:25:51.290]                     if (!future$lazy) 
[10:25:51.290]                       future <- run(future)
[10:25:51.290]                     invisible(future)
[10:25:51.290]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.290]                 }
[10:25:51.290]             }
[10:25:51.290]         }
[10:25:51.290]     })
[10:25:51.290]     if (TRUE) {
[10:25:51.290]         base::sink(type = "output", split = FALSE)
[10:25:51.290]         if (TRUE) {
[10:25:51.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.290]         }
[10:25:51.290]         else {
[10:25:51.290]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.290]         }
[10:25:51.290]         base::close(...future.stdout)
[10:25:51.290]         ...future.stdout <- NULL
[10:25:51.290]     }
[10:25:51.290]     ...future.result$conditions <- ...future.conditions
[10:25:51.290]     ...future.result$finished <- base::Sys.time()
[10:25:51.290]     ...future.result
[10:25:51.290] }
[10:25:51.293] MultisessionFuture started
[10:25:51.294] - Launch lazy future ... done
[10:25:51.294] run() for ‘MultisessionFuture’ ... done
[10:25:51.294] getGlobalsAndPackages() ...
[10:25:51.294] Searching for globals...
[10:25:51.295] - globals found: [1] ‘{’
[10:25:51.295] Searching for globals ... DONE
[10:25:51.295] Resolving globals: FALSE
[10:25:51.295] 
[10:25:51.295] 
[10:25:51.296] getGlobalsAndPackages() ... DONE
[10:25:51.296] run() for ‘Future’ ...
[10:25:51.296] - state: ‘created’
[10:25:51.296] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.318] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.318] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.318]   - Field: ‘node’
[10:25:51.318]   - Field: ‘label’
[10:25:51.319]   - Field: ‘local’
[10:25:51.319]   - Field: ‘owner’
[10:25:51.319]   - Field: ‘envir’
[10:25:51.319]   - Field: ‘workers’
[10:25:51.319]   - Field: ‘packages’
[10:25:51.319]   - Field: ‘gc’
[10:25:51.319]   - Field: ‘conditions’
[10:25:51.319]   - Field: ‘persistent’
[10:25:51.319]   - Field: ‘expr’
[10:25:51.319]   - Field: ‘uuid’
[10:25:51.319]   - Field: ‘seed’
[10:25:51.320]   - Field: ‘version’
[10:25:51.320]   - Field: ‘result’
[10:25:51.320]   - Field: ‘asynchronous’
[10:25:51.320]   - Field: ‘calls’
[10:25:51.320]   - Field: ‘globals’
[10:25:51.320]   - Field: ‘stdout’
[10:25:51.320]   - Field: ‘earlySignal’
[10:25:51.320]   - Field: ‘lazy’
[10:25:51.320]   - Field: ‘state’
[10:25:51.320] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.320] - Launch lazy future ...
[10:25:51.321] Packages needed by the future expression (n = 0): <none>
[10:25:51.321] Packages needed by future strategies (n = 0): <none>
[10:25:51.321] {
[10:25:51.321]     {
[10:25:51.321]         {
[10:25:51.321]             ...future.startTime <- base::Sys.time()
[10:25:51.321]             {
[10:25:51.321]                 {
[10:25:51.321]                   {
[10:25:51.321]                     {
[10:25:51.321]                       base::local({
[10:25:51.321]                         has_future <- base::requireNamespace("future", 
[10:25:51.321]                           quietly = TRUE)
[10:25:51.321]                         if (has_future) {
[10:25:51.321]                           ns <- base::getNamespace("future")
[10:25:51.321]                           version <- ns[[".package"]][["version"]]
[10:25:51.321]                           if (is.null(version)) 
[10:25:51.321]                             version <- utils::packageVersion("future")
[10:25:51.321]                         }
[10:25:51.321]                         else {
[10:25:51.321]                           version <- NULL
[10:25:51.321]                         }
[10:25:51.321]                         if (!has_future || version < "1.8.0") {
[10:25:51.321]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.321]                             "", base::R.version$version.string), 
[10:25:51.321]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.321]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.321]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.321]                               "release", "version")], collapse = " "), 
[10:25:51.321]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.321]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.321]                             info)
[10:25:51.321]                           info <- base::paste(info, collapse = "; ")
[10:25:51.321]                           if (!has_future) {
[10:25:51.321]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.321]                               info)
[10:25:51.321]                           }
[10:25:51.321]                           else {
[10:25:51.321]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.321]                               info, version)
[10:25:51.321]                           }
[10:25:51.321]                           base::stop(msg)
[10:25:51.321]                         }
[10:25:51.321]                       })
[10:25:51.321]                     }
[10:25:51.321]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.321]                     base::options(mc.cores = 1L)
[10:25:51.321]                   }
[10:25:51.321]                   options(future.plan = NULL)
[10:25:51.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.321]                 }
[10:25:51.321]                 ...future.workdir <- getwd()
[10:25:51.321]             }
[10:25:51.321]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.321]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.321]         }
[10:25:51.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.321]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.321]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.321]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.321]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.321]             base::names(...future.oldOptions))
[10:25:51.321]     }
[10:25:51.321]     if (FALSE) {
[10:25:51.321]     }
[10:25:51.321]     else {
[10:25:51.321]         if (TRUE) {
[10:25:51.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.321]                 open = "w")
[10:25:51.321]         }
[10:25:51.321]         else {
[10:25:51.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.321]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.321]         }
[10:25:51.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.321]             base::sink(type = "output", split = FALSE)
[10:25:51.321]             base::close(...future.stdout)
[10:25:51.321]         }, add = TRUE)
[10:25:51.321]     }
[10:25:51.321]     ...future.frame <- base::sys.nframe()
[10:25:51.321]     ...future.conditions <- base::list()
[10:25:51.321]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.321]     if (FALSE) {
[10:25:51.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.321]     }
[10:25:51.321]     ...future.result <- base::tryCatch({
[10:25:51.321]         base::withCallingHandlers({
[10:25:51.321]             ...future.value <- base::withVisible(base::local({
[10:25:51.321]                 ...future.makeSendCondition <- base::local({
[10:25:51.321]                   sendCondition <- NULL
[10:25:51.321]                   function(frame = 1L) {
[10:25:51.321]                     if (is.function(sendCondition)) 
[10:25:51.321]                       return(sendCondition)
[10:25:51.321]                     ns <- getNamespace("parallel")
[10:25:51.321]                     if (exists("sendData", mode = "function", 
[10:25:51.321]                       envir = ns)) {
[10:25:51.321]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.321]                         envir = ns)
[10:25:51.321]                       envir <- sys.frame(frame)
[10:25:51.321]                       master <- NULL
[10:25:51.321]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.321]                         !identical(envir, emptyenv())) {
[10:25:51.321]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.321]                           inherits = FALSE)) {
[10:25:51.321]                           master <- get("master", mode = "list", 
[10:25:51.321]                             envir = envir, inherits = FALSE)
[10:25:51.321]                           if (inherits(master, c("SOCKnode", 
[10:25:51.321]                             "SOCK0node"))) {
[10:25:51.321]                             sendCondition <<- function(cond) {
[10:25:51.321]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.321]                                 success = TRUE)
[10:25:51.321]                               parallel_sendData(master, data)
[10:25:51.321]                             }
[10:25:51.321]                             return(sendCondition)
[10:25:51.321]                           }
[10:25:51.321]                         }
[10:25:51.321]                         frame <- frame + 1L
[10:25:51.321]                         envir <- sys.frame(frame)
[10:25:51.321]                       }
[10:25:51.321]                     }
[10:25:51.321]                     sendCondition <<- function(cond) NULL
[10:25:51.321]                   }
[10:25:51.321]                 })
[10:25:51.321]                 withCallingHandlers({
[10:25:51.321]                   {
[10:25:51.321]                     4
[10:25:51.321]                   }
[10:25:51.321]                 }, immediateCondition = function(cond) {
[10:25:51.321]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.321]                   sendCondition(cond)
[10:25:51.321]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.321]                   {
[10:25:51.321]                     inherits <- base::inherits
[10:25:51.321]                     invokeRestart <- base::invokeRestart
[10:25:51.321]                     is.null <- base::is.null
[10:25:51.321]                     muffled <- FALSE
[10:25:51.321]                     if (inherits(cond, "message")) {
[10:25:51.321]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.321]                       if (muffled) 
[10:25:51.321]                         invokeRestart("muffleMessage")
[10:25:51.321]                     }
[10:25:51.321]                     else if (inherits(cond, "warning")) {
[10:25:51.321]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.321]                       if (muffled) 
[10:25:51.321]                         invokeRestart("muffleWarning")
[10:25:51.321]                     }
[10:25:51.321]                     else if (inherits(cond, "condition")) {
[10:25:51.321]                       if (!is.null(pattern)) {
[10:25:51.321]                         computeRestarts <- base::computeRestarts
[10:25:51.321]                         grepl <- base::grepl
[10:25:51.321]                         restarts <- computeRestarts(cond)
[10:25:51.321]                         for (restart in restarts) {
[10:25:51.321]                           name <- restart$name
[10:25:51.321]                           if (is.null(name)) 
[10:25:51.321]                             next
[10:25:51.321]                           if (!grepl(pattern, name)) 
[10:25:51.321]                             next
[10:25:51.321]                           invokeRestart(restart)
[10:25:51.321]                           muffled <- TRUE
[10:25:51.321]                           break
[10:25:51.321]                         }
[10:25:51.321]                       }
[10:25:51.321]                     }
[10:25:51.321]                     invisible(muffled)
[10:25:51.321]                   }
[10:25:51.321]                   muffleCondition(cond)
[10:25:51.321]                 })
[10:25:51.321]             }))
[10:25:51.321]             future::FutureResult(value = ...future.value$value, 
[10:25:51.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.321]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.321]                     ...future.globalenv.names))
[10:25:51.321]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.321]         }, condition = base::local({
[10:25:51.321]             c <- base::c
[10:25:51.321]             inherits <- base::inherits
[10:25:51.321]             invokeRestart <- base::invokeRestart
[10:25:51.321]             length <- base::length
[10:25:51.321]             list <- base::list
[10:25:51.321]             seq.int <- base::seq.int
[10:25:51.321]             signalCondition <- base::signalCondition
[10:25:51.321]             sys.calls <- base::sys.calls
[10:25:51.321]             `[[` <- base::`[[`
[10:25:51.321]             `+` <- base::`+`
[10:25:51.321]             `<<-` <- base::`<<-`
[10:25:51.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.321]                   3L)]
[10:25:51.321]             }
[10:25:51.321]             function(cond) {
[10:25:51.321]                 is_error <- inherits(cond, "error")
[10:25:51.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.321]                   NULL)
[10:25:51.321]                 if (is_error) {
[10:25:51.321]                   sessionInformation <- function() {
[10:25:51.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.321]                       search = base::search(), system = base::Sys.info())
[10:25:51.321]                   }
[10:25:51.321]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.321]                     cond$call), session = sessionInformation(), 
[10:25:51.321]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.321]                   signalCondition(cond)
[10:25:51.321]                 }
[10:25:51.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.321]                 "immediateCondition"))) {
[10:25:51.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.321]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.321]                   if (TRUE && !signal) {
[10:25:51.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.321]                     {
[10:25:51.321]                       inherits <- base::inherits
[10:25:51.321]                       invokeRestart <- base::invokeRestart
[10:25:51.321]                       is.null <- base::is.null
[10:25:51.321]                       muffled <- FALSE
[10:25:51.321]                       if (inherits(cond, "message")) {
[10:25:51.321]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.321]                         if (muffled) 
[10:25:51.321]                           invokeRestart("muffleMessage")
[10:25:51.321]                       }
[10:25:51.321]                       else if (inherits(cond, "warning")) {
[10:25:51.321]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.321]                         if (muffled) 
[10:25:51.321]                           invokeRestart("muffleWarning")
[10:25:51.321]                       }
[10:25:51.321]                       else if (inherits(cond, "condition")) {
[10:25:51.321]                         if (!is.null(pattern)) {
[10:25:51.321]                           computeRestarts <- base::computeRestarts
[10:25:51.321]                           grepl <- base::grepl
[10:25:51.321]                           restarts <- computeRestarts(cond)
[10:25:51.321]                           for (restart in restarts) {
[10:25:51.321]                             name <- restart$name
[10:25:51.321]                             if (is.null(name)) 
[10:25:51.321]                               next
[10:25:51.321]                             if (!grepl(pattern, name)) 
[10:25:51.321]                               next
[10:25:51.321]                             invokeRestart(restart)
[10:25:51.321]                             muffled <- TRUE
[10:25:51.321]                             break
[10:25:51.321]                           }
[10:25:51.321]                         }
[10:25:51.321]                       }
[10:25:51.321]                       invisible(muffled)
[10:25:51.321]                     }
[10:25:51.321]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.321]                   }
[10:25:51.321]                 }
[10:25:51.321]                 else {
[10:25:51.321]                   if (TRUE) {
[10:25:51.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.321]                     {
[10:25:51.321]                       inherits <- base::inherits
[10:25:51.321]                       invokeRestart <- base::invokeRestart
[10:25:51.321]                       is.null <- base::is.null
[10:25:51.321]                       muffled <- FALSE
[10:25:51.321]                       if (inherits(cond, "message")) {
[10:25:51.321]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.321]                         if (muffled) 
[10:25:51.321]                           invokeRestart("muffleMessage")
[10:25:51.321]                       }
[10:25:51.321]                       else if (inherits(cond, "warning")) {
[10:25:51.321]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.321]                         if (muffled) 
[10:25:51.321]                           invokeRestart("muffleWarning")
[10:25:51.321]                       }
[10:25:51.321]                       else if (inherits(cond, "condition")) {
[10:25:51.321]                         if (!is.null(pattern)) {
[10:25:51.321]                           computeRestarts <- base::computeRestarts
[10:25:51.321]                           grepl <- base::grepl
[10:25:51.321]                           restarts <- computeRestarts(cond)
[10:25:51.321]                           for (restart in restarts) {
[10:25:51.321]                             name <- restart$name
[10:25:51.321]                             if (is.null(name)) 
[10:25:51.321]                               next
[10:25:51.321]                             if (!grepl(pattern, name)) 
[10:25:51.321]                               next
[10:25:51.321]                             invokeRestart(restart)
[10:25:51.321]                             muffled <- TRUE
[10:25:51.321]                             break
[10:25:51.321]                           }
[10:25:51.321]                         }
[10:25:51.321]                       }
[10:25:51.321]                       invisible(muffled)
[10:25:51.321]                     }
[10:25:51.321]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.321]                   }
[10:25:51.321]                 }
[10:25:51.321]             }
[10:25:51.321]         }))
[10:25:51.321]     }, error = function(ex) {
[10:25:51.321]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.321]                 ...future.rng), started = ...future.startTime, 
[10:25:51.321]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.321]             version = "1.8"), class = "FutureResult")
[10:25:51.321]     }, finally = {
[10:25:51.321]         if (!identical(...future.workdir, getwd())) 
[10:25:51.321]             setwd(...future.workdir)
[10:25:51.321]         {
[10:25:51.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.321]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.321]             }
[10:25:51.321]             base::options(...future.oldOptions)
[10:25:51.321]             if (.Platform$OS.type == "windows") {
[10:25:51.321]                 old_names <- names(...future.oldEnvVars)
[10:25:51.321]                 envs <- base::Sys.getenv()
[10:25:51.321]                 names <- names(envs)
[10:25:51.321]                 common <- intersect(names, old_names)
[10:25:51.321]                 added <- setdiff(names, old_names)
[10:25:51.321]                 removed <- setdiff(old_names, names)
[10:25:51.321]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.321]                   envs[common]]
[10:25:51.321]                 NAMES <- toupper(changed)
[10:25:51.321]                 args <- list()
[10:25:51.321]                 for (kk in seq_along(NAMES)) {
[10:25:51.321]                   name <- changed[[kk]]
[10:25:51.321]                   NAME <- NAMES[[kk]]
[10:25:51.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.321]                     next
[10:25:51.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.321]                 }
[10:25:51.321]                 NAMES <- toupper(added)
[10:25:51.321]                 for (kk in seq_along(NAMES)) {
[10:25:51.321]                   name <- added[[kk]]
[10:25:51.321]                   NAME <- NAMES[[kk]]
[10:25:51.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.321]                     next
[10:25:51.321]                   args[[name]] <- ""
[10:25:51.321]                 }
[10:25:51.321]                 NAMES <- toupper(removed)
[10:25:51.321]                 for (kk in seq_along(NAMES)) {
[10:25:51.321]                   name <- removed[[kk]]
[10:25:51.321]                   NAME <- NAMES[[kk]]
[10:25:51.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.321]                     next
[10:25:51.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.321]                 }
[10:25:51.321]                 if (length(args) > 0) 
[10:25:51.321]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.321]             }
[10:25:51.321]             else {
[10:25:51.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.321]             }
[10:25:51.321]             {
[10:25:51.321]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.321]                   0L) {
[10:25:51.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.321]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.321]                   base::options(opts)
[10:25:51.321]                 }
[10:25:51.321]                 {
[10:25:51.321]                   {
[10:25:51.321]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.321]                     NULL
[10:25:51.321]                   }
[10:25:51.321]                   options(future.plan = NULL)
[10:25:51.321]                   if (is.na(NA_character_)) 
[10:25:51.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.321]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.321]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.321]                     envir = parent.frame()) 
[10:25:51.321]                   {
[10:25:51.321]                     if (is.function(workers)) 
[10:25:51.321]                       workers <- workers()
[10:25:51.321]                     workers <- structure(as.integer(workers), 
[10:25:51.321]                       class = class(workers))
[10:25:51.321]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.321]                       workers >= 1)
[10:25:51.321]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.321]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.321]                     }
[10:25:51.321]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.321]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.321]                       envir = envir)
[10:25:51.321]                     if (!future$lazy) 
[10:25:51.321]                       future <- run(future)
[10:25:51.321]                     invisible(future)
[10:25:51.321]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.321]                 }
[10:25:51.321]             }
[10:25:51.321]         }
[10:25:51.321]     })
[10:25:51.321]     if (TRUE) {
[10:25:51.321]         base::sink(type = "output", split = FALSE)
[10:25:51.321]         if (TRUE) {
[10:25:51.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.321]         }
[10:25:51.321]         else {
[10:25:51.321]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.321]         }
[10:25:51.321]         base::close(...future.stdout)
[10:25:51.321]         ...future.stdout <- NULL
[10:25:51.321]     }
[10:25:51.321]     ...future.result$conditions <- ...future.conditions
[10:25:51.321]     ...future.result$finished <- base::Sys.time()
[10:25:51.321]     ...future.result
[10:25:51.321] }
[10:25:51.323] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:51.334] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.335] - Validating connection of MultisessionFuture
[10:25:51.335] - received message: FutureResult
[10:25:51.335] - Received FutureResult
[10:25:51.335] - Erased future from FutureRegistry
[10:25:51.335] result() for ClusterFuture ...
[10:25:51.336] - result already collected: FutureResult
[10:25:51.336] result() for ClusterFuture ... done
[10:25:51.336] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.336] result() for ClusterFuture ...
[10:25:51.336] - result already collected: FutureResult
[10:25:51.336] result() for ClusterFuture ... done
[10:25:51.337] result() for ClusterFuture ...
[10:25:51.337] - result already collected: FutureResult
[10:25:51.337] result() for ClusterFuture ... done
[10:25:51.338] MultisessionFuture started
[10:25:51.338] - Launch lazy future ... done
[10:25:51.338] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f67ac918> 
Classes 'listenv', 'environment' <environment: 0x55c0f53e26b0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:25:51.343] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.343] - Validating connection of MultisessionFuture
[10:25:51.343] - received message: FutureResult
[10:25:51.343] - Received FutureResult
[10:25:51.343] - Erased future from FutureRegistry
[10:25:51.344] result() for ClusterFuture ...
[10:25:51.344] - result already collected: FutureResult
[10:25:51.344] result() for ClusterFuture ... done
[10:25:51.344] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:51.356] resolve() on list environment ...
[10:25:51.357]  recursive: 0
[10:25:51.358]  length: 6
[10:25:51.358]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:51.358] signalConditionsASAP(numeric, pos=1) ...
[10:25:51.358] - nx: 6
[10:25:51.358] - relay: TRUE
[10:25:51.358] - stdout: TRUE
[10:25:51.358] - signal: TRUE
[10:25:51.358] - resignal: FALSE
[10:25:51.358] - force: TRUE
[10:25:51.358] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.358] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.359]  - until=2
[10:25:51.359]  - relaying element #2
[10:25:51.359] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.359] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.359] signalConditionsASAP(NULL, pos=1) ... done
[10:25:51.359]  length: 5 (resolved future 1)
[10:25:51.359] Future #2
[10:25:51.359] result() for ClusterFuture ...
[10:25:51.359] - result already collected: FutureResult
[10:25:51.359] result() for ClusterFuture ... done
[10:25:51.359] result() for ClusterFuture ...
[10:25:51.360] - result already collected: FutureResult
[10:25:51.360] result() for ClusterFuture ... done
[10:25:51.360] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:51.360] - nx: 6
[10:25:51.360] - relay: TRUE
[10:25:51.360] - stdout: TRUE
[10:25:51.360] - signal: TRUE
[10:25:51.360] - resignal: FALSE
[10:25:51.360] - force: TRUE
[10:25:51.360] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.360] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.361]  - until=2
[10:25:51.361]  - relaying element #2
[10:25:51.361] result() for ClusterFuture ...
[10:25:51.361] - result already collected: FutureResult
[10:25:51.361] result() for ClusterFuture ... done
[10:25:51.361] result() for ClusterFuture ...
[10:25:51.361] - result already collected: FutureResult
[10:25:51.361] result() for ClusterFuture ... done
[10:25:51.361] result() for ClusterFuture ...
[10:25:51.361] - result already collected: FutureResult
[10:25:51.361] result() for ClusterFuture ... done
[10:25:51.362] result() for ClusterFuture ...
[10:25:51.362] - result already collected: FutureResult
[10:25:51.362] result() for ClusterFuture ... done
[10:25:51.362] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.362] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.362] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:51.362]  length: 4 (resolved future 2)
[10:25:51.362] Future #3
[10:25:51.362] result() for ClusterFuture ...
[10:25:51.362] - result already collected: FutureResult
[10:25:51.362] result() for ClusterFuture ... done
[10:25:51.363] result() for ClusterFuture ...
[10:25:51.363] - result already collected: FutureResult
[10:25:51.363] result() for ClusterFuture ... done
[10:25:51.363] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:51.363] - nx: 6
[10:25:51.363] - relay: TRUE
[10:25:51.363] - stdout: TRUE
[10:25:51.363] - signal: TRUE
[10:25:51.363] - resignal: FALSE
[10:25:51.363] - force: TRUE
[10:25:51.363] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.364] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.364]  - until=3
[10:25:51.364]  - relaying element #3
[10:25:51.364] result() for ClusterFuture ...
[10:25:51.364] - result already collected: FutureResult
[10:25:51.364] result() for ClusterFuture ... done
[10:25:51.364] result() for ClusterFuture ...
[10:25:51.364] - result already collected: FutureResult
[10:25:51.364] result() for ClusterFuture ... done
[10:25:51.364] result() for ClusterFuture ...
[10:25:51.364] - result already collected: FutureResult
[10:25:51.365] result() for ClusterFuture ... done
[10:25:51.365] result() for ClusterFuture ...
[10:25:51.365] - result already collected: FutureResult
[10:25:51.365] result() for ClusterFuture ... done
[10:25:51.365] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.365] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.365] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:51.365]  length: 3 (resolved future 3)
[10:25:51.376] signalConditionsASAP(NULL, pos=5) ...
[10:25:51.376] - nx: 6
[10:25:51.376] - relay: TRUE
[10:25:51.376] - stdout: TRUE
[10:25:51.376] - signal: TRUE
[10:25:51.376] - resignal: FALSE
[10:25:51.376] - force: TRUE
[10:25:51.377] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.377] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.377]  - until=6
[10:25:51.377]  - relaying element #4
[10:25:51.377]  - relaying element #6
[10:25:51.377] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:25:51.377] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.377] signalConditionsASAP(NULL, pos=5) ... done
[10:25:51.377]  length: 2 (resolved future 5)
[10:25:51.377] signalConditionsASAP(numeric, pos=6) ...
[10:25:51.378] - nx: 6
[10:25:51.378] - relay: TRUE
[10:25:51.378] - stdout: TRUE
[10:25:51.378] - signal: TRUE
[10:25:51.378] - resignal: FALSE
[10:25:51.378] - force: TRUE
[10:25:51.378] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:25:51.378] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.378]  - until=6
[10:25:51.378]  - relaying element #4
[10:25:51.378] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:25:51.378] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.379] signalConditionsASAP(NULL, pos=6) ... done
[10:25:51.379]  length: 1 (resolved future 6)
[10:25:51.389] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.390] - Validating connection of MultisessionFuture
[10:25:51.390] - received message: FutureResult
[10:25:51.390] - Received FutureResult
[10:25:51.390] - Erased future from FutureRegistry
[10:25:51.390] result() for ClusterFuture ...
[10:25:51.390] - result already collected: FutureResult
[10:25:51.390] result() for ClusterFuture ... done
[10:25:51.390] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.390] Future #4
[10:25:51.391] result() for ClusterFuture ...
[10:25:51.391] - result already collected: FutureResult
[10:25:51.391] result() for ClusterFuture ... done
[10:25:51.391] result() for ClusterFuture ...
[10:25:51.391] - result already collected: FutureResult
[10:25:51.391] result() for ClusterFuture ... done
[10:25:51.391] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:51.391] - nx: 6
[10:25:51.391] - relay: TRUE
[10:25:51.391] - stdout: TRUE
[10:25:51.391] - signal: TRUE
[10:25:51.391] - resignal: FALSE
[10:25:51.392] - force: TRUE
[10:25:51.392] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:25:51.392] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.392]  - until=6
[10:25:51.392]  - relaying element #4
[10:25:51.392] result() for ClusterFuture ...
[10:25:51.392] - result already collected: FutureResult
[10:25:51.392] result() for ClusterFuture ... done
[10:25:51.392] result() for ClusterFuture ...
[10:25:51.392] - result already collected: FutureResult
[10:25:51.392] result() for ClusterFuture ... done
[10:25:51.393] result() for ClusterFuture ...
[10:25:51.393] - result already collected: FutureResult
[10:25:51.393] result() for ClusterFuture ... done
[10:25:51.393] result() for ClusterFuture ...
[10:25:51.393] - result already collected: FutureResult
[10:25:51.393] result() for ClusterFuture ... done
[10:25:51.393] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.393] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.393] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:51.393]  length: 0 (resolved future 4)
[10:25:51.393] Relaying remaining futures
[10:25:51.393] signalConditionsASAP(NULL, pos=0) ...
[10:25:51.394] - nx: 6
[10:25:51.394] - relay: TRUE
[10:25:51.394] - stdout: TRUE
[10:25:51.394] - signal: TRUE
[10:25:51.394] - resignal: FALSE
[10:25:51.394] - force: TRUE
[10:25:51.394] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.394] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:51.394] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.394] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.394] signalConditionsASAP(NULL, pos=0) ... done
[10:25:51.395] resolve() on list environment ... DONE
[10:25:51.395] result() for ClusterFuture ...
[10:25:51.395] - result already collected: FutureResult
[10:25:51.395] result() for ClusterFuture ... done
[10:25:51.395] result() for ClusterFuture ...
[10:25:51.395] - result already collected: FutureResult
[10:25:51.395] result() for ClusterFuture ... done
[10:25:51.395] result() for ClusterFuture ...
[10:25:51.395] - result already collected: FutureResult
[10:25:51.395] result() for ClusterFuture ... done
[10:25:51.395] result() for ClusterFuture ...
[10:25:51.396] - result already collected: FutureResult
[10:25:51.396] result() for ClusterFuture ... done
[10:25:51.396] result() for ClusterFuture ...
[10:25:51.396] - result already collected: FutureResult
[10:25:51.396] result() for ClusterFuture ... done
[10:25:51.396] result() for ClusterFuture ...
[10:25:51.396] - result already collected: FutureResult
[10:25:51.396] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f4f3aa28> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:25:51.398] getGlobalsAndPackages() ...
[10:25:51.398] Searching for globals...
[10:25:51.398] 
[10:25:51.399] Searching for globals ... DONE
[10:25:51.399] - globals: [0] <none>
[10:25:51.399] getGlobalsAndPackages() ... DONE
[10:25:51.399] run() for ‘Future’ ...
[10:25:51.399] - state: ‘created’
[10:25:51.399] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.413] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.413]   - Field: ‘node’
[10:25:51.413]   - Field: ‘label’
[10:25:51.413]   - Field: ‘local’
[10:25:51.413]   - Field: ‘owner’
[10:25:51.414]   - Field: ‘envir’
[10:25:51.414]   - Field: ‘workers’
[10:25:51.414]   - Field: ‘packages’
[10:25:51.414]   - Field: ‘gc’
[10:25:51.414]   - Field: ‘conditions’
[10:25:51.414]   - Field: ‘persistent’
[10:25:51.414]   - Field: ‘expr’
[10:25:51.414]   - Field: ‘uuid’
[10:25:51.414]   - Field: ‘seed’
[10:25:51.414]   - Field: ‘version’
[10:25:51.414]   - Field: ‘result’
[10:25:51.415]   - Field: ‘asynchronous’
[10:25:51.415]   - Field: ‘calls’
[10:25:51.415]   - Field: ‘globals’
[10:25:51.415]   - Field: ‘stdout’
[10:25:51.415]   - Field: ‘earlySignal’
[10:25:51.415]   - Field: ‘lazy’
[10:25:51.415]   - Field: ‘state’
[10:25:51.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.415] - Launch lazy future ...
[10:25:51.416] Packages needed by the future expression (n = 0): <none>
[10:25:51.416] Packages needed by future strategies (n = 0): <none>
[10:25:51.416] {
[10:25:51.416]     {
[10:25:51.416]         {
[10:25:51.416]             ...future.startTime <- base::Sys.time()
[10:25:51.416]             {
[10:25:51.416]                 {
[10:25:51.416]                   {
[10:25:51.416]                     {
[10:25:51.416]                       base::local({
[10:25:51.416]                         has_future <- base::requireNamespace("future", 
[10:25:51.416]                           quietly = TRUE)
[10:25:51.416]                         if (has_future) {
[10:25:51.416]                           ns <- base::getNamespace("future")
[10:25:51.416]                           version <- ns[[".package"]][["version"]]
[10:25:51.416]                           if (is.null(version)) 
[10:25:51.416]                             version <- utils::packageVersion("future")
[10:25:51.416]                         }
[10:25:51.416]                         else {
[10:25:51.416]                           version <- NULL
[10:25:51.416]                         }
[10:25:51.416]                         if (!has_future || version < "1.8.0") {
[10:25:51.416]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.416]                             "", base::R.version$version.string), 
[10:25:51.416]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.416]                               "release", "version")], collapse = " "), 
[10:25:51.416]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.416]                             info)
[10:25:51.416]                           info <- base::paste(info, collapse = "; ")
[10:25:51.416]                           if (!has_future) {
[10:25:51.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.416]                               info)
[10:25:51.416]                           }
[10:25:51.416]                           else {
[10:25:51.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.416]                               info, version)
[10:25:51.416]                           }
[10:25:51.416]                           base::stop(msg)
[10:25:51.416]                         }
[10:25:51.416]                       })
[10:25:51.416]                     }
[10:25:51.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.416]                     base::options(mc.cores = 1L)
[10:25:51.416]                   }
[10:25:51.416]                   options(future.plan = NULL)
[10:25:51.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.416]                 }
[10:25:51.416]                 ...future.workdir <- getwd()
[10:25:51.416]             }
[10:25:51.416]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.416]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.416]         }
[10:25:51.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.416]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.416]             base::names(...future.oldOptions))
[10:25:51.416]     }
[10:25:51.416]     if (FALSE) {
[10:25:51.416]     }
[10:25:51.416]     else {
[10:25:51.416]         if (TRUE) {
[10:25:51.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.416]                 open = "w")
[10:25:51.416]         }
[10:25:51.416]         else {
[10:25:51.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.416]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.416]         }
[10:25:51.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.416]             base::sink(type = "output", split = FALSE)
[10:25:51.416]             base::close(...future.stdout)
[10:25:51.416]         }, add = TRUE)
[10:25:51.416]     }
[10:25:51.416]     ...future.frame <- base::sys.nframe()
[10:25:51.416]     ...future.conditions <- base::list()
[10:25:51.416]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.416]     if (FALSE) {
[10:25:51.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.416]     }
[10:25:51.416]     ...future.result <- base::tryCatch({
[10:25:51.416]         base::withCallingHandlers({
[10:25:51.416]             ...future.value <- base::withVisible(base::local({
[10:25:51.416]                 ...future.makeSendCondition <- base::local({
[10:25:51.416]                   sendCondition <- NULL
[10:25:51.416]                   function(frame = 1L) {
[10:25:51.416]                     if (is.function(sendCondition)) 
[10:25:51.416]                       return(sendCondition)
[10:25:51.416]                     ns <- getNamespace("parallel")
[10:25:51.416]                     if (exists("sendData", mode = "function", 
[10:25:51.416]                       envir = ns)) {
[10:25:51.416]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.416]                         envir = ns)
[10:25:51.416]                       envir <- sys.frame(frame)
[10:25:51.416]                       master <- NULL
[10:25:51.416]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.416]                         !identical(envir, emptyenv())) {
[10:25:51.416]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.416]                           inherits = FALSE)) {
[10:25:51.416]                           master <- get("master", mode = "list", 
[10:25:51.416]                             envir = envir, inherits = FALSE)
[10:25:51.416]                           if (inherits(master, c("SOCKnode", 
[10:25:51.416]                             "SOCK0node"))) {
[10:25:51.416]                             sendCondition <<- function(cond) {
[10:25:51.416]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.416]                                 success = TRUE)
[10:25:51.416]                               parallel_sendData(master, data)
[10:25:51.416]                             }
[10:25:51.416]                             return(sendCondition)
[10:25:51.416]                           }
[10:25:51.416]                         }
[10:25:51.416]                         frame <- frame + 1L
[10:25:51.416]                         envir <- sys.frame(frame)
[10:25:51.416]                       }
[10:25:51.416]                     }
[10:25:51.416]                     sendCondition <<- function(cond) NULL
[10:25:51.416]                   }
[10:25:51.416]                 })
[10:25:51.416]                 withCallingHandlers({
[10:25:51.416]                   2
[10:25:51.416]                 }, immediateCondition = function(cond) {
[10:25:51.416]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.416]                   sendCondition(cond)
[10:25:51.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.416]                   {
[10:25:51.416]                     inherits <- base::inherits
[10:25:51.416]                     invokeRestart <- base::invokeRestart
[10:25:51.416]                     is.null <- base::is.null
[10:25:51.416]                     muffled <- FALSE
[10:25:51.416]                     if (inherits(cond, "message")) {
[10:25:51.416]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.416]                       if (muffled) 
[10:25:51.416]                         invokeRestart("muffleMessage")
[10:25:51.416]                     }
[10:25:51.416]                     else if (inherits(cond, "warning")) {
[10:25:51.416]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.416]                       if (muffled) 
[10:25:51.416]                         invokeRestart("muffleWarning")
[10:25:51.416]                     }
[10:25:51.416]                     else if (inherits(cond, "condition")) {
[10:25:51.416]                       if (!is.null(pattern)) {
[10:25:51.416]                         computeRestarts <- base::computeRestarts
[10:25:51.416]                         grepl <- base::grepl
[10:25:51.416]                         restarts <- computeRestarts(cond)
[10:25:51.416]                         for (restart in restarts) {
[10:25:51.416]                           name <- restart$name
[10:25:51.416]                           if (is.null(name)) 
[10:25:51.416]                             next
[10:25:51.416]                           if (!grepl(pattern, name)) 
[10:25:51.416]                             next
[10:25:51.416]                           invokeRestart(restart)
[10:25:51.416]                           muffled <- TRUE
[10:25:51.416]                           break
[10:25:51.416]                         }
[10:25:51.416]                       }
[10:25:51.416]                     }
[10:25:51.416]                     invisible(muffled)
[10:25:51.416]                   }
[10:25:51.416]                   muffleCondition(cond)
[10:25:51.416]                 })
[10:25:51.416]             }))
[10:25:51.416]             future::FutureResult(value = ...future.value$value, 
[10:25:51.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.416]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.416]                     ...future.globalenv.names))
[10:25:51.416]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.416]         }, condition = base::local({
[10:25:51.416]             c <- base::c
[10:25:51.416]             inherits <- base::inherits
[10:25:51.416]             invokeRestart <- base::invokeRestart
[10:25:51.416]             length <- base::length
[10:25:51.416]             list <- base::list
[10:25:51.416]             seq.int <- base::seq.int
[10:25:51.416]             signalCondition <- base::signalCondition
[10:25:51.416]             sys.calls <- base::sys.calls
[10:25:51.416]             `[[` <- base::`[[`
[10:25:51.416]             `+` <- base::`+`
[10:25:51.416]             `<<-` <- base::`<<-`
[10:25:51.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.416]                   3L)]
[10:25:51.416]             }
[10:25:51.416]             function(cond) {
[10:25:51.416]                 is_error <- inherits(cond, "error")
[10:25:51.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.416]                   NULL)
[10:25:51.416]                 if (is_error) {
[10:25:51.416]                   sessionInformation <- function() {
[10:25:51.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.416]                       search = base::search(), system = base::Sys.info())
[10:25:51.416]                   }
[10:25:51.416]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.416]                     cond$call), session = sessionInformation(), 
[10:25:51.416]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.416]                   signalCondition(cond)
[10:25:51.416]                 }
[10:25:51.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.416]                 "immediateCondition"))) {
[10:25:51.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.416]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.416]                   if (TRUE && !signal) {
[10:25:51.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.416]                     {
[10:25:51.416]                       inherits <- base::inherits
[10:25:51.416]                       invokeRestart <- base::invokeRestart
[10:25:51.416]                       is.null <- base::is.null
[10:25:51.416]                       muffled <- FALSE
[10:25:51.416]                       if (inherits(cond, "message")) {
[10:25:51.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.416]                         if (muffled) 
[10:25:51.416]                           invokeRestart("muffleMessage")
[10:25:51.416]                       }
[10:25:51.416]                       else if (inherits(cond, "warning")) {
[10:25:51.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.416]                         if (muffled) 
[10:25:51.416]                           invokeRestart("muffleWarning")
[10:25:51.416]                       }
[10:25:51.416]                       else if (inherits(cond, "condition")) {
[10:25:51.416]                         if (!is.null(pattern)) {
[10:25:51.416]                           computeRestarts <- base::computeRestarts
[10:25:51.416]                           grepl <- base::grepl
[10:25:51.416]                           restarts <- computeRestarts(cond)
[10:25:51.416]                           for (restart in restarts) {
[10:25:51.416]                             name <- restart$name
[10:25:51.416]                             if (is.null(name)) 
[10:25:51.416]                               next
[10:25:51.416]                             if (!grepl(pattern, name)) 
[10:25:51.416]                               next
[10:25:51.416]                             invokeRestart(restart)
[10:25:51.416]                             muffled <- TRUE
[10:25:51.416]                             break
[10:25:51.416]                           }
[10:25:51.416]                         }
[10:25:51.416]                       }
[10:25:51.416]                       invisible(muffled)
[10:25:51.416]                     }
[10:25:51.416]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.416]                   }
[10:25:51.416]                 }
[10:25:51.416]                 else {
[10:25:51.416]                   if (TRUE) {
[10:25:51.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.416]                     {
[10:25:51.416]                       inherits <- base::inherits
[10:25:51.416]                       invokeRestart <- base::invokeRestart
[10:25:51.416]                       is.null <- base::is.null
[10:25:51.416]                       muffled <- FALSE
[10:25:51.416]                       if (inherits(cond, "message")) {
[10:25:51.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.416]                         if (muffled) 
[10:25:51.416]                           invokeRestart("muffleMessage")
[10:25:51.416]                       }
[10:25:51.416]                       else if (inherits(cond, "warning")) {
[10:25:51.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.416]                         if (muffled) 
[10:25:51.416]                           invokeRestart("muffleWarning")
[10:25:51.416]                       }
[10:25:51.416]                       else if (inherits(cond, "condition")) {
[10:25:51.416]                         if (!is.null(pattern)) {
[10:25:51.416]                           computeRestarts <- base::computeRestarts
[10:25:51.416]                           grepl <- base::grepl
[10:25:51.416]                           restarts <- computeRestarts(cond)
[10:25:51.416]                           for (restart in restarts) {
[10:25:51.416]                             name <- restart$name
[10:25:51.416]                             if (is.null(name)) 
[10:25:51.416]                               next
[10:25:51.416]                             if (!grepl(pattern, name)) 
[10:25:51.416]                               next
[10:25:51.416]                             invokeRestart(restart)
[10:25:51.416]                             muffled <- TRUE
[10:25:51.416]                             break
[10:25:51.416]                           }
[10:25:51.416]                         }
[10:25:51.416]                       }
[10:25:51.416]                       invisible(muffled)
[10:25:51.416]                     }
[10:25:51.416]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.416]                   }
[10:25:51.416]                 }
[10:25:51.416]             }
[10:25:51.416]         }))
[10:25:51.416]     }, error = function(ex) {
[10:25:51.416]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.416]                 ...future.rng), started = ...future.startTime, 
[10:25:51.416]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.416]             version = "1.8"), class = "FutureResult")
[10:25:51.416]     }, finally = {
[10:25:51.416]         if (!identical(...future.workdir, getwd())) 
[10:25:51.416]             setwd(...future.workdir)
[10:25:51.416]         {
[10:25:51.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.416]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.416]             }
[10:25:51.416]             base::options(...future.oldOptions)
[10:25:51.416]             if (.Platform$OS.type == "windows") {
[10:25:51.416]                 old_names <- names(...future.oldEnvVars)
[10:25:51.416]                 envs <- base::Sys.getenv()
[10:25:51.416]                 names <- names(envs)
[10:25:51.416]                 common <- intersect(names, old_names)
[10:25:51.416]                 added <- setdiff(names, old_names)
[10:25:51.416]                 removed <- setdiff(old_names, names)
[10:25:51.416]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.416]                   envs[common]]
[10:25:51.416]                 NAMES <- toupper(changed)
[10:25:51.416]                 args <- list()
[10:25:51.416]                 for (kk in seq_along(NAMES)) {
[10:25:51.416]                   name <- changed[[kk]]
[10:25:51.416]                   NAME <- NAMES[[kk]]
[10:25:51.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.416]                     next
[10:25:51.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.416]                 }
[10:25:51.416]                 NAMES <- toupper(added)
[10:25:51.416]                 for (kk in seq_along(NAMES)) {
[10:25:51.416]                   name <- added[[kk]]
[10:25:51.416]                   NAME <- NAMES[[kk]]
[10:25:51.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.416]                     next
[10:25:51.416]                   args[[name]] <- ""
[10:25:51.416]                 }
[10:25:51.416]                 NAMES <- toupper(removed)
[10:25:51.416]                 for (kk in seq_along(NAMES)) {
[10:25:51.416]                   name <- removed[[kk]]
[10:25:51.416]                   NAME <- NAMES[[kk]]
[10:25:51.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.416]                     next
[10:25:51.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.416]                 }
[10:25:51.416]                 if (length(args) > 0) 
[10:25:51.416]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.416]             }
[10:25:51.416]             else {
[10:25:51.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.416]             }
[10:25:51.416]             {
[10:25:51.416]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.416]                   0L) {
[10:25:51.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.416]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.416]                   base::options(opts)
[10:25:51.416]                 }
[10:25:51.416]                 {
[10:25:51.416]                   {
[10:25:51.416]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.416]                     NULL
[10:25:51.416]                   }
[10:25:51.416]                   options(future.plan = NULL)
[10:25:51.416]                   if (is.na(NA_character_)) 
[10:25:51.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.416]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.416]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.416]                     envir = parent.frame()) 
[10:25:51.416]                   {
[10:25:51.416]                     if (is.function(workers)) 
[10:25:51.416]                       workers <- workers()
[10:25:51.416]                     workers <- structure(as.integer(workers), 
[10:25:51.416]                       class = class(workers))
[10:25:51.416]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.416]                       workers >= 1)
[10:25:51.416]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.416]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.416]                     }
[10:25:51.416]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.416]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.416]                       envir = envir)
[10:25:51.416]                     if (!future$lazy) 
[10:25:51.416]                       future <- run(future)
[10:25:51.416]                     invisible(future)
[10:25:51.416]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.416]                 }
[10:25:51.416]             }
[10:25:51.416]         }
[10:25:51.416]     })
[10:25:51.416]     if (TRUE) {
[10:25:51.416]         base::sink(type = "output", split = FALSE)
[10:25:51.416]         if (TRUE) {
[10:25:51.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.416]         }
[10:25:51.416]         else {
[10:25:51.416]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.416]         }
[10:25:51.416]         base::close(...future.stdout)
[10:25:51.416]         ...future.stdout <- NULL
[10:25:51.416]     }
[10:25:51.416]     ...future.result$conditions <- ...future.conditions
[10:25:51.416]     ...future.result$finished <- base::Sys.time()
[10:25:51.416]     ...future.result
[10:25:51.416] }
[10:25:51.419] MultisessionFuture started
[10:25:51.419] - Launch lazy future ... done
[10:25:51.419] run() for ‘MultisessionFuture’ ... done
[10:25:51.419] getGlobalsAndPackages() ...
[10:25:51.420] Searching for globals...
[10:25:51.420] 
[10:25:51.420] Searching for globals ... DONE
[10:25:51.420] - globals: [0] <none>
[10:25:51.420] getGlobalsAndPackages() ... DONE
[10:25:51.420] run() for ‘Future’ ...
[10:25:51.420] - state: ‘created’
[10:25:51.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.434] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.434]   - Field: ‘node’
[10:25:51.435]   - Field: ‘label’
[10:25:51.435]   - Field: ‘local’
[10:25:51.435]   - Field: ‘owner’
[10:25:51.435]   - Field: ‘envir’
[10:25:51.435]   - Field: ‘workers’
[10:25:51.435]   - Field: ‘packages’
[10:25:51.435]   - Field: ‘gc’
[10:25:51.435]   - Field: ‘conditions’
[10:25:51.435]   - Field: ‘persistent’
[10:25:51.435]   - Field: ‘expr’
[10:25:51.436]   - Field: ‘uuid’
[10:25:51.436]   - Field: ‘seed’
[10:25:51.436]   - Field: ‘version’
[10:25:51.436]   - Field: ‘result’
[10:25:51.436]   - Field: ‘asynchronous’
[10:25:51.436]   - Field: ‘calls’
[10:25:51.436]   - Field: ‘globals’
[10:25:51.436]   - Field: ‘stdout’
[10:25:51.436]   - Field: ‘earlySignal’
[10:25:51.436]   - Field: ‘lazy’
[10:25:51.436]   - Field: ‘state’
[10:25:51.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.437] - Launch lazy future ...
[10:25:51.437] Packages needed by the future expression (n = 0): <none>
[10:25:51.437] Packages needed by future strategies (n = 0): <none>
[10:25:51.437] {
[10:25:51.437]     {
[10:25:51.437]         {
[10:25:51.437]             ...future.startTime <- base::Sys.time()
[10:25:51.437]             {
[10:25:51.437]                 {
[10:25:51.437]                   {
[10:25:51.437]                     {
[10:25:51.437]                       base::local({
[10:25:51.437]                         has_future <- base::requireNamespace("future", 
[10:25:51.437]                           quietly = TRUE)
[10:25:51.437]                         if (has_future) {
[10:25:51.437]                           ns <- base::getNamespace("future")
[10:25:51.437]                           version <- ns[[".package"]][["version"]]
[10:25:51.437]                           if (is.null(version)) 
[10:25:51.437]                             version <- utils::packageVersion("future")
[10:25:51.437]                         }
[10:25:51.437]                         else {
[10:25:51.437]                           version <- NULL
[10:25:51.437]                         }
[10:25:51.437]                         if (!has_future || version < "1.8.0") {
[10:25:51.437]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.437]                             "", base::R.version$version.string), 
[10:25:51.437]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.437]                               "release", "version")], collapse = " "), 
[10:25:51.437]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.437]                             info)
[10:25:51.437]                           info <- base::paste(info, collapse = "; ")
[10:25:51.437]                           if (!has_future) {
[10:25:51.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.437]                               info)
[10:25:51.437]                           }
[10:25:51.437]                           else {
[10:25:51.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.437]                               info, version)
[10:25:51.437]                           }
[10:25:51.437]                           base::stop(msg)
[10:25:51.437]                         }
[10:25:51.437]                       })
[10:25:51.437]                     }
[10:25:51.437]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.437]                     base::options(mc.cores = 1L)
[10:25:51.437]                   }
[10:25:51.437]                   options(future.plan = NULL)
[10:25:51.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.437]                 }
[10:25:51.437]                 ...future.workdir <- getwd()
[10:25:51.437]             }
[10:25:51.437]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.437]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.437]         }
[10:25:51.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.437]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.437]             base::names(...future.oldOptions))
[10:25:51.437]     }
[10:25:51.437]     if (FALSE) {
[10:25:51.437]     }
[10:25:51.437]     else {
[10:25:51.437]         if (TRUE) {
[10:25:51.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.437]                 open = "w")
[10:25:51.437]         }
[10:25:51.437]         else {
[10:25:51.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.437]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.437]         }
[10:25:51.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.437]             base::sink(type = "output", split = FALSE)
[10:25:51.437]             base::close(...future.stdout)
[10:25:51.437]         }, add = TRUE)
[10:25:51.437]     }
[10:25:51.437]     ...future.frame <- base::sys.nframe()
[10:25:51.437]     ...future.conditions <- base::list()
[10:25:51.437]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.437]     if (FALSE) {
[10:25:51.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.437]     }
[10:25:51.437]     ...future.result <- base::tryCatch({
[10:25:51.437]         base::withCallingHandlers({
[10:25:51.437]             ...future.value <- base::withVisible(base::local({
[10:25:51.437]                 ...future.makeSendCondition <- base::local({
[10:25:51.437]                   sendCondition <- NULL
[10:25:51.437]                   function(frame = 1L) {
[10:25:51.437]                     if (is.function(sendCondition)) 
[10:25:51.437]                       return(sendCondition)
[10:25:51.437]                     ns <- getNamespace("parallel")
[10:25:51.437]                     if (exists("sendData", mode = "function", 
[10:25:51.437]                       envir = ns)) {
[10:25:51.437]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.437]                         envir = ns)
[10:25:51.437]                       envir <- sys.frame(frame)
[10:25:51.437]                       master <- NULL
[10:25:51.437]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.437]                         !identical(envir, emptyenv())) {
[10:25:51.437]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.437]                           inherits = FALSE)) {
[10:25:51.437]                           master <- get("master", mode = "list", 
[10:25:51.437]                             envir = envir, inherits = FALSE)
[10:25:51.437]                           if (inherits(master, c("SOCKnode", 
[10:25:51.437]                             "SOCK0node"))) {
[10:25:51.437]                             sendCondition <<- function(cond) {
[10:25:51.437]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.437]                                 success = TRUE)
[10:25:51.437]                               parallel_sendData(master, data)
[10:25:51.437]                             }
[10:25:51.437]                             return(sendCondition)
[10:25:51.437]                           }
[10:25:51.437]                         }
[10:25:51.437]                         frame <- frame + 1L
[10:25:51.437]                         envir <- sys.frame(frame)
[10:25:51.437]                       }
[10:25:51.437]                     }
[10:25:51.437]                     sendCondition <<- function(cond) NULL
[10:25:51.437]                   }
[10:25:51.437]                 })
[10:25:51.437]                 withCallingHandlers({
[10:25:51.437]                   NULL
[10:25:51.437]                 }, immediateCondition = function(cond) {
[10:25:51.437]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.437]                   sendCondition(cond)
[10:25:51.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.437]                   {
[10:25:51.437]                     inherits <- base::inherits
[10:25:51.437]                     invokeRestart <- base::invokeRestart
[10:25:51.437]                     is.null <- base::is.null
[10:25:51.437]                     muffled <- FALSE
[10:25:51.437]                     if (inherits(cond, "message")) {
[10:25:51.437]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.437]                       if (muffled) 
[10:25:51.437]                         invokeRestart("muffleMessage")
[10:25:51.437]                     }
[10:25:51.437]                     else if (inherits(cond, "warning")) {
[10:25:51.437]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.437]                       if (muffled) 
[10:25:51.437]                         invokeRestart("muffleWarning")
[10:25:51.437]                     }
[10:25:51.437]                     else if (inherits(cond, "condition")) {
[10:25:51.437]                       if (!is.null(pattern)) {
[10:25:51.437]                         computeRestarts <- base::computeRestarts
[10:25:51.437]                         grepl <- base::grepl
[10:25:51.437]                         restarts <- computeRestarts(cond)
[10:25:51.437]                         for (restart in restarts) {
[10:25:51.437]                           name <- restart$name
[10:25:51.437]                           if (is.null(name)) 
[10:25:51.437]                             next
[10:25:51.437]                           if (!grepl(pattern, name)) 
[10:25:51.437]                             next
[10:25:51.437]                           invokeRestart(restart)
[10:25:51.437]                           muffled <- TRUE
[10:25:51.437]                           break
[10:25:51.437]                         }
[10:25:51.437]                       }
[10:25:51.437]                     }
[10:25:51.437]                     invisible(muffled)
[10:25:51.437]                   }
[10:25:51.437]                   muffleCondition(cond)
[10:25:51.437]                 })
[10:25:51.437]             }))
[10:25:51.437]             future::FutureResult(value = ...future.value$value, 
[10:25:51.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.437]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.437]                     ...future.globalenv.names))
[10:25:51.437]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.437]         }, condition = base::local({
[10:25:51.437]             c <- base::c
[10:25:51.437]             inherits <- base::inherits
[10:25:51.437]             invokeRestart <- base::invokeRestart
[10:25:51.437]             length <- base::length
[10:25:51.437]             list <- base::list
[10:25:51.437]             seq.int <- base::seq.int
[10:25:51.437]             signalCondition <- base::signalCondition
[10:25:51.437]             sys.calls <- base::sys.calls
[10:25:51.437]             `[[` <- base::`[[`
[10:25:51.437]             `+` <- base::`+`
[10:25:51.437]             `<<-` <- base::`<<-`
[10:25:51.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.437]                   3L)]
[10:25:51.437]             }
[10:25:51.437]             function(cond) {
[10:25:51.437]                 is_error <- inherits(cond, "error")
[10:25:51.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.437]                   NULL)
[10:25:51.437]                 if (is_error) {
[10:25:51.437]                   sessionInformation <- function() {
[10:25:51.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.437]                       search = base::search(), system = base::Sys.info())
[10:25:51.437]                   }
[10:25:51.437]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.437]                     cond$call), session = sessionInformation(), 
[10:25:51.437]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.437]                   signalCondition(cond)
[10:25:51.437]                 }
[10:25:51.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.437]                 "immediateCondition"))) {
[10:25:51.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.437]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.437]                   if (TRUE && !signal) {
[10:25:51.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.437]                     {
[10:25:51.437]                       inherits <- base::inherits
[10:25:51.437]                       invokeRestart <- base::invokeRestart
[10:25:51.437]                       is.null <- base::is.null
[10:25:51.437]                       muffled <- FALSE
[10:25:51.437]                       if (inherits(cond, "message")) {
[10:25:51.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.437]                         if (muffled) 
[10:25:51.437]                           invokeRestart("muffleMessage")
[10:25:51.437]                       }
[10:25:51.437]                       else if (inherits(cond, "warning")) {
[10:25:51.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.437]                         if (muffled) 
[10:25:51.437]                           invokeRestart("muffleWarning")
[10:25:51.437]                       }
[10:25:51.437]                       else if (inherits(cond, "condition")) {
[10:25:51.437]                         if (!is.null(pattern)) {
[10:25:51.437]                           computeRestarts <- base::computeRestarts
[10:25:51.437]                           grepl <- base::grepl
[10:25:51.437]                           restarts <- computeRestarts(cond)
[10:25:51.437]                           for (restart in restarts) {
[10:25:51.437]                             name <- restart$name
[10:25:51.437]                             if (is.null(name)) 
[10:25:51.437]                               next
[10:25:51.437]                             if (!grepl(pattern, name)) 
[10:25:51.437]                               next
[10:25:51.437]                             invokeRestart(restart)
[10:25:51.437]                             muffled <- TRUE
[10:25:51.437]                             break
[10:25:51.437]                           }
[10:25:51.437]                         }
[10:25:51.437]                       }
[10:25:51.437]                       invisible(muffled)
[10:25:51.437]                     }
[10:25:51.437]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.437]                   }
[10:25:51.437]                 }
[10:25:51.437]                 else {
[10:25:51.437]                   if (TRUE) {
[10:25:51.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.437]                     {
[10:25:51.437]                       inherits <- base::inherits
[10:25:51.437]                       invokeRestart <- base::invokeRestart
[10:25:51.437]                       is.null <- base::is.null
[10:25:51.437]                       muffled <- FALSE
[10:25:51.437]                       if (inherits(cond, "message")) {
[10:25:51.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.437]                         if (muffled) 
[10:25:51.437]                           invokeRestart("muffleMessage")
[10:25:51.437]                       }
[10:25:51.437]                       else if (inherits(cond, "warning")) {
[10:25:51.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.437]                         if (muffled) 
[10:25:51.437]                           invokeRestart("muffleWarning")
[10:25:51.437]                       }
[10:25:51.437]                       else if (inherits(cond, "condition")) {
[10:25:51.437]                         if (!is.null(pattern)) {
[10:25:51.437]                           computeRestarts <- base::computeRestarts
[10:25:51.437]                           grepl <- base::grepl
[10:25:51.437]                           restarts <- computeRestarts(cond)
[10:25:51.437]                           for (restart in restarts) {
[10:25:51.437]                             name <- restart$name
[10:25:51.437]                             if (is.null(name)) 
[10:25:51.437]                               next
[10:25:51.437]                             if (!grepl(pattern, name)) 
[10:25:51.437]                               next
[10:25:51.437]                             invokeRestart(restart)
[10:25:51.437]                             muffled <- TRUE
[10:25:51.437]                             break
[10:25:51.437]                           }
[10:25:51.437]                         }
[10:25:51.437]                       }
[10:25:51.437]                       invisible(muffled)
[10:25:51.437]                     }
[10:25:51.437]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.437]                   }
[10:25:51.437]                 }
[10:25:51.437]             }
[10:25:51.437]         }))
[10:25:51.437]     }, error = function(ex) {
[10:25:51.437]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.437]                 ...future.rng), started = ...future.startTime, 
[10:25:51.437]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.437]             version = "1.8"), class = "FutureResult")
[10:25:51.437]     }, finally = {
[10:25:51.437]         if (!identical(...future.workdir, getwd())) 
[10:25:51.437]             setwd(...future.workdir)
[10:25:51.437]         {
[10:25:51.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.437]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.437]             }
[10:25:51.437]             base::options(...future.oldOptions)
[10:25:51.437]             if (.Platform$OS.type == "windows") {
[10:25:51.437]                 old_names <- names(...future.oldEnvVars)
[10:25:51.437]                 envs <- base::Sys.getenv()
[10:25:51.437]                 names <- names(envs)
[10:25:51.437]                 common <- intersect(names, old_names)
[10:25:51.437]                 added <- setdiff(names, old_names)
[10:25:51.437]                 removed <- setdiff(old_names, names)
[10:25:51.437]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.437]                   envs[common]]
[10:25:51.437]                 NAMES <- toupper(changed)
[10:25:51.437]                 args <- list()
[10:25:51.437]                 for (kk in seq_along(NAMES)) {
[10:25:51.437]                   name <- changed[[kk]]
[10:25:51.437]                   NAME <- NAMES[[kk]]
[10:25:51.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.437]                     next
[10:25:51.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.437]                 }
[10:25:51.437]                 NAMES <- toupper(added)
[10:25:51.437]                 for (kk in seq_along(NAMES)) {
[10:25:51.437]                   name <- added[[kk]]
[10:25:51.437]                   NAME <- NAMES[[kk]]
[10:25:51.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.437]                     next
[10:25:51.437]                   args[[name]] <- ""
[10:25:51.437]                 }
[10:25:51.437]                 NAMES <- toupper(removed)
[10:25:51.437]                 for (kk in seq_along(NAMES)) {
[10:25:51.437]                   name <- removed[[kk]]
[10:25:51.437]                   NAME <- NAMES[[kk]]
[10:25:51.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.437]                     next
[10:25:51.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.437]                 }
[10:25:51.437]                 if (length(args) > 0) 
[10:25:51.437]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.437]             }
[10:25:51.437]             else {
[10:25:51.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.437]             }
[10:25:51.437]             {
[10:25:51.437]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.437]                   0L) {
[10:25:51.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.437]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.437]                   base::options(opts)
[10:25:51.437]                 }
[10:25:51.437]                 {
[10:25:51.437]                   {
[10:25:51.437]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.437]                     NULL
[10:25:51.437]                   }
[10:25:51.437]                   options(future.plan = NULL)
[10:25:51.437]                   if (is.na(NA_character_)) 
[10:25:51.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.437]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.437]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.437]                     envir = parent.frame()) 
[10:25:51.437]                   {
[10:25:51.437]                     if (is.function(workers)) 
[10:25:51.437]                       workers <- workers()
[10:25:51.437]                     workers <- structure(as.integer(workers), 
[10:25:51.437]                       class = class(workers))
[10:25:51.437]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.437]                       workers >= 1)
[10:25:51.437]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.437]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.437]                     }
[10:25:51.437]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.437]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.437]                       envir = envir)
[10:25:51.437]                     if (!future$lazy) 
[10:25:51.437]                       future <- run(future)
[10:25:51.437]                     invisible(future)
[10:25:51.437]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.437]                 }
[10:25:51.437]             }
[10:25:51.437]         }
[10:25:51.437]     })
[10:25:51.437]     if (TRUE) {
[10:25:51.437]         base::sink(type = "output", split = FALSE)
[10:25:51.437]         if (TRUE) {
[10:25:51.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.437]         }
[10:25:51.437]         else {
[10:25:51.437]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.437]         }
[10:25:51.437]         base::close(...future.stdout)
[10:25:51.437]         ...future.stdout <- NULL
[10:25:51.437]     }
[10:25:51.437]     ...future.result$conditions <- ...future.conditions
[10:25:51.437]     ...future.result$finished <- base::Sys.time()
[10:25:51.437]     ...future.result
[10:25:51.437] }
[10:25:51.441] MultisessionFuture started
[10:25:51.441] - Launch lazy future ... done
[10:25:51.441] run() for ‘MultisessionFuture’ ... done
[10:25:51.441] getGlobalsAndPackages() ...
[10:25:51.441] Searching for globals...
[10:25:51.442] - globals found: [1] ‘{’
[10:25:51.442] Searching for globals ... DONE
[10:25:51.442] Resolving globals: FALSE
[10:25:51.443] 
[10:25:51.443] 
[10:25:51.443] getGlobalsAndPackages() ... DONE
[10:25:51.443] run() for ‘Future’ ...
[10:25:51.443] - state: ‘created’
[10:25:51.443] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.457] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.457]   - Field: ‘node’
[10:25:51.457]   - Field: ‘label’
[10:25:51.457]   - Field: ‘local’
[10:25:51.457]   - Field: ‘owner’
[10:25:51.457]   - Field: ‘envir’
[10:25:51.457]   - Field: ‘workers’
[10:25:51.458]   - Field: ‘packages’
[10:25:51.458]   - Field: ‘gc’
[10:25:51.458]   - Field: ‘conditions’
[10:25:51.458]   - Field: ‘persistent’
[10:25:51.458]   - Field: ‘expr’
[10:25:51.458]   - Field: ‘uuid’
[10:25:51.458]   - Field: ‘seed’
[10:25:51.458]   - Field: ‘version’
[10:25:51.458]   - Field: ‘result’
[10:25:51.458]   - Field: ‘asynchronous’
[10:25:51.458]   - Field: ‘calls’
[10:25:51.459]   - Field: ‘globals’
[10:25:51.459]   - Field: ‘stdout’
[10:25:51.459]   - Field: ‘earlySignal’
[10:25:51.459]   - Field: ‘lazy’
[10:25:51.459]   - Field: ‘state’
[10:25:51.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.459] - Launch lazy future ...
[10:25:51.459] Packages needed by the future expression (n = 0): <none>
[10:25:51.459] Packages needed by future strategies (n = 0): <none>
[10:25:51.460] {
[10:25:51.460]     {
[10:25:51.460]         {
[10:25:51.460]             ...future.startTime <- base::Sys.time()
[10:25:51.460]             {
[10:25:51.460]                 {
[10:25:51.460]                   {
[10:25:51.460]                     {
[10:25:51.460]                       base::local({
[10:25:51.460]                         has_future <- base::requireNamespace("future", 
[10:25:51.460]                           quietly = TRUE)
[10:25:51.460]                         if (has_future) {
[10:25:51.460]                           ns <- base::getNamespace("future")
[10:25:51.460]                           version <- ns[[".package"]][["version"]]
[10:25:51.460]                           if (is.null(version)) 
[10:25:51.460]                             version <- utils::packageVersion("future")
[10:25:51.460]                         }
[10:25:51.460]                         else {
[10:25:51.460]                           version <- NULL
[10:25:51.460]                         }
[10:25:51.460]                         if (!has_future || version < "1.8.0") {
[10:25:51.460]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.460]                             "", base::R.version$version.string), 
[10:25:51.460]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.460]                               "release", "version")], collapse = " "), 
[10:25:51.460]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.460]                             info)
[10:25:51.460]                           info <- base::paste(info, collapse = "; ")
[10:25:51.460]                           if (!has_future) {
[10:25:51.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.460]                               info)
[10:25:51.460]                           }
[10:25:51.460]                           else {
[10:25:51.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.460]                               info, version)
[10:25:51.460]                           }
[10:25:51.460]                           base::stop(msg)
[10:25:51.460]                         }
[10:25:51.460]                       })
[10:25:51.460]                     }
[10:25:51.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.460]                     base::options(mc.cores = 1L)
[10:25:51.460]                   }
[10:25:51.460]                   options(future.plan = NULL)
[10:25:51.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.460]                 }
[10:25:51.460]                 ...future.workdir <- getwd()
[10:25:51.460]             }
[10:25:51.460]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.460]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.460]         }
[10:25:51.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.460]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.460]             base::names(...future.oldOptions))
[10:25:51.460]     }
[10:25:51.460]     if (FALSE) {
[10:25:51.460]     }
[10:25:51.460]     else {
[10:25:51.460]         if (TRUE) {
[10:25:51.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.460]                 open = "w")
[10:25:51.460]         }
[10:25:51.460]         else {
[10:25:51.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.460]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.460]         }
[10:25:51.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.460]             base::sink(type = "output", split = FALSE)
[10:25:51.460]             base::close(...future.stdout)
[10:25:51.460]         }, add = TRUE)
[10:25:51.460]     }
[10:25:51.460]     ...future.frame <- base::sys.nframe()
[10:25:51.460]     ...future.conditions <- base::list()
[10:25:51.460]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.460]     if (FALSE) {
[10:25:51.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.460]     }
[10:25:51.460]     ...future.result <- base::tryCatch({
[10:25:51.460]         base::withCallingHandlers({
[10:25:51.460]             ...future.value <- base::withVisible(base::local({
[10:25:51.460]                 ...future.makeSendCondition <- base::local({
[10:25:51.460]                   sendCondition <- NULL
[10:25:51.460]                   function(frame = 1L) {
[10:25:51.460]                     if (is.function(sendCondition)) 
[10:25:51.460]                       return(sendCondition)
[10:25:51.460]                     ns <- getNamespace("parallel")
[10:25:51.460]                     if (exists("sendData", mode = "function", 
[10:25:51.460]                       envir = ns)) {
[10:25:51.460]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.460]                         envir = ns)
[10:25:51.460]                       envir <- sys.frame(frame)
[10:25:51.460]                       master <- NULL
[10:25:51.460]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.460]                         !identical(envir, emptyenv())) {
[10:25:51.460]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.460]                           inherits = FALSE)) {
[10:25:51.460]                           master <- get("master", mode = "list", 
[10:25:51.460]                             envir = envir, inherits = FALSE)
[10:25:51.460]                           if (inherits(master, c("SOCKnode", 
[10:25:51.460]                             "SOCK0node"))) {
[10:25:51.460]                             sendCondition <<- function(cond) {
[10:25:51.460]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.460]                                 success = TRUE)
[10:25:51.460]                               parallel_sendData(master, data)
[10:25:51.460]                             }
[10:25:51.460]                             return(sendCondition)
[10:25:51.460]                           }
[10:25:51.460]                         }
[10:25:51.460]                         frame <- frame + 1L
[10:25:51.460]                         envir <- sys.frame(frame)
[10:25:51.460]                       }
[10:25:51.460]                     }
[10:25:51.460]                     sendCondition <<- function(cond) NULL
[10:25:51.460]                   }
[10:25:51.460]                 })
[10:25:51.460]                 withCallingHandlers({
[10:25:51.460]                   {
[10:25:51.460]                     4
[10:25:51.460]                   }
[10:25:51.460]                 }, immediateCondition = function(cond) {
[10:25:51.460]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.460]                   sendCondition(cond)
[10:25:51.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.460]                   {
[10:25:51.460]                     inherits <- base::inherits
[10:25:51.460]                     invokeRestart <- base::invokeRestart
[10:25:51.460]                     is.null <- base::is.null
[10:25:51.460]                     muffled <- FALSE
[10:25:51.460]                     if (inherits(cond, "message")) {
[10:25:51.460]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.460]                       if (muffled) 
[10:25:51.460]                         invokeRestart("muffleMessage")
[10:25:51.460]                     }
[10:25:51.460]                     else if (inherits(cond, "warning")) {
[10:25:51.460]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.460]                       if (muffled) 
[10:25:51.460]                         invokeRestart("muffleWarning")
[10:25:51.460]                     }
[10:25:51.460]                     else if (inherits(cond, "condition")) {
[10:25:51.460]                       if (!is.null(pattern)) {
[10:25:51.460]                         computeRestarts <- base::computeRestarts
[10:25:51.460]                         grepl <- base::grepl
[10:25:51.460]                         restarts <- computeRestarts(cond)
[10:25:51.460]                         for (restart in restarts) {
[10:25:51.460]                           name <- restart$name
[10:25:51.460]                           if (is.null(name)) 
[10:25:51.460]                             next
[10:25:51.460]                           if (!grepl(pattern, name)) 
[10:25:51.460]                             next
[10:25:51.460]                           invokeRestart(restart)
[10:25:51.460]                           muffled <- TRUE
[10:25:51.460]                           break
[10:25:51.460]                         }
[10:25:51.460]                       }
[10:25:51.460]                     }
[10:25:51.460]                     invisible(muffled)
[10:25:51.460]                   }
[10:25:51.460]                   muffleCondition(cond)
[10:25:51.460]                 })
[10:25:51.460]             }))
[10:25:51.460]             future::FutureResult(value = ...future.value$value, 
[10:25:51.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.460]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.460]                     ...future.globalenv.names))
[10:25:51.460]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.460]         }, condition = base::local({
[10:25:51.460]             c <- base::c
[10:25:51.460]             inherits <- base::inherits
[10:25:51.460]             invokeRestart <- base::invokeRestart
[10:25:51.460]             length <- base::length
[10:25:51.460]             list <- base::list
[10:25:51.460]             seq.int <- base::seq.int
[10:25:51.460]             signalCondition <- base::signalCondition
[10:25:51.460]             sys.calls <- base::sys.calls
[10:25:51.460]             `[[` <- base::`[[`
[10:25:51.460]             `+` <- base::`+`
[10:25:51.460]             `<<-` <- base::`<<-`
[10:25:51.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.460]                   3L)]
[10:25:51.460]             }
[10:25:51.460]             function(cond) {
[10:25:51.460]                 is_error <- inherits(cond, "error")
[10:25:51.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.460]                   NULL)
[10:25:51.460]                 if (is_error) {
[10:25:51.460]                   sessionInformation <- function() {
[10:25:51.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.460]                       search = base::search(), system = base::Sys.info())
[10:25:51.460]                   }
[10:25:51.460]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.460]                     cond$call), session = sessionInformation(), 
[10:25:51.460]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.460]                   signalCondition(cond)
[10:25:51.460]                 }
[10:25:51.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.460]                 "immediateCondition"))) {
[10:25:51.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.460]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.460]                   if (TRUE && !signal) {
[10:25:51.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.460]                     {
[10:25:51.460]                       inherits <- base::inherits
[10:25:51.460]                       invokeRestart <- base::invokeRestart
[10:25:51.460]                       is.null <- base::is.null
[10:25:51.460]                       muffled <- FALSE
[10:25:51.460]                       if (inherits(cond, "message")) {
[10:25:51.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.460]                         if (muffled) 
[10:25:51.460]                           invokeRestart("muffleMessage")
[10:25:51.460]                       }
[10:25:51.460]                       else if (inherits(cond, "warning")) {
[10:25:51.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.460]                         if (muffled) 
[10:25:51.460]                           invokeRestart("muffleWarning")
[10:25:51.460]                       }
[10:25:51.460]                       else if (inherits(cond, "condition")) {
[10:25:51.460]                         if (!is.null(pattern)) {
[10:25:51.460]                           computeRestarts <- base::computeRestarts
[10:25:51.460]                           grepl <- base::grepl
[10:25:51.460]                           restarts <- computeRestarts(cond)
[10:25:51.460]                           for (restart in restarts) {
[10:25:51.460]                             name <- restart$name
[10:25:51.460]                             if (is.null(name)) 
[10:25:51.460]                               next
[10:25:51.460]                             if (!grepl(pattern, name)) 
[10:25:51.460]                               next
[10:25:51.460]                             invokeRestart(restart)
[10:25:51.460]                             muffled <- TRUE
[10:25:51.460]                             break
[10:25:51.460]                           }
[10:25:51.460]                         }
[10:25:51.460]                       }
[10:25:51.460]                       invisible(muffled)
[10:25:51.460]                     }
[10:25:51.460]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.460]                   }
[10:25:51.460]                 }
[10:25:51.460]                 else {
[10:25:51.460]                   if (TRUE) {
[10:25:51.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.460]                     {
[10:25:51.460]                       inherits <- base::inherits
[10:25:51.460]                       invokeRestart <- base::invokeRestart
[10:25:51.460]                       is.null <- base::is.null
[10:25:51.460]                       muffled <- FALSE
[10:25:51.460]                       if (inherits(cond, "message")) {
[10:25:51.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.460]                         if (muffled) 
[10:25:51.460]                           invokeRestart("muffleMessage")
[10:25:51.460]                       }
[10:25:51.460]                       else if (inherits(cond, "warning")) {
[10:25:51.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.460]                         if (muffled) 
[10:25:51.460]                           invokeRestart("muffleWarning")
[10:25:51.460]                       }
[10:25:51.460]                       else if (inherits(cond, "condition")) {
[10:25:51.460]                         if (!is.null(pattern)) {
[10:25:51.460]                           computeRestarts <- base::computeRestarts
[10:25:51.460]                           grepl <- base::grepl
[10:25:51.460]                           restarts <- computeRestarts(cond)
[10:25:51.460]                           for (restart in restarts) {
[10:25:51.460]                             name <- restart$name
[10:25:51.460]                             if (is.null(name)) 
[10:25:51.460]                               next
[10:25:51.460]                             if (!grepl(pattern, name)) 
[10:25:51.460]                               next
[10:25:51.460]                             invokeRestart(restart)
[10:25:51.460]                             muffled <- TRUE
[10:25:51.460]                             break
[10:25:51.460]                           }
[10:25:51.460]                         }
[10:25:51.460]                       }
[10:25:51.460]                       invisible(muffled)
[10:25:51.460]                     }
[10:25:51.460]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.460]                   }
[10:25:51.460]                 }
[10:25:51.460]             }
[10:25:51.460]         }))
[10:25:51.460]     }, error = function(ex) {
[10:25:51.460]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.460]                 ...future.rng), started = ...future.startTime, 
[10:25:51.460]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.460]             version = "1.8"), class = "FutureResult")
[10:25:51.460]     }, finally = {
[10:25:51.460]         if (!identical(...future.workdir, getwd())) 
[10:25:51.460]             setwd(...future.workdir)
[10:25:51.460]         {
[10:25:51.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.460]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.460]             }
[10:25:51.460]             base::options(...future.oldOptions)
[10:25:51.460]             if (.Platform$OS.type == "windows") {
[10:25:51.460]                 old_names <- names(...future.oldEnvVars)
[10:25:51.460]                 envs <- base::Sys.getenv()
[10:25:51.460]                 names <- names(envs)
[10:25:51.460]                 common <- intersect(names, old_names)
[10:25:51.460]                 added <- setdiff(names, old_names)
[10:25:51.460]                 removed <- setdiff(old_names, names)
[10:25:51.460]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.460]                   envs[common]]
[10:25:51.460]                 NAMES <- toupper(changed)
[10:25:51.460]                 args <- list()
[10:25:51.460]                 for (kk in seq_along(NAMES)) {
[10:25:51.460]                   name <- changed[[kk]]
[10:25:51.460]                   NAME <- NAMES[[kk]]
[10:25:51.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.460]                     next
[10:25:51.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.460]                 }
[10:25:51.460]                 NAMES <- toupper(added)
[10:25:51.460]                 for (kk in seq_along(NAMES)) {
[10:25:51.460]                   name <- added[[kk]]
[10:25:51.460]                   NAME <- NAMES[[kk]]
[10:25:51.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.460]                     next
[10:25:51.460]                   args[[name]] <- ""
[10:25:51.460]                 }
[10:25:51.460]                 NAMES <- toupper(removed)
[10:25:51.460]                 for (kk in seq_along(NAMES)) {
[10:25:51.460]                   name <- removed[[kk]]
[10:25:51.460]                   NAME <- NAMES[[kk]]
[10:25:51.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.460]                     next
[10:25:51.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.460]                 }
[10:25:51.460]                 if (length(args) > 0) 
[10:25:51.460]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.460]             }
[10:25:51.460]             else {
[10:25:51.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.460]             }
[10:25:51.460]             {
[10:25:51.460]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.460]                   0L) {
[10:25:51.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.460]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.460]                   base::options(opts)
[10:25:51.460]                 }
[10:25:51.460]                 {
[10:25:51.460]                   {
[10:25:51.460]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.460]                     NULL
[10:25:51.460]                   }
[10:25:51.460]                   options(future.plan = NULL)
[10:25:51.460]                   if (is.na(NA_character_)) 
[10:25:51.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.460]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.460]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.460]                     envir = parent.frame()) 
[10:25:51.460]                   {
[10:25:51.460]                     if (is.function(workers)) 
[10:25:51.460]                       workers <- workers()
[10:25:51.460]                     workers <- structure(as.integer(workers), 
[10:25:51.460]                       class = class(workers))
[10:25:51.460]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.460]                       workers >= 1)
[10:25:51.460]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.460]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.460]                     }
[10:25:51.460]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.460]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.460]                       envir = envir)
[10:25:51.460]                     if (!future$lazy) 
[10:25:51.460]                       future <- run(future)
[10:25:51.460]                     invisible(future)
[10:25:51.460]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.460]                 }
[10:25:51.460]             }
[10:25:51.460]         }
[10:25:51.460]     })
[10:25:51.460]     if (TRUE) {
[10:25:51.460]         base::sink(type = "output", split = FALSE)
[10:25:51.460]         if (TRUE) {
[10:25:51.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.460]         }
[10:25:51.460]         else {
[10:25:51.460]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.460]         }
[10:25:51.460]         base::close(...future.stdout)
[10:25:51.460]         ...future.stdout <- NULL
[10:25:51.460]     }
[10:25:51.460]     ...future.result$conditions <- ...future.conditions
[10:25:51.460]     ...future.result$finished <- base::Sys.time()
[10:25:51.460]     ...future.result
[10:25:51.460] }
[10:25:51.462] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:51.473] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.473] - Validating connection of MultisessionFuture
[10:25:51.474] - received message: FutureResult
[10:25:51.474] - Received FutureResult
[10:25:51.474] - Erased future from FutureRegistry
[10:25:51.474] result() for ClusterFuture ...
[10:25:51.474] - result already collected: FutureResult
[10:25:51.477] result() for ClusterFuture ... done
[10:25:51.477] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.477] result() for ClusterFuture ...
[10:25:51.477] - result already collected: FutureResult
[10:25:51.478] result() for ClusterFuture ... done
[10:25:51.478] result() for ClusterFuture ...
[10:25:51.478] - result already collected: FutureResult
[10:25:51.478] result() for ClusterFuture ... done
[10:25:51.479] MultisessionFuture started
[10:25:51.479] - Launch lazy future ... done
[10:25:51.479] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f63cd738> 
Classes 'listenv', 'environment' <environment: 0x55c0f58aa3e0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:25:51.486] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.486] - Validating connection of MultisessionFuture
[10:25:51.486] - received message: FutureResult
[10:25:51.487] - Received FutureResult
[10:25:51.487] - Erased future from FutureRegistry
[10:25:51.487] result() for ClusterFuture ...
[10:25:51.487] - result already collected: FutureResult
[10:25:51.487] result() for ClusterFuture ... done
[10:25:51.487] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:51.500] resolve() on list environment ...
[10:25:51.500]  recursive: 0
[10:25:51.501]  length: 6
[10:25:51.501]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:51.501] signalConditionsASAP(numeric, pos=1) ...
[10:25:51.501] - nx: 6
[10:25:51.501] - relay: TRUE
[10:25:51.502] - stdout: TRUE
[10:25:51.502] - signal: TRUE
[10:25:51.502] - resignal: FALSE
[10:25:51.502] - force: TRUE
[10:25:51.502] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.502] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.502]  - until=2
[10:25:51.502]  - relaying element #2
[10:25:51.502] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.502] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.502] signalConditionsASAP(NULL, pos=1) ... done
[10:25:51.503]  length: 5 (resolved future 1)
[10:25:51.503] Future #2
[10:25:51.503] result() for ClusterFuture ...
[10:25:51.503] - result already collected: FutureResult
[10:25:51.503] result() for ClusterFuture ... done
[10:25:51.503] result() for ClusterFuture ...
[10:25:51.503] - result already collected: FutureResult
[10:25:51.503] result() for ClusterFuture ... done
[10:25:51.503] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:51.503] - nx: 6
[10:25:51.503] - relay: TRUE
[10:25:51.504] - stdout: TRUE
[10:25:51.504] - signal: TRUE
[10:25:51.504] - resignal: FALSE
[10:25:51.504] - force: TRUE
[10:25:51.504] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.504] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.504]  - until=2
[10:25:51.504]  - relaying element #2
[10:25:51.504] result() for ClusterFuture ...
[10:25:51.504] - result already collected: FutureResult
[10:25:51.504] result() for ClusterFuture ... done
[10:25:51.504] result() for ClusterFuture ...
[10:25:51.505] - result already collected: FutureResult
[10:25:51.505] result() for ClusterFuture ... done
[10:25:51.505] result() for ClusterFuture ...
[10:25:51.505] - result already collected: FutureResult
[10:25:51.505] result() for ClusterFuture ... done
[10:25:51.505] result() for ClusterFuture ...
[10:25:51.505] - result already collected: FutureResult
[10:25:51.505] result() for ClusterFuture ... done
[10:25:51.505] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.505] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.505] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:51.506]  length: 4 (resolved future 2)
[10:25:51.506] Future #3
[10:25:51.506] result() for ClusterFuture ...
[10:25:51.506] - result already collected: FutureResult
[10:25:51.506] result() for ClusterFuture ... done
[10:25:51.506] result() for ClusterFuture ...
[10:25:51.506] - result already collected: FutureResult
[10:25:51.506] result() for ClusterFuture ... done
[10:25:51.506] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:51.506] - nx: 6
[10:25:51.506] - relay: TRUE
[10:25:51.507] - stdout: TRUE
[10:25:51.507] - signal: TRUE
[10:25:51.507] - resignal: FALSE
[10:25:51.507] - force: TRUE
[10:25:51.507] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.507] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.507]  - until=3
[10:25:51.507]  - relaying element #3
[10:25:51.507] result() for ClusterFuture ...
[10:25:51.507] - result already collected: FutureResult
[10:25:51.507] result() for ClusterFuture ... done
[10:25:51.507] result() for ClusterFuture ...
[10:25:51.508] - result already collected: FutureResult
[10:25:51.508] result() for ClusterFuture ... done
[10:25:51.508] result() for ClusterFuture ...
[10:25:51.508] - result already collected: FutureResult
[10:25:51.508] result() for ClusterFuture ... done
[10:25:51.508] result() for ClusterFuture ...
[10:25:51.508] - result already collected: FutureResult
[10:25:51.508] result() for ClusterFuture ... done
[10:25:51.508] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.508] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.508] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:51.509]  length: 3 (resolved future 3)
[10:25:51.519] signalConditionsASAP(NULL, pos=5) ...
[10:25:51.519] - nx: 6
[10:25:51.519] - relay: TRUE
[10:25:51.519] - stdout: TRUE
[10:25:51.520] - signal: TRUE
[10:25:51.520] - resignal: FALSE
[10:25:51.520] - force: TRUE
[10:25:51.520] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.520] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.520]  - until=6
[10:25:51.520]  - relaying element #4
[10:25:51.520]  - relaying element #6
[10:25:51.520] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:25:51.520] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.521] signalConditionsASAP(NULL, pos=5) ... done
[10:25:51.521]  length: 2 (resolved future 5)
[10:25:51.521] signalConditionsASAP(numeric, pos=6) ...
[10:25:51.521] - nx: 6
[10:25:51.521] - relay: TRUE
[10:25:51.521] - stdout: TRUE
[10:25:51.521] - signal: TRUE
[10:25:51.521] - resignal: FALSE
[10:25:51.521] - force: TRUE
[10:25:51.521] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:25:51.521] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.522]  - until=6
[10:25:51.522]  - relaying element #4
[10:25:51.522] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:25:51.522] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.522] signalConditionsASAP(NULL, pos=6) ... done
[10:25:51.522]  length: 1 (resolved future 6)
[10:25:51.533] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.533] - Validating connection of MultisessionFuture
[10:25:51.533] - received message: FutureResult
[10:25:51.533] - Received FutureResult
[10:25:51.533] - Erased future from FutureRegistry
[10:25:51.533] result() for ClusterFuture ...
[10:25:51.533] - result already collected: FutureResult
[10:25:51.534] result() for ClusterFuture ... done
[10:25:51.534] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.534] Future #4
[10:25:51.534] result() for ClusterFuture ...
[10:25:51.534] - result already collected: FutureResult
[10:25:51.534] result() for ClusterFuture ... done
[10:25:51.534] result() for ClusterFuture ...
[10:25:51.534] - result already collected: FutureResult
[10:25:51.534] result() for ClusterFuture ... done
[10:25:51.534] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:51.534] - nx: 6
[10:25:51.535] - relay: TRUE
[10:25:51.535] - stdout: TRUE
[10:25:51.535] - signal: TRUE
[10:25:51.535] - resignal: FALSE
[10:25:51.535] - force: TRUE
[10:25:51.535] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:25:51.535] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.535]  - until=6
[10:25:51.535]  - relaying element #4
[10:25:51.535] result() for ClusterFuture ...
[10:25:51.535] - result already collected: FutureResult
[10:25:51.536] result() for ClusterFuture ... done
[10:25:51.536] result() for ClusterFuture ...
[10:25:51.536] - result already collected: FutureResult
[10:25:51.536] result() for ClusterFuture ... done
[10:25:51.536] result() for ClusterFuture ...
[10:25:51.536] - result already collected: FutureResult
[10:25:51.536] result() for ClusterFuture ... done
[10:25:51.536] result() for ClusterFuture ...
[10:25:51.536] - result already collected: FutureResult
[10:25:51.536] result() for ClusterFuture ... done
[10:25:51.536] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.536] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.537] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:51.537]  length: 0 (resolved future 4)
[10:25:51.537] Relaying remaining futures
[10:25:51.537] signalConditionsASAP(NULL, pos=0) ...
[10:25:51.537] - nx: 6
[10:25:51.537] - relay: TRUE
[10:25:51.537] - stdout: TRUE
[10:25:51.537] - signal: TRUE
[10:25:51.537] - resignal: FALSE
[10:25:51.537] - force: TRUE
[10:25:51.537] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.538] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:51.538] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.538] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.538] signalConditionsASAP(NULL, pos=0) ... done
[10:25:51.538] resolve() on list environment ... DONE
[10:25:51.538] result() for ClusterFuture ...
[10:25:51.538] - result already collected: FutureResult
[10:25:51.538] result() for ClusterFuture ... done
[10:25:51.538] result() for ClusterFuture ...
[10:25:51.538] - result already collected: FutureResult
[10:25:51.539] result() for ClusterFuture ... done
[10:25:51.539] result() for ClusterFuture ...
[10:25:51.539] - result already collected: FutureResult
[10:25:51.539] result() for ClusterFuture ... done
[10:25:51.539] result() for ClusterFuture ...
[10:25:51.539] - result already collected: FutureResult
[10:25:51.539] result() for ClusterFuture ... done
[10:25:51.539] result() for ClusterFuture ...
[10:25:51.539] - result already collected: FutureResult
[10:25:51.540] result() for ClusterFuture ... done
[10:25:51.540] result() for ClusterFuture ...
[10:25:51.540] - result already collected: FutureResult
[10:25:51.540] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f52d7618> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:25:51.542] getGlobalsAndPackages() ...
[10:25:51.542] Searching for globals...
[10:25:51.542] 
[10:25:51.542] Searching for globals ... DONE
[10:25:51.542] - globals: [0] <none>
[10:25:51.543] getGlobalsAndPackages() ... DONE
[10:25:51.543] run() for ‘Future’ ...
[10:25:51.543] - state: ‘created’
[10:25:51.543] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.557] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.557]   - Field: ‘node’
[10:25:51.557]   - Field: ‘label’
[10:25:51.557]   - Field: ‘local’
[10:25:51.557]   - Field: ‘owner’
[10:25:51.558]   - Field: ‘envir’
[10:25:51.558]   - Field: ‘workers’
[10:25:51.558]   - Field: ‘packages’
[10:25:51.558]   - Field: ‘gc’
[10:25:51.558]   - Field: ‘conditions’
[10:25:51.558]   - Field: ‘persistent’
[10:25:51.558]   - Field: ‘expr’
[10:25:51.558]   - Field: ‘uuid’
[10:25:51.558]   - Field: ‘seed’
[10:25:51.558]   - Field: ‘version’
[10:25:51.558]   - Field: ‘result’
[10:25:51.559]   - Field: ‘asynchronous’
[10:25:51.559]   - Field: ‘calls’
[10:25:51.559]   - Field: ‘globals’
[10:25:51.559]   - Field: ‘stdout’
[10:25:51.559]   - Field: ‘earlySignal’
[10:25:51.559]   - Field: ‘lazy’
[10:25:51.559]   - Field: ‘state’
[10:25:51.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.559] - Launch lazy future ...
[10:25:51.560] Packages needed by the future expression (n = 0): <none>
[10:25:51.560] Packages needed by future strategies (n = 0): <none>
[10:25:51.560] {
[10:25:51.560]     {
[10:25:51.560]         {
[10:25:51.560]             ...future.startTime <- base::Sys.time()
[10:25:51.560]             {
[10:25:51.560]                 {
[10:25:51.560]                   {
[10:25:51.560]                     {
[10:25:51.560]                       base::local({
[10:25:51.560]                         has_future <- base::requireNamespace("future", 
[10:25:51.560]                           quietly = TRUE)
[10:25:51.560]                         if (has_future) {
[10:25:51.560]                           ns <- base::getNamespace("future")
[10:25:51.560]                           version <- ns[[".package"]][["version"]]
[10:25:51.560]                           if (is.null(version)) 
[10:25:51.560]                             version <- utils::packageVersion("future")
[10:25:51.560]                         }
[10:25:51.560]                         else {
[10:25:51.560]                           version <- NULL
[10:25:51.560]                         }
[10:25:51.560]                         if (!has_future || version < "1.8.0") {
[10:25:51.560]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.560]                             "", base::R.version$version.string), 
[10:25:51.560]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.560]                               "release", "version")], collapse = " "), 
[10:25:51.560]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.560]                             info)
[10:25:51.560]                           info <- base::paste(info, collapse = "; ")
[10:25:51.560]                           if (!has_future) {
[10:25:51.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.560]                               info)
[10:25:51.560]                           }
[10:25:51.560]                           else {
[10:25:51.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.560]                               info, version)
[10:25:51.560]                           }
[10:25:51.560]                           base::stop(msg)
[10:25:51.560]                         }
[10:25:51.560]                       })
[10:25:51.560]                     }
[10:25:51.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.560]                     base::options(mc.cores = 1L)
[10:25:51.560]                   }
[10:25:51.560]                   options(future.plan = NULL)
[10:25:51.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.560]                 }
[10:25:51.560]                 ...future.workdir <- getwd()
[10:25:51.560]             }
[10:25:51.560]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.560]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.560]         }
[10:25:51.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.560]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.560]             base::names(...future.oldOptions))
[10:25:51.560]     }
[10:25:51.560]     if (FALSE) {
[10:25:51.560]     }
[10:25:51.560]     else {
[10:25:51.560]         if (TRUE) {
[10:25:51.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.560]                 open = "w")
[10:25:51.560]         }
[10:25:51.560]         else {
[10:25:51.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.560]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.560]         }
[10:25:51.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.560]             base::sink(type = "output", split = FALSE)
[10:25:51.560]             base::close(...future.stdout)
[10:25:51.560]         }, add = TRUE)
[10:25:51.560]     }
[10:25:51.560]     ...future.frame <- base::sys.nframe()
[10:25:51.560]     ...future.conditions <- base::list()
[10:25:51.560]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.560]     if (FALSE) {
[10:25:51.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.560]     }
[10:25:51.560]     ...future.result <- base::tryCatch({
[10:25:51.560]         base::withCallingHandlers({
[10:25:51.560]             ...future.value <- base::withVisible(base::local({
[10:25:51.560]                 ...future.makeSendCondition <- base::local({
[10:25:51.560]                   sendCondition <- NULL
[10:25:51.560]                   function(frame = 1L) {
[10:25:51.560]                     if (is.function(sendCondition)) 
[10:25:51.560]                       return(sendCondition)
[10:25:51.560]                     ns <- getNamespace("parallel")
[10:25:51.560]                     if (exists("sendData", mode = "function", 
[10:25:51.560]                       envir = ns)) {
[10:25:51.560]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.560]                         envir = ns)
[10:25:51.560]                       envir <- sys.frame(frame)
[10:25:51.560]                       master <- NULL
[10:25:51.560]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.560]                         !identical(envir, emptyenv())) {
[10:25:51.560]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.560]                           inherits = FALSE)) {
[10:25:51.560]                           master <- get("master", mode = "list", 
[10:25:51.560]                             envir = envir, inherits = FALSE)
[10:25:51.560]                           if (inherits(master, c("SOCKnode", 
[10:25:51.560]                             "SOCK0node"))) {
[10:25:51.560]                             sendCondition <<- function(cond) {
[10:25:51.560]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.560]                                 success = TRUE)
[10:25:51.560]                               parallel_sendData(master, data)
[10:25:51.560]                             }
[10:25:51.560]                             return(sendCondition)
[10:25:51.560]                           }
[10:25:51.560]                         }
[10:25:51.560]                         frame <- frame + 1L
[10:25:51.560]                         envir <- sys.frame(frame)
[10:25:51.560]                       }
[10:25:51.560]                     }
[10:25:51.560]                     sendCondition <<- function(cond) NULL
[10:25:51.560]                   }
[10:25:51.560]                 })
[10:25:51.560]                 withCallingHandlers({
[10:25:51.560]                   2
[10:25:51.560]                 }, immediateCondition = function(cond) {
[10:25:51.560]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.560]                   sendCondition(cond)
[10:25:51.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.560]                   {
[10:25:51.560]                     inherits <- base::inherits
[10:25:51.560]                     invokeRestart <- base::invokeRestart
[10:25:51.560]                     is.null <- base::is.null
[10:25:51.560]                     muffled <- FALSE
[10:25:51.560]                     if (inherits(cond, "message")) {
[10:25:51.560]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.560]                       if (muffled) 
[10:25:51.560]                         invokeRestart("muffleMessage")
[10:25:51.560]                     }
[10:25:51.560]                     else if (inherits(cond, "warning")) {
[10:25:51.560]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.560]                       if (muffled) 
[10:25:51.560]                         invokeRestart("muffleWarning")
[10:25:51.560]                     }
[10:25:51.560]                     else if (inherits(cond, "condition")) {
[10:25:51.560]                       if (!is.null(pattern)) {
[10:25:51.560]                         computeRestarts <- base::computeRestarts
[10:25:51.560]                         grepl <- base::grepl
[10:25:51.560]                         restarts <- computeRestarts(cond)
[10:25:51.560]                         for (restart in restarts) {
[10:25:51.560]                           name <- restart$name
[10:25:51.560]                           if (is.null(name)) 
[10:25:51.560]                             next
[10:25:51.560]                           if (!grepl(pattern, name)) 
[10:25:51.560]                             next
[10:25:51.560]                           invokeRestart(restart)
[10:25:51.560]                           muffled <- TRUE
[10:25:51.560]                           break
[10:25:51.560]                         }
[10:25:51.560]                       }
[10:25:51.560]                     }
[10:25:51.560]                     invisible(muffled)
[10:25:51.560]                   }
[10:25:51.560]                   muffleCondition(cond)
[10:25:51.560]                 })
[10:25:51.560]             }))
[10:25:51.560]             future::FutureResult(value = ...future.value$value, 
[10:25:51.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.560]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.560]                     ...future.globalenv.names))
[10:25:51.560]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.560]         }, condition = base::local({
[10:25:51.560]             c <- base::c
[10:25:51.560]             inherits <- base::inherits
[10:25:51.560]             invokeRestart <- base::invokeRestart
[10:25:51.560]             length <- base::length
[10:25:51.560]             list <- base::list
[10:25:51.560]             seq.int <- base::seq.int
[10:25:51.560]             signalCondition <- base::signalCondition
[10:25:51.560]             sys.calls <- base::sys.calls
[10:25:51.560]             `[[` <- base::`[[`
[10:25:51.560]             `+` <- base::`+`
[10:25:51.560]             `<<-` <- base::`<<-`
[10:25:51.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.560]                   3L)]
[10:25:51.560]             }
[10:25:51.560]             function(cond) {
[10:25:51.560]                 is_error <- inherits(cond, "error")
[10:25:51.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.560]                   NULL)
[10:25:51.560]                 if (is_error) {
[10:25:51.560]                   sessionInformation <- function() {
[10:25:51.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.560]                       search = base::search(), system = base::Sys.info())
[10:25:51.560]                   }
[10:25:51.560]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.560]                     cond$call), session = sessionInformation(), 
[10:25:51.560]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.560]                   signalCondition(cond)
[10:25:51.560]                 }
[10:25:51.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.560]                 "immediateCondition"))) {
[10:25:51.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.560]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.560]                   if (TRUE && !signal) {
[10:25:51.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.560]                     {
[10:25:51.560]                       inherits <- base::inherits
[10:25:51.560]                       invokeRestart <- base::invokeRestart
[10:25:51.560]                       is.null <- base::is.null
[10:25:51.560]                       muffled <- FALSE
[10:25:51.560]                       if (inherits(cond, "message")) {
[10:25:51.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.560]                         if (muffled) 
[10:25:51.560]                           invokeRestart("muffleMessage")
[10:25:51.560]                       }
[10:25:51.560]                       else if (inherits(cond, "warning")) {
[10:25:51.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.560]                         if (muffled) 
[10:25:51.560]                           invokeRestart("muffleWarning")
[10:25:51.560]                       }
[10:25:51.560]                       else if (inherits(cond, "condition")) {
[10:25:51.560]                         if (!is.null(pattern)) {
[10:25:51.560]                           computeRestarts <- base::computeRestarts
[10:25:51.560]                           grepl <- base::grepl
[10:25:51.560]                           restarts <- computeRestarts(cond)
[10:25:51.560]                           for (restart in restarts) {
[10:25:51.560]                             name <- restart$name
[10:25:51.560]                             if (is.null(name)) 
[10:25:51.560]                               next
[10:25:51.560]                             if (!grepl(pattern, name)) 
[10:25:51.560]                               next
[10:25:51.560]                             invokeRestart(restart)
[10:25:51.560]                             muffled <- TRUE
[10:25:51.560]                             break
[10:25:51.560]                           }
[10:25:51.560]                         }
[10:25:51.560]                       }
[10:25:51.560]                       invisible(muffled)
[10:25:51.560]                     }
[10:25:51.560]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.560]                   }
[10:25:51.560]                 }
[10:25:51.560]                 else {
[10:25:51.560]                   if (TRUE) {
[10:25:51.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.560]                     {
[10:25:51.560]                       inherits <- base::inherits
[10:25:51.560]                       invokeRestart <- base::invokeRestart
[10:25:51.560]                       is.null <- base::is.null
[10:25:51.560]                       muffled <- FALSE
[10:25:51.560]                       if (inherits(cond, "message")) {
[10:25:51.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.560]                         if (muffled) 
[10:25:51.560]                           invokeRestart("muffleMessage")
[10:25:51.560]                       }
[10:25:51.560]                       else if (inherits(cond, "warning")) {
[10:25:51.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.560]                         if (muffled) 
[10:25:51.560]                           invokeRestart("muffleWarning")
[10:25:51.560]                       }
[10:25:51.560]                       else if (inherits(cond, "condition")) {
[10:25:51.560]                         if (!is.null(pattern)) {
[10:25:51.560]                           computeRestarts <- base::computeRestarts
[10:25:51.560]                           grepl <- base::grepl
[10:25:51.560]                           restarts <- computeRestarts(cond)
[10:25:51.560]                           for (restart in restarts) {
[10:25:51.560]                             name <- restart$name
[10:25:51.560]                             if (is.null(name)) 
[10:25:51.560]                               next
[10:25:51.560]                             if (!grepl(pattern, name)) 
[10:25:51.560]                               next
[10:25:51.560]                             invokeRestart(restart)
[10:25:51.560]                             muffled <- TRUE
[10:25:51.560]                             break
[10:25:51.560]                           }
[10:25:51.560]                         }
[10:25:51.560]                       }
[10:25:51.560]                       invisible(muffled)
[10:25:51.560]                     }
[10:25:51.560]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.560]                   }
[10:25:51.560]                 }
[10:25:51.560]             }
[10:25:51.560]         }))
[10:25:51.560]     }, error = function(ex) {
[10:25:51.560]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.560]                 ...future.rng), started = ...future.startTime, 
[10:25:51.560]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.560]             version = "1.8"), class = "FutureResult")
[10:25:51.560]     }, finally = {
[10:25:51.560]         if (!identical(...future.workdir, getwd())) 
[10:25:51.560]             setwd(...future.workdir)
[10:25:51.560]         {
[10:25:51.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.560]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.560]             }
[10:25:51.560]             base::options(...future.oldOptions)
[10:25:51.560]             if (.Platform$OS.type == "windows") {
[10:25:51.560]                 old_names <- names(...future.oldEnvVars)
[10:25:51.560]                 envs <- base::Sys.getenv()
[10:25:51.560]                 names <- names(envs)
[10:25:51.560]                 common <- intersect(names, old_names)
[10:25:51.560]                 added <- setdiff(names, old_names)
[10:25:51.560]                 removed <- setdiff(old_names, names)
[10:25:51.560]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.560]                   envs[common]]
[10:25:51.560]                 NAMES <- toupper(changed)
[10:25:51.560]                 args <- list()
[10:25:51.560]                 for (kk in seq_along(NAMES)) {
[10:25:51.560]                   name <- changed[[kk]]
[10:25:51.560]                   NAME <- NAMES[[kk]]
[10:25:51.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.560]                     next
[10:25:51.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.560]                 }
[10:25:51.560]                 NAMES <- toupper(added)
[10:25:51.560]                 for (kk in seq_along(NAMES)) {
[10:25:51.560]                   name <- added[[kk]]
[10:25:51.560]                   NAME <- NAMES[[kk]]
[10:25:51.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.560]                     next
[10:25:51.560]                   args[[name]] <- ""
[10:25:51.560]                 }
[10:25:51.560]                 NAMES <- toupper(removed)
[10:25:51.560]                 for (kk in seq_along(NAMES)) {
[10:25:51.560]                   name <- removed[[kk]]
[10:25:51.560]                   NAME <- NAMES[[kk]]
[10:25:51.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.560]                     next
[10:25:51.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.560]                 }
[10:25:51.560]                 if (length(args) > 0) 
[10:25:51.560]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.560]             }
[10:25:51.560]             else {
[10:25:51.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.560]             }
[10:25:51.560]             {
[10:25:51.560]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.560]                   0L) {
[10:25:51.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.560]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.560]                   base::options(opts)
[10:25:51.560]                 }
[10:25:51.560]                 {
[10:25:51.560]                   {
[10:25:51.560]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.560]                     NULL
[10:25:51.560]                   }
[10:25:51.560]                   options(future.plan = NULL)
[10:25:51.560]                   if (is.na(NA_character_)) 
[10:25:51.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.560]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.560]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.560]                     envir = parent.frame()) 
[10:25:51.560]                   {
[10:25:51.560]                     if (is.function(workers)) 
[10:25:51.560]                       workers <- workers()
[10:25:51.560]                     workers <- structure(as.integer(workers), 
[10:25:51.560]                       class = class(workers))
[10:25:51.560]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.560]                       workers >= 1)
[10:25:51.560]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.560]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.560]                     }
[10:25:51.560]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.560]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.560]                       envir = envir)
[10:25:51.560]                     if (!future$lazy) 
[10:25:51.560]                       future <- run(future)
[10:25:51.560]                     invisible(future)
[10:25:51.560]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.560]                 }
[10:25:51.560]             }
[10:25:51.560]         }
[10:25:51.560]     })
[10:25:51.560]     if (TRUE) {
[10:25:51.560]         base::sink(type = "output", split = FALSE)
[10:25:51.560]         if (TRUE) {
[10:25:51.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.560]         }
[10:25:51.560]         else {
[10:25:51.560]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.560]         }
[10:25:51.560]         base::close(...future.stdout)
[10:25:51.560]         ...future.stdout <- NULL
[10:25:51.560]     }
[10:25:51.560]     ...future.result$conditions <- ...future.conditions
[10:25:51.560]     ...future.result$finished <- base::Sys.time()
[10:25:51.560]     ...future.result
[10:25:51.560] }
[10:25:51.563] MultisessionFuture started
[10:25:51.563] - Launch lazy future ... done
[10:25:51.563] run() for ‘MultisessionFuture’ ... done
[10:25:51.564] getGlobalsAndPackages() ...
[10:25:51.564] Searching for globals...
[10:25:51.564] 
[10:25:51.564] Searching for globals ... DONE
[10:25:51.564] - globals: [0] <none>
[10:25:51.564] getGlobalsAndPackages() ... DONE
[10:25:51.565] run() for ‘Future’ ...
[10:25:51.565] - state: ‘created’
[10:25:51.565] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.578] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.579]   - Field: ‘node’
[10:25:51.579]   - Field: ‘label’
[10:25:51.579]   - Field: ‘local’
[10:25:51.579]   - Field: ‘owner’
[10:25:51.579]   - Field: ‘envir’
[10:25:51.579]   - Field: ‘workers’
[10:25:51.579]   - Field: ‘packages’
[10:25:51.579]   - Field: ‘gc’
[10:25:51.579]   - Field: ‘conditions’
[10:25:51.579]   - Field: ‘persistent’
[10:25:51.579]   - Field: ‘expr’
[10:25:51.580]   - Field: ‘uuid’
[10:25:51.580]   - Field: ‘seed’
[10:25:51.580]   - Field: ‘version’
[10:25:51.580]   - Field: ‘result’
[10:25:51.580]   - Field: ‘asynchronous’
[10:25:51.580]   - Field: ‘calls’
[10:25:51.580]   - Field: ‘globals’
[10:25:51.580]   - Field: ‘stdout’
[10:25:51.580]   - Field: ‘earlySignal’
[10:25:51.580]   - Field: ‘lazy’
[10:25:51.580]   - Field: ‘state’
[10:25:51.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.581] - Launch lazy future ...
[10:25:51.581] Packages needed by the future expression (n = 0): <none>
[10:25:51.581] Packages needed by future strategies (n = 0): <none>
[10:25:51.582] {
[10:25:51.582]     {
[10:25:51.582]         {
[10:25:51.582]             ...future.startTime <- base::Sys.time()
[10:25:51.582]             {
[10:25:51.582]                 {
[10:25:51.582]                   {
[10:25:51.582]                     {
[10:25:51.582]                       base::local({
[10:25:51.582]                         has_future <- base::requireNamespace("future", 
[10:25:51.582]                           quietly = TRUE)
[10:25:51.582]                         if (has_future) {
[10:25:51.582]                           ns <- base::getNamespace("future")
[10:25:51.582]                           version <- ns[[".package"]][["version"]]
[10:25:51.582]                           if (is.null(version)) 
[10:25:51.582]                             version <- utils::packageVersion("future")
[10:25:51.582]                         }
[10:25:51.582]                         else {
[10:25:51.582]                           version <- NULL
[10:25:51.582]                         }
[10:25:51.582]                         if (!has_future || version < "1.8.0") {
[10:25:51.582]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.582]                             "", base::R.version$version.string), 
[10:25:51.582]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.582]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.582]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.582]                               "release", "version")], collapse = " "), 
[10:25:51.582]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.582]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.582]                             info)
[10:25:51.582]                           info <- base::paste(info, collapse = "; ")
[10:25:51.582]                           if (!has_future) {
[10:25:51.582]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.582]                               info)
[10:25:51.582]                           }
[10:25:51.582]                           else {
[10:25:51.582]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.582]                               info, version)
[10:25:51.582]                           }
[10:25:51.582]                           base::stop(msg)
[10:25:51.582]                         }
[10:25:51.582]                       })
[10:25:51.582]                     }
[10:25:51.582]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.582]                     base::options(mc.cores = 1L)
[10:25:51.582]                   }
[10:25:51.582]                   options(future.plan = NULL)
[10:25:51.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.582]                 }
[10:25:51.582]                 ...future.workdir <- getwd()
[10:25:51.582]             }
[10:25:51.582]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.582]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.582]         }
[10:25:51.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.582]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.582]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.582]             base::names(...future.oldOptions))
[10:25:51.582]     }
[10:25:51.582]     if (FALSE) {
[10:25:51.582]     }
[10:25:51.582]     else {
[10:25:51.582]         if (TRUE) {
[10:25:51.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.582]                 open = "w")
[10:25:51.582]         }
[10:25:51.582]         else {
[10:25:51.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.582]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.582]         }
[10:25:51.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.582]             base::sink(type = "output", split = FALSE)
[10:25:51.582]             base::close(...future.stdout)
[10:25:51.582]         }, add = TRUE)
[10:25:51.582]     }
[10:25:51.582]     ...future.frame <- base::sys.nframe()
[10:25:51.582]     ...future.conditions <- base::list()
[10:25:51.582]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.582]     if (FALSE) {
[10:25:51.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.582]     }
[10:25:51.582]     ...future.result <- base::tryCatch({
[10:25:51.582]         base::withCallingHandlers({
[10:25:51.582]             ...future.value <- base::withVisible(base::local({
[10:25:51.582]                 ...future.makeSendCondition <- base::local({
[10:25:51.582]                   sendCondition <- NULL
[10:25:51.582]                   function(frame = 1L) {
[10:25:51.582]                     if (is.function(sendCondition)) 
[10:25:51.582]                       return(sendCondition)
[10:25:51.582]                     ns <- getNamespace("parallel")
[10:25:51.582]                     if (exists("sendData", mode = "function", 
[10:25:51.582]                       envir = ns)) {
[10:25:51.582]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.582]                         envir = ns)
[10:25:51.582]                       envir <- sys.frame(frame)
[10:25:51.582]                       master <- NULL
[10:25:51.582]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.582]                         !identical(envir, emptyenv())) {
[10:25:51.582]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.582]                           inherits = FALSE)) {
[10:25:51.582]                           master <- get("master", mode = "list", 
[10:25:51.582]                             envir = envir, inherits = FALSE)
[10:25:51.582]                           if (inherits(master, c("SOCKnode", 
[10:25:51.582]                             "SOCK0node"))) {
[10:25:51.582]                             sendCondition <<- function(cond) {
[10:25:51.582]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.582]                                 success = TRUE)
[10:25:51.582]                               parallel_sendData(master, data)
[10:25:51.582]                             }
[10:25:51.582]                             return(sendCondition)
[10:25:51.582]                           }
[10:25:51.582]                         }
[10:25:51.582]                         frame <- frame + 1L
[10:25:51.582]                         envir <- sys.frame(frame)
[10:25:51.582]                       }
[10:25:51.582]                     }
[10:25:51.582]                     sendCondition <<- function(cond) NULL
[10:25:51.582]                   }
[10:25:51.582]                 })
[10:25:51.582]                 withCallingHandlers({
[10:25:51.582]                   NULL
[10:25:51.582]                 }, immediateCondition = function(cond) {
[10:25:51.582]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.582]                   sendCondition(cond)
[10:25:51.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.582]                   {
[10:25:51.582]                     inherits <- base::inherits
[10:25:51.582]                     invokeRestart <- base::invokeRestart
[10:25:51.582]                     is.null <- base::is.null
[10:25:51.582]                     muffled <- FALSE
[10:25:51.582]                     if (inherits(cond, "message")) {
[10:25:51.582]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.582]                       if (muffled) 
[10:25:51.582]                         invokeRestart("muffleMessage")
[10:25:51.582]                     }
[10:25:51.582]                     else if (inherits(cond, "warning")) {
[10:25:51.582]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.582]                       if (muffled) 
[10:25:51.582]                         invokeRestart("muffleWarning")
[10:25:51.582]                     }
[10:25:51.582]                     else if (inherits(cond, "condition")) {
[10:25:51.582]                       if (!is.null(pattern)) {
[10:25:51.582]                         computeRestarts <- base::computeRestarts
[10:25:51.582]                         grepl <- base::grepl
[10:25:51.582]                         restarts <- computeRestarts(cond)
[10:25:51.582]                         for (restart in restarts) {
[10:25:51.582]                           name <- restart$name
[10:25:51.582]                           if (is.null(name)) 
[10:25:51.582]                             next
[10:25:51.582]                           if (!grepl(pattern, name)) 
[10:25:51.582]                             next
[10:25:51.582]                           invokeRestart(restart)
[10:25:51.582]                           muffled <- TRUE
[10:25:51.582]                           break
[10:25:51.582]                         }
[10:25:51.582]                       }
[10:25:51.582]                     }
[10:25:51.582]                     invisible(muffled)
[10:25:51.582]                   }
[10:25:51.582]                   muffleCondition(cond)
[10:25:51.582]                 })
[10:25:51.582]             }))
[10:25:51.582]             future::FutureResult(value = ...future.value$value, 
[10:25:51.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.582]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.582]                     ...future.globalenv.names))
[10:25:51.582]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.582]         }, condition = base::local({
[10:25:51.582]             c <- base::c
[10:25:51.582]             inherits <- base::inherits
[10:25:51.582]             invokeRestart <- base::invokeRestart
[10:25:51.582]             length <- base::length
[10:25:51.582]             list <- base::list
[10:25:51.582]             seq.int <- base::seq.int
[10:25:51.582]             signalCondition <- base::signalCondition
[10:25:51.582]             sys.calls <- base::sys.calls
[10:25:51.582]             `[[` <- base::`[[`
[10:25:51.582]             `+` <- base::`+`
[10:25:51.582]             `<<-` <- base::`<<-`
[10:25:51.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.582]                   3L)]
[10:25:51.582]             }
[10:25:51.582]             function(cond) {
[10:25:51.582]                 is_error <- inherits(cond, "error")
[10:25:51.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.582]                   NULL)
[10:25:51.582]                 if (is_error) {
[10:25:51.582]                   sessionInformation <- function() {
[10:25:51.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.582]                       search = base::search(), system = base::Sys.info())
[10:25:51.582]                   }
[10:25:51.582]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.582]                     cond$call), session = sessionInformation(), 
[10:25:51.582]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.582]                   signalCondition(cond)
[10:25:51.582]                 }
[10:25:51.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.582]                 "immediateCondition"))) {
[10:25:51.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.582]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.582]                   if (TRUE && !signal) {
[10:25:51.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.582]                     {
[10:25:51.582]                       inherits <- base::inherits
[10:25:51.582]                       invokeRestart <- base::invokeRestart
[10:25:51.582]                       is.null <- base::is.null
[10:25:51.582]                       muffled <- FALSE
[10:25:51.582]                       if (inherits(cond, "message")) {
[10:25:51.582]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.582]                         if (muffled) 
[10:25:51.582]                           invokeRestart("muffleMessage")
[10:25:51.582]                       }
[10:25:51.582]                       else if (inherits(cond, "warning")) {
[10:25:51.582]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.582]                         if (muffled) 
[10:25:51.582]                           invokeRestart("muffleWarning")
[10:25:51.582]                       }
[10:25:51.582]                       else if (inherits(cond, "condition")) {
[10:25:51.582]                         if (!is.null(pattern)) {
[10:25:51.582]                           computeRestarts <- base::computeRestarts
[10:25:51.582]                           grepl <- base::grepl
[10:25:51.582]                           restarts <- computeRestarts(cond)
[10:25:51.582]                           for (restart in restarts) {
[10:25:51.582]                             name <- restart$name
[10:25:51.582]                             if (is.null(name)) 
[10:25:51.582]                               next
[10:25:51.582]                             if (!grepl(pattern, name)) 
[10:25:51.582]                               next
[10:25:51.582]                             invokeRestart(restart)
[10:25:51.582]                             muffled <- TRUE
[10:25:51.582]                             break
[10:25:51.582]                           }
[10:25:51.582]                         }
[10:25:51.582]                       }
[10:25:51.582]                       invisible(muffled)
[10:25:51.582]                     }
[10:25:51.582]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.582]                   }
[10:25:51.582]                 }
[10:25:51.582]                 else {
[10:25:51.582]                   if (TRUE) {
[10:25:51.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.582]                     {
[10:25:51.582]                       inherits <- base::inherits
[10:25:51.582]                       invokeRestart <- base::invokeRestart
[10:25:51.582]                       is.null <- base::is.null
[10:25:51.582]                       muffled <- FALSE
[10:25:51.582]                       if (inherits(cond, "message")) {
[10:25:51.582]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.582]                         if (muffled) 
[10:25:51.582]                           invokeRestart("muffleMessage")
[10:25:51.582]                       }
[10:25:51.582]                       else if (inherits(cond, "warning")) {
[10:25:51.582]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.582]                         if (muffled) 
[10:25:51.582]                           invokeRestart("muffleWarning")
[10:25:51.582]                       }
[10:25:51.582]                       else if (inherits(cond, "condition")) {
[10:25:51.582]                         if (!is.null(pattern)) {
[10:25:51.582]                           computeRestarts <- base::computeRestarts
[10:25:51.582]                           grepl <- base::grepl
[10:25:51.582]                           restarts <- computeRestarts(cond)
[10:25:51.582]                           for (restart in restarts) {
[10:25:51.582]                             name <- restart$name
[10:25:51.582]                             if (is.null(name)) 
[10:25:51.582]                               next
[10:25:51.582]                             if (!grepl(pattern, name)) 
[10:25:51.582]                               next
[10:25:51.582]                             invokeRestart(restart)
[10:25:51.582]                             muffled <- TRUE
[10:25:51.582]                             break
[10:25:51.582]                           }
[10:25:51.582]                         }
[10:25:51.582]                       }
[10:25:51.582]                       invisible(muffled)
[10:25:51.582]                     }
[10:25:51.582]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.582]                   }
[10:25:51.582]                 }
[10:25:51.582]             }
[10:25:51.582]         }))
[10:25:51.582]     }, error = function(ex) {
[10:25:51.582]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.582]                 ...future.rng), started = ...future.startTime, 
[10:25:51.582]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.582]             version = "1.8"), class = "FutureResult")
[10:25:51.582]     }, finally = {
[10:25:51.582]         if (!identical(...future.workdir, getwd())) 
[10:25:51.582]             setwd(...future.workdir)
[10:25:51.582]         {
[10:25:51.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.582]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.582]             }
[10:25:51.582]             base::options(...future.oldOptions)
[10:25:51.582]             if (.Platform$OS.type == "windows") {
[10:25:51.582]                 old_names <- names(...future.oldEnvVars)
[10:25:51.582]                 envs <- base::Sys.getenv()
[10:25:51.582]                 names <- names(envs)
[10:25:51.582]                 common <- intersect(names, old_names)
[10:25:51.582]                 added <- setdiff(names, old_names)
[10:25:51.582]                 removed <- setdiff(old_names, names)
[10:25:51.582]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.582]                   envs[common]]
[10:25:51.582]                 NAMES <- toupper(changed)
[10:25:51.582]                 args <- list()
[10:25:51.582]                 for (kk in seq_along(NAMES)) {
[10:25:51.582]                   name <- changed[[kk]]
[10:25:51.582]                   NAME <- NAMES[[kk]]
[10:25:51.582]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.582]                     next
[10:25:51.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.582]                 }
[10:25:51.582]                 NAMES <- toupper(added)
[10:25:51.582]                 for (kk in seq_along(NAMES)) {
[10:25:51.582]                   name <- added[[kk]]
[10:25:51.582]                   NAME <- NAMES[[kk]]
[10:25:51.582]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.582]                     next
[10:25:51.582]                   args[[name]] <- ""
[10:25:51.582]                 }
[10:25:51.582]                 NAMES <- toupper(removed)
[10:25:51.582]                 for (kk in seq_along(NAMES)) {
[10:25:51.582]                   name <- removed[[kk]]
[10:25:51.582]                   NAME <- NAMES[[kk]]
[10:25:51.582]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.582]                     next
[10:25:51.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.582]                 }
[10:25:51.582]                 if (length(args) > 0) 
[10:25:51.582]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.582]             }
[10:25:51.582]             else {
[10:25:51.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.582]             }
[10:25:51.582]             {
[10:25:51.582]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.582]                   0L) {
[10:25:51.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.582]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.582]                   base::options(opts)
[10:25:51.582]                 }
[10:25:51.582]                 {
[10:25:51.582]                   {
[10:25:51.582]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.582]                     NULL
[10:25:51.582]                   }
[10:25:51.582]                   options(future.plan = NULL)
[10:25:51.582]                   if (is.na(NA_character_)) 
[10:25:51.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.582]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.582]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.582]                     envir = parent.frame()) 
[10:25:51.582]                   {
[10:25:51.582]                     if (is.function(workers)) 
[10:25:51.582]                       workers <- workers()
[10:25:51.582]                     workers <- structure(as.integer(workers), 
[10:25:51.582]                       class = class(workers))
[10:25:51.582]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.582]                       workers >= 1)
[10:25:51.582]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.582]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.582]                     }
[10:25:51.582]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.582]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.582]                       envir = envir)
[10:25:51.582]                     if (!future$lazy) 
[10:25:51.582]                       future <- run(future)
[10:25:51.582]                     invisible(future)
[10:25:51.582]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.582]                 }
[10:25:51.582]             }
[10:25:51.582]         }
[10:25:51.582]     })
[10:25:51.582]     if (TRUE) {
[10:25:51.582]         base::sink(type = "output", split = FALSE)
[10:25:51.582]         if (TRUE) {
[10:25:51.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.582]         }
[10:25:51.582]         else {
[10:25:51.582]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.582]         }
[10:25:51.582]         base::close(...future.stdout)
[10:25:51.582]         ...future.stdout <- NULL
[10:25:51.582]     }
[10:25:51.582]     ...future.result$conditions <- ...future.conditions
[10:25:51.582]     ...future.result$finished <- base::Sys.time()
[10:25:51.582]     ...future.result
[10:25:51.582] }
[10:25:51.585] MultisessionFuture started
[10:25:51.585] - Launch lazy future ... done
[10:25:51.585] run() for ‘MultisessionFuture’ ... done
[10:25:51.585] getGlobalsAndPackages() ...
[10:25:51.585] Searching for globals...
[10:25:51.586] - globals found: [1] ‘{’
[10:25:51.586] Searching for globals ... DONE
[10:25:51.586] Resolving globals: FALSE
[10:25:51.586] 
[10:25:51.587] 
[10:25:51.587] getGlobalsAndPackages() ... DONE
[10:25:51.587] run() for ‘Future’ ...
[10:25:51.587] - state: ‘created’
[10:25:51.587] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:51.601] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:51.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:51.601]   - Field: ‘node’
[10:25:51.601]   - Field: ‘label’
[10:25:51.601]   - Field: ‘local’
[10:25:51.602]   - Field: ‘owner’
[10:25:51.602]   - Field: ‘envir’
[10:25:51.602]   - Field: ‘workers’
[10:25:51.602]   - Field: ‘packages’
[10:25:51.602]   - Field: ‘gc’
[10:25:51.602]   - Field: ‘conditions’
[10:25:51.602]   - Field: ‘persistent’
[10:25:51.602]   - Field: ‘expr’
[10:25:51.602]   - Field: ‘uuid’
[10:25:51.602]   - Field: ‘seed’
[10:25:51.602]   - Field: ‘version’
[10:25:51.603]   - Field: ‘result’
[10:25:51.603]   - Field: ‘asynchronous’
[10:25:51.603]   - Field: ‘calls’
[10:25:51.603]   - Field: ‘globals’
[10:25:51.603]   - Field: ‘stdout’
[10:25:51.603]   - Field: ‘earlySignal’
[10:25:51.603]   - Field: ‘lazy’
[10:25:51.603]   - Field: ‘state’
[10:25:51.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:51.603] - Launch lazy future ...
[10:25:51.604] Packages needed by the future expression (n = 0): <none>
[10:25:51.604] Packages needed by future strategies (n = 0): <none>
[10:25:51.604] {
[10:25:51.604]     {
[10:25:51.604]         {
[10:25:51.604]             ...future.startTime <- base::Sys.time()
[10:25:51.604]             {
[10:25:51.604]                 {
[10:25:51.604]                   {
[10:25:51.604]                     {
[10:25:51.604]                       base::local({
[10:25:51.604]                         has_future <- base::requireNamespace("future", 
[10:25:51.604]                           quietly = TRUE)
[10:25:51.604]                         if (has_future) {
[10:25:51.604]                           ns <- base::getNamespace("future")
[10:25:51.604]                           version <- ns[[".package"]][["version"]]
[10:25:51.604]                           if (is.null(version)) 
[10:25:51.604]                             version <- utils::packageVersion("future")
[10:25:51.604]                         }
[10:25:51.604]                         else {
[10:25:51.604]                           version <- NULL
[10:25:51.604]                         }
[10:25:51.604]                         if (!has_future || version < "1.8.0") {
[10:25:51.604]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:51.604]                             "", base::R.version$version.string), 
[10:25:51.604]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:51.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:51.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:51.604]                               "release", "version")], collapse = " "), 
[10:25:51.604]                             hostname = base::Sys.info()[["nodename"]])
[10:25:51.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:51.604]                             info)
[10:25:51.604]                           info <- base::paste(info, collapse = "; ")
[10:25:51.604]                           if (!has_future) {
[10:25:51.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:51.604]                               info)
[10:25:51.604]                           }
[10:25:51.604]                           else {
[10:25:51.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:51.604]                               info, version)
[10:25:51.604]                           }
[10:25:51.604]                           base::stop(msg)
[10:25:51.604]                         }
[10:25:51.604]                       })
[10:25:51.604]                     }
[10:25:51.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:51.604]                     base::options(mc.cores = 1L)
[10:25:51.604]                   }
[10:25:51.604]                   options(future.plan = NULL)
[10:25:51.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:51.604]                 }
[10:25:51.604]                 ...future.workdir <- getwd()
[10:25:51.604]             }
[10:25:51.604]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:51.604]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:51.604]         }
[10:25:51.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:51.604]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:51.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:51.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:51.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:51.604]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:51.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:51.604]             base::names(...future.oldOptions))
[10:25:51.604]     }
[10:25:51.604]     if (FALSE) {
[10:25:51.604]     }
[10:25:51.604]     else {
[10:25:51.604]         if (TRUE) {
[10:25:51.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:51.604]                 open = "w")
[10:25:51.604]         }
[10:25:51.604]         else {
[10:25:51.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:51.604]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:51.604]         }
[10:25:51.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:51.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:51.604]             base::sink(type = "output", split = FALSE)
[10:25:51.604]             base::close(...future.stdout)
[10:25:51.604]         }, add = TRUE)
[10:25:51.604]     }
[10:25:51.604]     ...future.frame <- base::sys.nframe()
[10:25:51.604]     ...future.conditions <- base::list()
[10:25:51.604]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:51.604]     if (FALSE) {
[10:25:51.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:51.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:51.604]     }
[10:25:51.604]     ...future.result <- base::tryCatch({
[10:25:51.604]         base::withCallingHandlers({
[10:25:51.604]             ...future.value <- base::withVisible(base::local({
[10:25:51.604]                 ...future.makeSendCondition <- base::local({
[10:25:51.604]                   sendCondition <- NULL
[10:25:51.604]                   function(frame = 1L) {
[10:25:51.604]                     if (is.function(sendCondition)) 
[10:25:51.604]                       return(sendCondition)
[10:25:51.604]                     ns <- getNamespace("parallel")
[10:25:51.604]                     if (exists("sendData", mode = "function", 
[10:25:51.604]                       envir = ns)) {
[10:25:51.604]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:51.604]                         envir = ns)
[10:25:51.604]                       envir <- sys.frame(frame)
[10:25:51.604]                       master <- NULL
[10:25:51.604]                       while (!identical(envir, .GlobalEnv) && 
[10:25:51.604]                         !identical(envir, emptyenv())) {
[10:25:51.604]                         if (exists("master", mode = "list", envir = envir, 
[10:25:51.604]                           inherits = FALSE)) {
[10:25:51.604]                           master <- get("master", mode = "list", 
[10:25:51.604]                             envir = envir, inherits = FALSE)
[10:25:51.604]                           if (inherits(master, c("SOCKnode", 
[10:25:51.604]                             "SOCK0node"))) {
[10:25:51.604]                             sendCondition <<- function(cond) {
[10:25:51.604]                               data <- list(type = "VALUE", value = cond, 
[10:25:51.604]                                 success = TRUE)
[10:25:51.604]                               parallel_sendData(master, data)
[10:25:51.604]                             }
[10:25:51.604]                             return(sendCondition)
[10:25:51.604]                           }
[10:25:51.604]                         }
[10:25:51.604]                         frame <- frame + 1L
[10:25:51.604]                         envir <- sys.frame(frame)
[10:25:51.604]                       }
[10:25:51.604]                     }
[10:25:51.604]                     sendCondition <<- function(cond) NULL
[10:25:51.604]                   }
[10:25:51.604]                 })
[10:25:51.604]                 withCallingHandlers({
[10:25:51.604]                   {
[10:25:51.604]                     4
[10:25:51.604]                   }
[10:25:51.604]                 }, immediateCondition = function(cond) {
[10:25:51.604]                   sendCondition <- ...future.makeSendCondition()
[10:25:51.604]                   sendCondition(cond)
[10:25:51.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.604]                   {
[10:25:51.604]                     inherits <- base::inherits
[10:25:51.604]                     invokeRestart <- base::invokeRestart
[10:25:51.604]                     is.null <- base::is.null
[10:25:51.604]                     muffled <- FALSE
[10:25:51.604]                     if (inherits(cond, "message")) {
[10:25:51.604]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:51.604]                       if (muffled) 
[10:25:51.604]                         invokeRestart("muffleMessage")
[10:25:51.604]                     }
[10:25:51.604]                     else if (inherits(cond, "warning")) {
[10:25:51.604]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:51.604]                       if (muffled) 
[10:25:51.604]                         invokeRestart("muffleWarning")
[10:25:51.604]                     }
[10:25:51.604]                     else if (inherits(cond, "condition")) {
[10:25:51.604]                       if (!is.null(pattern)) {
[10:25:51.604]                         computeRestarts <- base::computeRestarts
[10:25:51.604]                         grepl <- base::grepl
[10:25:51.604]                         restarts <- computeRestarts(cond)
[10:25:51.604]                         for (restart in restarts) {
[10:25:51.604]                           name <- restart$name
[10:25:51.604]                           if (is.null(name)) 
[10:25:51.604]                             next
[10:25:51.604]                           if (!grepl(pattern, name)) 
[10:25:51.604]                             next
[10:25:51.604]                           invokeRestart(restart)
[10:25:51.604]                           muffled <- TRUE
[10:25:51.604]                           break
[10:25:51.604]                         }
[10:25:51.604]                       }
[10:25:51.604]                     }
[10:25:51.604]                     invisible(muffled)
[10:25:51.604]                   }
[10:25:51.604]                   muffleCondition(cond)
[10:25:51.604]                 })
[10:25:51.604]             }))
[10:25:51.604]             future::FutureResult(value = ...future.value$value, 
[10:25:51.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.604]                   ...future.rng), globalenv = if (FALSE) 
[10:25:51.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:51.604]                     ...future.globalenv.names))
[10:25:51.604]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:51.604]         }, condition = base::local({
[10:25:51.604]             c <- base::c
[10:25:51.604]             inherits <- base::inherits
[10:25:51.604]             invokeRestart <- base::invokeRestart
[10:25:51.604]             length <- base::length
[10:25:51.604]             list <- base::list
[10:25:51.604]             seq.int <- base::seq.int
[10:25:51.604]             signalCondition <- base::signalCondition
[10:25:51.604]             sys.calls <- base::sys.calls
[10:25:51.604]             `[[` <- base::`[[`
[10:25:51.604]             `+` <- base::`+`
[10:25:51.604]             `<<-` <- base::`<<-`
[10:25:51.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:51.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:51.604]                   3L)]
[10:25:51.604]             }
[10:25:51.604]             function(cond) {
[10:25:51.604]                 is_error <- inherits(cond, "error")
[10:25:51.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:51.604]                   NULL)
[10:25:51.604]                 if (is_error) {
[10:25:51.604]                   sessionInformation <- function() {
[10:25:51.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:51.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:51.604]                       search = base::search(), system = base::Sys.info())
[10:25:51.604]                   }
[10:25:51.604]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:51.604]                     cond$call), session = sessionInformation(), 
[10:25:51.604]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:51.604]                   signalCondition(cond)
[10:25:51.604]                 }
[10:25:51.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:51.604]                 "immediateCondition"))) {
[10:25:51.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:51.604]                   ...future.conditions[[length(...future.conditions) + 
[10:25:51.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:51.604]                   if (TRUE && !signal) {
[10:25:51.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.604]                     {
[10:25:51.604]                       inherits <- base::inherits
[10:25:51.604]                       invokeRestart <- base::invokeRestart
[10:25:51.604]                       is.null <- base::is.null
[10:25:51.604]                       muffled <- FALSE
[10:25:51.604]                       if (inherits(cond, "message")) {
[10:25:51.604]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.604]                         if (muffled) 
[10:25:51.604]                           invokeRestart("muffleMessage")
[10:25:51.604]                       }
[10:25:51.604]                       else if (inherits(cond, "warning")) {
[10:25:51.604]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.604]                         if (muffled) 
[10:25:51.604]                           invokeRestart("muffleWarning")
[10:25:51.604]                       }
[10:25:51.604]                       else if (inherits(cond, "condition")) {
[10:25:51.604]                         if (!is.null(pattern)) {
[10:25:51.604]                           computeRestarts <- base::computeRestarts
[10:25:51.604]                           grepl <- base::grepl
[10:25:51.604]                           restarts <- computeRestarts(cond)
[10:25:51.604]                           for (restart in restarts) {
[10:25:51.604]                             name <- restart$name
[10:25:51.604]                             if (is.null(name)) 
[10:25:51.604]                               next
[10:25:51.604]                             if (!grepl(pattern, name)) 
[10:25:51.604]                               next
[10:25:51.604]                             invokeRestart(restart)
[10:25:51.604]                             muffled <- TRUE
[10:25:51.604]                             break
[10:25:51.604]                           }
[10:25:51.604]                         }
[10:25:51.604]                       }
[10:25:51.604]                       invisible(muffled)
[10:25:51.604]                     }
[10:25:51.604]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.604]                   }
[10:25:51.604]                 }
[10:25:51.604]                 else {
[10:25:51.604]                   if (TRUE) {
[10:25:51.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:51.604]                     {
[10:25:51.604]                       inherits <- base::inherits
[10:25:51.604]                       invokeRestart <- base::invokeRestart
[10:25:51.604]                       is.null <- base::is.null
[10:25:51.604]                       muffled <- FALSE
[10:25:51.604]                       if (inherits(cond, "message")) {
[10:25:51.604]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:51.604]                         if (muffled) 
[10:25:51.604]                           invokeRestart("muffleMessage")
[10:25:51.604]                       }
[10:25:51.604]                       else if (inherits(cond, "warning")) {
[10:25:51.604]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:51.604]                         if (muffled) 
[10:25:51.604]                           invokeRestart("muffleWarning")
[10:25:51.604]                       }
[10:25:51.604]                       else if (inherits(cond, "condition")) {
[10:25:51.604]                         if (!is.null(pattern)) {
[10:25:51.604]                           computeRestarts <- base::computeRestarts
[10:25:51.604]                           grepl <- base::grepl
[10:25:51.604]                           restarts <- computeRestarts(cond)
[10:25:51.604]                           for (restart in restarts) {
[10:25:51.604]                             name <- restart$name
[10:25:51.604]                             if (is.null(name)) 
[10:25:51.604]                               next
[10:25:51.604]                             if (!grepl(pattern, name)) 
[10:25:51.604]                               next
[10:25:51.604]                             invokeRestart(restart)
[10:25:51.604]                             muffled <- TRUE
[10:25:51.604]                             break
[10:25:51.604]                           }
[10:25:51.604]                         }
[10:25:51.604]                       }
[10:25:51.604]                       invisible(muffled)
[10:25:51.604]                     }
[10:25:51.604]                     muffleCondition(cond, pattern = "^muffle")
[10:25:51.604]                   }
[10:25:51.604]                 }
[10:25:51.604]             }
[10:25:51.604]         }))
[10:25:51.604]     }, error = function(ex) {
[10:25:51.604]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:51.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:51.604]                 ...future.rng), started = ...future.startTime, 
[10:25:51.604]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:51.604]             version = "1.8"), class = "FutureResult")
[10:25:51.604]     }, finally = {
[10:25:51.604]         if (!identical(...future.workdir, getwd())) 
[10:25:51.604]             setwd(...future.workdir)
[10:25:51.604]         {
[10:25:51.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:51.604]                 ...future.oldOptions$nwarnings <- NULL
[10:25:51.604]             }
[10:25:51.604]             base::options(...future.oldOptions)
[10:25:51.604]             if (.Platform$OS.type == "windows") {
[10:25:51.604]                 old_names <- names(...future.oldEnvVars)
[10:25:51.604]                 envs <- base::Sys.getenv()
[10:25:51.604]                 names <- names(envs)
[10:25:51.604]                 common <- intersect(names, old_names)
[10:25:51.604]                 added <- setdiff(names, old_names)
[10:25:51.604]                 removed <- setdiff(old_names, names)
[10:25:51.604]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:51.604]                   envs[common]]
[10:25:51.604]                 NAMES <- toupper(changed)
[10:25:51.604]                 args <- list()
[10:25:51.604]                 for (kk in seq_along(NAMES)) {
[10:25:51.604]                   name <- changed[[kk]]
[10:25:51.604]                   NAME <- NAMES[[kk]]
[10:25:51.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.604]                     next
[10:25:51.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.604]                 }
[10:25:51.604]                 NAMES <- toupper(added)
[10:25:51.604]                 for (kk in seq_along(NAMES)) {
[10:25:51.604]                   name <- added[[kk]]
[10:25:51.604]                   NAME <- NAMES[[kk]]
[10:25:51.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.604]                     next
[10:25:51.604]                   args[[name]] <- ""
[10:25:51.604]                 }
[10:25:51.604]                 NAMES <- toupper(removed)
[10:25:51.604]                 for (kk in seq_along(NAMES)) {
[10:25:51.604]                   name <- removed[[kk]]
[10:25:51.604]                   NAME <- NAMES[[kk]]
[10:25:51.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:51.604]                     next
[10:25:51.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:51.604]                 }
[10:25:51.604]                 if (length(args) > 0) 
[10:25:51.604]                   base::do.call(base::Sys.setenv, args = args)
[10:25:51.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:51.604]             }
[10:25:51.604]             else {
[10:25:51.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:51.604]             }
[10:25:51.604]             {
[10:25:51.604]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:51.604]                   0L) {
[10:25:51.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:51.604]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:51.604]                   base::options(opts)
[10:25:51.604]                 }
[10:25:51.604]                 {
[10:25:51.604]                   {
[10:25:51.604]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:51.604]                     NULL
[10:25:51.604]                   }
[10:25:51.604]                   options(future.plan = NULL)
[10:25:51.604]                   if (is.na(NA_character_)) 
[10:25:51.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:51.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:51.604]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:51.604]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:51.604]                     envir = parent.frame()) 
[10:25:51.604]                   {
[10:25:51.604]                     if (is.function(workers)) 
[10:25:51.604]                       workers <- workers()
[10:25:51.604]                     workers <- structure(as.integer(workers), 
[10:25:51.604]                       class = class(workers))
[10:25:51.604]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:51.604]                       workers >= 1)
[10:25:51.604]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:51.604]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:51.604]                     }
[10:25:51.604]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:51.604]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:51.604]                       envir = envir)
[10:25:51.604]                     if (!future$lazy) 
[10:25:51.604]                       future <- run(future)
[10:25:51.604]                     invisible(future)
[10:25:51.604]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:51.604]                 }
[10:25:51.604]             }
[10:25:51.604]         }
[10:25:51.604]     })
[10:25:51.604]     if (TRUE) {
[10:25:51.604]         base::sink(type = "output", split = FALSE)
[10:25:51.604]         if (TRUE) {
[10:25:51.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:51.604]         }
[10:25:51.604]         else {
[10:25:51.604]             ...future.result["stdout"] <- base::list(NULL)
[10:25:51.604]         }
[10:25:51.604]         base::close(...future.stdout)
[10:25:51.604]         ...future.stdout <- NULL
[10:25:51.604]     }
[10:25:51.604]     ...future.result$conditions <- ...future.conditions
[10:25:51.604]     ...future.result$finished <- base::Sys.time()
[10:25:51.604]     ...future.result
[10:25:51.604] }
[10:25:51.606] Poll #1 (0): usedNodes() = 2, workers = 2
[10:25:51.617] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.617] - Validating connection of MultisessionFuture
[10:25:51.618] - received message: FutureResult
[10:25:51.618] - Received FutureResult
[10:25:51.618] - Erased future from FutureRegistry
[10:25:51.618] result() for ClusterFuture ...
[10:25:51.618] - result already collected: FutureResult
[10:25:51.618] result() for ClusterFuture ... done
[10:25:51.618] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.618] result() for ClusterFuture ...
[10:25:51.619] - result already collected: FutureResult
[10:25:51.619] result() for ClusterFuture ... done
[10:25:51.619] result() for ClusterFuture ...
[10:25:51.619] - result already collected: FutureResult
[10:25:51.619] result() for ClusterFuture ... done
[10:25:51.620] MultisessionFuture started
[10:25:51.620] - Launch lazy future ... done
[10:25:51.620] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55c0f61ecf70> 
Classes 'listenv', 'environment' <environment: 0x55c0f703b0b0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:25:51.634] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.634] - Validating connection of MultisessionFuture
[10:25:51.634] - received message: FutureResult
[10:25:51.635] - Received FutureResult
[10:25:51.635] - Erased future from FutureRegistry
[10:25:51.635] result() for ClusterFuture ...
[10:25:51.635] - result already collected: FutureResult
[10:25:51.635] result() for ClusterFuture ... done
[10:25:51.635] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:25:51.648] resolve() on list environment ...
[10:25:51.648]  recursive: 0
[10:25:51.649]  length: 6
[10:25:51.649]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:25:51.650] signalConditionsASAP(numeric, pos=1) ...
[10:25:51.650] - nx: 6
[10:25:51.650] - relay: TRUE
[10:25:51.650] - stdout: TRUE
[10:25:51.650] - signal: TRUE
[10:25:51.650] - resignal: FALSE
[10:25:51.650] - force: TRUE
[10:25:51.650] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.650] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.650]  - until=2
[10:25:51.650]  - relaying element #2
[10:25:51.651] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.651] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.651] signalConditionsASAP(NULL, pos=1) ... done
[10:25:51.651]  length: 5 (resolved future 1)
[10:25:51.651] Future #2
[10:25:51.651] result() for ClusterFuture ...
[10:25:51.651] - result already collected: FutureResult
[10:25:51.651] result() for ClusterFuture ... done
[10:25:51.651] result() for ClusterFuture ...
[10:25:51.651] - result already collected: FutureResult
[10:25:51.651] result() for ClusterFuture ... done
[10:25:51.652] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:25:51.652] - nx: 6
[10:25:51.652] - relay: TRUE
[10:25:51.652] - stdout: TRUE
[10:25:51.652] - signal: TRUE
[10:25:51.652] - resignal: FALSE
[10:25:51.652] - force: TRUE
[10:25:51.652] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.652] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:25:51.652]  - until=2
[10:25:51.652]  - relaying element #2
[10:25:51.652] result() for ClusterFuture ...
[10:25:51.653] - result already collected: FutureResult
[10:25:51.653] result() for ClusterFuture ... done
[10:25:51.653] result() for ClusterFuture ...
[10:25:51.653] - result already collected: FutureResult
[10:25:51.653] result() for ClusterFuture ... done
[10:25:51.653] result() for ClusterFuture ...
[10:25:51.653] - result already collected: FutureResult
[10:25:51.653] result() for ClusterFuture ... done
[10:25:51.653] result() for ClusterFuture ...
[10:25:51.653] - result already collected: FutureResult
[10:25:51.653] result() for ClusterFuture ... done
[10:25:51.654] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.654] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.654] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:25:51.654]  length: 4 (resolved future 2)
[10:25:51.654] Future #3
[10:25:51.654] result() for ClusterFuture ...
[10:25:51.654] - result already collected: FutureResult
[10:25:51.654] result() for ClusterFuture ... done
[10:25:51.654] result() for ClusterFuture ...
[10:25:51.655] - result already collected: FutureResult
[10:25:51.655] result() for ClusterFuture ... done
[10:25:51.655] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:25:51.655] - nx: 6
[10:25:51.655] - relay: TRUE
[10:25:51.655] - stdout: TRUE
[10:25:51.655] - signal: TRUE
[10:25:51.655] - resignal: FALSE
[10:25:51.655] - force: TRUE
[10:25:51.655] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.655] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:25:51.655]  - until=3
[10:25:51.656]  - relaying element #3
[10:25:51.656] result() for ClusterFuture ...
[10:25:51.656] - result already collected: FutureResult
[10:25:51.656] result() for ClusterFuture ... done
[10:25:51.656] result() for ClusterFuture ...
[10:25:51.656] - result already collected: FutureResult
[10:25:51.656] result() for ClusterFuture ... done
[10:25:51.656] result() for ClusterFuture ...
[10:25:51.656] - result already collected: FutureResult
[10:25:51.656] result() for ClusterFuture ... done
[10:25:51.656] result() for ClusterFuture ...
[10:25:51.656] - result already collected: FutureResult
[10:25:51.657] result() for ClusterFuture ... done
[10:25:51.657] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.657] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.657] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:25:51.657]  length: 3 (resolved future 3)
[10:25:51.666] receiveMessageFromWorker() for ClusterFuture ...
[10:25:51.666] - Validating connection of MultisessionFuture
[10:25:51.666] - received message: FutureResult
[10:25:51.666] - Received FutureResult
[10:25:51.667] - Erased future from FutureRegistry
[10:25:51.667] result() for ClusterFuture ...
[10:25:51.667] - result already collected: FutureResult
[10:25:51.667] result() for ClusterFuture ... done
[10:25:51.667] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:51.667] Future #4
[10:25:51.667] result() for ClusterFuture ...
[10:25:51.667] - result already collected: FutureResult
[10:25:51.667] result() for ClusterFuture ... done
[10:25:51.667] result() for ClusterFuture ...
[10:25:51.668] - result already collected: FutureResult
[10:25:51.668] result() for ClusterFuture ... done
[10:25:51.668] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:25:51.668] - nx: 6
[10:25:51.668] - relay: TRUE
[10:25:51.668] - stdout: TRUE
[10:25:51.668] - signal: TRUE
[10:25:51.668] - resignal: FALSE
[10:25:51.668] - force: TRUE
[10:25:51.668] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.668] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:25:51.668]  - until=4
[10:25:51.669]  - relaying element #4
[10:25:51.669] result() for ClusterFuture ...
[10:25:51.669] - result already collected: FutureResult
[10:25:51.669] result() for ClusterFuture ... done
[10:25:51.669] result() for ClusterFuture ...
[10:25:51.669] - result already collected: FutureResult
[10:25:51.669] result() for ClusterFuture ... done
[10:25:51.669] result() for ClusterFuture ...
[10:25:51.669] - result already collected: FutureResult
[10:25:51.669] result() for ClusterFuture ... done
[10:25:51.670] result() for ClusterFuture ...
[10:25:51.670] - result already collected: FutureResult
[10:25:51.670] result() for ClusterFuture ... done
[10:25:51.670] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.670] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.670] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:25:51.670]  length: 2 (resolved future 4)
[10:25:51.670] signalConditionsASAP(NULL, pos=5) ...
[10:25:51.670] - nx: 6
[10:25:51.670] - relay: TRUE
[10:25:51.670] - stdout: TRUE
[10:25:51.671] - signal: TRUE
[10:25:51.671] - resignal: FALSE
[10:25:51.671] - force: TRUE
[10:25:51.671] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.671] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.671]  - until=6
[10:25:51.671]  - relaying element #6
[10:25:51.671] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:51.671] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.671] signalConditionsASAP(NULL, pos=5) ... done
[10:25:51.671]  length: 1 (resolved future 5)
[10:25:51.672] signalConditionsASAP(numeric, pos=6) ...
[10:25:51.672] - nx: 6
[10:25:51.672] - relay: TRUE
[10:25:51.672] - stdout: TRUE
[10:25:51.672] - signal: TRUE
[10:25:51.672] - resignal: FALSE
[10:25:51.672] - force: TRUE
[10:25:51.672] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:25:51.672] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.672]  - until=6
[10:25:51.672] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.672] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.673] signalConditionsASAP(numeric, pos=6) ... done
[10:25:51.673]  length: 0 (resolved future 6)
[10:25:51.673] Relaying remaining futures
[10:25:51.673] signalConditionsASAP(NULL, pos=0) ...
[10:25:51.673] - nx: 6
[10:25:51.673] - relay: TRUE
[10:25:51.673] - stdout: TRUE
[10:25:51.673] - signal: TRUE
[10:25:51.673] - resignal: FALSE
[10:25:51.673] - force: TRUE
[10:25:51.673] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.674] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:25:51.674] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:25:51.674] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:25:51.674] signalConditionsASAP(NULL, pos=0) ... done
[10:25:51.674] resolve() on list environment ... DONE
[10:25:51.674] result() for ClusterFuture ...
[10:25:51.674] - result already collected: FutureResult
[10:25:51.674] result() for ClusterFuture ... done
[10:25:51.674] result() for ClusterFuture ...
[10:25:51.674] - result already collected: FutureResult
[10:25:51.675] result() for ClusterFuture ... done
[10:25:51.675] result() for ClusterFuture ...
[10:25:51.675] - result already collected: FutureResult
[10:25:51.675] result() for ClusterFuture ... done
[10:25:51.675] result() for ClusterFuture ...
[10:25:51.675] - result already collected: FutureResult
[10:25:51.675] result() for ClusterFuture ... done
[10:25:51.675] result() for ClusterFuture ...
[10:25:51.675] - result already collected: FutureResult
[10:25:51.675] result() for ClusterFuture ... done
[10:25:51.676] result() for ClusterFuture ...
[10:25:51.676] - result already collected: FutureResult
[10:25:51.676] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55c0f557e388> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[10:25:51.679] plan(): Setting new future strategy stack:
[10:25:51.679] List of future strategies:
[10:25:51.679] 1. FutureStrategy:
[10:25:51.679]    - args: function (..., envir = parent.frame())
[10:25:51.679]    - tweaked: FALSE
[10:25:51.679]    - call: future::plan(oplan)
[10:25:51.679] plan(): nbrOfWorkers() = 1
> 
