
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:23:04.889] plan(): Setting new future strategy stack:
[13:23:04.890] List of future strategies:
[13:23:04.890] 1. sequential:
[13:23:04.890]    - args: function (..., envir = parent.frame())
[13:23:04.890]    - tweaked: FALSE
[13:23:04.890]    - call: future::plan("sequential")
[13:23:04.906] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[13:23:04.962] plan(): Setting new future strategy stack:
[13:23:04.962] List of future strategies:
[13:23:04.962] 1. sequential:
[13:23:04.962]    - args: function (..., envir = parent.frame())
[13:23:04.962]    - tweaked: FALSE
[13:23:04.962]    - call: plan(strategy)
[13:23:04.975] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[13:23:04.976] getGlobalsAndPackages() ...
[13:23:04.976] Searching for globals...
[13:23:04.978] 
[13:23:04.979] Searching for globals ... DONE
[13:23:04.979] - globals: [0] <none>
[13:23:04.979] getGlobalsAndPackages() ... DONE
[13:23:04.980] run() for ‘Future’ ...
[13:23:04.980] - state: ‘created’
[13:23:04.980] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:04.980] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:04.980] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:04.981]   - Field: ‘label’
[13:23:04.981]   - Field: ‘local’
[13:23:04.981]   - Field: ‘owner’
[13:23:04.981]   - Field: ‘envir’
[13:23:04.981]   - Field: ‘packages’
[13:23:04.981]   - Field: ‘gc’
[13:23:04.981]   - Field: ‘conditions’
[13:23:04.981]   - Field: ‘expr’
[13:23:04.981]   - Field: ‘uuid’
[13:23:04.981]   - Field: ‘seed’
[13:23:04.981]   - Field: ‘version’
[13:23:04.982]   - Field: ‘result’
[13:23:04.982]   - Field: ‘asynchronous’
[13:23:04.982]   - Field: ‘calls’
[13:23:04.982]   - Field: ‘globals’
[13:23:04.982]   - Field: ‘stdout’
[13:23:04.982]   - Field: ‘earlySignal’
[13:23:04.982]   - Field: ‘lazy’
[13:23:04.982]   - Field: ‘state’
[13:23:04.982] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:04.982] - Launch lazy future ...
[13:23:04.983] Packages needed by the future expression (n = 0): <none>
[13:23:04.983] Packages needed by future strategies (n = 0): <none>
[13:23:04.984] {
[13:23:04.984]     {
[13:23:04.984]         {
[13:23:04.984]             ...future.startTime <- base::Sys.time()
[13:23:04.984]             {
[13:23:04.984]                 {
[13:23:04.984]                   {
[13:23:04.984]                     base::local({
[13:23:04.984]                       has_future <- base::requireNamespace("future", 
[13:23:04.984]                         quietly = TRUE)
[13:23:04.984]                       if (has_future) {
[13:23:04.984]                         ns <- base::getNamespace("future")
[13:23:04.984]                         version <- ns[[".package"]][["version"]]
[13:23:04.984]                         if (is.null(version)) 
[13:23:04.984]                           version <- utils::packageVersion("future")
[13:23:04.984]                       }
[13:23:04.984]                       else {
[13:23:04.984]                         version <- NULL
[13:23:04.984]                       }
[13:23:04.984]                       if (!has_future || version < "1.8.0") {
[13:23:04.984]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:04.984]                           "", base::R.version$version.string), 
[13:23:04.984]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:04.984]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:04.984]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:04.984]                             "release", "version")], collapse = " "), 
[13:23:04.984]                           hostname = base::Sys.info()[["nodename"]])
[13:23:04.984]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:04.984]                           info)
[13:23:04.984]                         info <- base::paste(info, collapse = "; ")
[13:23:04.984]                         if (!has_future) {
[13:23:04.984]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:04.984]                             info)
[13:23:04.984]                         }
[13:23:04.984]                         else {
[13:23:04.984]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:04.984]                             info, version)
[13:23:04.984]                         }
[13:23:04.984]                         base::stop(msg)
[13:23:04.984]                       }
[13:23:04.984]                     })
[13:23:04.984]                   }
[13:23:04.984]                   options(future.plan = NULL)
[13:23:04.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:04.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:04.984]                 }
[13:23:04.984]                 ...future.workdir <- getwd()
[13:23:04.984]             }
[13:23:04.984]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:04.984]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:04.984]         }
[13:23:04.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:04.984]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:04.984]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:04.984]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:04.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:04.984]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:04.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:04.984]             base::names(...future.oldOptions))
[13:23:04.984]     }
[13:23:04.984]     if (FALSE) {
[13:23:04.984]     }
[13:23:04.984]     else {
[13:23:04.984]         if (TRUE) {
[13:23:04.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:04.984]                 open = "w")
[13:23:04.984]         }
[13:23:04.984]         else {
[13:23:04.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:04.984]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:04.984]         }
[13:23:04.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:04.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:04.984]             base::sink(type = "output", split = FALSE)
[13:23:04.984]             base::close(...future.stdout)
[13:23:04.984]         }, add = TRUE)
[13:23:04.984]     }
[13:23:04.984]     ...future.frame <- base::sys.nframe()
[13:23:04.984]     ...future.conditions <- base::list()
[13:23:04.984]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:04.984]     if (FALSE) {
[13:23:04.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:04.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:04.984]     }
[13:23:04.984]     ...future.result <- base::tryCatch({
[13:23:04.984]         base::withCallingHandlers({
[13:23:04.984]             ...future.value <- base::withVisible(base::local(2))
[13:23:04.984]             future::FutureResult(value = ...future.value$value, 
[13:23:04.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:04.984]                   ...future.rng), globalenv = if (FALSE) 
[13:23:04.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:04.984]                     ...future.globalenv.names))
[13:23:04.984]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:04.984]         }, condition = base::local({
[13:23:04.984]             c <- base::c
[13:23:04.984]             inherits <- base::inherits
[13:23:04.984]             invokeRestart <- base::invokeRestart
[13:23:04.984]             length <- base::length
[13:23:04.984]             list <- base::list
[13:23:04.984]             seq.int <- base::seq.int
[13:23:04.984]             signalCondition <- base::signalCondition
[13:23:04.984]             sys.calls <- base::sys.calls
[13:23:04.984]             `[[` <- base::`[[`
[13:23:04.984]             `+` <- base::`+`
[13:23:04.984]             `<<-` <- base::`<<-`
[13:23:04.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:04.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:04.984]                   3L)]
[13:23:04.984]             }
[13:23:04.984]             function(cond) {
[13:23:04.984]                 is_error <- inherits(cond, "error")
[13:23:04.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:04.984]                   NULL)
[13:23:04.984]                 if (is_error) {
[13:23:04.984]                   sessionInformation <- function() {
[13:23:04.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:04.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:04.984]                       search = base::search(), system = base::Sys.info())
[13:23:04.984]                   }
[13:23:04.984]                   ...future.conditions[[length(...future.conditions) + 
[13:23:04.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:04.984]                     cond$call), session = sessionInformation(), 
[13:23:04.984]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:04.984]                   signalCondition(cond)
[13:23:04.984]                 }
[13:23:04.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:04.984]                 "immediateCondition"))) {
[13:23:04.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:04.984]                   ...future.conditions[[length(...future.conditions) + 
[13:23:04.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:04.984]                   if (TRUE && !signal) {
[13:23:04.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:04.984]                     {
[13:23:04.984]                       inherits <- base::inherits
[13:23:04.984]                       invokeRestart <- base::invokeRestart
[13:23:04.984]                       is.null <- base::is.null
[13:23:04.984]                       muffled <- FALSE
[13:23:04.984]                       if (inherits(cond, "message")) {
[13:23:04.984]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:04.984]                         if (muffled) 
[13:23:04.984]                           invokeRestart("muffleMessage")
[13:23:04.984]                       }
[13:23:04.984]                       else if (inherits(cond, "warning")) {
[13:23:04.984]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:04.984]                         if (muffled) 
[13:23:04.984]                           invokeRestart("muffleWarning")
[13:23:04.984]                       }
[13:23:04.984]                       else if (inherits(cond, "condition")) {
[13:23:04.984]                         if (!is.null(pattern)) {
[13:23:04.984]                           computeRestarts <- base::computeRestarts
[13:23:04.984]                           grepl <- base::grepl
[13:23:04.984]                           restarts <- computeRestarts(cond)
[13:23:04.984]                           for (restart in restarts) {
[13:23:04.984]                             name <- restart$name
[13:23:04.984]                             if (is.null(name)) 
[13:23:04.984]                               next
[13:23:04.984]                             if (!grepl(pattern, name)) 
[13:23:04.984]                               next
[13:23:04.984]                             invokeRestart(restart)
[13:23:04.984]                             muffled <- TRUE
[13:23:04.984]                             break
[13:23:04.984]                           }
[13:23:04.984]                         }
[13:23:04.984]                       }
[13:23:04.984]                       invisible(muffled)
[13:23:04.984]                     }
[13:23:04.984]                     muffleCondition(cond, pattern = "^muffle")
[13:23:04.984]                   }
[13:23:04.984]                 }
[13:23:04.984]                 else {
[13:23:04.984]                   if (TRUE) {
[13:23:04.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:04.984]                     {
[13:23:04.984]                       inherits <- base::inherits
[13:23:04.984]                       invokeRestart <- base::invokeRestart
[13:23:04.984]                       is.null <- base::is.null
[13:23:04.984]                       muffled <- FALSE
[13:23:04.984]                       if (inherits(cond, "message")) {
[13:23:04.984]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:04.984]                         if (muffled) 
[13:23:04.984]                           invokeRestart("muffleMessage")
[13:23:04.984]                       }
[13:23:04.984]                       else if (inherits(cond, "warning")) {
[13:23:04.984]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:04.984]                         if (muffled) 
[13:23:04.984]                           invokeRestart("muffleWarning")
[13:23:04.984]                       }
[13:23:04.984]                       else if (inherits(cond, "condition")) {
[13:23:04.984]                         if (!is.null(pattern)) {
[13:23:04.984]                           computeRestarts <- base::computeRestarts
[13:23:04.984]                           grepl <- base::grepl
[13:23:04.984]                           restarts <- computeRestarts(cond)
[13:23:04.984]                           for (restart in restarts) {
[13:23:04.984]                             name <- restart$name
[13:23:04.984]                             if (is.null(name)) 
[13:23:04.984]                               next
[13:23:04.984]                             if (!grepl(pattern, name)) 
[13:23:04.984]                               next
[13:23:04.984]                             invokeRestart(restart)
[13:23:04.984]                             muffled <- TRUE
[13:23:04.984]                             break
[13:23:04.984]                           }
[13:23:04.984]                         }
[13:23:04.984]                       }
[13:23:04.984]                       invisible(muffled)
[13:23:04.984]                     }
[13:23:04.984]                     muffleCondition(cond, pattern = "^muffle")
[13:23:04.984]                   }
[13:23:04.984]                 }
[13:23:04.984]             }
[13:23:04.984]         }))
[13:23:04.984]     }, error = function(ex) {
[13:23:04.984]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:04.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:04.984]                 ...future.rng), started = ...future.startTime, 
[13:23:04.984]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:04.984]             version = "1.8"), class = "FutureResult")
[13:23:04.984]     }, finally = {
[13:23:04.984]         if (!identical(...future.workdir, getwd())) 
[13:23:04.984]             setwd(...future.workdir)
[13:23:04.984]         {
[13:23:04.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:04.984]                 ...future.oldOptions$nwarnings <- NULL
[13:23:04.984]             }
[13:23:04.984]             base::options(...future.oldOptions)
[13:23:04.984]             if (.Platform$OS.type == "windows") {
[13:23:04.984]                 old_names <- names(...future.oldEnvVars)
[13:23:04.984]                 envs <- base::Sys.getenv()
[13:23:04.984]                 names <- names(envs)
[13:23:04.984]                 common <- intersect(names, old_names)
[13:23:04.984]                 added <- setdiff(names, old_names)
[13:23:04.984]                 removed <- setdiff(old_names, names)
[13:23:04.984]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:04.984]                   envs[common]]
[13:23:04.984]                 NAMES <- toupper(changed)
[13:23:04.984]                 args <- list()
[13:23:04.984]                 for (kk in seq_along(NAMES)) {
[13:23:04.984]                   name <- changed[[kk]]
[13:23:04.984]                   NAME <- NAMES[[kk]]
[13:23:04.984]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:04.984]                     next
[13:23:04.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:04.984]                 }
[13:23:04.984]                 NAMES <- toupper(added)
[13:23:04.984]                 for (kk in seq_along(NAMES)) {
[13:23:04.984]                   name <- added[[kk]]
[13:23:04.984]                   NAME <- NAMES[[kk]]
[13:23:04.984]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:04.984]                     next
[13:23:04.984]                   args[[name]] <- ""
[13:23:04.984]                 }
[13:23:04.984]                 NAMES <- toupper(removed)
[13:23:04.984]                 for (kk in seq_along(NAMES)) {
[13:23:04.984]                   name <- removed[[kk]]
[13:23:04.984]                   NAME <- NAMES[[kk]]
[13:23:04.984]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:04.984]                     next
[13:23:04.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:04.984]                 }
[13:23:04.984]                 if (length(args) > 0) 
[13:23:04.984]                   base::do.call(base::Sys.setenv, args = args)
[13:23:04.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:04.984]             }
[13:23:04.984]             else {
[13:23:04.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:04.984]             }
[13:23:04.984]             {
[13:23:04.984]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:04.984]                   0L) {
[13:23:04.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:04.984]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:04.984]                   base::options(opts)
[13:23:04.984]                 }
[13:23:04.984]                 {
[13:23:04.984]                   {
[13:23:04.984]                     NULL
[13:23:04.984]                     RNGkind("Mersenne-Twister")
[13:23:04.984]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:04.984]                       inherits = FALSE)
[13:23:04.984]                   }
[13:23:04.984]                   options(future.plan = NULL)
[13:23:04.984]                   if (is.na(NA_character_)) 
[13:23:04.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:04.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:04.984]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:04.984]                   {
[13:23:04.984]                     future <- SequentialFuture(..., envir = envir)
[13:23:04.984]                     if (!future$lazy) 
[13:23:04.984]                       future <- run(future)
[13:23:04.984]                     invisible(future)
[13:23:04.984]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:04.984]                 }
[13:23:04.984]             }
[13:23:04.984]         }
[13:23:04.984]     })
[13:23:04.984]     if (TRUE) {
[13:23:04.984]         base::sink(type = "output", split = FALSE)
[13:23:04.984]         if (TRUE) {
[13:23:04.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:04.984]         }
[13:23:04.984]         else {
[13:23:04.984]             ...future.result["stdout"] <- base::list(NULL)
[13:23:04.984]         }
[13:23:04.984]         base::close(...future.stdout)
[13:23:04.984]         ...future.stdout <- NULL
[13:23:04.984]     }
[13:23:04.984]     ...future.result$conditions <- ...future.conditions
[13:23:04.984]     ...future.result$finished <- base::Sys.time()
[13:23:04.984]     ...future.result
[13:23:04.984] }
[13:23:04.986] plan(): Setting new future strategy stack:
[13:23:04.987] List of future strategies:
[13:23:04.987] 1. sequential:
[13:23:04.987]    - args: function (..., envir = parent.frame())
[13:23:04.987]    - tweaked: FALSE
[13:23:04.987]    - call: NULL
[13:23:04.987] plan(): nbrOfWorkers() = 1
[13:23:04.988] plan(): Setting new future strategy stack:
[13:23:04.988] List of future strategies:
[13:23:04.988] 1. sequential:
[13:23:04.988]    - args: function (..., envir = parent.frame())
[13:23:04.988]    - tweaked: FALSE
[13:23:04.988]    - call: plan(strategy)
[13:23:04.989] plan(): nbrOfWorkers() = 1
[13:23:04.989] SequentialFuture started (and completed)
[13:23:04.989] - Launch lazy future ... done
[13:23:04.990] run() for ‘SequentialFuture’ ... done
[13:23:04.990] getGlobalsAndPackages() ...
[13:23:04.990] Searching for globals...
[13:23:04.990] 
[13:23:04.990] Searching for globals ... DONE
[13:23:04.990] - globals: [0] <none>
[13:23:04.990] getGlobalsAndPackages() ... DONE
[13:23:04.991] run() for ‘Future’ ...
[13:23:04.991] - state: ‘created’
[13:23:04.991] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:04.991] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:04.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:04.991]   - Field: ‘label’
[13:23:04.992]   - Field: ‘local’
[13:23:04.992]   - Field: ‘owner’
[13:23:04.992]   - Field: ‘envir’
[13:23:04.992]   - Field: ‘packages’
[13:23:04.992]   - Field: ‘gc’
[13:23:04.992]   - Field: ‘conditions’
[13:23:04.992]   - Field: ‘expr’
[13:23:04.992]   - Field: ‘uuid’
[13:23:04.992]   - Field: ‘seed’
[13:23:04.992]   - Field: ‘version’
[13:23:04.993]   - Field: ‘result’
[13:23:04.993]   - Field: ‘asynchronous’
[13:23:04.993]   - Field: ‘calls’
[13:23:04.993]   - Field: ‘globals’
[13:23:04.993]   - Field: ‘stdout’
[13:23:04.993]   - Field: ‘earlySignal’
[13:23:04.993]   - Field: ‘lazy’
[13:23:04.993]   - Field: ‘state’
[13:23:04.993] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:04.993] - Launch lazy future ...
[13:23:04.994] Packages needed by the future expression (n = 0): <none>
[13:23:04.994] Packages needed by future strategies (n = 0): <none>
[13:23:04.994] {
[13:23:04.994]     {
[13:23:04.994]         {
[13:23:04.994]             ...future.startTime <- base::Sys.time()
[13:23:04.994]             {
[13:23:04.994]                 {
[13:23:04.994]                   {
[13:23:04.994]                     base::local({
[13:23:04.994]                       has_future <- base::requireNamespace("future", 
[13:23:04.994]                         quietly = TRUE)
[13:23:04.994]                       if (has_future) {
[13:23:04.994]                         ns <- base::getNamespace("future")
[13:23:04.994]                         version <- ns[[".package"]][["version"]]
[13:23:04.994]                         if (is.null(version)) 
[13:23:04.994]                           version <- utils::packageVersion("future")
[13:23:04.994]                       }
[13:23:04.994]                       else {
[13:23:04.994]                         version <- NULL
[13:23:04.994]                       }
[13:23:04.994]                       if (!has_future || version < "1.8.0") {
[13:23:04.994]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:04.994]                           "", base::R.version$version.string), 
[13:23:04.994]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:04.994]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:04.994]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:04.994]                             "release", "version")], collapse = " "), 
[13:23:04.994]                           hostname = base::Sys.info()[["nodename"]])
[13:23:04.994]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:04.994]                           info)
[13:23:04.994]                         info <- base::paste(info, collapse = "; ")
[13:23:04.994]                         if (!has_future) {
[13:23:04.994]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:04.994]                             info)
[13:23:04.994]                         }
[13:23:04.994]                         else {
[13:23:04.994]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:04.994]                             info, version)
[13:23:04.994]                         }
[13:23:04.994]                         base::stop(msg)
[13:23:04.994]                       }
[13:23:04.994]                     })
[13:23:04.994]                   }
[13:23:04.994]                   options(future.plan = NULL)
[13:23:04.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:04.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:04.994]                 }
[13:23:04.994]                 ...future.workdir <- getwd()
[13:23:04.994]             }
[13:23:04.994]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:04.994]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:04.994]         }
[13:23:04.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:04.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:04.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:04.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:04.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:04.994]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:04.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:04.994]             base::names(...future.oldOptions))
[13:23:04.994]     }
[13:23:04.994]     if (FALSE) {
[13:23:04.994]     }
[13:23:04.994]     else {
[13:23:04.994]         if (TRUE) {
[13:23:04.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:04.994]                 open = "w")
[13:23:04.994]         }
[13:23:04.994]         else {
[13:23:04.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:04.994]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:04.994]         }
[13:23:04.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:04.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:04.994]             base::sink(type = "output", split = FALSE)
[13:23:04.994]             base::close(...future.stdout)
[13:23:04.994]         }, add = TRUE)
[13:23:04.994]     }
[13:23:04.994]     ...future.frame <- base::sys.nframe()
[13:23:04.994]     ...future.conditions <- base::list()
[13:23:04.994]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:04.994]     if (FALSE) {
[13:23:04.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:04.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:04.994]     }
[13:23:04.994]     ...future.result <- base::tryCatch({
[13:23:04.994]         base::withCallingHandlers({
[13:23:04.994]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:04.994]             future::FutureResult(value = ...future.value$value, 
[13:23:04.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:04.994]                   ...future.rng), globalenv = if (FALSE) 
[13:23:04.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:04.994]                     ...future.globalenv.names))
[13:23:04.994]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:04.994]         }, condition = base::local({
[13:23:04.994]             c <- base::c
[13:23:04.994]             inherits <- base::inherits
[13:23:04.994]             invokeRestart <- base::invokeRestart
[13:23:04.994]             length <- base::length
[13:23:04.994]             list <- base::list
[13:23:04.994]             seq.int <- base::seq.int
[13:23:04.994]             signalCondition <- base::signalCondition
[13:23:04.994]             sys.calls <- base::sys.calls
[13:23:04.994]             `[[` <- base::`[[`
[13:23:04.994]             `+` <- base::`+`
[13:23:04.994]             `<<-` <- base::`<<-`
[13:23:04.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:04.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:04.994]                   3L)]
[13:23:04.994]             }
[13:23:04.994]             function(cond) {
[13:23:04.994]                 is_error <- inherits(cond, "error")
[13:23:04.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:04.994]                   NULL)
[13:23:04.994]                 if (is_error) {
[13:23:04.994]                   sessionInformation <- function() {
[13:23:04.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:04.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:04.994]                       search = base::search(), system = base::Sys.info())
[13:23:04.994]                   }
[13:23:04.994]                   ...future.conditions[[length(...future.conditions) + 
[13:23:04.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:04.994]                     cond$call), session = sessionInformation(), 
[13:23:04.994]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:04.994]                   signalCondition(cond)
[13:23:04.994]                 }
[13:23:04.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:04.994]                 "immediateCondition"))) {
[13:23:04.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:04.994]                   ...future.conditions[[length(...future.conditions) + 
[13:23:04.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:04.994]                   if (TRUE && !signal) {
[13:23:04.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:04.994]                     {
[13:23:04.994]                       inherits <- base::inherits
[13:23:04.994]                       invokeRestart <- base::invokeRestart
[13:23:04.994]                       is.null <- base::is.null
[13:23:04.994]                       muffled <- FALSE
[13:23:04.994]                       if (inherits(cond, "message")) {
[13:23:04.994]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:04.994]                         if (muffled) 
[13:23:04.994]                           invokeRestart("muffleMessage")
[13:23:04.994]                       }
[13:23:04.994]                       else if (inherits(cond, "warning")) {
[13:23:04.994]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:04.994]                         if (muffled) 
[13:23:04.994]                           invokeRestart("muffleWarning")
[13:23:04.994]                       }
[13:23:04.994]                       else if (inherits(cond, "condition")) {
[13:23:04.994]                         if (!is.null(pattern)) {
[13:23:04.994]                           computeRestarts <- base::computeRestarts
[13:23:04.994]                           grepl <- base::grepl
[13:23:04.994]                           restarts <- computeRestarts(cond)
[13:23:04.994]                           for (restart in restarts) {
[13:23:04.994]                             name <- restart$name
[13:23:04.994]                             if (is.null(name)) 
[13:23:04.994]                               next
[13:23:04.994]                             if (!grepl(pattern, name)) 
[13:23:04.994]                               next
[13:23:04.994]                             invokeRestart(restart)
[13:23:04.994]                             muffled <- TRUE
[13:23:04.994]                             break
[13:23:04.994]                           }
[13:23:04.994]                         }
[13:23:04.994]                       }
[13:23:04.994]                       invisible(muffled)
[13:23:04.994]                     }
[13:23:04.994]                     muffleCondition(cond, pattern = "^muffle")
[13:23:04.994]                   }
[13:23:04.994]                 }
[13:23:04.994]                 else {
[13:23:04.994]                   if (TRUE) {
[13:23:04.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:04.994]                     {
[13:23:04.994]                       inherits <- base::inherits
[13:23:04.994]                       invokeRestart <- base::invokeRestart
[13:23:04.994]                       is.null <- base::is.null
[13:23:04.994]                       muffled <- FALSE
[13:23:04.994]                       if (inherits(cond, "message")) {
[13:23:04.994]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:04.994]                         if (muffled) 
[13:23:04.994]                           invokeRestart("muffleMessage")
[13:23:04.994]                       }
[13:23:04.994]                       else if (inherits(cond, "warning")) {
[13:23:04.994]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:04.994]                         if (muffled) 
[13:23:04.994]                           invokeRestart("muffleWarning")
[13:23:04.994]                       }
[13:23:04.994]                       else if (inherits(cond, "condition")) {
[13:23:04.994]                         if (!is.null(pattern)) {
[13:23:04.994]                           computeRestarts <- base::computeRestarts
[13:23:04.994]                           grepl <- base::grepl
[13:23:04.994]                           restarts <- computeRestarts(cond)
[13:23:04.994]                           for (restart in restarts) {
[13:23:04.994]                             name <- restart$name
[13:23:04.994]                             if (is.null(name)) 
[13:23:04.994]                               next
[13:23:04.994]                             if (!grepl(pattern, name)) 
[13:23:04.994]                               next
[13:23:04.994]                             invokeRestart(restart)
[13:23:04.994]                             muffled <- TRUE
[13:23:04.994]                             break
[13:23:04.994]                           }
[13:23:04.994]                         }
[13:23:04.994]                       }
[13:23:04.994]                       invisible(muffled)
[13:23:04.994]                     }
[13:23:04.994]                     muffleCondition(cond, pattern = "^muffle")
[13:23:04.994]                   }
[13:23:04.994]                 }
[13:23:04.994]             }
[13:23:04.994]         }))
[13:23:04.994]     }, error = function(ex) {
[13:23:04.994]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:04.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:04.994]                 ...future.rng), started = ...future.startTime, 
[13:23:04.994]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:04.994]             version = "1.8"), class = "FutureResult")
[13:23:04.994]     }, finally = {
[13:23:04.994]         if (!identical(...future.workdir, getwd())) 
[13:23:04.994]             setwd(...future.workdir)
[13:23:04.994]         {
[13:23:04.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:04.994]                 ...future.oldOptions$nwarnings <- NULL
[13:23:04.994]             }
[13:23:04.994]             base::options(...future.oldOptions)
[13:23:04.994]             if (.Platform$OS.type == "windows") {
[13:23:04.994]                 old_names <- names(...future.oldEnvVars)
[13:23:04.994]                 envs <- base::Sys.getenv()
[13:23:04.994]                 names <- names(envs)
[13:23:04.994]                 common <- intersect(names, old_names)
[13:23:04.994]                 added <- setdiff(names, old_names)
[13:23:04.994]                 removed <- setdiff(old_names, names)
[13:23:04.994]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:04.994]                   envs[common]]
[13:23:04.994]                 NAMES <- toupper(changed)
[13:23:04.994]                 args <- list()
[13:23:04.994]                 for (kk in seq_along(NAMES)) {
[13:23:04.994]                   name <- changed[[kk]]
[13:23:04.994]                   NAME <- NAMES[[kk]]
[13:23:04.994]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:04.994]                     next
[13:23:04.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:04.994]                 }
[13:23:04.994]                 NAMES <- toupper(added)
[13:23:04.994]                 for (kk in seq_along(NAMES)) {
[13:23:04.994]                   name <- added[[kk]]
[13:23:04.994]                   NAME <- NAMES[[kk]]
[13:23:04.994]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:04.994]                     next
[13:23:04.994]                   args[[name]] <- ""
[13:23:04.994]                 }
[13:23:04.994]                 NAMES <- toupper(removed)
[13:23:04.994]                 for (kk in seq_along(NAMES)) {
[13:23:04.994]                   name <- removed[[kk]]
[13:23:04.994]                   NAME <- NAMES[[kk]]
[13:23:04.994]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:04.994]                     next
[13:23:04.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:04.994]                 }
[13:23:04.994]                 if (length(args) > 0) 
[13:23:04.994]                   base::do.call(base::Sys.setenv, args = args)
[13:23:04.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:04.994]             }
[13:23:04.994]             else {
[13:23:04.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:04.994]             }
[13:23:04.994]             {
[13:23:04.994]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:04.994]                   0L) {
[13:23:04.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:04.994]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:04.994]                   base::options(opts)
[13:23:04.994]                 }
[13:23:04.994]                 {
[13:23:04.994]                   {
[13:23:04.994]                     NULL
[13:23:04.994]                     RNGkind("Mersenne-Twister")
[13:23:04.994]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:04.994]                       inherits = FALSE)
[13:23:04.994]                   }
[13:23:04.994]                   options(future.plan = NULL)
[13:23:04.994]                   if (is.na(NA_character_)) 
[13:23:04.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:04.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:04.994]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:04.994]                   {
[13:23:04.994]                     future <- SequentialFuture(..., envir = envir)
[13:23:04.994]                     if (!future$lazy) 
[13:23:04.994]                       future <- run(future)
[13:23:04.994]                     invisible(future)
[13:23:04.994]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:04.994]                 }
[13:23:04.994]             }
[13:23:04.994]         }
[13:23:04.994]     })
[13:23:04.994]     if (TRUE) {
[13:23:04.994]         base::sink(type = "output", split = FALSE)
[13:23:04.994]         if (TRUE) {
[13:23:04.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:04.994]         }
[13:23:04.994]         else {
[13:23:04.994]             ...future.result["stdout"] <- base::list(NULL)
[13:23:04.994]         }
[13:23:04.994]         base::close(...future.stdout)
[13:23:04.994]         ...future.stdout <- NULL
[13:23:04.994]     }
[13:23:04.994]     ...future.result$conditions <- ...future.conditions
[13:23:04.994]     ...future.result$finished <- base::Sys.time()
[13:23:04.994]     ...future.result
[13:23:04.994] }
[13:23:04.996] plan(): Setting new future strategy stack:
[13:23:04.996] List of future strategies:
[13:23:04.996] 1. sequential:
[13:23:04.996]    - args: function (..., envir = parent.frame())
[13:23:04.996]    - tweaked: FALSE
[13:23:04.996]    - call: NULL
[13:23:04.997] plan(): nbrOfWorkers() = 1
[13:23:04.997] plan(): Setting new future strategy stack:
[13:23:04.998] List of future strategies:
[13:23:04.998] 1. sequential:
[13:23:04.998]    - args: function (..., envir = parent.frame())
[13:23:04.998]    - tweaked: FALSE
[13:23:04.998]    - call: plan(strategy)
[13:23:04.998] plan(): nbrOfWorkers() = 1
[13:23:04.998] SequentialFuture started (and completed)
[13:23:04.998] - Launch lazy future ... done
[13:23:04.998] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d4c17c30> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d53cced8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d4c17c30> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d53cced8> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:23:05.005] resolved() for ‘SequentialFuture’ ...
[13:23:05.005] - state: ‘finished’
[13:23:05.005] - run: TRUE
[13:23:05.005] - result: ‘FutureResult’
[13:23:05.005] resolved() for ‘SequentialFuture’ ... done
[13:23:05.006] resolved() for ‘SequentialFuture’ ...
[13:23:05.006] - state: ‘finished’
[13:23:05.006] - run: TRUE
[13:23:05.006] - result: ‘FutureResult’
[13:23:05.006] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:05.007] resolve() on list ...
[13:23:05.007]  recursive: 0
[13:23:05.007]  length: 6
[13:23:05.008]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:05.008] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.008] - nx: 6
[13:23:05.008] - relay: TRUE
[13:23:05.008] - stdout: TRUE
[13:23:05.008] - signal: TRUE
[13:23:05.008] - resignal: FALSE
[13:23:05.008] - force: TRUE
[13:23:05.008] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.008] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.008]  - until=2
[13:23:05.009]  - relaying element #2
[13:23:05.009] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.009] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.009] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.009]  length: 5 (resolved future 1)
[13:23:05.009] resolved() for ‘SequentialFuture’ ...
[13:23:05.009] - state: ‘finished’
[13:23:05.009] - run: TRUE
[13:23:05.009] - result: ‘FutureResult’
[13:23:05.009] resolved() for ‘SequentialFuture’ ... done
[13:23:05.010] Future #2
[13:23:05.010] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.010] - nx: 6
[13:23:05.010] - relay: TRUE
[13:23:05.010] - stdout: TRUE
[13:23:05.010] - signal: TRUE
[13:23:05.010] - resignal: FALSE
[13:23:05.010] - force: TRUE
[13:23:05.011] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.011] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.011]  - until=2
[13:23:05.011]  - relaying element #2
[13:23:05.011] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.011] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.011] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.011]  length: 4 (resolved future 2)
[13:23:05.012] resolved() for ‘SequentialFuture’ ...
[13:23:05.015] - state: ‘finished’
[13:23:05.015] - run: TRUE
[13:23:05.015] - result: ‘FutureResult’
[13:23:05.015] resolved() for ‘SequentialFuture’ ... done
[13:23:05.015] Future #3
[13:23:05.015] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.015] - nx: 6
[13:23:05.015] - relay: TRUE
[13:23:05.015] - stdout: TRUE
[13:23:05.015] - signal: TRUE
[13:23:05.016] - resignal: FALSE
[13:23:05.016] - force: TRUE
[13:23:05.016] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.016] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.016]  - until=3
[13:23:05.016]  - relaying element #3
[13:23:05.016] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.016] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.016] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.017]  length: 3 (resolved future 3)
[13:23:05.017] signalConditionsASAP(NULL, pos=4) ...
[13:23:05.017] - nx: 6
[13:23:05.017] - relay: TRUE
[13:23:05.017] - stdout: TRUE
[13:23:05.017] - signal: TRUE
[13:23:05.017] - resignal: FALSE
[13:23:05.017] - force: TRUE
[13:23:05.017] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.017] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.017]  - until=5
[13:23:05.017]  - relaying element #5
[13:23:05.018] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.018] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.018] signalConditionsASAP(NULL, pos=4) ... done
[13:23:05.018]  length: 2 (resolved future 4)
[13:23:05.018] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.018] - nx: 6
[13:23:05.018] - relay: TRUE
[13:23:05.018] - stdout: TRUE
[13:23:05.018] - signal: TRUE
[13:23:05.018] - resignal: FALSE
[13:23:05.018] - force: TRUE
[13:23:05.019] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.019] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.019]  - until=6
[13:23:05.019]  - relaying element #6
[13:23:05.019] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.019] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.019] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.019]  length: 1 (resolved future 5)
[13:23:05.019] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.019] - nx: 6
[13:23:05.019] - relay: TRUE
[13:23:05.020] - stdout: TRUE
[13:23:05.020] - signal: TRUE
[13:23:05.020] - resignal: FALSE
[13:23:05.020] - force: TRUE
[13:23:05.020] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.020] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.020]  - until=6
[13:23:05.020] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.020] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.020] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.020]  length: 0 (resolved future 6)
[13:23:05.021] Relaying remaining futures
[13:23:05.021] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.021] - nx: 6
[13:23:05.021] - relay: TRUE
[13:23:05.021] - stdout: TRUE
[13:23:05.021] - signal: TRUE
[13:23:05.021] - resignal: FALSE
[13:23:05.021] - force: TRUE
[13:23:05.021] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.021] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:05.021] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.022] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.022] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.022] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[13:23:05.024] getGlobalsAndPackages() ...
[13:23:05.024] Searching for globals...
[13:23:05.025] 
[13:23:05.025] Searching for globals ... DONE
[13:23:05.025] - globals: [0] <none>
[13:23:05.025] getGlobalsAndPackages() ... DONE
[13:23:05.025] run() for ‘Future’ ...
[13:23:05.025] - state: ‘created’
[13:23:05.026] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.026] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.026] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.026]   - Field: ‘label’
[13:23:05.026]   - Field: ‘local’
[13:23:05.026]   - Field: ‘owner’
[13:23:05.026]   - Field: ‘envir’
[13:23:05.027]   - Field: ‘packages’
[13:23:05.027]   - Field: ‘gc’
[13:23:05.027]   - Field: ‘conditions’
[13:23:05.027]   - Field: ‘expr’
[13:23:05.027]   - Field: ‘uuid’
[13:23:05.027]   - Field: ‘seed’
[13:23:05.027]   - Field: ‘version’
[13:23:05.027]   - Field: ‘result’
[13:23:05.027]   - Field: ‘asynchronous’
[13:23:05.028]   - Field: ‘calls’
[13:23:05.028]   - Field: ‘globals’
[13:23:05.028]   - Field: ‘stdout’
[13:23:05.028]   - Field: ‘earlySignal’
[13:23:05.028]   - Field: ‘lazy’
[13:23:05.028]   - Field: ‘state’
[13:23:05.028] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.028] - Launch lazy future ...
[13:23:05.028] Packages needed by the future expression (n = 0): <none>
[13:23:05.029] Packages needed by future strategies (n = 0): <none>
[13:23:05.029] {
[13:23:05.029]     {
[13:23:05.029]         {
[13:23:05.029]             ...future.startTime <- base::Sys.time()
[13:23:05.029]             {
[13:23:05.029]                 {
[13:23:05.029]                   {
[13:23:05.029]                     base::local({
[13:23:05.029]                       has_future <- base::requireNamespace("future", 
[13:23:05.029]                         quietly = TRUE)
[13:23:05.029]                       if (has_future) {
[13:23:05.029]                         ns <- base::getNamespace("future")
[13:23:05.029]                         version <- ns[[".package"]][["version"]]
[13:23:05.029]                         if (is.null(version)) 
[13:23:05.029]                           version <- utils::packageVersion("future")
[13:23:05.029]                       }
[13:23:05.029]                       else {
[13:23:05.029]                         version <- NULL
[13:23:05.029]                       }
[13:23:05.029]                       if (!has_future || version < "1.8.0") {
[13:23:05.029]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.029]                           "", base::R.version$version.string), 
[13:23:05.029]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.029]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.029]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.029]                             "release", "version")], collapse = " "), 
[13:23:05.029]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.029]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.029]                           info)
[13:23:05.029]                         info <- base::paste(info, collapse = "; ")
[13:23:05.029]                         if (!has_future) {
[13:23:05.029]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.029]                             info)
[13:23:05.029]                         }
[13:23:05.029]                         else {
[13:23:05.029]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.029]                             info, version)
[13:23:05.029]                         }
[13:23:05.029]                         base::stop(msg)
[13:23:05.029]                       }
[13:23:05.029]                     })
[13:23:05.029]                   }
[13:23:05.029]                   options(future.plan = NULL)
[13:23:05.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.029]                 }
[13:23:05.029]                 ...future.workdir <- getwd()
[13:23:05.029]             }
[13:23:05.029]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.029]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.029]         }
[13:23:05.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.029]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.029]             base::names(...future.oldOptions))
[13:23:05.029]     }
[13:23:05.029]     if (FALSE) {
[13:23:05.029]     }
[13:23:05.029]     else {
[13:23:05.029]         if (TRUE) {
[13:23:05.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.029]                 open = "w")
[13:23:05.029]         }
[13:23:05.029]         else {
[13:23:05.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.029]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.029]         }
[13:23:05.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.029]             base::sink(type = "output", split = FALSE)
[13:23:05.029]             base::close(...future.stdout)
[13:23:05.029]         }, add = TRUE)
[13:23:05.029]     }
[13:23:05.029]     ...future.frame <- base::sys.nframe()
[13:23:05.029]     ...future.conditions <- base::list()
[13:23:05.029]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.029]     if (FALSE) {
[13:23:05.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.029]     }
[13:23:05.029]     ...future.result <- base::tryCatch({
[13:23:05.029]         base::withCallingHandlers({
[13:23:05.029]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.029]             future::FutureResult(value = ...future.value$value, 
[13:23:05.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.029]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.029]                     ...future.globalenv.names))
[13:23:05.029]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.029]         }, condition = base::local({
[13:23:05.029]             c <- base::c
[13:23:05.029]             inherits <- base::inherits
[13:23:05.029]             invokeRestart <- base::invokeRestart
[13:23:05.029]             length <- base::length
[13:23:05.029]             list <- base::list
[13:23:05.029]             seq.int <- base::seq.int
[13:23:05.029]             signalCondition <- base::signalCondition
[13:23:05.029]             sys.calls <- base::sys.calls
[13:23:05.029]             `[[` <- base::`[[`
[13:23:05.029]             `+` <- base::`+`
[13:23:05.029]             `<<-` <- base::`<<-`
[13:23:05.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.029]                   3L)]
[13:23:05.029]             }
[13:23:05.029]             function(cond) {
[13:23:05.029]                 is_error <- inherits(cond, "error")
[13:23:05.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.029]                   NULL)
[13:23:05.029]                 if (is_error) {
[13:23:05.029]                   sessionInformation <- function() {
[13:23:05.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.029]                       search = base::search(), system = base::Sys.info())
[13:23:05.029]                   }
[13:23:05.029]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.029]                     cond$call), session = sessionInformation(), 
[13:23:05.029]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.029]                   signalCondition(cond)
[13:23:05.029]                 }
[13:23:05.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.029]                 "immediateCondition"))) {
[13:23:05.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.029]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.029]                   if (TRUE && !signal) {
[13:23:05.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.029]                     {
[13:23:05.029]                       inherits <- base::inherits
[13:23:05.029]                       invokeRestart <- base::invokeRestart
[13:23:05.029]                       is.null <- base::is.null
[13:23:05.029]                       muffled <- FALSE
[13:23:05.029]                       if (inherits(cond, "message")) {
[13:23:05.029]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.029]                         if (muffled) 
[13:23:05.029]                           invokeRestart("muffleMessage")
[13:23:05.029]                       }
[13:23:05.029]                       else if (inherits(cond, "warning")) {
[13:23:05.029]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.029]                         if (muffled) 
[13:23:05.029]                           invokeRestart("muffleWarning")
[13:23:05.029]                       }
[13:23:05.029]                       else if (inherits(cond, "condition")) {
[13:23:05.029]                         if (!is.null(pattern)) {
[13:23:05.029]                           computeRestarts <- base::computeRestarts
[13:23:05.029]                           grepl <- base::grepl
[13:23:05.029]                           restarts <- computeRestarts(cond)
[13:23:05.029]                           for (restart in restarts) {
[13:23:05.029]                             name <- restart$name
[13:23:05.029]                             if (is.null(name)) 
[13:23:05.029]                               next
[13:23:05.029]                             if (!grepl(pattern, name)) 
[13:23:05.029]                               next
[13:23:05.029]                             invokeRestart(restart)
[13:23:05.029]                             muffled <- TRUE
[13:23:05.029]                             break
[13:23:05.029]                           }
[13:23:05.029]                         }
[13:23:05.029]                       }
[13:23:05.029]                       invisible(muffled)
[13:23:05.029]                     }
[13:23:05.029]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.029]                   }
[13:23:05.029]                 }
[13:23:05.029]                 else {
[13:23:05.029]                   if (TRUE) {
[13:23:05.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.029]                     {
[13:23:05.029]                       inherits <- base::inherits
[13:23:05.029]                       invokeRestart <- base::invokeRestart
[13:23:05.029]                       is.null <- base::is.null
[13:23:05.029]                       muffled <- FALSE
[13:23:05.029]                       if (inherits(cond, "message")) {
[13:23:05.029]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.029]                         if (muffled) 
[13:23:05.029]                           invokeRestart("muffleMessage")
[13:23:05.029]                       }
[13:23:05.029]                       else if (inherits(cond, "warning")) {
[13:23:05.029]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.029]                         if (muffled) 
[13:23:05.029]                           invokeRestart("muffleWarning")
[13:23:05.029]                       }
[13:23:05.029]                       else if (inherits(cond, "condition")) {
[13:23:05.029]                         if (!is.null(pattern)) {
[13:23:05.029]                           computeRestarts <- base::computeRestarts
[13:23:05.029]                           grepl <- base::grepl
[13:23:05.029]                           restarts <- computeRestarts(cond)
[13:23:05.029]                           for (restart in restarts) {
[13:23:05.029]                             name <- restart$name
[13:23:05.029]                             if (is.null(name)) 
[13:23:05.029]                               next
[13:23:05.029]                             if (!grepl(pattern, name)) 
[13:23:05.029]                               next
[13:23:05.029]                             invokeRestart(restart)
[13:23:05.029]                             muffled <- TRUE
[13:23:05.029]                             break
[13:23:05.029]                           }
[13:23:05.029]                         }
[13:23:05.029]                       }
[13:23:05.029]                       invisible(muffled)
[13:23:05.029]                     }
[13:23:05.029]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.029]                   }
[13:23:05.029]                 }
[13:23:05.029]             }
[13:23:05.029]         }))
[13:23:05.029]     }, error = function(ex) {
[13:23:05.029]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.029]                 ...future.rng), started = ...future.startTime, 
[13:23:05.029]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.029]             version = "1.8"), class = "FutureResult")
[13:23:05.029]     }, finally = {
[13:23:05.029]         if (!identical(...future.workdir, getwd())) 
[13:23:05.029]             setwd(...future.workdir)
[13:23:05.029]         {
[13:23:05.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.029]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.029]             }
[13:23:05.029]             base::options(...future.oldOptions)
[13:23:05.029]             if (.Platform$OS.type == "windows") {
[13:23:05.029]                 old_names <- names(...future.oldEnvVars)
[13:23:05.029]                 envs <- base::Sys.getenv()
[13:23:05.029]                 names <- names(envs)
[13:23:05.029]                 common <- intersect(names, old_names)
[13:23:05.029]                 added <- setdiff(names, old_names)
[13:23:05.029]                 removed <- setdiff(old_names, names)
[13:23:05.029]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.029]                   envs[common]]
[13:23:05.029]                 NAMES <- toupper(changed)
[13:23:05.029]                 args <- list()
[13:23:05.029]                 for (kk in seq_along(NAMES)) {
[13:23:05.029]                   name <- changed[[kk]]
[13:23:05.029]                   NAME <- NAMES[[kk]]
[13:23:05.029]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.029]                     next
[13:23:05.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.029]                 }
[13:23:05.029]                 NAMES <- toupper(added)
[13:23:05.029]                 for (kk in seq_along(NAMES)) {
[13:23:05.029]                   name <- added[[kk]]
[13:23:05.029]                   NAME <- NAMES[[kk]]
[13:23:05.029]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.029]                     next
[13:23:05.029]                   args[[name]] <- ""
[13:23:05.029]                 }
[13:23:05.029]                 NAMES <- toupper(removed)
[13:23:05.029]                 for (kk in seq_along(NAMES)) {
[13:23:05.029]                   name <- removed[[kk]]
[13:23:05.029]                   NAME <- NAMES[[kk]]
[13:23:05.029]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.029]                     next
[13:23:05.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.029]                 }
[13:23:05.029]                 if (length(args) > 0) 
[13:23:05.029]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.029]             }
[13:23:05.029]             else {
[13:23:05.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.029]             }
[13:23:05.029]             {
[13:23:05.029]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.029]                   0L) {
[13:23:05.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.029]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.029]                   base::options(opts)
[13:23:05.029]                 }
[13:23:05.029]                 {
[13:23:05.029]                   {
[13:23:05.029]                     NULL
[13:23:05.029]                     RNGkind("Mersenne-Twister")
[13:23:05.029]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.029]                       inherits = FALSE)
[13:23:05.029]                   }
[13:23:05.029]                   options(future.plan = NULL)
[13:23:05.029]                   if (is.na(NA_character_)) 
[13:23:05.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.029]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.029]                   {
[13:23:05.029]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.029]                     if (!future$lazy) 
[13:23:05.029]                       future <- run(future)
[13:23:05.029]                     invisible(future)
[13:23:05.029]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.029]                 }
[13:23:05.029]             }
[13:23:05.029]         }
[13:23:05.029]     })
[13:23:05.029]     if (TRUE) {
[13:23:05.029]         base::sink(type = "output", split = FALSE)
[13:23:05.029]         if (TRUE) {
[13:23:05.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.029]         }
[13:23:05.029]         else {
[13:23:05.029]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.029]         }
[13:23:05.029]         base::close(...future.stdout)
[13:23:05.029]         ...future.stdout <- NULL
[13:23:05.029]     }
[13:23:05.029]     ...future.result$conditions <- ...future.conditions
[13:23:05.029]     ...future.result$finished <- base::Sys.time()
[13:23:05.029]     ...future.result
[13:23:05.029] }
[13:23:05.031] plan(): Setting new future strategy stack:
[13:23:05.031] List of future strategies:
[13:23:05.031] 1. sequential:
[13:23:05.031]    - args: function (..., envir = parent.frame())
[13:23:05.031]    - tweaked: FALSE
[13:23:05.031]    - call: NULL
[13:23:05.031] plan(): nbrOfWorkers() = 1
[13:23:05.032] plan(): Setting new future strategy stack:
[13:23:05.032] List of future strategies:
[13:23:05.032] 1. sequential:
[13:23:05.032]    - args: function (..., envir = parent.frame())
[13:23:05.032]    - tweaked: FALSE
[13:23:05.032]    - call: plan(strategy)
[13:23:05.033] plan(): nbrOfWorkers() = 1
[13:23:05.033] SequentialFuture started (and completed)
[13:23:05.033] - Launch lazy future ... done
[13:23:05.033] run() for ‘SequentialFuture’ ... done
[13:23:05.033] getGlobalsAndPackages() ...
[13:23:05.033] Searching for globals...
[13:23:05.034] 
[13:23:05.034] Searching for globals ... DONE
[13:23:05.034] - globals: [0] <none>
[13:23:05.034] getGlobalsAndPackages() ... DONE
[13:23:05.034] run() for ‘Future’ ...
[13:23:05.034] - state: ‘created’
[13:23:05.034] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.035] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.035] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.035]   - Field: ‘label’
[13:23:05.035]   - Field: ‘local’
[13:23:05.035]   - Field: ‘owner’
[13:23:05.035]   - Field: ‘envir’
[13:23:05.035]   - Field: ‘packages’
[13:23:05.035]   - Field: ‘gc’
[13:23:05.036]   - Field: ‘conditions’
[13:23:05.036]   - Field: ‘expr’
[13:23:05.036]   - Field: ‘uuid’
[13:23:05.036]   - Field: ‘seed’
[13:23:05.036]   - Field: ‘version’
[13:23:05.036]   - Field: ‘result’
[13:23:05.036]   - Field: ‘asynchronous’
[13:23:05.036]   - Field: ‘calls’
[13:23:05.036]   - Field: ‘globals’
[13:23:05.036]   - Field: ‘stdout’
[13:23:05.036]   - Field: ‘earlySignal’
[13:23:05.037]   - Field: ‘lazy’
[13:23:05.037]   - Field: ‘state’
[13:23:05.037] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.037] - Launch lazy future ...
[13:23:05.037] Packages needed by the future expression (n = 0): <none>
[13:23:05.037] Packages needed by future strategies (n = 0): <none>
[13:23:05.038] {
[13:23:05.038]     {
[13:23:05.038]         {
[13:23:05.038]             ...future.startTime <- base::Sys.time()
[13:23:05.038]             {
[13:23:05.038]                 {
[13:23:05.038]                   {
[13:23:05.038]                     base::local({
[13:23:05.038]                       has_future <- base::requireNamespace("future", 
[13:23:05.038]                         quietly = TRUE)
[13:23:05.038]                       if (has_future) {
[13:23:05.038]                         ns <- base::getNamespace("future")
[13:23:05.038]                         version <- ns[[".package"]][["version"]]
[13:23:05.038]                         if (is.null(version)) 
[13:23:05.038]                           version <- utils::packageVersion("future")
[13:23:05.038]                       }
[13:23:05.038]                       else {
[13:23:05.038]                         version <- NULL
[13:23:05.038]                       }
[13:23:05.038]                       if (!has_future || version < "1.8.0") {
[13:23:05.038]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.038]                           "", base::R.version$version.string), 
[13:23:05.038]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.038]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.038]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.038]                             "release", "version")], collapse = " "), 
[13:23:05.038]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.038]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.038]                           info)
[13:23:05.038]                         info <- base::paste(info, collapse = "; ")
[13:23:05.038]                         if (!has_future) {
[13:23:05.038]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.038]                             info)
[13:23:05.038]                         }
[13:23:05.038]                         else {
[13:23:05.038]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.038]                             info, version)
[13:23:05.038]                         }
[13:23:05.038]                         base::stop(msg)
[13:23:05.038]                       }
[13:23:05.038]                     })
[13:23:05.038]                   }
[13:23:05.038]                   options(future.plan = NULL)
[13:23:05.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.038]                 }
[13:23:05.038]                 ...future.workdir <- getwd()
[13:23:05.038]             }
[13:23:05.038]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.038]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.038]         }
[13:23:05.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.038]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.038]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.038]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.038]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.038]             base::names(...future.oldOptions))
[13:23:05.038]     }
[13:23:05.038]     if (FALSE) {
[13:23:05.038]     }
[13:23:05.038]     else {
[13:23:05.038]         if (TRUE) {
[13:23:05.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.038]                 open = "w")
[13:23:05.038]         }
[13:23:05.038]         else {
[13:23:05.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.038]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.038]         }
[13:23:05.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.038]             base::sink(type = "output", split = FALSE)
[13:23:05.038]             base::close(...future.stdout)
[13:23:05.038]         }, add = TRUE)
[13:23:05.038]     }
[13:23:05.038]     ...future.frame <- base::sys.nframe()
[13:23:05.038]     ...future.conditions <- base::list()
[13:23:05.038]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.038]     if (FALSE) {
[13:23:05.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.038]     }
[13:23:05.038]     ...future.result <- base::tryCatch({
[13:23:05.038]         base::withCallingHandlers({
[13:23:05.038]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.038]             future::FutureResult(value = ...future.value$value, 
[13:23:05.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.038]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.038]                     ...future.globalenv.names))
[13:23:05.038]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.038]         }, condition = base::local({
[13:23:05.038]             c <- base::c
[13:23:05.038]             inherits <- base::inherits
[13:23:05.038]             invokeRestart <- base::invokeRestart
[13:23:05.038]             length <- base::length
[13:23:05.038]             list <- base::list
[13:23:05.038]             seq.int <- base::seq.int
[13:23:05.038]             signalCondition <- base::signalCondition
[13:23:05.038]             sys.calls <- base::sys.calls
[13:23:05.038]             `[[` <- base::`[[`
[13:23:05.038]             `+` <- base::`+`
[13:23:05.038]             `<<-` <- base::`<<-`
[13:23:05.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.038]                   3L)]
[13:23:05.038]             }
[13:23:05.038]             function(cond) {
[13:23:05.038]                 is_error <- inherits(cond, "error")
[13:23:05.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.038]                   NULL)
[13:23:05.038]                 if (is_error) {
[13:23:05.038]                   sessionInformation <- function() {
[13:23:05.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.038]                       search = base::search(), system = base::Sys.info())
[13:23:05.038]                   }
[13:23:05.038]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.038]                     cond$call), session = sessionInformation(), 
[13:23:05.038]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.038]                   signalCondition(cond)
[13:23:05.038]                 }
[13:23:05.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.038]                 "immediateCondition"))) {
[13:23:05.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.038]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.038]                   if (TRUE && !signal) {
[13:23:05.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.038]                     {
[13:23:05.038]                       inherits <- base::inherits
[13:23:05.038]                       invokeRestart <- base::invokeRestart
[13:23:05.038]                       is.null <- base::is.null
[13:23:05.038]                       muffled <- FALSE
[13:23:05.038]                       if (inherits(cond, "message")) {
[13:23:05.038]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.038]                         if (muffled) 
[13:23:05.038]                           invokeRestart("muffleMessage")
[13:23:05.038]                       }
[13:23:05.038]                       else if (inherits(cond, "warning")) {
[13:23:05.038]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.038]                         if (muffled) 
[13:23:05.038]                           invokeRestart("muffleWarning")
[13:23:05.038]                       }
[13:23:05.038]                       else if (inherits(cond, "condition")) {
[13:23:05.038]                         if (!is.null(pattern)) {
[13:23:05.038]                           computeRestarts <- base::computeRestarts
[13:23:05.038]                           grepl <- base::grepl
[13:23:05.038]                           restarts <- computeRestarts(cond)
[13:23:05.038]                           for (restart in restarts) {
[13:23:05.038]                             name <- restart$name
[13:23:05.038]                             if (is.null(name)) 
[13:23:05.038]                               next
[13:23:05.038]                             if (!grepl(pattern, name)) 
[13:23:05.038]                               next
[13:23:05.038]                             invokeRestart(restart)
[13:23:05.038]                             muffled <- TRUE
[13:23:05.038]                             break
[13:23:05.038]                           }
[13:23:05.038]                         }
[13:23:05.038]                       }
[13:23:05.038]                       invisible(muffled)
[13:23:05.038]                     }
[13:23:05.038]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.038]                   }
[13:23:05.038]                 }
[13:23:05.038]                 else {
[13:23:05.038]                   if (TRUE) {
[13:23:05.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.038]                     {
[13:23:05.038]                       inherits <- base::inherits
[13:23:05.038]                       invokeRestart <- base::invokeRestart
[13:23:05.038]                       is.null <- base::is.null
[13:23:05.038]                       muffled <- FALSE
[13:23:05.038]                       if (inherits(cond, "message")) {
[13:23:05.038]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.038]                         if (muffled) 
[13:23:05.038]                           invokeRestart("muffleMessage")
[13:23:05.038]                       }
[13:23:05.038]                       else if (inherits(cond, "warning")) {
[13:23:05.038]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.038]                         if (muffled) 
[13:23:05.038]                           invokeRestart("muffleWarning")
[13:23:05.038]                       }
[13:23:05.038]                       else if (inherits(cond, "condition")) {
[13:23:05.038]                         if (!is.null(pattern)) {
[13:23:05.038]                           computeRestarts <- base::computeRestarts
[13:23:05.038]                           grepl <- base::grepl
[13:23:05.038]                           restarts <- computeRestarts(cond)
[13:23:05.038]                           for (restart in restarts) {
[13:23:05.038]                             name <- restart$name
[13:23:05.038]                             if (is.null(name)) 
[13:23:05.038]                               next
[13:23:05.038]                             if (!grepl(pattern, name)) 
[13:23:05.038]                               next
[13:23:05.038]                             invokeRestart(restart)
[13:23:05.038]                             muffled <- TRUE
[13:23:05.038]                             break
[13:23:05.038]                           }
[13:23:05.038]                         }
[13:23:05.038]                       }
[13:23:05.038]                       invisible(muffled)
[13:23:05.038]                     }
[13:23:05.038]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.038]                   }
[13:23:05.038]                 }
[13:23:05.038]             }
[13:23:05.038]         }))
[13:23:05.038]     }, error = function(ex) {
[13:23:05.038]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.038]                 ...future.rng), started = ...future.startTime, 
[13:23:05.038]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.038]             version = "1.8"), class = "FutureResult")
[13:23:05.038]     }, finally = {
[13:23:05.038]         if (!identical(...future.workdir, getwd())) 
[13:23:05.038]             setwd(...future.workdir)
[13:23:05.038]         {
[13:23:05.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.038]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.038]             }
[13:23:05.038]             base::options(...future.oldOptions)
[13:23:05.038]             if (.Platform$OS.type == "windows") {
[13:23:05.038]                 old_names <- names(...future.oldEnvVars)
[13:23:05.038]                 envs <- base::Sys.getenv()
[13:23:05.038]                 names <- names(envs)
[13:23:05.038]                 common <- intersect(names, old_names)
[13:23:05.038]                 added <- setdiff(names, old_names)
[13:23:05.038]                 removed <- setdiff(old_names, names)
[13:23:05.038]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.038]                   envs[common]]
[13:23:05.038]                 NAMES <- toupper(changed)
[13:23:05.038]                 args <- list()
[13:23:05.038]                 for (kk in seq_along(NAMES)) {
[13:23:05.038]                   name <- changed[[kk]]
[13:23:05.038]                   NAME <- NAMES[[kk]]
[13:23:05.038]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.038]                     next
[13:23:05.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.038]                 }
[13:23:05.038]                 NAMES <- toupper(added)
[13:23:05.038]                 for (kk in seq_along(NAMES)) {
[13:23:05.038]                   name <- added[[kk]]
[13:23:05.038]                   NAME <- NAMES[[kk]]
[13:23:05.038]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.038]                     next
[13:23:05.038]                   args[[name]] <- ""
[13:23:05.038]                 }
[13:23:05.038]                 NAMES <- toupper(removed)
[13:23:05.038]                 for (kk in seq_along(NAMES)) {
[13:23:05.038]                   name <- removed[[kk]]
[13:23:05.038]                   NAME <- NAMES[[kk]]
[13:23:05.038]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.038]                     next
[13:23:05.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.038]                 }
[13:23:05.038]                 if (length(args) > 0) 
[13:23:05.038]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.038]             }
[13:23:05.038]             else {
[13:23:05.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.038]             }
[13:23:05.038]             {
[13:23:05.038]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.038]                   0L) {
[13:23:05.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.038]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.038]                   base::options(opts)
[13:23:05.038]                 }
[13:23:05.038]                 {
[13:23:05.038]                   {
[13:23:05.038]                     NULL
[13:23:05.038]                     RNGkind("Mersenne-Twister")
[13:23:05.038]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.038]                       inherits = FALSE)
[13:23:05.038]                   }
[13:23:05.038]                   options(future.plan = NULL)
[13:23:05.038]                   if (is.na(NA_character_)) 
[13:23:05.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.038]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.038]                   {
[13:23:05.038]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.038]                     if (!future$lazy) 
[13:23:05.038]                       future <- run(future)
[13:23:05.038]                     invisible(future)
[13:23:05.038]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.038]                 }
[13:23:05.038]             }
[13:23:05.038]         }
[13:23:05.038]     })
[13:23:05.038]     if (TRUE) {
[13:23:05.038]         base::sink(type = "output", split = FALSE)
[13:23:05.038]         if (TRUE) {
[13:23:05.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.038]         }
[13:23:05.038]         else {
[13:23:05.038]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.038]         }
[13:23:05.038]         base::close(...future.stdout)
[13:23:05.038]         ...future.stdout <- NULL
[13:23:05.038]     }
[13:23:05.038]     ...future.result$conditions <- ...future.conditions
[13:23:05.038]     ...future.result$finished <- base::Sys.time()
[13:23:05.038]     ...future.result
[13:23:05.038] }
[13:23:05.040] plan(): Setting new future strategy stack:
[13:23:05.040] List of future strategies:
[13:23:05.040] 1. sequential:
[13:23:05.040]    - args: function (..., envir = parent.frame())
[13:23:05.040]    - tweaked: FALSE
[13:23:05.040]    - call: NULL
[13:23:05.040] plan(): nbrOfWorkers() = 1
[13:23:05.041] plan(): Setting new future strategy stack:
[13:23:05.041] List of future strategies:
[13:23:05.041] 1. sequential:
[13:23:05.041]    - args: function (..., envir = parent.frame())
[13:23:05.041]    - tweaked: FALSE
[13:23:05.041]    - call: plan(strategy)
[13:23:05.041] plan(): nbrOfWorkers() = 1
[13:23:05.042] SequentialFuture started (and completed)
[13:23:05.042] - Launch lazy future ... done
[13:23:05.042] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d52e5818> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d5787880> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d52e5818> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d5787880> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:23:05.049] resolved() for ‘SequentialFuture’ ...
[13:23:05.049] - state: ‘finished’
[13:23:05.049] - run: TRUE
[13:23:05.049] - result: ‘FutureResult’
[13:23:05.049] resolved() for ‘SequentialFuture’ ... done
[13:23:05.050] resolved() for ‘SequentialFuture’ ...
[13:23:05.050] - state: ‘finished’
[13:23:05.050] - run: TRUE
[13:23:05.050] - result: ‘FutureResult’
[13:23:05.050] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:05.052] resolve() on list ...
[13:23:05.052]  recursive: 0
[13:23:05.052]  length: 6
[13:23:05.052]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:05.052] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.052] - nx: 6
[13:23:05.053] - relay: TRUE
[13:23:05.053] - stdout: TRUE
[13:23:05.053] - signal: TRUE
[13:23:05.053] - resignal: FALSE
[13:23:05.053] - force: TRUE
[13:23:05.053] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.053] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.053]  - until=2
[13:23:05.053]  - relaying element #2
[13:23:05.053] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.053] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.054] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.054]  length: 5 (resolved future 1)
[13:23:05.054] resolved() for ‘SequentialFuture’ ...
[13:23:05.054] - state: ‘finished’
[13:23:05.054] - run: TRUE
[13:23:05.054] - result: ‘FutureResult’
[13:23:05.054] resolved() for ‘SequentialFuture’ ... done
[13:23:05.054] Future #2
[13:23:05.054] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.055] - nx: 6
[13:23:05.055] - relay: TRUE
[13:23:05.055] - stdout: TRUE
[13:23:05.055] - signal: TRUE
[13:23:05.055] - resignal: FALSE
[13:23:05.055] - force: TRUE
[13:23:05.055] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.055] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.055]  - until=2
[13:23:05.055]  - relaying element #2
[13:23:05.056] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.056] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.056] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.056]  length: 4 (resolved future 2)
[13:23:05.056] resolved() for ‘SequentialFuture’ ...
[13:23:05.056] - state: ‘finished’
[13:23:05.056] - run: TRUE
[13:23:05.056] - result: ‘FutureResult’
[13:23:05.056] resolved() for ‘SequentialFuture’ ... done
[13:23:05.056] Future #3
[13:23:05.057] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.057] - nx: 6
[13:23:05.057] - relay: TRUE
[13:23:05.057] - stdout: TRUE
[13:23:05.057] - signal: TRUE
[13:23:05.057] - resignal: FALSE
[13:23:05.057] - force: TRUE
[13:23:05.057] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.057] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.057]  - until=3
[13:23:05.058]  - relaying element #3
[13:23:05.058] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.058] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.058] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.058]  length: 3 (resolved future 3)
[13:23:05.058] signalConditionsASAP(NULL, pos=4) ...
[13:23:05.058] - nx: 6
[13:23:05.058] - relay: TRUE
[13:23:05.058] - stdout: TRUE
[13:23:05.058] - signal: TRUE
[13:23:05.058] - resignal: FALSE
[13:23:05.059] - force: TRUE
[13:23:05.059] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.059] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.059]  - until=5
[13:23:05.059]  - relaying element #5
[13:23:05.059] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.059] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.059] signalConditionsASAP(NULL, pos=4) ... done
[13:23:05.059]  length: 2 (resolved future 4)
[13:23:05.059] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.059] - nx: 6
[13:23:05.060] - relay: TRUE
[13:23:05.060] - stdout: TRUE
[13:23:05.060] - signal: TRUE
[13:23:05.060] - resignal: FALSE
[13:23:05.060] - force: TRUE
[13:23:05.060] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.060] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.060]  - until=6
[13:23:05.060]  - relaying element #6
[13:23:05.060] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.060] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.061] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.061]  length: 1 (resolved future 5)
[13:23:05.061] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.061] - nx: 6
[13:23:05.061] - relay: TRUE
[13:23:05.061] - stdout: TRUE
[13:23:05.061] - signal: TRUE
[13:23:05.061] - resignal: FALSE
[13:23:05.061] - force: TRUE
[13:23:05.061] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.061] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.061]  - until=6
[13:23:05.062] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.062] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.062] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.062]  length: 0 (resolved future 6)
[13:23:05.062] Relaying remaining futures
[13:23:05.062] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.062] - nx: 6
[13:23:05.062] - relay: TRUE
[13:23:05.062] - stdout: TRUE
[13:23:05.062] - signal: TRUE
[13:23:05.062] - resignal: FALSE
[13:23:05.063] - force: TRUE
[13:23:05.063] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.063] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:05.063] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.063] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.063] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.063] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:23:05.067] getGlobalsAndPackages() ...
[13:23:05.067] Searching for globals...
[13:23:05.067] 
[13:23:05.067] Searching for globals ... DONE
[13:23:05.067] - globals: [0] <none>
[13:23:05.067] getGlobalsAndPackages() ... DONE
[13:23:05.068] run() for ‘Future’ ...
[13:23:05.068] - state: ‘created’
[13:23:05.068] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.068] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.068] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.069]   - Field: ‘label’
[13:23:05.069]   - Field: ‘local’
[13:23:05.069]   - Field: ‘owner’
[13:23:05.069]   - Field: ‘envir’
[13:23:05.069]   - Field: ‘packages’
[13:23:05.069]   - Field: ‘gc’
[13:23:05.069]   - Field: ‘conditions’
[13:23:05.069]   - Field: ‘expr’
[13:23:05.069]   - Field: ‘uuid’
[13:23:05.069]   - Field: ‘seed’
[13:23:05.069]   - Field: ‘version’
[13:23:05.070]   - Field: ‘result’
[13:23:05.070]   - Field: ‘asynchronous’
[13:23:05.070]   - Field: ‘calls’
[13:23:05.070]   - Field: ‘globals’
[13:23:05.070]   - Field: ‘stdout’
[13:23:05.070]   - Field: ‘earlySignal’
[13:23:05.070]   - Field: ‘lazy’
[13:23:05.070]   - Field: ‘state’
[13:23:05.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.070] - Launch lazy future ...
[13:23:05.071] Packages needed by the future expression (n = 0): <none>
[13:23:05.071] Packages needed by future strategies (n = 0): <none>
[13:23:05.071] {
[13:23:05.071]     {
[13:23:05.071]         {
[13:23:05.071]             ...future.startTime <- base::Sys.time()
[13:23:05.071]             {
[13:23:05.071]                 {
[13:23:05.071]                   {
[13:23:05.071]                     base::local({
[13:23:05.071]                       has_future <- base::requireNamespace("future", 
[13:23:05.071]                         quietly = TRUE)
[13:23:05.071]                       if (has_future) {
[13:23:05.071]                         ns <- base::getNamespace("future")
[13:23:05.071]                         version <- ns[[".package"]][["version"]]
[13:23:05.071]                         if (is.null(version)) 
[13:23:05.071]                           version <- utils::packageVersion("future")
[13:23:05.071]                       }
[13:23:05.071]                       else {
[13:23:05.071]                         version <- NULL
[13:23:05.071]                       }
[13:23:05.071]                       if (!has_future || version < "1.8.0") {
[13:23:05.071]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.071]                           "", base::R.version$version.string), 
[13:23:05.071]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.071]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.071]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.071]                             "release", "version")], collapse = " "), 
[13:23:05.071]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.071]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.071]                           info)
[13:23:05.071]                         info <- base::paste(info, collapse = "; ")
[13:23:05.071]                         if (!has_future) {
[13:23:05.071]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.071]                             info)
[13:23:05.071]                         }
[13:23:05.071]                         else {
[13:23:05.071]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.071]                             info, version)
[13:23:05.071]                         }
[13:23:05.071]                         base::stop(msg)
[13:23:05.071]                       }
[13:23:05.071]                     })
[13:23:05.071]                   }
[13:23:05.071]                   options(future.plan = NULL)
[13:23:05.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.071]                 }
[13:23:05.071]                 ...future.workdir <- getwd()
[13:23:05.071]             }
[13:23:05.071]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.071]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.071]         }
[13:23:05.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.071]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.071]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.071]             base::names(...future.oldOptions))
[13:23:05.071]     }
[13:23:05.071]     if (FALSE) {
[13:23:05.071]     }
[13:23:05.071]     else {
[13:23:05.071]         if (TRUE) {
[13:23:05.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.071]                 open = "w")
[13:23:05.071]         }
[13:23:05.071]         else {
[13:23:05.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.071]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.071]         }
[13:23:05.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.071]             base::sink(type = "output", split = FALSE)
[13:23:05.071]             base::close(...future.stdout)
[13:23:05.071]         }, add = TRUE)
[13:23:05.071]     }
[13:23:05.071]     ...future.frame <- base::sys.nframe()
[13:23:05.071]     ...future.conditions <- base::list()
[13:23:05.071]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.071]     if (FALSE) {
[13:23:05.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.071]     }
[13:23:05.071]     ...future.result <- base::tryCatch({
[13:23:05.071]         base::withCallingHandlers({
[13:23:05.071]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.071]             future::FutureResult(value = ...future.value$value, 
[13:23:05.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.071]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.071]                     ...future.globalenv.names))
[13:23:05.071]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.071]         }, condition = base::local({
[13:23:05.071]             c <- base::c
[13:23:05.071]             inherits <- base::inherits
[13:23:05.071]             invokeRestart <- base::invokeRestart
[13:23:05.071]             length <- base::length
[13:23:05.071]             list <- base::list
[13:23:05.071]             seq.int <- base::seq.int
[13:23:05.071]             signalCondition <- base::signalCondition
[13:23:05.071]             sys.calls <- base::sys.calls
[13:23:05.071]             `[[` <- base::`[[`
[13:23:05.071]             `+` <- base::`+`
[13:23:05.071]             `<<-` <- base::`<<-`
[13:23:05.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.071]                   3L)]
[13:23:05.071]             }
[13:23:05.071]             function(cond) {
[13:23:05.071]                 is_error <- inherits(cond, "error")
[13:23:05.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.071]                   NULL)
[13:23:05.071]                 if (is_error) {
[13:23:05.071]                   sessionInformation <- function() {
[13:23:05.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.071]                       search = base::search(), system = base::Sys.info())
[13:23:05.071]                   }
[13:23:05.071]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.071]                     cond$call), session = sessionInformation(), 
[13:23:05.071]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.071]                   signalCondition(cond)
[13:23:05.071]                 }
[13:23:05.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.071]                 "immediateCondition"))) {
[13:23:05.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.071]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.071]                   if (TRUE && !signal) {
[13:23:05.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.071]                     {
[13:23:05.071]                       inherits <- base::inherits
[13:23:05.071]                       invokeRestart <- base::invokeRestart
[13:23:05.071]                       is.null <- base::is.null
[13:23:05.071]                       muffled <- FALSE
[13:23:05.071]                       if (inherits(cond, "message")) {
[13:23:05.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.071]                         if (muffled) 
[13:23:05.071]                           invokeRestart("muffleMessage")
[13:23:05.071]                       }
[13:23:05.071]                       else if (inherits(cond, "warning")) {
[13:23:05.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.071]                         if (muffled) 
[13:23:05.071]                           invokeRestart("muffleWarning")
[13:23:05.071]                       }
[13:23:05.071]                       else if (inherits(cond, "condition")) {
[13:23:05.071]                         if (!is.null(pattern)) {
[13:23:05.071]                           computeRestarts <- base::computeRestarts
[13:23:05.071]                           grepl <- base::grepl
[13:23:05.071]                           restarts <- computeRestarts(cond)
[13:23:05.071]                           for (restart in restarts) {
[13:23:05.071]                             name <- restart$name
[13:23:05.071]                             if (is.null(name)) 
[13:23:05.071]                               next
[13:23:05.071]                             if (!grepl(pattern, name)) 
[13:23:05.071]                               next
[13:23:05.071]                             invokeRestart(restart)
[13:23:05.071]                             muffled <- TRUE
[13:23:05.071]                             break
[13:23:05.071]                           }
[13:23:05.071]                         }
[13:23:05.071]                       }
[13:23:05.071]                       invisible(muffled)
[13:23:05.071]                     }
[13:23:05.071]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.071]                   }
[13:23:05.071]                 }
[13:23:05.071]                 else {
[13:23:05.071]                   if (TRUE) {
[13:23:05.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.071]                     {
[13:23:05.071]                       inherits <- base::inherits
[13:23:05.071]                       invokeRestart <- base::invokeRestart
[13:23:05.071]                       is.null <- base::is.null
[13:23:05.071]                       muffled <- FALSE
[13:23:05.071]                       if (inherits(cond, "message")) {
[13:23:05.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.071]                         if (muffled) 
[13:23:05.071]                           invokeRestart("muffleMessage")
[13:23:05.071]                       }
[13:23:05.071]                       else if (inherits(cond, "warning")) {
[13:23:05.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.071]                         if (muffled) 
[13:23:05.071]                           invokeRestart("muffleWarning")
[13:23:05.071]                       }
[13:23:05.071]                       else if (inherits(cond, "condition")) {
[13:23:05.071]                         if (!is.null(pattern)) {
[13:23:05.071]                           computeRestarts <- base::computeRestarts
[13:23:05.071]                           grepl <- base::grepl
[13:23:05.071]                           restarts <- computeRestarts(cond)
[13:23:05.071]                           for (restart in restarts) {
[13:23:05.071]                             name <- restart$name
[13:23:05.071]                             if (is.null(name)) 
[13:23:05.071]                               next
[13:23:05.071]                             if (!grepl(pattern, name)) 
[13:23:05.071]                               next
[13:23:05.071]                             invokeRestart(restart)
[13:23:05.071]                             muffled <- TRUE
[13:23:05.071]                             break
[13:23:05.071]                           }
[13:23:05.071]                         }
[13:23:05.071]                       }
[13:23:05.071]                       invisible(muffled)
[13:23:05.071]                     }
[13:23:05.071]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.071]                   }
[13:23:05.071]                 }
[13:23:05.071]             }
[13:23:05.071]         }))
[13:23:05.071]     }, error = function(ex) {
[13:23:05.071]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.071]                 ...future.rng), started = ...future.startTime, 
[13:23:05.071]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.071]             version = "1.8"), class = "FutureResult")
[13:23:05.071]     }, finally = {
[13:23:05.071]         if (!identical(...future.workdir, getwd())) 
[13:23:05.071]             setwd(...future.workdir)
[13:23:05.071]         {
[13:23:05.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.071]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.071]             }
[13:23:05.071]             base::options(...future.oldOptions)
[13:23:05.071]             if (.Platform$OS.type == "windows") {
[13:23:05.071]                 old_names <- names(...future.oldEnvVars)
[13:23:05.071]                 envs <- base::Sys.getenv()
[13:23:05.071]                 names <- names(envs)
[13:23:05.071]                 common <- intersect(names, old_names)
[13:23:05.071]                 added <- setdiff(names, old_names)
[13:23:05.071]                 removed <- setdiff(old_names, names)
[13:23:05.071]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.071]                   envs[common]]
[13:23:05.071]                 NAMES <- toupper(changed)
[13:23:05.071]                 args <- list()
[13:23:05.071]                 for (kk in seq_along(NAMES)) {
[13:23:05.071]                   name <- changed[[kk]]
[13:23:05.071]                   NAME <- NAMES[[kk]]
[13:23:05.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.071]                     next
[13:23:05.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.071]                 }
[13:23:05.071]                 NAMES <- toupper(added)
[13:23:05.071]                 for (kk in seq_along(NAMES)) {
[13:23:05.071]                   name <- added[[kk]]
[13:23:05.071]                   NAME <- NAMES[[kk]]
[13:23:05.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.071]                     next
[13:23:05.071]                   args[[name]] <- ""
[13:23:05.071]                 }
[13:23:05.071]                 NAMES <- toupper(removed)
[13:23:05.071]                 for (kk in seq_along(NAMES)) {
[13:23:05.071]                   name <- removed[[kk]]
[13:23:05.071]                   NAME <- NAMES[[kk]]
[13:23:05.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.071]                     next
[13:23:05.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.071]                 }
[13:23:05.071]                 if (length(args) > 0) 
[13:23:05.071]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.071]             }
[13:23:05.071]             else {
[13:23:05.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.071]             }
[13:23:05.071]             {
[13:23:05.071]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.071]                   0L) {
[13:23:05.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.071]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.071]                   base::options(opts)
[13:23:05.071]                 }
[13:23:05.071]                 {
[13:23:05.071]                   {
[13:23:05.071]                     NULL
[13:23:05.071]                     RNGkind("Mersenne-Twister")
[13:23:05.071]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.071]                       inherits = FALSE)
[13:23:05.071]                   }
[13:23:05.071]                   options(future.plan = NULL)
[13:23:05.071]                   if (is.na(NA_character_)) 
[13:23:05.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.071]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.071]                   {
[13:23:05.071]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.071]                     if (!future$lazy) 
[13:23:05.071]                       future <- run(future)
[13:23:05.071]                     invisible(future)
[13:23:05.071]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.071]                 }
[13:23:05.071]             }
[13:23:05.071]         }
[13:23:05.071]     })
[13:23:05.071]     if (TRUE) {
[13:23:05.071]         base::sink(type = "output", split = FALSE)
[13:23:05.071]         if (TRUE) {
[13:23:05.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.071]         }
[13:23:05.071]         else {
[13:23:05.071]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.071]         }
[13:23:05.071]         base::close(...future.stdout)
[13:23:05.071]         ...future.stdout <- NULL
[13:23:05.071]     }
[13:23:05.071]     ...future.result$conditions <- ...future.conditions
[13:23:05.071]     ...future.result$finished <- base::Sys.time()
[13:23:05.071]     ...future.result
[13:23:05.071] }
[13:23:05.073] plan(): Setting new future strategy stack:
[13:23:05.073] List of future strategies:
[13:23:05.073] 1. sequential:
[13:23:05.073]    - args: function (..., envir = parent.frame())
[13:23:05.073]    - tweaked: FALSE
[13:23:05.073]    - call: NULL
[13:23:05.074] plan(): nbrOfWorkers() = 1
[13:23:05.075] plan(): Setting new future strategy stack:
[13:23:05.075] List of future strategies:
[13:23:05.075] 1. sequential:
[13:23:05.075]    - args: function (..., envir = parent.frame())
[13:23:05.075]    - tweaked: FALSE
[13:23:05.075]    - call: plan(strategy)
[13:23:05.075] plan(): nbrOfWorkers() = 1
[13:23:05.075] SequentialFuture started (and completed)
[13:23:05.075] - Launch lazy future ... done
[13:23:05.076] run() for ‘SequentialFuture’ ... done
[13:23:05.076] getGlobalsAndPackages() ...
[13:23:05.076] Searching for globals...
[13:23:05.076] 
[13:23:05.076] Searching for globals ... DONE
[13:23:05.076] - globals: [0] <none>
[13:23:05.078] getGlobalsAndPackages() ... DONE
[13:23:05.079] run() for ‘Future’ ...
[13:23:05.079] - state: ‘created’
[13:23:05.079] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.079] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.079]   - Field: ‘label’
[13:23:05.079]   - Field: ‘local’
[13:23:05.080]   - Field: ‘owner’
[13:23:05.080]   - Field: ‘envir’
[13:23:05.080]   - Field: ‘packages’
[13:23:05.080]   - Field: ‘gc’
[13:23:05.080]   - Field: ‘conditions’
[13:23:05.080]   - Field: ‘expr’
[13:23:05.080]   - Field: ‘uuid’
[13:23:05.080]   - Field: ‘seed’
[13:23:05.080]   - Field: ‘version’
[13:23:05.080]   - Field: ‘result’
[13:23:05.081]   - Field: ‘asynchronous’
[13:23:05.081]   - Field: ‘calls’
[13:23:05.081]   - Field: ‘globals’
[13:23:05.081]   - Field: ‘stdout’
[13:23:05.081]   - Field: ‘earlySignal’
[13:23:05.081]   - Field: ‘lazy’
[13:23:05.081]   - Field: ‘state’
[13:23:05.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.081] - Launch lazy future ...
[13:23:05.082] Packages needed by the future expression (n = 0): <none>
[13:23:05.082] Packages needed by future strategies (n = 0): <none>
[13:23:05.082] {
[13:23:05.082]     {
[13:23:05.082]         {
[13:23:05.082]             ...future.startTime <- base::Sys.time()
[13:23:05.082]             {
[13:23:05.082]                 {
[13:23:05.082]                   {
[13:23:05.082]                     base::local({
[13:23:05.082]                       has_future <- base::requireNamespace("future", 
[13:23:05.082]                         quietly = TRUE)
[13:23:05.082]                       if (has_future) {
[13:23:05.082]                         ns <- base::getNamespace("future")
[13:23:05.082]                         version <- ns[[".package"]][["version"]]
[13:23:05.082]                         if (is.null(version)) 
[13:23:05.082]                           version <- utils::packageVersion("future")
[13:23:05.082]                       }
[13:23:05.082]                       else {
[13:23:05.082]                         version <- NULL
[13:23:05.082]                       }
[13:23:05.082]                       if (!has_future || version < "1.8.0") {
[13:23:05.082]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.082]                           "", base::R.version$version.string), 
[13:23:05.082]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.082]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.082]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.082]                             "release", "version")], collapse = " "), 
[13:23:05.082]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.082]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.082]                           info)
[13:23:05.082]                         info <- base::paste(info, collapse = "; ")
[13:23:05.082]                         if (!has_future) {
[13:23:05.082]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.082]                             info)
[13:23:05.082]                         }
[13:23:05.082]                         else {
[13:23:05.082]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.082]                             info, version)
[13:23:05.082]                         }
[13:23:05.082]                         base::stop(msg)
[13:23:05.082]                       }
[13:23:05.082]                     })
[13:23:05.082]                   }
[13:23:05.082]                   options(future.plan = NULL)
[13:23:05.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.082]                 }
[13:23:05.082]                 ...future.workdir <- getwd()
[13:23:05.082]             }
[13:23:05.082]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.082]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.082]         }
[13:23:05.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.082]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.082]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.082]             base::names(...future.oldOptions))
[13:23:05.082]     }
[13:23:05.082]     if (FALSE) {
[13:23:05.082]     }
[13:23:05.082]     else {
[13:23:05.082]         if (TRUE) {
[13:23:05.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.082]                 open = "w")
[13:23:05.082]         }
[13:23:05.082]         else {
[13:23:05.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.082]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.082]         }
[13:23:05.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.082]             base::sink(type = "output", split = FALSE)
[13:23:05.082]             base::close(...future.stdout)
[13:23:05.082]         }, add = TRUE)
[13:23:05.082]     }
[13:23:05.082]     ...future.frame <- base::sys.nframe()
[13:23:05.082]     ...future.conditions <- base::list()
[13:23:05.082]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.082]     if (FALSE) {
[13:23:05.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.082]     }
[13:23:05.082]     ...future.result <- base::tryCatch({
[13:23:05.082]         base::withCallingHandlers({
[13:23:05.082]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.082]             future::FutureResult(value = ...future.value$value, 
[13:23:05.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.082]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.082]                     ...future.globalenv.names))
[13:23:05.082]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.082]         }, condition = base::local({
[13:23:05.082]             c <- base::c
[13:23:05.082]             inherits <- base::inherits
[13:23:05.082]             invokeRestart <- base::invokeRestart
[13:23:05.082]             length <- base::length
[13:23:05.082]             list <- base::list
[13:23:05.082]             seq.int <- base::seq.int
[13:23:05.082]             signalCondition <- base::signalCondition
[13:23:05.082]             sys.calls <- base::sys.calls
[13:23:05.082]             `[[` <- base::`[[`
[13:23:05.082]             `+` <- base::`+`
[13:23:05.082]             `<<-` <- base::`<<-`
[13:23:05.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.082]                   3L)]
[13:23:05.082]             }
[13:23:05.082]             function(cond) {
[13:23:05.082]                 is_error <- inherits(cond, "error")
[13:23:05.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.082]                   NULL)
[13:23:05.082]                 if (is_error) {
[13:23:05.082]                   sessionInformation <- function() {
[13:23:05.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.082]                       search = base::search(), system = base::Sys.info())
[13:23:05.082]                   }
[13:23:05.082]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.082]                     cond$call), session = sessionInformation(), 
[13:23:05.082]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.082]                   signalCondition(cond)
[13:23:05.082]                 }
[13:23:05.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.082]                 "immediateCondition"))) {
[13:23:05.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.082]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.082]                   if (TRUE && !signal) {
[13:23:05.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.082]                     {
[13:23:05.082]                       inherits <- base::inherits
[13:23:05.082]                       invokeRestart <- base::invokeRestart
[13:23:05.082]                       is.null <- base::is.null
[13:23:05.082]                       muffled <- FALSE
[13:23:05.082]                       if (inherits(cond, "message")) {
[13:23:05.082]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.082]                         if (muffled) 
[13:23:05.082]                           invokeRestart("muffleMessage")
[13:23:05.082]                       }
[13:23:05.082]                       else if (inherits(cond, "warning")) {
[13:23:05.082]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.082]                         if (muffled) 
[13:23:05.082]                           invokeRestart("muffleWarning")
[13:23:05.082]                       }
[13:23:05.082]                       else if (inherits(cond, "condition")) {
[13:23:05.082]                         if (!is.null(pattern)) {
[13:23:05.082]                           computeRestarts <- base::computeRestarts
[13:23:05.082]                           grepl <- base::grepl
[13:23:05.082]                           restarts <- computeRestarts(cond)
[13:23:05.082]                           for (restart in restarts) {
[13:23:05.082]                             name <- restart$name
[13:23:05.082]                             if (is.null(name)) 
[13:23:05.082]                               next
[13:23:05.082]                             if (!grepl(pattern, name)) 
[13:23:05.082]                               next
[13:23:05.082]                             invokeRestart(restart)
[13:23:05.082]                             muffled <- TRUE
[13:23:05.082]                             break
[13:23:05.082]                           }
[13:23:05.082]                         }
[13:23:05.082]                       }
[13:23:05.082]                       invisible(muffled)
[13:23:05.082]                     }
[13:23:05.082]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.082]                   }
[13:23:05.082]                 }
[13:23:05.082]                 else {
[13:23:05.082]                   if (TRUE) {
[13:23:05.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.082]                     {
[13:23:05.082]                       inherits <- base::inherits
[13:23:05.082]                       invokeRestart <- base::invokeRestart
[13:23:05.082]                       is.null <- base::is.null
[13:23:05.082]                       muffled <- FALSE
[13:23:05.082]                       if (inherits(cond, "message")) {
[13:23:05.082]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.082]                         if (muffled) 
[13:23:05.082]                           invokeRestart("muffleMessage")
[13:23:05.082]                       }
[13:23:05.082]                       else if (inherits(cond, "warning")) {
[13:23:05.082]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.082]                         if (muffled) 
[13:23:05.082]                           invokeRestart("muffleWarning")
[13:23:05.082]                       }
[13:23:05.082]                       else if (inherits(cond, "condition")) {
[13:23:05.082]                         if (!is.null(pattern)) {
[13:23:05.082]                           computeRestarts <- base::computeRestarts
[13:23:05.082]                           grepl <- base::grepl
[13:23:05.082]                           restarts <- computeRestarts(cond)
[13:23:05.082]                           for (restart in restarts) {
[13:23:05.082]                             name <- restart$name
[13:23:05.082]                             if (is.null(name)) 
[13:23:05.082]                               next
[13:23:05.082]                             if (!grepl(pattern, name)) 
[13:23:05.082]                               next
[13:23:05.082]                             invokeRestart(restart)
[13:23:05.082]                             muffled <- TRUE
[13:23:05.082]                             break
[13:23:05.082]                           }
[13:23:05.082]                         }
[13:23:05.082]                       }
[13:23:05.082]                       invisible(muffled)
[13:23:05.082]                     }
[13:23:05.082]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.082]                   }
[13:23:05.082]                 }
[13:23:05.082]             }
[13:23:05.082]         }))
[13:23:05.082]     }, error = function(ex) {
[13:23:05.082]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.082]                 ...future.rng), started = ...future.startTime, 
[13:23:05.082]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.082]             version = "1.8"), class = "FutureResult")
[13:23:05.082]     }, finally = {
[13:23:05.082]         if (!identical(...future.workdir, getwd())) 
[13:23:05.082]             setwd(...future.workdir)
[13:23:05.082]         {
[13:23:05.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.082]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.082]             }
[13:23:05.082]             base::options(...future.oldOptions)
[13:23:05.082]             if (.Platform$OS.type == "windows") {
[13:23:05.082]                 old_names <- names(...future.oldEnvVars)
[13:23:05.082]                 envs <- base::Sys.getenv()
[13:23:05.082]                 names <- names(envs)
[13:23:05.082]                 common <- intersect(names, old_names)
[13:23:05.082]                 added <- setdiff(names, old_names)
[13:23:05.082]                 removed <- setdiff(old_names, names)
[13:23:05.082]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.082]                   envs[common]]
[13:23:05.082]                 NAMES <- toupper(changed)
[13:23:05.082]                 args <- list()
[13:23:05.082]                 for (kk in seq_along(NAMES)) {
[13:23:05.082]                   name <- changed[[kk]]
[13:23:05.082]                   NAME <- NAMES[[kk]]
[13:23:05.082]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.082]                     next
[13:23:05.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.082]                 }
[13:23:05.082]                 NAMES <- toupper(added)
[13:23:05.082]                 for (kk in seq_along(NAMES)) {
[13:23:05.082]                   name <- added[[kk]]
[13:23:05.082]                   NAME <- NAMES[[kk]]
[13:23:05.082]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.082]                     next
[13:23:05.082]                   args[[name]] <- ""
[13:23:05.082]                 }
[13:23:05.082]                 NAMES <- toupper(removed)
[13:23:05.082]                 for (kk in seq_along(NAMES)) {
[13:23:05.082]                   name <- removed[[kk]]
[13:23:05.082]                   NAME <- NAMES[[kk]]
[13:23:05.082]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.082]                     next
[13:23:05.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.082]                 }
[13:23:05.082]                 if (length(args) > 0) 
[13:23:05.082]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.082]             }
[13:23:05.082]             else {
[13:23:05.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.082]             }
[13:23:05.082]             {
[13:23:05.082]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.082]                   0L) {
[13:23:05.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.082]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.082]                   base::options(opts)
[13:23:05.082]                 }
[13:23:05.082]                 {
[13:23:05.082]                   {
[13:23:05.082]                     NULL
[13:23:05.082]                     RNGkind("Mersenne-Twister")
[13:23:05.082]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.082]                       inherits = FALSE)
[13:23:05.082]                   }
[13:23:05.082]                   options(future.plan = NULL)
[13:23:05.082]                   if (is.na(NA_character_)) 
[13:23:05.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.082]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.082]                   {
[13:23:05.082]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.082]                     if (!future$lazy) 
[13:23:05.082]                       future <- run(future)
[13:23:05.082]                     invisible(future)
[13:23:05.082]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.082]                 }
[13:23:05.082]             }
[13:23:05.082]         }
[13:23:05.082]     })
[13:23:05.082]     if (TRUE) {
[13:23:05.082]         base::sink(type = "output", split = FALSE)
[13:23:05.082]         if (TRUE) {
[13:23:05.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.082]         }
[13:23:05.082]         else {
[13:23:05.082]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.082]         }
[13:23:05.082]         base::close(...future.stdout)
[13:23:05.082]         ...future.stdout <- NULL
[13:23:05.082]     }
[13:23:05.082]     ...future.result$conditions <- ...future.conditions
[13:23:05.082]     ...future.result$finished <- base::Sys.time()
[13:23:05.082]     ...future.result
[13:23:05.082] }
[13:23:05.084] plan(): Setting new future strategy stack:
[13:23:05.084] List of future strategies:
[13:23:05.084] 1. sequential:
[13:23:05.084]    - args: function (..., envir = parent.frame())
[13:23:05.084]    - tweaked: FALSE
[13:23:05.084]    - call: NULL
[13:23:05.085] plan(): nbrOfWorkers() = 1
[13:23:05.085] plan(): Setting new future strategy stack:
[13:23:05.086] List of future strategies:
[13:23:05.086] 1. sequential:
[13:23:05.086]    - args: function (..., envir = parent.frame())
[13:23:05.086]    - tweaked: FALSE
[13:23:05.086]    - call: plan(strategy)
[13:23:05.086] plan(): nbrOfWorkers() = 1
[13:23:05.086] SequentialFuture started (and completed)
[13:23:05.086] - Launch lazy future ... done
[13:23:05.086] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d5912100> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d4c90338> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d5912100> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d4c90338> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:23:05.092] resolved() for ‘SequentialFuture’ ...
[13:23:05.092] - state: ‘finished’
[13:23:05.092] - run: TRUE
[13:23:05.092] - result: ‘FutureResult’
[13:23:05.092] resolved() for ‘SequentialFuture’ ... done
[13:23:05.092] resolved() for ‘SequentialFuture’ ...
[13:23:05.092] - state: ‘finished’
[13:23:05.092] - run: TRUE
[13:23:05.092] - result: ‘FutureResult’
[13:23:05.093] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:05.094] resolve() on list ...
[13:23:05.094]  recursive: 0
[13:23:05.094]  length: 6
[13:23:05.094]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:05.095] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.095] - nx: 6
[13:23:05.095] - relay: TRUE
[13:23:05.095] - stdout: TRUE
[13:23:05.095] - signal: TRUE
[13:23:05.095] - resignal: FALSE
[13:23:05.095] - force: TRUE
[13:23:05.095] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.095] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.095]  - until=2
[13:23:05.096]  - relaying element #2
[13:23:05.096] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.096] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.096] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.096]  length: 5 (resolved future 1)
[13:23:05.096] resolved() for ‘SequentialFuture’ ...
[13:23:05.096] - state: ‘finished’
[13:23:05.096] - run: TRUE
[13:23:05.096] - result: ‘FutureResult’
[13:23:05.097] resolved() for ‘SequentialFuture’ ... done
[13:23:05.097] Future #2
[13:23:05.097] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.097] - nx: 6
[13:23:05.097] - relay: TRUE
[13:23:05.097] - stdout: TRUE
[13:23:05.097] - signal: TRUE
[13:23:05.097] - resignal: FALSE
[13:23:05.097] - force: TRUE
[13:23:05.097] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.097] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.098]  - until=2
[13:23:05.098]  - relaying element #2
[13:23:05.098] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.098] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.098] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.098]  length: 4 (resolved future 2)
[13:23:05.098] resolved() for ‘SequentialFuture’ ...
[13:23:05.098] - state: ‘finished’
[13:23:05.098] - run: TRUE
[13:23:05.099] - result: ‘FutureResult’
[13:23:05.099] resolved() for ‘SequentialFuture’ ... done
[13:23:05.099] Future #3
[13:23:05.099] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.099] - nx: 6
[13:23:05.099] - relay: TRUE
[13:23:05.099] - stdout: TRUE
[13:23:05.099] - signal: TRUE
[13:23:05.099] - resignal: FALSE
[13:23:05.099] - force: TRUE
[13:23:05.100] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.100] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.100]  - until=3
[13:23:05.100]  - relaying element #3
[13:23:05.100] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.100] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.100] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.100]  length: 3 (resolved future 3)
[13:23:05.100] signalConditionsASAP(NULL, pos=4) ...
[13:23:05.100] - nx: 6
[13:23:05.101] - relay: TRUE
[13:23:05.101] - stdout: TRUE
[13:23:05.101] - signal: TRUE
[13:23:05.101] - resignal: FALSE
[13:23:05.101] - force: TRUE
[13:23:05.101] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.101] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.101]  - until=5
[13:23:05.101]  - relaying element #5
[13:23:05.101] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.101] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.102] signalConditionsASAP(NULL, pos=4) ... done
[13:23:05.102]  length: 2 (resolved future 4)
[13:23:05.102] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.102] - nx: 6
[13:23:05.102] - relay: TRUE
[13:23:05.102] - stdout: TRUE
[13:23:05.102] - signal: TRUE
[13:23:05.102] - resignal: FALSE
[13:23:05.102] - force: TRUE
[13:23:05.102] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.102] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.102]  - until=6
[13:23:05.103]  - relaying element #6
[13:23:05.103] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.103] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.103] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.103]  length: 1 (resolved future 5)
[13:23:05.103] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.103] - nx: 6
[13:23:05.103] - relay: TRUE
[13:23:05.103] - stdout: TRUE
[13:23:05.103] - signal: TRUE
[13:23:05.103] - resignal: FALSE
[13:23:05.104] - force: TRUE
[13:23:05.104] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.104] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.104]  - until=6
[13:23:05.104] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.104] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.104] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.104]  length: 0 (resolved future 6)
[13:23:05.104] Relaying remaining futures
[13:23:05.104] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.104] - nx: 6
[13:23:05.105] - relay: TRUE
[13:23:05.105] - stdout: TRUE
[13:23:05.105] - signal: TRUE
[13:23:05.105] - resignal: FALSE
[13:23:05.105] - force: TRUE
[13:23:05.105] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.105] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:05.105] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.105] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.105] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.105] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:23:05.111] getGlobalsAndPackages() ...
[13:23:05.111] Searching for globals...
[13:23:05.112] 
[13:23:05.112] Searching for globals ... DONE
[13:23:05.112] - globals: [0] <none>
[13:23:05.112] getGlobalsAndPackages() ... DONE
[13:23:05.112] run() for ‘Future’ ...
[13:23:05.112] - state: ‘created’
[13:23:05.113] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.113] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.113]   - Field: ‘label’
[13:23:05.113]   - Field: ‘local’
[13:23:05.113]   - Field: ‘owner’
[13:23:05.113]   - Field: ‘envir’
[13:23:05.113]   - Field: ‘packages’
[13:23:05.114]   - Field: ‘gc’
[13:23:05.114]   - Field: ‘conditions’
[13:23:05.114]   - Field: ‘expr’
[13:23:05.114]   - Field: ‘uuid’
[13:23:05.114]   - Field: ‘seed’
[13:23:05.114]   - Field: ‘version’
[13:23:05.114]   - Field: ‘result’
[13:23:05.114]   - Field: ‘asynchronous’
[13:23:05.114]   - Field: ‘calls’
[13:23:05.114]   - Field: ‘globals’
[13:23:05.114]   - Field: ‘stdout’
[13:23:05.115]   - Field: ‘earlySignal’
[13:23:05.115]   - Field: ‘lazy’
[13:23:05.115]   - Field: ‘state’
[13:23:05.115] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.115] - Launch lazy future ...
[13:23:05.115] Packages needed by the future expression (n = 0): <none>
[13:23:05.115] Packages needed by future strategies (n = 0): <none>
[13:23:05.116] {
[13:23:05.116]     {
[13:23:05.116]         {
[13:23:05.116]             ...future.startTime <- base::Sys.time()
[13:23:05.116]             {
[13:23:05.116]                 {
[13:23:05.116]                   {
[13:23:05.116]                     base::local({
[13:23:05.116]                       has_future <- base::requireNamespace("future", 
[13:23:05.116]                         quietly = TRUE)
[13:23:05.116]                       if (has_future) {
[13:23:05.116]                         ns <- base::getNamespace("future")
[13:23:05.116]                         version <- ns[[".package"]][["version"]]
[13:23:05.116]                         if (is.null(version)) 
[13:23:05.116]                           version <- utils::packageVersion("future")
[13:23:05.116]                       }
[13:23:05.116]                       else {
[13:23:05.116]                         version <- NULL
[13:23:05.116]                       }
[13:23:05.116]                       if (!has_future || version < "1.8.0") {
[13:23:05.116]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.116]                           "", base::R.version$version.string), 
[13:23:05.116]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.116]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.116]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.116]                             "release", "version")], collapse = " "), 
[13:23:05.116]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.116]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.116]                           info)
[13:23:05.116]                         info <- base::paste(info, collapse = "; ")
[13:23:05.116]                         if (!has_future) {
[13:23:05.116]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.116]                             info)
[13:23:05.116]                         }
[13:23:05.116]                         else {
[13:23:05.116]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.116]                             info, version)
[13:23:05.116]                         }
[13:23:05.116]                         base::stop(msg)
[13:23:05.116]                       }
[13:23:05.116]                     })
[13:23:05.116]                   }
[13:23:05.116]                   options(future.plan = NULL)
[13:23:05.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.116]                 }
[13:23:05.116]                 ...future.workdir <- getwd()
[13:23:05.116]             }
[13:23:05.116]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.116]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.116]         }
[13:23:05.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.116]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.116]             base::names(...future.oldOptions))
[13:23:05.116]     }
[13:23:05.116]     if (FALSE) {
[13:23:05.116]     }
[13:23:05.116]     else {
[13:23:05.116]         if (TRUE) {
[13:23:05.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.116]                 open = "w")
[13:23:05.116]         }
[13:23:05.116]         else {
[13:23:05.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.116]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.116]         }
[13:23:05.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.116]             base::sink(type = "output", split = FALSE)
[13:23:05.116]             base::close(...future.stdout)
[13:23:05.116]         }, add = TRUE)
[13:23:05.116]     }
[13:23:05.116]     ...future.frame <- base::sys.nframe()
[13:23:05.116]     ...future.conditions <- base::list()
[13:23:05.116]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.116]     if (FALSE) {
[13:23:05.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.116]     }
[13:23:05.116]     ...future.result <- base::tryCatch({
[13:23:05.116]         base::withCallingHandlers({
[13:23:05.116]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.116]             future::FutureResult(value = ...future.value$value, 
[13:23:05.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.116]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.116]                     ...future.globalenv.names))
[13:23:05.116]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.116]         }, condition = base::local({
[13:23:05.116]             c <- base::c
[13:23:05.116]             inherits <- base::inherits
[13:23:05.116]             invokeRestart <- base::invokeRestart
[13:23:05.116]             length <- base::length
[13:23:05.116]             list <- base::list
[13:23:05.116]             seq.int <- base::seq.int
[13:23:05.116]             signalCondition <- base::signalCondition
[13:23:05.116]             sys.calls <- base::sys.calls
[13:23:05.116]             `[[` <- base::`[[`
[13:23:05.116]             `+` <- base::`+`
[13:23:05.116]             `<<-` <- base::`<<-`
[13:23:05.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.116]                   3L)]
[13:23:05.116]             }
[13:23:05.116]             function(cond) {
[13:23:05.116]                 is_error <- inherits(cond, "error")
[13:23:05.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.116]                   NULL)
[13:23:05.116]                 if (is_error) {
[13:23:05.116]                   sessionInformation <- function() {
[13:23:05.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.116]                       search = base::search(), system = base::Sys.info())
[13:23:05.116]                   }
[13:23:05.116]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.116]                     cond$call), session = sessionInformation(), 
[13:23:05.116]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.116]                   signalCondition(cond)
[13:23:05.116]                 }
[13:23:05.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.116]                 "immediateCondition"))) {
[13:23:05.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.116]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.116]                   if (TRUE && !signal) {
[13:23:05.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.116]                     {
[13:23:05.116]                       inherits <- base::inherits
[13:23:05.116]                       invokeRestart <- base::invokeRestart
[13:23:05.116]                       is.null <- base::is.null
[13:23:05.116]                       muffled <- FALSE
[13:23:05.116]                       if (inherits(cond, "message")) {
[13:23:05.116]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.116]                         if (muffled) 
[13:23:05.116]                           invokeRestart("muffleMessage")
[13:23:05.116]                       }
[13:23:05.116]                       else if (inherits(cond, "warning")) {
[13:23:05.116]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.116]                         if (muffled) 
[13:23:05.116]                           invokeRestart("muffleWarning")
[13:23:05.116]                       }
[13:23:05.116]                       else if (inherits(cond, "condition")) {
[13:23:05.116]                         if (!is.null(pattern)) {
[13:23:05.116]                           computeRestarts <- base::computeRestarts
[13:23:05.116]                           grepl <- base::grepl
[13:23:05.116]                           restarts <- computeRestarts(cond)
[13:23:05.116]                           for (restart in restarts) {
[13:23:05.116]                             name <- restart$name
[13:23:05.116]                             if (is.null(name)) 
[13:23:05.116]                               next
[13:23:05.116]                             if (!grepl(pattern, name)) 
[13:23:05.116]                               next
[13:23:05.116]                             invokeRestart(restart)
[13:23:05.116]                             muffled <- TRUE
[13:23:05.116]                             break
[13:23:05.116]                           }
[13:23:05.116]                         }
[13:23:05.116]                       }
[13:23:05.116]                       invisible(muffled)
[13:23:05.116]                     }
[13:23:05.116]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.116]                   }
[13:23:05.116]                 }
[13:23:05.116]                 else {
[13:23:05.116]                   if (TRUE) {
[13:23:05.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.116]                     {
[13:23:05.116]                       inherits <- base::inherits
[13:23:05.116]                       invokeRestart <- base::invokeRestart
[13:23:05.116]                       is.null <- base::is.null
[13:23:05.116]                       muffled <- FALSE
[13:23:05.116]                       if (inherits(cond, "message")) {
[13:23:05.116]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.116]                         if (muffled) 
[13:23:05.116]                           invokeRestart("muffleMessage")
[13:23:05.116]                       }
[13:23:05.116]                       else if (inherits(cond, "warning")) {
[13:23:05.116]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.116]                         if (muffled) 
[13:23:05.116]                           invokeRestart("muffleWarning")
[13:23:05.116]                       }
[13:23:05.116]                       else if (inherits(cond, "condition")) {
[13:23:05.116]                         if (!is.null(pattern)) {
[13:23:05.116]                           computeRestarts <- base::computeRestarts
[13:23:05.116]                           grepl <- base::grepl
[13:23:05.116]                           restarts <- computeRestarts(cond)
[13:23:05.116]                           for (restart in restarts) {
[13:23:05.116]                             name <- restart$name
[13:23:05.116]                             if (is.null(name)) 
[13:23:05.116]                               next
[13:23:05.116]                             if (!grepl(pattern, name)) 
[13:23:05.116]                               next
[13:23:05.116]                             invokeRestart(restart)
[13:23:05.116]                             muffled <- TRUE
[13:23:05.116]                             break
[13:23:05.116]                           }
[13:23:05.116]                         }
[13:23:05.116]                       }
[13:23:05.116]                       invisible(muffled)
[13:23:05.116]                     }
[13:23:05.116]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.116]                   }
[13:23:05.116]                 }
[13:23:05.116]             }
[13:23:05.116]         }))
[13:23:05.116]     }, error = function(ex) {
[13:23:05.116]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.116]                 ...future.rng), started = ...future.startTime, 
[13:23:05.116]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.116]             version = "1.8"), class = "FutureResult")
[13:23:05.116]     }, finally = {
[13:23:05.116]         if (!identical(...future.workdir, getwd())) 
[13:23:05.116]             setwd(...future.workdir)
[13:23:05.116]         {
[13:23:05.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.116]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.116]             }
[13:23:05.116]             base::options(...future.oldOptions)
[13:23:05.116]             if (.Platform$OS.type == "windows") {
[13:23:05.116]                 old_names <- names(...future.oldEnvVars)
[13:23:05.116]                 envs <- base::Sys.getenv()
[13:23:05.116]                 names <- names(envs)
[13:23:05.116]                 common <- intersect(names, old_names)
[13:23:05.116]                 added <- setdiff(names, old_names)
[13:23:05.116]                 removed <- setdiff(old_names, names)
[13:23:05.116]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.116]                   envs[common]]
[13:23:05.116]                 NAMES <- toupper(changed)
[13:23:05.116]                 args <- list()
[13:23:05.116]                 for (kk in seq_along(NAMES)) {
[13:23:05.116]                   name <- changed[[kk]]
[13:23:05.116]                   NAME <- NAMES[[kk]]
[13:23:05.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.116]                     next
[13:23:05.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.116]                 }
[13:23:05.116]                 NAMES <- toupper(added)
[13:23:05.116]                 for (kk in seq_along(NAMES)) {
[13:23:05.116]                   name <- added[[kk]]
[13:23:05.116]                   NAME <- NAMES[[kk]]
[13:23:05.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.116]                     next
[13:23:05.116]                   args[[name]] <- ""
[13:23:05.116]                 }
[13:23:05.116]                 NAMES <- toupper(removed)
[13:23:05.116]                 for (kk in seq_along(NAMES)) {
[13:23:05.116]                   name <- removed[[kk]]
[13:23:05.116]                   NAME <- NAMES[[kk]]
[13:23:05.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.116]                     next
[13:23:05.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.116]                 }
[13:23:05.116]                 if (length(args) > 0) 
[13:23:05.116]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.116]             }
[13:23:05.116]             else {
[13:23:05.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.116]             }
[13:23:05.116]             {
[13:23:05.116]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.116]                   0L) {
[13:23:05.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.116]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.116]                   base::options(opts)
[13:23:05.116]                 }
[13:23:05.116]                 {
[13:23:05.116]                   {
[13:23:05.116]                     NULL
[13:23:05.116]                     RNGkind("Mersenne-Twister")
[13:23:05.116]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.116]                       inherits = FALSE)
[13:23:05.116]                   }
[13:23:05.116]                   options(future.plan = NULL)
[13:23:05.116]                   if (is.na(NA_character_)) 
[13:23:05.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.116]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.116]                   {
[13:23:05.116]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.116]                     if (!future$lazy) 
[13:23:05.116]                       future <- run(future)
[13:23:05.116]                     invisible(future)
[13:23:05.116]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.116]                 }
[13:23:05.116]             }
[13:23:05.116]         }
[13:23:05.116]     })
[13:23:05.116]     if (TRUE) {
[13:23:05.116]         base::sink(type = "output", split = FALSE)
[13:23:05.116]         if (TRUE) {
[13:23:05.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.116]         }
[13:23:05.116]         else {
[13:23:05.116]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.116]         }
[13:23:05.116]         base::close(...future.stdout)
[13:23:05.116]         ...future.stdout <- NULL
[13:23:05.116]     }
[13:23:05.116]     ...future.result$conditions <- ...future.conditions
[13:23:05.116]     ...future.result$finished <- base::Sys.time()
[13:23:05.116]     ...future.result
[13:23:05.116] }
[13:23:05.118] plan(): Setting new future strategy stack:
[13:23:05.118] List of future strategies:
[13:23:05.118] 1. sequential:
[13:23:05.118]    - args: function (..., envir = parent.frame())
[13:23:05.118]    - tweaked: FALSE
[13:23:05.118]    - call: NULL
[13:23:05.118] plan(): nbrOfWorkers() = 1
[13:23:05.119] plan(): Setting new future strategy stack:
[13:23:05.119] List of future strategies:
[13:23:05.119] 1. sequential:
[13:23:05.119]    - args: function (..., envir = parent.frame())
[13:23:05.119]    - tweaked: FALSE
[13:23:05.119]    - call: plan(strategy)
[13:23:05.120] plan(): nbrOfWorkers() = 1
[13:23:05.120] SequentialFuture started (and completed)
[13:23:05.120] - Launch lazy future ... done
[13:23:05.120] run() for ‘SequentialFuture’ ... done
[13:23:05.120] getGlobalsAndPackages() ...
[13:23:05.120] Searching for globals...
[13:23:05.121] 
[13:23:05.121] Searching for globals ... DONE
[13:23:05.121] - globals: [0] <none>
[13:23:05.121] getGlobalsAndPackages() ... DONE
[13:23:05.121] run() for ‘Future’ ...
[13:23:05.121] - state: ‘created’
[13:23:05.121] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.122] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.122] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.122]   - Field: ‘label’
[13:23:05.122]   - Field: ‘local’
[13:23:05.122]   - Field: ‘owner’
[13:23:05.122]   - Field: ‘envir’
[13:23:05.122]   - Field: ‘packages’
[13:23:05.122]   - Field: ‘gc’
[13:23:05.122]   - Field: ‘conditions’
[13:23:05.123]   - Field: ‘expr’
[13:23:05.123]   - Field: ‘uuid’
[13:23:05.123]   - Field: ‘seed’
[13:23:05.123]   - Field: ‘version’
[13:23:05.123]   - Field: ‘result’
[13:23:05.123]   - Field: ‘asynchronous’
[13:23:05.123]   - Field: ‘calls’
[13:23:05.123]   - Field: ‘globals’
[13:23:05.123]   - Field: ‘stdout’
[13:23:05.123]   - Field: ‘earlySignal’
[13:23:05.123]   - Field: ‘lazy’
[13:23:05.124]   - Field: ‘state’
[13:23:05.124] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.124] - Launch lazy future ...
[13:23:05.124] Packages needed by the future expression (n = 0): <none>
[13:23:05.124] Packages needed by future strategies (n = 0): <none>
[13:23:05.125] {
[13:23:05.125]     {
[13:23:05.125]         {
[13:23:05.125]             ...future.startTime <- base::Sys.time()
[13:23:05.125]             {
[13:23:05.125]                 {
[13:23:05.125]                   {
[13:23:05.125]                     base::local({
[13:23:05.125]                       has_future <- base::requireNamespace("future", 
[13:23:05.125]                         quietly = TRUE)
[13:23:05.125]                       if (has_future) {
[13:23:05.125]                         ns <- base::getNamespace("future")
[13:23:05.125]                         version <- ns[[".package"]][["version"]]
[13:23:05.125]                         if (is.null(version)) 
[13:23:05.125]                           version <- utils::packageVersion("future")
[13:23:05.125]                       }
[13:23:05.125]                       else {
[13:23:05.125]                         version <- NULL
[13:23:05.125]                       }
[13:23:05.125]                       if (!has_future || version < "1.8.0") {
[13:23:05.125]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.125]                           "", base::R.version$version.string), 
[13:23:05.125]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.125]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.125]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.125]                             "release", "version")], collapse = " "), 
[13:23:05.125]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.125]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.125]                           info)
[13:23:05.125]                         info <- base::paste(info, collapse = "; ")
[13:23:05.125]                         if (!has_future) {
[13:23:05.125]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.125]                             info)
[13:23:05.125]                         }
[13:23:05.125]                         else {
[13:23:05.125]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.125]                             info, version)
[13:23:05.125]                         }
[13:23:05.125]                         base::stop(msg)
[13:23:05.125]                       }
[13:23:05.125]                     })
[13:23:05.125]                   }
[13:23:05.125]                   options(future.plan = NULL)
[13:23:05.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.125]                 }
[13:23:05.125]                 ...future.workdir <- getwd()
[13:23:05.125]             }
[13:23:05.125]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.125]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.125]         }
[13:23:05.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.125]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.125]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.125]             base::names(...future.oldOptions))
[13:23:05.125]     }
[13:23:05.125]     if (FALSE) {
[13:23:05.125]     }
[13:23:05.125]     else {
[13:23:05.125]         if (TRUE) {
[13:23:05.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.125]                 open = "w")
[13:23:05.125]         }
[13:23:05.125]         else {
[13:23:05.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.125]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.125]         }
[13:23:05.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.125]             base::sink(type = "output", split = FALSE)
[13:23:05.125]             base::close(...future.stdout)
[13:23:05.125]         }, add = TRUE)
[13:23:05.125]     }
[13:23:05.125]     ...future.frame <- base::sys.nframe()
[13:23:05.125]     ...future.conditions <- base::list()
[13:23:05.125]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.125]     if (FALSE) {
[13:23:05.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.125]     }
[13:23:05.125]     ...future.result <- base::tryCatch({
[13:23:05.125]         base::withCallingHandlers({
[13:23:05.125]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.125]             future::FutureResult(value = ...future.value$value, 
[13:23:05.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.125]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.125]                     ...future.globalenv.names))
[13:23:05.125]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.125]         }, condition = base::local({
[13:23:05.125]             c <- base::c
[13:23:05.125]             inherits <- base::inherits
[13:23:05.125]             invokeRestart <- base::invokeRestart
[13:23:05.125]             length <- base::length
[13:23:05.125]             list <- base::list
[13:23:05.125]             seq.int <- base::seq.int
[13:23:05.125]             signalCondition <- base::signalCondition
[13:23:05.125]             sys.calls <- base::sys.calls
[13:23:05.125]             `[[` <- base::`[[`
[13:23:05.125]             `+` <- base::`+`
[13:23:05.125]             `<<-` <- base::`<<-`
[13:23:05.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.125]                   3L)]
[13:23:05.125]             }
[13:23:05.125]             function(cond) {
[13:23:05.125]                 is_error <- inherits(cond, "error")
[13:23:05.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.125]                   NULL)
[13:23:05.125]                 if (is_error) {
[13:23:05.125]                   sessionInformation <- function() {
[13:23:05.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.125]                       search = base::search(), system = base::Sys.info())
[13:23:05.125]                   }
[13:23:05.125]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.125]                     cond$call), session = sessionInformation(), 
[13:23:05.125]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.125]                   signalCondition(cond)
[13:23:05.125]                 }
[13:23:05.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.125]                 "immediateCondition"))) {
[13:23:05.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.125]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.125]                   if (TRUE && !signal) {
[13:23:05.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.125]                     {
[13:23:05.125]                       inherits <- base::inherits
[13:23:05.125]                       invokeRestart <- base::invokeRestart
[13:23:05.125]                       is.null <- base::is.null
[13:23:05.125]                       muffled <- FALSE
[13:23:05.125]                       if (inherits(cond, "message")) {
[13:23:05.125]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.125]                         if (muffled) 
[13:23:05.125]                           invokeRestart("muffleMessage")
[13:23:05.125]                       }
[13:23:05.125]                       else if (inherits(cond, "warning")) {
[13:23:05.125]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.125]                         if (muffled) 
[13:23:05.125]                           invokeRestart("muffleWarning")
[13:23:05.125]                       }
[13:23:05.125]                       else if (inherits(cond, "condition")) {
[13:23:05.125]                         if (!is.null(pattern)) {
[13:23:05.125]                           computeRestarts <- base::computeRestarts
[13:23:05.125]                           grepl <- base::grepl
[13:23:05.125]                           restarts <- computeRestarts(cond)
[13:23:05.125]                           for (restart in restarts) {
[13:23:05.125]                             name <- restart$name
[13:23:05.125]                             if (is.null(name)) 
[13:23:05.125]                               next
[13:23:05.125]                             if (!grepl(pattern, name)) 
[13:23:05.125]                               next
[13:23:05.125]                             invokeRestart(restart)
[13:23:05.125]                             muffled <- TRUE
[13:23:05.125]                             break
[13:23:05.125]                           }
[13:23:05.125]                         }
[13:23:05.125]                       }
[13:23:05.125]                       invisible(muffled)
[13:23:05.125]                     }
[13:23:05.125]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.125]                   }
[13:23:05.125]                 }
[13:23:05.125]                 else {
[13:23:05.125]                   if (TRUE) {
[13:23:05.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.125]                     {
[13:23:05.125]                       inherits <- base::inherits
[13:23:05.125]                       invokeRestart <- base::invokeRestart
[13:23:05.125]                       is.null <- base::is.null
[13:23:05.125]                       muffled <- FALSE
[13:23:05.125]                       if (inherits(cond, "message")) {
[13:23:05.125]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.125]                         if (muffled) 
[13:23:05.125]                           invokeRestart("muffleMessage")
[13:23:05.125]                       }
[13:23:05.125]                       else if (inherits(cond, "warning")) {
[13:23:05.125]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.125]                         if (muffled) 
[13:23:05.125]                           invokeRestart("muffleWarning")
[13:23:05.125]                       }
[13:23:05.125]                       else if (inherits(cond, "condition")) {
[13:23:05.125]                         if (!is.null(pattern)) {
[13:23:05.125]                           computeRestarts <- base::computeRestarts
[13:23:05.125]                           grepl <- base::grepl
[13:23:05.125]                           restarts <- computeRestarts(cond)
[13:23:05.125]                           for (restart in restarts) {
[13:23:05.125]                             name <- restart$name
[13:23:05.125]                             if (is.null(name)) 
[13:23:05.125]                               next
[13:23:05.125]                             if (!grepl(pattern, name)) 
[13:23:05.125]                               next
[13:23:05.125]                             invokeRestart(restart)
[13:23:05.125]                             muffled <- TRUE
[13:23:05.125]                             break
[13:23:05.125]                           }
[13:23:05.125]                         }
[13:23:05.125]                       }
[13:23:05.125]                       invisible(muffled)
[13:23:05.125]                     }
[13:23:05.125]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.125]                   }
[13:23:05.125]                 }
[13:23:05.125]             }
[13:23:05.125]         }))
[13:23:05.125]     }, error = function(ex) {
[13:23:05.125]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.125]                 ...future.rng), started = ...future.startTime, 
[13:23:05.125]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.125]             version = "1.8"), class = "FutureResult")
[13:23:05.125]     }, finally = {
[13:23:05.125]         if (!identical(...future.workdir, getwd())) 
[13:23:05.125]             setwd(...future.workdir)
[13:23:05.125]         {
[13:23:05.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.125]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.125]             }
[13:23:05.125]             base::options(...future.oldOptions)
[13:23:05.125]             if (.Platform$OS.type == "windows") {
[13:23:05.125]                 old_names <- names(...future.oldEnvVars)
[13:23:05.125]                 envs <- base::Sys.getenv()
[13:23:05.125]                 names <- names(envs)
[13:23:05.125]                 common <- intersect(names, old_names)
[13:23:05.125]                 added <- setdiff(names, old_names)
[13:23:05.125]                 removed <- setdiff(old_names, names)
[13:23:05.125]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.125]                   envs[common]]
[13:23:05.125]                 NAMES <- toupper(changed)
[13:23:05.125]                 args <- list()
[13:23:05.125]                 for (kk in seq_along(NAMES)) {
[13:23:05.125]                   name <- changed[[kk]]
[13:23:05.125]                   NAME <- NAMES[[kk]]
[13:23:05.125]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.125]                     next
[13:23:05.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.125]                 }
[13:23:05.125]                 NAMES <- toupper(added)
[13:23:05.125]                 for (kk in seq_along(NAMES)) {
[13:23:05.125]                   name <- added[[kk]]
[13:23:05.125]                   NAME <- NAMES[[kk]]
[13:23:05.125]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.125]                     next
[13:23:05.125]                   args[[name]] <- ""
[13:23:05.125]                 }
[13:23:05.125]                 NAMES <- toupper(removed)
[13:23:05.125]                 for (kk in seq_along(NAMES)) {
[13:23:05.125]                   name <- removed[[kk]]
[13:23:05.125]                   NAME <- NAMES[[kk]]
[13:23:05.125]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.125]                     next
[13:23:05.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.125]                 }
[13:23:05.125]                 if (length(args) > 0) 
[13:23:05.125]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.125]             }
[13:23:05.125]             else {
[13:23:05.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.125]             }
[13:23:05.125]             {
[13:23:05.125]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.125]                   0L) {
[13:23:05.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.125]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.125]                   base::options(opts)
[13:23:05.125]                 }
[13:23:05.125]                 {
[13:23:05.125]                   {
[13:23:05.125]                     NULL
[13:23:05.125]                     RNGkind("Mersenne-Twister")
[13:23:05.125]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.125]                       inherits = FALSE)
[13:23:05.125]                   }
[13:23:05.125]                   options(future.plan = NULL)
[13:23:05.125]                   if (is.na(NA_character_)) 
[13:23:05.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.125]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.125]                   {
[13:23:05.125]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.125]                     if (!future$lazy) 
[13:23:05.125]                       future <- run(future)
[13:23:05.125]                     invisible(future)
[13:23:05.125]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.125]                 }
[13:23:05.125]             }
[13:23:05.125]         }
[13:23:05.125]     })
[13:23:05.125]     if (TRUE) {
[13:23:05.125]         base::sink(type = "output", split = FALSE)
[13:23:05.125]         if (TRUE) {
[13:23:05.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.125]         }
[13:23:05.125]         else {
[13:23:05.125]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.125]         }
[13:23:05.125]         base::close(...future.stdout)
[13:23:05.125]         ...future.stdout <- NULL
[13:23:05.125]     }
[13:23:05.125]     ...future.result$conditions <- ...future.conditions
[13:23:05.125]     ...future.result$finished <- base::Sys.time()
[13:23:05.125]     ...future.result
[13:23:05.125] }
[13:23:05.126] plan(): Setting new future strategy stack:
[13:23:05.127] List of future strategies:
[13:23:05.127] 1. sequential:
[13:23:05.127]    - args: function (..., envir = parent.frame())
[13:23:05.127]    - tweaked: FALSE
[13:23:05.127]    - call: NULL
[13:23:05.127] plan(): nbrOfWorkers() = 1
[13:23:05.128] plan(): Setting new future strategy stack:
[13:23:05.128] List of future strategies:
[13:23:05.128] 1. sequential:
[13:23:05.128]    - args: function (..., envir = parent.frame())
[13:23:05.128]    - tweaked: FALSE
[13:23:05.128]    - call: plan(strategy)
[13:23:05.128] plan(): nbrOfWorkers() = 1
[13:23:05.129] SequentialFuture started (and completed)
[13:23:05.129] - Launch lazy future ... done
[13:23:05.129] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d3d0aa08> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d51a5ff0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d3d0aa08> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d51a5ff0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:23:05.134] resolved() for ‘SequentialFuture’ ...
[13:23:05.134] - state: ‘finished’
[13:23:05.135] - run: TRUE
[13:23:05.135] - result: ‘FutureResult’
[13:23:05.135] resolved() for ‘SequentialFuture’ ... done
[13:23:05.135] resolved() for ‘SequentialFuture’ ...
[13:23:05.135] - state: ‘finished’
[13:23:05.135] - run: TRUE
[13:23:05.135] - result: ‘FutureResult’
[13:23:05.135] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:05.137] resolve() on list ...
[13:23:05.137]  recursive: 0
[13:23:05.137]  length: 6
[13:23:05.137]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:05.138] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.138] - nx: 6
[13:23:05.138] - relay: TRUE
[13:23:05.138] - stdout: TRUE
[13:23:05.138] - signal: TRUE
[13:23:05.138] - resignal: FALSE
[13:23:05.138] - force: TRUE
[13:23:05.138] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.138] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.138]  - until=2
[13:23:05.138]  - relaying element #2
[13:23:05.139] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.139] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.139] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.139]  length: 5 (resolved future 1)
[13:23:05.139] resolved() for ‘SequentialFuture’ ...
[13:23:05.139] - state: ‘finished’
[13:23:05.139] - run: TRUE
[13:23:05.139] - result: ‘FutureResult’
[13:23:05.139] resolved() for ‘SequentialFuture’ ... done
[13:23:05.139] Future #2
[13:23:05.142] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.142] - nx: 6
[13:23:05.142] - relay: TRUE
[13:23:05.142] - stdout: TRUE
[13:23:05.142] - signal: TRUE
[13:23:05.142] - resignal: FALSE
[13:23:05.142] - force: TRUE
[13:23:05.142] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.142] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.142]  - until=2
[13:23:05.142]  - relaying element #2
[13:23:05.143] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.143] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.143] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.143]  length: 4 (resolved future 2)
[13:23:05.143] resolved() for ‘SequentialFuture’ ...
[13:23:05.143] - state: ‘finished’
[13:23:05.143] - run: TRUE
[13:23:05.143] - result: ‘FutureResult’
[13:23:05.143] resolved() for ‘SequentialFuture’ ... done
[13:23:05.144] Future #3
[13:23:05.144] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.144] - nx: 6
[13:23:05.144] - relay: TRUE
[13:23:05.144] - stdout: TRUE
[13:23:05.144] - signal: TRUE
[13:23:05.144] - resignal: FALSE
[13:23:05.144] - force: TRUE
[13:23:05.144] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.144] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.145]  - until=3
[13:23:05.145]  - relaying element #3
[13:23:05.145] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.145] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.145] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.145]  length: 3 (resolved future 3)
[13:23:05.145] signalConditionsASAP(NULL, pos=4) ...
[13:23:05.145] - nx: 6
[13:23:05.145] - relay: TRUE
[13:23:05.146] - stdout: TRUE
[13:23:05.146] - signal: TRUE
[13:23:05.146] - resignal: FALSE
[13:23:05.146] - force: TRUE
[13:23:05.146] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.146] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.146]  - until=5
[13:23:05.146]  - relaying element #5
[13:23:05.146] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.146] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.146] signalConditionsASAP(NULL, pos=4) ... done
[13:23:05.146]  length: 2 (resolved future 4)
[13:23:05.147] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.147] - nx: 6
[13:23:05.147] - relay: TRUE
[13:23:05.147] - stdout: TRUE
[13:23:05.147] - signal: TRUE
[13:23:05.147] - resignal: FALSE
[13:23:05.147] - force: TRUE
[13:23:05.147] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.147] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.147]  - until=6
[13:23:05.147]  - relaying element #6
[13:23:05.148] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.148] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.148] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.148]  length: 1 (resolved future 5)
[13:23:05.148] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.148] - nx: 6
[13:23:05.148] - relay: TRUE
[13:23:05.148] - stdout: TRUE
[13:23:05.148] - signal: TRUE
[13:23:05.148] - resignal: FALSE
[13:23:05.148] - force: TRUE
[13:23:05.149] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.149] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.149]  - until=6
[13:23:05.149] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.149] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.149] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.149]  length: 0 (resolved future 6)
[13:23:05.149] Relaying remaining futures
[13:23:05.149] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.149] - nx: 6
[13:23:05.149] - relay: TRUE
[13:23:05.149] - stdout: TRUE
[13:23:05.150] - signal: TRUE
[13:23:05.150] - resignal: FALSE
[13:23:05.150] - force: TRUE
[13:23:05.150] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.150] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:05.150] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.150] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.150] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.150] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:23:05.154] getGlobalsAndPackages() ...
[13:23:05.154] Searching for globals...
[13:23:05.155] 
[13:23:05.155] Searching for globals ... DONE
[13:23:05.155] - globals: [0] <none>
[13:23:05.155] getGlobalsAndPackages() ... DONE
[13:23:05.155] run() for ‘Future’ ...
[13:23:05.155] - state: ‘created’
[13:23:05.155] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.156] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.156]   - Field: ‘label’
[13:23:05.156]   - Field: ‘local’
[13:23:05.156]   - Field: ‘owner’
[13:23:05.156]   - Field: ‘envir’
[13:23:05.156]   - Field: ‘packages’
[13:23:05.156]   - Field: ‘gc’
[13:23:05.157]   - Field: ‘conditions’
[13:23:05.157]   - Field: ‘expr’
[13:23:05.157]   - Field: ‘uuid’
[13:23:05.157]   - Field: ‘seed’
[13:23:05.157]   - Field: ‘version’
[13:23:05.157]   - Field: ‘result’
[13:23:05.157]   - Field: ‘asynchronous’
[13:23:05.157]   - Field: ‘calls’
[13:23:05.157]   - Field: ‘globals’
[13:23:05.157]   - Field: ‘stdout’
[13:23:05.158]   - Field: ‘earlySignal’
[13:23:05.158]   - Field: ‘lazy’
[13:23:05.158]   - Field: ‘state’
[13:23:05.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.158] - Launch lazy future ...
[13:23:05.158] Packages needed by the future expression (n = 0): <none>
[13:23:05.158] Packages needed by future strategies (n = 0): <none>
[13:23:05.159] {
[13:23:05.159]     {
[13:23:05.159]         {
[13:23:05.159]             ...future.startTime <- base::Sys.time()
[13:23:05.159]             {
[13:23:05.159]                 {
[13:23:05.159]                   {
[13:23:05.159]                     base::local({
[13:23:05.159]                       has_future <- base::requireNamespace("future", 
[13:23:05.159]                         quietly = TRUE)
[13:23:05.159]                       if (has_future) {
[13:23:05.159]                         ns <- base::getNamespace("future")
[13:23:05.159]                         version <- ns[[".package"]][["version"]]
[13:23:05.159]                         if (is.null(version)) 
[13:23:05.159]                           version <- utils::packageVersion("future")
[13:23:05.159]                       }
[13:23:05.159]                       else {
[13:23:05.159]                         version <- NULL
[13:23:05.159]                       }
[13:23:05.159]                       if (!has_future || version < "1.8.0") {
[13:23:05.159]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.159]                           "", base::R.version$version.string), 
[13:23:05.159]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.159]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.159]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.159]                             "release", "version")], collapse = " "), 
[13:23:05.159]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.159]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.159]                           info)
[13:23:05.159]                         info <- base::paste(info, collapse = "; ")
[13:23:05.159]                         if (!has_future) {
[13:23:05.159]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.159]                             info)
[13:23:05.159]                         }
[13:23:05.159]                         else {
[13:23:05.159]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.159]                             info, version)
[13:23:05.159]                         }
[13:23:05.159]                         base::stop(msg)
[13:23:05.159]                       }
[13:23:05.159]                     })
[13:23:05.159]                   }
[13:23:05.159]                   options(future.plan = NULL)
[13:23:05.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.159]                 }
[13:23:05.159]                 ...future.workdir <- getwd()
[13:23:05.159]             }
[13:23:05.159]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.159]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.159]         }
[13:23:05.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.159]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.159]             base::names(...future.oldOptions))
[13:23:05.159]     }
[13:23:05.159]     if (FALSE) {
[13:23:05.159]     }
[13:23:05.159]     else {
[13:23:05.159]         if (TRUE) {
[13:23:05.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.159]                 open = "w")
[13:23:05.159]         }
[13:23:05.159]         else {
[13:23:05.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.159]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.159]         }
[13:23:05.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.159]             base::sink(type = "output", split = FALSE)
[13:23:05.159]             base::close(...future.stdout)
[13:23:05.159]         }, add = TRUE)
[13:23:05.159]     }
[13:23:05.159]     ...future.frame <- base::sys.nframe()
[13:23:05.159]     ...future.conditions <- base::list()
[13:23:05.159]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.159]     if (FALSE) {
[13:23:05.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.159]     }
[13:23:05.159]     ...future.result <- base::tryCatch({
[13:23:05.159]         base::withCallingHandlers({
[13:23:05.159]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.159]             future::FutureResult(value = ...future.value$value, 
[13:23:05.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.159]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.159]                     ...future.globalenv.names))
[13:23:05.159]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.159]         }, condition = base::local({
[13:23:05.159]             c <- base::c
[13:23:05.159]             inherits <- base::inherits
[13:23:05.159]             invokeRestart <- base::invokeRestart
[13:23:05.159]             length <- base::length
[13:23:05.159]             list <- base::list
[13:23:05.159]             seq.int <- base::seq.int
[13:23:05.159]             signalCondition <- base::signalCondition
[13:23:05.159]             sys.calls <- base::sys.calls
[13:23:05.159]             `[[` <- base::`[[`
[13:23:05.159]             `+` <- base::`+`
[13:23:05.159]             `<<-` <- base::`<<-`
[13:23:05.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.159]                   3L)]
[13:23:05.159]             }
[13:23:05.159]             function(cond) {
[13:23:05.159]                 is_error <- inherits(cond, "error")
[13:23:05.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.159]                   NULL)
[13:23:05.159]                 if (is_error) {
[13:23:05.159]                   sessionInformation <- function() {
[13:23:05.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.159]                       search = base::search(), system = base::Sys.info())
[13:23:05.159]                   }
[13:23:05.159]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.159]                     cond$call), session = sessionInformation(), 
[13:23:05.159]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.159]                   signalCondition(cond)
[13:23:05.159]                 }
[13:23:05.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.159]                 "immediateCondition"))) {
[13:23:05.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.159]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.159]                   if (TRUE && !signal) {
[13:23:05.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.159]                     {
[13:23:05.159]                       inherits <- base::inherits
[13:23:05.159]                       invokeRestart <- base::invokeRestart
[13:23:05.159]                       is.null <- base::is.null
[13:23:05.159]                       muffled <- FALSE
[13:23:05.159]                       if (inherits(cond, "message")) {
[13:23:05.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.159]                         if (muffled) 
[13:23:05.159]                           invokeRestart("muffleMessage")
[13:23:05.159]                       }
[13:23:05.159]                       else if (inherits(cond, "warning")) {
[13:23:05.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.159]                         if (muffled) 
[13:23:05.159]                           invokeRestart("muffleWarning")
[13:23:05.159]                       }
[13:23:05.159]                       else if (inherits(cond, "condition")) {
[13:23:05.159]                         if (!is.null(pattern)) {
[13:23:05.159]                           computeRestarts <- base::computeRestarts
[13:23:05.159]                           grepl <- base::grepl
[13:23:05.159]                           restarts <- computeRestarts(cond)
[13:23:05.159]                           for (restart in restarts) {
[13:23:05.159]                             name <- restart$name
[13:23:05.159]                             if (is.null(name)) 
[13:23:05.159]                               next
[13:23:05.159]                             if (!grepl(pattern, name)) 
[13:23:05.159]                               next
[13:23:05.159]                             invokeRestart(restart)
[13:23:05.159]                             muffled <- TRUE
[13:23:05.159]                             break
[13:23:05.159]                           }
[13:23:05.159]                         }
[13:23:05.159]                       }
[13:23:05.159]                       invisible(muffled)
[13:23:05.159]                     }
[13:23:05.159]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.159]                   }
[13:23:05.159]                 }
[13:23:05.159]                 else {
[13:23:05.159]                   if (TRUE) {
[13:23:05.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.159]                     {
[13:23:05.159]                       inherits <- base::inherits
[13:23:05.159]                       invokeRestart <- base::invokeRestart
[13:23:05.159]                       is.null <- base::is.null
[13:23:05.159]                       muffled <- FALSE
[13:23:05.159]                       if (inherits(cond, "message")) {
[13:23:05.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.159]                         if (muffled) 
[13:23:05.159]                           invokeRestart("muffleMessage")
[13:23:05.159]                       }
[13:23:05.159]                       else if (inherits(cond, "warning")) {
[13:23:05.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.159]                         if (muffled) 
[13:23:05.159]                           invokeRestart("muffleWarning")
[13:23:05.159]                       }
[13:23:05.159]                       else if (inherits(cond, "condition")) {
[13:23:05.159]                         if (!is.null(pattern)) {
[13:23:05.159]                           computeRestarts <- base::computeRestarts
[13:23:05.159]                           grepl <- base::grepl
[13:23:05.159]                           restarts <- computeRestarts(cond)
[13:23:05.159]                           for (restart in restarts) {
[13:23:05.159]                             name <- restart$name
[13:23:05.159]                             if (is.null(name)) 
[13:23:05.159]                               next
[13:23:05.159]                             if (!grepl(pattern, name)) 
[13:23:05.159]                               next
[13:23:05.159]                             invokeRestart(restart)
[13:23:05.159]                             muffled <- TRUE
[13:23:05.159]                             break
[13:23:05.159]                           }
[13:23:05.159]                         }
[13:23:05.159]                       }
[13:23:05.159]                       invisible(muffled)
[13:23:05.159]                     }
[13:23:05.159]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.159]                   }
[13:23:05.159]                 }
[13:23:05.159]             }
[13:23:05.159]         }))
[13:23:05.159]     }, error = function(ex) {
[13:23:05.159]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.159]                 ...future.rng), started = ...future.startTime, 
[13:23:05.159]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.159]             version = "1.8"), class = "FutureResult")
[13:23:05.159]     }, finally = {
[13:23:05.159]         if (!identical(...future.workdir, getwd())) 
[13:23:05.159]             setwd(...future.workdir)
[13:23:05.159]         {
[13:23:05.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.159]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.159]             }
[13:23:05.159]             base::options(...future.oldOptions)
[13:23:05.159]             if (.Platform$OS.type == "windows") {
[13:23:05.159]                 old_names <- names(...future.oldEnvVars)
[13:23:05.159]                 envs <- base::Sys.getenv()
[13:23:05.159]                 names <- names(envs)
[13:23:05.159]                 common <- intersect(names, old_names)
[13:23:05.159]                 added <- setdiff(names, old_names)
[13:23:05.159]                 removed <- setdiff(old_names, names)
[13:23:05.159]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.159]                   envs[common]]
[13:23:05.159]                 NAMES <- toupper(changed)
[13:23:05.159]                 args <- list()
[13:23:05.159]                 for (kk in seq_along(NAMES)) {
[13:23:05.159]                   name <- changed[[kk]]
[13:23:05.159]                   NAME <- NAMES[[kk]]
[13:23:05.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.159]                     next
[13:23:05.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.159]                 }
[13:23:05.159]                 NAMES <- toupper(added)
[13:23:05.159]                 for (kk in seq_along(NAMES)) {
[13:23:05.159]                   name <- added[[kk]]
[13:23:05.159]                   NAME <- NAMES[[kk]]
[13:23:05.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.159]                     next
[13:23:05.159]                   args[[name]] <- ""
[13:23:05.159]                 }
[13:23:05.159]                 NAMES <- toupper(removed)
[13:23:05.159]                 for (kk in seq_along(NAMES)) {
[13:23:05.159]                   name <- removed[[kk]]
[13:23:05.159]                   NAME <- NAMES[[kk]]
[13:23:05.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.159]                     next
[13:23:05.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.159]                 }
[13:23:05.159]                 if (length(args) > 0) 
[13:23:05.159]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.159]             }
[13:23:05.159]             else {
[13:23:05.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.159]             }
[13:23:05.159]             {
[13:23:05.159]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.159]                   0L) {
[13:23:05.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.159]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.159]                   base::options(opts)
[13:23:05.159]                 }
[13:23:05.159]                 {
[13:23:05.159]                   {
[13:23:05.159]                     NULL
[13:23:05.159]                     RNGkind("Mersenne-Twister")
[13:23:05.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.159]                       inherits = FALSE)
[13:23:05.159]                   }
[13:23:05.159]                   options(future.plan = NULL)
[13:23:05.159]                   if (is.na(NA_character_)) 
[13:23:05.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.159]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.159]                   {
[13:23:05.159]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.159]                     if (!future$lazy) 
[13:23:05.159]                       future <- run(future)
[13:23:05.159]                     invisible(future)
[13:23:05.159]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.159]                 }
[13:23:05.159]             }
[13:23:05.159]         }
[13:23:05.159]     })
[13:23:05.159]     if (TRUE) {
[13:23:05.159]         base::sink(type = "output", split = FALSE)
[13:23:05.159]         if (TRUE) {
[13:23:05.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.159]         }
[13:23:05.159]         else {
[13:23:05.159]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.159]         }
[13:23:05.159]         base::close(...future.stdout)
[13:23:05.159]         ...future.stdout <- NULL
[13:23:05.159]     }
[13:23:05.159]     ...future.result$conditions <- ...future.conditions
[13:23:05.159]     ...future.result$finished <- base::Sys.time()
[13:23:05.159]     ...future.result
[13:23:05.159] }
[13:23:05.161] plan(): Setting new future strategy stack:
[13:23:05.161] List of future strategies:
[13:23:05.161] 1. sequential:
[13:23:05.161]    - args: function (..., envir = parent.frame())
[13:23:05.161]    - tweaked: FALSE
[13:23:05.161]    - call: NULL
[13:23:05.161] plan(): nbrOfWorkers() = 1
[13:23:05.162] plan(): Setting new future strategy stack:
[13:23:05.162] List of future strategies:
[13:23:05.162] 1. sequential:
[13:23:05.162]    - args: function (..., envir = parent.frame())
[13:23:05.162]    - tweaked: FALSE
[13:23:05.162]    - call: plan(strategy)
[13:23:05.163] plan(): nbrOfWorkers() = 1
[13:23:05.163] SequentialFuture started (and completed)
[13:23:05.163] - Launch lazy future ... done
[13:23:05.163] run() for ‘SequentialFuture’ ... done
[13:23:05.163] getGlobalsAndPackages() ...
[13:23:05.163] Searching for globals...
[13:23:05.164] 
[13:23:05.164] Searching for globals ... DONE
[13:23:05.164] - globals: [0] <none>
[13:23:05.164] getGlobalsAndPackages() ... DONE
[13:23:05.164] run() for ‘Future’ ...
[13:23:05.164] - state: ‘created’
[13:23:05.164] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.165] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.165] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.165]   - Field: ‘label’
[13:23:05.165]   - Field: ‘local’
[13:23:05.165]   - Field: ‘owner’
[13:23:05.165]   - Field: ‘envir’
[13:23:05.165]   - Field: ‘packages’
[13:23:05.165]   - Field: ‘gc’
[13:23:05.166]   - Field: ‘conditions’
[13:23:05.166]   - Field: ‘expr’
[13:23:05.166]   - Field: ‘uuid’
[13:23:05.166]   - Field: ‘seed’
[13:23:05.166]   - Field: ‘version’
[13:23:05.166]   - Field: ‘result’
[13:23:05.166]   - Field: ‘asynchronous’
[13:23:05.166]   - Field: ‘calls’
[13:23:05.166]   - Field: ‘globals’
[13:23:05.166]   - Field: ‘stdout’
[13:23:05.166]   - Field: ‘earlySignal’
[13:23:05.167]   - Field: ‘lazy’
[13:23:05.167]   - Field: ‘state’
[13:23:05.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.167] - Launch lazy future ...
[13:23:05.167] Packages needed by the future expression (n = 0): <none>
[13:23:05.167] Packages needed by future strategies (n = 0): <none>
[13:23:05.168] {
[13:23:05.168]     {
[13:23:05.168]         {
[13:23:05.168]             ...future.startTime <- base::Sys.time()
[13:23:05.168]             {
[13:23:05.168]                 {
[13:23:05.168]                   {
[13:23:05.168]                     base::local({
[13:23:05.168]                       has_future <- base::requireNamespace("future", 
[13:23:05.168]                         quietly = TRUE)
[13:23:05.168]                       if (has_future) {
[13:23:05.168]                         ns <- base::getNamespace("future")
[13:23:05.168]                         version <- ns[[".package"]][["version"]]
[13:23:05.168]                         if (is.null(version)) 
[13:23:05.168]                           version <- utils::packageVersion("future")
[13:23:05.168]                       }
[13:23:05.168]                       else {
[13:23:05.168]                         version <- NULL
[13:23:05.168]                       }
[13:23:05.168]                       if (!has_future || version < "1.8.0") {
[13:23:05.168]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.168]                           "", base::R.version$version.string), 
[13:23:05.168]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.168]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.168]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.168]                             "release", "version")], collapse = " "), 
[13:23:05.168]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.168]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.168]                           info)
[13:23:05.168]                         info <- base::paste(info, collapse = "; ")
[13:23:05.168]                         if (!has_future) {
[13:23:05.168]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.168]                             info)
[13:23:05.168]                         }
[13:23:05.168]                         else {
[13:23:05.168]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.168]                             info, version)
[13:23:05.168]                         }
[13:23:05.168]                         base::stop(msg)
[13:23:05.168]                       }
[13:23:05.168]                     })
[13:23:05.168]                   }
[13:23:05.168]                   options(future.plan = NULL)
[13:23:05.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.168]                 }
[13:23:05.168]                 ...future.workdir <- getwd()
[13:23:05.168]             }
[13:23:05.168]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.168]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.168]         }
[13:23:05.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.168]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.168]             base::names(...future.oldOptions))
[13:23:05.168]     }
[13:23:05.168]     if (FALSE) {
[13:23:05.168]     }
[13:23:05.168]     else {
[13:23:05.168]         if (TRUE) {
[13:23:05.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.168]                 open = "w")
[13:23:05.168]         }
[13:23:05.168]         else {
[13:23:05.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.168]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.168]         }
[13:23:05.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.168]             base::sink(type = "output", split = FALSE)
[13:23:05.168]             base::close(...future.stdout)
[13:23:05.168]         }, add = TRUE)
[13:23:05.168]     }
[13:23:05.168]     ...future.frame <- base::sys.nframe()
[13:23:05.168]     ...future.conditions <- base::list()
[13:23:05.168]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.168]     if (FALSE) {
[13:23:05.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.168]     }
[13:23:05.168]     ...future.result <- base::tryCatch({
[13:23:05.168]         base::withCallingHandlers({
[13:23:05.168]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.168]             future::FutureResult(value = ...future.value$value, 
[13:23:05.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.168]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.168]                     ...future.globalenv.names))
[13:23:05.168]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.168]         }, condition = base::local({
[13:23:05.168]             c <- base::c
[13:23:05.168]             inherits <- base::inherits
[13:23:05.168]             invokeRestart <- base::invokeRestart
[13:23:05.168]             length <- base::length
[13:23:05.168]             list <- base::list
[13:23:05.168]             seq.int <- base::seq.int
[13:23:05.168]             signalCondition <- base::signalCondition
[13:23:05.168]             sys.calls <- base::sys.calls
[13:23:05.168]             `[[` <- base::`[[`
[13:23:05.168]             `+` <- base::`+`
[13:23:05.168]             `<<-` <- base::`<<-`
[13:23:05.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.168]                   3L)]
[13:23:05.168]             }
[13:23:05.168]             function(cond) {
[13:23:05.168]                 is_error <- inherits(cond, "error")
[13:23:05.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.168]                   NULL)
[13:23:05.168]                 if (is_error) {
[13:23:05.168]                   sessionInformation <- function() {
[13:23:05.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.168]                       search = base::search(), system = base::Sys.info())
[13:23:05.168]                   }
[13:23:05.168]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.168]                     cond$call), session = sessionInformation(), 
[13:23:05.168]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.168]                   signalCondition(cond)
[13:23:05.168]                 }
[13:23:05.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.168]                 "immediateCondition"))) {
[13:23:05.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.168]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.168]                   if (TRUE && !signal) {
[13:23:05.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.168]                     {
[13:23:05.168]                       inherits <- base::inherits
[13:23:05.168]                       invokeRestart <- base::invokeRestart
[13:23:05.168]                       is.null <- base::is.null
[13:23:05.168]                       muffled <- FALSE
[13:23:05.168]                       if (inherits(cond, "message")) {
[13:23:05.168]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.168]                         if (muffled) 
[13:23:05.168]                           invokeRestart("muffleMessage")
[13:23:05.168]                       }
[13:23:05.168]                       else if (inherits(cond, "warning")) {
[13:23:05.168]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.168]                         if (muffled) 
[13:23:05.168]                           invokeRestart("muffleWarning")
[13:23:05.168]                       }
[13:23:05.168]                       else if (inherits(cond, "condition")) {
[13:23:05.168]                         if (!is.null(pattern)) {
[13:23:05.168]                           computeRestarts <- base::computeRestarts
[13:23:05.168]                           grepl <- base::grepl
[13:23:05.168]                           restarts <- computeRestarts(cond)
[13:23:05.168]                           for (restart in restarts) {
[13:23:05.168]                             name <- restart$name
[13:23:05.168]                             if (is.null(name)) 
[13:23:05.168]                               next
[13:23:05.168]                             if (!grepl(pattern, name)) 
[13:23:05.168]                               next
[13:23:05.168]                             invokeRestart(restart)
[13:23:05.168]                             muffled <- TRUE
[13:23:05.168]                             break
[13:23:05.168]                           }
[13:23:05.168]                         }
[13:23:05.168]                       }
[13:23:05.168]                       invisible(muffled)
[13:23:05.168]                     }
[13:23:05.168]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.168]                   }
[13:23:05.168]                 }
[13:23:05.168]                 else {
[13:23:05.168]                   if (TRUE) {
[13:23:05.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.168]                     {
[13:23:05.168]                       inherits <- base::inherits
[13:23:05.168]                       invokeRestart <- base::invokeRestart
[13:23:05.168]                       is.null <- base::is.null
[13:23:05.168]                       muffled <- FALSE
[13:23:05.168]                       if (inherits(cond, "message")) {
[13:23:05.168]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.168]                         if (muffled) 
[13:23:05.168]                           invokeRestart("muffleMessage")
[13:23:05.168]                       }
[13:23:05.168]                       else if (inherits(cond, "warning")) {
[13:23:05.168]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.168]                         if (muffled) 
[13:23:05.168]                           invokeRestart("muffleWarning")
[13:23:05.168]                       }
[13:23:05.168]                       else if (inherits(cond, "condition")) {
[13:23:05.168]                         if (!is.null(pattern)) {
[13:23:05.168]                           computeRestarts <- base::computeRestarts
[13:23:05.168]                           grepl <- base::grepl
[13:23:05.168]                           restarts <- computeRestarts(cond)
[13:23:05.168]                           for (restart in restarts) {
[13:23:05.168]                             name <- restart$name
[13:23:05.168]                             if (is.null(name)) 
[13:23:05.168]                               next
[13:23:05.168]                             if (!grepl(pattern, name)) 
[13:23:05.168]                               next
[13:23:05.168]                             invokeRestart(restart)
[13:23:05.168]                             muffled <- TRUE
[13:23:05.168]                             break
[13:23:05.168]                           }
[13:23:05.168]                         }
[13:23:05.168]                       }
[13:23:05.168]                       invisible(muffled)
[13:23:05.168]                     }
[13:23:05.168]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.168]                   }
[13:23:05.168]                 }
[13:23:05.168]             }
[13:23:05.168]         }))
[13:23:05.168]     }, error = function(ex) {
[13:23:05.168]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.168]                 ...future.rng), started = ...future.startTime, 
[13:23:05.168]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.168]             version = "1.8"), class = "FutureResult")
[13:23:05.168]     }, finally = {
[13:23:05.168]         if (!identical(...future.workdir, getwd())) 
[13:23:05.168]             setwd(...future.workdir)
[13:23:05.168]         {
[13:23:05.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.168]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.168]             }
[13:23:05.168]             base::options(...future.oldOptions)
[13:23:05.168]             if (.Platform$OS.type == "windows") {
[13:23:05.168]                 old_names <- names(...future.oldEnvVars)
[13:23:05.168]                 envs <- base::Sys.getenv()
[13:23:05.168]                 names <- names(envs)
[13:23:05.168]                 common <- intersect(names, old_names)
[13:23:05.168]                 added <- setdiff(names, old_names)
[13:23:05.168]                 removed <- setdiff(old_names, names)
[13:23:05.168]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.168]                   envs[common]]
[13:23:05.168]                 NAMES <- toupper(changed)
[13:23:05.168]                 args <- list()
[13:23:05.168]                 for (kk in seq_along(NAMES)) {
[13:23:05.168]                   name <- changed[[kk]]
[13:23:05.168]                   NAME <- NAMES[[kk]]
[13:23:05.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.168]                     next
[13:23:05.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.168]                 }
[13:23:05.168]                 NAMES <- toupper(added)
[13:23:05.168]                 for (kk in seq_along(NAMES)) {
[13:23:05.168]                   name <- added[[kk]]
[13:23:05.168]                   NAME <- NAMES[[kk]]
[13:23:05.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.168]                     next
[13:23:05.168]                   args[[name]] <- ""
[13:23:05.168]                 }
[13:23:05.168]                 NAMES <- toupper(removed)
[13:23:05.168]                 for (kk in seq_along(NAMES)) {
[13:23:05.168]                   name <- removed[[kk]]
[13:23:05.168]                   NAME <- NAMES[[kk]]
[13:23:05.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.168]                     next
[13:23:05.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.168]                 }
[13:23:05.168]                 if (length(args) > 0) 
[13:23:05.168]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.168]             }
[13:23:05.168]             else {
[13:23:05.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.168]             }
[13:23:05.168]             {
[13:23:05.168]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.168]                   0L) {
[13:23:05.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.168]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.168]                   base::options(opts)
[13:23:05.168]                 }
[13:23:05.168]                 {
[13:23:05.168]                   {
[13:23:05.168]                     NULL
[13:23:05.168]                     RNGkind("Mersenne-Twister")
[13:23:05.168]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.168]                       inherits = FALSE)
[13:23:05.168]                   }
[13:23:05.168]                   options(future.plan = NULL)
[13:23:05.168]                   if (is.na(NA_character_)) 
[13:23:05.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.168]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.168]                   {
[13:23:05.168]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.168]                     if (!future$lazy) 
[13:23:05.168]                       future <- run(future)
[13:23:05.168]                     invisible(future)
[13:23:05.168]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.168]                 }
[13:23:05.168]             }
[13:23:05.168]         }
[13:23:05.168]     })
[13:23:05.168]     if (TRUE) {
[13:23:05.168]         base::sink(type = "output", split = FALSE)
[13:23:05.168]         if (TRUE) {
[13:23:05.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.168]         }
[13:23:05.168]         else {
[13:23:05.168]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.168]         }
[13:23:05.168]         base::close(...future.stdout)
[13:23:05.168]         ...future.stdout <- NULL
[13:23:05.168]     }
[13:23:05.168]     ...future.result$conditions <- ...future.conditions
[13:23:05.168]     ...future.result$finished <- base::Sys.time()
[13:23:05.168]     ...future.result
[13:23:05.168] }
[13:23:05.169] plan(): Setting new future strategy stack:
[13:23:05.170] List of future strategies:
[13:23:05.170] 1. sequential:
[13:23:05.170]    - args: function (..., envir = parent.frame())
[13:23:05.170]    - tweaked: FALSE
[13:23:05.170]    - call: NULL
[13:23:05.170] plan(): nbrOfWorkers() = 1
[13:23:05.171] plan(): Setting new future strategy stack:
[13:23:05.171] List of future strategies:
[13:23:05.171] 1. sequential:
[13:23:05.171]    - args: function (..., envir = parent.frame())
[13:23:05.171]    - tweaked: FALSE
[13:23:05.171]    - call: plan(strategy)
[13:23:05.171] plan(): nbrOfWorkers() = 1
[13:23:05.173] SequentialFuture started (and completed)
[13:23:05.174] - Launch lazy future ... done
[13:23:05.174] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d5553538> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d5940f58> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d5553538> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5596d5940f58> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:23:05.179] resolved() for ‘SequentialFuture’ ...
[13:23:05.180] - state: ‘finished’
[13:23:05.180] - run: TRUE
[13:23:05.180] - result: ‘FutureResult’
[13:23:05.180] resolved() for ‘SequentialFuture’ ... done
[13:23:05.180] resolved() for ‘SequentialFuture’ ...
[13:23:05.180] - state: ‘finished’
[13:23:05.180] - run: TRUE
[13:23:05.180] - result: ‘FutureResult’
[13:23:05.180] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:05.182] resolve() on list ...
[13:23:05.183]  recursive: 0
[13:23:05.183]  length: 6
[13:23:05.183]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:05.183] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.183] - nx: 6
[13:23:05.183] - relay: TRUE
[13:23:05.183] - stdout: TRUE
[13:23:05.183] - signal: TRUE
[13:23:05.183] - resignal: FALSE
[13:23:05.183] - force: TRUE
[13:23:05.183] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.184] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.184]  - until=2
[13:23:05.184]  - relaying element #2
[13:23:05.184] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.184] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.184] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.184]  length: 5 (resolved future 1)
[13:23:05.184] resolved() for ‘SequentialFuture’ ...
[13:23:05.184] - state: ‘finished’
[13:23:05.184] - run: TRUE
[13:23:05.185] - result: ‘FutureResult’
[13:23:05.185] resolved() for ‘SequentialFuture’ ... done
[13:23:05.185] Future #2
[13:23:05.185] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.185] - nx: 6
[13:23:05.185] - relay: TRUE
[13:23:05.185] - stdout: TRUE
[13:23:05.185] - signal: TRUE
[13:23:05.185] - resignal: FALSE
[13:23:05.185] - force: TRUE
[13:23:05.186] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.186] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.186]  - until=2
[13:23:05.186]  - relaying element #2
[13:23:05.186] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.186] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.186] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.186]  length: 4 (resolved future 2)
[13:23:05.186] resolved() for ‘SequentialFuture’ ...
[13:23:05.187] - state: ‘finished’
[13:23:05.187] - run: TRUE
[13:23:05.187] - result: ‘FutureResult’
[13:23:05.187] resolved() for ‘SequentialFuture’ ... done
[13:23:05.187] Future #3
[13:23:05.187] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.187] - nx: 6
[13:23:05.187] - relay: TRUE
[13:23:05.187] - stdout: TRUE
[13:23:05.187] - signal: TRUE
[13:23:05.187] - resignal: FALSE
[13:23:05.188] - force: TRUE
[13:23:05.188] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.188] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.188]  - until=3
[13:23:05.188]  - relaying element #3
[13:23:05.188] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.188] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.188] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.188]  length: 3 (resolved future 3)
[13:23:05.189] signalConditionsASAP(NULL, pos=4) ...
[13:23:05.189] - nx: 6
[13:23:05.189] - relay: TRUE
[13:23:05.189] - stdout: TRUE
[13:23:05.189] - signal: TRUE
[13:23:05.189] - resignal: FALSE
[13:23:05.189] - force: TRUE
[13:23:05.189] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.189] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.189]  - until=5
[13:23:05.190]  - relaying element #5
[13:23:05.190] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.190] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.190] signalConditionsASAP(NULL, pos=4) ... done
[13:23:05.190]  length: 2 (resolved future 4)
[13:23:05.190] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.190] - nx: 6
[13:23:05.190] - relay: TRUE
[13:23:05.190] - stdout: TRUE
[13:23:05.190] - signal: TRUE
[13:23:05.190] - resignal: FALSE
[13:23:05.190] - force: TRUE
[13:23:05.191] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.191] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.191]  - until=6
[13:23:05.191]  - relaying element #6
[13:23:05.191] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.191] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.191] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.191]  length: 1 (resolved future 5)
[13:23:05.191] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.191] - nx: 6
[13:23:05.191] - relay: TRUE
[13:23:05.192] - stdout: TRUE
[13:23:05.192] - signal: TRUE
[13:23:05.192] - resignal: FALSE
[13:23:05.192] - force: TRUE
[13:23:05.192] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.192] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.192]  - until=6
[13:23:05.192] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.192] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.192] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.192]  length: 0 (resolved future 6)
[13:23:05.193] Relaying remaining futures
[13:23:05.193] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.193] - nx: 6
[13:23:05.193] - relay: TRUE
[13:23:05.193] - stdout: TRUE
[13:23:05.193] - signal: TRUE
[13:23:05.193] - resignal: FALSE
[13:23:05.193] - force: TRUE
[13:23:05.193] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.193] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:05.193] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.194] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.194] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.194] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[13:23:05.205] plan(): Setting new future strategy stack:
[13:23:05.205] List of future strategies:
[13:23:05.205] 1. sequential:
[13:23:05.205]    - args: function (..., envir = parent.frame())
[13:23:05.205]    - tweaked: FALSE
[13:23:05.205]    - call: plan(strategy)
[13:23:05.206] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[13:23:05.206] getGlobalsAndPackages() ...
[13:23:05.206] Searching for globals...
[13:23:05.206] 
[13:23:05.206] Searching for globals ... DONE
[13:23:05.206] - globals: [0] <none>
[13:23:05.207] getGlobalsAndPackages() ... DONE
[13:23:05.207] run() for ‘Future’ ...
[13:23:05.207] - state: ‘created’
[13:23:05.207] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.207] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.207] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.208]   - Field: ‘label’
[13:23:05.208]   - Field: ‘local’
[13:23:05.208]   - Field: ‘owner’
[13:23:05.208]   - Field: ‘envir’
[13:23:05.208]   - Field: ‘packages’
[13:23:05.208]   - Field: ‘gc’
[13:23:05.208]   - Field: ‘conditions’
[13:23:05.208]   - Field: ‘expr’
[13:23:05.208]   - Field: ‘uuid’
[13:23:05.208]   - Field: ‘seed’
[13:23:05.209]   - Field: ‘version’
[13:23:05.209]   - Field: ‘result’
[13:23:05.209]   - Field: ‘asynchronous’
[13:23:05.209]   - Field: ‘calls’
[13:23:05.209]   - Field: ‘globals’
[13:23:05.209]   - Field: ‘stdout’
[13:23:05.209]   - Field: ‘earlySignal’
[13:23:05.209]   - Field: ‘lazy’
[13:23:05.209]   - Field: ‘state’
[13:23:05.209] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.209] - Launch lazy future ...
[13:23:05.210] Packages needed by the future expression (n = 0): <none>
[13:23:05.210] Packages needed by future strategies (n = 0): <none>
[13:23:05.210] {
[13:23:05.210]     {
[13:23:05.210]         {
[13:23:05.210]             ...future.startTime <- base::Sys.time()
[13:23:05.210]             {
[13:23:05.210]                 {
[13:23:05.210]                   {
[13:23:05.210]                     base::local({
[13:23:05.210]                       has_future <- base::requireNamespace("future", 
[13:23:05.210]                         quietly = TRUE)
[13:23:05.210]                       if (has_future) {
[13:23:05.210]                         ns <- base::getNamespace("future")
[13:23:05.210]                         version <- ns[[".package"]][["version"]]
[13:23:05.210]                         if (is.null(version)) 
[13:23:05.210]                           version <- utils::packageVersion("future")
[13:23:05.210]                       }
[13:23:05.210]                       else {
[13:23:05.210]                         version <- NULL
[13:23:05.210]                       }
[13:23:05.210]                       if (!has_future || version < "1.8.0") {
[13:23:05.210]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.210]                           "", base::R.version$version.string), 
[13:23:05.210]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.210]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.210]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.210]                             "release", "version")], collapse = " "), 
[13:23:05.210]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.210]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.210]                           info)
[13:23:05.210]                         info <- base::paste(info, collapse = "; ")
[13:23:05.210]                         if (!has_future) {
[13:23:05.210]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.210]                             info)
[13:23:05.210]                         }
[13:23:05.210]                         else {
[13:23:05.210]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.210]                             info, version)
[13:23:05.210]                         }
[13:23:05.210]                         base::stop(msg)
[13:23:05.210]                       }
[13:23:05.210]                     })
[13:23:05.210]                   }
[13:23:05.210]                   options(future.plan = NULL)
[13:23:05.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.210]                 }
[13:23:05.210]                 ...future.workdir <- getwd()
[13:23:05.210]             }
[13:23:05.210]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.210]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.210]         }
[13:23:05.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.210]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.210]             base::names(...future.oldOptions))
[13:23:05.210]     }
[13:23:05.210]     if (FALSE) {
[13:23:05.210]     }
[13:23:05.210]     else {
[13:23:05.210]         if (TRUE) {
[13:23:05.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.210]                 open = "w")
[13:23:05.210]         }
[13:23:05.210]         else {
[13:23:05.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.210]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.210]         }
[13:23:05.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.210]             base::sink(type = "output", split = FALSE)
[13:23:05.210]             base::close(...future.stdout)
[13:23:05.210]         }, add = TRUE)
[13:23:05.210]     }
[13:23:05.210]     ...future.frame <- base::sys.nframe()
[13:23:05.210]     ...future.conditions <- base::list()
[13:23:05.210]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.210]     if (FALSE) {
[13:23:05.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.210]     }
[13:23:05.210]     ...future.result <- base::tryCatch({
[13:23:05.210]         base::withCallingHandlers({
[13:23:05.210]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.210]             future::FutureResult(value = ...future.value$value, 
[13:23:05.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.210]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.210]                     ...future.globalenv.names))
[13:23:05.210]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.210]         }, condition = base::local({
[13:23:05.210]             c <- base::c
[13:23:05.210]             inherits <- base::inherits
[13:23:05.210]             invokeRestart <- base::invokeRestart
[13:23:05.210]             length <- base::length
[13:23:05.210]             list <- base::list
[13:23:05.210]             seq.int <- base::seq.int
[13:23:05.210]             signalCondition <- base::signalCondition
[13:23:05.210]             sys.calls <- base::sys.calls
[13:23:05.210]             `[[` <- base::`[[`
[13:23:05.210]             `+` <- base::`+`
[13:23:05.210]             `<<-` <- base::`<<-`
[13:23:05.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.210]                   3L)]
[13:23:05.210]             }
[13:23:05.210]             function(cond) {
[13:23:05.210]                 is_error <- inherits(cond, "error")
[13:23:05.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.210]                   NULL)
[13:23:05.210]                 if (is_error) {
[13:23:05.210]                   sessionInformation <- function() {
[13:23:05.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.210]                       search = base::search(), system = base::Sys.info())
[13:23:05.210]                   }
[13:23:05.210]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.210]                     cond$call), session = sessionInformation(), 
[13:23:05.210]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.210]                   signalCondition(cond)
[13:23:05.210]                 }
[13:23:05.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.210]                 "immediateCondition"))) {
[13:23:05.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.210]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.210]                   if (TRUE && !signal) {
[13:23:05.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.210]                     {
[13:23:05.210]                       inherits <- base::inherits
[13:23:05.210]                       invokeRestart <- base::invokeRestart
[13:23:05.210]                       is.null <- base::is.null
[13:23:05.210]                       muffled <- FALSE
[13:23:05.210]                       if (inherits(cond, "message")) {
[13:23:05.210]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.210]                         if (muffled) 
[13:23:05.210]                           invokeRestart("muffleMessage")
[13:23:05.210]                       }
[13:23:05.210]                       else if (inherits(cond, "warning")) {
[13:23:05.210]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.210]                         if (muffled) 
[13:23:05.210]                           invokeRestart("muffleWarning")
[13:23:05.210]                       }
[13:23:05.210]                       else if (inherits(cond, "condition")) {
[13:23:05.210]                         if (!is.null(pattern)) {
[13:23:05.210]                           computeRestarts <- base::computeRestarts
[13:23:05.210]                           grepl <- base::grepl
[13:23:05.210]                           restarts <- computeRestarts(cond)
[13:23:05.210]                           for (restart in restarts) {
[13:23:05.210]                             name <- restart$name
[13:23:05.210]                             if (is.null(name)) 
[13:23:05.210]                               next
[13:23:05.210]                             if (!grepl(pattern, name)) 
[13:23:05.210]                               next
[13:23:05.210]                             invokeRestart(restart)
[13:23:05.210]                             muffled <- TRUE
[13:23:05.210]                             break
[13:23:05.210]                           }
[13:23:05.210]                         }
[13:23:05.210]                       }
[13:23:05.210]                       invisible(muffled)
[13:23:05.210]                     }
[13:23:05.210]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.210]                   }
[13:23:05.210]                 }
[13:23:05.210]                 else {
[13:23:05.210]                   if (TRUE) {
[13:23:05.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.210]                     {
[13:23:05.210]                       inherits <- base::inherits
[13:23:05.210]                       invokeRestart <- base::invokeRestart
[13:23:05.210]                       is.null <- base::is.null
[13:23:05.210]                       muffled <- FALSE
[13:23:05.210]                       if (inherits(cond, "message")) {
[13:23:05.210]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.210]                         if (muffled) 
[13:23:05.210]                           invokeRestart("muffleMessage")
[13:23:05.210]                       }
[13:23:05.210]                       else if (inherits(cond, "warning")) {
[13:23:05.210]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.210]                         if (muffled) 
[13:23:05.210]                           invokeRestart("muffleWarning")
[13:23:05.210]                       }
[13:23:05.210]                       else if (inherits(cond, "condition")) {
[13:23:05.210]                         if (!is.null(pattern)) {
[13:23:05.210]                           computeRestarts <- base::computeRestarts
[13:23:05.210]                           grepl <- base::grepl
[13:23:05.210]                           restarts <- computeRestarts(cond)
[13:23:05.210]                           for (restart in restarts) {
[13:23:05.210]                             name <- restart$name
[13:23:05.210]                             if (is.null(name)) 
[13:23:05.210]                               next
[13:23:05.210]                             if (!grepl(pattern, name)) 
[13:23:05.210]                               next
[13:23:05.210]                             invokeRestart(restart)
[13:23:05.210]                             muffled <- TRUE
[13:23:05.210]                             break
[13:23:05.210]                           }
[13:23:05.210]                         }
[13:23:05.210]                       }
[13:23:05.210]                       invisible(muffled)
[13:23:05.210]                     }
[13:23:05.210]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.210]                   }
[13:23:05.210]                 }
[13:23:05.210]             }
[13:23:05.210]         }))
[13:23:05.210]     }, error = function(ex) {
[13:23:05.210]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.210]                 ...future.rng), started = ...future.startTime, 
[13:23:05.210]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.210]             version = "1.8"), class = "FutureResult")
[13:23:05.210]     }, finally = {
[13:23:05.210]         if (!identical(...future.workdir, getwd())) 
[13:23:05.210]             setwd(...future.workdir)
[13:23:05.210]         {
[13:23:05.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.210]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.210]             }
[13:23:05.210]             base::options(...future.oldOptions)
[13:23:05.210]             if (.Platform$OS.type == "windows") {
[13:23:05.210]                 old_names <- names(...future.oldEnvVars)
[13:23:05.210]                 envs <- base::Sys.getenv()
[13:23:05.210]                 names <- names(envs)
[13:23:05.210]                 common <- intersect(names, old_names)
[13:23:05.210]                 added <- setdiff(names, old_names)
[13:23:05.210]                 removed <- setdiff(old_names, names)
[13:23:05.210]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.210]                   envs[common]]
[13:23:05.210]                 NAMES <- toupper(changed)
[13:23:05.210]                 args <- list()
[13:23:05.210]                 for (kk in seq_along(NAMES)) {
[13:23:05.210]                   name <- changed[[kk]]
[13:23:05.210]                   NAME <- NAMES[[kk]]
[13:23:05.210]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.210]                     next
[13:23:05.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.210]                 }
[13:23:05.210]                 NAMES <- toupper(added)
[13:23:05.210]                 for (kk in seq_along(NAMES)) {
[13:23:05.210]                   name <- added[[kk]]
[13:23:05.210]                   NAME <- NAMES[[kk]]
[13:23:05.210]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.210]                     next
[13:23:05.210]                   args[[name]] <- ""
[13:23:05.210]                 }
[13:23:05.210]                 NAMES <- toupper(removed)
[13:23:05.210]                 for (kk in seq_along(NAMES)) {
[13:23:05.210]                   name <- removed[[kk]]
[13:23:05.210]                   NAME <- NAMES[[kk]]
[13:23:05.210]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.210]                     next
[13:23:05.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.210]                 }
[13:23:05.210]                 if (length(args) > 0) 
[13:23:05.210]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.210]             }
[13:23:05.210]             else {
[13:23:05.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.210]             }
[13:23:05.210]             {
[13:23:05.210]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.210]                   0L) {
[13:23:05.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.210]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.210]                   base::options(opts)
[13:23:05.210]                 }
[13:23:05.210]                 {
[13:23:05.210]                   {
[13:23:05.210]                     NULL
[13:23:05.210]                     RNGkind("Mersenne-Twister")
[13:23:05.210]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.210]                       inherits = FALSE)
[13:23:05.210]                   }
[13:23:05.210]                   options(future.plan = NULL)
[13:23:05.210]                   if (is.na(NA_character_)) 
[13:23:05.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.210]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.210]                   {
[13:23:05.210]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.210]                     if (!future$lazy) 
[13:23:05.210]                       future <- run(future)
[13:23:05.210]                     invisible(future)
[13:23:05.210]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.210]                 }
[13:23:05.210]             }
[13:23:05.210]         }
[13:23:05.210]     })
[13:23:05.210]     if (TRUE) {
[13:23:05.210]         base::sink(type = "output", split = FALSE)
[13:23:05.210]         if (TRUE) {
[13:23:05.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.210]         }
[13:23:05.210]         else {
[13:23:05.210]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.210]         }
[13:23:05.210]         base::close(...future.stdout)
[13:23:05.210]         ...future.stdout <- NULL
[13:23:05.210]     }
[13:23:05.210]     ...future.result$conditions <- ...future.conditions
[13:23:05.210]     ...future.result$finished <- base::Sys.time()
[13:23:05.210]     ...future.result
[13:23:05.210] }
[13:23:05.212] plan(): Setting new future strategy stack:
[13:23:05.212] List of future strategies:
[13:23:05.212] 1. sequential:
[13:23:05.212]    - args: function (..., envir = parent.frame())
[13:23:05.212]    - tweaked: FALSE
[13:23:05.212]    - call: NULL
[13:23:05.213] plan(): nbrOfWorkers() = 1
[13:23:05.213] plan(): Setting new future strategy stack:
[13:23:05.214] List of future strategies:
[13:23:05.214] 1. sequential:
[13:23:05.214]    - args: function (..., envir = parent.frame())
[13:23:05.214]    - tweaked: FALSE
[13:23:05.214]    - call: plan(strategy)
[13:23:05.214] plan(): nbrOfWorkers() = 1
[13:23:05.214] SequentialFuture started (and completed)
[13:23:05.214] - Launch lazy future ... done
[13:23:05.214] run() for ‘SequentialFuture’ ... done
[13:23:05.214] getGlobalsAndPackages() ...
[13:23:05.215] Searching for globals...
[13:23:05.215] 
[13:23:05.215] Searching for globals ... DONE
[13:23:05.215] - globals: [0] <none>
[13:23:05.215] getGlobalsAndPackages() ... DONE
[13:23:05.215] run() for ‘Future’ ...
[13:23:05.216] - state: ‘created’
[13:23:05.216] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.216] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.216]   - Field: ‘label’
[13:23:05.216]   - Field: ‘local’
[13:23:05.216]   - Field: ‘owner’
[13:23:05.217]   - Field: ‘envir’
[13:23:05.217]   - Field: ‘packages’
[13:23:05.217]   - Field: ‘gc’
[13:23:05.217]   - Field: ‘conditions’
[13:23:05.217]   - Field: ‘expr’
[13:23:05.217]   - Field: ‘uuid’
[13:23:05.217]   - Field: ‘seed’
[13:23:05.217]   - Field: ‘version’
[13:23:05.217]   - Field: ‘result’
[13:23:05.217]   - Field: ‘asynchronous’
[13:23:05.217]   - Field: ‘calls’
[13:23:05.218]   - Field: ‘globals’
[13:23:05.218]   - Field: ‘stdout’
[13:23:05.218]   - Field: ‘earlySignal’
[13:23:05.218]   - Field: ‘lazy’
[13:23:05.218]   - Field: ‘state’
[13:23:05.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.218] - Launch lazy future ...
[13:23:05.218] Packages needed by the future expression (n = 0): <none>
[13:23:05.218] Packages needed by future strategies (n = 0): <none>
[13:23:05.219] {
[13:23:05.219]     {
[13:23:05.219]         {
[13:23:05.219]             ...future.startTime <- base::Sys.time()
[13:23:05.219]             {
[13:23:05.219]                 {
[13:23:05.219]                   {
[13:23:05.219]                     base::local({
[13:23:05.219]                       has_future <- base::requireNamespace("future", 
[13:23:05.219]                         quietly = TRUE)
[13:23:05.219]                       if (has_future) {
[13:23:05.219]                         ns <- base::getNamespace("future")
[13:23:05.219]                         version <- ns[[".package"]][["version"]]
[13:23:05.219]                         if (is.null(version)) 
[13:23:05.219]                           version <- utils::packageVersion("future")
[13:23:05.219]                       }
[13:23:05.219]                       else {
[13:23:05.219]                         version <- NULL
[13:23:05.219]                       }
[13:23:05.219]                       if (!has_future || version < "1.8.0") {
[13:23:05.219]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.219]                           "", base::R.version$version.string), 
[13:23:05.219]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.219]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.219]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.219]                             "release", "version")], collapse = " "), 
[13:23:05.219]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.219]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.219]                           info)
[13:23:05.219]                         info <- base::paste(info, collapse = "; ")
[13:23:05.219]                         if (!has_future) {
[13:23:05.219]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.219]                             info)
[13:23:05.219]                         }
[13:23:05.219]                         else {
[13:23:05.219]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.219]                             info, version)
[13:23:05.219]                         }
[13:23:05.219]                         base::stop(msg)
[13:23:05.219]                       }
[13:23:05.219]                     })
[13:23:05.219]                   }
[13:23:05.219]                   options(future.plan = NULL)
[13:23:05.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.219]                 }
[13:23:05.219]                 ...future.workdir <- getwd()
[13:23:05.219]             }
[13:23:05.219]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.219]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.219]         }
[13:23:05.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.219]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.219]             base::names(...future.oldOptions))
[13:23:05.219]     }
[13:23:05.219]     if (FALSE) {
[13:23:05.219]     }
[13:23:05.219]     else {
[13:23:05.219]         if (TRUE) {
[13:23:05.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.219]                 open = "w")
[13:23:05.219]         }
[13:23:05.219]         else {
[13:23:05.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.219]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.219]         }
[13:23:05.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.219]             base::sink(type = "output", split = FALSE)
[13:23:05.219]             base::close(...future.stdout)
[13:23:05.219]         }, add = TRUE)
[13:23:05.219]     }
[13:23:05.219]     ...future.frame <- base::sys.nframe()
[13:23:05.219]     ...future.conditions <- base::list()
[13:23:05.219]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.219]     if (FALSE) {
[13:23:05.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.219]     }
[13:23:05.219]     ...future.result <- base::tryCatch({
[13:23:05.219]         base::withCallingHandlers({
[13:23:05.219]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.219]             future::FutureResult(value = ...future.value$value, 
[13:23:05.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.219]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.219]                     ...future.globalenv.names))
[13:23:05.219]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.219]         }, condition = base::local({
[13:23:05.219]             c <- base::c
[13:23:05.219]             inherits <- base::inherits
[13:23:05.219]             invokeRestart <- base::invokeRestart
[13:23:05.219]             length <- base::length
[13:23:05.219]             list <- base::list
[13:23:05.219]             seq.int <- base::seq.int
[13:23:05.219]             signalCondition <- base::signalCondition
[13:23:05.219]             sys.calls <- base::sys.calls
[13:23:05.219]             `[[` <- base::`[[`
[13:23:05.219]             `+` <- base::`+`
[13:23:05.219]             `<<-` <- base::`<<-`
[13:23:05.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.219]                   3L)]
[13:23:05.219]             }
[13:23:05.219]             function(cond) {
[13:23:05.219]                 is_error <- inherits(cond, "error")
[13:23:05.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.219]                   NULL)
[13:23:05.219]                 if (is_error) {
[13:23:05.219]                   sessionInformation <- function() {
[13:23:05.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.219]                       search = base::search(), system = base::Sys.info())
[13:23:05.219]                   }
[13:23:05.219]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.219]                     cond$call), session = sessionInformation(), 
[13:23:05.219]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.219]                   signalCondition(cond)
[13:23:05.219]                 }
[13:23:05.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.219]                 "immediateCondition"))) {
[13:23:05.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.219]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.219]                   if (TRUE && !signal) {
[13:23:05.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.219]                     {
[13:23:05.219]                       inherits <- base::inherits
[13:23:05.219]                       invokeRestart <- base::invokeRestart
[13:23:05.219]                       is.null <- base::is.null
[13:23:05.219]                       muffled <- FALSE
[13:23:05.219]                       if (inherits(cond, "message")) {
[13:23:05.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.219]                         if (muffled) 
[13:23:05.219]                           invokeRestart("muffleMessage")
[13:23:05.219]                       }
[13:23:05.219]                       else if (inherits(cond, "warning")) {
[13:23:05.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.219]                         if (muffled) 
[13:23:05.219]                           invokeRestart("muffleWarning")
[13:23:05.219]                       }
[13:23:05.219]                       else if (inherits(cond, "condition")) {
[13:23:05.219]                         if (!is.null(pattern)) {
[13:23:05.219]                           computeRestarts <- base::computeRestarts
[13:23:05.219]                           grepl <- base::grepl
[13:23:05.219]                           restarts <- computeRestarts(cond)
[13:23:05.219]                           for (restart in restarts) {
[13:23:05.219]                             name <- restart$name
[13:23:05.219]                             if (is.null(name)) 
[13:23:05.219]                               next
[13:23:05.219]                             if (!grepl(pattern, name)) 
[13:23:05.219]                               next
[13:23:05.219]                             invokeRestart(restart)
[13:23:05.219]                             muffled <- TRUE
[13:23:05.219]                             break
[13:23:05.219]                           }
[13:23:05.219]                         }
[13:23:05.219]                       }
[13:23:05.219]                       invisible(muffled)
[13:23:05.219]                     }
[13:23:05.219]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.219]                   }
[13:23:05.219]                 }
[13:23:05.219]                 else {
[13:23:05.219]                   if (TRUE) {
[13:23:05.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.219]                     {
[13:23:05.219]                       inherits <- base::inherits
[13:23:05.219]                       invokeRestart <- base::invokeRestart
[13:23:05.219]                       is.null <- base::is.null
[13:23:05.219]                       muffled <- FALSE
[13:23:05.219]                       if (inherits(cond, "message")) {
[13:23:05.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.219]                         if (muffled) 
[13:23:05.219]                           invokeRestart("muffleMessage")
[13:23:05.219]                       }
[13:23:05.219]                       else if (inherits(cond, "warning")) {
[13:23:05.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.219]                         if (muffled) 
[13:23:05.219]                           invokeRestart("muffleWarning")
[13:23:05.219]                       }
[13:23:05.219]                       else if (inherits(cond, "condition")) {
[13:23:05.219]                         if (!is.null(pattern)) {
[13:23:05.219]                           computeRestarts <- base::computeRestarts
[13:23:05.219]                           grepl <- base::grepl
[13:23:05.219]                           restarts <- computeRestarts(cond)
[13:23:05.219]                           for (restart in restarts) {
[13:23:05.219]                             name <- restart$name
[13:23:05.219]                             if (is.null(name)) 
[13:23:05.219]                               next
[13:23:05.219]                             if (!grepl(pattern, name)) 
[13:23:05.219]                               next
[13:23:05.219]                             invokeRestart(restart)
[13:23:05.219]                             muffled <- TRUE
[13:23:05.219]                             break
[13:23:05.219]                           }
[13:23:05.219]                         }
[13:23:05.219]                       }
[13:23:05.219]                       invisible(muffled)
[13:23:05.219]                     }
[13:23:05.219]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.219]                   }
[13:23:05.219]                 }
[13:23:05.219]             }
[13:23:05.219]         }))
[13:23:05.219]     }, error = function(ex) {
[13:23:05.219]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.219]                 ...future.rng), started = ...future.startTime, 
[13:23:05.219]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.219]             version = "1.8"), class = "FutureResult")
[13:23:05.219]     }, finally = {
[13:23:05.219]         if (!identical(...future.workdir, getwd())) 
[13:23:05.219]             setwd(...future.workdir)
[13:23:05.219]         {
[13:23:05.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.219]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.219]             }
[13:23:05.219]             base::options(...future.oldOptions)
[13:23:05.219]             if (.Platform$OS.type == "windows") {
[13:23:05.219]                 old_names <- names(...future.oldEnvVars)
[13:23:05.219]                 envs <- base::Sys.getenv()
[13:23:05.219]                 names <- names(envs)
[13:23:05.219]                 common <- intersect(names, old_names)
[13:23:05.219]                 added <- setdiff(names, old_names)
[13:23:05.219]                 removed <- setdiff(old_names, names)
[13:23:05.219]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.219]                   envs[common]]
[13:23:05.219]                 NAMES <- toupper(changed)
[13:23:05.219]                 args <- list()
[13:23:05.219]                 for (kk in seq_along(NAMES)) {
[13:23:05.219]                   name <- changed[[kk]]
[13:23:05.219]                   NAME <- NAMES[[kk]]
[13:23:05.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.219]                     next
[13:23:05.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.219]                 }
[13:23:05.219]                 NAMES <- toupper(added)
[13:23:05.219]                 for (kk in seq_along(NAMES)) {
[13:23:05.219]                   name <- added[[kk]]
[13:23:05.219]                   NAME <- NAMES[[kk]]
[13:23:05.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.219]                     next
[13:23:05.219]                   args[[name]] <- ""
[13:23:05.219]                 }
[13:23:05.219]                 NAMES <- toupper(removed)
[13:23:05.219]                 for (kk in seq_along(NAMES)) {
[13:23:05.219]                   name <- removed[[kk]]
[13:23:05.219]                   NAME <- NAMES[[kk]]
[13:23:05.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.219]                     next
[13:23:05.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.219]                 }
[13:23:05.219]                 if (length(args) > 0) 
[13:23:05.219]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.219]             }
[13:23:05.219]             else {
[13:23:05.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.219]             }
[13:23:05.219]             {
[13:23:05.219]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.219]                   0L) {
[13:23:05.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.219]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.219]                   base::options(opts)
[13:23:05.219]                 }
[13:23:05.219]                 {
[13:23:05.219]                   {
[13:23:05.219]                     NULL
[13:23:05.219]                     RNGkind("Mersenne-Twister")
[13:23:05.219]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.219]                       inherits = FALSE)
[13:23:05.219]                   }
[13:23:05.219]                   options(future.plan = NULL)
[13:23:05.219]                   if (is.na(NA_character_)) 
[13:23:05.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.219]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.219]                   {
[13:23:05.219]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.219]                     if (!future$lazy) 
[13:23:05.219]                       future <- run(future)
[13:23:05.219]                     invisible(future)
[13:23:05.219]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.219]                 }
[13:23:05.219]             }
[13:23:05.219]         }
[13:23:05.219]     })
[13:23:05.219]     if (TRUE) {
[13:23:05.219]         base::sink(type = "output", split = FALSE)
[13:23:05.219]         if (TRUE) {
[13:23:05.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.219]         }
[13:23:05.219]         else {
[13:23:05.219]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.219]         }
[13:23:05.219]         base::close(...future.stdout)
[13:23:05.219]         ...future.stdout <- NULL
[13:23:05.219]     }
[13:23:05.219]     ...future.result$conditions <- ...future.conditions
[13:23:05.219]     ...future.result$finished <- base::Sys.time()
[13:23:05.219]     ...future.result
[13:23:05.219] }
[13:23:05.221] plan(): Setting new future strategy stack:
[13:23:05.221] List of future strategies:
[13:23:05.221] 1. sequential:
[13:23:05.221]    - args: function (..., envir = parent.frame())
[13:23:05.221]    - tweaked: FALSE
[13:23:05.221]    - call: NULL
[13:23:05.221] plan(): nbrOfWorkers() = 1
[13:23:05.222] plan(): Setting new future strategy stack:
[13:23:05.222] List of future strategies:
[13:23:05.222] 1. sequential:
[13:23:05.222]    - args: function (..., envir = parent.frame())
[13:23:05.222]    - tweaked: FALSE
[13:23:05.222]    - call: plan(strategy)
[13:23:05.223] plan(): nbrOfWorkers() = 1
[13:23:05.223] SequentialFuture started (and completed)
[13:23:05.223] - Launch lazy future ... done
[13:23:05.223] run() for ‘SequentialFuture’ ... done
[13:23:05.224] getGlobalsAndPackages() ...
[13:23:05.224] Searching for globals...
[13:23:05.226] - globals found: [1] ‘{’
[13:23:05.226] Searching for globals ... DONE
[13:23:05.226] Resolving globals: FALSE
[13:23:05.227] 
[13:23:05.227] 
[13:23:05.227] getGlobalsAndPackages() ... DONE
[13:23:05.227] run() for ‘Future’ ...
[13:23:05.227] - state: ‘created’
[13:23:05.227] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.228] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.228] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.228]   - Field: ‘label’
[13:23:05.228]   - Field: ‘local’
[13:23:05.228]   - Field: ‘owner’
[13:23:05.228]   - Field: ‘envir’
[13:23:05.228]   - Field: ‘packages’
[13:23:05.228]   - Field: ‘gc’
[13:23:05.228]   - Field: ‘conditions’
[13:23:05.229]   - Field: ‘expr’
[13:23:05.229]   - Field: ‘uuid’
[13:23:05.229]   - Field: ‘seed’
[13:23:05.229]   - Field: ‘version’
[13:23:05.229]   - Field: ‘result’
[13:23:05.229]   - Field: ‘asynchronous’
[13:23:05.229]   - Field: ‘calls’
[13:23:05.229]   - Field: ‘globals’
[13:23:05.229]   - Field: ‘stdout’
[13:23:05.229]   - Field: ‘earlySignal’
[13:23:05.229]   - Field: ‘lazy’
[13:23:05.230]   - Field: ‘state’
[13:23:05.230] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.230] - Launch lazy future ...
[13:23:05.230] Packages needed by the future expression (n = 0): <none>
[13:23:05.230] Packages needed by future strategies (n = 0): <none>
[13:23:05.233] {
[13:23:05.233]     {
[13:23:05.233]         {
[13:23:05.233]             ...future.startTime <- base::Sys.time()
[13:23:05.233]             {
[13:23:05.233]                 {
[13:23:05.233]                   {
[13:23:05.233]                     base::local({
[13:23:05.233]                       has_future <- base::requireNamespace("future", 
[13:23:05.233]                         quietly = TRUE)
[13:23:05.233]                       if (has_future) {
[13:23:05.233]                         ns <- base::getNamespace("future")
[13:23:05.233]                         version <- ns[[".package"]][["version"]]
[13:23:05.233]                         if (is.null(version)) 
[13:23:05.233]                           version <- utils::packageVersion("future")
[13:23:05.233]                       }
[13:23:05.233]                       else {
[13:23:05.233]                         version <- NULL
[13:23:05.233]                       }
[13:23:05.233]                       if (!has_future || version < "1.8.0") {
[13:23:05.233]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.233]                           "", base::R.version$version.string), 
[13:23:05.233]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.233]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.233]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.233]                             "release", "version")], collapse = " "), 
[13:23:05.233]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.233]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.233]                           info)
[13:23:05.233]                         info <- base::paste(info, collapse = "; ")
[13:23:05.233]                         if (!has_future) {
[13:23:05.233]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.233]                             info)
[13:23:05.233]                         }
[13:23:05.233]                         else {
[13:23:05.233]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.233]                             info, version)
[13:23:05.233]                         }
[13:23:05.233]                         base::stop(msg)
[13:23:05.233]                       }
[13:23:05.233]                     })
[13:23:05.233]                   }
[13:23:05.233]                   options(future.plan = NULL)
[13:23:05.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.233]                 }
[13:23:05.233]                 ...future.workdir <- getwd()
[13:23:05.233]             }
[13:23:05.233]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.233]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.233]         }
[13:23:05.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.233]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.233]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.233]             base::names(...future.oldOptions))
[13:23:05.233]     }
[13:23:05.233]     if (FALSE) {
[13:23:05.233]     }
[13:23:05.233]     else {
[13:23:05.233]         if (TRUE) {
[13:23:05.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.233]                 open = "w")
[13:23:05.233]         }
[13:23:05.233]         else {
[13:23:05.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.233]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.233]         }
[13:23:05.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.233]             base::sink(type = "output", split = FALSE)
[13:23:05.233]             base::close(...future.stdout)
[13:23:05.233]         }, add = TRUE)
[13:23:05.233]     }
[13:23:05.233]     ...future.frame <- base::sys.nframe()
[13:23:05.233]     ...future.conditions <- base::list()
[13:23:05.233]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.233]     if (FALSE) {
[13:23:05.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.233]     }
[13:23:05.233]     ...future.result <- base::tryCatch({
[13:23:05.233]         base::withCallingHandlers({
[13:23:05.233]             ...future.value <- base::withVisible(base::local({
[13:23:05.233]                 4
[13:23:05.233]             }))
[13:23:05.233]             future::FutureResult(value = ...future.value$value, 
[13:23:05.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.233]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.233]                     ...future.globalenv.names))
[13:23:05.233]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.233]         }, condition = base::local({
[13:23:05.233]             c <- base::c
[13:23:05.233]             inherits <- base::inherits
[13:23:05.233]             invokeRestart <- base::invokeRestart
[13:23:05.233]             length <- base::length
[13:23:05.233]             list <- base::list
[13:23:05.233]             seq.int <- base::seq.int
[13:23:05.233]             signalCondition <- base::signalCondition
[13:23:05.233]             sys.calls <- base::sys.calls
[13:23:05.233]             `[[` <- base::`[[`
[13:23:05.233]             `+` <- base::`+`
[13:23:05.233]             `<<-` <- base::`<<-`
[13:23:05.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.233]                   3L)]
[13:23:05.233]             }
[13:23:05.233]             function(cond) {
[13:23:05.233]                 is_error <- inherits(cond, "error")
[13:23:05.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.233]                   NULL)
[13:23:05.233]                 if (is_error) {
[13:23:05.233]                   sessionInformation <- function() {
[13:23:05.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.233]                       search = base::search(), system = base::Sys.info())
[13:23:05.233]                   }
[13:23:05.233]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.233]                     cond$call), session = sessionInformation(), 
[13:23:05.233]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.233]                   signalCondition(cond)
[13:23:05.233]                 }
[13:23:05.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.233]                 "immediateCondition"))) {
[13:23:05.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.233]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.233]                   if (TRUE && !signal) {
[13:23:05.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.233]                     {
[13:23:05.233]                       inherits <- base::inherits
[13:23:05.233]                       invokeRestart <- base::invokeRestart
[13:23:05.233]                       is.null <- base::is.null
[13:23:05.233]                       muffled <- FALSE
[13:23:05.233]                       if (inherits(cond, "message")) {
[13:23:05.233]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.233]                         if (muffled) 
[13:23:05.233]                           invokeRestart("muffleMessage")
[13:23:05.233]                       }
[13:23:05.233]                       else if (inherits(cond, "warning")) {
[13:23:05.233]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.233]                         if (muffled) 
[13:23:05.233]                           invokeRestart("muffleWarning")
[13:23:05.233]                       }
[13:23:05.233]                       else if (inherits(cond, "condition")) {
[13:23:05.233]                         if (!is.null(pattern)) {
[13:23:05.233]                           computeRestarts <- base::computeRestarts
[13:23:05.233]                           grepl <- base::grepl
[13:23:05.233]                           restarts <- computeRestarts(cond)
[13:23:05.233]                           for (restart in restarts) {
[13:23:05.233]                             name <- restart$name
[13:23:05.233]                             if (is.null(name)) 
[13:23:05.233]                               next
[13:23:05.233]                             if (!grepl(pattern, name)) 
[13:23:05.233]                               next
[13:23:05.233]                             invokeRestart(restart)
[13:23:05.233]                             muffled <- TRUE
[13:23:05.233]                             break
[13:23:05.233]                           }
[13:23:05.233]                         }
[13:23:05.233]                       }
[13:23:05.233]                       invisible(muffled)
[13:23:05.233]                     }
[13:23:05.233]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.233]                   }
[13:23:05.233]                 }
[13:23:05.233]                 else {
[13:23:05.233]                   if (TRUE) {
[13:23:05.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.233]                     {
[13:23:05.233]                       inherits <- base::inherits
[13:23:05.233]                       invokeRestart <- base::invokeRestart
[13:23:05.233]                       is.null <- base::is.null
[13:23:05.233]                       muffled <- FALSE
[13:23:05.233]                       if (inherits(cond, "message")) {
[13:23:05.233]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.233]                         if (muffled) 
[13:23:05.233]                           invokeRestart("muffleMessage")
[13:23:05.233]                       }
[13:23:05.233]                       else if (inherits(cond, "warning")) {
[13:23:05.233]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.233]                         if (muffled) 
[13:23:05.233]                           invokeRestart("muffleWarning")
[13:23:05.233]                       }
[13:23:05.233]                       else if (inherits(cond, "condition")) {
[13:23:05.233]                         if (!is.null(pattern)) {
[13:23:05.233]                           computeRestarts <- base::computeRestarts
[13:23:05.233]                           grepl <- base::grepl
[13:23:05.233]                           restarts <- computeRestarts(cond)
[13:23:05.233]                           for (restart in restarts) {
[13:23:05.233]                             name <- restart$name
[13:23:05.233]                             if (is.null(name)) 
[13:23:05.233]                               next
[13:23:05.233]                             if (!grepl(pattern, name)) 
[13:23:05.233]                               next
[13:23:05.233]                             invokeRestart(restart)
[13:23:05.233]                             muffled <- TRUE
[13:23:05.233]                             break
[13:23:05.233]                           }
[13:23:05.233]                         }
[13:23:05.233]                       }
[13:23:05.233]                       invisible(muffled)
[13:23:05.233]                     }
[13:23:05.233]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.233]                   }
[13:23:05.233]                 }
[13:23:05.233]             }
[13:23:05.233]         }))
[13:23:05.233]     }, error = function(ex) {
[13:23:05.233]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.233]                 ...future.rng), started = ...future.startTime, 
[13:23:05.233]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.233]             version = "1.8"), class = "FutureResult")
[13:23:05.233]     }, finally = {
[13:23:05.233]         if (!identical(...future.workdir, getwd())) 
[13:23:05.233]             setwd(...future.workdir)
[13:23:05.233]         {
[13:23:05.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.233]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.233]             }
[13:23:05.233]             base::options(...future.oldOptions)
[13:23:05.233]             if (.Platform$OS.type == "windows") {
[13:23:05.233]                 old_names <- names(...future.oldEnvVars)
[13:23:05.233]                 envs <- base::Sys.getenv()
[13:23:05.233]                 names <- names(envs)
[13:23:05.233]                 common <- intersect(names, old_names)
[13:23:05.233]                 added <- setdiff(names, old_names)
[13:23:05.233]                 removed <- setdiff(old_names, names)
[13:23:05.233]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.233]                   envs[common]]
[13:23:05.233]                 NAMES <- toupper(changed)
[13:23:05.233]                 args <- list()
[13:23:05.233]                 for (kk in seq_along(NAMES)) {
[13:23:05.233]                   name <- changed[[kk]]
[13:23:05.233]                   NAME <- NAMES[[kk]]
[13:23:05.233]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.233]                     next
[13:23:05.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.233]                 }
[13:23:05.233]                 NAMES <- toupper(added)
[13:23:05.233]                 for (kk in seq_along(NAMES)) {
[13:23:05.233]                   name <- added[[kk]]
[13:23:05.233]                   NAME <- NAMES[[kk]]
[13:23:05.233]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.233]                     next
[13:23:05.233]                   args[[name]] <- ""
[13:23:05.233]                 }
[13:23:05.233]                 NAMES <- toupper(removed)
[13:23:05.233]                 for (kk in seq_along(NAMES)) {
[13:23:05.233]                   name <- removed[[kk]]
[13:23:05.233]                   NAME <- NAMES[[kk]]
[13:23:05.233]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.233]                     next
[13:23:05.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.233]                 }
[13:23:05.233]                 if (length(args) > 0) 
[13:23:05.233]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.233]             }
[13:23:05.233]             else {
[13:23:05.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.233]             }
[13:23:05.233]             {
[13:23:05.233]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.233]                   0L) {
[13:23:05.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.233]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.233]                   base::options(opts)
[13:23:05.233]                 }
[13:23:05.233]                 {
[13:23:05.233]                   {
[13:23:05.233]                     NULL
[13:23:05.233]                     RNGkind("Mersenne-Twister")
[13:23:05.233]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.233]                       inherits = FALSE)
[13:23:05.233]                   }
[13:23:05.233]                   options(future.plan = NULL)
[13:23:05.233]                   if (is.na(NA_character_)) 
[13:23:05.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.233]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.233]                   {
[13:23:05.233]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.233]                     if (!future$lazy) 
[13:23:05.233]                       future <- run(future)
[13:23:05.233]                     invisible(future)
[13:23:05.233]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.233]                 }
[13:23:05.233]             }
[13:23:05.233]         }
[13:23:05.233]     })
[13:23:05.233]     if (TRUE) {
[13:23:05.233]         base::sink(type = "output", split = FALSE)
[13:23:05.233]         if (TRUE) {
[13:23:05.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.233]         }
[13:23:05.233]         else {
[13:23:05.233]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.233]         }
[13:23:05.233]         base::close(...future.stdout)
[13:23:05.233]         ...future.stdout <- NULL
[13:23:05.233]     }
[13:23:05.233]     ...future.result$conditions <- ...future.conditions
[13:23:05.233]     ...future.result$finished <- base::Sys.time()
[13:23:05.233]     ...future.result
[13:23:05.233] }
[13:23:05.235] plan(): Setting new future strategy stack:
[13:23:05.235] List of future strategies:
[13:23:05.235] 1. sequential:
[13:23:05.235]    - args: function (..., envir = parent.frame())
[13:23:05.235]    - tweaked: FALSE
[13:23:05.235]    - call: NULL
[13:23:05.235] plan(): nbrOfWorkers() = 1
[13:23:05.236] plan(): Setting new future strategy stack:
[13:23:05.236] List of future strategies:
[13:23:05.236] 1. sequential:
[13:23:05.236]    - args: function (..., envir = parent.frame())
[13:23:05.236]    - tweaked: FALSE
[13:23:05.236]    - call: plan(strategy)
[13:23:05.237] plan(): nbrOfWorkers() = 1
[13:23:05.237] SequentialFuture started (and completed)
[13:23:05.237] - Launch lazy future ... done
[13:23:05.237] run() for ‘SequentialFuture’ ... done
<environment: 0x5596d41cdbc8> 
<environment: 0x5596d3db80c0> 
[13:23:05.239] resolved() for ‘SequentialFuture’ ...
[13:23:05.239] - state: ‘finished’
[13:23:05.239] - run: TRUE
[13:23:05.239] - result: ‘FutureResult’
[13:23:05.239] resolved() for ‘SequentialFuture’ ... done
[13:23:05.239] resolved() for ‘SequentialFuture’ ...
[13:23:05.239] - state: ‘finished’
[13:23:05.239] - run: TRUE
[13:23:05.239] - result: ‘FutureResult’
[13:23:05.240] resolved() for ‘SequentialFuture’ ... done
[13:23:05.240] resolved() for ‘SequentialFuture’ ...
[13:23:05.240] - state: ‘finished’
[13:23:05.240] - run: TRUE
[13:23:05.240] - result: ‘FutureResult’
[13:23:05.240] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:05.242] resolve() on environment ...
[13:23:05.242]  recursive: 0
[13:23:05.242]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:05.242] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.242] - nx: 4
[13:23:05.242] - relay: TRUE
[13:23:05.243] - stdout: TRUE
[13:23:05.243] - signal: TRUE
[13:23:05.243] - resignal: FALSE
[13:23:05.243] - force: TRUE
[13:23:05.243] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.243] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.243]  - until=2
[13:23:05.243]  - relaying element #2
[13:23:05.243] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.243] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.243] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.244]  length: 3 (resolved future 1)
[13:23:05.244] resolved() for ‘SequentialFuture’ ...
[13:23:05.244] - state: ‘finished’
[13:23:05.244] - run: TRUE
[13:23:05.244] - result: ‘FutureResult’
[13:23:05.244] resolved() for ‘SequentialFuture’ ... done
[13:23:05.244] Future #2
[13:23:05.244] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.244] - nx: 4
[13:23:05.245] - relay: TRUE
[13:23:05.245] - stdout: TRUE
[13:23:05.245] - signal: TRUE
[13:23:05.245] - resignal: FALSE
[13:23:05.245] - force: TRUE
[13:23:05.245] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.245] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.245]  - until=2
[13:23:05.245]  - relaying element #2
[13:23:05.245] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.245] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.246] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.246]  length: 2 (resolved future 2)
[13:23:05.246] resolved() for ‘SequentialFuture’ ...
[13:23:05.246] - state: ‘finished’
[13:23:05.246] - run: TRUE
[13:23:05.246] - result: ‘FutureResult’
[13:23:05.246] resolved() for ‘SequentialFuture’ ... done
[13:23:05.246] Future #3
[13:23:05.246] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.247] - nx: 4
[13:23:05.247] - relay: TRUE
[13:23:05.247] - stdout: TRUE
[13:23:05.247] - signal: TRUE
[13:23:05.247] - resignal: FALSE
[13:23:05.247] - force: TRUE
[13:23:05.247] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.247] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.247]  - until=3
[13:23:05.247]  - relaying element #3
[13:23:05.247] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.248] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.248] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.248]  length: 1 (resolved future 3)
[13:23:05.248] resolved() for ‘SequentialFuture’ ...
[13:23:05.248] - state: ‘finished’
[13:23:05.248] - run: TRUE
[13:23:05.248] - result: ‘FutureResult’
[13:23:05.248] resolved() for ‘SequentialFuture’ ... done
[13:23:05.248] Future #4
[13:23:05.249] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.249] - nx: 4
[13:23:05.249] - relay: TRUE
[13:23:05.249] - stdout: TRUE
[13:23:05.249] - signal: TRUE
[13:23:05.249] - resignal: FALSE
[13:23:05.249] - force: TRUE
[13:23:05.249] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.249] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.249]  - until=4
[13:23:05.249]  - relaying element #4
[13:23:05.250] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.250] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.250] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.250]  length: 0 (resolved future 4)
[13:23:05.250] Relaying remaining futures
[13:23:05.250] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.250] - nx: 4
[13:23:05.250] - relay: TRUE
[13:23:05.250] - stdout: TRUE
[13:23:05.250] - signal: TRUE
[13:23:05.250] - resignal: FALSE
[13:23:05.250] - force: TRUE
[13:23:05.251] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.251] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:05.251] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.251] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.251] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.251] resolve() on environment ... DONE
<environment: 0x5596d3631350> 
Dimensions: c(1, 6)
[13:23:05.252] getGlobalsAndPackages() ...
[13:23:05.252] Searching for globals...
[13:23:05.252] 
[13:23:05.252] Searching for globals ... DONE
[13:23:05.252] - globals: [0] <none>
[13:23:05.252] getGlobalsAndPackages() ... DONE
[13:23:05.253] run() for ‘Future’ ...
[13:23:05.253] - state: ‘created’
[13:23:05.253] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.253] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.253] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.253]   - Field: ‘label’
[13:23:05.254]   - Field: ‘local’
[13:23:05.254]   - Field: ‘owner’
[13:23:05.254]   - Field: ‘envir’
[13:23:05.254]   - Field: ‘packages’
[13:23:05.254]   - Field: ‘gc’
[13:23:05.254]   - Field: ‘conditions’
[13:23:05.254]   - Field: ‘expr’
[13:23:05.254]   - Field: ‘uuid’
[13:23:05.254]   - Field: ‘seed’
[13:23:05.254]   - Field: ‘version’
[13:23:05.255]   - Field: ‘result’
[13:23:05.255]   - Field: ‘asynchronous’
[13:23:05.255]   - Field: ‘calls’
[13:23:05.255]   - Field: ‘globals’
[13:23:05.255]   - Field: ‘stdout’
[13:23:05.255]   - Field: ‘earlySignal’
[13:23:05.255]   - Field: ‘lazy’
[13:23:05.255]   - Field: ‘state’
[13:23:05.255] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.255] - Launch lazy future ...
[13:23:05.256] Packages needed by the future expression (n = 0): <none>
[13:23:05.256] Packages needed by future strategies (n = 0): <none>
[13:23:05.256] {
[13:23:05.256]     {
[13:23:05.256]         {
[13:23:05.256]             ...future.startTime <- base::Sys.time()
[13:23:05.256]             {
[13:23:05.256]                 {
[13:23:05.256]                   {
[13:23:05.256]                     base::local({
[13:23:05.256]                       has_future <- base::requireNamespace("future", 
[13:23:05.256]                         quietly = TRUE)
[13:23:05.256]                       if (has_future) {
[13:23:05.256]                         ns <- base::getNamespace("future")
[13:23:05.256]                         version <- ns[[".package"]][["version"]]
[13:23:05.256]                         if (is.null(version)) 
[13:23:05.256]                           version <- utils::packageVersion("future")
[13:23:05.256]                       }
[13:23:05.256]                       else {
[13:23:05.256]                         version <- NULL
[13:23:05.256]                       }
[13:23:05.256]                       if (!has_future || version < "1.8.0") {
[13:23:05.256]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.256]                           "", base::R.version$version.string), 
[13:23:05.256]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.256]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.256]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.256]                             "release", "version")], collapse = " "), 
[13:23:05.256]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.256]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.256]                           info)
[13:23:05.256]                         info <- base::paste(info, collapse = "; ")
[13:23:05.256]                         if (!has_future) {
[13:23:05.256]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.256]                             info)
[13:23:05.256]                         }
[13:23:05.256]                         else {
[13:23:05.256]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.256]                             info, version)
[13:23:05.256]                         }
[13:23:05.256]                         base::stop(msg)
[13:23:05.256]                       }
[13:23:05.256]                     })
[13:23:05.256]                   }
[13:23:05.256]                   options(future.plan = NULL)
[13:23:05.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.256]                 }
[13:23:05.256]                 ...future.workdir <- getwd()
[13:23:05.256]             }
[13:23:05.256]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.256]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.256]         }
[13:23:05.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.256]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.256]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.256]             base::names(...future.oldOptions))
[13:23:05.256]     }
[13:23:05.256]     if (FALSE) {
[13:23:05.256]     }
[13:23:05.256]     else {
[13:23:05.256]         if (TRUE) {
[13:23:05.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.256]                 open = "w")
[13:23:05.256]         }
[13:23:05.256]         else {
[13:23:05.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.256]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.256]         }
[13:23:05.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.256]             base::sink(type = "output", split = FALSE)
[13:23:05.256]             base::close(...future.stdout)
[13:23:05.256]         }, add = TRUE)
[13:23:05.256]     }
[13:23:05.256]     ...future.frame <- base::sys.nframe()
[13:23:05.256]     ...future.conditions <- base::list()
[13:23:05.256]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.256]     if (FALSE) {
[13:23:05.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.256]     }
[13:23:05.256]     ...future.result <- base::tryCatch({
[13:23:05.256]         base::withCallingHandlers({
[13:23:05.256]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.256]             future::FutureResult(value = ...future.value$value, 
[13:23:05.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.256]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.256]                     ...future.globalenv.names))
[13:23:05.256]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.256]         }, condition = base::local({
[13:23:05.256]             c <- base::c
[13:23:05.256]             inherits <- base::inherits
[13:23:05.256]             invokeRestart <- base::invokeRestart
[13:23:05.256]             length <- base::length
[13:23:05.256]             list <- base::list
[13:23:05.256]             seq.int <- base::seq.int
[13:23:05.256]             signalCondition <- base::signalCondition
[13:23:05.256]             sys.calls <- base::sys.calls
[13:23:05.256]             `[[` <- base::`[[`
[13:23:05.256]             `+` <- base::`+`
[13:23:05.256]             `<<-` <- base::`<<-`
[13:23:05.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.256]                   3L)]
[13:23:05.256]             }
[13:23:05.256]             function(cond) {
[13:23:05.256]                 is_error <- inherits(cond, "error")
[13:23:05.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.256]                   NULL)
[13:23:05.256]                 if (is_error) {
[13:23:05.256]                   sessionInformation <- function() {
[13:23:05.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.256]                       search = base::search(), system = base::Sys.info())
[13:23:05.256]                   }
[13:23:05.256]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.256]                     cond$call), session = sessionInformation(), 
[13:23:05.256]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.256]                   signalCondition(cond)
[13:23:05.256]                 }
[13:23:05.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.256]                 "immediateCondition"))) {
[13:23:05.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.256]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.256]                   if (TRUE && !signal) {
[13:23:05.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.256]                     {
[13:23:05.256]                       inherits <- base::inherits
[13:23:05.256]                       invokeRestart <- base::invokeRestart
[13:23:05.256]                       is.null <- base::is.null
[13:23:05.256]                       muffled <- FALSE
[13:23:05.256]                       if (inherits(cond, "message")) {
[13:23:05.256]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.256]                         if (muffled) 
[13:23:05.256]                           invokeRestart("muffleMessage")
[13:23:05.256]                       }
[13:23:05.256]                       else if (inherits(cond, "warning")) {
[13:23:05.256]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.256]                         if (muffled) 
[13:23:05.256]                           invokeRestart("muffleWarning")
[13:23:05.256]                       }
[13:23:05.256]                       else if (inherits(cond, "condition")) {
[13:23:05.256]                         if (!is.null(pattern)) {
[13:23:05.256]                           computeRestarts <- base::computeRestarts
[13:23:05.256]                           grepl <- base::grepl
[13:23:05.256]                           restarts <- computeRestarts(cond)
[13:23:05.256]                           for (restart in restarts) {
[13:23:05.256]                             name <- restart$name
[13:23:05.256]                             if (is.null(name)) 
[13:23:05.256]                               next
[13:23:05.256]                             if (!grepl(pattern, name)) 
[13:23:05.256]                               next
[13:23:05.256]                             invokeRestart(restart)
[13:23:05.256]                             muffled <- TRUE
[13:23:05.256]                             break
[13:23:05.256]                           }
[13:23:05.256]                         }
[13:23:05.256]                       }
[13:23:05.256]                       invisible(muffled)
[13:23:05.256]                     }
[13:23:05.256]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.256]                   }
[13:23:05.256]                 }
[13:23:05.256]                 else {
[13:23:05.256]                   if (TRUE) {
[13:23:05.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.256]                     {
[13:23:05.256]                       inherits <- base::inherits
[13:23:05.256]                       invokeRestart <- base::invokeRestart
[13:23:05.256]                       is.null <- base::is.null
[13:23:05.256]                       muffled <- FALSE
[13:23:05.256]                       if (inherits(cond, "message")) {
[13:23:05.256]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.256]                         if (muffled) 
[13:23:05.256]                           invokeRestart("muffleMessage")
[13:23:05.256]                       }
[13:23:05.256]                       else if (inherits(cond, "warning")) {
[13:23:05.256]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.256]                         if (muffled) 
[13:23:05.256]                           invokeRestart("muffleWarning")
[13:23:05.256]                       }
[13:23:05.256]                       else if (inherits(cond, "condition")) {
[13:23:05.256]                         if (!is.null(pattern)) {
[13:23:05.256]                           computeRestarts <- base::computeRestarts
[13:23:05.256]                           grepl <- base::grepl
[13:23:05.256]                           restarts <- computeRestarts(cond)
[13:23:05.256]                           for (restart in restarts) {
[13:23:05.256]                             name <- restart$name
[13:23:05.256]                             if (is.null(name)) 
[13:23:05.256]                               next
[13:23:05.256]                             if (!grepl(pattern, name)) 
[13:23:05.256]                               next
[13:23:05.256]                             invokeRestart(restart)
[13:23:05.256]                             muffled <- TRUE
[13:23:05.256]                             break
[13:23:05.256]                           }
[13:23:05.256]                         }
[13:23:05.256]                       }
[13:23:05.256]                       invisible(muffled)
[13:23:05.256]                     }
[13:23:05.256]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.256]                   }
[13:23:05.256]                 }
[13:23:05.256]             }
[13:23:05.256]         }))
[13:23:05.256]     }, error = function(ex) {
[13:23:05.256]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.256]                 ...future.rng), started = ...future.startTime, 
[13:23:05.256]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.256]             version = "1.8"), class = "FutureResult")
[13:23:05.256]     }, finally = {
[13:23:05.256]         if (!identical(...future.workdir, getwd())) 
[13:23:05.256]             setwd(...future.workdir)
[13:23:05.256]         {
[13:23:05.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.256]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.256]             }
[13:23:05.256]             base::options(...future.oldOptions)
[13:23:05.256]             if (.Platform$OS.type == "windows") {
[13:23:05.256]                 old_names <- names(...future.oldEnvVars)
[13:23:05.256]                 envs <- base::Sys.getenv()
[13:23:05.256]                 names <- names(envs)
[13:23:05.256]                 common <- intersect(names, old_names)
[13:23:05.256]                 added <- setdiff(names, old_names)
[13:23:05.256]                 removed <- setdiff(old_names, names)
[13:23:05.256]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.256]                   envs[common]]
[13:23:05.256]                 NAMES <- toupper(changed)
[13:23:05.256]                 args <- list()
[13:23:05.256]                 for (kk in seq_along(NAMES)) {
[13:23:05.256]                   name <- changed[[kk]]
[13:23:05.256]                   NAME <- NAMES[[kk]]
[13:23:05.256]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.256]                     next
[13:23:05.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.256]                 }
[13:23:05.256]                 NAMES <- toupper(added)
[13:23:05.256]                 for (kk in seq_along(NAMES)) {
[13:23:05.256]                   name <- added[[kk]]
[13:23:05.256]                   NAME <- NAMES[[kk]]
[13:23:05.256]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.256]                     next
[13:23:05.256]                   args[[name]] <- ""
[13:23:05.256]                 }
[13:23:05.256]                 NAMES <- toupper(removed)
[13:23:05.256]                 for (kk in seq_along(NAMES)) {
[13:23:05.256]                   name <- removed[[kk]]
[13:23:05.256]                   NAME <- NAMES[[kk]]
[13:23:05.256]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.256]                     next
[13:23:05.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.256]                 }
[13:23:05.256]                 if (length(args) > 0) 
[13:23:05.256]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.256]             }
[13:23:05.256]             else {
[13:23:05.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.256]             }
[13:23:05.256]             {
[13:23:05.256]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.256]                   0L) {
[13:23:05.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.256]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.256]                   base::options(opts)
[13:23:05.256]                 }
[13:23:05.256]                 {
[13:23:05.256]                   {
[13:23:05.256]                     NULL
[13:23:05.256]                     RNGkind("Mersenne-Twister")
[13:23:05.256]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.256]                       inherits = FALSE)
[13:23:05.256]                   }
[13:23:05.256]                   options(future.plan = NULL)
[13:23:05.256]                   if (is.na(NA_character_)) 
[13:23:05.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.256]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.256]                   {
[13:23:05.256]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.256]                     if (!future$lazy) 
[13:23:05.256]                       future <- run(future)
[13:23:05.256]                     invisible(future)
[13:23:05.256]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.256]                 }
[13:23:05.256]             }
[13:23:05.256]         }
[13:23:05.256]     })
[13:23:05.256]     if (TRUE) {
[13:23:05.256]         base::sink(type = "output", split = FALSE)
[13:23:05.256]         if (TRUE) {
[13:23:05.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.256]         }
[13:23:05.256]         else {
[13:23:05.256]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.256]         }
[13:23:05.256]         base::close(...future.stdout)
[13:23:05.256]         ...future.stdout <- NULL
[13:23:05.256]     }
[13:23:05.256]     ...future.result$conditions <- ...future.conditions
[13:23:05.256]     ...future.result$finished <- base::Sys.time()
[13:23:05.256]     ...future.result
[13:23:05.256] }
[13:23:05.258] plan(): Setting new future strategy stack:
[13:23:05.258] List of future strategies:
[13:23:05.258] 1. sequential:
[13:23:05.258]    - args: function (..., envir = parent.frame())
[13:23:05.258]    - tweaked: FALSE
[13:23:05.258]    - call: NULL
[13:23:05.259] plan(): nbrOfWorkers() = 1
[13:23:05.259] plan(): Setting new future strategy stack:
[13:23:05.260] List of future strategies:
[13:23:05.260] 1. sequential:
[13:23:05.260]    - args: function (..., envir = parent.frame())
[13:23:05.260]    - tweaked: FALSE
[13:23:05.260]    - call: plan(strategy)
[13:23:05.260] plan(): nbrOfWorkers() = 1
[13:23:05.260] SequentialFuture started (and completed)
[13:23:05.260] - Launch lazy future ... done
[13:23:05.260] run() for ‘SequentialFuture’ ... done
[13:23:05.260] getGlobalsAndPackages() ...
[13:23:05.261] Searching for globals...
[13:23:05.261] 
[13:23:05.261] Searching for globals ... DONE
[13:23:05.261] - globals: [0] <none>
[13:23:05.261] getGlobalsAndPackages() ... DONE
[13:23:05.261] run() for ‘Future’ ...
[13:23:05.264] - state: ‘created’
[13:23:05.264] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.264] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.264] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.264]   - Field: ‘label’
[13:23:05.264]   - Field: ‘local’
[13:23:05.264]   - Field: ‘owner’
[13:23:05.265]   - Field: ‘envir’
[13:23:05.265]   - Field: ‘packages’
[13:23:05.265]   - Field: ‘gc’
[13:23:05.265]   - Field: ‘conditions’
[13:23:05.265]   - Field: ‘expr’
[13:23:05.265]   - Field: ‘uuid’
[13:23:05.265]   - Field: ‘seed’
[13:23:05.265]   - Field: ‘version’
[13:23:05.265]   - Field: ‘result’
[13:23:05.265]   - Field: ‘asynchronous’
[13:23:05.266]   - Field: ‘calls’
[13:23:05.266]   - Field: ‘globals’
[13:23:05.266]   - Field: ‘stdout’
[13:23:05.266]   - Field: ‘earlySignal’
[13:23:05.266]   - Field: ‘lazy’
[13:23:05.266]   - Field: ‘state’
[13:23:05.266] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.266] - Launch lazy future ...
[13:23:05.266] Packages needed by the future expression (n = 0): <none>
[13:23:05.267] Packages needed by future strategies (n = 0): <none>
[13:23:05.267] {
[13:23:05.267]     {
[13:23:05.267]         {
[13:23:05.267]             ...future.startTime <- base::Sys.time()
[13:23:05.267]             {
[13:23:05.267]                 {
[13:23:05.267]                   {
[13:23:05.267]                     base::local({
[13:23:05.267]                       has_future <- base::requireNamespace("future", 
[13:23:05.267]                         quietly = TRUE)
[13:23:05.267]                       if (has_future) {
[13:23:05.267]                         ns <- base::getNamespace("future")
[13:23:05.267]                         version <- ns[[".package"]][["version"]]
[13:23:05.267]                         if (is.null(version)) 
[13:23:05.267]                           version <- utils::packageVersion("future")
[13:23:05.267]                       }
[13:23:05.267]                       else {
[13:23:05.267]                         version <- NULL
[13:23:05.267]                       }
[13:23:05.267]                       if (!has_future || version < "1.8.0") {
[13:23:05.267]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.267]                           "", base::R.version$version.string), 
[13:23:05.267]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.267]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.267]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.267]                             "release", "version")], collapse = " "), 
[13:23:05.267]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.267]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.267]                           info)
[13:23:05.267]                         info <- base::paste(info, collapse = "; ")
[13:23:05.267]                         if (!has_future) {
[13:23:05.267]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.267]                             info)
[13:23:05.267]                         }
[13:23:05.267]                         else {
[13:23:05.267]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.267]                             info, version)
[13:23:05.267]                         }
[13:23:05.267]                         base::stop(msg)
[13:23:05.267]                       }
[13:23:05.267]                     })
[13:23:05.267]                   }
[13:23:05.267]                   options(future.plan = NULL)
[13:23:05.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.267]                 }
[13:23:05.267]                 ...future.workdir <- getwd()
[13:23:05.267]             }
[13:23:05.267]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.267]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.267]         }
[13:23:05.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.267]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.267]             base::names(...future.oldOptions))
[13:23:05.267]     }
[13:23:05.267]     if (FALSE) {
[13:23:05.267]     }
[13:23:05.267]     else {
[13:23:05.267]         if (TRUE) {
[13:23:05.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.267]                 open = "w")
[13:23:05.267]         }
[13:23:05.267]         else {
[13:23:05.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.267]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.267]         }
[13:23:05.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.267]             base::sink(type = "output", split = FALSE)
[13:23:05.267]             base::close(...future.stdout)
[13:23:05.267]         }, add = TRUE)
[13:23:05.267]     }
[13:23:05.267]     ...future.frame <- base::sys.nframe()
[13:23:05.267]     ...future.conditions <- base::list()
[13:23:05.267]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.267]     if (FALSE) {
[13:23:05.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.267]     }
[13:23:05.267]     ...future.result <- base::tryCatch({
[13:23:05.267]         base::withCallingHandlers({
[13:23:05.267]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.267]             future::FutureResult(value = ...future.value$value, 
[13:23:05.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.267]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.267]                     ...future.globalenv.names))
[13:23:05.267]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.267]         }, condition = base::local({
[13:23:05.267]             c <- base::c
[13:23:05.267]             inherits <- base::inherits
[13:23:05.267]             invokeRestart <- base::invokeRestart
[13:23:05.267]             length <- base::length
[13:23:05.267]             list <- base::list
[13:23:05.267]             seq.int <- base::seq.int
[13:23:05.267]             signalCondition <- base::signalCondition
[13:23:05.267]             sys.calls <- base::sys.calls
[13:23:05.267]             `[[` <- base::`[[`
[13:23:05.267]             `+` <- base::`+`
[13:23:05.267]             `<<-` <- base::`<<-`
[13:23:05.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.267]                   3L)]
[13:23:05.267]             }
[13:23:05.267]             function(cond) {
[13:23:05.267]                 is_error <- inherits(cond, "error")
[13:23:05.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.267]                   NULL)
[13:23:05.267]                 if (is_error) {
[13:23:05.267]                   sessionInformation <- function() {
[13:23:05.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.267]                       search = base::search(), system = base::Sys.info())
[13:23:05.267]                   }
[13:23:05.267]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.267]                     cond$call), session = sessionInformation(), 
[13:23:05.267]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.267]                   signalCondition(cond)
[13:23:05.267]                 }
[13:23:05.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.267]                 "immediateCondition"))) {
[13:23:05.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.267]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.267]                   if (TRUE && !signal) {
[13:23:05.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.267]                     {
[13:23:05.267]                       inherits <- base::inherits
[13:23:05.267]                       invokeRestart <- base::invokeRestart
[13:23:05.267]                       is.null <- base::is.null
[13:23:05.267]                       muffled <- FALSE
[13:23:05.267]                       if (inherits(cond, "message")) {
[13:23:05.267]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.267]                         if (muffled) 
[13:23:05.267]                           invokeRestart("muffleMessage")
[13:23:05.267]                       }
[13:23:05.267]                       else if (inherits(cond, "warning")) {
[13:23:05.267]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.267]                         if (muffled) 
[13:23:05.267]                           invokeRestart("muffleWarning")
[13:23:05.267]                       }
[13:23:05.267]                       else if (inherits(cond, "condition")) {
[13:23:05.267]                         if (!is.null(pattern)) {
[13:23:05.267]                           computeRestarts <- base::computeRestarts
[13:23:05.267]                           grepl <- base::grepl
[13:23:05.267]                           restarts <- computeRestarts(cond)
[13:23:05.267]                           for (restart in restarts) {
[13:23:05.267]                             name <- restart$name
[13:23:05.267]                             if (is.null(name)) 
[13:23:05.267]                               next
[13:23:05.267]                             if (!grepl(pattern, name)) 
[13:23:05.267]                               next
[13:23:05.267]                             invokeRestart(restart)
[13:23:05.267]                             muffled <- TRUE
[13:23:05.267]                             break
[13:23:05.267]                           }
[13:23:05.267]                         }
[13:23:05.267]                       }
[13:23:05.267]                       invisible(muffled)
[13:23:05.267]                     }
[13:23:05.267]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.267]                   }
[13:23:05.267]                 }
[13:23:05.267]                 else {
[13:23:05.267]                   if (TRUE) {
[13:23:05.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.267]                     {
[13:23:05.267]                       inherits <- base::inherits
[13:23:05.267]                       invokeRestart <- base::invokeRestart
[13:23:05.267]                       is.null <- base::is.null
[13:23:05.267]                       muffled <- FALSE
[13:23:05.267]                       if (inherits(cond, "message")) {
[13:23:05.267]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.267]                         if (muffled) 
[13:23:05.267]                           invokeRestart("muffleMessage")
[13:23:05.267]                       }
[13:23:05.267]                       else if (inherits(cond, "warning")) {
[13:23:05.267]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.267]                         if (muffled) 
[13:23:05.267]                           invokeRestart("muffleWarning")
[13:23:05.267]                       }
[13:23:05.267]                       else if (inherits(cond, "condition")) {
[13:23:05.267]                         if (!is.null(pattern)) {
[13:23:05.267]                           computeRestarts <- base::computeRestarts
[13:23:05.267]                           grepl <- base::grepl
[13:23:05.267]                           restarts <- computeRestarts(cond)
[13:23:05.267]                           for (restart in restarts) {
[13:23:05.267]                             name <- restart$name
[13:23:05.267]                             if (is.null(name)) 
[13:23:05.267]                               next
[13:23:05.267]                             if (!grepl(pattern, name)) 
[13:23:05.267]                               next
[13:23:05.267]                             invokeRestart(restart)
[13:23:05.267]                             muffled <- TRUE
[13:23:05.267]                             break
[13:23:05.267]                           }
[13:23:05.267]                         }
[13:23:05.267]                       }
[13:23:05.267]                       invisible(muffled)
[13:23:05.267]                     }
[13:23:05.267]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.267]                   }
[13:23:05.267]                 }
[13:23:05.267]             }
[13:23:05.267]         }))
[13:23:05.267]     }, error = function(ex) {
[13:23:05.267]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.267]                 ...future.rng), started = ...future.startTime, 
[13:23:05.267]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.267]             version = "1.8"), class = "FutureResult")
[13:23:05.267]     }, finally = {
[13:23:05.267]         if (!identical(...future.workdir, getwd())) 
[13:23:05.267]             setwd(...future.workdir)
[13:23:05.267]         {
[13:23:05.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.267]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.267]             }
[13:23:05.267]             base::options(...future.oldOptions)
[13:23:05.267]             if (.Platform$OS.type == "windows") {
[13:23:05.267]                 old_names <- names(...future.oldEnvVars)
[13:23:05.267]                 envs <- base::Sys.getenv()
[13:23:05.267]                 names <- names(envs)
[13:23:05.267]                 common <- intersect(names, old_names)
[13:23:05.267]                 added <- setdiff(names, old_names)
[13:23:05.267]                 removed <- setdiff(old_names, names)
[13:23:05.267]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.267]                   envs[common]]
[13:23:05.267]                 NAMES <- toupper(changed)
[13:23:05.267]                 args <- list()
[13:23:05.267]                 for (kk in seq_along(NAMES)) {
[13:23:05.267]                   name <- changed[[kk]]
[13:23:05.267]                   NAME <- NAMES[[kk]]
[13:23:05.267]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.267]                     next
[13:23:05.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.267]                 }
[13:23:05.267]                 NAMES <- toupper(added)
[13:23:05.267]                 for (kk in seq_along(NAMES)) {
[13:23:05.267]                   name <- added[[kk]]
[13:23:05.267]                   NAME <- NAMES[[kk]]
[13:23:05.267]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.267]                     next
[13:23:05.267]                   args[[name]] <- ""
[13:23:05.267]                 }
[13:23:05.267]                 NAMES <- toupper(removed)
[13:23:05.267]                 for (kk in seq_along(NAMES)) {
[13:23:05.267]                   name <- removed[[kk]]
[13:23:05.267]                   NAME <- NAMES[[kk]]
[13:23:05.267]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.267]                     next
[13:23:05.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.267]                 }
[13:23:05.267]                 if (length(args) > 0) 
[13:23:05.267]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.267]             }
[13:23:05.267]             else {
[13:23:05.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.267]             }
[13:23:05.267]             {
[13:23:05.267]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.267]                   0L) {
[13:23:05.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.267]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.267]                   base::options(opts)
[13:23:05.267]                 }
[13:23:05.267]                 {
[13:23:05.267]                   {
[13:23:05.267]                     NULL
[13:23:05.267]                     RNGkind("Mersenne-Twister")
[13:23:05.267]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.267]                       inherits = FALSE)
[13:23:05.267]                   }
[13:23:05.267]                   options(future.plan = NULL)
[13:23:05.267]                   if (is.na(NA_character_)) 
[13:23:05.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.267]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.267]                   {
[13:23:05.267]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.267]                     if (!future$lazy) 
[13:23:05.267]                       future <- run(future)
[13:23:05.267]                     invisible(future)
[13:23:05.267]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.267]                 }
[13:23:05.267]             }
[13:23:05.267]         }
[13:23:05.267]     })
[13:23:05.267]     if (TRUE) {
[13:23:05.267]         base::sink(type = "output", split = FALSE)
[13:23:05.267]         if (TRUE) {
[13:23:05.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.267]         }
[13:23:05.267]         else {
[13:23:05.267]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.267]         }
[13:23:05.267]         base::close(...future.stdout)
[13:23:05.267]         ...future.stdout <- NULL
[13:23:05.267]     }
[13:23:05.267]     ...future.result$conditions <- ...future.conditions
[13:23:05.267]     ...future.result$finished <- base::Sys.time()
[13:23:05.267]     ...future.result
[13:23:05.267] }
[13:23:05.269] plan(): Setting new future strategy stack:
[13:23:05.269] List of future strategies:
[13:23:05.269] 1. sequential:
[13:23:05.269]    - args: function (..., envir = parent.frame())
[13:23:05.269]    - tweaked: FALSE
[13:23:05.269]    - call: NULL
[13:23:05.269] plan(): nbrOfWorkers() = 1
[13:23:05.270] plan(): Setting new future strategy stack:
[13:23:05.270] List of future strategies:
[13:23:05.270] 1. sequential:
[13:23:05.270]    - args: function (..., envir = parent.frame())
[13:23:05.270]    - tweaked: FALSE
[13:23:05.270]    - call: plan(strategy)
[13:23:05.271] plan(): nbrOfWorkers() = 1
[13:23:05.271] SequentialFuture started (and completed)
[13:23:05.271] - Launch lazy future ... done
[13:23:05.271] run() for ‘SequentialFuture’ ... done
[13:23:05.271] getGlobalsAndPackages() ...
[13:23:05.271] Searching for globals...
[13:23:05.272] - globals found: [1] ‘{’
[13:23:05.272] Searching for globals ... DONE
[13:23:05.272] Resolving globals: FALSE
[13:23:05.273] 
[13:23:05.273] 
[13:23:05.273] getGlobalsAndPackages() ... DONE
[13:23:05.273] run() for ‘Future’ ...
[13:23:05.273] - state: ‘created’
[13:23:05.273] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.274] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.274]   - Field: ‘label’
[13:23:05.274]   - Field: ‘local’
[13:23:05.274]   - Field: ‘owner’
[13:23:05.274]   - Field: ‘envir’
[13:23:05.274]   - Field: ‘packages’
[13:23:05.274]   - Field: ‘gc’
[13:23:05.274]   - Field: ‘conditions’
[13:23:05.274]   - Field: ‘expr’
[13:23:05.275]   - Field: ‘uuid’
[13:23:05.275]   - Field: ‘seed’
[13:23:05.275]   - Field: ‘version’
[13:23:05.275]   - Field: ‘result’
[13:23:05.275]   - Field: ‘asynchronous’
[13:23:05.275]   - Field: ‘calls’
[13:23:05.275]   - Field: ‘globals’
[13:23:05.275]   - Field: ‘stdout’
[13:23:05.275]   - Field: ‘earlySignal’
[13:23:05.275]   - Field: ‘lazy’
[13:23:05.276]   - Field: ‘state’
[13:23:05.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.276] - Launch lazy future ...
[13:23:05.276] Packages needed by the future expression (n = 0): <none>
[13:23:05.276] Packages needed by future strategies (n = 0): <none>
[13:23:05.277] {
[13:23:05.277]     {
[13:23:05.277]         {
[13:23:05.277]             ...future.startTime <- base::Sys.time()
[13:23:05.277]             {
[13:23:05.277]                 {
[13:23:05.277]                   {
[13:23:05.277]                     base::local({
[13:23:05.277]                       has_future <- base::requireNamespace("future", 
[13:23:05.277]                         quietly = TRUE)
[13:23:05.277]                       if (has_future) {
[13:23:05.277]                         ns <- base::getNamespace("future")
[13:23:05.277]                         version <- ns[[".package"]][["version"]]
[13:23:05.277]                         if (is.null(version)) 
[13:23:05.277]                           version <- utils::packageVersion("future")
[13:23:05.277]                       }
[13:23:05.277]                       else {
[13:23:05.277]                         version <- NULL
[13:23:05.277]                       }
[13:23:05.277]                       if (!has_future || version < "1.8.0") {
[13:23:05.277]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.277]                           "", base::R.version$version.string), 
[13:23:05.277]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.277]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.277]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.277]                             "release", "version")], collapse = " "), 
[13:23:05.277]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.277]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.277]                           info)
[13:23:05.277]                         info <- base::paste(info, collapse = "; ")
[13:23:05.277]                         if (!has_future) {
[13:23:05.277]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.277]                             info)
[13:23:05.277]                         }
[13:23:05.277]                         else {
[13:23:05.277]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.277]                             info, version)
[13:23:05.277]                         }
[13:23:05.277]                         base::stop(msg)
[13:23:05.277]                       }
[13:23:05.277]                     })
[13:23:05.277]                   }
[13:23:05.277]                   options(future.plan = NULL)
[13:23:05.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.277]                 }
[13:23:05.277]                 ...future.workdir <- getwd()
[13:23:05.277]             }
[13:23:05.277]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.277]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.277]         }
[13:23:05.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.277]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.277]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.277]             base::names(...future.oldOptions))
[13:23:05.277]     }
[13:23:05.277]     if (FALSE) {
[13:23:05.277]     }
[13:23:05.277]     else {
[13:23:05.277]         if (TRUE) {
[13:23:05.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.277]                 open = "w")
[13:23:05.277]         }
[13:23:05.277]         else {
[13:23:05.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.277]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.277]         }
[13:23:05.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.277]             base::sink(type = "output", split = FALSE)
[13:23:05.277]             base::close(...future.stdout)
[13:23:05.277]         }, add = TRUE)
[13:23:05.277]     }
[13:23:05.277]     ...future.frame <- base::sys.nframe()
[13:23:05.277]     ...future.conditions <- base::list()
[13:23:05.277]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.277]     if (FALSE) {
[13:23:05.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.277]     }
[13:23:05.277]     ...future.result <- base::tryCatch({
[13:23:05.277]         base::withCallingHandlers({
[13:23:05.277]             ...future.value <- base::withVisible(base::local({
[13:23:05.277]                 4
[13:23:05.277]             }))
[13:23:05.277]             future::FutureResult(value = ...future.value$value, 
[13:23:05.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.277]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.277]                     ...future.globalenv.names))
[13:23:05.277]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.277]         }, condition = base::local({
[13:23:05.277]             c <- base::c
[13:23:05.277]             inherits <- base::inherits
[13:23:05.277]             invokeRestart <- base::invokeRestart
[13:23:05.277]             length <- base::length
[13:23:05.277]             list <- base::list
[13:23:05.277]             seq.int <- base::seq.int
[13:23:05.277]             signalCondition <- base::signalCondition
[13:23:05.277]             sys.calls <- base::sys.calls
[13:23:05.277]             `[[` <- base::`[[`
[13:23:05.277]             `+` <- base::`+`
[13:23:05.277]             `<<-` <- base::`<<-`
[13:23:05.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.277]                   3L)]
[13:23:05.277]             }
[13:23:05.277]             function(cond) {
[13:23:05.277]                 is_error <- inherits(cond, "error")
[13:23:05.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.277]                   NULL)
[13:23:05.277]                 if (is_error) {
[13:23:05.277]                   sessionInformation <- function() {
[13:23:05.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.277]                       search = base::search(), system = base::Sys.info())
[13:23:05.277]                   }
[13:23:05.277]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.277]                     cond$call), session = sessionInformation(), 
[13:23:05.277]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.277]                   signalCondition(cond)
[13:23:05.277]                 }
[13:23:05.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.277]                 "immediateCondition"))) {
[13:23:05.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.277]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.277]                   if (TRUE && !signal) {
[13:23:05.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.277]                     {
[13:23:05.277]                       inherits <- base::inherits
[13:23:05.277]                       invokeRestart <- base::invokeRestart
[13:23:05.277]                       is.null <- base::is.null
[13:23:05.277]                       muffled <- FALSE
[13:23:05.277]                       if (inherits(cond, "message")) {
[13:23:05.277]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.277]                         if (muffled) 
[13:23:05.277]                           invokeRestart("muffleMessage")
[13:23:05.277]                       }
[13:23:05.277]                       else if (inherits(cond, "warning")) {
[13:23:05.277]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.277]                         if (muffled) 
[13:23:05.277]                           invokeRestart("muffleWarning")
[13:23:05.277]                       }
[13:23:05.277]                       else if (inherits(cond, "condition")) {
[13:23:05.277]                         if (!is.null(pattern)) {
[13:23:05.277]                           computeRestarts <- base::computeRestarts
[13:23:05.277]                           grepl <- base::grepl
[13:23:05.277]                           restarts <- computeRestarts(cond)
[13:23:05.277]                           for (restart in restarts) {
[13:23:05.277]                             name <- restart$name
[13:23:05.277]                             if (is.null(name)) 
[13:23:05.277]                               next
[13:23:05.277]                             if (!grepl(pattern, name)) 
[13:23:05.277]                               next
[13:23:05.277]                             invokeRestart(restart)
[13:23:05.277]                             muffled <- TRUE
[13:23:05.277]                             break
[13:23:05.277]                           }
[13:23:05.277]                         }
[13:23:05.277]                       }
[13:23:05.277]                       invisible(muffled)
[13:23:05.277]                     }
[13:23:05.277]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.277]                   }
[13:23:05.277]                 }
[13:23:05.277]                 else {
[13:23:05.277]                   if (TRUE) {
[13:23:05.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.277]                     {
[13:23:05.277]                       inherits <- base::inherits
[13:23:05.277]                       invokeRestart <- base::invokeRestart
[13:23:05.277]                       is.null <- base::is.null
[13:23:05.277]                       muffled <- FALSE
[13:23:05.277]                       if (inherits(cond, "message")) {
[13:23:05.277]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.277]                         if (muffled) 
[13:23:05.277]                           invokeRestart("muffleMessage")
[13:23:05.277]                       }
[13:23:05.277]                       else if (inherits(cond, "warning")) {
[13:23:05.277]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.277]                         if (muffled) 
[13:23:05.277]                           invokeRestart("muffleWarning")
[13:23:05.277]                       }
[13:23:05.277]                       else if (inherits(cond, "condition")) {
[13:23:05.277]                         if (!is.null(pattern)) {
[13:23:05.277]                           computeRestarts <- base::computeRestarts
[13:23:05.277]                           grepl <- base::grepl
[13:23:05.277]                           restarts <- computeRestarts(cond)
[13:23:05.277]                           for (restart in restarts) {
[13:23:05.277]                             name <- restart$name
[13:23:05.277]                             if (is.null(name)) 
[13:23:05.277]                               next
[13:23:05.277]                             if (!grepl(pattern, name)) 
[13:23:05.277]                               next
[13:23:05.277]                             invokeRestart(restart)
[13:23:05.277]                             muffled <- TRUE
[13:23:05.277]                             break
[13:23:05.277]                           }
[13:23:05.277]                         }
[13:23:05.277]                       }
[13:23:05.277]                       invisible(muffled)
[13:23:05.277]                     }
[13:23:05.277]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.277]                   }
[13:23:05.277]                 }
[13:23:05.277]             }
[13:23:05.277]         }))
[13:23:05.277]     }, error = function(ex) {
[13:23:05.277]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.277]                 ...future.rng), started = ...future.startTime, 
[13:23:05.277]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.277]             version = "1.8"), class = "FutureResult")
[13:23:05.277]     }, finally = {
[13:23:05.277]         if (!identical(...future.workdir, getwd())) 
[13:23:05.277]             setwd(...future.workdir)
[13:23:05.277]         {
[13:23:05.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.277]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.277]             }
[13:23:05.277]             base::options(...future.oldOptions)
[13:23:05.277]             if (.Platform$OS.type == "windows") {
[13:23:05.277]                 old_names <- names(...future.oldEnvVars)
[13:23:05.277]                 envs <- base::Sys.getenv()
[13:23:05.277]                 names <- names(envs)
[13:23:05.277]                 common <- intersect(names, old_names)
[13:23:05.277]                 added <- setdiff(names, old_names)
[13:23:05.277]                 removed <- setdiff(old_names, names)
[13:23:05.277]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.277]                   envs[common]]
[13:23:05.277]                 NAMES <- toupper(changed)
[13:23:05.277]                 args <- list()
[13:23:05.277]                 for (kk in seq_along(NAMES)) {
[13:23:05.277]                   name <- changed[[kk]]
[13:23:05.277]                   NAME <- NAMES[[kk]]
[13:23:05.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.277]                     next
[13:23:05.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.277]                 }
[13:23:05.277]                 NAMES <- toupper(added)
[13:23:05.277]                 for (kk in seq_along(NAMES)) {
[13:23:05.277]                   name <- added[[kk]]
[13:23:05.277]                   NAME <- NAMES[[kk]]
[13:23:05.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.277]                     next
[13:23:05.277]                   args[[name]] <- ""
[13:23:05.277]                 }
[13:23:05.277]                 NAMES <- toupper(removed)
[13:23:05.277]                 for (kk in seq_along(NAMES)) {
[13:23:05.277]                   name <- removed[[kk]]
[13:23:05.277]                   NAME <- NAMES[[kk]]
[13:23:05.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.277]                     next
[13:23:05.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.277]                 }
[13:23:05.277]                 if (length(args) > 0) 
[13:23:05.277]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.277]             }
[13:23:05.277]             else {
[13:23:05.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.277]             }
[13:23:05.277]             {
[13:23:05.277]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.277]                   0L) {
[13:23:05.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.277]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.277]                   base::options(opts)
[13:23:05.277]                 }
[13:23:05.277]                 {
[13:23:05.277]                   {
[13:23:05.277]                     NULL
[13:23:05.277]                     RNGkind("Mersenne-Twister")
[13:23:05.277]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.277]                       inherits = FALSE)
[13:23:05.277]                   }
[13:23:05.277]                   options(future.plan = NULL)
[13:23:05.277]                   if (is.na(NA_character_)) 
[13:23:05.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.277]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.277]                   {
[13:23:05.277]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.277]                     if (!future$lazy) 
[13:23:05.277]                       future <- run(future)
[13:23:05.277]                     invisible(future)
[13:23:05.277]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.277]                 }
[13:23:05.277]             }
[13:23:05.277]         }
[13:23:05.277]     })
[13:23:05.277]     if (TRUE) {
[13:23:05.277]         base::sink(type = "output", split = FALSE)
[13:23:05.277]         if (TRUE) {
[13:23:05.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.277]         }
[13:23:05.277]         else {
[13:23:05.277]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.277]         }
[13:23:05.277]         base::close(...future.stdout)
[13:23:05.277]         ...future.stdout <- NULL
[13:23:05.277]     }
[13:23:05.277]     ...future.result$conditions <- ...future.conditions
[13:23:05.277]     ...future.result$finished <- base::Sys.time()
[13:23:05.277]     ...future.result
[13:23:05.277] }
[13:23:05.278] plan(): Setting new future strategy stack:
[13:23:05.278] List of future strategies:
[13:23:05.278] 1. sequential:
[13:23:05.278]    - args: function (..., envir = parent.frame())
[13:23:05.278]    - tweaked: FALSE
[13:23:05.278]    - call: NULL
[13:23:05.279] plan(): nbrOfWorkers() = 1
[13:23:05.280] plan(): Setting new future strategy stack:
[13:23:05.280] List of future strategies:
[13:23:05.280] 1. sequential:
[13:23:05.280]    - args: function (..., envir = parent.frame())
[13:23:05.280]    - tweaked: FALSE
[13:23:05.280]    - call: plan(strategy)
[13:23:05.280] plan(): nbrOfWorkers() = 1
[13:23:05.280] SequentialFuture started (and completed)
[13:23:05.280] - Launch lazy future ... done
[13:23:05.281] run() for ‘SequentialFuture’ ... done
<environment: 0x5596d576bdf8> 
<environment: 0x5596d5536e40> 
[13:23:05.282] resolved() for ‘SequentialFuture’ ...
[13:23:05.282] - state: ‘finished’
[13:23:05.282] - run: TRUE
[13:23:05.282] - result: ‘FutureResult’
[13:23:05.282] resolved() for ‘SequentialFuture’ ... done
[13:23:05.282] resolved() for ‘SequentialFuture’ ...
[13:23:05.283] - state: ‘finished’
[13:23:05.283] - run: TRUE
[13:23:05.283] - result: ‘FutureResult’
[13:23:05.283] resolved() for ‘SequentialFuture’ ... done
[13:23:05.283] resolved() for ‘SequentialFuture’ ...
[13:23:05.283] - state: ‘finished’
[13:23:05.283] - run: TRUE
[13:23:05.283] - result: ‘FutureResult’
[13:23:05.283] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:05.284] resolve() on environment ...
[13:23:05.285]  recursive: 0
[13:23:05.285]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:05.285] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.285] - nx: 4
[13:23:05.285] - relay: TRUE
[13:23:05.285] - stdout: TRUE
[13:23:05.286] - signal: TRUE
[13:23:05.286] - resignal: FALSE
[13:23:05.286] - force: TRUE
[13:23:05.286] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.286] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.286]  - until=2
[13:23:05.286]  - relaying element #2
[13:23:05.286] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.286] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.286] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.286]  length: 3 (resolved future 1)
[13:23:05.287] resolved() for ‘SequentialFuture’ ...
[13:23:05.287] - state: ‘finished’
[13:23:05.287] - run: TRUE
[13:23:05.287] - result: ‘FutureResult’
[13:23:05.287] resolved() for ‘SequentialFuture’ ... done
[13:23:05.287] Future #2
[13:23:05.287] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.287] - nx: 4
[13:23:05.287] - relay: TRUE
[13:23:05.287] - stdout: TRUE
[13:23:05.288] - signal: TRUE
[13:23:05.288] - resignal: FALSE
[13:23:05.288] - force: TRUE
[13:23:05.288] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.288] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.288]  - until=2
[13:23:05.288]  - relaying element #2
[13:23:05.288] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.288] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.288] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.289]  length: 2 (resolved future 2)
[13:23:05.289] resolved() for ‘SequentialFuture’ ...
[13:23:05.289] - state: ‘finished’
[13:23:05.289] - run: TRUE
[13:23:05.289] - result: ‘FutureResult’
[13:23:05.289] resolved() for ‘SequentialFuture’ ... done
[13:23:05.289] Future #3
[13:23:05.289] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.289] - nx: 4
[13:23:05.289] - relay: TRUE
[13:23:05.290] - stdout: TRUE
[13:23:05.290] - signal: TRUE
[13:23:05.290] - resignal: FALSE
[13:23:05.290] - force: TRUE
[13:23:05.290] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.290] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.290]  - until=3
[13:23:05.290]  - relaying element #3
[13:23:05.290] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.290] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.291] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.291]  length: 1 (resolved future 3)
[13:23:05.291] resolved() for ‘SequentialFuture’ ...
[13:23:05.291] - state: ‘finished’
[13:23:05.291] - run: TRUE
[13:23:05.291] - result: ‘FutureResult’
[13:23:05.291] resolved() for ‘SequentialFuture’ ... done
[13:23:05.291] Future #4
[13:23:05.294] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.294] - nx: 4
[13:23:05.294] - relay: TRUE
[13:23:05.294] - stdout: TRUE
[13:23:05.294] - signal: TRUE
[13:23:05.294] - resignal: FALSE
[13:23:05.294] - force: TRUE
[13:23:05.294] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.294] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.294]  - until=4
[13:23:05.294]  - relaying element #4
[13:23:05.295] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.295] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.295] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.295]  length: 0 (resolved future 4)
[13:23:05.295] Relaying remaining futures
[13:23:05.295] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.295] - nx: 4
[13:23:05.295] - relay: TRUE
[13:23:05.295] - stdout: TRUE
[13:23:05.295] - signal: TRUE
[13:23:05.296] - resignal: FALSE
[13:23:05.296] - force: TRUE
[13:23:05.296] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.296] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:05.296] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.296] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.296] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.296] resolve() on environment ... DONE
<environment: 0x5596d57684f8> 
Dimensions: c(2, 3)
[13:23:05.297] getGlobalsAndPackages() ...
[13:23:05.297] Searching for globals...
[13:23:05.297] 
[13:23:05.298] Searching for globals ... DONE
[13:23:05.298] - globals: [0] <none>
[13:23:05.298] getGlobalsAndPackages() ... DONE
[13:23:05.298] run() for ‘Future’ ...
[13:23:05.298] - state: ‘created’
[13:23:05.298] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.299] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.299] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.299]   - Field: ‘label’
[13:23:05.299]   - Field: ‘local’
[13:23:05.299]   - Field: ‘owner’
[13:23:05.299]   - Field: ‘envir’
[13:23:05.299]   - Field: ‘packages’
[13:23:05.299]   - Field: ‘gc’
[13:23:05.299]   - Field: ‘conditions’
[13:23:05.299]   - Field: ‘expr’
[13:23:05.300]   - Field: ‘uuid’
[13:23:05.300]   - Field: ‘seed’
[13:23:05.300]   - Field: ‘version’
[13:23:05.300]   - Field: ‘result’
[13:23:05.300]   - Field: ‘asynchronous’
[13:23:05.300]   - Field: ‘calls’
[13:23:05.300]   - Field: ‘globals’
[13:23:05.300]   - Field: ‘stdout’
[13:23:05.300]   - Field: ‘earlySignal’
[13:23:05.300]   - Field: ‘lazy’
[13:23:05.301]   - Field: ‘state’
[13:23:05.301] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.301] - Launch lazy future ...
[13:23:05.301] Packages needed by the future expression (n = 0): <none>
[13:23:05.301] Packages needed by future strategies (n = 0): <none>
[13:23:05.301] {
[13:23:05.301]     {
[13:23:05.301]         {
[13:23:05.301]             ...future.startTime <- base::Sys.time()
[13:23:05.301]             {
[13:23:05.301]                 {
[13:23:05.301]                   {
[13:23:05.301]                     base::local({
[13:23:05.301]                       has_future <- base::requireNamespace("future", 
[13:23:05.301]                         quietly = TRUE)
[13:23:05.301]                       if (has_future) {
[13:23:05.301]                         ns <- base::getNamespace("future")
[13:23:05.301]                         version <- ns[[".package"]][["version"]]
[13:23:05.301]                         if (is.null(version)) 
[13:23:05.301]                           version <- utils::packageVersion("future")
[13:23:05.301]                       }
[13:23:05.301]                       else {
[13:23:05.301]                         version <- NULL
[13:23:05.301]                       }
[13:23:05.301]                       if (!has_future || version < "1.8.0") {
[13:23:05.301]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.301]                           "", base::R.version$version.string), 
[13:23:05.301]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.301]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.301]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.301]                             "release", "version")], collapse = " "), 
[13:23:05.301]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.301]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.301]                           info)
[13:23:05.301]                         info <- base::paste(info, collapse = "; ")
[13:23:05.301]                         if (!has_future) {
[13:23:05.301]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.301]                             info)
[13:23:05.301]                         }
[13:23:05.301]                         else {
[13:23:05.301]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.301]                             info, version)
[13:23:05.301]                         }
[13:23:05.301]                         base::stop(msg)
[13:23:05.301]                       }
[13:23:05.301]                     })
[13:23:05.301]                   }
[13:23:05.301]                   options(future.plan = NULL)
[13:23:05.301]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.301]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.301]                 }
[13:23:05.301]                 ...future.workdir <- getwd()
[13:23:05.301]             }
[13:23:05.301]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.301]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.301]         }
[13:23:05.301]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.301]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.301]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.301]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.301]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.301]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.301]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.301]             base::names(...future.oldOptions))
[13:23:05.301]     }
[13:23:05.301]     if (FALSE) {
[13:23:05.301]     }
[13:23:05.301]     else {
[13:23:05.301]         if (TRUE) {
[13:23:05.301]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.301]                 open = "w")
[13:23:05.301]         }
[13:23:05.301]         else {
[13:23:05.301]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.301]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.301]         }
[13:23:05.301]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.301]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.301]             base::sink(type = "output", split = FALSE)
[13:23:05.301]             base::close(...future.stdout)
[13:23:05.301]         }, add = TRUE)
[13:23:05.301]     }
[13:23:05.301]     ...future.frame <- base::sys.nframe()
[13:23:05.301]     ...future.conditions <- base::list()
[13:23:05.301]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.301]     if (FALSE) {
[13:23:05.301]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.301]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.301]     }
[13:23:05.301]     ...future.result <- base::tryCatch({
[13:23:05.301]         base::withCallingHandlers({
[13:23:05.301]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.301]             future::FutureResult(value = ...future.value$value, 
[13:23:05.301]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.301]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.301]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.301]                     ...future.globalenv.names))
[13:23:05.301]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.301]         }, condition = base::local({
[13:23:05.301]             c <- base::c
[13:23:05.301]             inherits <- base::inherits
[13:23:05.301]             invokeRestart <- base::invokeRestart
[13:23:05.301]             length <- base::length
[13:23:05.301]             list <- base::list
[13:23:05.301]             seq.int <- base::seq.int
[13:23:05.301]             signalCondition <- base::signalCondition
[13:23:05.301]             sys.calls <- base::sys.calls
[13:23:05.301]             `[[` <- base::`[[`
[13:23:05.301]             `+` <- base::`+`
[13:23:05.301]             `<<-` <- base::`<<-`
[13:23:05.301]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.301]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.301]                   3L)]
[13:23:05.301]             }
[13:23:05.301]             function(cond) {
[13:23:05.301]                 is_error <- inherits(cond, "error")
[13:23:05.301]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.301]                   NULL)
[13:23:05.301]                 if (is_error) {
[13:23:05.301]                   sessionInformation <- function() {
[13:23:05.301]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.301]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.301]                       search = base::search(), system = base::Sys.info())
[13:23:05.301]                   }
[13:23:05.301]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.301]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.301]                     cond$call), session = sessionInformation(), 
[13:23:05.301]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.301]                   signalCondition(cond)
[13:23:05.301]                 }
[13:23:05.301]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.301]                 "immediateCondition"))) {
[13:23:05.301]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.301]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.301]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.301]                   if (TRUE && !signal) {
[13:23:05.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.301]                     {
[13:23:05.301]                       inherits <- base::inherits
[13:23:05.301]                       invokeRestart <- base::invokeRestart
[13:23:05.301]                       is.null <- base::is.null
[13:23:05.301]                       muffled <- FALSE
[13:23:05.301]                       if (inherits(cond, "message")) {
[13:23:05.301]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.301]                         if (muffled) 
[13:23:05.301]                           invokeRestart("muffleMessage")
[13:23:05.301]                       }
[13:23:05.301]                       else if (inherits(cond, "warning")) {
[13:23:05.301]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.301]                         if (muffled) 
[13:23:05.301]                           invokeRestart("muffleWarning")
[13:23:05.301]                       }
[13:23:05.301]                       else if (inherits(cond, "condition")) {
[13:23:05.301]                         if (!is.null(pattern)) {
[13:23:05.301]                           computeRestarts <- base::computeRestarts
[13:23:05.301]                           grepl <- base::grepl
[13:23:05.301]                           restarts <- computeRestarts(cond)
[13:23:05.301]                           for (restart in restarts) {
[13:23:05.301]                             name <- restart$name
[13:23:05.301]                             if (is.null(name)) 
[13:23:05.301]                               next
[13:23:05.301]                             if (!grepl(pattern, name)) 
[13:23:05.301]                               next
[13:23:05.301]                             invokeRestart(restart)
[13:23:05.301]                             muffled <- TRUE
[13:23:05.301]                             break
[13:23:05.301]                           }
[13:23:05.301]                         }
[13:23:05.301]                       }
[13:23:05.301]                       invisible(muffled)
[13:23:05.301]                     }
[13:23:05.301]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.301]                   }
[13:23:05.301]                 }
[13:23:05.301]                 else {
[13:23:05.301]                   if (TRUE) {
[13:23:05.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.301]                     {
[13:23:05.301]                       inherits <- base::inherits
[13:23:05.301]                       invokeRestart <- base::invokeRestart
[13:23:05.301]                       is.null <- base::is.null
[13:23:05.301]                       muffled <- FALSE
[13:23:05.301]                       if (inherits(cond, "message")) {
[13:23:05.301]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.301]                         if (muffled) 
[13:23:05.301]                           invokeRestart("muffleMessage")
[13:23:05.301]                       }
[13:23:05.301]                       else if (inherits(cond, "warning")) {
[13:23:05.301]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.301]                         if (muffled) 
[13:23:05.301]                           invokeRestart("muffleWarning")
[13:23:05.301]                       }
[13:23:05.301]                       else if (inherits(cond, "condition")) {
[13:23:05.301]                         if (!is.null(pattern)) {
[13:23:05.301]                           computeRestarts <- base::computeRestarts
[13:23:05.301]                           grepl <- base::grepl
[13:23:05.301]                           restarts <- computeRestarts(cond)
[13:23:05.301]                           for (restart in restarts) {
[13:23:05.301]                             name <- restart$name
[13:23:05.301]                             if (is.null(name)) 
[13:23:05.301]                               next
[13:23:05.301]                             if (!grepl(pattern, name)) 
[13:23:05.301]                               next
[13:23:05.301]                             invokeRestart(restart)
[13:23:05.301]                             muffled <- TRUE
[13:23:05.301]                             break
[13:23:05.301]                           }
[13:23:05.301]                         }
[13:23:05.301]                       }
[13:23:05.301]                       invisible(muffled)
[13:23:05.301]                     }
[13:23:05.301]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.301]                   }
[13:23:05.301]                 }
[13:23:05.301]             }
[13:23:05.301]         }))
[13:23:05.301]     }, error = function(ex) {
[13:23:05.301]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.301]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.301]                 ...future.rng), started = ...future.startTime, 
[13:23:05.301]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.301]             version = "1.8"), class = "FutureResult")
[13:23:05.301]     }, finally = {
[13:23:05.301]         if (!identical(...future.workdir, getwd())) 
[13:23:05.301]             setwd(...future.workdir)
[13:23:05.301]         {
[13:23:05.301]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.301]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.301]             }
[13:23:05.301]             base::options(...future.oldOptions)
[13:23:05.301]             if (.Platform$OS.type == "windows") {
[13:23:05.301]                 old_names <- names(...future.oldEnvVars)
[13:23:05.301]                 envs <- base::Sys.getenv()
[13:23:05.301]                 names <- names(envs)
[13:23:05.301]                 common <- intersect(names, old_names)
[13:23:05.301]                 added <- setdiff(names, old_names)
[13:23:05.301]                 removed <- setdiff(old_names, names)
[13:23:05.301]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.301]                   envs[common]]
[13:23:05.301]                 NAMES <- toupper(changed)
[13:23:05.301]                 args <- list()
[13:23:05.301]                 for (kk in seq_along(NAMES)) {
[13:23:05.301]                   name <- changed[[kk]]
[13:23:05.301]                   NAME <- NAMES[[kk]]
[13:23:05.301]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.301]                     next
[13:23:05.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.301]                 }
[13:23:05.301]                 NAMES <- toupper(added)
[13:23:05.301]                 for (kk in seq_along(NAMES)) {
[13:23:05.301]                   name <- added[[kk]]
[13:23:05.301]                   NAME <- NAMES[[kk]]
[13:23:05.301]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.301]                     next
[13:23:05.301]                   args[[name]] <- ""
[13:23:05.301]                 }
[13:23:05.301]                 NAMES <- toupper(removed)
[13:23:05.301]                 for (kk in seq_along(NAMES)) {
[13:23:05.301]                   name <- removed[[kk]]
[13:23:05.301]                   NAME <- NAMES[[kk]]
[13:23:05.301]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.301]                     next
[13:23:05.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.301]                 }
[13:23:05.301]                 if (length(args) > 0) 
[13:23:05.301]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.301]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.301]             }
[13:23:05.301]             else {
[13:23:05.301]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.301]             }
[13:23:05.301]             {
[13:23:05.301]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.301]                   0L) {
[13:23:05.301]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.301]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.301]                   base::options(opts)
[13:23:05.301]                 }
[13:23:05.301]                 {
[13:23:05.301]                   {
[13:23:05.301]                     NULL
[13:23:05.301]                     RNGkind("Mersenne-Twister")
[13:23:05.301]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.301]                       inherits = FALSE)
[13:23:05.301]                   }
[13:23:05.301]                   options(future.plan = NULL)
[13:23:05.301]                   if (is.na(NA_character_)) 
[13:23:05.301]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.301]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.301]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.301]                   {
[13:23:05.301]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.301]                     if (!future$lazy) 
[13:23:05.301]                       future <- run(future)
[13:23:05.301]                     invisible(future)
[13:23:05.301]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.301]                 }
[13:23:05.301]             }
[13:23:05.301]         }
[13:23:05.301]     })
[13:23:05.301]     if (TRUE) {
[13:23:05.301]         base::sink(type = "output", split = FALSE)
[13:23:05.301]         if (TRUE) {
[13:23:05.301]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.301]         }
[13:23:05.301]         else {
[13:23:05.301]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.301]         }
[13:23:05.301]         base::close(...future.stdout)
[13:23:05.301]         ...future.stdout <- NULL
[13:23:05.301]     }
[13:23:05.301]     ...future.result$conditions <- ...future.conditions
[13:23:05.301]     ...future.result$finished <- base::Sys.time()
[13:23:05.301]     ...future.result
[13:23:05.301] }
[13:23:05.303] plan(): Setting new future strategy stack:
[13:23:05.303] List of future strategies:
[13:23:05.303] 1. sequential:
[13:23:05.303]    - args: function (..., envir = parent.frame())
[13:23:05.303]    - tweaked: FALSE
[13:23:05.303]    - call: NULL
[13:23:05.304] plan(): nbrOfWorkers() = 1
[13:23:05.305] plan(): Setting new future strategy stack:
[13:23:05.305] List of future strategies:
[13:23:05.305] 1. sequential:
[13:23:05.305]    - args: function (..., envir = parent.frame())
[13:23:05.305]    - tweaked: FALSE
[13:23:05.305]    - call: plan(strategy)
[13:23:05.305] plan(): nbrOfWorkers() = 1
[13:23:05.305] SequentialFuture started (and completed)
[13:23:05.306] - Launch lazy future ... done
[13:23:05.306] run() for ‘SequentialFuture’ ... done
[13:23:05.306] getGlobalsAndPackages() ...
[13:23:05.306] Searching for globals...
[13:23:05.306] 
[13:23:05.306] Searching for globals ... DONE
[13:23:05.306] - globals: [0] <none>
[13:23:05.307] getGlobalsAndPackages() ... DONE
[13:23:05.307] run() for ‘Future’ ...
[13:23:05.307] - state: ‘created’
[13:23:05.307] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.307] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.308]   - Field: ‘label’
[13:23:05.308]   - Field: ‘local’
[13:23:05.308]   - Field: ‘owner’
[13:23:05.308]   - Field: ‘envir’
[13:23:05.308]   - Field: ‘packages’
[13:23:05.308]   - Field: ‘gc’
[13:23:05.308]   - Field: ‘conditions’
[13:23:05.308]   - Field: ‘expr’
[13:23:05.308]   - Field: ‘uuid’
[13:23:05.308]   - Field: ‘seed’
[13:23:05.309]   - Field: ‘version’
[13:23:05.309]   - Field: ‘result’
[13:23:05.309]   - Field: ‘asynchronous’
[13:23:05.309]   - Field: ‘calls’
[13:23:05.309]   - Field: ‘globals’
[13:23:05.309]   - Field: ‘stdout’
[13:23:05.309]   - Field: ‘earlySignal’
[13:23:05.309]   - Field: ‘lazy’
[13:23:05.309]   - Field: ‘state’
[13:23:05.309] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.310] - Launch lazy future ...
[13:23:05.310] Packages needed by the future expression (n = 0): <none>
[13:23:05.310] Packages needed by future strategies (n = 0): <none>
[13:23:05.310] {
[13:23:05.310]     {
[13:23:05.310]         {
[13:23:05.310]             ...future.startTime <- base::Sys.time()
[13:23:05.310]             {
[13:23:05.310]                 {
[13:23:05.310]                   {
[13:23:05.310]                     base::local({
[13:23:05.310]                       has_future <- base::requireNamespace("future", 
[13:23:05.310]                         quietly = TRUE)
[13:23:05.310]                       if (has_future) {
[13:23:05.310]                         ns <- base::getNamespace("future")
[13:23:05.310]                         version <- ns[[".package"]][["version"]]
[13:23:05.310]                         if (is.null(version)) 
[13:23:05.310]                           version <- utils::packageVersion("future")
[13:23:05.310]                       }
[13:23:05.310]                       else {
[13:23:05.310]                         version <- NULL
[13:23:05.310]                       }
[13:23:05.310]                       if (!has_future || version < "1.8.0") {
[13:23:05.310]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.310]                           "", base::R.version$version.string), 
[13:23:05.310]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.310]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.310]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.310]                             "release", "version")], collapse = " "), 
[13:23:05.310]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.310]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.310]                           info)
[13:23:05.310]                         info <- base::paste(info, collapse = "; ")
[13:23:05.310]                         if (!has_future) {
[13:23:05.310]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.310]                             info)
[13:23:05.310]                         }
[13:23:05.310]                         else {
[13:23:05.310]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.310]                             info, version)
[13:23:05.310]                         }
[13:23:05.310]                         base::stop(msg)
[13:23:05.310]                       }
[13:23:05.310]                     })
[13:23:05.310]                   }
[13:23:05.310]                   options(future.plan = NULL)
[13:23:05.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.310]                 }
[13:23:05.310]                 ...future.workdir <- getwd()
[13:23:05.310]             }
[13:23:05.310]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.310]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.310]         }
[13:23:05.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.310]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.310]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.310]             base::names(...future.oldOptions))
[13:23:05.310]     }
[13:23:05.310]     if (FALSE) {
[13:23:05.310]     }
[13:23:05.310]     else {
[13:23:05.310]         if (TRUE) {
[13:23:05.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.310]                 open = "w")
[13:23:05.310]         }
[13:23:05.310]         else {
[13:23:05.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.310]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.310]         }
[13:23:05.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.310]             base::sink(type = "output", split = FALSE)
[13:23:05.310]             base::close(...future.stdout)
[13:23:05.310]         }, add = TRUE)
[13:23:05.310]     }
[13:23:05.310]     ...future.frame <- base::sys.nframe()
[13:23:05.310]     ...future.conditions <- base::list()
[13:23:05.310]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.310]     if (FALSE) {
[13:23:05.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.310]     }
[13:23:05.310]     ...future.result <- base::tryCatch({
[13:23:05.310]         base::withCallingHandlers({
[13:23:05.310]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.310]             future::FutureResult(value = ...future.value$value, 
[13:23:05.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.310]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.310]                     ...future.globalenv.names))
[13:23:05.310]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.310]         }, condition = base::local({
[13:23:05.310]             c <- base::c
[13:23:05.310]             inherits <- base::inherits
[13:23:05.310]             invokeRestart <- base::invokeRestart
[13:23:05.310]             length <- base::length
[13:23:05.310]             list <- base::list
[13:23:05.310]             seq.int <- base::seq.int
[13:23:05.310]             signalCondition <- base::signalCondition
[13:23:05.310]             sys.calls <- base::sys.calls
[13:23:05.310]             `[[` <- base::`[[`
[13:23:05.310]             `+` <- base::`+`
[13:23:05.310]             `<<-` <- base::`<<-`
[13:23:05.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.310]                   3L)]
[13:23:05.310]             }
[13:23:05.310]             function(cond) {
[13:23:05.310]                 is_error <- inherits(cond, "error")
[13:23:05.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.310]                   NULL)
[13:23:05.310]                 if (is_error) {
[13:23:05.310]                   sessionInformation <- function() {
[13:23:05.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.310]                       search = base::search(), system = base::Sys.info())
[13:23:05.310]                   }
[13:23:05.310]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.310]                     cond$call), session = sessionInformation(), 
[13:23:05.310]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.310]                   signalCondition(cond)
[13:23:05.310]                 }
[13:23:05.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.310]                 "immediateCondition"))) {
[13:23:05.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.310]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.310]                   if (TRUE && !signal) {
[13:23:05.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.310]                     {
[13:23:05.310]                       inherits <- base::inherits
[13:23:05.310]                       invokeRestart <- base::invokeRestart
[13:23:05.310]                       is.null <- base::is.null
[13:23:05.310]                       muffled <- FALSE
[13:23:05.310]                       if (inherits(cond, "message")) {
[13:23:05.310]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.310]                         if (muffled) 
[13:23:05.310]                           invokeRestart("muffleMessage")
[13:23:05.310]                       }
[13:23:05.310]                       else if (inherits(cond, "warning")) {
[13:23:05.310]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.310]                         if (muffled) 
[13:23:05.310]                           invokeRestart("muffleWarning")
[13:23:05.310]                       }
[13:23:05.310]                       else if (inherits(cond, "condition")) {
[13:23:05.310]                         if (!is.null(pattern)) {
[13:23:05.310]                           computeRestarts <- base::computeRestarts
[13:23:05.310]                           grepl <- base::grepl
[13:23:05.310]                           restarts <- computeRestarts(cond)
[13:23:05.310]                           for (restart in restarts) {
[13:23:05.310]                             name <- restart$name
[13:23:05.310]                             if (is.null(name)) 
[13:23:05.310]                               next
[13:23:05.310]                             if (!grepl(pattern, name)) 
[13:23:05.310]                               next
[13:23:05.310]                             invokeRestart(restart)
[13:23:05.310]                             muffled <- TRUE
[13:23:05.310]                             break
[13:23:05.310]                           }
[13:23:05.310]                         }
[13:23:05.310]                       }
[13:23:05.310]                       invisible(muffled)
[13:23:05.310]                     }
[13:23:05.310]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.310]                   }
[13:23:05.310]                 }
[13:23:05.310]                 else {
[13:23:05.310]                   if (TRUE) {
[13:23:05.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.310]                     {
[13:23:05.310]                       inherits <- base::inherits
[13:23:05.310]                       invokeRestart <- base::invokeRestart
[13:23:05.310]                       is.null <- base::is.null
[13:23:05.310]                       muffled <- FALSE
[13:23:05.310]                       if (inherits(cond, "message")) {
[13:23:05.310]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.310]                         if (muffled) 
[13:23:05.310]                           invokeRestart("muffleMessage")
[13:23:05.310]                       }
[13:23:05.310]                       else if (inherits(cond, "warning")) {
[13:23:05.310]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.310]                         if (muffled) 
[13:23:05.310]                           invokeRestart("muffleWarning")
[13:23:05.310]                       }
[13:23:05.310]                       else if (inherits(cond, "condition")) {
[13:23:05.310]                         if (!is.null(pattern)) {
[13:23:05.310]                           computeRestarts <- base::computeRestarts
[13:23:05.310]                           grepl <- base::grepl
[13:23:05.310]                           restarts <- computeRestarts(cond)
[13:23:05.310]                           for (restart in restarts) {
[13:23:05.310]                             name <- restart$name
[13:23:05.310]                             if (is.null(name)) 
[13:23:05.310]                               next
[13:23:05.310]                             if (!grepl(pattern, name)) 
[13:23:05.310]                               next
[13:23:05.310]                             invokeRestart(restart)
[13:23:05.310]                             muffled <- TRUE
[13:23:05.310]                             break
[13:23:05.310]                           }
[13:23:05.310]                         }
[13:23:05.310]                       }
[13:23:05.310]                       invisible(muffled)
[13:23:05.310]                     }
[13:23:05.310]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.310]                   }
[13:23:05.310]                 }
[13:23:05.310]             }
[13:23:05.310]         }))
[13:23:05.310]     }, error = function(ex) {
[13:23:05.310]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.310]                 ...future.rng), started = ...future.startTime, 
[13:23:05.310]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.310]             version = "1.8"), class = "FutureResult")
[13:23:05.310]     }, finally = {
[13:23:05.310]         if (!identical(...future.workdir, getwd())) 
[13:23:05.310]             setwd(...future.workdir)
[13:23:05.310]         {
[13:23:05.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.310]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.310]             }
[13:23:05.310]             base::options(...future.oldOptions)
[13:23:05.310]             if (.Platform$OS.type == "windows") {
[13:23:05.310]                 old_names <- names(...future.oldEnvVars)
[13:23:05.310]                 envs <- base::Sys.getenv()
[13:23:05.310]                 names <- names(envs)
[13:23:05.310]                 common <- intersect(names, old_names)
[13:23:05.310]                 added <- setdiff(names, old_names)
[13:23:05.310]                 removed <- setdiff(old_names, names)
[13:23:05.310]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.310]                   envs[common]]
[13:23:05.310]                 NAMES <- toupper(changed)
[13:23:05.310]                 args <- list()
[13:23:05.310]                 for (kk in seq_along(NAMES)) {
[13:23:05.310]                   name <- changed[[kk]]
[13:23:05.310]                   NAME <- NAMES[[kk]]
[13:23:05.310]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.310]                     next
[13:23:05.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.310]                 }
[13:23:05.310]                 NAMES <- toupper(added)
[13:23:05.310]                 for (kk in seq_along(NAMES)) {
[13:23:05.310]                   name <- added[[kk]]
[13:23:05.310]                   NAME <- NAMES[[kk]]
[13:23:05.310]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.310]                     next
[13:23:05.310]                   args[[name]] <- ""
[13:23:05.310]                 }
[13:23:05.310]                 NAMES <- toupper(removed)
[13:23:05.310]                 for (kk in seq_along(NAMES)) {
[13:23:05.310]                   name <- removed[[kk]]
[13:23:05.310]                   NAME <- NAMES[[kk]]
[13:23:05.310]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.310]                     next
[13:23:05.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.310]                 }
[13:23:05.310]                 if (length(args) > 0) 
[13:23:05.310]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.310]             }
[13:23:05.310]             else {
[13:23:05.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.310]             }
[13:23:05.310]             {
[13:23:05.310]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.310]                   0L) {
[13:23:05.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.310]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.310]                   base::options(opts)
[13:23:05.310]                 }
[13:23:05.310]                 {
[13:23:05.310]                   {
[13:23:05.310]                     NULL
[13:23:05.310]                     RNGkind("Mersenne-Twister")
[13:23:05.310]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.310]                       inherits = FALSE)
[13:23:05.310]                   }
[13:23:05.310]                   options(future.plan = NULL)
[13:23:05.310]                   if (is.na(NA_character_)) 
[13:23:05.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.310]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.310]                   {
[13:23:05.310]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.310]                     if (!future$lazy) 
[13:23:05.310]                       future <- run(future)
[13:23:05.310]                     invisible(future)
[13:23:05.310]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.310]                 }
[13:23:05.310]             }
[13:23:05.310]         }
[13:23:05.310]     })
[13:23:05.310]     if (TRUE) {
[13:23:05.310]         base::sink(type = "output", split = FALSE)
[13:23:05.310]         if (TRUE) {
[13:23:05.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.310]         }
[13:23:05.310]         else {
[13:23:05.310]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.310]         }
[13:23:05.310]         base::close(...future.stdout)
[13:23:05.310]         ...future.stdout <- NULL
[13:23:05.310]     }
[13:23:05.310]     ...future.result$conditions <- ...future.conditions
[13:23:05.310]     ...future.result$finished <- base::Sys.time()
[13:23:05.310]     ...future.result
[13:23:05.310] }
[13:23:05.312] plan(): Setting new future strategy stack:
[13:23:05.312] List of future strategies:
[13:23:05.312] 1. sequential:
[13:23:05.312]    - args: function (..., envir = parent.frame())
[13:23:05.312]    - tweaked: FALSE
[13:23:05.312]    - call: NULL
[13:23:05.313] plan(): nbrOfWorkers() = 1
[13:23:05.314] plan(): Setting new future strategy stack:
[13:23:05.314] List of future strategies:
[13:23:05.314] 1. sequential:
[13:23:05.314]    - args: function (..., envir = parent.frame())
[13:23:05.314]    - tweaked: FALSE
[13:23:05.314]    - call: plan(strategy)
[13:23:05.314] plan(): nbrOfWorkers() = 1
[13:23:05.314] SequentialFuture started (and completed)
[13:23:05.314] - Launch lazy future ... done
[13:23:05.314] run() for ‘SequentialFuture’ ... done
[13:23:05.315] getGlobalsAndPackages() ...
[13:23:05.315] Searching for globals...
[13:23:05.315] - globals found: [1] ‘{’
[13:23:05.316] Searching for globals ... DONE
[13:23:05.316] Resolving globals: FALSE
[13:23:05.316] 
[13:23:05.316] 
[13:23:05.316] getGlobalsAndPackages() ... DONE
[13:23:05.316] run() for ‘Future’ ...
[13:23:05.317] - state: ‘created’
[13:23:05.317] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.317] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.317] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.317]   - Field: ‘label’
[13:23:05.317]   - Field: ‘local’
[13:23:05.317]   - Field: ‘owner’
[13:23:05.318]   - Field: ‘envir’
[13:23:05.318]   - Field: ‘packages’
[13:23:05.318]   - Field: ‘gc’
[13:23:05.318]   - Field: ‘conditions’
[13:23:05.318]   - Field: ‘expr’
[13:23:05.318]   - Field: ‘uuid’
[13:23:05.318]   - Field: ‘seed’
[13:23:05.318]   - Field: ‘version’
[13:23:05.318]   - Field: ‘result’
[13:23:05.318]   - Field: ‘asynchronous’
[13:23:05.318]   - Field: ‘calls’
[13:23:05.319]   - Field: ‘globals’
[13:23:05.319]   - Field: ‘stdout’
[13:23:05.319]   - Field: ‘earlySignal’
[13:23:05.319]   - Field: ‘lazy’
[13:23:05.319]   - Field: ‘state’
[13:23:05.319] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.319] - Launch lazy future ...
[13:23:05.319] Packages needed by the future expression (n = 0): <none>
[13:23:05.319] Packages needed by future strategies (n = 0): <none>
[13:23:05.320] {
[13:23:05.320]     {
[13:23:05.320]         {
[13:23:05.320]             ...future.startTime <- base::Sys.time()
[13:23:05.320]             {
[13:23:05.320]                 {
[13:23:05.320]                   {
[13:23:05.320]                     base::local({
[13:23:05.320]                       has_future <- base::requireNamespace("future", 
[13:23:05.320]                         quietly = TRUE)
[13:23:05.320]                       if (has_future) {
[13:23:05.320]                         ns <- base::getNamespace("future")
[13:23:05.320]                         version <- ns[[".package"]][["version"]]
[13:23:05.320]                         if (is.null(version)) 
[13:23:05.320]                           version <- utils::packageVersion("future")
[13:23:05.320]                       }
[13:23:05.320]                       else {
[13:23:05.320]                         version <- NULL
[13:23:05.320]                       }
[13:23:05.320]                       if (!has_future || version < "1.8.0") {
[13:23:05.320]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.320]                           "", base::R.version$version.string), 
[13:23:05.320]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.320]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.320]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.320]                             "release", "version")], collapse = " "), 
[13:23:05.320]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.320]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.320]                           info)
[13:23:05.320]                         info <- base::paste(info, collapse = "; ")
[13:23:05.320]                         if (!has_future) {
[13:23:05.320]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.320]                             info)
[13:23:05.320]                         }
[13:23:05.320]                         else {
[13:23:05.320]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.320]                             info, version)
[13:23:05.320]                         }
[13:23:05.320]                         base::stop(msg)
[13:23:05.320]                       }
[13:23:05.320]                     })
[13:23:05.320]                   }
[13:23:05.320]                   options(future.plan = NULL)
[13:23:05.320]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.320]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.320]                 }
[13:23:05.320]                 ...future.workdir <- getwd()
[13:23:05.320]             }
[13:23:05.320]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.320]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.320]         }
[13:23:05.320]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.320]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.320]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.320]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.320]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.320]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.320]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.320]             base::names(...future.oldOptions))
[13:23:05.320]     }
[13:23:05.320]     if (FALSE) {
[13:23:05.320]     }
[13:23:05.320]     else {
[13:23:05.320]         if (TRUE) {
[13:23:05.320]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.320]                 open = "w")
[13:23:05.320]         }
[13:23:05.320]         else {
[13:23:05.320]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.320]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.320]         }
[13:23:05.320]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.320]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.320]             base::sink(type = "output", split = FALSE)
[13:23:05.320]             base::close(...future.stdout)
[13:23:05.320]         }, add = TRUE)
[13:23:05.320]     }
[13:23:05.320]     ...future.frame <- base::sys.nframe()
[13:23:05.320]     ...future.conditions <- base::list()
[13:23:05.320]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.320]     if (FALSE) {
[13:23:05.320]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.320]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.320]     }
[13:23:05.320]     ...future.result <- base::tryCatch({
[13:23:05.320]         base::withCallingHandlers({
[13:23:05.320]             ...future.value <- base::withVisible(base::local({
[13:23:05.320]                 4
[13:23:05.320]             }))
[13:23:05.320]             future::FutureResult(value = ...future.value$value, 
[13:23:05.320]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.320]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.320]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.320]                     ...future.globalenv.names))
[13:23:05.320]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.320]         }, condition = base::local({
[13:23:05.320]             c <- base::c
[13:23:05.320]             inherits <- base::inherits
[13:23:05.320]             invokeRestart <- base::invokeRestart
[13:23:05.320]             length <- base::length
[13:23:05.320]             list <- base::list
[13:23:05.320]             seq.int <- base::seq.int
[13:23:05.320]             signalCondition <- base::signalCondition
[13:23:05.320]             sys.calls <- base::sys.calls
[13:23:05.320]             `[[` <- base::`[[`
[13:23:05.320]             `+` <- base::`+`
[13:23:05.320]             `<<-` <- base::`<<-`
[13:23:05.320]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.320]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.320]                   3L)]
[13:23:05.320]             }
[13:23:05.320]             function(cond) {
[13:23:05.320]                 is_error <- inherits(cond, "error")
[13:23:05.320]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.320]                   NULL)
[13:23:05.320]                 if (is_error) {
[13:23:05.320]                   sessionInformation <- function() {
[13:23:05.320]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.320]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.320]                       search = base::search(), system = base::Sys.info())
[13:23:05.320]                   }
[13:23:05.320]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.320]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.320]                     cond$call), session = sessionInformation(), 
[13:23:05.320]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.320]                   signalCondition(cond)
[13:23:05.320]                 }
[13:23:05.320]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.320]                 "immediateCondition"))) {
[13:23:05.320]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.320]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.320]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.320]                   if (TRUE && !signal) {
[13:23:05.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.320]                     {
[13:23:05.320]                       inherits <- base::inherits
[13:23:05.320]                       invokeRestart <- base::invokeRestart
[13:23:05.320]                       is.null <- base::is.null
[13:23:05.320]                       muffled <- FALSE
[13:23:05.320]                       if (inherits(cond, "message")) {
[13:23:05.320]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.320]                         if (muffled) 
[13:23:05.320]                           invokeRestart("muffleMessage")
[13:23:05.320]                       }
[13:23:05.320]                       else if (inherits(cond, "warning")) {
[13:23:05.320]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.320]                         if (muffled) 
[13:23:05.320]                           invokeRestart("muffleWarning")
[13:23:05.320]                       }
[13:23:05.320]                       else if (inherits(cond, "condition")) {
[13:23:05.320]                         if (!is.null(pattern)) {
[13:23:05.320]                           computeRestarts <- base::computeRestarts
[13:23:05.320]                           grepl <- base::grepl
[13:23:05.320]                           restarts <- computeRestarts(cond)
[13:23:05.320]                           for (restart in restarts) {
[13:23:05.320]                             name <- restart$name
[13:23:05.320]                             if (is.null(name)) 
[13:23:05.320]                               next
[13:23:05.320]                             if (!grepl(pattern, name)) 
[13:23:05.320]                               next
[13:23:05.320]                             invokeRestart(restart)
[13:23:05.320]                             muffled <- TRUE
[13:23:05.320]                             break
[13:23:05.320]                           }
[13:23:05.320]                         }
[13:23:05.320]                       }
[13:23:05.320]                       invisible(muffled)
[13:23:05.320]                     }
[13:23:05.320]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.320]                   }
[13:23:05.320]                 }
[13:23:05.320]                 else {
[13:23:05.320]                   if (TRUE) {
[13:23:05.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.320]                     {
[13:23:05.320]                       inherits <- base::inherits
[13:23:05.320]                       invokeRestart <- base::invokeRestart
[13:23:05.320]                       is.null <- base::is.null
[13:23:05.320]                       muffled <- FALSE
[13:23:05.320]                       if (inherits(cond, "message")) {
[13:23:05.320]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.320]                         if (muffled) 
[13:23:05.320]                           invokeRestart("muffleMessage")
[13:23:05.320]                       }
[13:23:05.320]                       else if (inherits(cond, "warning")) {
[13:23:05.320]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.320]                         if (muffled) 
[13:23:05.320]                           invokeRestart("muffleWarning")
[13:23:05.320]                       }
[13:23:05.320]                       else if (inherits(cond, "condition")) {
[13:23:05.320]                         if (!is.null(pattern)) {
[13:23:05.320]                           computeRestarts <- base::computeRestarts
[13:23:05.320]                           grepl <- base::grepl
[13:23:05.320]                           restarts <- computeRestarts(cond)
[13:23:05.320]                           for (restart in restarts) {
[13:23:05.320]                             name <- restart$name
[13:23:05.320]                             if (is.null(name)) 
[13:23:05.320]                               next
[13:23:05.320]                             if (!grepl(pattern, name)) 
[13:23:05.320]                               next
[13:23:05.320]                             invokeRestart(restart)
[13:23:05.320]                             muffled <- TRUE
[13:23:05.320]                             break
[13:23:05.320]                           }
[13:23:05.320]                         }
[13:23:05.320]                       }
[13:23:05.320]                       invisible(muffled)
[13:23:05.320]                     }
[13:23:05.320]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.320]                   }
[13:23:05.320]                 }
[13:23:05.320]             }
[13:23:05.320]         }))
[13:23:05.320]     }, error = function(ex) {
[13:23:05.320]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.320]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.320]                 ...future.rng), started = ...future.startTime, 
[13:23:05.320]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.320]             version = "1.8"), class = "FutureResult")
[13:23:05.320]     }, finally = {
[13:23:05.320]         if (!identical(...future.workdir, getwd())) 
[13:23:05.320]             setwd(...future.workdir)
[13:23:05.320]         {
[13:23:05.320]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.320]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.320]             }
[13:23:05.320]             base::options(...future.oldOptions)
[13:23:05.320]             if (.Platform$OS.type == "windows") {
[13:23:05.320]                 old_names <- names(...future.oldEnvVars)
[13:23:05.320]                 envs <- base::Sys.getenv()
[13:23:05.320]                 names <- names(envs)
[13:23:05.320]                 common <- intersect(names, old_names)
[13:23:05.320]                 added <- setdiff(names, old_names)
[13:23:05.320]                 removed <- setdiff(old_names, names)
[13:23:05.320]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.320]                   envs[common]]
[13:23:05.320]                 NAMES <- toupper(changed)
[13:23:05.320]                 args <- list()
[13:23:05.320]                 for (kk in seq_along(NAMES)) {
[13:23:05.320]                   name <- changed[[kk]]
[13:23:05.320]                   NAME <- NAMES[[kk]]
[13:23:05.320]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.320]                     next
[13:23:05.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.320]                 }
[13:23:05.320]                 NAMES <- toupper(added)
[13:23:05.320]                 for (kk in seq_along(NAMES)) {
[13:23:05.320]                   name <- added[[kk]]
[13:23:05.320]                   NAME <- NAMES[[kk]]
[13:23:05.320]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.320]                     next
[13:23:05.320]                   args[[name]] <- ""
[13:23:05.320]                 }
[13:23:05.320]                 NAMES <- toupper(removed)
[13:23:05.320]                 for (kk in seq_along(NAMES)) {
[13:23:05.320]                   name <- removed[[kk]]
[13:23:05.320]                   NAME <- NAMES[[kk]]
[13:23:05.320]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.320]                     next
[13:23:05.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.320]                 }
[13:23:05.320]                 if (length(args) > 0) 
[13:23:05.320]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.320]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.320]             }
[13:23:05.320]             else {
[13:23:05.320]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.320]             }
[13:23:05.320]             {
[13:23:05.320]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.320]                   0L) {
[13:23:05.320]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.320]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.320]                   base::options(opts)
[13:23:05.320]                 }
[13:23:05.320]                 {
[13:23:05.320]                   {
[13:23:05.320]                     NULL
[13:23:05.320]                     RNGkind("Mersenne-Twister")
[13:23:05.320]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.320]                       inherits = FALSE)
[13:23:05.320]                   }
[13:23:05.320]                   options(future.plan = NULL)
[13:23:05.320]                   if (is.na(NA_character_)) 
[13:23:05.320]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.320]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.320]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.320]                   {
[13:23:05.320]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.320]                     if (!future$lazy) 
[13:23:05.320]                       future <- run(future)
[13:23:05.320]                     invisible(future)
[13:23:05.320]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.320]                 }
[13:23:05.320]             }
[13:23:05.320]         }
[13:23:05.320]     })
[13:23:05.320]     if (TRUE) {
[13:23:05.320]         base::sink(type = "output", split = FALSE)
[13:23:05.320]         if (TRUE) {
[13:23:05.320]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.320]         }
[13:23:05.320]         else {
[13:23:05.320]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.320]         }
[13:23:05.320]         base::close(...future.stdout)
[13:23:05.320]         ...future.stdout <- NULL
[13:23:05.320]     }
[13:23:05.320]     ...future.result$conditions <- ...future.conditions
[13:23:05.320]     ...future.result$finished <- base::Sys.time()
[13:23:05.320]     ...future.result
[13:23:05.320] }
[13:23:05.322] plan(): Setting new future strategy stack:
[13:23:05.322] List of future strategies:
[13:23:05.322] 1. sequential:
[13:23:05.322]    - args: function (..., envir = parent.frame())
[13:23:05.322]    - tweaked: FALSE
[13:23:05.322]    - call: NULL
[13:23:05.322] plan(): nbrOfWorkers() = 1
[13:23:05.323] plan(): Setting new future strategy stack:
[13:23:05.323] List of future strategies:
[13:23:05.323] 1. sequential:
[13:23:05.323]    - args: function (..., envir = parent.frame())
[13:23:05.323]    - tweaked: FALSE
[13:23:05.323]    - call: plan(strategy)
[13:23:05.324] plan(): nbrOfWorkers() = 1
[13:23:05.324] SequentialFuture started (and completed)
[13:23:05.324] - Launch lazy future ... done
[13:23:05.324] run() for ‘SequentialFuture’ ... done
<environment: 0x5596d3aee868> 
<environment: 0x5596d4b69a98> 
[13:23:05.328] resolved() for ‘SequentialFuture’ ...
[13:23:05.328] - state: ‘finished’
[13:23:05.328] - run: TRUE
[13:23:05.328] - result: ‘FutureResult’
[13:23:05.328] resolved() for ‘SequentialFuture’ ... done
[13:23:05.328] resolved() for ‘SequentialFuture’ ...
[13:23:05.328] - state: ‘finished’
[13:23:05.328] - run: TRUE
[13:23:05.328] - result: ‘FutureResult’
[13:23:05.329] resolved() for ‘SequentialFuture’ ... done
[13:23:05.329] resolved() for ‘SequentialFuture’ ...
[13:23:05.329] - state: ‘finished’
[13:23:05.329] - run: TRUE
[13:23:05.329] - result: ‘FutureResult’
[13:23:05.329] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:05.330] resolve() on environment ...
[13:23:05.330]  recursive: 0
[13:23:05.331]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:05.331] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.331] - nx: 4
[13:23:05.331] - relay: TRUE
[13:23:05.331] - stdout: TRUE
[13:23:05.331] - signal: TRUE
[13:23:05.332] - resignal: FALSE
[13:23:05.332] - force: TRUE
[13:23:05.332] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.332] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.332]  - until=2
[13:23:05.332]  - relaying element #2
[13:23:05.332] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.332] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.332] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.332]  length: 3 (resolved future 1)
[13:23:05.333] resolved() for ‘SequentialFuture’ ...
[13:23:05.333] - state: ‘finished’
[13:23:05.333] - run: TRUE
[13:23:05.333] - result: ‘FutureResult’
[13:23:05.333] resolved() for ‘SequentialFuture’ ... done
[13:23:05.333] Future #2
[13:23:05.333] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.333] - nx: 4
[13:23:05.333] - relay: TRUE
[13:23:05.334] - stdout: TRUE
[13:23:05.334] - signal: TRUE
[13:23:05.334] - resignal: FALSE
[13:23:05.334] - force: TRUE
[13:23:05.334] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.334] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.334]  - until=2
[13:23:05.334]  - relaying element #2
[13:23:05.334] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.334] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.335] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.335]  length: 2 (resolved future 2)
[13:23:05.335] resolved() for ‘SequentialFuture’ ...
[13:23:05.335] - state: ‘finished’
[13:23:05.335] - run: TRUE
[13:23:05.335] - result: ‘FutureResult’
[13:23:05.335] resolved() for ‘SequentialFuture’ ... done
[13:23:05.335] Future #3
[13:23:05.335] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.335] - nx: 4
[13:23:05.336] - relay: TRUE
[13:23:05.336] - stdout: TRUE
[13:23:05.336] - signal: TRUE
[13:23:05.336] - resignal: FALSE
[13:23:05.336] - force: TRUE
[13:23:05.336] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.336] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.336]  - until=3
[13:23:05.336]  - relaying element #3
[13:23:05.336] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.337] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.337] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.337]  length: 1 (resolved future 3)
[13:23:05.337] resolved() for ‘SequentialFuture’ ...
[13:23:05.337] - state: ‘finished’
[13:23:05.337] - run: TRUE
[13:23:05.337] - result: ‘FutureResult’
[13:23:05.337] resolved() for ‘SequentialFuture’ ... done
[13:23:05.337] Future #4
[13:23:05.338] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.338] - nx: 4
[13:23:05.338] - relay: TRUE
[13:23:05.338] - stdout: TRUE
[13:23:05.338] - signal: TRUE
[13:23:05.338] - resignal: FALSE
[13:23:05.338] - force: TRUE
[13:23:05.338] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.338] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.338]  - until=4
[13:23:05.338]  - relaying element #4
[13:23:05.339] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.339] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.339] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.339]  length: 0 (resolved future 4)
[13:23:05.339] Relaying remaining futures
[13:23:05.339] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.339] - nx: 4
[13:23:05.339] - relay: TRUE
[13:23:05.339] - stdout: TRUE
[13:23:05.339] - signal: TRUE
[13:23:05.339] - resignal: FALSE
[13:23:05.340] - force: TRUE
[13:23:05.340] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.340] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:05.340] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.340] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.340] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.340] resolve() on environment ... DONE
<environment: 0x5596d383d8d8> 
Dimensions: c(2, 3, 1)
[13:23:05.341] getGlobalsAndPackages() ...
[13:23:05.341] Searching for globals...
[13:23:05.341] 
[13:23:05.341] Searching for globals ... DONE
[13:23:05.342] - globals: [0] <none>
[13:23:05.342] getGlobalsAndPackages() ... DONE
[13:23:05.342] run() for ‘Future’ ...
[13:23:05.342] - state: ‘created’
[13:23:05.342] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.342] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.343] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.343]   - Field: ‘label’
[13:23:05.343]   - Field: ‘local’
[13:23:05.343]   - Field: ‘owner’
[13:23:05.343]   - Field: ‘envir’
[13:23:05.343]   - Field: ‘packages’
[13:23:05.343]   - Field: ‘gc’
[13:23:05.343]   - Field: ‘conditions’
[13:23:05.343]   - Field: ‘expr’
[13:23:05.343]   - Field: ‘uuid’
[13:23:05.344]   - Field: ‘seed’
[13:23:05.344]   - Field: ‘version’
[13:23:05.344]   - Field: ‘result’
[13:23:05.344]   - Field: ‘asynchronous’
[13:23:05.344]   - Field: ‘calls’
[13:23:05.344]   - Field: ‘globals’
[13:23:05.344]   - Field: ‘stdout’
[13:23:05.344]   - Field: ‘earlySignal’
[13:23:05.344]   - Field: ‘lazy’
[13:23:05.344]   - Field: ‘state’
[13:23:05.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.345] - Launch lazy future ...
[13:23:05.345] Packages needed by the future expression (n = 0): <none>
[13:23:05.345] Packages needed by future strategies (n = 0): <none>
[13:23:05.345] {
[13:23:05.345]     {
[13:23:05.345]         {
[13:23:05.345]             ...future.startTime <- base::Sys.time()
[13:23:05.345]             {
[13:23:05.345]                 {
[13:23:05.345]                   {
[13:23:05.345]                     base::local({
[13:23:05.345]                       has_future <- base::requireNamespace("future", 
[13:23:05.345]                         quietly = TRUE)
[13:23:05.345]                       if (has_future) {
[13:23:05.345]                         ns <- base::getNamespace("future")
[13:23:05.345]                         version <- ns[[".package"]][["version"]]
[13:23:05.345]                         if (is.null(version)) 
[13:23:05.345]                           version <- utils::packageVersion("future")
[13:23:05.345]                       }
[13:23:05.345]                       else {
[13:23:05.345]                         version <- NULL
[13:23:05.345]                       }
[13:23:05.345]                       if (!has_future || version < "1.8.0") {
[13:23:05.345]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.345]                           "", base::R.version$version.string), 
[13:23:05.345]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.345]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.345]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.345]                             "release", "version")], collapse = " "), 
[13:23:05.345]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.345]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.345]                           info)
[13:23:05.345]                         info <- base::paste(info, collapse = "; ")
[13:23:05.345]                         if (!has_future) {
[13:23:05.345]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.345]                             info)
[13:23:05.345]                         }
[13:23:05.345]                         else {
[13:23:05.345]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.345]                             info, version)
[13:23:05.345]                         }
[13:23:05.345]                         base::stop(msg)
[13:23:05.345]                       }
[13:23:05.345]                     })
[13:23:05.345]                   }
[13:23:05.345]                   options(future.plan = NULL)
[13:23:05.345]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.345]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.345]                 }
[13:23:05.345]                 ...future.workdir <- getwd()
[13:23:05.345]             }
[13:23:05.345]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.345]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.345]         }
[13:23:05.345]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.345]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.345]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.345]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.345]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.345]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.345]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.345]             base::names(...future.oldOptions))
[13:23:05.345]     }
[13:23:05.345]     if (FALSE) {
[13:23:05.345]     }
[13:23:05.345]     else {
[13:23:05.345]         if (TRUE) {
[13:23:05.345]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.345]                 open = "w")
[13:23:05.345]         }
[13:23:05.345]         else {
[13:23:05.345]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.345]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.345]         }
[13:23:05.345]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.345]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.345]             base::sink(type = "output", split = FALSE)
[13:23:05.345]             base::close(...future.stdout)
[13:23:05.345]         }, add = TRUE)
[13:23:05.345]     }
[13:23:05.345]     ...future.frame <- base::sys.nframe()
[13:23:05.345]     ...future.conditions <- base::list()
[13:23:05.345]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.345]     if (FALSE) {
[13:23:05.345]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.345]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.345]     }
[13:23:05.345]     ...future.result <- base::tryCatch({
[13:23:05.345]         base::withCallingHandlers({
[13:23:05.345]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.345]             future::FutureResult(value = ...future.value$value, 
[13:23:05.345]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.345]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.345]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.345]                     ...future.globalenv.names))
[13:23:05.345]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.345]         }, condition = base::local({
[13:23:05.345]             c <- base::c
[13:23:05.345]             inherits <- base::inherits
[13:23:05.345]             invokeRestart <- base::invokeRestart
[13:23:05.345]             length <- base::length
[13:23:05.345]             list <- base::list
[13:23:05.345]             seq.int <- base::seq.int
[13:23:05.345]             signalCondition <- base::signalCondition
[13:23:05.345]             sys.calls <- base::sys.calls
[13:23:05.345]             `[[` <- base::`[[`
[13:23:05.345]             `+` <- base::`+`
[13:23:05.345]             `<<-` <- base::`<<-`
[13:23:05.345]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.345]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.345]                   3L)]
[13:23:05.345]             }
[13:23:05.345]             function(cond) {
[13:23:05.345]                 is_error <- inherits(cond, "error")
[13:23:05.345]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.345]                   NULL)
[13:23:05.345]                 if (is_error) {
[13:23:05.345]                   sessionInformation <- function() {
[13:23:05.345]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.345]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.345]                       search = base::search(), system = base::Sys.info())
[13:23:05.345]                   }
[13:23:05.345]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.345]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.345]                     cond$call), session = sessionInformation(), 
[13:23:05.345]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.345]                   signalCondition(cond)
[13:23:05.345]                 }
[13:23:05.345]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.345]                 "immediateCondition"))) {
[13:23:05.345]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.345]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.345]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.345]                   if (TRUE && !signal) {
[13:23:05.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.345]                     {
[13:23:05.345]                       inherits <- base::inherits
[13:23:05.345]                       invokeRestart <- base::invokeRestart
[13:23:05.345]                       is.null <- base::is.null
[13:23:05.345]                       muffled <- FALSE
[13:23:05.345]                       if (inherits(cond, "message")) {
[13:23:05.345]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.345]                         if (muffled) 
[13:23:05.345]                           invokeRestart("muffleMessage")
[13:23:05.345]                       }
[13:23:05.345]                       else if (inherits(cond, "warning")) {
[13:23:05.345]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.345]                         if (muffled) 
[13:23:05.345]                           invokeRestart("muffleWarning")
[13:23:05.345]                       }
[13:23:05.345]                       else if (inherits(cond, "condition")) {
[13:23:05.345]                         if (!is.null(pattern)) {
[13:23:05.345]                           computeRestarts <- base::computeRestarts
[13:23:05.345]                           grepl <- base::grepl
[13:23:05.345]                           restarts <- computeRestarts(cond)
[13:23:05.345]                           for (restart in restarts) {
[13:23:05.345]                             name <- restart$name
[13:23:05.345]                             if (is.null(name)) 
[13:23:05.345]                               next
[13:23:05.345]                             if (!grepl(pattern, name)) 
[13:23:05.345]                               next
[13:23:05.345]                             invokeRestart(restart)
[13:23:05.345]                             muffled <- TRUE
[13:23:05.345]                             break
[13:23:05.345]                           }
[13:23:05.345]                         }
[13:23:05.345]                       }
[13:23:05.345]                       invisible(muffled)
[13:23:05.345]                     }
[13:23:05.345]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.345]                   }
[13:23:05.345]                 }
[13:23:05.345]                 else {
[13:23:05.345]                   if (TRUE) {
[13:23:05.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.345]                     {
[13:23:05.345]                       inherits <- base::inherits
[13:23:05.345]                       invokeRestart <- base::invokeRestart
[13:23:05.345]                       is.null <- base::is.null
[13:23:05.345]                       muffled <- FALSE
[13:23:05.345]                       if (inherits(cond, "message")) {
[13:23:05.345]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.345]                         if (muffled) 
[13:23:05.345]                           invokeRestart("muffleMessage")
[13:23:05.345]                       }
[13:23:05.345]                       else if (inherits(cond, "warning")) {
[13:23:05.345]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.345]                         if (muffled) 
[13:23:05.345]                           invokeRestart("muffleWarning")
[13:23:05.345]                       }
[13:23:05.345]                       else if (inherits(cond, "condition")) {
[13:23:05.345]                         if (!is.null(pattern)) {
[13:23:05.345]                           computeRestarts <- base::computeRestarts
[13:23:05.345]                           grepl <- base::grepl
[13:23:05.345]                           restarts <- computeRestarts(cond)
[13:23:05.345]                           for (restart in restarts) {
[13:23:05.345]                             name <- restart$name
[13:23:05.345]                             if (is.null(name)) 
[13:23:05.345]                               next
[13:23:05.345]                             if (!grepl(pattern, name)) 
[13:23:05.345]                               next
[13:23:05.345]                             invokeRestart(restart)
[13:23:05.345]                             muffled <- TRUE
[13:23:05.345]                             break
[13:23:05.345]                           }
[13:23:05.345]                         }
[13:23:05.345]                       }
[13:23:05.345]                       invisible(muffled)
[13:23:05.345]                     }
[13:23:05.345]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.345]                   }
[13:23:05.345]                 }
[13:23:05.345]             }
[13:23:05.345]         }))
[13:23:05.345]     }, error = function(ex) {
[13:23:05.345]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.345]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.345]                 ...future.rng), started = ...future.startTime, 
[13:23:05.345]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.345]             version = "1.8"), class = "FutureResult")
[13:23:05.345]     }, finally = {
[13:23:05.345]         if (!identical(...future.workdir, getwd())) 
[13:23:05.345]             setwd(...future.workdir)
[13:23:05.345]         {
[13:23:05.345]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.345]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.345]             }
[13:23:05.345]             base::options(...future.oldOptions)
[13:23:05.345]             if (.Platform$OS.type == "windows") {
[13:23:05.345]                 old_names <- names(...future.oldEnvVars)
[13:23:05.345]                 envs <- base::Sys.getenv()
[13:23:05.345]                 names <- names(envs)
[13:23:05.345]                 common <- intersect(names, old_names)
[13:23:05.345]                 added <- setdiff(names, old_names)
[13:23:05.345]                 removed <- setdiff(old_names, names)
[13:23:05.345]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.345]                   envs[common]]
[13:23:05.345]                 NAMES <- toupper(changed)
[13:23:05.345]                 args <- list()
[13:23:05.345]                 for (kk in seq_along(NAMES)) {
[13:23:05.345]                   name <- changed[[kk]]
[13:23:05.345]                   NAME <- NAMES[[kk]]
[13:23:05.345]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.345]                     next
[13:23:05.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.345]                 }
[13:23:05.345]                 NAMES <- toupper(added)
[13:23:05.345]                 for (kk in seq_along(NAMES)) {
[13:23:05.345]                   name <- added[[kk]]
[13:23:05.345]                   NAME <- NAMES[[kk]]
[13:23:05.345]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.345]                     next
[13:23:05.345]                   args[[name]] <- ""
[13:23:05.345]                 }
[13:23:05.345]                 NAMES <- toupper(removed)
[13:23:05.345]                 for (kk in seq_along(NAMES)) {
[13:23:05.345]                   name <- removed[[kk]]
[13:23:05.345]                   NAME <- NAMES[[kk]]
[13:23:05.345]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.345]                     next
[13:23:05.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.345]                 }
[13:23:05.345]                 if (length(args) > 0) 
[13:23:05.345]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.345]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.345]             }
[13:23:05.345]             else {
[13:23:05.345]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.345]             }
[13:23:05.345]             {
[13:23:05.345]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.345]                   0L) {
[13:23:05.345]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.345]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.345]                   base::options(opts)
[13:23:05.345]                 }
[13:23:05.345]                 {
[13:23:05.345]                   {
[13:23:05.345]                     NULL
[13:23:05.345]                     RNGkind("Mersenne-Twister")
[13:23:05.345]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.345]                       inherits = FALSE)
[13:23:05.345]                   }
[13:23:05.345]                   options(future.plan = NULL)
[13:23:05.345]                   if (is.na(NA_character_)) 
[13:23:05.345]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.345]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.345]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.345]                   {
[13:23:05.345]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.345]                     if (!future$lazy) 
[13:23:05.345]                       future <- run(future)
[13:23:05.345]                     invisible(future)
[13:23:05.345]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.345]                 }
[13:23:05.345]             }
[13:23:05.345]         }
[13:23:05.345]     })
[13:23:05.345]     if (TRUE) {
[13:23:05.345]         base::sink(type = "output", split = FALSE)
[13:23:05.345]         if (TRUE) {
[13:23:05.345]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.345]         }
[13:23:05.345]         else {
[13:23:05.345]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.345]         }
[13:23:05.345]         base::close(...future.stdout)
[13:23:05.345]         ...future.stdout <- NULL
[13:23:05.345]     }
[13:23:05.345]     ...future.result$conditions <- ...future.conditions
[13:23:05.345]     ...future.result$finished <- base::Sys.time()
[13:23:05.345]     ...future.result
[13:23:05.345] }
[13:23:05.347] plan(): Setting new future strategy stack:
[13:23:05.347] List of future strategies:
[13:23:05.347] 1. sequential:
[13:23:05.347]    - args: function (..., envir = parent.frame())
[13:23:05.347]    - tweaked: FALSE
[13:23:05.347]    - call: NULL
[13:23:05.348] plan(): nbrOfWorkers() = 1
[13:23:05.349] plan(): Setting new future strategy stack:
[13:23:05.349] List of future strategies:
[13:23:05.349] 1. sequential:
[13:23:05.349]    - args: function (..., envir = parent.frame())
[13:23:05.349]    - tweaked: FALSE
[13:23:05.349]    - call: plan(strategy)
[13:23:05.349] plan(): nbrOfWorkers() = 1
[13:23:05.349] SequentialFuture started (and completed)
[13:23:05.349] - Launch lazy future ... done
[13:23:05.350] run() for ‘SequentialFuture’ ... done
[13:23:05.350] getGlobalsAndPackages() ...
[13:23:05.350] Searching for globals...
[13:23:05.350] 
[13:23:05.350] Searching for globals ... DONE
[13:23:05.350] - globals: [0] <none>
[13:23:05.350] getGlobalsAndPackages() ... DONE
[13:23:05.351] run() for ‘Future’ ...
[13:23:05.351] - state: ‘created’
[13:23:05.351] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.351] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.351] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.351]   - Field: ‘label’
[13:23:05.352]   - Field: ‘local’
[13:23:05.352]   - Field: ‘owner’
[13:23:05.352]   - Field: ‘envir’
[13:23:05.352]   - Field: ‘packages’
[13:23:05.352]   - Field: ‘gc’
[13:23:05.352]   - Field: ‘conditions’
[13:23:05.352]   - Field: ‘expr’
[13:23:05.352]   - Field: ‘uuid’
[13:23:05.352]   - Field: ‘seed’
[13:23:05.352]   - Field: ‘version’
[13:23:05.355]   - Field: ‘result’
[13:23:05.355]   - Field: ‘asynchronous’
[13:23:05.355]   - Field: ‘calls’
[13:23:05.355]   - Field: ‘globals’
[13:23:05.355]   - Field: ‘stdout’
[13:23:05.355]   - Field: ‘earlySignal’
[13:23:05.355]   - Field: ‘lazy’
[13:23:05.356]   - Field: ‘state’
[13:23:05.356] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.356] - Launch lazy future ...
[13:23:05.356] Packages needed by the future expression (n = 0): <none>
[13:23:05.356] Packages needed by future strategies (n = 0): <none>
[13:23:05.357] {
[13:23:05.357]     {
[13:23:05.357]         {
[13:23:05.357]             ...future.startTime <- base::Sys.time()
[13:23:05.357]             {
[13:23:05.357]                 {
[13:23:05.357]                   {
[13:23:05.357]                     base::local({
[13:23:05.357]                       has_future <- base::requireNamespace("future", 
[13:23:05.357]                         quietly = TRUE)
[13:23:05.357]                       if (has_future) {
[13:23:05.357]                         ns <- base::getNamespace("future")
[13:23:05.357]                         version <- ns[[".package"]][["version"]]
[13:23:05.357]                         if (is.null(version)) 
[13:23:05.357]                           version <- utils::packageVersion("future")
[13:23:05.357]                       }
[13:23:05.357]                       else {
[13:23:05.357]                         version <- NULL
[13:23:05.357]                       }
[13:23:05.357]                       if (!has_future || version < "1.8.0") {
[13:23:05.357]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.357]                           "", base::R.version$version.string), 
[13:23:05.357]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.357]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.357]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.357]                             "release", "version")], collapse = " "), 
[13:23:05.357]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.357]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.357]                           info)
[13:23:05.357]                         info <- base::paste(info, collapse = "; ")
[13:23:05.357]                         if (!has_future) {
[13:23:05.357]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.357]                             info)
[13:23:05.357]                         }
[13:23:05.357]                         else {
[13:23:05.357]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.357]                             info, version)
[13:23:05.357]                         }
[13:23:05.357]                         base::stop(msg)
[13:23:05.357]                       }
[13:23:05.357]                     })
[13:23:05.357]                   }
[13:23:05.357]                   options(future.plan = NULL)
[13:23:05.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.357]                 }
[13:23:05.357]                 ...future.workdir <- getwd()
[13:23:05.357]             }
[13:23:05.357]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.357]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.357]         }
[13:23:05.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.357]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.357]             base::names(...future.oldOptions))
[13:23:05.357]     }
[13:23:05.357]     if (FALSE) {
[13:23:05.357]     }
[13:23:05.357]     else {
[13:23:05.357]         if (TRUE) {
[13:23:05.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.357]                 open = "w")
[13:23:05.357]         }
[13:23:05.357]         else {
[13:23:05.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.357]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.357]         }
[13:23:05.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.357]             base::sink(type = "output", split = FALSE)
[13:23:05.357]             base::close(...future.stdout)
[13:23:05.357]         }, add = TRUE)
[13:23:05.357]     }
[13:23:05.357]     ...future.frame <- base::sys.nframe()
[13:23:05.357]     ...future.conditions <- base::list()
[13:23:05.357]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.357]     if (FALSE) {
[13:23:05.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.357]     }
[13:23:05.357]     ...future.result <- base::tryCatch({
[13:23:05.357]         base::withCallingHandlers({
[13:23:05.357]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.357]             future::FutureResult(value = ...future.value$value, 
[13:23:05.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.357]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.357]                     ...future.globalenv.names))
[13:23:05.357]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.357]         }, condition = base::local({
[13:23:05.357]             c <- base::c
[13:23:05.357]             inherits <- base::inherits
[13:23:05.357]             invokeRestart <- base::invokeRestart
[13:23:05.357]             length <- base::length
[13:23:05.357]             list <- base::list
[13:23:05.357]             seq.int <- base::seq.int
[13:23:05.357]             signalCondition <- base::signalCondition
[13:23:05.357]             sys.calls <- base::sys.calls
[13:23:05.357]             `[[` <- base::`[[`
[13:23:05.357]             `+` <- base::`+`
[13:23:05.357]             `<<-` <- base::`<<-`
[13:23:05.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.357]                   3L)]
[13:23:05.357]             }
[13:23:05.357]             function(cond) {
[13:23:05.357]                 is_error <- inherits(cond, "error")
[13:23:05.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.357]                   NULL)
[13:23:05.357]                 if (is_error) {
[13:23:05.357]                   sessionInformation <- function() {
[13:23:05.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.357]                       search = base::search(), system = base::Sys.info())
[13:23:05.357]                   }
[13:23:05.357]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.357]                     cond$call), session = sessionInformation(), 
[13:23:05.357]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.357]                   signalCondition(cond)
[13:23:05.357]                 }
[13:23:05.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.357]                 "immediateCondition"))) {
[13:23:05.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.357]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.357]                   if (TRUE && !signal) {
[13:23:05.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.357]                     {
[13:23:05.357]                       inherits <- base::inherits
[13:23:05.357]                       invokeRestart <- base::invokeRestart
[13:23:05.357]                       is.null <- base::is.null
[13:23:05.357]                       muffled <- FALSE
[13:23:05.357]                       if (inherits(cond, "message")) {
[13:23:05.357]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.357]                         if (muffled) 
[13:23:05.357]                           invokeRestart("muffleMessage")
[13:23:05.357]                       }
[13:23:05.357]                       else if (inherits(cond, "warning")) {
[13:23:05.357]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.357]                         if (muffled) 
[13:23:05.357]                           invokeRestart("muffleWarning")
[13:23:05.357]                       }
[13:23:05.357]                       else if (inherits(cond, "condition")) {
[13:23:05.357]                         if (!is.null(pattern)) {
[13:23:05.357]                           computeRestarts <- base::computeRestarts
[13:23:05.357]                           grepl <- base::grepl
[13:23:05.357]                           restarts <- computeRestarts(cond)
[13:23:05.357]                           for (restart in restarts) {
[13:23:05.357]                             name <- restart$name
[13:23:05.357]                             if (is.null(name)) 
[13:23:05.357]                               next
[13:23:05.357]                             if (!grepl(pattern, name)) 
[13:23:05.357]                               next
[13:23:05.357]                             invokeRestart(restart)
[13:23:05.357]                             muffled <- TRUE
[13:23:05.357]                             break
[13:23:05.357]                           }
[13:23:05.357]                         }
[13:23:05.357]                       }
[13:23:05.357]                       invisible(muffled)
[13:23:05.357]                     }
[13:23:05.357]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.357]                   }
[13:23:05.357]                 }
[13:23:05.357]                 else {
[13:23:05.357]                   if (TRUE) {
[13:23:05.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.357]                     {
[13:23:05.357]                       inherits <- base::inherits
[13:23:05.357]                       invokeRestart <- base::invokeRestart
[13:23:05.357]                       is.null <- base::is.null
[13:23:05.357]                       muffled <- FALSE
[13:23:05.357]                       if (inherits(cond, "message")) {
[13:23:05.357]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.357]                         if (muffled) 
[13:23:05.357]                           invokeRestart("muffleMessage")
[13:23:05.357]                       }
[13:23:05.357]                       else if (inherits(cond, "warning")) {
[13:23:05.357]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.357]                         if (muffled) 
[13:23:05.357]                           invokeRestart("muffleWarning")
[13:23:05.357]                       }
[13:23:05.357]                       else if (inherits(cond, "condition")) {
[13:23:05.357]                         if (!is.null(pattern)) {
[13:23:05.357]                           computeRestarts <- base::computeRestarts
[13:23:05.357]                           grepl <- base::grepl
[13:23:05.357]                           restarts <- computeRestarts(cond)
[13:23:05.357]                           for (restart in restarts) {
[13:23:05.357]                             name <- restart$name
[13:23:05.357]                             if (is.null(name)) 
[13:23:05.357]                               next
[13:23:05.357]                             if (!grepl(pattern, name)) 
[13:23:05.357]                               next
[13:23:05.357]                             invokeRestart(restart)
[13:23:05.357]                             muffled <- TRUE
[13:23:05.357]                             break
[13:23:05.357]                           }
[13:23:05.357]                         }
[13:23:05.357]                       }
[13:23:05.357]                       invisible(muffled)
[13:23:05.357]                     }
[13:23:05.357]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.357]                   }
[13:23:05.357]                 }
[13:23:05.357]             }
[13:23:05.357]         }))
[13:23:05.357]     }, error = function(ex) {
[13:23:05.357]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.357]                 ...future.rng), started = ...future.startTime, 
[13:23:05.357]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.357]             version = "1.8"), class = "FutureResult")
[13:23:05.357]     }, finally = {
[13:23:05.357]         if (!identical(...future.workdir, getwd())) 
[13:23:05.357]             setwd(...future.workdir)
[13:23:05.357]         {
[13:23:05.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.357]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.357]             }
[13:23:05.357]             base::options(...future.oldOptions)
[13:23:05.357]             if (.Platform$OS.type == "windows") {
[13:23:05.357]                 old_names <- names(...future.oldEnvVars)
[13:23:05.357]                 envs <- base::Sys.getenv()
[13:23:05.357]                 names <- names(envs)
[13:23:05.357]                 common <- intersect(names, old_names)
[13:23:05.357]                 added <- setdiff(names, old_names)
[13:23:05.357]                 removed <- setdiff(old_names, names)
[13:23:05.357]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.357]                   envs[common]]
[13:23:05.357]                 NAMES <- toupper(changed)
[13:23:05.357]                 args <- list()
[13:23:05.357]                 for (kk in seq_along(NAMES)) {
[13:23:05.357]                   name <- changed[[kk]]
[13:23:05.357]                   NAME <- NAMES[[kk]]
[13:23:05.357]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.357]                     next
[13:23:05.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.357]                 }
[13:23:05.357]                 NAMES <- toupper(added)
[13:23:05.357]                 for (kk in seq_along(NAMES)) {
[13:23:05.357]                   name <- added[[kk]]
[13:23:05.357]                   NAME <- NAMES[[kk]]
[13:23:05.357]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.357]                     next
[13:23:05.357]                   args[[name]] <- ""
[13:23:05.357]                 }
[13:23:05.357]                 NAMES <- toupper(removed)
[13:23:05.357]                 for (kk in seq_along(NAMES)) {
[13:23:05.357]                   name <- removed[[kk]]
[13:23:05.357]                   NAME <- NAMES[[kk]]
[13:23:05.357]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.357]                     next
[13:23:05.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.357]                 }
[13:23:05.357]                 if (length(args) > 0) 
[13:23:05.357]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.357]             }
[13:23:05.357]             else {
[13:23:05.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.357]             }
[13:23:05.357]             {
[13:23:05.357]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.357]                   0L) {
[13:23:05.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.357]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.357]                   base::options(opts)
[13:23:05.357]                 }
[13:23:05.357]                 {
[13:23:05.357]                   {
[13:23:05.357]                     NULL
[13:23:05.357]                     RNGkind("Mersenne-Twister")
[13:23:05.357]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.357]                       inherits = FALSE)
[13:23:05.357]                   }
[13:23:05.357]                   options(future.plan = NULL)
[13:23:05.357]                   if (is.na(NA_character_)) 
[13:23:05.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.357]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.357]                   {
[13:23:05.357]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.357]                     if (!future$lazy) 
[13:23:05.357]                       future <- run(future)
[13:23:05.357]                     invisible(future)
[13:23:05.357]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.357]                 }
[13:23:05.357]             }
[13:23:05.357]         }
[13:23:05.357]     })
[13:23:05.357]     if (TRUE) {
[13:23:05.357]         base::sink(type = "output", split = FALSE)
[13:23:05.357]         if (TRUE) {
[13:23:05.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.357]         }
[13:23:05.357]         else {
[13:23:05.357]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.357]         }
[13:23:05.357]         base::close(...future.stdout)
[13:23:05.357]         ...future.stdout <- NULL
[13:23:05.357]     }
[13:23:05.357]     ...future.result$conditions <- ...future.conditions
[13:23:05.357]     ...future.result$finished <- base::Sys.time()
[13:23:05.357]     ...future.result
[13:23:05.357] }
[13:23:05.359] plan(): Setting new future strategy stack:
[13:23:05.359] List of future strategies:
[13:23:05.359] 1. sequential:
[13:23:05.359]    - args: function (..., envir = parent.frame())
[13:23:05.359]    - tweaked: FALSE
[13:23:05.359]    - call: NULL
[13:23:05.359] plan(): nbrOfWorkers() = 1
[13:23:05.360] plan(): Setting new future strategy stack:
[13:23:05.360] List of future strategies:
[13:23:05.360] 1. sequential:
[13:23:05.360]    - args: function (..., envir = parent.frame())
[13:23:05.360]    - tweaked: FALSE
[13:23:05.360]    - call: plan(strategy)
[13:23:05.360] plan(): nbrOfWorkers() = 1
[13:23:05.361] SequentialFuture started (and completed)
[13:23:05.361] - Launch lazy future ... done
[13:23:05.361] run() for ‘SequentialFuture’ ... done
[13:23:05.361] getGlobalsAndPackages() ...
[13:23:05.361] Searching for globals...
[13:23:05.362] - globals found: [1] ‘{’
[13:23:05.362] Searching for globals ... DONE
[13:23:05.362] Resolving globals: FALSE
[13:23:05.363] 
[13:23:05.363] 
[13:23:05.363] getGlobalsAndPackages() ... DONE
[13:23:05.363] run() for ‘Future’ ...
[13:23:05.363] - state: ‘created’
[13:23:05.363] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.364] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.364]   - Field: ‘label’
[13:23:05.364]   - Field: ‘local’
[13:23:05.364]   - Field: ‘owner’
[13:23:05.364]   - Field: ‘envir’
[13:23:05.364]   - Field: ‘packages’
[13:23:05.364]   - Field: ‘gc’
[13:23:05.364]   - Field: ‘conditions’
[13:23:05.364]   - Field: ‘expr’
[13:23:05.365]   - Field: ‘uuid’
[13:23:05.365]   - Field: ‘seed’
[13:23:05.365]   - Field: ‘version’
[13:23:05.365]   - Field: ‘result’
[13:23:05.365]   - Field: ‘asynchronous’
[13:23:05.365]   - Field: ‘calls’
[13:23:05.365]   - Field: ‘globals’
[13:23:05.365]   - Field: ‘stdout’
[13:23:05.365]   - Field: ‘earlySignal’
[13:23:05.365]   - Field: ‘lazy’
[13:23:05.366]   - Field: ‘state’
[13:23:05.366] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.366] - Launch lazy future ...
[13:23:05.366] Packages needed by the future expression (n = 0): <none>
[13:23:05.366] Packages needed by future strategies (n = 0): <none>
[13:23:05.366] {
[13:23:05.366]     {
[13:23:05.366]         {
[13:23:05.366]             ...future.startTime <- base::Sys.time()
[13:23:05.366]             {
[13:23:05.366]                 {
[13:23:05.366]                   {
[13:23:05.366]                     base::local({
[13:23:05.366]                       has_future <- base::requireNamespace("future", 
[13:23:05.366]                         quietly = TRUE)
[13:23:05.366]                       if (has_future) {
[13:23:05.366]                         ns <- base::getNamespace("future")
[13:23:05.366]                         version <- ns[[".package"]][["version"]]
[13:23:05.366]                         if (is.null(version)) 
[13:23:05.366]                           version <- utils::packageVersion("future")
[13:23:05.366]                       }
[13:23:05.366]                       else {
[13:23:05.366]                         version <- NULL
[13:23:05.366]                       }
[13:23:05.366]                       if (!has_future || version < "1.8.0") {
[13:23:05.366]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.366]                           "", base::R.version$version.string), 
[13:23:05.366]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.366]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.366]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.366]                             "release", "version")], collapse = " "), 
[13:23:05.366]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.366]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.366]                           info)
[13:23:05.366]                         info <- base::paste(info, collapse = "; ")
[13:23:05.366]                         if (!has_future) {
[13:23:05.366]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.366]                             info)
[13:23:05.366]                         }
[13:23:05.366]                         else {
[13:23:05.366]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.366]                             info, version)
[13:23:05.366]                         }
[13:23:05.366]                         base::stop(msg)
[13:23:05.366]                       }
[13:23:05.366]                     })
[13:23:05.366]                   }
[13:23:05.366]                   options(future.plan = NULL)
[13:23:05.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.366]                 }
[13:23:05.366]                 ...future.workdir <- getwd()
[13:23:05.366]             }
[13:23:05.366]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.366]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.366]         }
[13:23:05.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.366]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.366]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.366]             base::names(...future.oldOptions))
[13:23:05.366]     }
[13:23:05.366]     if (FALSE) {
[13:23:05.366]     }
[13:23:05.366]     else {
[13:23:05.366]         if (TRUE) {
[13:23:05.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.366]                 open = "w")
[13:23:05.366]         }
[13:23:05.366]         else {
[13:23:05.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.366]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.366]         }
[13:23:05.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.366]             base::sink(type = "output", split = FALSE)
[13:23:05.366]             base::close(...future.stdout)
[13:23:05.366]         }, add = TRUE)
[13:23:05.366]     }
[13:23:05.366]     ...future.frame <- base::sys.nframe()
[13:23:05.366]     ...future.conditions <- base::list()
[13:23:05.366]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.366]     if (FALSE) {
[13:23:05.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.366]     }
[13:23:05.366]     ...future.result <- base::tryCatch({
[13:23:05.366]         base::withCallingHandlers({
[13:23:05.366]             ...future.value <- base::withVisible(base::local({
[13:23:05.366]                 4
[13:23:05.366]             }))
[13:23:05.366]             future::FutureResult(value = ...future.value$value, 
[13:23:05.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.366]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.366]                     ...future.globalenv.names))
[13:23:05.366]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.366]         }, condition = base::local({
[13:23:05.366]             c <- base::c
[13:23:05.366]             inherits <- base::inherits
[13:23:05.366]             invokeRestart <- base::invokeRestart
[13:23:05.366]             length <- base::length
[13:23:05.366]             list <- base::list
[13:23:05.366]             seq.int <- base::seq.int
[13:23:05.366]             signalCondition <- base::signalCondition
[13:23:05.366]             sys.calls <- base::sys.calls
[13:23:05.366]             `[[` <- base::`[[`
[13:23:05.366]             `+` <- base::`+`
[13:23:05.366]             `<<-` <- base::`<<-`
[13:23:05.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.366]                   3L)]
[13:23:05.366]             }
[13:23:05.366]             function(cond) {
[13:23:05.366]                 is_error <- inherits(cond, "error")
[13:23:05.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.366]                   NULL)
[13:23:05.366]                 if (is_error) {
[13:23:05.366]                   sessionInformation <- function() {
[13:23:05.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.366]                       search = base::search(), system = base::Sys.info())
[13:23:05.366]                   }
[13:23:05.366]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.366]                     cond$call), session = sessionInformation(), 
[13:23:05.366]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.366]                   signalCondition(cond)
[13:23:05.366]                 }
[13:23:05.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.366]                 "immediateCondition"))) {
[13:23:05.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.366]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.366]                   if (TRUE && !signal) {
[13:23:05.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.366]                     {
[13:23:05.366]                       inherits <- base::inherits
[13:23:05.366]                       invokeRestart <- base::invokeRestart
[13:23:05.366]                       is.null <- base::is.null
[13:23:05.366]                       muffled <- FALSE
[13:23:05.366]                       if (inherits(cond, "message")) {
[13:23:05.366]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.366]                         if (muffled) 
[13:23:05.366]                           invokeRestart("muffleMessage")
[13:23:05.366]                       }
[13:23:05.366]                       else if (inherits(cond, "warning")) {
[13:23:05.366]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.366]                         if (muffled) 
[13:23:05.366]                           invokeRestart("muffleWarning")
[13:23:05.366]                       }
[13:23:05.366]                       else if (inherits(cond, "condition")) {
[13:23:05.366]                         if (!is.null(pattern)) {
[13:23:05.366]                           computeRestarts <- base::computeRestarts
[13:23:05.366]                           grepl <- base::grepl
[13:23:05.366]                           restarts <- computeRestarts(cond)
[13:23:05.366]                           for (restart in restarts) {
[13:23:05.366]                             name <- restart$name
[13:23:05.366]                             if (is.null(name)) 
[13:23:05.366]                               next
[13:23:05.366]                             if (!grepl(pattern, name)) 
[13:23:05.366]                               next
[13:23:05.366]                             invokeRestart(restart)
[13:23:05.366]                             muffled <- TRUE
[13:23:05.366]                             break
[13:23:05.366]                           }
[13:23:05.366]                         }
[13:23:05.366]                       }
[13:23:05.366]                       invisible(muffled)
[13:23:05.366]                     }
[13:23:05.366]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.366]                   }
[13:23:05.366]                 }
[13:23:05.366]                 else {
[13:23:05.366]                   if (TRUE) {
[13:23:05.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.366]                     {
[13:23:05.366]                       inherits <- base::inherits
[13:23:05.366]                       invokeRestart <- base::invokeRestart
[13:23:05.366]                       is.null <- base::is.null
[13:23:05.366]                       muffled <- FALSE
[13:23:05.366]                       if (inherits(cond, "message")) {
[13:23:05.366]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.366]                         if (muffled) 
[13:23:05.366]                           invokeRestart("muffleMessage")
[13:23:05.366]                       }
[13:23:05.366]                       else if (inherits(cond, "warning")) {
[13:23:05.366]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.366]                         if (muffled) 
[13:23:05.366]                           invokeRestart("muffleWarning")
[13:23:05.366]                       }
[13:23:05.366]                       else if (inherits(cond, "condition")) {
[13:23:05.366]                         if (!is.null(pattern)) {
[13:23:05.366]                           computeRestarts <- base::computeRestarts
[13:23:05.366]                           grepl <- base::grepl
[13:23:05.366]                           restarts <- computeRestarts(cond)
[13:23:05.366]                           for (restart in restarts) {
[13:23:05.366]                             name <- restart$name
[13:23:05.366]                             if (is.null(name)) 
[13:23:05.366]                               next
[13:23:05.366]                             if (!grepl(pattern, name)) 
[13:23:05.366]                               next
[13:23:05.366]                             invokeRestart(restart)
[13:23:05.366]                             muffled <- TRUE
[13:23:05.366]                             break
[13:23:05.366]                           }
[13:23:05.366]                         }
[13:23:05.366]                       }
[13:23:05.366]                       invisible(muffled)
[13:23:05.366]                     }
[13:23:05.366]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.366]                   }
[13:23:05.366]                 }
[13:23:05.366]             }
[13:23:05.366]         }))
[13:23:05.366]     }, error = function(ex) {
[13:23:05.366]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.366]                 ...future.rng), started = ...future.startTime, 
[13:23:05.366]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.366]             version = "1.8"), class = "FutureResult")
[13:23:05.366]     }, finally = {
[13:23:05.366]         if (!identical(...future.workdir, getwd())) 
[13:23:05.366]             setwd(...future.workdir)
[13:23:05.366]         {
[13:23:05.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.366]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.366]             }
[13:23:05.366]             base::options(...future.oldOptions)
[13:23:05.366]             if (.Platform$OS.type == "windows") {
[13:23:05.366]                 old_names <- names(...future.oldEnvVars)
[13:23:05.366]                 envs <- base::Sys.getenv()
[13:23:05.366]                 names <- names(envs)
[13:23:05.366]                 common <- intersect(names, old_names)
[13:23:05.366]                 added <- setdiff(names, old_names)
[13:23:05.366]                 removed <- setdiff(old_names, names)
[13:23:05.366]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.366]                   envs[common]]
[13:23:05.366]                 NAMES <- toupper(changed)
[13:23:05.366]                 args <- list()
[13:23:05.366]                 for (kk in seq_along(NAMES)) {
[13:23:05.366]                   name <- changed[[kk]]
[13:23:05.366]                   NAME <- NAMES[[kk]]
[13:23:05.366]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.366]                     next
[13:23:05.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.366]                 }
[13:23:05.366]                 NAMES <- toupper(added)
[13:23:05.366]                 for (kk in seq_along(NAMES)) {
[13:23:05.366]                   name <- added[[kk]]
[13:23:05.366]                   NAME <- NAMES[[kk]]
[13:23:05.366]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.366]                     next
[13:23:05.366]                   args[[name]] <- ""
[13:23:05.366]                 }
[13:23:05.366]                 NAMES <- toupper(removed)
[13:23:05.366]                 for (kk in seq_along(NAMES)) {
[13:23:05.366]                   name <- removed[[kk]]
[13:23:05.366]                   NAME <- NAMES[[kk]]
[13:23:05.366]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.366]                     next
[13:23:05.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.366]                 }
[13:23:05.366]                 if (length(args) > 0) 
[13:23:05.366]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.366]             }
[13:23:05.366]             else {
[13:23:05.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.366]             }
[13:23:05.366]             {
[13:23:05.366]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.366]                   0L) {
[13:23:05.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.366]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.366]                   base::options(opts)
[13:23:05.366]                 }
[13:23:05.366]                 {
[13:23:05.366]                   {
[13:23:05.366]                     NULL
[13:23:05.366]                     RNGkind("Mersenne-Twister")
[13:23:05.366]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.366]                       inherits = FALSE)
[13:23:05.366]                   }
[13:23:05.366]                   options(future.plan = NULL)
[13:23:05.366]                   if (is.na(NA_character_)) 
[13:23:05.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.366]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.366]                   {
[13:23:05.366]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.366]                     if (!future$lazy) 
[13:23:05.366]                       future <- run(future)
[13:23:05.366]                     invisible(future)
[13:23:05.366]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.366]                 }
[13:23:05.366]             }
[13:23:05.366]         }
[13:23:05.366]     })
[13:23:05.366]     if (TRUE) {
[13:23:05.366]         base::sink(type = "output", split = FALSE)
[13:23:05.366]         if (TRUE) {
[13:23:05.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.366]         }
[13:23:05.366]         else {
[13:23:05.366]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.366]         }
[13:23:05.366]         base::close(...future.stdout)
[13:23:05.366]         ...future.stdout <- NULL
[13:23:05.366]     }
[13:23:05.366]     ...future.result$conditions <- ...future.conditions
[13:23:05.366]     ...future.result$finished <- base::Sys.time()
[13:23:05.366]     ...future.result
[13:23:05.366] }
[13:23:05.368] plan(): Setting new future strategy stack:
[13:23:05.368] List of future strategies:
[13:23:05.368] 1. sequential:
[13:23:05.368]    - args: function (..., envir = parent.frame())
[13:23:05.368]    - tweaked: FALSE
[13:23:05.368]    - call: NULL
[13:23:05.369] plan(): nbrOfWorkers() = 1
[13:23:05.370] plan(): Setting new future strategy stack:
[13:23:05.370] List of future strategies:
[13:23:05.370] 1. sequential:
[13:23:05.370]    - args: function (..., envir = parent.frame())
[13:23:05.370]    - tweaked: FALSE
[13:23:05.370]    - call: plan(strategy)
[13:23:05.370] plan(): nbrOfWorkers() = 1
[13:23:05.370] SequentialFuture started (and completed)
[13:23:05.370] - Launch lazy future ... done
[13:23:05.371] run() for ‘SequentialFuture’ ... done
<environment: 0x5596d55b5d08> 
<environment: 0x5596d54329c0> 
[13:23:05.372] resolved() for ‘SequentialFuture’ ...
[13:23:05.372] - state: ‘finished’
[13:23:05.372] - run: TRUE
[13:23:05.372] - result: ‘FutureResult’
[13:23:05.372] resolved() for ‘SequentialFuture’ ... done
[13:23:05.372] resolved() for ‘SequentialFuture’ ...
[13:23:05.373] - state: ‘finished’
[13:23:05.373] - run: TRUE
[13:23:05.373] - result: ‘FutureResult’
[13:23:05.373] resolved() for ‘SequentialFuture’ ... done
[13:23:05.373] resolved() for ‘SequentialFuture’ ...
[13:23:05.373] - state: ‘finished’
[13:23:05.373] - run: TRUE
[13:23:05.373] - result: ‘FutureResult’
[13:23:05.373] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:05.374] resolve() on environment ...
[13:23:05.375]  recursive: 0
[13:23:05.375]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:05.375] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.375] - nx: 4
[13:23:05.375] - relay: TRUE
[13:23:05.375] - stdout: TRUE
[13:23:05.376] - signal: TRUE
[13:23:05.376] - resignal: FALSE
[13:23:05.376] - force: TRUE
[13:23:05.376] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.376] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.376]  - until=2
[13:23:05.376]  - relaying element #2
[13:23:05.376] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.376] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.376] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.377]  length: 3 (resolved future 1)
[13:23:05.377] resolved() for ‘SequentialFuture’ ...
[13:23:05.377] - state: ‘finished’
[13:23:05.377] - run: TRUE
[13:23:05.377] - result: ‘FutureResult’
[13:23:05.377] resolved() for ‘SequentialFuture’ ... done
[13:23:05.377] Future #2
[13:23:05.377] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.377] - nx: 4
[13:23:05.377] - relay: TRUE
[13:23:05.378] - stdout: TRUE
[13:23:05.378] - signal: TRUE
[13:23:05.378] - resignal: FALSE
[13:23:05.378] - force: TRUE
[13:23:05.378] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.378] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.378]  - until=2
[13:23:05.378]  - relaying element #2
[13:23:05.378] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.378] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.379] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.379]  length: 2 (resolved future 2)
[13:23:05.379] resolved() for ‘SequentialFuture’ ...
[13:23:05.379] - state: ‘finished’
[13:23:05.379] - run: TRUE
[13:23:05.379] - result: ‘FutureResult’
[13:23:05.379] resolved() for ‘SequentialFuture’ ... done
[13:23:05.379] Future #3
[13:23:05.379] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.379] - nx: 4
[13:23:05.380] - relay: TRUE
[13:23:05.380] - stdout: TRUE
[13:23:05.380] - signal: TRUE
[13:23:05.380] - resignal: FALSE
[13:23:05.380] - force: TRUE
[13:23:05.380] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.380] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.380]  - until=3
[13:23:05.380]  - relaying element #3
[13:23:05.381] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.381] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.381] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.381]  length: 1 (resolved future 3)
[13:23:05.381] resolved() for ‘SequentialFuture’ ...
[13:23:05.381] - state: ‘finished’
[13:23:05.381] - run: TRUE
[13:23:05.382] - result: ‘FutureResult’
[13:23:05.382] resolved() for ‘SequentialFuture’ ... done
[13:23:05.382] Future #4
[13:23:05.382] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.382] - nx: 4
[13:23:05.382] - relay: TRUE
[13:23:05.382] - stdout: TRUE
[13:23:05.382] - signal: TRUE
[13:23:05.383] - resignal: FALSE
[13:23:05.383] - force: TRUE
[13:23:05.383] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.383] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.383]  - until=4
[13:23:05.383]  - relaying element #4
[13:23:05.383] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.386] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.386] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.386]  length: 0 (resolved future 4)
[13:23:05.386] Relaying remaining futures
[13:23:05.386] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.386] - nx: 4
[13:23:05.386] - relay: TRUE
[13:23:05.386] - stdout: TRUE
[13:23:05.386] - signal: TRUE
[13:23:05.386] - resignal: FALSE
[13:23:05.386] - force: TRUE
[13:23:05.387] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.387] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:05.387] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.387] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.387] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.387] resolve() on environment ... DONE
<environment: 0x5596d55d87b8> 
Dimensions: c(2, 1, 3, 1)
[13:23:05.388] getGlobalsAndPackages() ...
[13:23:05.388] Searching for globals...
[13:23:05.388] 
[13:23:05.388] Searching for globals ... DONE
[13:23:05.388] - globals: [0] <none>
[13:23:05.389] getGlobalsAndPackages() ... DONE
[13:23:05.389] run() for ‘Future’ ...
[13:23:05.389] - state: ‘created’
[13:23:05.389] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.390]   - Field: ‘label’
[13:23:05.390]   - Field: ‘local’
[13:23:05.390]   - Field: ‘owner’
[13:23:05.390]   - Field: ‘envir’
[13:23:05.390]   - Field: ‘packages’
[13:23:05.390]   - Field: ‘gc’
[13:23:05.390]   - Field: ‘conditions’
[13:23:05.390]   - Field: ‘expr’
[13:23:05.390]   - Field: ‘uuid’
[13:23:05.390]   - Field: ‘seed’
[13:23:05.391]   - Field: ‘version’
[13:23:05.391]   - Field: ‘result’
[13:23:05.391]   - Field: ‘asynchronous’
[13:23:05.391]   - Field: ‘calls’
[13:23:05.391]   - Field: ‘globals’
[13:23:05.391]   - Field: ‘stdout’
[13:23:05.391]   - Field: ‘earlySignal’
[13:23:05.391]   - Field: ‘lazy’
[13:23:05.391]   - Field: ‘state’
[13:23:05.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.391] - Launch lazy future ...
[13:23:05.392] Packages needed by the future expression (n = 0): <none>
[13:23:05.392] Packages needed by future strategies (n = 0): <none>
[13:23:05.392] {
[13:23:05.392]     {
[13:23:05.392]         {
[13:23:05.392]             ...future.startTime <- base::Sys.time()
[13:23:05.392]             {
[13:23:05.392]                 {
[13:23:05.392]                   {
[13:23:05.392]                     base::local({
[13:23:05.392]                       has_future <- base::requireNamespace("future", 
[13:23:05.392]                         quietly = TRUE)
[13:23:05.392]                       if (has_future) {
[13:23:05.392]                         ns <- base::getNamespace("future")
[13:23:05.392]                         version <- ns[[".package"]][["version"]]
[13:23:05.392]                         if (is.null(version)) 
[13:23:05.392]                           version <- utils::packageVersion("future")
[13:23:05.392]                       }
[13:23:05.392]                       else {
[13:23:05.392]                         version <- NULL
[13:23:05.392]                       }
[13:23:05.392]                       if (!has_future || version < "1.8.0") {
[13:23:05.392]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.392]                           "", base::R.version$version.string), 
[13:23:05.392]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.392]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.392]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.392]                             "release", "version")], collapse = " "), 
[13:23:05.392]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.392]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.392]                           info)
[13:23:05.392]                         info <- base::paste(info, collapse = "; ")
[13:23:05.392]                         if (!has_future) {
[13:23:05.392]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.392]                             info)
[13:23:05.392]                         }
[13:23:05.392]                         else {
[13:23:05.392]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.392]                             info, version)
[13:23:05.392]                         }
[13:23:05.392]                         base::stop(msg)
[13:23:05.392]                       }
[13:23:05.392]                     })
[13:23:05.392]                   }
[13:23:05.392]                   options(future.plan = NULL)
[13:23:05.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.392]                 }
[13:23:05.392]                 ...future.workdir <- getwd()
[13:23:05.392]             }
[13:23:05.392]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.392]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.392]         }
[13:23:05.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.392]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.392]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.392]             base::names(...future.oldOptions))
[13:23:05.392]     }
[13:23:05.392]     if (FALSE) {
[13:23:05.392]     }
[13:23:05.392]     else {
[13:23:05.392]         if (TRUE) {
[13:23:05.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.392]                 open = "w")
[13:23:05.392]         }
[13:23:05.392]         else {
[13:23:05.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.392]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.392]         }
[13:23:05.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.392]             base::sink(type = "output", split = FALSE)
[13:23:05.392]             base::close(...future.stdout)
[13:23:05.392]         }, add = TRUE)
[13:23:05.392]     }
[13:23:05.392]     ...future.frame <- base::sys.nframe()
[13:23:05.392]     ...future.conditions <- base::list()
[13:23:05.392]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.392]     if (FALSE) {
[13:23:05.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.392]     }
[13:23:05.392]     ...future.result <- base::tryCatch({
[13:23:05.392]         base::withCallingHandlers({
[13:23:05.392]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.392]             future::FutureResult(value = ...future.value$value, 
[13:23:05.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.392]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.392]                     ...future.globalenv.names))
[13:23:05.392]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.392]         }, condition = base::local({
[13:23:05.392]             c <- base::c
[13:23:05.392]             inherits <- base::inherits
[13:23:05.392]             invokeRestart <- base::invokeRestart
[13:23:05.392]             length <- base::length
[13:23:05.392]             list <- base::list
[13:23:05.392]             seq.int <- base::seq.int
[13:23:05.392]             signalCondition <- base::signalCondition
[13:23:05.392]             sys.calls <- base::sys.calls
[13:23:05.392]             `[[` <- base::`[[`
[13:23:05.392]             `+` <- base::`+`
[13:23:05.392]             `<<-` <- base::`<<-`
[13:23:05.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.392]                   3L)]
[13:23:05.392]             }
[13:23:05.392]             function(cond) {
[13:23:05.392]                 is_error <- inherits(cond, "error")
[13:23:05.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.392]                   NULL)
[13:23:05.392]                 if (is_error) {
[13:23:05.392]                   sessionInformation <- function() {
[13:23:05.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.392]                       search = base::search(), system = base::Sys.info())
[13:23:05.392]                   }
[13:23:05.392]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.392]                     cond$call), session = sessionInformation(), 
[13:23:05.392]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.392]                   signalCondition(cond)
[13:23:05.392]                 }
[13:23:05.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.392]                 "immediateCondition"))) {
[13:23:05.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.392]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.392]                   if (TRUE && !signal) {
[13:23:05.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.392]                     {
[13:23:05.392]                       inherits <- base::inherits
[13:23:05.392]                       invokeRestart <- base::invokeRestart
[13:23:05.392]                       is.null <- base::is.null
[13:23:05.392]                       muffled <- FALSE
[13:23:05.392]                       if (inherits(cond, "message")) {
[13:23:05.392]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.392]                         if (muffled) 
[13:23:05.392]                           invokeRestart("muffleMessage")
[13:23:05.392]                       }
[13:23:05.392]                       else if (inherits(cond, "warning")) {
[13:23:05.392]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.392]                         if (muffled) 
[13:23:05.392]                           invokeRestart("muffleWarning")
[13:23:05.392]                       }
[13:23:05.392]                       else if (inherits(cond, "condition")) {
[13:23:05.392]                         if (!is.null(pattern)) {
[13:23:05.392]                           computeRestarts <- base::computeRestarts
[13:23:05.392]                           grepl <- base::grepl
[13:23:05.392]                           restarts <- computeRestarts(cond)
[13:23:05.392]                           for (restart in restarts) {
[13:23:05.392]                             name <- restart$name
[13:23:05.392]                             if (is.null(name)) 
[13:23:05.392]                               next
[13:23:05.392]                             if (!grepl(pattern, name)) 
[13:23:05.392]                               next
[13:23:05.392]                             invokeRestart(restart)
[13:23:05.392]                             muffled <- TRUE
[13:23:05.392]                             break
[13:23:05.392]                           }
[13:23:05.392]                         }
[13:23:05.392]                       }
[13:23:05.392]                       invisible(muffled)
[13:23:05.392]                     }
[13:23:05.392]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.392]                   }
[13:23:05.392]                 }
[13:23:05.392]                 else {
[13:23:05.392]                   if (TRUE) {
[13:23:05.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.392]                     {
[13:23:05.392]                       inherits <- base::inherits
[13:23:05.392]                       invokeRestart <- base::invokeRestart
[13:23:05.392]                       is.null <- base::is.null
[13:23:05.392]                       muffled <- FALSE
[13:23:05.392]                       if (inherits(cond, "message")) {
[13:23:05.392]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.392]                         if (muffled) 
[13:23:05.392]                           invokeRestart("muffleMessage")
[13:23:05.392]                       }
[13:23:05.392]                       else if (inherits(cond, "warning")) {
[13:23:05.392]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.392]                         if (muffled) 
[13:23:05.392]                           invokeRestart("muffleWarning")
[13:23:05.392]                       }
[13:23:05.392]                       else if (inherits(cond, "condition")) {
[13:23:05.392]                         if (!is.null(pattern)) {
[13:23:05.392]                           computeRestarts <- base::computeRestarts
[13:23:05.392]                           grepl <- base::grepl
[13:23:05.392]                           restarts <- computeRestarts(cond)
[13:23:05.392]                           for (restart in restarts) {
[13:23:05.392]                             name <- restart$name
[13:23:05.392]                             if (is.null(name)) 
[13:23:05.392]                               next
[13:23:05.392]                             if (!grepl(pattern, name)) 
[13:23:05.392]                               next
[13:23:05.392]                             invokeRestart(restart)
[13:23:05.392]                             muffled <- TRUE
[13:23:05.392]                             break
[13:23:05.392]                           }
[13:23:05.392]                         }
[13:23:05.392]                       }
[13:23:05.392]                       invisible(muffled)
[13:23:05.392]                     }
[13:23:05.392]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.392]                   }
[13:23:05.392]                 }
[13:23:05.392]             }
[13:23:05.392]         }))
[13:23:05.392]     }, error = function(ex) {
[13:23:05.392]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.392]                 ...future.rng), started = ...future.startTime, 
[13:23:05.392]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.392]             version = "1.8"), class = "FutureResult")
[13:23:05.392]     }, finally = {
[13:23:05.392]         if (!identical(...future.workdir, getwd())) 
[13:23:05.392]             setwd(...future.workdir)
[13:23:05.392]         {
[13:23:05.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.392]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.392]             }
[13:23:05.392]             base::options(...future.oldOptions)
[13:23:05.392]             if (.Platform$OS.type == "windows") {
[13:23:05.392]                 old_names <- names(...future.oldEnvVars)
[13:23:05.392]                 envs <- base::Sys.getenv()
[13:23:05.392]                 names <- names(envs)
[13:23:05.392]                 common <- intersect(names, old_names)
[13:23:05.392]                 added <- setdiff(names, old_names)
[13:23:05.392]                 removed <- setdiff(old_names, names)
[13:23:05.392]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.392]                   envs[common]]
[13:23:05.392]                 NAMES <- toupper(changed)
[13:23:05.392]                 args <- list()
[13:23:05.392]                 for (kk in seq_along(NAMES)) {
[13:23:05.392]                   name <- changed[[kk]]
[13:23:05.392]                   NAME <- NAMES[[kk]]
[13:23:05.392]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.392]                     next
[13:23:05.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.392]                 }
[13:23:05.392]                 NAMES <- toupper(added)
[13:23:05.392]                 for (kk in seq_along(NAMES)) {
[13:23:05.392]                   name <- added[[kk]]
[13:23:05.392]                   NAME <- NAMES[[kk]]
[13:23:05.392]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.392]                     next
[13:23:05.392]                   args[[name]] <- ""
[13:23:05.392]                 }
[13:23:05.392]                 NAMES <- toupper(removed)
[13:23:05.392]                 for (kk in seq_along(NAMES)) {
[13:23:05.392]                   name <- removed[[kk]]
[13:23:05.392]                   NAME <- NAMES[[kk]]
[13:23:05.392]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.392]                     next
[13:23:05.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.392]                 }
[13:23:05.392]                 if (length(args) > 0) 
[13:23:05.392]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.392]             }
[13:23:05.392]             else {
[13:23:05.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.392]             }
[13:23:05.392]             {
[13:23:05.392]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.392]                   0L) {
[13:23:05.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.392]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.392]                   base::options(opts)
[13:23:05.392]                 }
[13:23:05.392]                 {
[13:23:05.392]                   {
[13:23:05.392]                     NULL
[13:23:05.392]                     RNGkind("Mersenne-Twister")
[13:23:05.392]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.392]                       inherits = FALSE)
[13:23:05.392]                   }
[13:23:05.392]                   options(future.plan = NULL)
[13:23:05.392]                   if (is.na(NA_character_)) 
[13:23:05.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.392]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.392]                   {
[13:23:05.392]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.392]                     if (!future$lazy) 
[13:23:05.392]                       future <- run(future)
[13:23:05.392]                     invisible(future)
[13:23:05.392]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.392]                 }
[13:23:05.392]             }
[13:23:05.392]         }
[13:23:05.392]     })
[13:23:05.392]     if (TRUE) {
[13:23:05.392]         base::sink(type = "output", split = FALSE)
[13:23:05.392]         if (TRUE) {
[13:23:05.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.392]         }
[13:23:05.392]         else {
[13:23:05.392]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.392]         }
[13:23:05.392]         base::close(...future.stdout)
[13:23:05.392]         ...future.stdout <- NULL
[13:23:05.392]     }
[13:23:05.392]     ...future.result$conditions <- ...future.conditions
[13:23:05.392]     ...future.result$finished <- base::Sys.time()
[13:23:05.392]     ...future.result
[13:23:05.392] }
[13:23:05.394] plan(): Setting new future strategy stack:
[13:23:05.394] List of future strategies:
[13:23:05.394] 1. sequential:
[13:23:05.394]    - args: function (..., envir = parent.frame())
[13:23:05.394]    - tweaked: FALSE
[13:23:05.394]    - call: NULL
[13:23:05.395] plan(): nbrOfWorkers() = 1
[13:23:05.396] plan(): Setting new future strategy stack:
[13:23:05.396] List of future strategies:
[13:23:05.396] 1. sequential:
[13:23:05.396]    - args: function (..., envir = parent.frame())
[13:23:05.396]    - tweaked: FALSE
[13:23:05.396]    - call: plan(strategy)
[13:23:05.396] plan(): nbrOfWorkers() = 1
[13:23:05.396] SequentialFuture started (and completed)
[13:23:05.396] - Launch lazy future ... done
[13:23:05.396] run() for ‘SequentialFuture’ ... done
[13:23:05.397] getGlobalsAndPackages() ...
[13:23:05.397] Searching for globals...
[13:23:05.397] 
[13:23:05.397] Searching for globals ... DONE
[13:23:05.397] - globals: [0] <none>
[13:23:05.397] getGlobalsAndPackages() ... DONE
[13:23:05.398] run() for ‘Future’ ...
[13:23:05.398] - state: ‘created’
[13:23:05.398] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.398] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.398]   - Field: ‘label’
[13:23:05.398]   - Field: ‘local’
[13:23:05.399]   - Field: ‘owner’
[13:23:05.399]   - Field: ‘envir’
[13:23:05.399]   - Field: ‘packages’
[13:23:05.399]   - Field: ‘gc’
[13:23:05.399]   - Field: ‘conditions’
[13:23:05.399]   - Field: ‘expr’
[13:23:05.399]   - Field: ‘uuid’
[13:23:05.399]   - Field: ‘seed’
[13:23:05.399]   - Field: ‘version’
[13:23:05.399]   - Field: ‘result’
[13:23:05.399]   - Field: ‘asynchronous’
[13:23:05.400]   - Field: ‘calls’
[13:23:05.400]   - Field: ‘globals’
[13:23:05.400]   - Field: ‘stdout’
[13:23:05.400]   - Field: ‘earlySignal’
[13:23:05.400]   - Field: ‘lazy’
[13:23:05.400]   - Field: ‘state’
[13:23:05.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.400] - Launch lazy future ...
[13:23:05.400] Packages needed by the future expression (n = 0): <none>
[13:23:05.401] Packages needed by future strategies (n = 0): <none>
[13:23:05.401] {
[13:23:05.401]     {
[13:23:05.401]         {
[13:23:05.401]             ...future.startTime <- base::Sys.time()
[13:23:05.401]             {
[13:23:05.401]                 {
[13:23:05.401]                   {
[13:23:05.401]                     base::local({
[13:23:05.401]                       has_future <- base::requireNamespace("future", 
[13:23:05.401]                         quietly = TRUE)
[13:23:05.401]                       if (has_future) {
[13:23:05.401]                         ns <- base::getNamespace("future")
[13:23:05.401]                         version <- ns[[".package"]][["version"]]
[13:23:05.401]                         if (is.null(version)) 
[13:23:05.401]                           version <- utils::packageVersion("future")
[13:23:05.401]                       }
[13:23:05.401]                       else {
[13:23:05.401]                         version <- NULL
[13:23:05.401]                       }
[13:23:05.401]                       if (!has_future || version < "1.8.0") {
[13:23:05.401]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.401]                           "", base::R.version$version.string), 
[13:23:05.401]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.401]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.401]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.401]                             "release", "version")], collapse = " "), 
[13:23:05.401]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.401]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.401]                           info)
[13:23:05.401]                         info <- base::paste(info, collapse = "; ")
[13:23:05.401]                         if (!has_future) {
[13:23:05.401]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.401]                             info)
[13:23:05.401]                         }
[13:23:05.401]                         else {
[13:23:05.401]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.401]                             info, version)
[13:23:05.401]                         }
[13:23:05.401]                         base::stop(msg)
[13:23:05.401]                       }
[13:23:05.401]                     })
[13:23:05.401]                   }
[13:23:05.401]                   options(future.plan = NULL)
[13:23:05.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.401]                 }
[13:23:05.401]                 ...future.workdir <- getwd()
[13:23:05.401]             }
[13:23:05.401]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.401]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.401]         }
[13:23:05.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.401]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.401]             base::names(...future.oldOptions))
[13:23:05.401]     }
[13:23:05.401]     if (FALSE) {
[13:23:05.401]     }
[13:23:05.401]     else {
[13:23:05.401]         if (TRUE) {
[13:23:05.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.401]                 open = "w")
[13:23:05.401]         }
[13:23:05.401]         else {
[13:23:05.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.401]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.401]         }
[13:23:05.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.401]             base::sink(type = "output", split = FALSE)
[13:23:05.401]             base::close(...future.stdout)
[13:23:05.401]         }, add = TRUE)
[13:23:05.401]     }
[13:23:05.401]     ...future.frame <- base::sys.nframe()
[13:23:05.401]     ...future.conditions <- base::list()
[13:23:05.401]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.401]     if (FALSE) {
[13:23:05.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.401]     }
[13:23:05.401]     ...future.result <- base::tryCatch({
[13:23:05.401]         base::withCallingHandlers({
[13:23:05.401]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.401]             future::FutureResult(value = ...future.value$value, 
[13:23:05.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.401]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.401]                     ...future.globalenv.names))
[13:23:05.401]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.401]         }, condition = base::local({
[13:23:05.401]             c <- base::c
[13:23:05.401]             inherits <- base::inherits
[13:23:05.401]             invokeRestart <- base::invokeRestart
[13:23:05.401]             length <- base::length
[13:23:05.401]             list <- base::list
[13:23:05.401]             seq.int <- base::seq.int
[13:23:05.401]             signalCondition <- base::signalCondition
[13:23:05.401]             sys.calls <- base::sys.calls
[13:23:05.401]             `[[` <- base::`[[`
[13:23:05.401]             `+` <- base::`+`
[13:23:05.401]             `<<-` <- base::`<<-`
[13:23:05.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.401]                   3L)]
[13:23:05.401]             }
[13:23:05.401]             function(cond) {
[13:23:05.401]                 is_error <- inherits(cond, "error")
[13:23:05.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.401]                   NULL)
[13:23:05.401]                 if (is_error) {
[13:23:05.401]                   sessionInformation <- function() {
[13:23:05.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.401]                       search = base::search(), system = base::Sys.info())
[13:23:05.401]                   }
[13:23:05.401]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.401]                     cond$call), session = sessionInformation(), 
[13:23:05.401]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.401]                   signalCondition(cond)
[13:23:05.401]                 }
[13:23:05.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.401]                 "immediateCondition"))) {
[13:23:05.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.401]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.401]                   if (TRUE && !signal) {
[13:23:05.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.401]                     {
[13:23:05.401]                       inherits <- base::inherits
[13:23:05.401]                       invokeRestart <- base::invokeRestart
[13:23:05.401]                       is.null <- base::is.null
[13:23:05.401]                       muffled <- FALSE
[13:23:05.401]                       if (inherits(cond, "message")) {
[13:23:05.401]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.401]                         if (muffled) 
[13:23:05.401]                           invokeRestart("muffleMessage")
[13:23:05.401]                       }
[13:23:05.401]                       else if (inherits(cond, "warning")) {
[13:23:05.401]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.401]                         if (muffled) 
[13:23:05.401]                           invokeRestart("muffleWarning")
[13:23:05.401]                       }
[13:23:05.401]                       else if (inherits(cond, "condition")) {
[13:23:05.401]                         if (!is.null(pattern)) {
[13:23:05.401]                           computeRestarts <- base::computeRestarts
[13:23:05.401]                           grepl <- base::grepl
[13:23:05.401]                           restarts <- computeRestarts(cond)
[13:23:05.401]                           for (restart in restarts) {
[13:23:05.401]                             name <- restart$name
[13:23:05.401]                             if (is.null(name)) 
[13:23:05.401]                               next
[13:23:05.401]                             if (!grepl(pattern, name)) 
[13:23:05.401]                               next
[13:23:05.401]                             invokeRestart(restart)
[13:23:05.401]                             muffled <- TRUE
[13:23:05.401]                             break
[13:23:05.401]                           }
[13:23:05.401]                         }
[13:23:05.401]                       }
[13:23:05.401]                       invisible(muffled)
[13:23:05.401]                     }
[13:23:05.401]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.401]                   }
[13:23:05.401]                 }
[13:23:05.401]                 else {
[13:23:05.401]                   if (TRUE) {
[13:23:05.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.401]                     {
[13:23:05.401]                       inherits <- base::inherits
[13:23:05.401]                       invokeRestart <- base::invokeRestart
[13:23:05.401]                       is.null <- base::is.null
[13:23:05.401]                       muffled <- FALSE
[13:23:05.401]                       if (inherits(cond, "message")) {
[13:23:05.401]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.401]                         if (muffled) 
[13:23:05.401]                           invokeRestart("muffleMessage")
[13:23:05.401]                       }
[13:23:05.401]                       else if (inherits(cond, "warning")) {
[13:23:05.401]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.401]                         if (muffled) 
[13:23:05.401]                           invokeRestart("muffleWarning")
[13:23:05.401]                       }
[13:23:05.401]                       else if (inherits(cond, "condition")) {
[13:23:05.401]                         if (!is.null(pattern)) {
[13:23:05.401]                           computeRestarts <- base::computeRestarts
[13:23:05.401]                           grepl <- base::grepl
[13:23:05.401]                           restarts <- computeRestarts(cond)
[13:23:05.401]                           for (restart in restarts) {
[13:23:05.401]                             name <- restart$name
[13:23:05.401]                             if (is.null(name)) 
[13:23:05.401]                               next
[13:23:05.401]                             if (!grepl(pattern, name)) 
[13:23:05.401]                               next
[13:23:05.401]                             invokeRestart(restart)
[13:23:05.401]                             muffled <- TRUE
[13:23:05.401]                             break
[13:23:05.401]                           }
[13:23:05.401]                         }
[13:23:05.401]                       }
[13:23:05.401]                       invisible(muffled)
[13:23:05.401]                     }
[13:23:05.401]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.401]                   }
[13:23:05.401]                 }
[13:23:05.401]             }
[13:23:05.401]         }))
[13:23:05.401]     }, error = function(ex) {
[13:23:05.401]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.401]                 ...future.rng), started = ...future.startTime, 
[13:23:05.401]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.401]             version = "1.8"), class = "FutureResult")
[13:23:05.401]     }, finally = {
[13:23:05.401]         if (!identical(...future.workdir, getwd())) 
[13:23:05.401]             setwd(...future.workdir)
[13:23:05.401]         {
[13:23:05.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.401]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.401]             }
[13:23:05.401]             base::options(...future.oldOptions)
[13:23:05.401]             if (.Platform$OS.type == "windows") {
[13:23:05.401]                 old_names <- names(...future.oldEnvVars)
[13:23:05.401]                 envs <- base::Sys.getenv()
[13:23:05.401]                 names <- names(envs)
[13:23:05.401]                 common <- intersect(names, old_names)
[13:23:05.401]                 added <- setdiff(names, old_names)
[13:23:05.401]                 removed <- setdiff(old_names, names)
[13:23:05.401]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.401]                   envs[common]]
[13:23:05.401]                 NAMES <- toupper(changed)
[13:23:05.401]                 args <- list()
[13:23:05.401]                 for (kk in seq_along(NAMES)) {
[13:23:05.401]                   name <- changed[[kk]]
[13:23:05.401]                   NAME <- NAMES[[kk]]
[13:23:05.401]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.401]                     next
[13:23:05.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.401]                 }
[13:23:05.401]                 NAMES <- toupper(added)
[13:23:05.401]                 for (kk in seq_along(NAMES)) {
[13:23:05.401]                   name <- added[[kk]]
[13:23:05.401]                   NAME <- NAMES[[kk]]
[13:23:05.401]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.401]                     next
[13:23:05.401]                   args[[name]] <- ""
[13:23:05.401]                 }
[13:23:05.401]                 NAMES <- toupper(removed)
[13:23:05.401]                 for (kk in seq_along(NAMES)) {
[13:23:05.401]                   name <- removed[[kk]]
[13:23:05.401]                   NAME <- NAMES[[kk]]
[13:23:05.401]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.401]                     next
[13:23:05.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.401]                 }
[13:23:05.401]                 if (length(args) > 0) 
[13:23:05.401]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.401]             }
[13:23:05.401]             else {
[13:23:05.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.401]             }
[13:23:05.401]             {
[13:23:05.401]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.401]                   0L) {
[13:23:05.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.401]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.401]                   base::options(opts)
[13:23:05.401]                 }
[13:23:05.401]                 {
[13:23:05.401]                   {
[13:23:05.401]                     NULL
[13:23:05.401]                     RNGkind("Mersenne-Twister")
[13:23:05.401]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.401]                       inherits = FALSE)
[13:23:05.401]                   }
[13:23:05.401]                   options(future.plan = NULL)
[13:23:05.401]                   if (is.na(NA_character_)) 
[13:23:05.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.401]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.401]                   {
[13:23:05.401]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.401]                     if (!future$lazy) 
[13:23:05.401]                       future <- run(future)
[13:23:05.401]                     invisible(future)
[13:23:05.401]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.401]                 }
[13:23:05.401]             }
[13:23:05.401]         }
[13:23:05.401]     })
[13:23:05.401]     if (TRUE) {
[13:23:05.401]         base::sink(type = "output", split = FALSE)
[13:23:05.401]         if (TRUE) {
[13:23:05.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.401]         }
[13:23:05.401]         else {
[13:23:05.401]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.401]         }
[13:23:05.401]         base::close(...future.stdout)
[13:23:05.401]         ...future.stdout <- NULL
[13:23:05.401]     }
[13:23:05.401]     ...future.result$conditions <- ...future.conditions
[13:23:05.401]     ...future.result$finished <- base::Sys.time()
[13:23:05.401]     ...future.result
[13:23:05.401] }
[13:23:05.403] plan(): Setting new future strategy stack:
[13:23:05.403] List of future strategies:
[13:23:05.403] 1. sequential:
[13:23:05.403]    - args: function (..., envir = parent.frame())
[13:23:05.403]    - tweaked: FALSE
[13:23:05.403]    - call: NULL
[13:23:05.403] plan(): nbrOfWorkers() = 1
[13:23:05.404] plan(): Setting new future strategy stack:
[13:23:05.404] List of future strategies:
[13:23:05.404] 1. sequential:
[13:23:05.404]    - args: function (..., envir = parent.frame())
[13:23:05.404]    - tweaked: FALSE
[13:23:05.404]    - call: plan(strategy)
[13:23:05.405] plan(): nbrOfWorkers() = 1
[13:23:05.405] SequentialFuture started (and completed)
[13:23:05.405] - Launch lazy future ... done
[13:23:05.405] run() for ‘SequentialFuture’ ... done
[13:23:05.405] getGlobalsAndPackages() ...
[13:23:05.406] Searching for globals...
[13:23:05.406] - globals found: [1] ‘{’
[13:23:05.406] Searching for globals ... DONE
[13:23:05.406] Resolving globals: FALSE
[13:23:05.407] 
[13:23:05.407] 
[13:23:05.407] getGlobalsAndPackages() ... DONE
[13:23:05.407] run() for ‘Future’ ...
[13:23:05.407] - state: ‘created’
[13:23:05.407] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.408]   - Field: ‘label’
[13:23:05.408]   - Field: ‘local’
[13:23:05.408]   - Field: ‘owner’
[13:23:05.408]   - Field: ‘envir’
[13:23:05.408]   - Field: ‘packages’
[13:23:05.408]   - Field: ‘gc’
[13:23:05.409]   - Field: ‘conditions’
[13:23:05.409]   - Field: ‘expr’
[13:23:05.409]   - Field: ‘uuid’
[13:23:05.409]   - Field: ‘seed’
[13:23:05.409]   - Field: ‘version’
[13:23:05.409]   - Field: ‘result’
[13:23:05.409]   - Field: ‘asynchronous’
[13:23:05.409]   - Field: ‘calls’
[13:23:05.409]   - Field: ‘globals’
[13:23:05.409]   - Field: ‘stdout’
[13:23:05.409]   - Field: ‘earlySignal’
[13:23:05.410]   - Field: ‘lazy’
[13:23:05.410]   - Field: ‘state’
[13:23:05.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.410] - Launch lazy future ...
[13:23:05.410] Packages needed by the future expression (n = 0): <none>
[13:23:05.410] Packages needed by future strategies (n = 0): <none>
[13:23:05.411] {
[13:23:05.411]     {
[13:23:05.411]         {
[13:23:05.411]             ...future.startTime <- base::Sys.time()
[13:23:05.411]             {
[13:23:05.411]                 {
[13:23:05.411]                   {
[13:23:05.411]                     base::local({
[13:23:05.411]                       has_future <- base::requireNamespace("future", 
[13:23:05.411]                         quietly = TRUE)
[13:23:05.411]                       if (has_future) {
[13:23:05.411]                         ns <- base::getNamespace("future")
[13:23:05.411]                         version <- ns[[".package"]][["version"]]
[13:23:05.411]                         if (is.null(version)) 
[13:23:05.411]                           version <- utils::packageVersion("future")
[13:23:05.411]                       }
[13:23:05.411]                       else {
[13:23:05.411]                         version <- NULL
[13:23:05.411]                       }
[13:23:05.411]                       if (!has_future || version < "1.8.0") {
[13:23:05.411]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.411]                           "", base::R.version$version.string), 
[13:23:05.411]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.411]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.411]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.411]                             "release", "version")], collapse = " "), 
[13:23:05.411]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.411]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.411]                           info)
[13:23:05.411]                         info <- base::paste(info, collapse = "; ")
[13:23:05.411]                         if (!has_future) {
[13:23:05.411]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.411]                             info)
[13:23:05.411]                         }
[13:23:05.411]                         else {
[13:23:05.411]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.411]                             info, version)
[13:23:05.411]                         }
[13:23:05.411]                         base::stop(msg)
[13:23:05.411]                       }
[13:23:05.411]                     })
[13:23:05.411]                   }
[13:23:05.411]                   options(future.plan = NULL)
[13:23:05.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.411]                 }
[13:23:05.411]                 ...future.workdir <- getwd()
[13:23:05.411]             }
[13:23:05.411]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.411]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.411]         }
[13:23:05.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.411]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.411]             base::names(...future.oldOptions))
[13:23:05.411]     }
[13:23:05.411]     if (FALSE) {
[13:23:05.411]     }
[13:23:05.411]     else {
[13:23:05.411]         if (TRUE) {
[13:23:05.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.411]                 open = "w")
[13:23:05.411]         }
[13:23:05.411]         else {
[13:23:05.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.411]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.411]         }
[13:23:05.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.411]             base::sink(type = "output", split = FALSE)
[13:23:05.411]             base::close(...future.stdout)
[13:23:05.411]         }, add = TRUE)
[13:23:05.411]     }
[13:23:05.411]     ...future.frame <- base::sys.nframe()
[13:23:05.411]     ...future.conditions <- base::list()
[13:23:05.411]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.411]     if (FALSE) {
[13:23:05.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.411]     }
[13:23:05.411]     ...future.result <- base::tryCatch({
[13:23:05.411]         base::withCallingHandlers({
[13:23:05.411]             ...future.value <- base::withVisible(base::local({
[13:23:05.411]                 4
[13:23:05.411]             }))
[13:23:05.411]             future::FutureResult(value = ...future.value$value, 
[13:23:05.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.411]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.411]                     ...future.globalenv.names))
[13:23:05.411]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.411]         }, condition = base::local({
[13:23:05.411]             c <- base::c
[13:23:05.411]             inherits <- base::inherits
[13:23:05.411]             invokeRestart <- base::invokeRestart
[13:23:05.411]             length <- base::length
[13:23:05.411]             list <- base::list
[13:23:05.411]             seq.int <- base::seq.int
[13:23:05.411]             signalCondition <- base::signalCondition
[13:23:05.411]             sys.calls <- base::sys.calls
[13:23:05.411]             `[[` <- base::`[[`
[13:23:05.411]             `+` <- base::`+`
[13:23:05.411]             `<<-` <- base::`<<-`
[13:23:05.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.411]                   3L)]
[13:23:05.411]             }
[13:23:05.411]             function(cond) {
[13:23:05.411]                 is_error <- inherits(cond, "error")
[13:23:05.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.411]                   NULL)
[13:23:05.411]                 if (is_error) {
[13:23:05.411]                   sessionInformation <- function() {
[13:23:05.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.411]                       search = base::search(), system = base::Sys.info())
[13:23:05.411]                   }
[13:23:05.411]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.411]                     cond$call), session = sessionInformation(), 
[13:23:05.411]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.411]                   signalCondition(cond)
[13:23:05.411]                 }
[13:23:05.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.411]                 "immediateCondition"))) {
[13:23:05.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.411]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.411]                   if (TRUE && !signal) {
[13:23:05.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.411]                     {
[13:23:05.411]                       inherits <- base::inherits
[13:23:05.411]                       invokeRestart <- base::invokeRestart
[13:23:05.411]                       is.null <- base::is.null
[13:23:05.411]                       muffled <- FALSE
[13:23:05.411]                       if (inherits(cond, "message")) {
[13:23:05.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.411]                         if (muffled) 
[13:23:05.411]                           invokeRestart("muffleMessage")
[13:23:05.411]                       }
[13:23:05.411]                       else if (inherits(cond, "warning")) {
[13:23:05.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.411]                         if (muffled) 
[13:23:05.411]                           invokeRestart("muffleWarning")
[13:23:05.411]                       }
[13:23:05.411]                       else if (inherits(cond, "condition")) {
[13:23:05.411]                         if (!is.null(pattern)) {
[13:23:05.411]                           computeRestarts <- base::computeRestarts
[13:23:05.411]                           grepl <- base::grepl
[13:23:05.411]                           restarts <- computeRestarts(cond)
[13:23:05.411]                           for (restart in restarts) {
[13:23:05.411]                             name <- restart$name
[13:23:05.411]                             if (is.null(name)) 
[13:23:05.411]                               next
[13:23:05.411]                             if (!grepl(pattern, name)) 
[13:23:05.411]                               next
[13:23:05.411]                             invokeRestart(restart)
[13:23:05.411]                             muffled <- TRUE
[13:23:05.411]                             break
[13:23:05.411]                           }
[13:23:05.411]                         }
[13:23:05.411]                       }
[13:23:05.411]                       invisible(muffled)
[13:23:05.411]                     }
[13:23:05.411]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.411]                   }
[13:23:05.411]                 }
[13:23:05.411]                 else {
[13:23:05.411]                   if (TRUE) {
[13:23:05.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.411]                     {
[13:23:05.411]                       inherits <- base::inherits
[13:23:05.411]                       invokeRestart <- base::invokeRestart
[13:23:05.411]                       is.null <- base::is.null
[13:23:05.411]                       muffled <- FALSE
[13:23:05.411]                       if (inherits(cond, "message")) {
[13:23:05.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.411]                         if (muffled) 
[13:23:05.411]                           invokeRestart("muffleMessage")
[13:23:05.411]                       }
[13:23:05.411]                       else if (inherits(cond, "warning")) {
[13:23:05.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.411]                         if (muffled) 
[13:23:05.411]                           invokeRestart("muffleWarning")
[13:23:05.411]                       }
[13:23:05.411]                       else if (inherits(cond, "condition")) {
[13:23:05.411]                         if (!is.null(pattern)) {
[13:23:05.411]                           computeRestarts <- base::computeRestarts
[13:23:05.411]                           grepl <- base::grepl
[13:23:05.411]                           restarts <- computeRestarts(cond)
[13:23:05.411]                           for (restart in restarts) {
[13:23:05.411]                             name <- restart$name
[13:23:05.411]                             if (is.null(name)) 
[13:23:05.411]                               next
[13:23:05.411]                             if (!grepl(pattern, name)) 
[13:23:05.411]                               next
[13:23:05.411]                             invokeRestart(restart)
[13:23:05.411]                             muffled <- TRUE
[13:23:05.411]                             break
[13:23:05.411]                           }
[13:23:05.411]                         }
[13:23:05.411]                       }
[13:23:05.411]                       invisible(muffled)
[13:23:05.411]                     }
[13:23:05.411]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.411]                   }
[13:23:05.411]                 }
[13:23:05.411]             }
[13:23:05.411]         }))
[13:23:05.411]     }, error = function(ex) {
[13:23:05.411]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.411]                 ...future.rng), started = ...future.startTime, 
[13:23:05.411]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.411]             version = "1.8"), class = "FutureResult")
[13:23:05.411]     }, finally = {
[13:23:05.411]         if (!identical(...future.workdir, getwd())) 
[13:23:05.411]             setwd(...future.workdir)
[13:23:05.411]         {
[13:23:05.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.411]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.411]             }
[13:23:05.411]             base::options(...future.oldOptions)
[13:23:05.411]             if (.Platform$OS.type == "windows") {
[13:23:05.411]                 old_names <- names(...future.oldEnvVars)
[13:23:05.411]                 envs <- base::Sys.getenv()
[13:23:05.411]                 names <- names(envs)
[13:23:05.411]                 common <- intersect(names, old_names)
[13:23:05.411]                 added <- setdiff(names, old_names)
[13:23:05.411]                 removed <- setdiff(old_names, names)
[13:23:05.411]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.411]                   envs[common]]
[13:23:05.411]                 NAMES <- toupper(changed)
[13:23:05.411]                 args <- list()
[13:23:05.411]                 for (kk in seq_along(NAMES)) {
[13:23:05.411]                   name <- changed[[kk]]
[13:23:05.411]                   NAME <- NAMES[[kk]]
[13:23:05.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.411]                     next
[13:23:05.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.411]                 }
[13:23:05.411]                 NAMES <- toupper(added)
[13:23:05.411]                 for (kk in seq_along(NAMES)) {
[13:23:05.411]                   name <- added[[kk]]
[13:23:05.411]                   NAME <- NAMES[[kk]]
[13:23:05.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.411]                     next
[13:23:05.411]                   args[[name]] <- ""
[13:23:05.411]                 }
[13:23:05.411]                 NAMES <- toupper(removed)
[13:23:05.411]                 for (kk in seq_along(NAMES)) {
[13:23:05.411]                   name <- removed[[kk]]
[13:23:05.411]                   NAME <- NAMES[[kk]]
[13:23:05.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.411]                     next
[13:23:05.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.411]                 }
[13:23:05.411]                 if (length(args) > 0) 
[13:23:05.411]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.411]             }
[13:23:05.411]             else {
[13:23:05.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.411]             }
[13:23:05.411]             {
[13:23:05.411]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.411]                   0L) {
[13:23:05.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.411]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.411]                   base::options(opts)
[13:23:05.411]                 }
[13:23:05.411]                 {
[13:23:05.411]                   {
[13:23:05.411]                     NULL
[13:23:05.411]                     RNGkind("Mersenne-Twister")
[13:23:05.411]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.411]                       inherits = FALSE)
[13:23:05.411]                   }
[13:23:05.411]                   options(future.plan = NULL)
[13:23:05.411]                   if (is.na(NA_character_)) 
[13:23:05.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.411]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.411]                   {
[13:23:05.411]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.411]                     if (!future$lazy) 
[13:23:05.411]                       future <- run(future)
[13:23:05.411]                     invisible(future)
[13:23:05.411]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.411]                 }
[13:23:05.411]             }
[13:23:05.411]         }
[13:23:05.411]     })
[13:23:05.411]     if (TRUE) {
[13:23:05.411]         base::sink(type = "output", split = FALSE)
[13:23:05.411]         if (TRUE) {
[13:23:05.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.411]         }
[13:23:05.411]         else {
[13:23:05.411]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.411]         }
[13:23:05.411]         base::close(...future.stdout)
[13:23:05.411]         ...future.stdout <- NULL
[13:23:05.411]     }
[13:23:05.411]     ...future.result$conditions <- ...future.conditions
[13:23:05.411]     ...future.result$finished <- base::Sys.time()
[13:23:05.411]     ...future.result
[13:23:05.411] }
[13:23:05.413] plan(): Setting new future strategy stack:
[13:23:05.413] List of future strategies:
[13:23:05.413] 1. sequential:
[13:23:05.413]    - args: function (..., envir = parent.frame())
[13:23:05.413]    - tweaked: FALSE
[13:23:05.413]    - call: NULL
[13:23:05.413] plan(): nbrOfWorkers() = 1
[13:23:05.414] plan(): Setting new future strategy stack:
[13:23:05.414] List of future strategies:
[13:23:05.414] 1. sequential:
[13:23:05.414]    - args: function (..., envir = parent.frame())
[13:23:05.414]    - tweaked: FALSE
[13:23:05.414]    - call: plan(strategy)
[13:23:05.414] plan(): nbrOfWorkers() = 1
[13:23:05.415] SequentialFuture started (and completed)
[13:23:05.415] - Launch lazy future ... done
[13:23:05.415] run() for ‘SequentialFuture’ ... done
<environment: 0x5596d3f89388> 
<environment: 0x5596d5c40388> 
[13:23:05.419] resolved() for ‘SequentialFuture’ ...
[13:23:05.419] - state: ‘finished’
[13:23:05.419] - run: TRUE
[13:23:05.419] - result: ‘FutureResult’
[13:23:05.419] resolved() for ‘SequentialFuture’ ... done
[13:23:05.419] resolved() for ‘SequentialFuture’ ...
[13:23:05.420] - state: ‘finished’
[13:23:05.420] - run: TRUE
[13:23:05.420] - result: ‘FutureResult’
[13:23:05.420] resolved() for ‘SequentialFuture’ ... done
[13:23:05.420] resolved() for ‘SequentialFuture’ ...
[13:23:05.420] - state: ‘finished’
[13:23:05.420] - run: TRUE
[13:23:05.420] - result: ‘FutureResult’
[13:23:05.420] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:05.422] resolve() on environment ...
[13:23:05.422]  recursive: 0
[13:23:05.422]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:05.422] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.422] - nx: 4
[13:23:05.423] - relay: TRUE
[13:23:05.423] - stdout: TRUE
[13:23:05.423] - signal: TRUE
[13:23:05.423] - resignal: FALSE
[13:23:05.423] - force: TRUE
[13:23:05.423] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.423] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.423]  - until=2
[13:23:05.423]  - relaying element #2
[13:23:05.423] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.423] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.424] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.424]  length: 3 (resolved future 1)
[13:23:05.424] resolved() for ‘SequentialFuture’ ...
[13:23:05.424] - state: ‘finished’
[13:23:05.424] - run: TRUE
[13:23:05.424] - result: ‘FutureResult’
[13:23:05.424] resolved() for ‘SequentialFuture’ ... done
[13:23:05.424] Future #2
[13:23:05.424] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.425] - nx: 4
[13:23:05.425] - relay: TRUE
[13:23:05.425] - stdout: TRUE
[13:23:05.425] - signal: TRUE
[13:23:05.425] - resignal: FALSE
[13:23:05.425] - force: TRUE
[13:23:05.425] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:05.425] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:05.425]  - until=2
[13:23:05.425]  - relaying element #2
[13:23:05.426] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.426] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.426] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.426]  length: 2 (resolved future 2)
[13:23:05.426] resolved() for ‘SequentialFuture’ ...
[13:23:05.426] - state: ‘finished’
[13:23:05.426] - run: TRUE
[13:23:05.426] - result: ‘FutureResult’
[13:23:05.426] resolved() for ‘SequentialFuture’ ... done
[13:23:05.426] Future #3
[13:23:05.427] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.427] - nx: 4
[13:23:05.427] - relay: TRUE
[13:23:05.427] - stdout: TRUE
[13:23:05.427] - signal: TRUE
[13:23:05.427] - resignal: FALSE
[13:23:05.427] - force: TRUE
[13:23:05.427] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:05.427] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:05.427]  - until=3
[13:23:05.427]  - relaying element #3
[13:23:05.428] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.428] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.428] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.428]  length: 1 (resolved future 3)
[13:23:05.428] resolved() for ‘SequentialFuture’ ...
[13:23:05.428] - state: ‘finished’
[13:23:05.429] - run: TRUE
[13:23:05.429] - result: ‘FutureResult’
[13:23:05.429] resolved() for ‘SequentialFuture’ ... done
[13:23:05.429] Future #4
[13:23:05.429] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.429] - nx: 4
[13:23:05.429] - relay: TRUE
[13:23:05.429] - stdout: TRUE
[13:23:05.429] - signal: TRUE
[13:23:05.429] - resignal: FALSE
[13:23:05.429] - force: TRUE
[13:23:05.430] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:05.430] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:05.430]  - until=4
[13:23:05.430]  - relaying element #4
[13:23:05.430] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.430] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.430] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.430]  length: 0 (resolved future 4)
[13:23:05.430] Relaying remaining futures
[13:23:05.431] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.431] - nx: 4
[13:23:05.431] - relay: TRUE
[13:23:05.431] - stdout: TRUE
[13:23:05.431] - signal: TRUE
[13:23:05.431] - resignal: FALSE
[13:23:05.431] - force: TRUE
[13:23:05.431] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.431] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:05.431] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:05.431] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:05.431] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.432] resolve() on environment ... DONE
<environment: 0x5596d3d62a00> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[13:23:05.433] plan(): Setting new future strategy stack:
[13:23:05.433] List of future strategies:
[13:23:05.433] 1. sequential:
[13:23:05.433]    - args: function (..., envir = parent.frame())
[13:23:05.433]    - tweaked: FALSE
[13:23:05.433]    - call: plan(strategy)
[13:23:05.433] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[13:23:05.434] getGlobalsAndPackages() ...
[13:23:05.434] Searching for globals...
[13:23:05.434] 
[13:23:05.434] Searching for globals ... DONE
[13:23:05.434] - globals: [0] <none>
[13:23:05.434] getGlobalsAndPackages() ... DONE
[13:23:05.435] run() for ‘Future’ ...
[13:23:05.435] - state: ‘created’
[13:23:05.435] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.435] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.435]   - Field: ‘label’
[13:23:05.436]   - Field: ‘local’
[13:23:05.436]   - Field: ‘owner’
[13:23:05.436]   - Field: ‘envir’
[13:23:05.436]   - Field: ‘packages’
[13:23:05.436]   - Field: ‘gc’
[13:23:05.436]   - Field: ‘conditions’
[13:23:05.436]   - Field: ‘expr’
[13:23:05.436]   - Field: ‘uuid’
[13:23:05.436]   - Field: ‘seed’
[13:23:05.436]   - Field: ‘version’
[13:23:05.437]   - Field: ‘result’
[13:23:05.437]   - Field: ‘asynchronous’
[13:23:05.437]   - Field: ‘calls’
[13:23:05.437]   - Field: ‘globals’
[13:23:05.437]   - Field: ‘stdout’
[13:23:05.437]   - Field: ‘earlySignal’
[13:23:05.437]   - Field: ‘lazy’
[13:23:05.437]   - Field: ‘state’
[13:23:05.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.437] - Launch lazy future ...
[13:23:05.438] Packages needed by the future expression (n = 0): <none>
[13:23:05.438] Packages needed by future strategies (n = 0): <none>
[13:23:05.438] {
[13:23:05.438]     {
[13:23:05.438]         {
[13:23:05.438]             ...future.startTime <- base::Sys.time()
[13:23:05.438]             {
[13:23:05.438]                 {
[13:23:05.438]                   {
[13:23:05.438]                     base::local({
[13:23:05.438]                       has_future <- base::requireNamespace("future", 
[13:23:05.438]                         quietly = TRUE)
[13:23:05.438]                       if (has_future) {
[13:23:05.438]                         ns <- base::getNamespace("future")
[13:23:05.438]                         version <- ns[[".package"]][["version"]]
[13:23:05.438]                         if (is.null(version)) 
[13:23:05.438]                           version <- utils::packageVersion("future")
[13:23:05.438]                       }
[13:23:05.438]                       else {
[13:23:05.438]                         version <- NULL
[13:23:05.438]                       }
[13:23:05.438]                       if (!has_future || version < "1.8.0") {
[13:23:05.438]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.438]                           "", base::R.version$version.string), 
[13:23:05.438]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.438]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.438]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.438]                             "release", "version")], collapse = " "), 
[13:23:05.438]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.438]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.438]                           info)
[13:23:05.438]                         info <- base::paste(info, collapse = "; ")
[13:23:05.438]                         if (!has_future) {
[13:23:05.438]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.438]                             info)
[13:23:05.438]                         }
[13:23:05.438]                         else {
[13:23:05.438]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.438]                             info, version)
[13:23:05.438]                         }
[13:23:05.438]                         base::stop(msg)
[13:23:05.438]                       }
[13:23:05.438]                     })
[13:23:05.438]                   }
[13:23:05.438]                   options(future.plan = NULL)
[13:23:05.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.438]                 }
[13:23:05.438]                 ...future.workdir <- getwd()
[13:23:05.438]             }
[13:23:05.438]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.438]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.438]         }
[13:23:05.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.438]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.438]             base::names(...future.oldOptions))
[13:23:05.438]     }
[13:23:05.438]     if (FALSE) {
[13:23:05.438]     }
[13:23:05.438]     else {
[13:23:05.438]         if (TRUE) {
[13:23:05.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.438]                 open = "w")
[13:23:05.438]         }
[13:23:05.438]         else {
[13:23:05.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.438]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.438]         }
[13:23:05.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.438]             base::sink(type = "output", split = FALSE)
[13:23:05.438]             base::close(...future.stdout)
[13:23:05.438]         }, add = TRUE)
[13:23:05.438]     }
[13:23:05.438]     ...future.frame <- base::sys.nframe()
[13:23:05.438]     ...future.conditions <- base::list()
[13:23:05.438]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.438]     if (FALSE) {
[13:23:05.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.438]     }
[13:23:05.438]     ...future.result <- base::tryCatch({
[13:23:05.438]         base::withCallingHandlers({
[13:23:05.438]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.438]             future::FutureResult(value = ...future.value$value, 
[13:23:05.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.438]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.438]                     ...future.globalenv.names))
[13:23:05.438]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.438]         }, condition = base::local({
[13:23:05.438]             c <- base::c
[13:23:05.438]             inherits <- base::inherits
[13:23:05.438]             invokeRestart <- base::invokeRestart
[13:23:05.438]             length <- base::length
[13:23:05.438]             list <- base::list
[13:23:05.438]             seq.int <- base::seq.int
[13:23:05.438]             signalCondition <- base::signalCondition
[13:23:05.438]             sys.calls <- base::sys.calls
[13:23:05.438]             `[[` <- base::`[[`
[13:23:05.438]             `+` <- base::`+`
[13:23:05.438]             `<<-` <- base::`<<-`
[13:23:05.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.438]                   3L)]
[13:23:05.438]             }
[13:23:05.438]             function(cond) {
[13:23:05.438]                 is_error <- inherits(cond, "error")
[13:23:05.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.438]                   NULL)
[13:23:05.438]                 if (is_error) {
[13:23:05.438]                   sessionInformation <- function() {
[13:23:05.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.438]                       search = base::search(), system = base::Sys.info())
[13:23:05.438]                   }
[13:23:05.438]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.438]                     cond$call), session = sessionInformation(), 
[13:23:05.438]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.438]                   signalCondition(cond)
[13:23:05.438]                 }
[13:23:05.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.438]                 "immediateCondition"))) {
[13:23:05.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.438]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.438]                   if (TRUE && !signal) {
[13:23:05.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.438]                     {
[13:23:05.438]                       inherits <- base::inherits
[13:23:05.438]                       invokeRestart <- base::invokeRestart
[13:23:05.438]                       is.null <- base::is.null
[13:23:05.438]                       muffled <- FALSE
[13:23:05.438]                       if (inherits(cond, "message")) {
[13:23:05.438]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.438]                         if (muffled) 
[13:23:05.438]                           invokeRestart("muffleMessage")
[13:23:05.438]                       }
[13:23:05.438]                       else if (inherits(cond, "warning")) {
[13:23:05.438]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.438]                         if (muffled) 
[13:23:05.438]                           invokeRestart("muffleWarning")
[13:23:05.438]                       }
[13:23:05.438]                       else if (inherits(cond, "condition")) {
[13:23:05.438]                         if (!is.null(pattern)) {
[13:23:05.438]                           computeRestarts <- base::computeRestarts
[13:23:05.438]                           grepl <- base::grepl
[13:23:05.438]                           restarts <- computeRestarts(cond)
[13:23:05.438]                           for (restart in restarts) {
[13:23:05.438]                             name <- restart$name
[13:23:05.438]                             if (is.null(name)) 
[13:23:05.438]                               next
[13:23:05.438]                             if (!grepl(pattern, name)) 
[13:23:05.438]                               next
[13:23:05.438]                             invokeRestart(restart)
[13:23:05.438]                             muffled <- TRUE
[13:23:05.438]                             break
[13:23:05.438]                           }
[13:23:05.438]                         }
[13:23:05.438]                       }
[13:23:05.438]                       invisible(muffled)
[13:23:05.438]                     }
[13:23:05.438]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.438]                   }
[13:23:05.438]                 }
[13:23:05.438]                 else {
[13:23:05.438]                   if (TRUE) {
[13:23:05.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.438]                     {
[13:23:05.438]                       inherits <- base::inherits
[13:23:05.438]                       invokeRestart <- base::invokeRestart
[13:23:05.438]                       is.null <- base::is.null
[13:23:05.438]                       muffled <- FALSE
[13:23:05.438]                       if (inherits(cond, "message")) {
[13:23:05.438]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.438]                         if (muffled) 
[13:23:05.438]                           invokeRestart("muffleMessage")
[13:23:05.438]                       }
[13:23:05.438]                       else if (inherits(cond, "warning")) {
[13:23:05.438]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.438]                         if (muffled) 
[13:23:05.438]                           invokeRestart("muffleWarning")
[13:23:05.438]                       }
[13:23:05.438]                       else if (inherits(cond, "condition")) {
[13:23:05.438]                         if (!is.null(pattern)) {
[13:23:05.438]                           computeRestarts <- base::computeRestarts
[13:23:05.438]                           grepl <- base::grepl
[13:23:05.438]                           restarts <- computeRestarts(cond)
[13:23:05.438]                           for (restart in restarts) {
[13:23:05.438]                             name <- restart$name
[13:23:05.438]                             if (is.null(name)) 
[13:23:05.438]                               next
[13:23:05.438]                             if (!grepl(pattern, name)) 
[13:23:05.438]                               next
[13:23:05.438]                             invokeRestart(restart)
[13:23:05.438]                             muffled <- TRUE
[13:23:05.438]                             break
[13:23:05.438]                           }
[13:23:05.438]                         }
[13:23:05.438]                       }
[13:23:05.438]                       invisible(muffled)
[13:23:05.438]                     }
[13:23:05.438]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.438]                   }
[13:23:05.438]                 }
[13:23:05.438]             }
[13:23:05.438]         }))
[13:23:05.438]     }, error = function(ex) {
[13:23:05.438]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.438]                 ...future.rng), started = ...future.startTime, 
[13:23:05.438]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.438]             version = "1.8"), class = "FutureResult")
[13:23:05.438]     }, finally = {
[13:23:05.438]         if (!identical(...future.workdir, getwd())) 
[13:23:05.438]             setwd(...future.workdir)
[13:23:05.438]         {
[13:23:05.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.438]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.438]             }
[13:23:05.438]             base::options(...future.oldOptions)
[13:23:05.438]             if (.Platform$OS.type == "windows") {
[13:23:05.438]                 old_names <- names(...future.oldEnvVars)
[13:23:05.438]                 envs <- base::Sys.getenv()
[13:23:05.438]                 names <- names(envs)
[13:23:05.438]                 common <- intersect(names, old_names)
[13:23:05.438]                 added <- setdiff(names, old_names)
[13:23:05.438]                 removed <- setdiff(old_names, names)
[13:23:05.438]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.438]                   envs[common]]
[13:23:05.438]                 NAMES <- toupper(changed)
[13:23:05.438]                 args <- list()
[13:23:05.438]                 for (kk in seq_along(NAMES)) {
[13:23:05.438]                   name <- changed[[kk]]
[13:23:05.438]                   NAME <- NAMES[[kk]]
[13:23:05.438]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.438]                     next
[13:23:05.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.438]                 }
[13:23:05.438]                 NAMES <- toupper(added)
[13:23:05.438]                 for (kk in seq_along(NAMES)) {
[13:23:05.438]                   name <- added[[kk]]
[13:23:05.438]                   NAME <- NAMES[[kk]]
[13:23:05.438]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.438]                     next
[13:23:05.438]                   args[[name]] <- ""
[13:23:05.438]                 }
[13:23:05.438]                 NAMES <- toupper(removed)
[13:23:05.438]                 for (kk in seq_along(NAMES)) {
[13:23:05.438]                   name <- removed[[kk]]
[13:23:05.438]                   NAME <- NAMES[[kk]]
[13:23:05.438]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.438]                     next
[13:23:05.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.438]                 }
[13:23:05.438]                 if (length(args) > 0) 
[13:23:05.438]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.438]             }
[13:23:05.438]             else {
[13:23:05.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.438]             }
[13:23:05.438]             {
[13:23:05.438]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.438]                   0L) {
[13:23:05.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.438]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.438]                   base::options(opts)
[13:23:05.438]                 }
[13:23:05.438]                 {
[13:23:05.438]                   {
[13:23:05.438]                     NULL
[13:23:05.438]                     RNGkind("Mersenne-Twister")
[13:23:05.438]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.438]                       inherits = FALSE)
[13:23:05.438]                   }
[13:23:05.438]                   options(future.plan = NULL)
[13:23:05.438]                   if (is.na(NA_character_)) 
[13:23:05.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.438]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.438]                   {
[13:23:05.438]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.438]                     if (!future$lazy) 
[13:23:05.438]                       future <- run(future)
[13:23:05.438]                     invisible(future)
[13:23:05.438]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.438]                 }
[13:23:05.438]             }
[13:23:05.438]         }
[13:23:05.438]     })
[13:23:05.438]     if (TRUE) {
[13:23:05.438]         base::sink(type = "output", split = FALSE)
[13:23:05.438]         if (TRUE) {
[13:23:05.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.438]         }
[13:23:05.438]         else {
[13:23:05.438]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.438]         }
[13:23:05.438]         base::close(...future.stdout)
[13:23:05.438]         ...future.stdout <- NULL
[13:23:05.438]     }
[13:23:05.438]     ...future.result$conditions <- ...future.conditions
[13:23:05.438]     ...future.result$finished <- base::Sys.time()
[13:23:05.438]     ...future.result
[13:23:05.438] }
[13:23:05.440] plan(): Setting new future strategy stack:
[13:23:05.440] List of future strategies:
[13:23:05.440] 1. sequential:
[13:23:05.440]    - args: function (..., envir = parent.frame())
[13:23:05.440]    - tweaked: FALSE
[13:23:05.440]    - call: NULL
[13:23:05.441] plan(): nbrOfWorkers() = 1
[13:23:05.441] plan(): Setting new future strategy stack:
[13:23:05.442] List of future strategies:
[13:23:05.442] 1. sequential:
[13:23:05.442]    - args: function (..., envir = parent.frame())
[13:23:05.442]    - tweaked: FALSE
[13:23:05.442]    - call: plan(strategy)
[13:23:05.442] plan(): nbrOfWorkers() = 1
[13:23:05.442] SequentialFuture started (and completed)
[13:23:05.442] - Launch lazy future ... done
[13:23:05.442] run() for ‘SequentialFuture’ ... done
[13:23:05.443] getGlobalsAndPackages() ...
[13:23:05.443] Searching for globals...
[13:23:05.443] 
[13:23:05.443] Searching for globals ... DONE
[13:23:05.443] - globals: [0] <none>
[13:23:05.443] getGlobalsAndPackages() ... DONE
[13:23:05.443] run() for ‘Future’ ...
[13:23:05.444] - state: ‘created’
[13:23:05.444] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.444] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.444]   - Field: ‘label’
[13:23:05.444]   - Field: ‘local’
[13:23:05.444]   - Field: ‘owner’
[13:23:05.447]   - Field: ‘envir’
[13:23:05.447]   - Field: ‘packages’
[13:23:05.447]   - Field: ‘gc’
[13:23:05.447]   - Field: ‘conditions’
[13:23:05.447]   - Field: ‘expr’
[13:23:05.447]   - Field: ‘uuid’
[13:23:05.448]   - Field: ‘seed’
[13:23:05.448]   - Field: ‘version’
[13:23:05.448]   - Field: ‘result’
[13:23:05.448]   - Field: ‘asynchronous’
[13:23:05.448]   - Field: ‘calls’
[13:23:05.448]   - Field: ‘globals’
[13:23:05.448]   - Field: ‘stdout’
[13:23:05.448]   - Field: ‘earlySignal’
[13:23:05.448]   - Field: ‘lazy’
[13:23:05.448]   - Field: ‘state’
[13:23:05.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.449] - Launch lazy future ...
[13:23:05.449] Packages needed by the future expression (n = 0): <none>
[13:23:05.449] Packages needed by future strategies (n = 0): <none>
[13:23:05.450] {
[13:23:05.450]     {
[13:23:05.450]         {
[13:23:05.450]             ...future.startTime <- base::Sys.time()
[13:23:05.450]             {
[13:23:05.450]                 {
[13:23:05.450]                   {
[13:23:05.450]                     base::local({
[13:23:05.450]                       has_future <- base::requireNamespace("future", 
[13:23:05.450]                         quietly = TRUE)
[13:23:05.450]                       if (has_future) {
[13:23:05.450]                         ns <- base::getNamespace("future")
[13:23:05.450]                         version <- ns[[".package"]][["version"]]
[13:23:05.450]                         if (is.null(version)) 
[13:23:05.450]                           version <- utils::packageVersion("future")
[13:23:05.450]                       }
[13:23:05.450]                       else {
[13:23:05.450]                         version <- NULL
[13:23:05.450]                       }
[13:23:05.450]                       if (!has_future || version < "1.8.0") {
[13:23:05.450]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.450]                           "", base::R.version$version.string), 
[13:23:05.450]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.450]                             "release", "version")], collapse = " "), 
[13:23:05.450]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.450]                           info)
[13:23:05.450]                         info <- base::paste(info, collapse = "; ")
[13:23:05.450]                         if (!has_future) {
[13:23:05.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.450]                             info)
[13:23:05.450]                         }
[13:23:05.450]                         else {
[13:23:05.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.450]                             info, version)
[13:23:05.450]                         }
[13:23:05.450]                         base::stop(msg)
[13:23:05.450]                       }
[13:23:05.450]                     })
[13:23:05.450]                   }
[13:23:05.450]                   options(future.plan = NULL)
[13:23:05.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.450]                 }
[13:23:05.450]                 ...future.workdir <- getwd()
[13:23:05.450]             }
[13:23:05.450]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.450]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.450]         }
[13:23:05.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.450]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.450]             base::names(...future.oldOptions))
[13:23:05.450]     }
[13:23:05.450]     if (FALSE) {
[13:23:05.450]     }
[13:23:05.450]     else {
[13:23:05.450]         if (TRUE) {
[13:23:05.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.450]                 open = "w")
[13:23:05.450]         }
[13:23:05.450]         else {
[13:23:05.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.450]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.450]         }
[13:23:05.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.450]             base::sink(type = "output", split = FALSE)
[13:23:05.450]             base::close(...future.stdout)
[13:23:05.450]         }, add = TRUE)
[13:23:05.450]     }
[13:23:05.450]     ...future.frame <- base::sys.nframe()
[13:23:05.450]     ...future.conditions <- base::list()
[13:23:05.450]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.450]     if (FALSE) {
[13:23:05.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.450]     }
[13:23:05.450]     ...future.result <- base::tryCatch({
[13:23:05.450]         base::withCallingHandlers({
[13:23:05.450]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.450]             future::FutureResult(value = ...future.value$value, 
[13:23:05.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.450]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.450]                     ...future.globalenv.names))
[13:23:05.450]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.450]         }, condition = base::local({
[13:23:05.450]             c <- base::c
[13:23:05.450]             inherits <- base::inherits
[13:23:05.450]             invokeRestart <- base::invokeRestart
[13:23:05.450]             length <- base::length
[13:23:05.450]             list <- base::list
[13:23:05.450]             seq.int <- base::seq.int
[13:23:05.450]             signalCondition <- base::signalCondition
[13:23:05.450]             sys.calls <- base::sys.calls
[13:23:05.450]             `[[` <- base::`[[`
[13:23:05.450]             `+` <- base::`+`
[13:23:05.450]             `<<-` <- base::`<<-`
[13:23:05.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.450]                   3L)]
[13:23:05.450]             }
[13:23:05.450]             function(cond) {
[13:23:05.450]                 is_error <- inherits(cond, "error")
[13:23:05.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.450]                   NULL)
[13:23:05.450]                 if (is_error) {
[13:23:05.450]                   sessionInformation <- function() {
[13:23:05.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.450]                       search = base::search(), system = base::Sys.info())
[13:23:05.450]                   }
[13:23:05.450]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.450]                     cond$call), session = sessionInformation(), 
[13:23:05.450]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.450]                   signalCondition(cond)
[13:23:05.450]                 }
[13:23:05.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.450]                 "immediateCondition"))) {
[13:23:05.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.450]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.450]                   if (TRUE && !signal) {
[13:23:05.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.450]                     {
[13:23:05.450]                       inherits <- base::inherits
[13:23:05.450]                       invokeRestart <- base::invokeRestart
[13:23:05.450]                       is.null <- base::is.null
[13:23:05.450]                       muffled <- FALSE
[13:23:05.450]                       if (inherits(cond, "message")) {
[13:23:05.450]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.450]                         if (muffled) 
[13:23:05.450]                           invokeRestart("muffleMessage")
[13:23:05.450]                       }
[13:23:05.450]                       else if (inherits(cond, "warning")) {
[13:23:05.450]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.450]                         if (muffled) 
[13:23:05.450]                           invokeRestart("muffleWarning")
[13:23:05.450]                       }
[13:23:05.450]                       else if (inherits(cond, "condition")) {
[13:23:05.450]                         if (!is.null(pattern)) {
[13:23:05.450]                           computeRestarts <- base::computeRestarts
[13:23:05.450]                           grepl <- base::grepl
[13:23:05.450]                           restarts <- computeRestarts(cond)
[13:23:05.450]                           for (restart in restarts) {
[13:23:05.450]                             name <- restart$name
[13:23:05.450]                             if (is.null(name)) 
[13:23:05.450]                               next
[13:23:05.450]                             if (!grepl(pattern, name)) 
[13:23:05.450]                               next
[13:23:05.450]                             invokeRestart(restart)
[13:23:05.450]                             muffled <- TRUE
[13:23:05.450]                             break
[13:23:05.450]                           }
[13:23:05.450]                         }
[13:23:05.450]                       }
[13:23:05.450]                       invisible(muffled)
[13:23:05.450]                     }
[13:23:05.450]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.450]                   }
[13:23:05.450]                 }
[13:23:05.450]                 else {
[13:23:05.450]                   if (TRUE) {
[13:23:05.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.450]                     {
[13:23:05.450]                       inherits <- base::inherits
[13:23:05.450]                       invokeRestart <- base::invokeRestart
[13:23:05.450]                       is.null <- base::is.null
[13:23:05.450]                       muffled <- FALSE
[13:23:05.450]                       if (inherits(cond, "message")) {
[13:23:05.450]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.450]                         if (muffled) 
[13:23:05.450]                           invokeRestart("muffleMessage")
[13:23:05.450]                       }
[13:23:05.450]                       else if (inherits(cond, "warning")) {
[13:23:05.450]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.450]                         if (muffled) 
[13:23:05.450]                           invokeRestart("muffleWarning")
[13:23:05.450]                       }
[13:23:05.450]                       else if (inherits(cond, "condition")) {
[13:23:05.450]                         if (!is.null(pattern)) {
[13:23:05.450]                           computeRestarts <- base::computeRestarts
[13:23:05.450]                           grepl <- base::grepl
[13:23:05.450]                           restarts <- computeRestarts(cond)
[13:23:05.450]                           for (restart in restarts) {
[13:23:05.450]                             name <- restart$name
[13:23:05.450]                             if (is.null(name)) 
[13:23:05.450]                               next
[13:23:05.450]                             if (!grepl(pattern, name)) 
[13:23:05.450]                               next
[13:23:05.450]                             invokeRestart(restart)
[13:23:05.450]                             muffled <- TRUE
[13:23:05.450]                             break
[13:23:05.450]                           }
[13:23:05.450]                         }
[13:23:05.450]                       }
[13:23:05.450]                       invisible(muffled)
[13:23:05.450]                     }
[13:23:05.450]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.450]                   }
[13:23:05.450]                 }
[13:23:05.450]             }
[13:23:05.450]         }))
[13:23:05.450]     }, error = function(ex) {
[13:23:05.450]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.450]                 ...future.rng), started = ...future.startTime, 
[13:23:05.450]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.450]             version = "1.8"), class = "FutureResult")
[13:23:05.450]     }, finally = {
[13:23:05.450]         if (!identical(...future.workdir, getwd())) 
[13:23:05.450]             setwd(...future.workdir)
[13:23:05.450]         {
[13:23:05.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.450]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.450]             }
[13:23:05.450]             base::options(...future.oldOptions)
[13:23:05.450]             if (.Platform$OS.type == "windows") {
[13:23:05.450]                 old_names <- names(...future.oldEnvVars)
[13:23:05.450]                 envs <- base::Sys.getenv()
[13:23:05.450]                 names <- names(envs)
[13:23:05.450]                 common <- intersect(names, old_names)
[13:23:05.450]                 added <- setdiff(names, old_names)
[13:23:05.450]                 removed <- setdiff(old_names, names)
[13:23:05.450]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.450]                   envs[common]]
[13:23:05.450]                 NAMES <- toupper(changed)
[13:23:05.450]                 args <- list()
[13:23:05.450]                 for (kk in seq_along(NAMES)) {
[13:23:05.450]                   name <- changed[[kk]]
[13:23:05.450]                   NAME <- NAMES[[kk]]
[13:23:05.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.450]                     next
[13:23:05.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.450]                 }
[13:23:05.450]                 NAMES <- toupper(added)
[13:23:05.450]                 for (kk in seq_along(NAMES)) {
[13:23:05.450]                   name <- added[[kk]]
[13:23:05.450]                   NAME <- NAMES[[kk]]
[13:23:05.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.450]                     next
[13:23:05.450]                   args[[name]] <- ""
[13:23:05.450]                 }
[13:23:05.450]                 NAMES <- toupper(removed)
[13:23:05.450]                 for (kk in seq_along(NAMES)) {
[13:23:05.450]                   name <- removed[[kk]]
[13:23:05.450]                   NAME <- NAMES[[kk]]
[13:23:05.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.450]                     next
[13:23:05.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.450]                 }
[13:23:05.450]                 if (length(args) > 0) 
[13:23:05.450]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.450]             }
[13:23:05.450]             else {
[13:23:05.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.450]             }
[13:23:05.450]             {
[13:23:05.450]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.450]                   0L) {
[13:23:05.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.450]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.450]                   base::options(opts)
[13:23:05.450]                 }
[13:23:05.450]                 {
[13:23:05.450]                   {
[13:23:05.450]                     NULL
[13:23:05.450]                     RNGkind("Mersenne-Twister")
[13:23:05.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.450]                       inherits = FALSE)
[13:23:05.450]                   }
[13:23:05.450]                   options(future.plan = NULL)
[13:23:05.450]                   if (is.na(NA_character_)) 
[13:23:05.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.450]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.450]                   {
[13:23:05.450]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.450]                     if (!future$lazy) 
[13:23:05.450]                       future <- run(future)
[13:23:05.450]                     invisible(future)
[13:23:05.450]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.450]                 }
[13:23:05.450]             }
[13:23:05.450]         }
[13:23:05.450]     })
[13:23:05.450]     if (TRUE) {
[13:23:05.450]         base::sink(type = "output", split = FALSE)
[13:23:05.450]         if (TRUE) {
[13:23:05.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.450]         }
[13:23:05.450]         else {
[13:23:05.450]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.450]         }
[13:23:05.450]         base::close(...future.stdout)
[13:23:05.450]         ...future.stdout <- NULL
[13:23:05.450]     }
[13:23:05.450]     ...future.result$conditions <- ...future.conditions
[13:23:05.450]     ...future.result$finished <- base::Sys.time()
[13:23:05.450]     ...future.result
[13:23:05.450] }
[13:23:05.451] plan(): Setting new future strategy stack:
[13:23:05.452] List of future strategies:
[13:23:05.452] 1. sequential:
[13:23:05.452]    - args: function (..., envir = parent.frame())
[13:23:05.452]    - tweaked: FALSE
[13:23:05.452]    - call: NULL
[13:23:05.452] plan(): nbrOfWorkers() = 1
[13:23:05.453] plan(): Setting new future strategy stack:
[13:23:05.453] List of future strategies:
[13:23:05.453] 1. sequential:
[13:23:05.453]    - args: function (..., envir = parent.frame())
[13:23:05.453]    - tweaked: FALSE
[13:23:05.453]    - call: plan(strategy)
[13:23:05.453] plan(): nbrOfWorkers() = 1
[13:23:05.453] SequentialFuture started (and completed)
[13:23:05.454] - Launch lazy future ... done
[13:23:05.454] run() for ‘SequentialFuture’ ... done
[13:23:05.454] getGlobalsAndPackages() ...
[13:23:05.454] Searching for globals...
[13:23:05.455] - globals found: [1] ‘{’
[13:23:05.455] Searching for globals ... DONE
[13:23:05.455] Resolving globals: FALSE
[13:23:05.456] 
[13:23:05.456] 
[13:23:05.456] getGlobalsAndPackages() ... DONE
[13:23:05.456] run() for ‘Future’ ...
[13:23:05.456] - state: ‘created’
[13:23:05.456] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.457]   - Field: ‘label’
[13:23:05.457]   - Field: ‘local’
[13:23:05.457]   - Field: ‘owner’
[13:23:05.457]   - Field: ‘envir’
[13:23:05.457]   - Field: ‘packages’
[13:23:05.457]   - Field: ‘gc’
[13:23:05.458]   - Field: ‘conditions’
[13:23:05.458]   - Field: ‘expr’
[13:23:05.458]   - Field: ‘uuid’
[13:23:05.458]   - Field: ‘seed’
[13:23:05.458]   - Field: ‘version’
[13:23:05.458]   - Field: ‘result’
[13:23:05.458]   - Field: ‘asynchronous’
[13:23:05.458]   - Field: ‘calls’
[13:23:05.458]   - Field: ‘globals’
[13:23:05.458]   - Field: ‘stdout’
[13:23:05.459]   - Field: ‘earlySignal’
[13:23:05.459]   - Field: ‘lazy’
[13:23:05.459]   - Field: ‘state’
[13:23:05.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.459] - Launch lazy future ...
[13:23:05.459] Packages needed by the future expression (n = 0): <none>
[13:23:05.459] Packages needed by future strategies (n = 0): <none>
[13:23:05.460] {
[13:23:05.460]     {
[13:23:05.460]         {
[13:23:05.460]             ...future.startTime <- base::Sys.time()
[13:23:05.460]             {
[13:23:05.460]                 {
[13:23:05.460]                   {
[13:23:05.460]                     base::local({
[13:23:05.460]                       has_future <- base::requireNamespace("future", 
[13:23:05.460]                         quietly = TRUE)
[13:23:05.460]                       if (has_future) {
[13:23:05.460]                         ns <- base::getNamespace("future")
[13:23:05.460]                         version <- ns[[".package"]][["version"]]
[13:23:05.460]                         if (is.null(version)) 
[13:23:05.460]                           version <- utils::packageVersion("future")
[13:23:05.460]                       }
[13:23:05.460]                       else {
[13:23:05.460]                         version <- NULL
[13:23:05.460]                       }
[13:23:05.460]                       if (!has_future || version < "1.8.0") {
[13:23:05.460]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.460]                           "", base::R.version$version.string), 
[13:23:05.460]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.460]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.460]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.460]                             "release", "version")], collapse = " "), 
[13:23:05.460]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.460]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.460]                           info)
[13:23:05.460]                         info <- base::paste(info, collapse = "; ")
[13:23:05.460]                         if (!has_future) {
[13:23:05.460]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.460]                             info)
[13:23:05.460]                         }
[13:23:05.460]                         else {
[13:23:05.460]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.460]                             info, version)
[13:23:05.460]                         }
[13:23:05.460]                         base::stop(msg)
[13:23:05.460]                       }
[13:23:05.460]                     })
[13:23:05.460]                   }
[13:23:05.460]                   options(future.plan = NULL)
[13:23:05.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.460]                 }
[13:23:05.460]                 ...future.workdir <- getwd()
[13:23:05.460]             }
[13:23:05.460]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.460]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.460]         }
[13:23:05.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.460]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.460]             base::names(...future.oldOptions))
[13:23:05.460]     }
[13:23:05.460]     if (FALSE) {
[13:23:05.460]     }
[13:23:05.460]     else {
[13:23:05.460]         if (TRUE) {
[13:23:05.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.460]                 open = "w")
[13:23:05.460]         }
[13:23:05.460]         else {
[13:23:05.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.460]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.460]         }
[13:23:05.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.460]             base::sink(type = "output", split = FALSE)
[13:23:05.460]             base::close(...future.stdout)
[13:23:05.460]         }, add = TRUE)
[13:23:05.460]     }
[13:23:05.460]     ...future.frame <- base::sys.nframe()
[13:23:05.460]     ...future.conditions <- base::list()
[13:23:05.460]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.460]     if (FALSE) {
[13:23:05.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.460]     }
[13:23:05.460]     ...future.result <- base::tryCatch({
[13:23:05.460]         base::withCallingHandlers({
[13:23:05.460]             ...future.value <- base::withVisible(base::local({
[13:23:05.460]                 4
[13:23:05.460]             }))
[13:23:05.460]             future::FutureResult(value = ...future.value$value, 
[13:23:05.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.460]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.460]                     ...future.globalenv.names))
[13:23:05.460]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.460]         }, condition = base::local({
[13:23:05.460]             c <- base::c
[13:23:05.460]             inherits <- base::inherits
[13:23:05.460]             invokeRestart <- base::invokeRestart
[13:23:05.460]             length <- base::length
[13:23:05.460]             list <- base::list
[13:23:05.460]             seq.int <- base::seq.int
[13:23:05.460]             signalCondition <- base::signalCondition
[13:23:05.460]             sys.calls <- base::sys.calls
[13:23:05.460]             `[[` <- base::`[[`
[13:23:05.460]             `+` <- base::`+`
[13:23:05.460]             `<<-` <- base::`<<-`
[13:23:05.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.460]                   3L)]
[13:23:05.460]             }
[13:23:05.460]             function(cond) {
[13:23:05.460]                 is_error <- inherits(cond, "error")
[13:23:05.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.460]                   NULL)
[13:23:05.460]                 if (is_error) {
[13:23:05.460]                   sessionInformation <- function() {
[13:23:05.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.460]                       search = base::search(), system = base::Sys.info())
[13:23:05.460]                   }
[13:23:05.460]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.460]                     cond$call), session = sessionInformation(), 
[13:23:05.460]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.460]                   signalCondition(cond)
[13:23:05.460]                 }
[13:23:05.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.460]                 "immediateCondition"))) {
[13:23:05.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.460]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.460]                   if (TRUE && !signal) {
[13:23:05.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.460]                     {
[13:23:05.460]                       inherits <- base::inherits
[13:23:05.460]                       invokeRestart <- base::invokeRestart
[13:23:05.460]                       is.null <- base::is.null
[13:23:05.460]                       muffled <- FALSE
[13:23:05.460]                       if (inherits(cond, "message")) {
[13:23:05.460]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.460]                         if (muffled) 
[13:23:05.460]                           invokeRestart("muffleMessage")
[13:23:05.460]                       }
[13:23:05.460]                       else if (inherits(cond, "warning")) {
[13:23:05.460]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.460]                         if (muffled) 
[13:23:05.460]                           invokeRestart("muffleWarning")
[13:23:05.460]                       }
[13:23:05.460]                       else if (inherits(cond, "condition")) {
[13:23:05.460]                         if (!is.null(pattern)) {
[13:23:05.460]                           computeRestarts <- base::computeRestarts
[13:23:05.460]                           grepl <- base::grepl
[13:23:05.460]                           restarts <- computeRestarts(cond)
[13:23:05.460]                           for (restart in restarts) {
[13:23:05.460]                             name <- restart$name
[13:23:05.460]                             if (is.null(name)) 
[13:23:05.460]                               next
[13:23:05.460]                             if (!grepl(pattern, name)) 
[13:23:05.460]                               next
[13:23:05.460]                             invokeRestart(restart)
[13:23:05.460]                             muffled <- TRUE
[13:23:05.460]                             break
[13:23:05.460]                           }
[13:23:05.460]                         }
[13:23:05.460]                       }
[13:23:05.460]                       invisible(muffled)
[13:23:05.460]                     }
[13:23:05.460]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.460]                   }
[13:23:05.460]                 }
[13:23:05.460]                 else {
[13:23:05.460]                   if (TRUE) {
[13:23:05.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.460]                     {
[13:23:05.460]                       inherits <- base::inherits
[13:23:05.460]                       invokeRestart <- base::invokeRestart
[13:23:05.460]                       is.null <- base::is.null
[13:23:05.460]                       muffled <- FALSE
[13:23:05.460]                       if (inherits(cond, "message")) {
[13:23:05.460]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.460]                         if (muffled) 
[13:23:05.460]                           invokeRestart("muffleMessage")
[13:23:05.460]                       }
[13:23:05.460]                       else if (inherits(cond, "warning")) {
[13:23:05.460]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.460]                         if (muffled) 
[13:23:05.460]                           invokeRestart("muffleWarning")
[13:23:05.460]                       }
[13:23:05.460]                       else if (inherits(cond, "condition")) {
[13:23:05.460]                         if (!is.null(pattern)) {
[13:23:05.460]                           computeRestarts <- base::computeRestarts
[13:23:05.460]                           grepl <- base::grepl
[13:23:05.460]                           restarts <- computeRestarts(cond)
[13:23:05.460]                           for (restart in restarts) {
[13:23:05.460]                             name <- restart$name
[13:23:05.460]                             if (is.null(name)) 
[13:23:05.460]                               next
[13:23:05.460]                             if (!grepl(pattern, name)) 
[13:23:05.460]                               next
[13:23:05.460]                             invokeRestart(restart)
[13:23:05.460]                             muffled <- TRUE
[13:23:05.460]                             break
[13:23:05.460]                           }
[13:23:05.460]                         }
[13:23:05.460]                       }
[13:23:05.460]                       invisible(muffled)
[13:23:05.460]                     }
[13:23:05.460]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.460]                   }
[13:23:05.460]                 }
[13:23:05.460]             }
[13:23:05.460]         }))
[13:23:05.460]     }, error = function(ex) {
[13:23:05.460]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.460]                 ...future.rng), started = ...future.startTime, 
[13:23:05.460]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.460]             version = "1.8"), class = "FutureResult")
[13:23:05.460]     }, finally = {
[13:23:05.460]         if (!identical(...future.workdir, getwd())) 
[13:23:05.460]             setwd(...future.workdir)
[13:23:05.460]         {
[13:23:05.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.460]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.460]             }
[13:23:05.460]             base::options(...future.oldOptions)
[13:23:05.460]             if (.Platform$OS.type == "windows") {
[13:23:05.460]                 old_names <- names(...future.oldEnvVars)
[13:23:05.460]                 envs <- base::Sys.getenv()
[13:23:05.460]                 names <- names(envs)
[13:23:05.460]                 common <- intersect(names, old_names)
[13:23:05.460]                 added <- setdiff(names, old_names)
[13:23:05.460]                 removed <- setdiff(old_names, names)
[13:23:05.460]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.460]                   envs[common]]
[13:23:05.460]                 NAMES <- toupper(changed)
[13:23:05.460]                 args <- list()
[13:23:05.460]                 for (kk in seq_along(NAMES)) {
[13:23:05.460]                   name <- changed[[kk]]
[13:23:05.460]                   NAME <- NAMES[[kk]]
[13:23:05.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.460]                     next
[13:23:05.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.460]                 }
[13:23:05.460]                 NAMES <- toupper(added)
[13:23:05.460]                 for (kk in seq_along(NAMES)) {
[13:23:05.460]                   name <- added[[kk]]
[13:23:05.460]                   NAME <- NAMES[[kk]]
[13:23:05.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.460]                     next
[13:23:05.460]                   args[[name]] <- ""
[13:23:05.460]                 }
[13:23:05.460]                 NAMES <- toupper(removed)
[13:23:05.460]                 for (kk in seq_along(NAMES)) {
[13:23:05.460]                   name <- removed[[kk]]
[13:23:05.460]                   NAME <- NAMES[[kk]]
[13:23:05.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.460]                     next
[13:23:05.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.460]                 }
[13:23:05.460]                 if (length(args) > 0) 
[13:23:05.460]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.460]             }
[13:23:05.460]             else {
[13:23:05.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.460]             }
[13:23:05.460]             {
[13:23:05.460]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.460]                   0L) {
[13:23:05.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.460]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.460]                   base::options(opts)
[13:23:05.460]                 }
[13:23:05.460]                 {
[13:23:05.460]                   {
[13:23:05.460]                     NULL
[13:23:05.460]                     RNGkind("Mersenne-Twister")
[13:23:05.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.460]                       inherits = FALSE)
[13:23:05.460]                   }
[13:23:05.460]                   options(future.plan = NULL)
[13:23:05.460]                   if (is.na(NA_character_)) 
[13:23:05.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.460]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.460]                   {
[13:23:05.460]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.460]                     if (!future$lazy) 
[13:23:05.460]                       future <- run(future)
[13:23:05.460]                     invisible(future)
[13:23:05.460]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.460]                 }
[13:23:05.460]             }
[13:23:05.460]         }
[13:23:05.460]     })
[13:23:05.460]     if (TRUE) {
[13:23:05.460]         base::sink(type = "output", split = FALSE)
[13:23:05.460]         if (TRUE) {
[13:23:05.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.460]         }
[13:23:05.460]         else {
[13:23:05.460]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.460]         }
[13:23:05.460]         base::close(...future.stdout)
[13:23:05.460]         ...future.stdout <- NULL
[13:23:05.460]     }
[13:23:05.460]     ...future.result$conditions <- ...future.conditions
[13:23:05.460]     ...future.result$finished <- base::Sys.time()
[13:23:05.460]     ...future.result
[13:23:05.460] }
[13:23:05.462] plan(): Setting new future strategy stack:
[13:23:05.462] List of future strategies:
[13:23:05.462] 1. sequential:
[13:23:05.462]    - args: function (..., envir = parent.frame())
[13:23:05.462]    - tweaked: FALSE
[13:23:05.462]    - call: NULL
[13:23:05.462] plan(): nbrOfWorkers() = 1
[13:23:05.463] plan(): Setting new future strategy stack:
[13:23:05.463] List of future strategies:
[13:23:05.463] 1. sequential:
[13:23:05.463]    - args: function (..., envir = parent.frame())
[13:23:05.463]    - tweaked: FALSE
[13:23:05.463]    - call: plan(strategy)
[13:23:05.464] plan(): nbrOfWorkers() = 1
[13:23:05.464] SequentialFuture started (and completed)
[13:23:05.464] - Launch lazy future ... done
[13:23:05.464] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d55c8a00> 
Classes 'listenv', 'environment' <environment: 0x5596d5517118> 
[13:23:05.468] resolved() for ‘SequentialFuture’ ...
[13:23:05.468] - state: ‘finished’
[13:23:05.468] - run: TRUE
[13:23:05.468] - result: ‘FutureResult’
[13:23:05.468] resolved() for ‘SequentialFuture’ ... done
[13:23:05.468] resolved() for ‘SequentialFuture’ ...
[13:23:05.468] - state: ‘finished’
[13:23:05.468] - run: TRUE
[13:23:05.468] - result: ‘FutureResult’
[13:23:05.469] resolved() for ‘SequentialFuture’ ... done
[13:23:05.469] resolved() for ‘SequentialFuture’ ...
[13:23:05.469] - state: ‘finished’
[13:23:05.469] - run: TRUE
[13:23:05.469] - result: ‘FutureResult’
[13:23:05.469] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:05.471] resolve() on list environment ...
[13:23:05.471]  recursive: 0
[13:23:05.472]  length: 6
[13:23:05.472]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:05.472] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.473] - nx: 6
[13:23:05.473] - relay: TRUE
[13:23:05.473] - stdout: TRUE
[13:23:05.473] - signal: TRUE
[13:23:05.473] - resignal: FALSE
[13:23:05.473] - force: TRUE
[13:23:05.473] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.473] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.473]  - until=2
[13:23:05.473]  - relaying element #2
[13:23:05.473] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.474] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.474] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.474]  length: 5 (resolved future 1)
[13:23:05.474] resolved() for ‘SequentialFuture’ ...
[13:23:05.474] - state: ‘finished’
[13:23:05.474] - run: TRUE
[13:23:05.474] - result: ‘FutureResult’
[13:23:05.474] resolved() for ‘SequentialFuture’ ... done
[13:23:05.474] Future #2
[13:23:05.475] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.475] - nx: 6
[13:23:05.475] - relay: TRUE
[13:23:05.475] - stdout: TRUE
[13:23:05.475] - signal: TRUE
[13:23:05.475] - resignal: FALSE
[13:23:05.475] - force: TRUE
[13:23:05.475] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.475] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.478]  - until=2
[13:23:05.478]  - relaying element #2
[13:23:05.478] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.478] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.478] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.479]  length: 4 (resolved future 2)
[13:23:05.479] resolved() for ‘SequentialFuture’ ...
[13:23:05.479] - state: ‘finished’
[13:23:05.479] - run: TRUE
[13:23:05.479] - result: ‘FutureResult’
[13:23:05.479] resolved() for ‘SequentialFuture’ ... done
[13:23:05.479] Future #3
[13:23:05.479] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.479] - nx: 6
[13:23:05.480] - relay: TRUE
[13:23:05.480] - stdout: TRUE
[13:23:05.480] - signal: TRUE
[13:23:05.480] - resignal: FALSE
[13:23:05.480] - force: TRUE
[13:23:05.480] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.480] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.480]  - until=3
[13:23:05.480]  - relaying element #3
[13:23:05.480] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.481] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.481] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.481]  length: 3 (resolved future 3)
[13:23:05.481] resolved() for ‘SequentialFuture’ ...
[13:23:05.481] - state: ‘finished’
[13:23:05.481] - run: TRUE
[13:23:05.481] - result: ‘FutureResult’
[13:23:05.481] resolved() for ‘SequentialFuture’ ... done
[13:23:05.481] Future #4
[13:23:05.482] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.482] - nx: 6
[13:23:05.482] - relay: TRUE
[13:23:05.482] - stdout: TRUE
[13:23:05.482] - signal: TRUE
[13:23:05.482] - resignal: FALSE
[13:23:05.482] - force: TRUE
[13:23:05.482] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.482] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.482]  - until=4
[13:23:05.482]  - relaying element #4
[13:23:05.483] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.483] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.483] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.483]  length: 2 (resolved future 4)
[13:23:05.483] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.483] - nx: 6
[13:23:05.483] - relay: TRUE
[13:23:05.483] - stdout: TRUE
[13:23:05.483] - signal: TRUE
[13:23:05.483] - resignal: FALSE
[13:23:05.483] - force: TRUE
[13:23:05.484] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.484] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.484]  - until=6
[13:23:05.484]  - relaying element #6
[13:23:05.484] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.484] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.484] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.484]  length: 1 (resolved future 5)
[13:23:05.484] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.484] - nx: 6
[13:23:05.485] - relay: TRUE
[13:23:05.485] - stdout: TRUE
[13:23:05.485] - signal: TRUE
[13:23:05.485] - resignal: FALSE
[13:23:05.485] - force: TRUE
[13:23:05.485] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.485] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.485]  - until=6
[13:23:05.485] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.485] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.485] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.486]  length: 0 (resolved future 6)
[13:23:05.486] Relaying remaining futures
[13:23:05.486] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.486] - nx: 6
[13:23:05.486] - relay: TRUE
[13:23:05.486] - stdout: TRUE
[13:23:05.486] - signal: TRUE
[13:23:05.486] - resignal: FALSE
[13:23:05.486] - force: TRUE
[13:23:05.486] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.486] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:05.487] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.487] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.487] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.487] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5596d585a320> 
Dimensions: c(1, 6)
[13:23:05.488] getGlobalsAndPackages() ...
[13:23:05.488] Searching for globals...
[13:23:05.488] 
[13:23:05.489] Searching for globals ... DONE
[13:23:05.489] - globals: [0] <none>
[13:23:05.489] getGlobalsAndPackages() ... DONE
[13:23:05.489] run() for ‘Future’ ...
[13:23:05.489] - state: ‘created’
[13:23:05.489] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.490] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.490]   - Field: ‘label’
[13:23:05.490]   - Field: ‘local’
[13:23:05.490]   - Field: ‘owner’
[13:23:05.490]   - Field: ‘envir’
[13:23:05.490]   - Field: ‘packages’
[13:23:05.490]   - Field: ‘gc’
[13:23:05.490]   - Field: ‘conditions’
[13:23:05.490]   - Field: ‘expr’
[13:23:05.491]   - Field: ‘uuid’
[13:23:05.491]   - Field: ‘seed’
[13:23:05.491]   - Field: ‘version’
[13:23:05.491]   - Field: ‘result’
[13:23:05.491]   - Field: ‘asynchronous’
[13:23:05.491]   - Field: ‘calls’
[13:23:05.491]   - Field: ‘globals’
[13:23:05.491]   - Field: ‘stdout’
[13:23:05.491]   - Field: ‘earlySignal’
[13:23:05.491]   - Field: ‘lazy’
[13:23:05.492]   - Field: ‘state’
[13:23:05.492] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.492] - Launch lazy future ...
[13:23:05.492] Packages needed by the future expression (n = 0): <none>
[13:23:05.492] Packages needed by future strategies (n = 0): <none>
[13:23:05.493] {
[13:23:05.493]     {
[13:23:05.493]         {
[13:23:05.493]             ...future.startTime <- base::Sys.time()
[13:23:05.493]             {
[13:23:05.493]                 {
[13:23:05.493]                   {
[13:23:05.493]                     base::local({
[13:23:05.493]                       has_future <- base::requireNamespace("future", 
[13:23:05.493]                         quietly = TRUE)
[13:23:05.493]                       if (has_future) {
[13:23:05.493]                         ns <- base::getNamespace("future")
[13:23:05.493]                         version <- ns[[".package"]][["version"]]
[13:23:05.493]                         if (is.null(version)) 
[13:23:05.493]                           version <- utils::packageVersion("future")
[13:23:05.493]                       }
[13:23:05.493]                       else {
[13:23:05.493]                         version <- NULL
[13:23:05.493]                       }
[13:23:05.493]                       if (!has_future || version < "1.8.0") {
[13:23:05.493]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.493]                           "", base::R.version$version.string), 
[13:23:05.493]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.493]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.493]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.493]                             "release", "version")], collapse = " "), 
[13:23:05.493]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.493]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.493]                           info)
[13:23:05.493]                         info <- base::paste(info, collapse = "; ")
[13:23:05.493]                         if (!has_future) {
[13:23:05.493]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.493]                             info)
[13:23:05.493]                         }
[13:23:05.493]                         else {
[13:23:05.493]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.493]                             info, version)
[13:23:05.493]                         }
[13:23:05.493]                         base::stop(msg)
[13:23:05.493]                       }
[13:23:05.493]                     })
[13:23:05.493]                   }
[13:23:05.493]                   options(future.plan = NULL)
[13:23:05.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.493]                 }
[13:23:05.493]                 ...future.workdir <- getwd()
[13:23:05.493]             }
[13:23:05.493]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.493]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.493]         }
[13:23:05.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.493]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.493]             base::names(...future.oldOptions))
[13:23:05.493]     }
[13:23:05.493]     if (FALSE) {
[13:23:05.493]     }
[13:23:05.493]     else {
[13:23:05.493]         if (TRUE) {
[13:23:05.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.493]                 open = "w")
[13:23:05.493]         }
[13:23:05.493]         else {
[13:23:05.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.493]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.493]         }
[13:23:05.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.493]             base::sink(type = "output", split = FALSE)
[13:23:05.493]             base::close(...future.stdout)
[13:23:05.493]         }, add = TRUE)
[13:23:05.493]     }
[13:23:05.493]     ...future.frame <- base::sys.nframe()
[13:23:05.493]     ...future.conditions <- base::list()
[13:23:05.493]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.493]     if (FALSE) {
[13:23:05.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.493]     }
[13:23:05.493]     ...future.result <- base::tryCatch({
[13:23:05.493]         base::withCallingHandlers({
[13:23:05.493]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.493]             future::FutureResult(value = ...future.value$value, 
[13:23:05.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.493]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.493]                     ...future.globalenv.names))
[13:23:05.493]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.493]         }, condition = base::local({
[13:23:05.493]             c <- base::c
[13:23:05.493]             inherits <- base::inherits
[13:23:05.493]             invokeRestart <- base::invokeRestart
[13:23:05.493]             length <- base::length
[13:23:05.493]             list <- base::list
[13:23:05.493]             seq.int <- base::seq.int
[13:23:05.493]             signalCondition <- base::signalCondition
[13:23:05.493]             sys.calls <- base::sys.calls
[13:23:05.493]             `[[` <- base::`[[`
[13:23:05.493]             `+` <- base::`+`
[13:23:05.493]             `<<-` <- base::`<<-`
[13:23:05.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.493]                   3L)]
[13:23:05.493]             }
[13:23:05.493]             function(cond) {
[13:23:05.493]                 is_error <- inherits(cond, "error")
[13:23:05.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.493]                   NULL)
[13:23:05.493]                 if (is_error) {
[13:23:05.493]                   sessionInformation <- function() {
[13:23:05.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.493]                       search = base::search(), system = base::Sys.info())
[13:23:05.493]                   }
[13:23:05.493]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.493]                     cond$call), session = sessionInformation(), 
[13:23:05.493]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.493]                   signalCondition(cond)
[13:23:05.493]                 }
[13:23:05.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.493]                 "immediateCondition"))) {
[13:23:05.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.493]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.493]                   if (TRUE && !signal) {
[13:23:05.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.493]                     {
[13:23:05.493]                       inherits <- base::inherits
[13:23:05.493]                       invokeRestart <- base::invokeRestart
[13:23:05.493]                       is.null <- base::is.null
[13:23:05.493]                       muffled <- FALSE
[13:23:05.493]                       if (inherits(cond, "message")) {
[13:23:05.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.493]                         if (muffled) 
[13:23:05.493]                           invokeRestart("muffleMessage")
[13:23:05.493]                       }
[13:23:05.493]                       else if (inherits(cond, "warning")) {
[13:23:05.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.493]                         if (muffled) 
[13:23:05.493]                           invokeRestart("muffleWarning")
[13:23:05.493]                       }
[13:23:05.493]                       else if (inherits(cond, "condition")) {
[13:23:05.493]                         if (!is.null(pattern)) {
[13:23:05.493]                           computeRestarts <- base::computeRestarts
[13:23:05.493]                           grepl <- base::grepl
[13:23:05.493]                           restarts <- computeRestarts(cond)
[13:23:05.493]                           for (restart in restarts) {
[13:23:05.493]                             name <- restart$name
[13:23:05.493]                             if (is.null(name)) 
[13:23:05.493]                               next
[13:23:05.493]                             if (!grepl(pattern, name)) 
[13:23:05.493]                               next
[13:23:05.493]                             invokeRestart(restart)
[13:23:05.493]                             muffled <- TRUE
[13:23:05.493]                             break
[13:23:05.493]                           }
[13:23:05.493]                         }
[13:23:05.493]                       }
[13:23:05.493]                       invisible(muffled)
[13:23:05.493]                     }
[13:23:05.493]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.493]                   }
[13:23:05.493]                 }
[13:23:05.493]                 else {
[13:23:05.493]                   if (TRUE) {
[13:23:05.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.493]                     {
[13:23:05.493]                       inherits <- base::inherits
[13:23:05.493]                       invokeRestart <- base::invokeRestart
[13:23:05.493]                       is.null <- base::is.null
[13:23:05.493]                       muffled <- FALSE
[13:23:05.493]                       if (inherits(cond, "message")) {
[13:23:05.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.493]                         if (muffled) 
[13:23:05.493]                           invokeRestart("muffleMessage")
[13:23:05.493]                       }
[13:23:05.493]                       else if (inherits(cond, "warning")) {
[13:23:05.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.493]                         if (muffled) 
[13:23:05.493]                           invokeRestart("muffleWarning")
[13:23:05.493]                       }
[13:23:05.493]                       else if (inherits(cond, "condition")) {
[13:23:05.493]                         if (!is.null(pattern)) {
[13:23:05.493]                           computeRestarts <- base::computeRestarts
[13:23:05.493]                           grepl <- base::grepl
[13:23:05.493]                           restarts <- computeRestarts(cond)
[13:23:05.493]                           for (restart in restarts) {
[13:23:05.493]                             name <- restart$name
[13:23:05.493]                             if (is.null(name)) 
[13:23:05.493]                               next
[13:23:05.493]                             if (!grepl(pattern, name)) 
[13:23:05.493]                               next
[13:23:05.493]                             invokeRestart(restart)
[13:23:05.493]                             muffled <- TRUE
[13:23:05.493]                             break
[13:23:05.493]                           }
[13:23:05.493]                         }
[13:23:05.493]                       }
[13:23:05.493]                       invisible(muffled)
[13:23:05.493]                     }
[13:23:05.493]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.493]                   }
[13:23:05.493]                 }
[13:23:05.493]             }
[13:23:05.493]         }))
[13:23:05.493]     }, error = function(ex) {
[13:23:05.493]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.493]                 ...future.rng), started = ...future.startTime, 
[13:23:05.493]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.493]             version = "1.8"), class = "FutureResult")
[13:23:05.493]     }, finally = {
[13:23:05.493]         if (!identical(...future.workdir, getwd())) 
[13:23:05.493]             setwd(...future.workdir)
[13:23:05.493]         {
[13:23:05.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.493]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.493]             }
[13:23:05.493]             base::options(...future.oldOptions)
[13:23:05.493]             if (.Platform$OS.type == "windows") {
[13:23:05.493]                 old_names <- names(...future.oldEnvVars)
[13:23:05.493]                 envs <- base::Sys.getenv()
[13:23:05.493]                 names <- names(envs)
[13:23:05.493]                 common <- intersect(names, old_names)
[13:23:05.493]                 added <- setdiff(names, old_names)
[13:23:05.493]                 removed <- setdiff(old_names, names)
[13:23:05.493]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.493]                   envs[common]]
[13:23:05.493]                 NAMES <- toupper(changed)
[13:23:05.493]                 args <- list()
[13:23:05.493]                 for (kk in seq_along(NAMES)) {
[13:23:05.493]                   name <- changed[[kk]]
[13:23:05.493]                   NAME <- NAMES[[kk]]
[13:23:05.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.493]                     next
[13:23:05.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.493]                 }
[13:23:05.493]                 NAMES <- toupper(added)
[13:23:05.493]                 for (kk in seq_along(NAMES)) {
[13:23:05.493]                   name <- added[[kk]]
[13:23:05.493]                   NAME <- NAMES[[kk]]
[13:23:05.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.493]                     next
[13:23:05.493]                   args[[name]] <- ""
[13:23:05.493]                 }
[13:23:05.493]                 NAMES <- toupper(removed)
[13:23:05.493]                 for (kk in seq_along(NAMES)) {
[13:23:05.493]                   name <- removed[[kk]]
[13:23:05.493]                   NAME <- NAMES[[kk]]
[13:23:05.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.493]                     next
[13:23:05.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.493]                 }
[13:23:05.493]                 if (length(args) > 0) 
[13:23:05.493]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.493]             }
[13:23:05.493]             else {
[13:23:05.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.493]             }
[13:23:05.493]             {
[13:23:05.493]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.493]                   0L) {
[13:23:05.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.493]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.493]                   base::options(opts)
[13:23:05.493]                 }
[13:23:05.493]                 {
[13:23:05.493]                   {
[13:23:05.493]                     NULL
[13:23:05.493]                     RNGkind("Mersenne-Twister")
[13:23:05.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.493]                       inherits = FALSE)
[13:23:05.493]                   }
[13:23:05.493]                   options(future.plan = NULL)
[13:23:05.493]                   if (is.na(NA_character_)) 
[13:23:05.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.493]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.493]                   {
[13:23:05.493]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.493]                     if (!future$lazy) 
[13:23:05.493]                       future <- run(future)
[13:23:05.493]                     invisible(future)
[13:23:05.493]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.493]                 }
[13:23:05.493]             }
[13:23:05.493]         }
[13:23:05.493]     })
[13:23:05.493]     if (TRUE) {
[13:23:05.493]         base::sink(type = "output", split = FALSE)
[13:23:05.493]         if (TRUE) {
[13:23:05.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.493]         }
[13:23:05.493]         else {
[13:23:05.493]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.493]         }
[13:23:05.493]         base::close(...future.stdout)
[13:23:05.493]         ...future.stdout <- NULL
[13:23:05.493]     }
[13:23:05.493]     ...future.result$conditions <- ...future.conditions
[13:23:05.493]     ...future.result$finished <- base::Sys.time()
[13:23:05.493]     ...future.result
[13:23:05.493] }
[13:23:05.495] plan(): Setting new future strategy stack:
[13:23:05.495] List of future strategies:
[13:23:05.495] 1. sequential:
[13:23:05.495]    - args: function (..., envir = parent.frame())
[13:23:05.495]    - tweaked: FALSE
[13:23:05.495]    - call: NULL
[13:23:05.495] plan(): nbrOfWorkers() = 1
[13:23:05.496] plan(): Setting new future strategy stack:
[13:23:05.496] List of future strategies:
[13:23:05.496] 1. sequential:
[13:23:05.496]    - args: function (..., envir = parent.frame())
[13:23:05.496]    - tweaked: FALSE
[13:23:05.496]    - call: plan(strategy)
[13:23:05.496] plan(): nbrOfWorkers() = 1
[13:23:05.497] SequentialFuture started (and completed)
[13:23:05.497] - Launch lazy future ... done
[13:23:05.497] run() for ‘SequentialFuture’ ... done
[13:23:05.497] getGlobalsAndPackages() ...
[13:23:05.497] Searching for globals...
[13:23:05.497] 
[13:23:05.498] Searching for globals ... DONE
[13:23:05.498] - globals: [0] <none>
[13:23:05.498] getGlobalsAndPackages() ... DONE
[13:23:05.498] run() for ‘Future’ ...
[13:23:05.498] - state: ‘created’
[13:23:05.498] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.498] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.499]   - Field: ‘label’
[13:23:05.499]   - Field: ‘local’
[13:23:05.499]   - Field: ‘owner’
[13:23:05.499]   - Field: ‘envir’
[13:23:05.499]   - Field: ‘packages’
[13:23:05.499]   - Field: ‘gc’
[13:23:05.499]   - Field: ‘conditions’
[13:23:05.499]   - Field: ‘expr’
[13:23:05.499]   - Field: ‘uuid’
[13:23:05.500]   - Field: ‘seed’
[13:23:05.500]   - Field: ‘version’
[13:23:05.500]   - Field: ‘result’
[13:23:05.500]   - Field: ‘asynchronous’
[13:23:05.500]   - Field: ‘calls’
[13:23:05.500]   - Field: ‘globals’
[13:23:05.500]   - Field: ‘stdout’
[13:23:05.500]   - Field: ‘earlySignal’
[13:23:05.500]   - Field: ‘lazy’
[13:23:05.500]   - Field: ‘state’
[13:23:05.501] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.501] - Launch lazy future ...
[13:23:05.501] Packages needed by the future expression (n = 0): <none>
[13:23:05.501] Packages needed by future strategies (n = 0): <none>
[13:23:05.501] {
[13:23:05.501]     {
[13:23:05.501]         {
[13:23:05.501]             ...future.startTime <- base::Sys.time()
[13:23:05.501]             {
[13:23:05.501]                 {
[13:23:05.501]                   {
[13:23:05.501]                     base::local({
[13:23:05.501]                       has_future <- base::requireNamespace("future", 
[13:23:05.501]                         quietly = TRUE)
[13:23:05.501]                       if (has_future) {
[13:23:05.501]                         ns <- base::getNamespace("future")
[13:23:05.501]                         version <- ns[[".package"]][["version"]]
[13:23:05.501]                         if (is.null(version)) 
[13:23:05.501]                           version <- utils::packageVersion("future")
[13:23:05.501]                       }
[13:23:05.501]                       else {
[13:23:05.501]                         version <- NULL
[13:23:05.501]                       }
[13:23:05.501]                       if (!has_future || version < "1.8.0") {
[13:23:05.501]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.501]                           "", base::R.version$version.string), 
[13:23:05.501]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.501]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.501]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.501]                             "release", "version")], collapse = " "), 
[13:23:05.501]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.501]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.501]                           info)
[13:23:05.501]                         info <- base::paste(info, collapse = "; ")
[13:23:05.501]                         if (!has_future) {
[13:23:05.501]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.501]                             info)
[13:23:05.501]                         }
[13:23:05.501]                         else {
[13:23:05.501]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.501]                             info, version)
[13:23:05.501]                         }
[13:23:05.501]                         base::stop(msg)
[13:23:05.501]                       }
[13:23:05.501]                     })
[13:23:05.501]                   }
[13:23:05.501]                   options(future.plan = NULL)
[13:23:05.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.501]                 }
[13:23:05.501]                 ...future.workdir <- getwd()
[13:23:05.501]             }
[13:23:05.501]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.501]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.501]         }
[13:23:05.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.501]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.501]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.501]             base::names(...future.oldOptions))
[13:23:05.501]     }
[13:23:05.501]     if (FALSE) {
[13:23:05.501]     }
[13:23:05.501]     else {
[13:23:05.501]         if (TRUE) {
[13:23:05.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.501]                 open = "w")
[13:23:05.501]         }
[13:23:05.501]         else {
[13:23:05.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.501]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.501]         }
[13:23:05.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.501]             base::sink(type = "output", split = FALSE)
[13:23:05.501]             base::close(...future.stdout)
[13:23:05.501]         }, add = TRUE)
[13:23:05.501]     }
[13:23:05.501]     ...future.frame <- base::sys.nframe()
[13:23:05.501]     ...future.conditions <- base::list()
[13:23:05.501]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.501]     if (FALSE) {
[13:23:05.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.501]     }
[13:23:05.501]     ...future.result <- base::tryCatch({
[13:23:05.501]         base::withCallingHandlers({
[13:23:05.501]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.501]             future::FutureResult(value = ...future.value$value, 
[13:23:05.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.501]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.501]                     ...future.globalenv.names))
[13:23:05.501]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.501]         }, condition = base::local({
[13:23:05.501]             c <- base::c
[13:23:05.501]             inherits <- base::inherits
[13:23:05.501]             invokeRestart <- base::invokeRestart
[13:23:05.501]             length <- base::length
[13:23:05.501]             list <- base::list
[13:23:05.501]             seq.int <- base::seq.int
[13:23:05.501]             signalCondition <- base::signalCondition
[13:23:05.501]             sys.calls <- base::sys.calls
[13:23:05.501]             `[[` <- base::`[[`
[13:23:05.501]             `+` <- base::`+`
[13:23:05.501]             `<<-` <- base::`<<-`
[13:23:05.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.501]                   3L)]
[13:23:05.501]             }
[13:23:05.501]             function(cond) {
[13:23:05.501]                 is_error <- inherits(cond, "error")
[13:23:05.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.501]                   NULL)
[13:23:05.501]                 if (is_error) {
[13:23:05.501]                   sessionInformation <- function() {
[13:23:05.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.501]                       search = base::search(), system = base::Sys.info())
[13:23:05.501]                   }
[13:23:05.501]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.501]                     cond$call), session = sessionInformation(), 
[13:23:05.501]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.501]                   signalCondition(cond)
[13:23:05.501]                 }
[13:23:05.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.501]                 "immediateCondition"))) {
[13:23:05.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.501]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.501]                   if (TRUE && !signal) {
[13:23:05.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.501]                     {
[13:23:05.501]                       inherits <- base::inherits
[13:23:05.501]                       invokeRestart <- base::invokeRestart
[13:23:05.501]                       is.null <- base::is.null
[13:23:05.501]                       muffled <- FALSE
[13:23:05.501]                       if (inherits(cond, "message")) {
[13:23:05.501]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.501]                         if (muffled) 
[13:23:05.501]                           invokeRestart("muffleMessage")
[13:23:05.501]                       }
[13:23:05.501]                       else if (inherits(cond, "warning")) {
[13:23:05.501]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.501]                         if (muffled) 
[13:23:05.501]                           invokeRestart("muffleWarning")
[13:23:05.501]                       }
[13:23:05.501]                       else if (inherits(cond, "condition")) {
[13:23:05.501]                         if (!is.null(pattern)) {
[13:23:05.501]                           computeRestarts <- base::computeRestarts
[13:23:05.501]                           grepl <- base::grepl
[13:23:05.501]                           restarts <- computeRestarts(cond)
[13:23:05.501]                           for (restart in restarts) {
[13:23:05.501]                             name <- restart$name
[13:23:05.501]                             if (is.null(name)) 
[13:23:05.501]                               next
[13:23:05.501]                             if (!grepl(pattern, name)) 
[13:23:05.501]                               next
[13:23:05.501]                             invokeRestart(restart)
[13:23:05.501]                             muffled <- TRUE
[13:23:05.501]                             break
[13:23:05.501]                           }
[13:23:05.501]                         }
[13:23:05.501]                       }
[13:23:05.501]                       invisible(muffled)
[13:23:05.501]                     }
[13:23:05.501]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.501]                   }
[13:23:05.501]                 }
[13:23:05.501]                 else {
[13:23:05.501]                   if (TRUE) {
[13:23:05.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.501]                     {
[13:23:05.501]                       inherits <- base::inherits
[13:23:05.501]                       invokeRestart <- base::invokeRestart
[13:23:05.501]                       is.null <- base::is.null
[13:23:05.501]                       muffled <- FALSE
[13:23:05.501]                       if (inherits(cond, "message")) {
[13:23:05.501]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.501]                         if (muffled) 
[13:23:05.501]                           invokeRestart("muffleMessage")
[13:23:05.501]                       }
[13:23:05.501]                       else if (inherits(cond, "warning")) {
[13:23:05.501]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.501]                         if (muffled) 
[13:23:05.501]                           invokeRestart("muffleWarning")
[13:23:05.501]                       }
[13:23:05.501]                       else if (inherits(cond, "condition")) {
[13:23:05.501]                         if (!is.null(pattern)) {
[13:23:05.501]                           computeRestarts <- base::computeRestarts
[13:23:05.501]                           grepl <- base::grepl
[13:23:05.501]                           restarts <- computeRestarts(cond)
[13:23:05.501]                           for (restart in restarts) {
[13:23:05.501]                             name <- restart$name
[13:23:05.501]                             if (is.null(name)) 
[13:23:05.501]                               next
[13:23:05.501]                             if (!grepl(pattern, name)) 
[13:23:05.501]                               next
[13:23:05.501]                             invokeRestart(restart)
[13:23:05.501]                             muffled <- TRUE
[13:23:05.501]                             break
[13:23:05.501]                           }
[13:23:05.501]                         }
[13:23:05.501]                       }
[13:23:05.501]                       invisible(muffled)
[13:23:05.501]                     }
[13:23:05.501]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.501]                   }
[13:23:05.501]                 }
[13:23:05.501]             }
[13:23:05.501]         }))
[13:23:05.501]     }, error = function(ex) {
[13:23:05.501]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.501]                 ...future.rng), started = ...future.startTime, 
[13:23:05.501]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.501]             version = "1.8"), class = "FutureResult")
[13:23:05.501]     }, finally = {
[13:23:05.501]         if (!identical(...future.workdir, getwd())) 
[13:23:05.501]             setwd(...future.workdir)
[13:23:05.501]         {
[13:23:05.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.501]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.501]             }
[13:23:05.501]             base::options(...future.oldOptions)
[13:23:05.501]             if (.Platform$OS.type == "windows") {
[13:23:05.501]                 old_names <- names(...future.oldEnvVars)
[13:23:05.501]                 envs <- base::Sys.getenv()
[13:23:05.501]                 names <- names(envs)
[13:23:05.501]                 common <- intersect(names, old_names)
[13:23:05.501]                 added <- setdiff(names, old_names)
[13:23:05.501]                 removed <- setdiff(old_names, names)
[13:23:05.501]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.501]                   envs[common]]
[13:23:05.501]                 NAMES <- toupper(changed)
[13:23:05.501]                 args <- list()
[13:23:05.501]                 for (kk in seq_along(NAMES)) {
[13:23:05.501]                   name <- changed[[kk]]
[13:23:05.501]                   NAME <- NAMES[[kk]]
[13:23:05.501]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.501]                     next
[13:23:05.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.501]                 }
[13:23:05.501]                 NAMES <- toupper(added)
[13:23:05.501]                 for (kk in seq_along(NAMES)) {
[13:23:05.501]                   name <- added[[kk]]
[13:23:05.501]                   NAME <- NAMES[[kk]]
[13:23:05.501]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.501]                     next
[13:23:05.501]                   args[[name]] <- ""
[13:23:05.501]                 }
[13:23:05.501]                 NAMES <- toupper(removed)
[13:23:05.501]                 for (kk in seq_along(NAMES)) {
[13:23:05.501]                   name <- removed[[kk]]
[13:23:05.501]                   NAME <- NAMES[[kk]]
[13:23:05.501]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.501]                     next
[13:23:05.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.501]                 }
[13:23:05.501]                 if (length(args) > 0) 
[13:23:05.501]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.501]             }
[13:23:05.501]             else {
[13:23:05.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.501]             }
[13:23:05.501]             {
[13:23:05.501]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.501]                   0L) {
[13:23:05.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.501]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.501]                   base::options(opts)
[13:23:05.501]                 }
[13:23:05.501]                 {
[13:23:05.501]                   {
[13:23:05.501]                     NULL
[13:23:05.501]                     RNGkind("Mersenne-Twister")
[13:23:05.501]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.501]                       inherits = FALSE)
[13:23:05.501]                   }
[13:23:05.501]                   options(future.plan = NULL)
[13:23:05.501]                   if (is.na(NA_character_)) 
[13:23:05.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.501]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.501]                   {
[13:23:05.501]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.501]                     if (!future$lazy) 
[13:23:05.501]                       future <- run(future)
[13:23:05.501]                     invisible(future)
[13:23:05.501]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.501]                 }
[13:23:05.501]             }
[13:23:05.501]         }
[13:23:05.501]     })
[13:23:05.501]     if (TRUE) {
[13:23:05.501]         base::sink(type = "output", split = FALSE)
[13:23:05.501]         if (TRUE) {
[13:23:05.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.501]         }
[13:23:05.501]         else {
[13:23:05.501]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.501]         }
[13:23:05.501]         base::close(...future.stdout)
[13:23:05.501]         ...future.stdout <- NULL
[13:23:05.501]     }
[13:23:05.501]     ...future.result$conditions <- ...future.conditions
[13:23:05.501]     ...future.result$finished <- base::Sys.time()
[13:23:05.501]     ...future.result
[13:23:05.501] }
[13:23:05.503] plan(): Setting new future strategy stack:
[13:23:05.503] List of future strategies:
[13:23:05.503] 1. sequential:
[13:23:05.503]    - args: function (..., envir = parent.frame())
[13:23:05.503]    - tweaked: FALSE
[13:23:05.503]    - call: NULL
[13:23:05.504] plan(): nbrOfWorkers() = 1
[13:23:05.537] plan(): Setting new future strategy stack:
[13:23:05.537] List of future strategies:
[13:23:05.537] 1. sequential:
[13:23:05.537]    - args: function (..., envir = parent.frame())
[13:23:05.537]    - tweaked: FALSE
[13:23:05.537]    - call: plan(strategy)
[13:23:05.538] plan(): nbrOfWorkers() = 1
[13:23:05.538] SequentialFuture started (and completed)
[13:23:05.538] - Launch lazy future ... done
[13:23:05.538] run() for ‘SequentialFuture’ ... done
[13:23:05.539] getGlobalsAndPackages() ...
[13:23:05.539] Searching for globals...
[13:23:05.540] - globals found: [1] ‘{’
[13:23:05.540] Searching for globals ... DONE
[13:23:05.540] Resolving globals: FALSE
[13:23:05.540] 
[13:23:05.540] 
[13:23:05.540] getGlobalsAndPackages() ... DONE
[13:23:05.541] run() for ‘Future’ ...
[13:23:05.541] - state: ‘created’
[13:23:05.541] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.541] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.541]   - Field: ‘label’
[13:23:05.542]   - Field: ‘local’
[13:23:05.542]   - Field: ‘owner’
[13:23:05.542]   - Field: ‘envir’
[13:23:05.542]   - Field: ‘packages’
[13:23:05.542]   - Field: ‘gc’
[13:23:05.542]   - Field: ‘conditions’
[13:23:05.542]   - Field: ‘expr’
[13:23:05.542]   - Field: ‘uuid’
[13:23:05.542]   - Field: ‘seed’
[13:23:05.542]   - Field: ‘version’
[13:23:05.543]   - Field: ‘result’
[13:23:05.543]   - Field: ‘asynchronous’
[13:23:05.543]   - Field: ‘calls’
[13:23:05.543]   - Field: ‘globals’
[13:23:05.543]   - Field: ‘stdout’
[13:23:05.543]   - Field: ‘earlySignal’
[13:23:05.543]   - Field: ‘lazy’
[13:23:05.543]   - Field: ‘state’
[13:23:05.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.543] - Launch lazy future ...
[13:23:05.544] Packages needed by the future expression (n = 0): <none>
[13:23:05.544] Packages needed by future strategies (n = 0): <none>
[13:23:05.544] {
[13:23:05.544]     {
[13:23:05.544]         {
[13:23:05.544]             ...future.startTime <- base::Sys.time()
[13:23:05.544]             {
[13:23:05.544]                 {
[13:23:05.544]                   {
[13:23:05.544]                     base::local({
[13:23:05.544]                       has_future <- base::requireNamespace("future", 
[13:23:05.544]                         quietly = TRUE)
[13:23:05.544]                       if (has_future) {
[13:23:05.544]                         ns <- base::getNamespace("future")
[13:23:05.544]                         version <- ns[[".package"]][["version"]]
[13:23:05.544]                         if (is.null(version)) 
[13:23:05.544]                           version <- utils::packageVersion("future")
[13:23:05.544]                       }
[13:23:05.544]                       else {
[13:23:05.544]                         version <- NULL
[13:23:05.544]                       }
[13:23:05.544]                       if (!has_future || version < "1.8.0") {
[13:23:05.544]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.544]                           "", base::R.version$version.string), 
[13:23:05.544]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.544]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.544]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.544]                             "release", "version")], collapse = " "), 
[13:23:05.544]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.544]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.544]                           info)
[13:23:05.544]                         info <- base::paste(info, collapse = "; ")
[13:23:05.544]                         if (!has_future) {
[13:23:05.544]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.544]                             info)
[13:23:05.544]                         }
[13:23:05.544]                         else {
[13:23:05.544]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.544]                             info, version)
[13:23:05.544]                         }
[13:23:05.544]                         base::stop(msg)
[13:23:05.544]                       }
[13:23:05.544]                     })
[13:23:05.544]                   }
[13:23:05.544]                   options(future.plan = NULL)
[13:23:05.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.544]                 }
[13:23:05.544]                 ...future.workdir <- getwd()
[13:23:05.544]             }
[13:23:05.544]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.544]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.544]         }
[13:23:05.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.544]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.544]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.544]             base::names(...future.oldOptions))
[13:23:05.544]     }
[13:23:05.544]     if (FALSE) {
[13:23:05.544]     }
[13:23:05.544]     else {
[13:23:05.544]         if (TRUE) {
[13:23:05.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.544]                 open = "w")
[13:23:05.544]         }
[13:23:05.544]         else {
[13:23:05.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.544]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.544]         }
[13:23:05.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.544]             base::sink(type = "output", split = FALSE)
[13:23:05.544]             base::close(...future.stdout)
[13:23:05.544]         }, add = TRUE)
[13:23:05.544]     }
[13:23:05.544]     ...future.frame <- base::sys.nframe()
[13:23:05.544]     ...future.conditions <- base::list()
[13:23:05.544]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.544]     if (FALSE) {
[13:23:05.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.544]     }
[13:23:05.544]     ...future.result <- base::tryCatch({
[13:23:05.544]         base::withCallingHandlers({
[13:23:05.544]             ...future.value <- base::withVisible(base::local({
[13:23:05.544]                 4
[13:23:05.544]             }))
[13:23:05.544]             future::FutureResult(value = ...future.value$value, 
[13:23:05.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.544]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.544]                     ...future.globalenv.names))
[13:23:05.544]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.544]         }, condition = base::local({
[13:23:05.544]             c <- base::c
[13:23:05.544]             inherits <- base::inherits
[13:23:05.544]             invokeRestart <- base::invokeRestart
[13:23:05.544]             length <- base::length
[13:23:05.544]             list <- base::list
[13:23:05.544]             seq.int <- base::seq.int
[13:23:05.544]             signalCondition <- base::signalCondition
[13:23:05.544]             sys.calls <- base::sys.calls
[13:23:05.544]             `[[` <- base::`[[`
[13:23:05.544]             `+` <- base::`+`
[13:23:05.544]             `<<-` <- base::`<<-`
[13:23:05.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.544]                   3L)]
[13:23:05.544]             }
[13:23:05.544]             function(cond) {
[13:23:05.544]                 is_error <- inherits(cond, "error")
[13:23:05.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.544]                   NULL)
[13:23:05.544]                 if (is_error) {
[13:23:05.544]                   sessionInformation <- function() {
[13:23:05.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.544]                       search = base::search(), system = base::Sys.info())
[13:23:05.544]                   }
[13:23:05.544]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.544]                     cond$call), session = sessionInformation(), 
[13:23:05.544]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.544]                   signalCondition(cond)
[13:23:05.544]                 }
[13:23:05.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.544]                 "immediateCondition"))) {
[13:23:05.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.544]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.544]                   if (TRUE && !signal) {
[13:23:05.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.544]                     {
[13:23:05.544]                       inherits <- base::inherits
[13:23:05.544]                       invokeRestart <- base::invokeRestart
[13:23:05.544]                       is.null <- base::is.null
[13:23:05.544]                       muffled <- FALSE
[13:23:05.544]                       if (inherits(cond, "message")) {
[13:23:05.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.544]                         if (muffled) 
[13:23:05.544]                           invokeRestart("muffleMessage")
[13:23:05.544]                       }
[13:23:05.544]                       else if (inherits(cond, "warning")) {
[13:23:05.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.544]                         if (muffled) 
[13:23:05.544]                           invokeRestart("muffleWarning")
[13:23:05.544]                       }
[13:23:05.544]                       else if (inherits(cond, "condition")) {
[13:23:05.544]                         if (!is.null(pattern)) {
[13:23:05.544]                           computeRestarts <- base::computeRestarts
[13:23:05.544]                           grepl <- base::grepl
[13:23:05.544]                           restarts <- computeRestarts(cond)
[13:23:05.544]                           for (restart in restarts) {
[13:23:05.544]                             name <- restart$name
[13:23:05.544]                             if (is.null(name)) 
[13:23:05.544]                               next
[13:23:05.544]                             if (!grepl(pattern, name)) 
[13:23:05.544]                               next
[13:23:05.544]                             invokeRestart(restart)
[13:23:05.544]                             muffled <- TRUE
[13:23:05.544]                             break
[13:23:05.544]                           }
[13:23:05.544]                         }
[13:23:05.544]                       }
[13:23:05.544]                       invisible(muffled)
[13:23:05.544]                     }
[13:23:05.544]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.544]                   }
[13:23:05.544]                 }
[13:23:05.544]                 else {
[13:23:05.544]                   if (TRUE) {
[13:23:05.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.544]                     {
[13:23:05.544]                       inherits <- base::inherits
[13:23:05.544]                       invokeRestart <- base::invokeRestart
[13:23:05.544]                       is.null <- base::is.null
[13:23:05.544]                       muffled <- FALSE
[13:23:05.544]                       if (inherits(cond, "message")) {
[13:23:05.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.544]                         if (muffled) 
[13:23:05.544]                           invokeRestart("muffleMessage")
[13:23:05.544]                       }
[13:23:05.544]                       else if (inherits(cond, "warning")) {
[13:23:05.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.544]                         if (muffled) 
[13:23:05.544]                           invokeRestart("muffleWarning")
[13:23:05.544]                       }
[13:23:05.544]                       else if (inherits(cond, "condition")) {
[13:23:05.544]                         if (!is.null(pattern)) {
[13:23:05.544]                           computeRestarts <- base::computeRestarts
[13:23:05.544]                           grepl <- base::grepl
[13:23:05.544]                           restarts <- computeRestarts(cond)
[13:23:05.544]                           for (restart in restarts) {
[13:23:05.544]                             name <- restart$name
[13:23:05.544]                             if (is.null(name)) 
[13:23:05.544]                               next
[13:23:05.544]                             if (!grepl(pattern, name)) 
[13:23:05.544]                               next
[13:23:05.544]                             invokeRestart(restart)
[13:23:05.544]                             muffled <- TRUE
[13:23:05.544]                             break
[13:23:05.544]                           }
[13:23:05.544]                         }
[13:23:05.544]                       }
[13:23:05.544]                       invisible(muffled)
[13:23:05.544]                     }
[13:23:05.544]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.544]                   }
[13:23:05.544]                 }
[13:23:05.544]             }
[13:23:05.544]         }))
[13:23:05.544]     }, error = function(ex) {
[13:23:05.544]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.544]                 ...future.rng), started = ...future.startTime, 
[13:23:05.544]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.544]             version = "1.8"), class = "FutureResult")
[13:23:05.544]     }, finally = {
[13:23:05.544]         if (!identical(...future.workdir, getwd())) 
[13:23:05.544]             setwd(...future.workdir)
[13:23:05.544]         {
[13:23:05.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.544]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.544]             }
[13:23:05.544]             base::options(...future.oldOptions)
[13:23:05.544]             if (.Platform$OS.type == "windows") {
[13:23:05.544]                 old_names <- names(...future.oldEnvVars)
[13:23:05.544]                 envs <- base::Sys.getenv()
[13:23:05.544]                 names <- names(envs)
[13:23:05.544]                 common <- intersect(names, old_names)
[13:23:05.544]                 added <- setdiff(names, old_names)
[13:23:05.544]                 removed <- setdiff(old_names, names)
[13:23:05.544]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.544]                   envs[common]]
[13:23:05.544]                 NAMES <- toupper(changed)
[13:23:05.544]                 args <- list()
[13:23:05.544]                 for (kk in seq_along(NAMES)) {
[13:23:05.544]                   name <- changed[[kk]]
[13:23:05.544]                   NAME <- NAMES[[kk]]
[13:23:05.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.544]                     next
[13:23:05.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.544]                 }
[13:23:05.544]                 NAMES <- toupper(added)
[13:23:05.544]                 for (kk in seq_along(NAMES)) {
[13:23:05.544]                   name <- added[[kk]]
[13:23:05.544]                   NAME <- NAMES[[kk]]
[13:23:05.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.544]                     next
[13:23:05.544]                   args[[name]] <- ""
[13:23:05.544]                 }
[13:23:05.544]                 NAMES <- toupper(removed)
[13:23:05.544]                 for (kk in seq_along(NAMES)) {
[13:23:05.544]                   name <- removed[[kk]]
[13:23:05.544]                   NAME <- NAMES[[kk]]
[13:23:05.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.544]                     next
[13:23:05.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.544]                 }
[13:23:05.544]                 if (length(args) > 0) 
[13:23:05.544]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.544]             }
[13:23:05.544]             else {
[13:23:05.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.544]             }
[13:23:05.544]             {
[13:23:05.544]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.544]                   0L) {
[13:23:05.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.544]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.544]                   base::options(opts)
[13:23:05.544]                 }
[13:23:05.544]                 {
[13:23:05.544]                   {
[13:23:05.544]                     NULL
[13:23:05.544]                     RNGkind("Mersenne-Twister")
[13:23:05.544]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.544]                       inherits = FALSE)
[13:23:05.544]                   }
[13:23:05.544]                   options(future.plan = NULL)
[13:23:05.544]                   if (is.na(NA_character_)) 
[13:23:05.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.544]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.544]                   {
[13:23:05.544]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.544]                     if (!future$lazy) 
[13:23:05.544]                       future <- run(future)
[13:23:05.544]                     invisible(future)
[13:23:05.544]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.544]                 }
[13:23:05.544]             }
[13:23:05.544]         }
[13:23:05.544]     })
[13:23:05.544]     if (TRUE) {
[13:23:05.544]         base::sink(type = "output", split = FALSE)
[13:23:05.544]         if (TRUE) {
[13:23:05.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.544]         }
[13:23:05.544]         else {
[13:23:05.544]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.544]         }
[13:23:05.544]         base::close(...future.stdout)
[13:23:05.544]         ...future.stdout <- NULL
[13:23:05.544]     }
[13:23:05.544]     ...future.result$conditions <- ...future.conditions
[13:23:05.544]     ...future.result$finished <- base::Sys.time()
[13:23:05.544]     ...future.result
[13:23:05.544] }
[13:23:05.546] plan(): Setting new future strategy stack:
[13:23:05.546] List of future strategies:
[13:23:05.546] 1. sequential:
[13:23:05.546]    - args: function (..., envir = parent.frame())
[13:23:05.546]    - tweaked: FALSE
[13:23:05.546]    - call: NULL
[13:23:05.547] plan(): nbrOfWorkers() = 1
[13:23:05.548] plan(): Setting new future strategy stack:
[13:23:05.548] List of future strategies:
[13:23:05.548] 1. sequential:
[13:23:05.548]    - args: function (..., envir = parent.frame())
[13:23:05.548]    - tweaked: FALSE
[13:23:05.548]    - call: plan(strategy)
[13:23:05.548] plan(): nbrOfWorkers() = 1
[13:23:05.548] SequentialFuture started (and completed)
[13:23:05.548] - Launch lazy future ... done
[13:23:05.549] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d52d9dc0> 
Classes 'listenv', 'environment' <environment: 0x5596d50c03b0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:23:05.553] resolved() for ‘SequentialFuture’ ...
[13:23:05.553] - state: ‘finished’
[13:23:05.553] - run: TRUE
[13:23:05.553] - result: ‘FutureResult’
[13:23:05.553] resolved() for ‘SequentialFuture’ ... done
[13:23:05.553] resolved() for ‘SequentialFuture’ ...
[13:23:05.553] - state: ‘finished’
[13:23:05.553] - run: TRUE
[13:23:05.554] - result: ‘FutureResult’
[13:23:05.554] resolved() for ‘SequentialFuture’ ... done
[13:23:05.554] resolved() for ‘SequentialFuture’ ...
[13:23:05.554] - state: ‘finished’
[13:23:05.554] - run: TRUE
[13:23:05.554] - result: ‘FutureResult’
[13:23:05.554] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:05.557] resolve() on list environment ...
[13:23:05.557]  recursive: 0
[13:23:05.558]  length: 6
[13:23:05.558]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:05.558] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.558] - nx: 6
[13:23:05.558] - relay: TRUE
[13:23:05.558] - stdout: TRUE
[13:23:05.558] - signal: TRUE
[13:23:05.558] - resignal: FALSE
[13:23:05.558] - force: TRUE
[13:23:05.559] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.559] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.559]  - until=2
[13:23:05.559]  - relaying element #2
[13:23:05.559] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.559] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.559] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.559]  length: 5 (resolved future 1)
[13:23:05.559] resolved() for ‘SequentialFuture’ ...
[13:23:05.559] - state: ‘finished’
[13:23:05.560] - run: TRUE
[13:23:05.560] - result: ‘FutureResult’
[13:23:05.560] resolved() for ‘SequentialFuture’ ... done
[13:23:05.560] Future #2
[13:23:05.560] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.560] - nx: 6
[13:23:05.560] - relay: TRUE
[13:23:05.560] - stdout: TRUE
[13:23:05.560] - signal: TRUE
[13:23:05.560] - resignal: FALSE
[13:23:05.561] - force: TRUE
[13:23:05.561] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.561] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.561]  - until=2
[13:23:05.561]  - relaying element #2
[13:23:05.561] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.561] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.561] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.561]  length: 4 (resolved future 2)
[13:23:05.562] resolved() for ‘SequentialFuture’ ...
[13:23:05.562] - state: ‘finished’
[13:23:05.562] - run: TRUE
[13:23:05.562] - result: ‘FutureResult’
[13:23:05.562] resolved() for ‘SequentialFuture’ ... done
[13:23:05.562] Future #3
[13:23:05.562] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.562] - nx: 6
[13:23:05.562] - relay: TRUE
[13:23:05.562] - stdout: TRUE
[13:23:05.563] - signal: TRUE
[13:23:05.563] - resignal: FALSE
[13:23:05.563] - force: TRUE
[13:23:05.563] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.563] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.563]  - until=3
[13:23:05.563]  - relaying element #3
[13:23:05.563] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.563] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.563] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.564]  length: 3 (resolved future 3)
[13:23:05.564] resolved() for ‘SequentialFuture’ ...
[13:23:05.564] - state: ‘finished’
[13:23:05.564] - run: TRUE
[13:23:05.564] - result: ‘FutureResult’
[13:23:05.564] resolved() for ‘SequentialFuture’ ... done
[13:23:05.564] Future #4
[13:23:05.564] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.564] - nx: 6
[13:23:05.564] - relay: TRUE
[13:23:05.565] - stdout: TRUE
[13:23:05.565] - signal: TRUE
[13:23:05.565] - resignal: FALSE
[13:23:05.565] - force: TRUE
[13:23:05.565] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.565] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.565]  - until=4
[13:23:05.565]  - relaying element #4
[13:23:05.567] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.567] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.568] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.568]  length: 2 (resolved future 4)
[13:23:05.568] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.568] - nx: 6
[13:23:05.568] - relay: TRUE
[13:23:05.568] - stdout: TRUE
[13:23:05.568] - signal: TRUE
[13:23:05.568] - resignal: FALSE
[13:23:05.569] - force: TRUE
[13:23:05.569] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.569] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.569]  - until=6
[13:23:05.569]  - relaying element #6
[13:23:05.569] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.569] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.569] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.569]  length: 1 (resolved future 5)
[13:23:05.570] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.570] - nx: 6
[13:23:05.570] - relay: TRUE
[13:23:05.570] - stdout: TRUE
[13:23:05.570] - signal: TRUE
[13:23:05.570] - resignal: FALSE
[13:23:05.570] - force: TRUE
[13:23:05.570] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.570] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.570]  - until=6
[13:23:05.570] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.571] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.571] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.571]  length: 0 (resolved future 6)
[13:23:05.571] Relaying remaining futures
[13:23:05.571] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.571] - nx: 6
[13:23:05.571] - relay: TRUE
[13:23:05.571] - stdout: TRUE
[13:23:05.571] - signal: TRUE
[13:23:05.571] - resignal: FALSE
[13:23:05.571] - force: TRUE
[13:23:05.572] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.572] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:05.572] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.572] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.572] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.572] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5596d55f5d30> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:23:05.574] getGlobalsAndPackages() ...
[13:23:05.575] Searching for globals...
[13:23:05.575] 
[13:23:05.575] Searching for globals ... DONE
[13:23:05.575] - globals: [0] <none>
[13:23:05.575] getGlobalsAndPackages() ... DONE
[13:23:05.576] run() for ‘Future’ ...
[13:23:05.576] - state: ‘created’
[13:23:05.576] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.576] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.576]   - Field: ‘label’
[13:23:05.576]   - Field: ‘local’
[13:23:05.577]   - Field: ‘owner’
[13:23:05.577]   - Field: ‘envir’
[13:23:05.577]   - Field: ‘packages’
[13:23:05.577]   - Field: ‘gc’
[13:23:05.577]   - Field: ‘conditions’
[13:23:05.577]   - Field: ‘expr’
[13:23:05.577]   - Field: ‘uuid’
[13:23:05.577]   - Field: ‘seed’
[13:23:05.577]   - Field: ‘version’
[13:23:05.577]   - Field: ‘result’
[13:23:05.578]   - Field: ‘asynchronous’
[13:23:05.578]   - Field: ‘calls’
[13:23:05.578]   - Field: ‘globals’
[13:23:05.578]   - Field: ‘stdout’
[13:23:05.578]   - Field: ‘earlySignal’
[13:23:05.578]   - Field: ‘lazy’
[13:23:05.578]   - Field: ‘state’
[13:23:05.578] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.578] - Launch lazy future ...
[13:23:05.578] Packages needed by the future expression (n = 0): <none>
[13:23:05.579] Packages needed by future strategies (n = 0): <none>
[13:23:05.579] {
[13:23:05.579]     {
[13:23:05.579]         {
[13:23:05.579]             ...future.startTime <- base::Sys.time()
[13:23:05.579]             {
[13:23:05.579]                 {
[13:23:05.579]                   {
[13:23:05.579]                     base::local({
[13:23:05.579]                       has_future <- base::requireNamespace("future", 
[13:23:05.579]                         quietly = TRUE)
[13:23:05.579]                       if (has_future) {
[13:23:05.579]                         ns <- base::getNamespace("future")
[13:23:05.579]                         version <- ns[[".package"]][["version"]]
[13:23:05.579]                         if (is.null(version)) 
[13:23:05.579]                           version <- utils::packageVersion("future")
[13:23:05.579]                       }
[13:23:05.579]                       else {
[13:23:05.579]                         version <- NULL
[13:23:05.579]                       }
[13:23:05.579]                       if (!has_future || version < "1.8.0") {
[13:23:05.579]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.579]                           "", base::R.version$version.string), 
[13:23:05.579]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.579]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.579]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.579]                             "release", "version")], collapse = " "), 
[13:23:05.579]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.579]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.579]                           info)
[13:23:05.579]                         info <- base::paste(info, collapse = "; ")
[13:23:05.579]                         if (!has_future) {
[13:23:05.579]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.579]                             info)
[13:23:05.579]                         }
[13:23:05.579]                         else {
[13:23:05.579]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.579]                             info, version)
[13:23:05.579]                         }
[13:23:05.579]                         base::stop(msg)
[13:23:05.579]                       }
[13:23:05.579]                     })
[13:23:05.579]                   }
[13:23:05.579]                   options(future.plan = NULL)
[13:23:05.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.579]                 }
[13:23:05.579]                 ...future.workdir <- getwd()
[13:23:05.579]             }
[13:23:05.579]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.579]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.579]         }
[13:23:05.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.579]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.579]             base::names(...future.oldOptions))
[13:23:05.579]     }
[13:23:05.579]     if (FALSE) {
[13:23:05.579]     }
[13:23:05.579]     else {
[13:23:05.579]         if (TRUE) {
[13:23:05.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.579]                 open = "w")
[13:23:05.579]         }
[13:23:05.579]         else {
[13:23:05.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.579]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.579]         }
[13:23:05.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.579]             base::sink(type = "output", split = FALSE)
[13:23:05.579]             base::close(...future.stdout)
[13:23:05.579]         }, add = TRUE)
[13:23:05.579]     }
[13:23:05.579]     ...future.frame <- base::sys.nframe()
[13:23:05.579]     ...future.conditions <- base::list()
[13:23:05.579]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.579]     if (FALSE) {
[13:23:05.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.579]     }
[13:23:05.579]     ...future.result <- base::tryCatch({
[13:23:05.579]         base::withCallingHandlers({
[13:23:05.579]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.579]             future::FutureResult(value = ...future.value$value, 
[13:23:05.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.579]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.579]                     ...future.globalenv.names))
[13:23:05.579]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.579]         }, condition = base::local({
[13:23:05.579]             c <- base::c
[13:23:05.579]             inherits <- base::inherits
[13:23:05.579]             invokeRestart <- base::invokeRestart
[13:23:05.579]             length <- base::length
[13:23:05.579]             list <- base::list
[13:23:05.579]             seq.int <- base::seq.int
[13:23:05.579]             signalCondition <- base::signalCondition
[13:23:05.579]             sys.calls <- base::sys.calls
[13:23:05.579]             `[[` <- base::`[[`
[13:23:05.579]             `+` <- base::`+`
[13:23:05.579]             `<<-` <- base::`<<-`
[13:23:05.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.579]                   3L)]
[13:23:05.579]             }
[13:23:05.579]             function(cond) {
[13:23:05.579]                 is_error <- inherits(cond, "error")
[13:23:05.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.579]                   NULL)
[13:23:05.579]                 if (is_error) {
[13:23:05.579]                   sessionInformation <- function() {
[13:23:05.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.579]                       search = base::search(), system = base::Sys.info())
[13:23:05.579]                   }
[13:23:05.579]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.579]                     cond$call), session = sessionInformation(), 
[13:23:05.579]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.579]                   signalCondition(cond)
[13:23:05.579]                 }
[13:23:05.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.579]                 "immediateCondition"))) {
[13:23:05.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.579]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.579]                   if (TRUE && !signal) {
[13:23:05.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.579]                     {
[13:23:05.579]                       inherits <- base::inherits
[13:23:05.579]                       invokeRestart <- base::invokeRestart
[13:23:05.579]                       is.null <- base::is.null
[13:23:05.579]                       muffled <- FALSE
[13:23:05.579]                       if (inherits(cond, "message")) {
[13:23:05.579]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.579]                         if (muffled) 
[13:23:05.579]                           invokeRestart("muffleMessage")
[13:23:05.579]                       }
[13:23:05.579]                       else if (inherits(cond, "warning")) {
[13:23:05.579]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.579]                         if (muffled) 
[13:23:05.579]                           invokeRestart("muffleWarning")
[13:23:05.579]                       }
[13:23:05.579]                       else if (inherits(cond, "condition")) {
[13:23:05.579]                         if (!is.null(pattern)) {
[13:23:05.579]                           computeRestarts <- base::computeRestarts
[13:23:05.579]                           grepl <- base::grepl
[13:23:05.579]                           restarts <- computeRestarts(cond)
[13:23:05.579]                           for (restart in restarts) {
[13:23:05.579]                             name <- restart$name
[13:23:05.579]                             if (is.null(name)) 
[13:23:05.579]                               next
[13:23:05.579]                             if (!grepl(pattern, name)) 
[13:23:05.579]                               next
[13:23:05.579]                             invokeRestart(restart)
[13:23:05.579]                             muffled <- TRUE
[13:23:05.579]                             break
[13:23:05.579]                           }
[13:23:05.579]                         }
[13:23:05.579]                       }
[13:23:05.579]                       invisible(muffled)
[13:23:05.579]                     }
[13:23:05.579]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.579]                   }
[13:23:05.579]                 }
[13:23:05.579]                 else {
[13:23:05.579]                   if (TRUE) {
[13:23:05.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.579]                     {
[13:23:05.579]                       inherits <- base::inherits
[13:23:05.579]                       invokeRestart <- base::invokeRestart
[13:23:05.579]                       is.null <- base::is.null
[13:23:05.579]                       muffled <- FALSE
[13:23:05.579]                       if (inherits(cond, "message")) {
[13:23:05.579]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.579]                         if (muffled) 
[13:23:05.579]                           invokeRestart("muffleMessage")
[13:23:05.579]                       }
[13:23:05.579]                       else if (inherits(cond, "warning")) {
[13:23:05.579]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.579]                         if (muffled) 
[13:23:05.579]                           invokeRestart("muffleWarning")
[13:23:05.579]                       }
[13:23:05.579]                       else if (inherits(cond, "condition")) {
[13:23:05.579]                         if (!is.null(pattern)) {
[13:23:05.579]                           computeRestarts <- base::computeRestarts
[13:23:05.579]                           grepl <- base::grepl
[13:23:05.579]                           restarts <- computeRestarts(cond)
[13:23:05.579]                           for (restart in restarts) {
[13:23:05.579]                             name <- restart$name
[13:23:05.579]                             if (is.null(name)) 
[13:23:05.579]                               next
[13:23:05.579]                             if (!grepl(pattern, name)) 
[13:23:05.579]                               next
[13:23:05.579]                             invokeRestart(restart)
[13:23:05.579]                             muffled <- TRUE
[13:23:05.579]                             break
[13:23:05.579]                           }
[13:23:05.579]                         }
[13:23:05.579]                       }
[13:23:05.579]                       invisible(muffled)
[13:23:05.579]                     }
[13:23:05.579]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.579]                   }
[13:23:05.579]                 }
[13:23:05.579]             }
[13:23:05.579]         }))
[13:23:05.579]     }, error = function(ex) {
[13:23:05.579]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.579]                 ...future.rng), started = ...future.startTime, 
[13:23:05.579]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.579]             version = "1.8"), class = "FutureResult")
[13:23:05.579]     }, finally = {
[13:23:05.579]         if (!identical(...future.workdir, getwd())) 
[13:23:05.579]             setwd(...future.workdir)
[13:23:05.579]         {
[13:23:05.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.579]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.579]             }
[13:23:05.579]             base::options(...future.oldOptions)
[13:23:05.579]             if (.Platform$OS.type == "windows") {
[13:23:05.579]                 old_names <- names(...future.oldEnvVars)
[13:23:05.579]                 envs <- base::Sys.getenv()
[13:23:05.579]                 names <- names(envs)
[13:23:05.579]                 common <- intersect(names, old_names)
[13:23:05.579]                 added <- setdiff(names, old_names)
[13:23:05.579]                 removed <- setdiff(old_names, names)
[13:23:05.579]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.579]                   envs[common]]
[13:23:05.579]                 NAMES <- toupper(changed)
[13:23:05.579]                 args <- list()
[13:23:05.579]                 for (kk in seq_along(NAMES)) {
[13:23:05.579]                   name <- changed[[kk]]
[13:23:05.579]                   NAME <- NAMES[[kk]]
[13:23:05.579]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.579]                     next
[13:23:05.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.579]                 }
[13:23:05.579]                 NAMES <- toupper(added)
[13:23:05.579]                 for (kk in seq_along(NAMES)) {
[13:23:05.579]                   name <- added[[kk]]
[13:23:05.579]                   NAME <- NAMES[[kk]]
[13:23:05.579]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.579]                     next
[13:23:05.579]                   args[[name]] <- ""
[13:23:05.579]                 }
[13:23:05.579]                 NAMES <- toupper(removed)
[13:23:05.579]                 for (kk in seq_along(NAMES)) {
[13:23:05.579]                   name <- removed[[kk]]
[13:23:05.579]                   NAME <- NAMES[[kk]]
[13:23:05.579]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.579]                     next
[13:23:05.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.579]                 }
[13:23:05.579]                 if (length(args) > 0) 
[13:23:05.579]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.579]             }
[13:23:05.579]             else {
[13:23:05.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.579]             }
[13:23:05.579]             {
[13:23:05.579]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.579]                   0L) {
[13:23:05.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.579]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.579]                   base::options(opts)
[13:23:05.579]                 }
[13:23:05.579]                 {
[13:23:05.579]                   {
[13:23:05.579]                     NULL
[13:23:05.579]                     RNGkind("Mersenne-Twister")
[13:23:05.579]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.579]                       inherits = FALSE)
[13:23:05.579]                   }
[13:23:05.579]                   options(future.plan = NULL)
[13:23:05.579]                   if (is.na(NA_character_)) 
[13:23:05.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.579]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.579]                   {
[13:23:05.579]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.579]                     if (!future$lazy) 
[13:23:05.579]                       future <- run(future)
[13:23:05.579]                     invisible(future)
[13:23:05.579]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.579]                 }
[13:23:05.579]             }
[13:23:05.579]         }
[13:23:05.579]     })
[13:23:05.579]     if (TRUE) {
[13:23:05.579]         base::sink(type = "output", split = FALSE)
[13:23:05.579]         if (TRUE) {
[13:23:05.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.579]         }
[13:23:05.579]         else {
[13:23:05.579]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.579]         }
[13:23:05.579]         base::close(...future.stdout)
[13:23:05.579]         ...future.stdout <- NULL
[13:23:05.579]     }
[13:23:05.579]     ...future.result$conditions <- ...future.conditions
[13:23:05.579]     ...future.result$finished <- base::Sys.time()
[13:23:05.579]     ...future.result
[13:23:05.579] }
[13:23:05.581] plan(): Setting new future strategy stack:
[13:23:05.581] List of future strategies:
[13:23:05.581] 1. sequential:
[13:23:05.581]    - args: function (..., envir = parent.frame())
[13:23:05.581]    - tweaked: FALSE
[13:23:05.581]    - call: NULL
[13:23:05.582] plan(): nbrOfWorkers() = 1
[13:23:05.583] plan(): Setting new future strategy stack:
[13:23:05.583] List of future strategies:
[13:23:05.583] 1. sequential:
[13:23:05.583]    - args: function (..., envir = parent.frame())
[13:23:05.583]    - tweaked: FALSE
[13:23:05.583]    - call: plan(strategy)
[13:23:05.583] plan(): nbrOfWorkers() = 1
[13:23:05.583] SequentialFuture started (and completed)
[13:23:05.583] - Launch lazy future ... done
[13:23:05.583] run() for ‘SequentialFuture’ ... done
[13:23:05.584] getGlobalsAndPackages() ...
[13:23:05.584] Searching for globals...
[13:23:05.584] 
[13:23:05.584] Searching for globals ... DONE
[13:23:05.584] - globals: [0] <none>
[13:23:05.584] getGlobalsAndPackages() ... DONE
[13:23:05.585] run() for ‘Future’ ...
[13:23:05.585] - state: ‘created’
[13:23:05.585] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.585] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.585]   - Field: ‘label’
[13:23:05.585]   - Field: ‘local’
[13:23:05.586]   - Field: ‘owner’
[13:23:05.586]   - Field: ‘envir’
[13:23:05.586]   - Field: ‘packages’
[13:23:05.586]   - Field: ‘gc’
[13:23:05.586]   - Field: ‘conditions’
[13:23:05.586]   - Field: ‘expr’
[13:23:05.586]   - Field: ‘uuid’
[13:23:05.586]   - Field: ‘seed’
[13:23:05.586]   - Field: ‘version’
[13:23:05.586]   - Field: ‘result’
[13:23:05.587]   - Field: ‘asynchronous’
[13:23:05.587]   - Field: ‘calls’
[13:23:05.587]   - Field: ‘globals’
[13:23:05.587]   - Field: ‘stdout’
[13:23:05.587]   - Field: ‘earlySignal’
[13:23:05.587]   - Field: ‘lazy’
[13:23:05.587]   - Field: ‘state’
[13:23:05.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.587] - Launch lazy future ...
[13:23:05.588] Packages needed by the future expression (n = 0): <none>
[13:23:05.588] Packages needed by future strategies (n = 0): <none>
[13:23:05.588] {
[13:23:05.588]     {
[13:23:05.588]         {
[13:23:05.588]             ...future.startTime <- base::Sys.time()
[13:23:05.588]             {
[13:23:05.588]                 {
[13:23:05.588]                   {
[13:23:05.588]                     base::local({
[13:23:05.588]                       has_future <- base::requireNamespace("future", 
[13:23:05.588]                         quietly = TRUE)
[13:23:05.588]                       if (has_future) {
[13:23:05.588]                         ns <- base::getNamespace("future")
[13:23:05.588]                         version <- ns[[".package"]][["version"]]
[13:23:05.588]                         if (is.null(version)) 
[13:23:05.588]                           version <- utils::packageVersion("future")
[13:23:05.588]                       }
[13:23:05.588]                       else {
[13:23:05.588]                         version <- NULL
[13:23:05.588]                       }
[13:23:05.588]                       if (!has_future || version < "1.8.0") {
[13:23:05.588]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.588]                           "", base::R.version$version.string), 
[13:23:05.588]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.588]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.588]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.588]                             "release", "version")], collapse = " "), 
[13:23:05.588]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.588]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.588]                           info)
[13:23:05.588]                         info <- base::paste(info, collapse = "; ")
[13:23:05.588]                         if (!has_future) {
[13:23:05.588]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.588]                             info)
[13:23:05.588]                         }
[13:23:05.588]                         else {
[13:23:05.588]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.588]                             info, version)
[13:23:05.588]                         }
[13:23:05.588]                         base::stop(msg)
[13:23:05.588]                       }
[13:23:05.588]                     })
[13:23:05.588]                   }
[13:23:05.588]                   options(future.plan = NULL)
[13:23:05.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.588]                 }
[13:23:05.588]                 ...future.workdir <- getwd()
[13:23:05.588]             }
[13:23:05.588]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.588]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.588]         }
[13:23:05.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.588]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.588]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.588]             base::names(...future.oldOptions))
[13:23:05.588]     }
[13:23:05.588]     if (FALSE) {
[13:23:05.588]     }
[13:23:05.588]     else {
[13:23:05.588]         if (TRUE) {
[13:23:05.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.588]                 open = "w")
[13:23:05.588]         }
[13:23:05.588]         else {
[13:23:05.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.588]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.588]         }
[13:23:05.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.588]             base::sink(type = "output", split = FALSE)
[13:23:05.588]             base::close(...future.stdout)
[13:23:05.588]         }, add = TRUE)
[13:23:05.588]     }
[13:23:05.588]     ...future.frame <- base::sys.nframe()
[13:23:05.588]     ...future.conditions <- base::list()
[13:23:05.588]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.588]     if (FALSE) {
[13:23:05.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.588]     }
[13:23:05.588]     ...future.result <- base::tryCatch({
[13:23:05.588]         base::withCallingHandlers({
[13:23:05.588]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.588]             future::FutureResult(value = ...future.value$value, 
[13:23:05.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.588]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.588]                     ...future.globalenv.names))
[13:23:05.588]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.588]         }, condition = base::local({
[13:23:05.588]             c <- base::c
[13:23:05.588]             inherits <- base::inherits
[13:23:05.588]             invokeRestart <- base::invokeRestart
[13:23:05.588]             length <- base::length
[13:23:05.588]             list <- base::list
[13:23:05.588]             seq.int <- base::seq.int
[13:23:05.588]             signalCondition <- base::signalCondition
[13:23:05.588]             sys.calls <- base::sys.calls
[13:23:05.588]             `[[` <- base::`[[`
[13:23:05.588]             `+` <- base::`+`
[13:23:05.588]             `<<-` <- base::`<<-`
[13:23:05.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.588]                   3L)]
[13:23:05.588]             }
[13:23:05.588]             function(cond) {
[13:23:05.588]                 is_error <- inherits(cond, "error")
[13:23:05.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.588]                   NULL)
[13:23:05.588]                 if (is_error) {
[13:23:05.588]                   sessionInformation <- function() {
[13:23:05.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.588]                       search = base::search(), system = base::Sys.info())
[13:23:05.588]                   }
[13:23:05.588]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.588]                     cond$call), session = sessionInformation(), 
[13:23:05.588]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.588]                   signalCondition(cond)
[13:23:05.588]                 }
[13:23:05.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.588]                 "immediateCondition"))) {
[13:23:05.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.588]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.588]                   if (TRUE && !signal) {
[13:23:05.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.588]                     {
[13:23:05.588]                       inherits <- base::inherits
[13:23:05.588]                       invokeRestart <- base::invokeRestart
[13:23:05.588]                       is.null <- base::is.null
[13:23:05.588]                       muffled <- FALSE
[13:23:05.588]                       if (inherits(cond, "message")) {
[13:23:05.588]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.588]                         if (muffled) 
[13:23:05.588]                           invokeRestart("muffleMessage")
[13:23:05.588]                       }
[13:23:05.588]                       else if (inherits(cond, "warning")) {
[13:23:05.588]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.588]                         if (muffled) 
[13:23:05.588]                           invokeRestart("muffleWarning")
[13:23:05.588]                       }
[13:23:05.588]                       else if (inherits(cond, "condition")) {
[13:23:05.588]                         if (!is.null(pattern)) {
[13:23:05.588]                           computeRestarts <- base::computeRestarts
[13:23:05.588]                           grepl <- base::grepl
[13:23:05.588]                           restarts <- computeRestarts(cond)
[13:23:05.588]                           for (restart in restarts) {
[13:23:05.588]                             name <- restart$name
[13:23:05.588]                             if (is.null(name)) 
[13:23:05.588]                               next
[13:23:05.588]                             if (!grepl(pattern, name)) 
[13:23:05.588]                               next
[13:23:05.588]                             invokeRestart(restart)
[13:23:05.588]                             muffled <- TRUE
[13:23:05.588]                             break
[13:23:05.588]                           }
[13:23:05.588]                         }
[13:23:05.588]                       }
[13:23:05.588]                       invisible(muffled)
[13:23:05.588]                     }
[13:23:05.588]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.588]                   }
[13:23:05.588]                 }
[13:23:05.588]                 else {
[13:23:05.588]                   if (TRUE) {
[13:23:05.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.588]                     {
[13:23:05.588]                       inherits <- base::inherits
[13:23:05.588]                       invokeRestart <- base::invokeRestart
[13:23:05.588]                       is.null <- base::is.null
[13:23:05.588]                       muffled <- FALSE
[13:23:05.588]                       if (inherits(cond, "message")) {
[13:23:05.588]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.588]                         if (muffled) 
[13:23:05.588]                           invokeRestart("muffleMessage")
[13:23:05.588]                       }
[13:23:05.588]                       else if (inherits(cond, "warning")) {
[13:23:05.588]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.588]                         if (muffled) 
[13:23:05.588]                           invokeRestart("muffleWarning")
[13:23:05.588]                       }
[13:23:05.588]                       else if (inherits(cond, "condition")) {
[13:23:05.588]                         if (!is.null(pattern)) {
[13:23:05.588]                           computeRestarts <- base::computeRestarts
[13:23:05.588]                           grepl <- base::grepl
[13:23:05.588]                           restarts <- computeRestarts(cond)
[13:23:05.588]                           for (restart in restarts) {
[13:23:05.588]                             name <- restart$name
[13:23:05.588]                             if (is.null(name)) 
[13:23:05.588]                               next
[13:23:05.588]                             if (!grepl(pattern, name)) 
[13:23:05.588]                               next
[13:23:05.588]                             invokeRestart(restart)
[13:23:05.588]                             muffled <- TRUE
[13:23:05.588]                             break
[13:23:05.588]                           }
[13:23:05.588]                         }
[13:23:05.588]                       }
[13:23:05.588]                       invisible(muffled)
[13:23:05.588]                     }
[13:23:05.588]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.588]                   }
[13:23:05.588]                 }
[13:23:05.588]             }
[13:23:05.588]         }))
[13:23:05.588]     }, error = function(ex) {
[13:23:05.588]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.588]                 ...future.rng), started = ...future.startTime, 
[13:23:05.588]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.588]             version = "1.8"), class = "FutureResult")
[13:23:05.588]     }, finally = {
[13:23:05.588]         if (!identical(...future.workdir, getwd())) 
[13:23:05.588]             setwd(...future.workdir)
[13:23:05.588]         {
[13:23:05.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.588]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.588]             }
[13:23:05.588]             base::options(...future.oldOptions)
[13:23:05.588]             if (.Platform$OS.type == "windows") {
[13:23:05.588]                 old_names <- names(...future.oldEnvVars)
[13:23:05.588]                 envs <- base::Sys.getenv()
[13:23:05.588]                 names <- names(envs)
[13:23:05.588]                 common <- intersect(names, old_names)
[13:23:05.588]                 added <- setdiff(names, old_names)
[13:23:05.588]                 removed <- setdiff(old_names, names)
[13:23:05.588]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.588]                   envs[common]]
[13:23:05.588]                 NAMES <- toupper(changed)
[13:23:05.588]                 args <- list()
[13:23:05.588]                 for (kk in seq_along(NAMES)) {
[13:23:05.588]                   name <- changed[[kk]]
[13:23:05.588]                   NAME <- NAMES[[kk]]
[13:23:05.588]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.588]                     next
[13:23:05.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.588]                 }
[13:23:05.588]                 NAMES <- toupper(added)
[13:23:05.588]                 for (kk in seq_along(NAMES)) {
[13:23:05.588]                   name <- added[[kk]]
[13:23:05.588]                   NAME <- NAMES[[kk]]
[13:23:05.588]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.588]                     next
[13:23:05.588]                   args[[name]] <- ""
[13:23:05.588]                 }
[13:23:05.588]                 NAMES <- toupper(removed)
[13:23:05.588]                 for (kk in seq_along(NAMES)) {
[13:23:05.588]                   name <- removed[[kk]]
[13:23:05.588]                   NAME <- NAMES[[kk]]
[13:23:05.588]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.588]                     next
[13:23:05.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.588]                 }
[13:23:05.588]                 if (length(args) > 0) 
[13:23:05.588]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.588]             }
[13:23:05.588]             else {
[13:23:05.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.588]             }
[13:23:05.588]             {
[13:23:05.588]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.588]                   0L) {
[13:23:05.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.588]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.588]                   base::options(opts)
[13:23:05.588]                 }
[13:23:05.588]                 {
[13:23:05.588]                   {
[13:23:05.588]                     NULL
[13:23:05.588]                     RNGkind("Mersenne-Twister")
[13:23:05.588]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.588]                       inherits = FALSE)
[13:23:05.588]                   }
[13:23:05.588]                   options(future.plan = NULL)
[13:23:05.588]                   if (is.na(NA_character_)) 
[13:23:05.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.588]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.588]                   {
[13:23:05.588]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.588]                     if (!future$lazy) 
[13:23:05.588]                       future <- run(future)
[13:23:05.588]                     invisible(future)
[13:23:05.588]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.588]                 }
[13:23:05.588]             }
[13:23:05.588]         }
[13:23:05.588]     })
[13:23:05.588]     if (TRUE) {
[13:23:05.588]         base::sink(type = "output", split = FALSE)
[13:23:05.588]         if (TRUE) {
[13:23:05.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.588]         }
[13:23:05.588]         else {
[13:23:05.588]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.588]         }
[13:23:05.588]         base::close(...future.stdout)
[13:23:05.588]         ...future.stdout <- NULL
[13:23:05.588]     }
[13:23:05.588]     ...future.result$conditions <- ...future.conditions
[13:23:05.588]     ...future.result$finished <- base::Sys.time()
[13:23:05.588]     ...future.result
[13:23:05.588] }
[13:23:05.590] plan(): Setting new future strategy stack:
[13:23:05.590] List of future strategies:
[13:23:05.590] 1. sequential:
[13:23:05.590]    - args: function (..., envir = parent.frame())
[13:23:05.590]    - tweaked: FALSE
[13:23:05.590]    - call: NULL
[13:23:05.591] plan(): nbrOfWorkers() = 1
[13:23:05.591] plan(): Setting new future strategy stack:
[13:23:05.591] List of future strategies:
[13:23:05.591] 1. sequential:
[13:23:05.591]    - args: function (..., envir = parent.frame())
[13:23:05.591]    - tweaked: FALSE
[13:23:05.591]    - call: plan(strategy)
[13:23:05.592] plan(): nbrOfWorkers() = 1
[13:23:05.592] SequentialFuture started (and completed)
[13:23:05.592] - Launch lazy future ... done
[13:23:05.592] run() for ‘SequentialFuture’ ... done
[13:23:05.593] getGlobalsAndPackages() ...
[13:23:05.593] Searching for globals...
[13:23:05.593] - globals found: [1] ‘{’
[13:23:05.594] Searching for globals ... DONE
[13:23:05.594] Resolving globals: FALSE
[13:23:05.594] 
[13:23:05.594] 
[13:23:05.594] getGlobalsAndPackages() ... DONE
[13:23:05.594] run() for ‘Future’ ...
[13:23:05.595] - state: ‘created’
[13:23:05.595] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.595] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.595]   - Field: ‘label’
[13:23:05.595]   - Field: ‘local’
[13:23:05.595]   - Field: ‘owner’
[13:23:05.595]   - Field: ‘envir’
[13:23:05.596]   - Field: ‘packages’
[13:23:05.596]   - Field: ‘gc’
[13:23:05.596]   - Field: ‘conditions’
[13:23:05.596]   - Field: ‘expr’
[13:23:05.596]   - Field: ‘uuid’
[13:23:05.596]   - Field: ‘seed’
[13:23:05.596]   - Field: ‘version’
[13:23:05.596]   - Field: ‘result’
[13:23:05.596]   - Field: ‘asynchronous’
[13:23:05.596]   - Field: ‘calls’
[13:23:05.597]   - Field: ‘globals’
[13:23:05.597]   - Field: ‘stdout’
[13:23:05.597]   - Field: ‘earlySignal’
[13:23:05.597]   - Field: ‘lazy’
[13:23:05.597]   - Field: ‘state’
[13:23:05.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.597] - Launch lazy future ...
[13:23:05.597] Packages needed by the future expression (n = 0): <none>
[13:23:05.597] Packages needed by future strategies (n = 0): <none>
[13:23:05.598] {
[13:23:05.598]     {
[13:23:05.598]         {
[13:23:05.598]             ...future.startTime <- base::Sys.time()
[13:23:05.598]             {
[13:23:05.598]                 {
[13:23:05.598]                   {
[13:23:05.598]                     base::local({
[13:23:05.598]                       has_future <- base::requireNamespace("future", 
[13:23:05.598]                         quietly = TRUE)
[13:23:05.598]                       if (has_future) {
[13:23:05.598]                         ns <- base::getNamespace("future")
[13:23:05.598]                         version <- ns[[".package"]][["version"]]
[13:23:05.598]                         if (is.null(version)) 
[13:23:05.598]                           version <- utils::packageVersion("future")
[13:23:05.598]                       }
[13:23:05.598]                       else {
[13:23:05.598]                         version <- NULL
[13:23:05.598]                       }
[13:23:05.598]                       if (!has_future || version < "1.8.0") {
[13:23:05.598]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.598]                           "", base::R.version$version.string), 
[13:23:05.598]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.598]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.598]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.598]                             "release", "version")], collapse = " "), 
[13:23:05.598]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.598]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.598]                           info)
[13:23:05.598]                         info <- base::paste(info, collapse = "; ")
[13:23:05.598]                         if (!has_future) {
[13:23:05.598]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.598]                             info)
[13:23:05.598]                         }
[13:23:05.598]                         else {
[13:23:05.598]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.598]                             info, version)
[13:23:05.598]                         }
[13:23:05.598]                         base::stop(msg)
[13:23:05.598]                       }
[13:23:05.598]                     })
[13:23:05.598]                   }
[13:23:05.598]                   options(future.plan = NULL)
[13:23:05.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.598]                 }
[13:23:05.598]                 ...future.workdir <- getwd()
[13:23:05.598]             }
[13:23:05.598]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.598]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.598]         }
[13:23:05.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.598]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.598]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.598]             base::names(...future.oldOptions))
[13:23:05.598]     }
[13:23:05.598]     if (FALSE) {
[13:23:05.598]     }
[13:23:05.598]     else {
[13:23:05.598]         if (TRUE) {
[13:23:05.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.598]                 open = "w")
[13:23:05.598]         }
[13:23:05.598]         else {
[13:23:05.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.598]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.598]         }
[13:23:05.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.598]             base::sink(type = "output", split = FALSE)
[13:23:05.598]             base::close(...future.stdout)
[13:23:05.598]         }, add = TRUE)
[13:23:05.598]     }
[13:23:05.598]     ...future.frame <- base::sys.nframe()
[13:23:05.598]     ...future.conditions <- base::list()
[13:23:05.598]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.598]     if (FALSE) {
[13:23:05.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.598]     }
[13:23:05.598]     ...future.result <- base::tryCatch({
[13:23:05.598]         base::withCallingHandlers({
[13:23:05.598]             ...future.value <- base::withVisible(base::local({
[13:23:05.598]                 4
[13:23:05.598]             }))
[13:23:05.598]             future::FutureResult(value = ...future.value$value, 
[13:23:05.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.598]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.598]                     ...future.globalenv.names))
[13:23:05.598]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.598]         }, condition = base::local({
[13:23:05.598]             c <- base::c
[13:23:05.598]             inherits <- base::inherits
[13:23:05.598]             invokeRestart <- base::invokeRestart
[13:23:05.598]             length <- base::length
[13:23:05.598]             list <- base::list
[13:23:05.598]             seq.int <- base::seq.int
[13:23:05.598]             signalCondition <- base::signalCondition
[13:23:05.598]             sys.calls <- base::sys.calls
[13:23:05.598]             `[[` <- base::`[[`
[13:23:05.598]             `+` <- base::`+`
[13:23:05.598]             `<<-` <- base::`<<-`
[13:23:05.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.598]                   3L)]
[13:23:05.598]             }
[13:23:05.598]             function(cond) {
[13:23:05.598]                 is_error <- inherits(cond, "error")
[13:23:05.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.598]                   NULL)
[13:23:05.598]                 if (is_error) {
[13:23:05.598]                   sessionInformation <- function() {
[13:23:05.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.598]                       search = base::search(), system = base::Sys.info())
[13:23:05.598]                   }
[13:23:05.598]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.598]                     cond$call), session = sessionInformation(), 
[13:23:05.598]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.598]                   signalCondition(cond)
[13:23:05.598]                 }
[13:23:05.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.598]                 "immediateCondition"))) {
[13:23:05.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.598]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.598]                   if (TRUE && !signal) {
[13:23:05.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.598]                     {
[13:23:05.598]                       inherits <- base::inherits
[13:23:05.598]                       invokeRestart <- base::invokeRestart
[13:23:05.598]                       is.null <- base::is.null
[13:23:05.598]                       muffled <- FALSE
[13:23:05.598]                       if (inherits(cond, "message")) {
[13:23:05.598]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.598]                         if (muffled) 
[13:23:05.598]                           invokeRestart("muffleMessage")
[13:23:05.598]                       }
[13:23:05.598]                       else if (inherits(cond, "warning")) {
[13:23:05.598]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.598]                         if (muffled) 
[13:23:05.598]                           invokeRestart("muffleWarning")
[13:23:05.598]                       }
[13:23:05.598]                       else if (inherits(cond, "condition")) {
[13:23:05.598]                         if (!is.null(pattern)) {
[13:23:05.598]                           computeRestarts <- base::computeRestarts
[13:23:05.598]                           grepl <- base::grepl
[13:23:05.598]                           restarts <- computeRestarts(cond)
[13:23:05.598]                           for (restart in restarts) {
[13:23:05.598]                             name <- restart$name
[13:23:05.598]                             if (is.null(name)) 
[13:23:05.598]                               next
[13:23:05.598]                             if (!grepl(pattern, name)) 
[13:23:05.598]                               next
[13:23:05.598]                             invokeRestart(restart)
[13:23:05.598]                             muffled <- TRUE
[13:23:05.598]                             break
[13:23:05.598]                           }
[13:23:05.598]                         }
[13:23:05.598]                       }
[13:23:05.598]                       invisible(muffled)
[13:23:05.598]                     }
[13:23:05.598]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.598]                   }
[13:23:05.598]                 }
[13:23:05.598]                 else {
[13:23:05.598]                   if (TRUE) {
[13:23:05.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.598]                     {
[13:23:05.598]                       inherits <- base::inherits
[13:23:05.598]                       invokeRestart <- base::invokeRestart
[13:23:05.598]                       is.null <- base::is.null
[13:23:05.598]                       muffled <- FALSE
[13:23:05.598]                       if (inherits(cond, "message")) {
[13:23:05.598]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.598]                         if (muffled) 
[13:23:05.598]                           invokeRestart("muffleMessage")
[13:23:05.598]                       }
[13:23:05.598]                       else if (inherits(cond, "warning")) {
[13:23:05.598]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.598]                         if (muffled) 
[13:23:05.598]                           invokeRestart("muffleWarning")
[13:23:05.598]                       }
[13:23:05.598]                       else if (inherits(cond, "condition")) {
[13:23:05.598]                         if (!is.null(pattern)) {
[13:23:05.598]                           computeRestarts <- base::computeRestarts
[13:23:05.598]                           grepl <- base::grepl
[13:23:05.598]                           restarts <- computeRestarts(cond)
[13:23:05.598]                           for (restart in restarts) {
[13:23:05.598]                             name <- restart$name
[13:23:05.598]                             if (is.null(name)) 
[13:23:05.598]                               next
[13:23:05.598]                             if (!grepl(pattern, name)) 
[13:23:05.598]                               next
[13:23:05.598]                             invokeRestart(restart)
[13:23:05.598]                             muffled <- TRUE
[13:23:05.598]                             break
[13:23:05.598]                           }
[13:23:05.598]                         }
[13:23:05.598]                       }
[13:23:05.598]                       invisible(muffled)
[13:23:05.598]                     }
[13:23:05.598]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.598]                   }
[13:23:05.598]                 }
[13:23:05.598]             }
[13:23:05.598]         }))
[13:23:05.598]     }, error = function(ex) {
[13:23:05.598]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.598]                 ...future.rng), started = ...future.startTime, 
[13:23:05.598]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.598]             version = "1.8"), class = "FutureResult")
[13:23:05.598]     }, finally = {
[13:23:05.598]         if (!identical(...future.workdir, getwd())) 
[13:23:05.598]             setwd(...future.workdir)
[13:23:05.598]         {
[13:23:05.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.598]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.598]             }
[13:23:05.598]             base::options(...future.oldOptions)
[13:23:05.598]             if (.Platform$OS.type == "windows") {
[13:23:05.598]                 old_names <- names(...future.oldEnvVars)
[13:23:05.598]                 envs <- base::Sys.getenv()
[13:23:05.598]                 names <- names(envs)
[13:23:05.598]                 common <- intersect(names, old_names)
[13:23:05.598]                 added <- setdiff(names, old_names)
[13:23:05.598]                 removed <- setdiff(old_names, names)
[13:23:05.598]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.598]                   envs[common]]
[13:23:05.598]                 NAMES <- toupper(changed)
[13:23:05.598]                 args <- list()
[13:23:05.598]                 for (kk in seq_along(NAMES)) {
[13:23:05.598]                   name <- changed[[kk]]
[13:23:05.598]                   NAME <- NAMES[[kk]]
[13:23:05.598]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.598]                     next
[13:23:05.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.598]                 }
[13:23:05.598]                 NAMES <- toupper(added)
[13:23:05.598]                 for (kk in seq_along(NAMES)) {
[13:23:05.598]                   name <- added[[kk]]
[13:23:05.598]                   NAME <- NAMES[[kk]]
[13:23:05.598]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.598]                     next
[13:23:05.598]                   args[[name]] <- ""
[13:23:05.598]                 }
[13:23:05.598]                 NAMES <- toupper(removed)
[13:23:05.598]                 for (kk in seq_along(NAMES)) {
[13:23:05.598]                   name <- removed[[kk]]
[13:23:05.598]                   NAME <- NAMES[[kk]]
[13:23:05.598]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.598]                     next
[13:23:05.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.598]                 }
[13:23:05.598]                 if (length(args) > 0) 
[13:23:05.598]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.598]             }
[13:23:05.598]             else {
[13:23:05.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.598]             }
[13:23:05.598]             {
[13:23:05.598]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.598]                   0L) {
[13:23:05.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.598]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.598]                   base::options(opts)
[13:23:05.598]                 }
[13:23:05.598]                 {
[13:23:05.598]                   {
[13:23:05.598]                     NULL
[13:23:05.598]                     RNGkind("Mersenne-Twister")
[13:23:05.598]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.598]                       inherits = FALSE)
[13:23:05.598]                   }
[13:23:05.598]                   options(future.plan = NULL)
[13:23:05.598]                   if (is.na(NA_character_)) 
[13:23:05.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.598]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.598]                   {
[13:23:05.598]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.598]                     if (!future$lazy) 
[13:23:05.598]                       future <- run(future)
[13:23:05.598]                     invisible(future)
[13:23:05.598]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.598]                 }
[13:23:05.598]             }
[13:23:05.598]         }
[13:23:05.598]     })
[13:23:05.598]     if (TRUE) {
[13:23:05.598]         base::sink(type = "output", split = FALSE)
[13:23:05.598]         if (TRUE) {
[13:23:05.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.598]         }
[13:23:05.598]         else {
[13:23:05.598]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.598]         }
[13:23:05.598]         base::close(...future.stdout)
[13:23:05.598]         ...future.stdout <- NULL
[13:23:05.598]     }
[13:23:05.598]     ...future.result$conditions <- ...future.conditions
[13:23:05.598]     ...future.result$finished <- base::Sys.time()
[13:23:05.598]     ...future.result
[13:23:05.598] }
[13:23:05.602] plan(): Setting new future strategy stack:
[13:23:05.602] List of future strategies:
[13:23:05.602] 1. sequential:
[13:23:05.602]    - args: function (..., envir = parent.frame())
[13:23:05.602]    - tweaked: FALSE
[13:23:05.602]    - call: NULL
[13:23:05.602] plan(): nbrOfWorkers() = 1
[13:23:05.603] plan(): Setting new future strategy stack:
[13:23:05.603] List of future strategies:
[13:23:05.603] 1. sequential:
[13:23:05.603]    - args: function (..., envir = parent.frame())
[13:23:05.603]    - tweaked: FALSE
[13:23:05.603]    - call: plan(strategy)
[13:23:05.604] plan(): nbrOfWorkers() = 1
[13:23:05.604] SequentialFuture started (and completed)
[13:23:05.604] - Launch lazy future ... done
[13:23:05.605] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d3845ee0> 
Classes 'listenv', 'environment' <environment: 0x5596d432fb80> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:23:05.609] resolved() for ‘SequentialFuture’ ...
[13:23:05.609] - state: ‘finished’
[13:23:05.609] - run: TRUE
[13:23:05.609] - result: ‘FutureResult’
[13:23:05.609] resolved() for ‘SequentialFuture’ ... done
[13:23:05.609] resolved() for ‘SequentialFuture’ ...
[13:23:05.609] - state: ‘finished’
[13:23:05.609] - run: TRUE
[13:23:05.609] - result: ‘FutureResult’
[13:23:05.610] resolved() for ‘SequentialFuture’ ... done
[13:23:05.610] resolved() for ‘SequentialFuture’ ...
[13:23:05.610] - state: ‘finished’
[13:23:05.610] - run: TRUE
[13:23:05.610] - result: ‘FutureResult’
[13:23:05.610] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:05.613] resolve() on list environment ...
[13:23:05.613]  recursive: 0
[13:23:05.614]  length: 6
[13:23:05.614]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:05.614] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.614] - nx: 6
[13:23:05.614] - relay: TRUE
[13:23:05.614] - stdout: TRUE
[13:23:05.614] - signal: TRUE
[13:23:05.614] - resignal: FALSE
[13:23:05.614] - force: TRUE
[13:23:05.615] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.615] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.615]  - until=2
[13:23:05.615]  - relaying element #2
[13:23:05.615] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.615] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.615] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.615]  length: 5 (resolved future 1)
[13:23:05.615] resolved() for ‘SequentialFuture’ ...
[13:23:05.615] - state: ‘finished’
[13:23:05.616] - run: TRUE
[13:23:05.616] - result: ‘FutureResult’
[13:23:05.616] resolved() for ‘SequentialFuture’ ... done
[13:23:05.616] Future #2
[13:23:05.616] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.616] - nx: 6
[13:23:05.616] - relay: TRUE
[13:23:05.616] - stdout: TRUE
[13:23:05.616] - signal: TRUE
[13:23:05.617] - resignal: FALSE
[13:23:05.617] - force: TRUE
[13:23:05.617] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.617] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.617]  - until=2
[13:23:05.617]  - relaying element #2
[13:23:05.617] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.617] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.617] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.617]  length: 4 (resolved future 2)
[13:23:05.618] resolved() for ‘SequentialFuture’ ...
[13:23:05.618] - state: ‘finished’
[13:23:05.618] - run: TRUE
[13:23:05.618] - result: ‘FutureResult’
[13:23:05.618] resolved() for ‘SequentialFuture’ ... done
[13:23:05.618] Future #3
[13:23:05.618] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.618] - nx: 6
[13:23:05.618] - relay: TRUE
[13:23:05.618] - stdout: TRUE
[13:23:05.619] - signal: TRUE
[13:23:05.619] - resignal: FALSE
[13:23:05.619] - force: TRUE
[13:23:05.619] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.619] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.619]  - until=3
[13:23:05.619]  - relaying element #3
[13:23:05.619] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.619] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.619] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.620]  length: 3 (resolved future 3)
[13:23:05.620] resolved() for ‘SequentialFuture’ ...
[13:23:05.620] - state: ‘finished’
[13:23:05.620] - run: TRUE
[13:23:05.620] - result: ‘FutureResult’
[13:23:05.620] resolved() for ‘SequentialFuture’ ... done
[13:23:05.620] Future #4
[13:23:05.620] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.620] - nx: 6
[13:23:05.621] - relay: TRUE
[13:23:05.621] - stdout: TRUE
[13:23:05.621] - signal: TRUE
[13:23:05.621] - resignal: FALSE
[13:23:05.621] - force: TRUE
[13:23:05.621] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.621] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.621]  - until=4
[13:23:05.621]  - relaying element #4
[13:23:05.621] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.622] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.622] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.622]  length: 2 (resolved future 4)
[13:23:05.622] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.622] - nx: 6
[13:23:05.622] - relay: TRUE
[13:23:05.622] - stdout: TRUE
[13:23:05.622] - signal: TRUE
[13:23:05.622] - resignal: FALSE
[13:23:05.622] - force: TRUE
[13:23:05.622] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.623] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.623]  - until=6
[13:23:05.623]  - relaying element #6
[13:23:05.623] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.623] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.623] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.623]  length: 1 (resolved future 5)
[13:23:05.623] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.623] - nx: 6
[13:23:05.623] - relay: TRUE
[13:23:05.623] - stdout: TRUE
[13:23:05.624] - signal: TRUE
[13:23:05.624] - resignal: FALSE
[13:23:05.624] - force: TRUE
[13:23:05.624] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.624] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.624]  - until=6
[13:23:05.624] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.624] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.624] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.624]  length: 0 (resolved future 6)
[13:23:05.624] Relaying remaining futures
[13:23:05.625] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.625] - nx: 6
[13:23:05.625] - relay: TRUE
[13:23:05.625] - stdout: TRUE
[13:23:05.625] - signal: TRUE
[13:23:05.625] - resignal: FALSE
[13:23:05.625] - force: TRUE
[13:23:05.625] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.625] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:05.625] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.625] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.626] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.626] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5596d50d1cb0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:23:05.630] getGlobalsAndPackages() ...
[13:23:05.630] Searching for globals...
[13:23:05.630] 
[13:23:05.630] Searching for globals ... DONE
[13:23:05.631] - globals: [0] <none>
[13:23:05.631] getGlobalsAndPackages() ... DONE
[13:23:05.631] run() for ‘Future’ ...
[13:23:05.631] - state: ‘created’
[13:23:05.631] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.632] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.632]   - Field: ‘label’
[13:23:05.632]   - Field: ‘local’
[13:23:05.632]   - Field: ‘owner’
[13:23:05.632]   - Field: ‘envir’
[13:23:05.632]   - Field: ‘packages’
[13:23:05.632]   - Field: ‘gc’
[13:23:05.633]   - Field: ‘conditions’
[13:23:05.633]   - Field: ‘expr’
[13:23:05.633]   - Field: ‘uuid’
[13:23:05.633]   - Field: ‘seed’
[13:23:05.633]   - Field: ‘version’
[13:23:05.633]   - Field: ‘result’
[13:23:05.633]   - Field: ‘asynchronous’
[13:23:05.633]   - Field: ‘calls’
[13:23:05.633]   - Field: ‘globals’
[13:23:05.633]   - Field: ‘stdout’
[13:23:05.634]   - Field: ‘earlySignal’
[13:23:05.634]   - Field: ‘lazy’
[13:23:05.634]   - Field: ‘state’
[13:23:05.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.634] - Launch lazy future ...
[13:23:05.634] Packages needed by the future expression (n = 0): <none>
[13:23:05.634] Packages needed by future strategies (n = 0): <none>
[13:23:05.635] {
[13:23:05.635]     {
[13:23:05.635]         {
[13:23:05.635]             ...future.startTime <- base::Sys.time()
[13:23:05.635]             {
[13:23:05.635]                 {
[13:23:05.635]                   {
[13:23:05.635]                     base::local({
[13:23:05.635]                       has_future <- base::requireNamespace("future", 
[13:23:05.635]                         quietly = TRUE)
[13:23:05.635]                       if (has_future) {
[13:23:05.635]                         ns <- base::getNamespace("future")
[13:23:05.635]                         version <- ns[[".package"]][["version"]]
[13:23:05.635]                         if (is.null(version)) 
[13:23:05.635]                           version <- utils::packageVersion("future")
[13:23:05.635]                       }
[13:23:05.635]                       else {
[13:23:05.635]                         version <- NULL
[13:23:05.635]                       }
[13:23:05.635]                       if (!has_future || version < "1.8.0") {
[13:23:05.635]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.635]                           "", base::R.version$version.string), 
[13:23:05.635]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.635]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.635]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.635]                             "release", "version")], collapse = " "), 
[13:23:05.635]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.635]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.635]                           info)
[13:23:05.635]                         info <- base::paste(info, collapse = "; ")
[13:23:05.635]                         if (!has_future) {
[13:23:05.635]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.635]                             info)
[13:23:05.635]                         }
[13:23:05.635]                         else {
[13:23:05.635]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.635]                             info, version)
[13:23:05.635]                         }
[13:23:05.635]                         base::stop(msg)
[13:23:05.635]                       }
[13:23:05.635]                     })
[13:23:05.635]                   }
[13:23:05.635]                   options(future.plan = NULL)
[13:23:05.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.635]                 }
[13:23:05.635]                 ...future.workdir <- getwd()
[13:23:05.635]             }
[13:23:05.635]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.635]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.635]         }
[13:23:05.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.635]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.635]             base::names(...future.oldOptions))
[13:23:05.635]     }
[13:23:05.635]     if (FALSE) {
[13:23:05.635]     }
[13:23:05.635]     else {
[13:23:05.635]         if (TRUE) {
[13:23:05.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.635]                 open = "w")
[13:23:05.635]         }
[13:23:05.635]         else {
[13:23:05.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.635]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.635]         }
[13:23:05.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.635]             base::sink(type = "output", split = FALSE)
[13:23:05.635]             base::close(...future.stdout)
[13:23:05.635]         }, add = TRUE)
[13:23:05.635]     }
[13:23:05.635]     ...future.frame <- base::sys.nframe()
[13:23:05.635]     ...future.conditions <- base::list()
[13:23:05.635]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.635]     if (FALSE) {
[13:23:05.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.635]     }
[13:23:05.635]     ...future.result <- base::tryCatch({
[13:23:05.635]         base::withCallingHandlers({
[13:23:05.635]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.635]             future::FutureResult(value = ...future.value$value, 
[13:23:05.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.635]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.635]                     ...future.globalenv.names))
[13:23:05.635]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.635]         }, condition = base::local({
[13:23:05.635]             c <- base::c
[13:23:05.635]             inherits <- base::inherits
[13:23:05.635]             invokeRestart <- base::invokeRestart
[13:23:05.635]             length <- base::length
[13:23:05.635]             list <- base::list
[13:23:05.635]             seq.int <- base::seq.int
[13:23:05.635]             signalCondition <- base::signalCondition
[13:23:05.635]             sys.calls <- base::sys.calls
[13:23:05.635]             `[[` <- base::`[[`
[13:23:05.635]             `+` <- base::`+`
[13:23:05.635]             `<<-` <- base::`<<-`
[13:23:05.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.635]                   3L)]
[13:23:05.635]             }
[13:23:05.635]             function(cond) {
[13:23:05.635]                 is_error <- inherits(cond, "error")
[13:23:05.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.635]                   NULL)
[13:23:05.635]                 if (is_error) {
[13:23:05.635]                   sessionInformation <- function() {
[13:23:05.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.635]                       search = base::search(), system = base::Sys.info())
[13:23:05.635]                   }
[13:23:05.635]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.635]                     cond$call), session = sessionInformation(), 
[13:23:05.635]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.635]                   signalCondition(cond)
[13:23:05.635]                 }
[13:23:05.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.635]                 "immediateCondition"))) {
[13:23:05.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.635]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.635]                   if (TRUE && !signal) {
[13:23:05.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.635]                     {
[13:23:05.635]                       inherits <- base::inherits
[13:23:05.635]                       invokeRestart <- base::invokeRestart
[13:23:05.635]                       is.null <- base::is.null
[13:23:05.635]                       muffled <- FALSE
[13:23:05.635]                       if (inherits(cond, "message")) {
[13:23:05.635]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.635]                         if (muffled) 
[13:23:05.635]                           invokeRestart("muffleMessage")
[13:23:05.635]                       }
[13:23:05.635]                       else if (inherits(cond, "warning")) {
[13:23:05.635]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.635]                         if (muffled) 
[13:23:05.635]                           invokeRestart("muffleWarning")
[13:23:05.635]                       }
[13:23:05.635]                       else if (inherits(cond, "condition")) {
[13:23:05.635]                         if (!is.null(pattern)) {
[13:23:05.635]                           computeRestarts <- base::computeRestarts
[13:23:05.635]                           grepl <- base::grepl
[13:23:05.635]                           restarts <- computeRestarts(cond)
[13:23:05.635]                           for (restart in restarts) {
[13:23:05.635]                             name <- restart$name
[13:23:05.635]                             if (is.null(name)) 
[13:23:05.635]                               next
[13:23:05.635]                             if (!grepl(pattern, name)) 
[13:23:05.635]                               next
[13:23:05.635]                             invokeRestart(restart)
[13:23:05.635]                             muffled <- TRUE
[13:23:05.635]                             break
[13:23:05.635]                           }
[13:23:05.635]                         }
[13:23:05.635]                       }
[13:23:05.635]                       invisible(muffled)
[13:23:05.635]                     }
[13:23:05.635]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.635]                   }
[13:23:05.635]                 }
[13:23:05.635]                 else {
[13:23:05.635]                   if (TRUE) {
[13:23:05.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.635]                     {
[13:23:05.635]                       inherits <- base::inherits
[13:23:05.635]                       invokeRestart <- base::invokeRestart
[13:23:05.635]                       is.null <- base::is.null
[13:23:05.635]                       muffled <- FALSE
[13:23:05.635]                       if (inherits(cond, "message")) {
[13:23:05.635]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.635]                         if (muffled) 
[13:23:05.635]                           invokeRestart("muffleMessage")
[13:23:05.635]                       }
[13:23:05.635]                       else if (inherits(cond, "warning")) {
[13:23:05.635]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.635]                         if (muffled) 
[13:23:05.635]                           invokeRestart("muffleWarning")
[13:23:05.635]                       }
[13:23:05.635]                       else if (inherits(cond, "condition")) {
[13:23:05.635]                         if (!is.null(pattern)) {
[13:23:05.635]                           computeRestarts <- base::computeRestarts
[13:23:05.635]                           grepl <- base::grepl
[13:23:05.635]                           restarts <- computeRestarts(cond)
[13:23:05.635]                           for (restart in restarts) {
[13:23:05.635]                             name <- restart$name
[13:23:05.635]                             if (is.null(name)) 
[13:23:05.635]                               next
[13:23:05.635]                             if (!grepl(pattern, name)) 
[13:23:05.635]                               next
[13:23:05.635]                             invokeRestart(restart)
[13:23:05.635]                             muffled <- TRUE
[13:23:05.635]                             break
[13:23:05.635]                           }
[13:23:05.635]                         }
[13:23:05.635]                       }
[13:23:05.635]                       invisible(muffled)
[13:23:05.635]                     }
[13:23:05.635]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.635]                   }
[13:23:05.635]                 }
[13:23:05.635]             }
[13:23:05.635]         }))
[13:23:05.635]     }, error = function(ex) {
[13:23:05.635]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.635]                 ...future.rng), started = ...future.startTime, 
[13:23:05.635]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.635]             version = "1.8"), class = "FutureResult")
[13:23:05.635]     }, finally = {
[13:23:05.635]         if (!identical(...future.workdir, getwd())) 
[13:23:05.635]             setwd(...future.workdir)
[13:23:05.635]         {
[13:23:05.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.635]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.635]             }
[13:23:05.635]             base::options(...future.oldOptions)
[13:23:05.635]             if (.Platform$OS.type == "windows") {
[13:23:05.635]                 old_names <- names(...future.oldEnvVars)
[13:23:05.635]                 envs <- base::Sys.getenv()
[13:23:05.635]                 names <- names(envs)
[13:23:05.635]                 common <- intersect(names, old_names)
[13:23:05.635]                 added <- setdiff(names, old_names)
[13:23:05.635]                 removed <- setdiff(old_names, names)
[13:23:05.635]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.635]                   envs[common]]
[13:23:05.635]                 NAMES <- toupper(changed)
[13:23:05.635]                 args <- list()
[13:23:05.635]                 for (kk in seq_along(NAMES)) {
[13:23:05.635]                   name <- changed[[kk]]
[13:23:05.635]                   NAME <- NAMES[[kk]]
[13:23:05.635]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.635]                     next
[13:23:05.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.635]                 }
[13:23:05.635]                 NAMES <- toupper(added)
[13:23:05.635]                 for (kk in seq_along(NAMES)) {
[13:23:05.635]                   name <- added[[kk]]
[13:23:05.635]                   NAME <- NAMES[[kk]]
[13:23:05.635]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.635]                     next
[13:23:05.635]                   args[[name]] <- ""
[13:23:05.635]                 }
[13:23:05.635]                 NAMES <- toupper(removed)
[13:23:05.635]                 for (kk in seq_along(NAMES)) {
[13:23:05.635]                   name <- removed[[kk]]
[13:23:05.635]                   NAME <- NAMES[[kk]]
[13:23:05.635]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.635]                     next
[13:23:05.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.635]                 }
[13:23:05.635]                 if (length(args) > 0) 
[13:23:05.635]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.635]             }
[13:23:05.635]             else {
[13:23:05.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.635]             }
[13:23:05.635]             {
[13:23:05.635]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.635]                   0L) {
[13:23:05.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.635]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.635]                   base::options(opts)
[13:23:05.635]                 }
[13:23:05.635]                 {
[13:23:05.635]                   {
[13:23:05.635]                     NULL
[13:23:05.635]                     RNGkind("Mersenne-Twister")
[13:23:05.635]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.635]                       inherits = FALSE)
[13:23:05.635]                   }
[13:23:05.635]                   options(future.plan = NULL)
[13:23:05.635]                   if (is.na(NA_character_)) 
[13:23:05.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.635]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.635]                   {
[13:23:05.635]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.635]                     if (!future$lazy) 
[13:23:05.635]                       future <- run(future)
[13:23:05.635]                     invisible(future)
[13:23:05.635]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.635]                 }
[13:23:05.635]             }
[13:23:05.635]         }
[13:23:05.635]     })
[13:23:05.635]     if (TRUE) {
[13:23:05.635]         base::sink(type = "output", split = FALSE)
[13:23:05.635]         if (TRUE) {
[13:23:05.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.635]         }
[13:23:05.635]         else {
[13:23:05.635]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.635]         }
[13:23:05.635]         base::close(...future.stdout)
[13:23:05.635]         ...future.stdout <- NULL
[13:23:05.635]     }
[13:23:05.635]     ...future.result$conditions <- ...future.conditions
[13:23:05.635]     ...future.result$finished <- base::Sys.time()
[13:23:05.635]     ...future.result
[13:23:05.635] }
[13:23:05.637] plan(): Setting new future strategy stack:
[13:23:05.637] List of future strategies:
[13:23:05.637] 1. sequential:
[13:23:05.637]    - args: function (..., envir = parent.frame())
[13:23:05.637]    - tweaked: FALSE
[13:23:05.637]    - call: NULL
[13:23:05.637] plan(): nbrOfWorkers() = 1
[13:23:05.638] plan(): Setting new future strategy stack:
[13:23:05.638] List of future strategies:
[13:23:05.638] 1. sequential:
[13:23:05.638]    - args: function (..., envir = parent.frame())
[13:23:05.638]    - tweaked: FALSE
[13:23:05.638]    - call: plan(strategy)
[13:23:05.639] plan(): nbrOfWorkers() = 1
[13:23:05.639] SequentialFuture started (and completed)
[13:23:05.639] - Launch lazy future ... done
[13:23:05.639] run() for ‘SequentialFuture’ ... done
[13:23:05.639] getGlobalsAndPackages() ...
[13:23:05.639] Searching for globals...
[13:23:05.639] 
[13:23:05.640] Searching for globals ... DONE
[13:23:05.640] - globals: [0] <none>
[13:23:05.640] getGlobalsAndPackages() ... DONE
[13:23:05.640] run() for ‘Future’ ...
[13:23:05.640] - state: ‘created’
[13:23:05.640] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.641] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.641]   - Field: ‘label’
[13:23:05.641]   - Field: ‘local’
[13:23:05.641]   - Field: ‘owner’
[13:23:05.641]   - Field: ‘envir’
[13:23:05.641]   - Field: ‘packages’
[13:23:05.641]   - Field: ‘gc’
[13:23:05.641]   - Field: ‘conditions’
[13:23:05.642]   - Field: ‘expr’
[13:23:05.642]   - Field: ‘uuid’
[13:23:05.642]   - Field: ‘seed’
[13:23:05.642]   - Field: ‘version’
[13:23:05.642]   - Field: ‘result’
[13:23:05.642]   - Field: ‘asynchronous’
[13:23:05.642]   - Field: ‘calls’
[13:23:05.642]   - Field: ‘globals’
[13:23:05.642]   - Field: ‘stdout’
[13:23:05.642]   - Field: ‘earlySignal’
[13:23:05.643]   - Field: ‘lazy’
[13:23:05.643]   - Field: ‘state’
[13:23:05.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.643] - Launch lazy future ...
[13:23:05.643] Packages needed by the future expression (n = 0): <none>
[13:23:05.643] Packages needed by future strategies (n = 0): <none>
[13:23:05.644] {
[13:23:05.644]     {
[13:23:05.644]         {
[13:23:05.644]             ...future.startTime <- base::Sys.time()
[13:23:05.644]             {
[13:23:05.644]                 {
[13:23:05.644]                   {
[13:23:05.644]                     base::local({
[13:23:05.644]                       has_future <- base::requireNamespace("future", 
[13:23:05.644]                         quietly = TRUE)
[13:23:05.644]                       if (has_future) {
[13:23:05.644]                         ns <- base::getNamespace("future")
[13:23:05.644]                         version <- ns[[".package"]][["version"]]
[13:23:05.644]                         if (is.null(version)) 
[13:23:05.644]                           version <- utils::packageVersion("future")
[13:23:05.644]                       }
[13:23:05.644]                       else {
[13:23:05.644]                         version <- NULL
[13:23:05.644]                       }
[13:23:05.644]                       if (!has_future || version < "1.8.0") {
[13:23:05.644]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.644]                           "", base::R.version$version.string), 
[13:23:05.644]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.644]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.644]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.644]                             "release", "version")], collapse = " "), 
[13:23:05.644]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.644]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.644]                           info)
[13:23:05.644]                         info <- base::paste(info, collapse = "; ")
[13:23:05.644]                         if (!has_future) {
[13:23:05.644]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.644]                             info)
[13:23:05.644]                         }
[13:23:05.644]                         else {
[13:23:05.644]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.644]                             info, version)
[13:23:05.644]                         }
[13:23:05.644]                         base::stop(msg)
[13:23:05.644]                       }
[13:23:05.644]                     })
[13:23:05.644]                   }
[13:23:05.644]                   options(future.plan = NULL)
[13:23:05.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.644]                 }
[13:23:05.644]                 ...future.workdir <- getwd()
[13:23:05.644]             }
[13:23:05.644]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.644]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.644]         }
[13:23:05.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.644]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.644]             base::names(...future.oldOptions))
[13:23:05.644]     }
[13:23:05.644]     if (FALSE) {
[13:23:05.644]     }
[13:23:05.644]     else {
[13:23:05.644]         if (TRUE) {
[13:23:05.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.644]                 open = "w")
[13:23:05.644]         }
[13:23:05.644]         else {
[13:23:05.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.644]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.644]         }
[13:23:05.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.644]             base::sink(type = "output", split = FALSE)
[13:23:05.644]             base::close(...future.stdout)
[13:23:05.644]         }, add = TRUE)
[13:23:05.644]     }
[13:23:05.644]     ...future.frame <- base::sys.nframe()
[13:23:05.644]     ...future.conditions <- base::list()
[13:23:05.644]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.644]     if (FALSE) {
[13:23:05.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.644]     }
[13:23:05.644]     ...future.result <- base::tryCatch({
[13:23:05.644]         base::withCallingHandlers({
[13:23:05.644]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.644]             future::FutureResult(value = ...future.value$value, 
[13:23:05.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.644]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.644]                     ...future.globalenv.names))
[13:23:05.644]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.644]         }, condition = base::local({
[13:23:05.644]             c <- base::c
[13:23:05.644]             inherits <- base::inherits
[13:23:05.644]             invokeRestart <- base::invokeRestart
[13:23:05.644]             length <- base::length
[13:23:05.644]             list <- base::list
[13:23:05.644]             seq.int <- base::seq.int
[13:23:05.644]             signalCondition <- base::signalCondition
[13:23:05.644]             sys.calls <- base::sys.calls
[13:23:05.644]             `[[` <- base::`[[`
[13:23:05.644]             `+` <- base::`+`
[13:23:05.644]             `<<-` <- base::`<<-`
[13:23:05.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.644]                   3L)]
[13:23:05.644]             }
[13:23:05.644]             function(cond) {
[13:23:05.644]                 is_error <- inherits(cond, "error")
[13:23:05.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.644]                   NULL)
[13:23:05.644]                 if (is_error) {
[13:23:05.644]                   sessionInformation <- function() {
[13:23:05.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.644]                       search = base::search(), system = base::Sys.info())
[13:23:05.644]                   }
[13:23:05.644]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.644]                     cond$call), session = sessionInformation(), 
[13:23:05.644]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.644]                   signalCondition(cond)
[13:23:05.644]                 }
[13:23:05.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.644]                 "immediateCondition"))) {
[13:23:05.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.644]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.644]                   if (TRUE && !signal) {
[13:23:05.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.644]                     {
[13:23:05.644]                       inherits <- base::inherits
[13:23:05.644]                       invokeRestart <- base::invokeRestart
[13:23:05.644]                       is.null <- base::is.null
[13:23:05.644]                       muffled <- FALSE
[13:23:05.644]                       if (inherits(cond, "message")) {
[13:23:05.644]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.644]                         if (muffled) 
[13:23:05.644]                           invokeRestart("muffleMessage")
[13:23:05.644]                       }
[13:23:05.644]                       else if (inherits(cond, "warning")) {
[13:23:05.644]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.644]                         if (muffled) 
[13:23:05.644]                           invokeRestart("muffleWarning")
[13:23:05.644]                       }
[13:23:05.644]                       else if (inherits(cond, "condition")) {
[13:23:05.644]                         if (!is.null(pattern)) {
[13:23:05.644]                           computeRestarts <- base::computeRestarts
[13:23:05.644]                           grepl <- base::grepl
[13:23:05.644]                           restarts <- computeRestarts(cond)
[13:23:05.644]                           for (restart in restarts) {
[13:23:05.644]                             name <- restart$name
[13:23:05.644]                             if (is.null(name)) 
[13:23:05.644]                               next
[13:23:05.644]                             if (!grepl(pattern, name)) 
[13:23:05.644]                               next
[13:23:05.644]                             invokeRestart(restart)
[13:23:05.644]                             muffled <- TRUE
[13:23:05.644]                             break
[13:23:05.644]                           }
[13:23:05.644]                         }
[13:23:05.644]                       }
[13:23:05.644]                       invisible(muffled)
[13:23:05.644]                     }
[13:23:05.644]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.644]                   }
[13:23:05.644]                 }
[13:23:05.644]                 else {
[13:23:05.644]                   if (TRUE) {
[13:23:05.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.644]                     {
[13:23:05.644]                       inherits <- base::inherits
[13:23:05.644]                       invokeRestart <- base::invokeRestart
[13:23:05.644]                       is.null <- base::is.null
[13:23:05.644]                       muffled <- FALSE
[13:23:05.644]                       if (inherits(cond, "message")) {
[13:23:05.644]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.644]                         if (muffled) 
[13:23:05.644]                           invokeRestart("muffleMessage")
[13:23:05.644]                       }
[13:23:05.644]                       else if (inherits(cond, "warning")) {
[13:23:05.644]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.644]                         if (muffled) 
[13:23:05.644]                           invokeRestart("muffleWarning")
[13:23:05.644]                       }
[13:23:05.644]                       else if (inherits(cond, "condition")) {
[13:23:05.644]                         if (!is.null(pattern)) {
[13:23:05.644]                           computeRestarts <- base::computeRestarts
[13:23:05.644]                           grepl <- base::grepl
[13:23:05.644]                           restarts <- computeRestarts(cond)
[13:23:05.644]                           for (restart in restarts) {
[13:23:05.644]                             name <- restart$name
[13:23:05.644]                             if (is.null(name)) 
[13:23:05.644]                               next
[13:23:05.644]                             if (!grepl(pattern, name)) 
[13:23:05.644]                               next
[13:23:05.644]                             invokeRestart(restart)
[13:23:05.644]                             muffled <- TRUE
[13:23:05.644]                             break
[13:23:05.644]                           }
[13:23:05.644]                         }
[13:23:05.644]                       }
[13:23:05.644]                       invisible(muffled)
[13:23:05.644]                     }
[13:23:05.644]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.644]                   }
[13:23:05.644]                 }
[13:23:05.644]             }
[13:23:05.644]         }))
[13:23:05.644]     }, error = function(ex) {
[13:23:05.644]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.644]                 ...future.rng), started = ...future.startTime, 
[13:23:05.644]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.644]             version = "1.8"), class = "FutureResult")
[13:23:05.644]     }, finally = {
[13:23:05.644]         if (!identical(...future.workdir, getwd())) 
[13:23:05.644]             setwd(...future.workdir)
[13:23:05.644]         {
[13:23:05.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.644]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.644]             }
[13:23:05.644]             base::options(...future.oldOptions)
[13:23:05.644]             if (.Platform$OS.type == "windows") {
[13:23:05.644]                 old_names <- names(...future.oldEnvVars)
[13:23:05.644]                 envs <- base::Sys.getenv()
[13:23:05.644]                 names <- names(envs)
[13:23:05.644]                 common <- intersect(names, old_names)
[13:23:05.644]                 added <- setdiff(names, old_names)
[13:23:05.644]                 removed <- setdiff(old_names, names)
[13:23:05.644]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.644]                   envs[common]]
[13:23:05.644]                 NAMES <- toupper(changed)
[13:23:05.644]                 args <- list()
[13:23:05.644]                 for (kk in seq_along(NAMES)) {
[13:23:05.644]                   name <- changed[[kk]]
[13:23:05.644]                   NAME <- NAMES[[kk]]
[13:23:05.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.644]                     next
[13:23:05.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.644]                 }
[13:23:05.644]                 NAMES <- toupper(added)
[13:23:05.644]                 for (kk in seq_along(NAMES)) {
[13:23:05.644]                   name <- added[[kk]]
[13:23:05.644]                   NAME <- NAMES[[kk]]
[13:23:05.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.644]                     next
[13:23:05.644]                   args[[name]] <- ""
[13:23:05.644]                 }
[13:23:05.644]                 NAMES <- toupper(removed)
[13:23:05.644]                 for (kk in seq_along(NAMES)) {
[13:23:05.644]                   name <- removed[[kk]]
[13:23:05.644]                   NAME <- NAMES[[kk]]
[13:23:05.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.644]                     next
[13:23:05.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.644]                 }
[13:23:05.644]                 if (length(args) > 0) 
[13:23:05.644]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.644]             }
[13:23:05.644]             else {
[13:23:05.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.644]             }
[13:23:05.644]             {
[13:23:05.644]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.644]                   0L) {
[13:23:05.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.644]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.644]                   base::options(opts)
[13:23:05.644]                 }
[13:23:05.644]                 {
[13:23:05.644]                   {
[13:23:05.644]                     NULL
[13:23:05.644]                     RNGkind("Mersenne-Twister")
[13:23:05.644]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.644]                       inherits = FALSE)
[13:23:05.644]                   }
[13:23:05.644]                   options(future.plan = NULL)
[13:23:05.644]                   if (is.na(NA_character_)) 
[13:23:05.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.644]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.644]                   {
[13:23:05.644]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.644]                     if (!future$lazy) 
[13:23:05.644]                       future <- run(future)
[13:23:05.644]                     invisible(future)
[13:23:05.644]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.644]                 }
[13:23:05.644]             }
[13:23:05.644]         }
[13:23:05.644]     })
[13:23:05.644]     if (TRUE) {
[13:23:05.644]         base::sink(type = "output", split = FALSE)
[13:23:05.644]         if (TRUE) {
[13:23:05.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.644]         }
[13:23:05.644]         else {
[13:23:05.644]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.644]         }
[13:23:05.644]         base::close(...future.stdout)
[13:23:05.644]         ...future.stdout <- NULL
[13:23:05.644]     }
[13:23:05.644]     ...future.result$conditions <- ...future.conditions
[13:23:05.644]     ...future.result$finished <- base::Sys.time()
[13:23:05.644]     ...future.result
[13:23:05.644] }
[13:23:05.646] plan(): Setting new future strategy stack:
[13:23:05.646] List of future strategies:
[13:23:05.646] 1. sequential:
[13:23:05.646]    - args: function (..., envir = parent.frame())
[13:23:05.646]    - tweaked: FALSE
[13:23:05.646]    - call: NULL
[13:23:05.646] plan(): nbrOfWorkers() = 1
[13:23:05.647] plan(): Setting new future strategy stack:
[13:23:05.647] List of future strategies:
[13:23:05.647] 1. sequential:
[13:23:05.647]    - args: function (..., envir = parent.frame())
[13:23:05.647]    - tweaked: FALSE
[13:23:05.647]    - call: plan(strategy)
[13:23:05.647] plan(): nbrOfWorkers() = 1
[13:23:05.647] SequentialFuture started (and completed)
[13:23:05.648] - Launch lazy future ... done
[13:23:05.648] run() for ‘SequentialFuture’ ... done
[13:23:05.648] getGlobalsAndPackages() ...
[13:23:05.648] Searching for globals...
[13:23:05.649] - globals found: [1] ‘{’
[13:23:05.649] Searching for globals ... DONE
[13:23:05.649] Resolving globals: FALSE
[13:23:05.649] 
[13:23:05.649] 
[13:23:05.650] getGlobalsAndPackages() ... DONE
[13:23:05.650] run() for ‘Future’ ...
[13:23:05.650] - state: ‘created’
[13:23:05.650] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.650] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.650] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.651]   - Field: ‘label’
[13:23:05.651]   - Field: ‘local’
[13:23:05.651]   - Field: ‘owner’
[13:23:05.651]   - Field: ‘envir’
[13:23:05.651]   - Field: ‘packages’
[13:23:05.651]   - Field: ‘gc’
[13:23:05.651]   - Field: ‘conditions’
[13:23:05.651]   - Field: ‘expr’
[13:23:05.651]   - Field: ‘uuid’
[13:23:05.651]   - Field: ‘seed’
[13:23:05.652]   - Field: ‘version’
[13:23:05.652]   - Field: ‘result’
[13:23:05.652]   - Field: ‘asynchronous’
[13:23:05.652]   - Field: ‘calls’
[13:23:05.652]   - Field: ‘globals’
[13:23:05.652]   - Field: ‘stdout’
[13:23:05.652]   - Field: ‘earlySignal’
[13:23:05.652]   - Field: ‘lazy’
[13:23:05.652]   - Field: ‘state’
[13:23:05.652] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.653] - Launch lazy future ...
[13:23:05.653] Packages needed by the future expression (n = 0): <none>
[13:23:05.653] Packages needed by future strategies (n = 0): <none>
[13:23:05.653] {
[13:23:05.653]     {
[13:23:05.653]         {
[13:23:05.653]             ...future.startTime <- base::Sys.time()
[13:23:05.653]             {
[13:23:05.653]                 {
[13:23:05.653]                   {
[13:23:05.653]                     base::local({
[13:23:05.653]                       has_future <- base::requireNamespace("future", 
[13:23:05.653]                         quietly = TRUE)
[13:23:05.653]                       if (has_future) {
[13:23:05.653]                         ns <- base::getNamespace("future")
[13:23:05.653]                         version <- ns[[".package"]][["version"]]
[13:23:05.653]                         if (is.null(version)) 
[13:23:05.653]                           version <- utils::packageVersion("future")
[13:23:05.653]                       }
[13:23:05.653]                       else {
[13:23:05.653]                         version <- NULL
[13:23:05.653]                       }
[13:23:05.653]                       if (!has_future || version < "1.8.0") {
[13:23:05.653]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.653]                           "", base::R.version$version.string), 
[13:23:05.653]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.653]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.653]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.653]                             "release", "version")], collapse = " "), 
[13:23:05.653]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.653]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.653]                           info)
[13:23:05.653]                         info <- base::paste(info, collapse = "; ")
[13:23:05.653]                         if (!has_future) {
[13:23:05.653]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.653]                             info)
[13:23:05.653]                         }
[13:23:05.653]                         else {
[13:23:05.653]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.653]                             info, version)
[13:23:05.653]                         }
[13:23:05.653]                         base::stop(msg)
[13:23:05.653]                       }
[13:23:05.653]                     })
[13:23:05.653]                   }
[13:23:05.653]                   options(future.plan = NULL)
[13:23:05.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.653]                 }
[13:23:05.653]                 ...future.workdir <- getwd()
[13:23:05.653]             }
[13:23:05.653]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.653]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.653]         }
[13:23:05.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.653]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.653]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.653]             base::names(...future.oldOptions))
[13:23:05.653]     }
[13:23:05.653]     if (FALSE) {
[13:23:05.653]     }
[13:23:05.653]     else {
[13:23:05.653]         if (TRUE) {
[13:23:05.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.653]                 open = "w")
[13:23:05.653]         }
[13:23:05.653]         else {
[13:23:05.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.653]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.653]         }
[13:23:05.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.653]             base::sink(type = "output", split = FALSE)
[13:23:05.653]             base::close(...future.stdout)
[13:23:05.653]         }, add = TRUE)
[13:23:05.653]     }
[13:23:05.653]     ...future.frame <- base::sys.nframe()
[13:23:05.653]     ...future.conditions <- base::list()
[13:23:05.653]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.653]     if (FALSE) {
[13:23:05.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.653]     }
[13:23:05.653]     ...future.result <- base::tryCatch({
[13:23:05.653]         base::withCallingHandlers({
[13:23:05.653]             ...future.value <- base::withVisible(base::local({
[13:23:05.653]                 4
[13:23:05.653]             }))
[13:23:05.653]             future::FutureResult(value = ...future.value$value, 
[13:23:05.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.653]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.653]                     ...future.globalenv.names))
[13:23:05.653]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.653]         }, condition = base::local({
[13:23:05.653]             c <- base::c
[13:23:05.653]             inherits <- base::inherits
[13:23:05.653]             invokeRestart <- base::invokeRestart
[13:23:05.653]             length <- base::length
[13:23:05.653]             list <- base::list
[13:23:05.653]             seq.int <- base::seq.int
[13:23:05.653]             signalCondition <- base::signalCondition
[13:23:05.653]             sys.calls <- base::sys.calls
[13:23:05.653]             `[[` <- base::`[[`
[13:23:05.653]             `+` <- base::`+`
[13:23:05.653]             `<<-` <- base::`<<-`
[13:23:05.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.653]                   3L)]
[13:23:05.653]             }
[13:23:05.653]             function(cond) {
[13:23:05.653]                 is_error <- inherits(cond, "error")
[13:23:05.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.653]                   NULL)
[13:23:05.653]                 if (is_error) {
[13:23:05.653]                   sessionInformation <- function() {
[13:23:05.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.653]                       search = base::search(), system = base::Sys.info())
[13:23:05.653]                   }
[13:23:05.653]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.653]                     cond$call), session = sessionInformation(), 
[13:23:05.653]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.653]                   signalCondition(cond)
[13:23:05.653]                 }
[13:23:05.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.653]                 "immediateCondition"))) {
[13:23:05.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.653]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.653]                   if (TRUE && !signal) {
[13:23:05.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.653]                     {
[13:23:05.653]                       inherits <- base::inherits
[13:23:05.653]                       invokeRestart <- base::invokeRestart
[13:23:05.653]                       is.null <- base::is.null
[13:23:05.653]                       muffled <- FALSE
[13:23:05.653]                       if (inherits(cond, "message")) {
[13:23:05.653]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.653]                         if (muffled) 
[13:23:05.653]                           invokeRestart("muffleMessage")
[13:23:05.653]                       }
[13:23:05.653]                       else if (inherits(cond, "warning")) {
[13:23:05.653]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.653]                         if (muffled) 
[13:23:05.653]                           invokeRestart("muffleWarning")
[13:23:05.653]                       }
[13:23:05.653]                       else if (inherits(cond, "condition")) {
[13:23:05.653]                         if (!is.null(pattern)) {
[13:23:05.653]                           computeRestarts <- base::computeRestarts
[13:23:05.653]                           grepl <- base::grepl
[13:23:05.653]                           restarts <- computeRestarts(cond)
[13:23:05.653]                           for (restart in restarts) {
[13:23:05.653]                             name <- restart$name
[13:23:05.653]                             if (is.null(name)) 
[13:23:05.653]                               next
[13:23:05.653]                             if (!grepl(pattern, name)) 
[13:23:05.653]                               next
[13:23:05.653]                             invokeRestart(restart)
[13:23:05.653]                             muffled <- TRUE
[13:23:05.653]                             break
[13:23:05.653]                           }
[13:23:05.653]                         }
[13:23:05.653]                       }
[13:23:05.653]                       invisible(muffled)
[13:23:05.653]                     }
[13:23:05.653]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.653]                   }
[13:23:05.653]                 }
[13:23:05.653]                 else {
[13:23:05.653]                   if (TRUE) {
[13:23:05.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.653]                     {
[13:23:05.653]                       inherits <- base::inherits
[13:23:05.653]                       invokeRestart <- base::invokeRestart
[13:23:05.653]                       is.null <- base::is.null
[13:23:05.653]                       muffled <- FALSE
[13:23:05.653]                       if (inherits(cond, "message")) {
[13:23:05.653]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.653]                         if (muffled) 
[13:23:05.653]                           invokeRestart("muffleMessage")
[13:23:05.653]                       }
[13:23:05.653]                       else if (inherits(cond, "warning")) {
[13:23:05.653]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.653]                         if (muffled) 
[13:23:05.653]                           invokeRestart("muffleWarning")
[13:23:05.653]                       }
[13:23:05.653]                       else if (inherits(cond, "condition")) {
[13:23:05.653]                         if (!is.null(pattern)) {
[13:23:05.653]                           computeRestarts <- base::computeRestarts
[13:23:05.653]                           grepl <- base::grepl
[13:23:05.653]                           restarts <- computeRestarts(cond)
[13:23:05.653]                           for (restart in restarts) {
[13:23:05.653]                             name <- restart$name
[13:23:05.653]                             if (is.null(name)) 
[13:23:05.653]                               next
[13:23:05.653]                             if (!grepl(pattern, name)) 
[13:23:05.653]                               next
[13:23:05.653]                             invokeRestart(restart)
[13:23:05.653]                             muffled <- TRUE
[13:23:05.653]                             break
[13:23:05.653]                           }
[13:23:05.653]                         }
[13:23:05.653]                       }
[13:23:05.653]                       invisible(muffled)
[13:23:05.653]                     }
[13:23:05.653]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.653]                   }
[13:23:05.653]                 }
[13:23:05.653]             }
[13:23:05.653]         }))
[13:23:05.653]     }, error = function(ex) {
[13:23:05.653]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.653]                 ...future.rng), started = ...future.startTime, 
[13:23:05.653]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.653]             version = "1.8"), class = "FutureResult")
[13:23:05.653]     }, finally = {
[13:23:05.653]         if (!identical(...future.workdir, getwd())) 
[13:23:05.653]             setwd(...future.workdir)
[13:23:05.653]         {
[13:23:05.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.653]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.653]             }
[13:23:05.653]             base::options(...future.oldOptions)
[13:23:05.653]             if (.Platform$OS.type == "windows") {
[13:23:05.653]                 old_names <- names(...future.oldEnvVars)
[13:23:05.653]                 envs <- base::Sys.getenv()
[13:23:05.653]                 names <- names(envs)
[13:23:05.653]                 common <- intersect(names, old_names)
[13:23:05.653]                 added <- setdiff(names, old_names)
[13:23:05.653]                 removed <- setdiff(old_names, names)
[13:23:05.653]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.653]                   envs[common]]
[13:23:05.653]                 NAMES <- toupper(changed)
[13:23:05.653]                 args <- list()
[13:23:05.653]                 for (kk in seq_along(NAMES)) {
[13:23:05.653]                   name <- changed[[kk]]
[13:23:05.653]                   NAME <- NAMES[[kk]]
[13:23:05.653]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.653]                     next
[13:23:05.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.653]                 }
[13:23:05.653]                 NAMES <- toupper(added)
[13:23:05.653]                 for (kk in seq_along(NAMES)) {
[13:23:05.653]                   name <- added[[kk]]
[13:23:05.653]                   NAME <- NAMES[[kk]]
[13:23:05.653]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.653]                     next
[13:23:05.653]                   args[[name]] <- ""
[13:23:05.653]                 }
[13:23:05.653]                 NAMES <- toupper(removed)
[13:23:05.653]                 for (kk in seq_along(NAMES)) {
[13:23:05.653]                   name <- removed[[kk]]
[13:23:05.653]                   NAME <- NAMES[[kk]]
[13:23:05.653]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.653]                     next
[13:23:05.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.653]                 }
[13:23:05.653]                 if (length(args) > 0) 
[13:23:05.653]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.653]             }
[13:23:05.653]             else {
[13:23:05.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.653]             }
[13:23:05.653]             {
[13:23:05.653]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.653]                   0L) {
[13:23:05.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.653]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.653]                   base::options(opts)
[13:23:05.653]                 }
[13:23:05.653]                 {
[13:23:05.653]                   {
[13:23:05.653]                     NULL
[13:23:05.653]                     RNGkind("Mersenne-Twister")
[13:23:05.653]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.653]                       inherits = FALSE)
[13:23:05.653]                   }
[13:23:05.653]                   options(future.plan = NULL)
[13:23:05.653]                   if (is.na(NA_character_)) 
[13:23:05.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.653]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.653]                   {
[13:23:05.653]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.653]                     if (!future$lazy) 
[13:23:05.653]                       future <- run(future)
[13:23:05.653]                     invisible(future)
[13:23:05.653]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.653]                 }
[13:23:05.653]             }
[13:23:05.653]         }
[13:23:05.653]     })
[13:23:05.653]     if (TRUE) {
[13:23:05.653]         base::sink(type = "output", split = FALSE)
[13:23:05.653]         if (TRUE) {
[13:23:05.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.653]         }
[13:23:05.653]         else {
[13:23:05.653]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.653]         }
[13:23:05.653]         base::close(...future.stdout)
[13:23:05.653]         ...future.stdout <- NULL
[13:23:05.653]     }
[13:23:05.653]     ...future.result$conditions <- ...future.conditions
[13:23:05.653]     ...future.result$finished <- base::Sys.time()
[13:23:05.653]     ...future.result
[13:23:05.653] }
[13:23:05.655] plan(): Setting new future strategy stack:
[13:23:05.656] List of future strategies:
[13:23:05.656] 1. sequential:
[13:23:05.656]    - args: function (..., envir = parent.frame())
[13:23:05.656]    - tweaked: FALSE
[13:23:05.656]    - call: NULL
[13:23:05.656] plan(): nbrOfWorkers() = 1
[13:23:05.657] plan(): Setting new future strategy stack:
[13:23:05.657] List of future strategies:
[13:23:05.657] 1. sequential:
[13:23:05.657]    - args: function (..., envir = parent.frame())
[13:23:05.657]    - tweaked: FALSE
[13:23:05.657]    - call: plan(strategy)
[13:23:05.657] plan(): nbrOfWorkers() = 1
[13:23:05.657] SequentialFuture started (and completed)
[13:23:05.658] - Launch lazy future ... done
[13:23:05.658] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d5cfcce8> 
Classes 'listenv', 'environment' <environment: 0x5596d5a7b2f8> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:23:05.664] resolved() for ‘SequentialFuture’ ...
[13:23:05.664] - state: ‘finished’
[13:23:05.664] - run: TRUE
[13:23:05.664] - result: ‘FutureResult’
[13:23:05.664] resolved() for ‘SequentialFuture’ ... done
[13:23:05.664] resolved() for ‘SequentialFuture’ ...
[13:23:05.665] - state: ‘finished’
[13:23:05.665] - run: TRUE
[13:23:05.665] - result: ‘FutureResult’
[13:23:05.665] resolved() for ‘SequentialFuture’ ... done
[13:23:05.665] resolved() for ‘SequentialFuture’ ...
[13:23:05.665] - state: ‘finished’
[13:23:05.665] - run: TRUE
[13:23:05.665] - result: ‘FutureResult’
[13:23:05.665] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:05.669] resolve() on list environment ...
[13:23:05.669]  recursive: 0
[13:23:05.670]  length: 6
[13:23:05.670]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:05.670] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.670] - nx: 6
[13:23:05.670] - relay: TRUE
[13:23:05.670] - stdout: TRUE
[13:23:05.670] - signal: TRUE
[13:23:05.670] - resignal: FALSE
[13:23:05.670] - force: TRUE
[13:23:05.671] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.671] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.671]  - until=2
[13:23:05.671]  - relaying element #2
[13:23:05.671] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.671] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.671] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.671]  length: 5 (resolved future 1)
[13:23:05.671] resolved() for ‘SequentialFuture’ ...
[13:23:05.672] - state: ‘finished’
[13:23:05.672] - run: TRUE
[13:23:05.672] - result: ‘FutureResult’
[13:23:05.672] resolved() for ‘SequentialFuture’ ... done
[13:23:05.672] Future #2
[13:23:05.672] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.672] - nx: 6
[13:23:05.672] - relay: TRUE
[13:23:05.672] - stdout: TRUE
[13:23:05.672] - signal: TRUE
[13:23:05.673] - resignal: FALSE
[13:23:05.673] - force: TRUE
[13:23:05.673] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.673] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.673]  - until=2
[13:23:05.673]  - relaying element #2
[13:23:05.673] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.673] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.673] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.674]  length: 4 (resolved future 2)
[13:23:05.674] resolved() for ‘SequentialFuture’ ...
[13:23:05.674] - state: ‘finished’
[13:23:05.674] - run: TRUE
[13:23:05.674] - result: ‘FutureResult’
[13:23:05.674] resolved() for ‘SequentialFuture’ ... done
[13:23:05.674] Future #3
[13:23:05.674] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.674] - nx: 6
[13:23:05.675] - relay: TRUE
[13:23:05.675] - stdout: TRUE
[13:23:05.675] - signal: TRUE
[13:23:05.675] - resignal: FALSE
[13:23:05.675] - force: TRUE
[13:23:05.675] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.675] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.675]  - until=3
[13:23:05.675]  - relaying element #3
[13:23:05.675] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.676] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.676] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.676]  length: 3 (resolved future 3)
[13:23:05.676] resolved() for ‘SequentialFuture’ ...
[13:23:05.676] - state: ‘finished’
[13:23:05.676] - run: TRUE
[13:23:05.676] - result: ‘FutureResult’
[13:23:05.676] resolved() for ‘SequentialFuture’ ... done
[13:23:05.676] Future #4
[13:23:05.677] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.677] - nx: 6
[13:23:05.677] - relay: TRUE
[13:23:05.677] - stdout: TRUE
[13:23:05.677] - signal: TRUE
[13:23:05.677] - resignal: FALSE
[13:23:05.677] - force: TRUE
[13:23:05.677] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.677] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.677]  - until=4
[13:23:05.677]  - relaying element #4
[13:23:05.678] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.678] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.678] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.678]  length: 2 (resolved future 4)
[13:23:05.678] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.678] - nx: 6
[13:23:05.678] - relay: TRUE
[13:23:05.678] - stdout: TRUE
[13:23:05.678] - signal: TRUE
[13:23:05.678] - resignal: FALSE
[13:23:05.679] - force: TRUE
[13:23:05.679] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.679] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.679]  - until=6
[13:23:05.679]  - relaying element #6
[13:23:05.679] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.679] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.679] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.679]  length: 1 (resolved future 5)
[13:23:05.679] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.680] - nx: 6
[13:23:05.680] - relay: TRUE
[13:23:05.680] - stdout: TRUE
[13:23:05.680] - signal: TRUE
[13:23:05.680] - resignal: FALSE
[13:23:05.680] - force: TRUE
[13:23:05.680] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.680] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.680]  - until=6
[13:23:05.680] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.680] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.681] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.681]  length: 0 (resolved future 6)
[13:23:05.681] Relaying remaining futures
[13:23:05.681] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.681] - nx: 6
[13:23:05.681] - relay: TRUE
[13:23:05.681] - stdout: TRUE
[13:23:05.681] - signal: TRUE
[13:23:05.681] - resignal: FALSE
[13:23:05.681] - force: TRUE
[13:23:05.681] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.681] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:05.682] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.682] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.682] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.682] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5596d3f1deb0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:23:05.684] getGlobalsAndPackages() ...
[13:23:05.685] Searching for globals...
[13:23:05.685] 
[13:23:05.685] Searching for globals ... DONE
[13:23:05.685] - globals: [0] <none>
[13:23:05.685] getGlobalsAndPackages() ... DONE
[13:23:05.685] run() for ‘Future’ ...
[13:23:05.686] - state: ‘created’
[13:23:05.686] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.686] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.686] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.686]   - Field: ‘label’
[13:23:05.686]   - Field: ‘local’
[13:23:05.686]   - Field: ‘owner’
[13:23:05.687]   - Field: ‘envir’
[13:23:05.687]   - Field: ‘packages’
[13:23:05.687]   - Field: ‘gc’
[13:23:05.687]   - Field: ‘conditions’
[13:23:05.687]   - Field: ‘expr’
[13:23:05.687]   - Field: ‘uuid’
[13:23:05.687]   - Field: ‘seed’
[13:23:05.687]   - Field: ‘version’
[13:23:05.687]   - Field: ‘result’
[13:23:05.687]   - Field: ‘asynchronous’
[13:23:05.688]   - Field: ‘calls’
[13:23:05.688]   - Field: ‘globals’
[13:23:05.688]   - Field: ‘stdout’
[13:23:05.688]   - Field: ‘earlySignal’
[13:23:05.688]   - Field: ‘lazy’
[13:23:05.688]   - Field: ‘state’
[13:23:05.688] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.688] - Launch lazy future ...
[13:23:05.688] Packages needed by the future expression (n = 0): <none>
[13:23:05.689] Packages needed by future strategies (n = 0): <none>
[13:23:05.689] {
[13:23:05.689]     {
[13:23:05.689]         {
[13:23:05.689]             ...future.startTime <- base::Sys.time()
[13:23:05.689]             {
[13:23:05.689]                 {
[13:23:05.689]                   {
[13:23:05.689]                     base::local({
[13:23:05.689]                       has_future <- base::requireNamespace("future", 
[13:23:05.689]                         quietly = TRUE)
[13:23:05.689]                       if (has_future) {
[13:23:05.689]                         ns <- base::getNamespace("future")
[13:23:05.689]                         version <- ns[[".package"]][["version"]]
[13:23:05.689]                         if (is.null(version)) 
[13:23:05.689]                           version <- utils::packageVersion("future")
[13:23:05.689]                       }
[13:23:05.689]                       else {
[13:23:05.689]                         version <- NULL
[13:23:05.689]                       }
[13:23:05.689]                       if (!has_future || version < "1.8.0") {
[13:23:05.689]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.689]                           "", base::R.version$version.string), 
[13:23:05.689]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.689]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.689]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.689]                             "release", "version")], collapse = " "), 
[13:23:05.689]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.689]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.689]                           info)
[13:23:05.689]                         info <- base::paste(info, collapse = "; ")
[13:23:05.689]                         if (!has_future) {
[13:23:05.689]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.689]                             info)
[13:23:05.689]                         }
[13:23:05.689]                         else {
[13:23:05.689]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.689]                             info, version)
[13:23:05.689]                         }
[13:23:05.689]                         base::stop(msg)
[13:23:05.689]                       }
[13:23:05.689]                     })
[13:23:05.689]                   }
[13:23:05.689]                   options(future.plan = NULL)
[13:23:05.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.689]                 }
[13:23:05.689]                 ...future.workdir <- getwd()
[13:23:05.689]             }
[13:23:05.689]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.689]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.689]         }
[13:23:05.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.689]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.689]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.689]             base::names(...future.oldOptions))
[13:23:05.689]     }
[13:23:05.689]     if (FALSE) {
[13:23:05.689]     }
[13:23:05.689]     else {
[13:23:05.689]         if (TRUE) {
[13:23:05.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.689]                 open = "w")
[13:23:05.689]         }
[13:23:05.689]         else {
[13:23:05.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.689]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.689]         }
[13:23:05.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.689]             base::sink(type = "output", split = FALSE)
[13:23:05.689]             base::close(...future.stdout)
[13:23:05.689]         }, add = TRUE)
[13:23:05.689]     }
[13:23:05.689]     ...future.frame <- base::sys.nframe()
[13:23:05.689]     ...future.conditions <- base::list()
[13:23:05.689]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.689]     if (FALSE) {
[13:23:05.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.689]     }
[13:23:05.689]     ...future.result <- base::tryCatch({
[13:23:05.689]         base::withCallingHandlers({
[13:23:05.689]             ...future.value <- base::withVisible(base::local(2))
[13:23:05.689]             future::FutureResult(value = ...future.value$value, 
[13:23:05.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.689]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.689]                     ...future.globalenv.names))
[13:23:05.689]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.689]         }, condition = base::local({
[13:23:05.689]             c <- base::c
[13:23:05.689]             inherits <- base::inherits
[13:23:05.689]             invokeRestart <- base::invokeRestart
[13:23:05.689]             length <- base::length
[13:23:05.689]             list <- base::list
[13:23:05.689]             seq.int <- base::seq.int
[13:23:05.689]             signalCondition <- base::signalCondition
[13:23:05.689]             sys.calls <- base::sys.calls
[13:23:05.689]             `[[` <- base::`[[`
[13:23:05.689]             `+` <- base::`+`
[13:23:05.689]             `<<-` <- base::`<<-`
[13:23:05.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.689]                   3L)]
[13:23:05.689]             }
[13:23:05.689]             function(cond) {
[13:23:05.689]                 is_error <- inherits(cond, "error")
[13:23:05.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.689]                   NULL)
[13:23:05.689]                 if (is_error) {
[13:23:05.689]                   sessionInformation <- function() {
[13:23:05.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.689]                       search = base::search(), system = base::Sys.info())
[13:23:05.689]                   }
[13:23:05.689]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.689]                     cond$call), session = sessionInformation(), 
[13:23:05.689]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.689]                   signalCondition(cond)
[13:23:05.689]                 }
[13:23:05.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.689]                 "immediateCondition"))) {
[13:23:05.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.689]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.689]                   if (TRUE && !signal) {
[13:23:05.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.689]                     {
[13:23:05.689]                       inherits <- base::inherits
[13:23:05.689]                       invokeRestart <- base::invokeRestart
[13:23:05.689]                       is.null <- base::is.null
[13:23:05.689]                       muffled <- FALSE
[13:23:05.689]                       if (inherits(cond, "message")) {
[13:23:05.689]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.689]                         if (muffled) 
[13:23:05.689]                           invokeRestart("muffleMessage")
[13:23:05.689]                       }
[13:23:05.689]                       else if (inherits(cond, "warning")) {
[13:23:05.689]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.689]                         if (muffled) 
[13:23:05.689]                           invokeRestart("muffleWarning")
[13:23:05.689]                       }
[13:23:05.689]                       else if (inherits(cond, "condition")) {
[13:23:05.689]                         if (!is.null(pattern)) {
[13:23:05.689]                           computeRestarts <- base::computeRestarts
[13:23:05.689]                           grepl <- base::grepl
[13:23:05.689]                           restarts <- computeRestarts(cond)
[13:23:05.689]                           for (restart in restarts) {
[13:23:05.689]                             name <- restart$name
[13:23:05.689]                             if (is.null(name)) 
[13:23:05.689]                               next
[13:23:05.689]                             if (!grepl(pattern, name)) 
[13:23:05.689]                               next
[13:23:05.689]                             invokeRestart(restart)
[13:23:05.689]                             muffled <- TRUE
[13:23:05.689]                             break
[13:23:05.689]                           }
[13:23:05.689]                         }
[13:23:05.689]                       }
[13:23:05.689]                       invisible(muffled)
[13:23:05.689]                     }
[13:23:05.689]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.689]                   }
[13:23:05.689]                 }
[13:23:05.689]                 else {
[13:23:05.689]                   if (TRUE) {
[13:23:05.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.689]                     {
[13:23:05.689]                       inherits <- base::inherits
[13:23:05.689]                       invokeRestart <- base::invokeRestart
[13:23:05.689]                       is.null <- base::is.null
[13:23:05.689]                       muffled <- FALSE
[13:23:05.689]                       if (inherits(cond, "message")) {
[13:23:05.689]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.689]                         if (muffled) 
[13:23:05.689]                           invokeRestart("muffleMessage")
[13:23:05.689]                       }
[13:23:05.689]                       else if (inherits(cond, "warning")) {
[13:23:05.689]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.689]                         if (muffled) 
[13:23:05.689]                           invokeRestart("muffleWarning")
[13:23:05.689]                       }
[13:23:05.689]                       else if (inherits(cond, "condition")) {
[13:23:05.689]                         if (!is.null(pattern)) {
[13:23:05.689]                           computeRestarts <- base::computeRestarts
[13:23:05.689]                           grepl <- base::grepl
[13:23:05.689]                           restarts <- computeRestarts(cond)
[13:23:05.689]                           for (restart in restarts) {
[13:23:05.689]                             name <- restart$name
[13:23:05.689]                             if (is.null(name)) 
[13:23:05.689]                               next
[13:23:05.689]                             if (!grepl(pattern, name)) 
[13:23:05.689]                               next
[13:23:05.689]                             invokeRestart(restart)
[13:23:05.689]                             muffled <- TRUE
[13:23:05.689]                             break
[13:23:05.689]                           }
[13:23:05.689]                         }
[13:23:05.689]                       }
[13:23:05.689]                       invisible(muffled)
[13:23:05.689]                     }
[13:23:05.689]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.689]                   }
[13:23:05.689]                 }
[13:23:05.689]             }
[13:23:05.689]         }))
[13:23:05.689]     }, error = function(ex) {
[13:23:05.689]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.689]                 ...future.rng), started = ...future.startTime, 
[13:23:05.689]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.689]             version = "1.8"), class = "FutureResult")
[13:23:05.689]     }, finally = {
[13:23:05.689]         if (!identical(...future.workdir, getwd())) 
[13:23:05.689]             setwd(...future.workdir)
[13:23:05.689]         {
[13:23:05.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.689]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.689]             }
[13:23:05.689]             base::options(...future.oldOptions)
[13:23:05.689]             if (.Platform$OS.type == "windows") {
[13:23:05.689]                 old_names <- names(...future.oldEnvVars)
[13:23:05.689]                 envs <- base::Sys.getenv()
[13:23:05.689]                 names <- names(envs)
[13:23:05.689]                 common <- intersect(names, old_names)
[13:23:05.689]                 added <- setdiff(names, old_names)
[13:23:05.689]                 removed <- setdiff(old_names, names)
[13:23:05.689]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.689]                   envs[common]]
[13:23:05.689]                 NAMES <- toupper(changed)
[13:23:05.689]                 args <- list()
[13:23:05.689]                 for (kk in seq_along(NAMES)) {
[13:23:05.689]                   name <- changed[[kk]]
[13:23:05.689]                   NAME <- NAMES[[kk]]
[13:23:05.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.689]                     next
[13:23:05.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.689]                 }
[13:23:05.689]                 NAMES <- toupper(added)
[13:23:05.689]                 for (kk in seq_along(NAMES)) {
[13:23:05.689]                   name <- added[[kk]]
[13:23:05.689]                   NAME <- NAMES[[kk]]
[13:23:05.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.689]                     next
[13:23:05.689]                   args[[name]] <- ""
[13:23:05.689]                 }
[13:23:05.689]                 NAMES <- toupper(removed)
[13:23:05.689]                 for (kk in seq_along(NAMES)) {
[13:23:05.689]                   name <- removed[[kk]]
[13:23:05.689]                   NAME <- NAMES[[kk]]
[13:23:05.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.689]                     next
[13:23:05.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.689]                 }
[13:23:05.689]                 if (length(args) > 0) 
[13:23:05.689]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.689]             }
[13:23:05.689]             else {
[13:23:05.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.689]             }
[13:23:05.689]             {
[13:23:05.689]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.689]                   0L) {
[13:23:05.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.689]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.689]                   base::options(opts)
[13:23:05.689]                 }
[13:23:05.689]                 {
[13:23:05.689]                   {
[13:23:05.689]                     NULL
[13:23:05.689]                     RNGkind("Mersenne-Twister")
[13:23:05.689]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.689]                       inherits = FALSE)
[13:23:05.689]                   }
[13:23:05.689]                   options(future.plan = NULL)
[13:23:05.689]                   if (is.na(NA_character_)) 
[13:23:05.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.689]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.689]                   {
[13:23:05.689]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.689]                     if (!future$lazy) 
[13:23:05.689]                       future <- run(future)
[13:23:05.689]                     invisible(future)
[13:23:05.689]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.689]                 }
[13:23:05.689]             }
[13:23:05.689]         }
[13:23:05.689]     })
[13:23:05.689]     if (TRUE) {
[13:23:05.689]         base::sink(type = "output", split = FALSE)
[13:23:05.689]         if (TRUE) {
[13:23:05.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.689]         }
[13:23:05.689]         else {
[13:23:05.689]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.689]         }
[13:23:05.689]         base::close(...future.stdout)
[13:23:05.689]         ...future.stdout <- NULL
[13:23:05.689]     }
[13:23:05.689]     ...future.result$conditions <- ...future.conditions
[13:23:05.689]     ...future.result$finished <- base::Sys.time()
[13:23:05.689]     ...future.result
[13:23:05.689] }
[13:23:05.693] plan(): Setting new future strategy stack:
[13:23:05.693] List of future strategies:
[13:23:05.693] 1. sequential:
[13:23:05.693]    - args: function (..., envir = parent.frame())
[13:23:05.693]    - tweaked: FALSE
[13:23:05.693]    - call: NULL
[13:23:05.693] plan(): nbrOfWorkers() = 1
[13:23:05.694] plan(): Setting new future strategy stack:
[13:23:05.694] List of future strategies:
[13:23:05.694] 1. sequential:
[13:23:05.694]    - args: function (..., envir = parent.frame())
[13:23:05.694]    - tweaked: FALSE
[13:23:05.694]    - call: plan(strategy)
[13:23:05.695] plan(): nbrOfWorkers() = 1
[13:23:05.695] SequentialFuture started (and completed)
[13:23:05.695] - Launch lazy future ... done
[13:23:05.695] run() for ‘SequentialFuture’ ... done
[13:23:05.695] getGlobalsAndPackages() ...
[13:23:05.695] Searching for globals...
[13:23:05.696] 
[13:23:05.696] Searching for globals ... DONE
[13:23:05.696] - globals: [0] <none>
[13:23:05.696] getGlobalsAndPackages() ... DONE
[13:23:05.696] run() for ‘Future’ ...
[13:23:05.697] - state: ‘created’
[13:23:05.697] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.697] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.697] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.697]   - Field: ‘label’
[13:23:05.697]   - Field: ‘local’
[13:23:05.697]   - Field: ‘owner’
[13:23:05.697]   - Field: ‘envir’
[13:23:05.698]   - Field: ‘packages’
[13:23:05.698]   - Field: ‘gc’
[13:23:05.698]   - Field: ‘conditions’
[13:23:05.698]   - Field: ‘expr’
[13:23:05.698]   - Field: ‘uuid’
[13:23:05.698]   - Field: ‘seed’
[13:23:05.698]   - Field: ‘version’
[13:23:05.698]   - Field: ‘result’
[13:23:05.698]   - Field: ‘asynchronous’
[13:23:05.698]   - Field: ‘calls’
[13:23:05.699]   - Field: ‘globals’
[13:23:05.699]   - Field: ‘stdout’
[13:23:05.699]   - Field: ‘earlySignal’
[13:23:05.699]   - Field: ‘lazy’
[13:23:05.699]   - Field: ‘state’
[13:23:05.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.699] - Launch lazy future ...
[13:23:05.699] Packages needed by the future expression (n = 0): <none>
[13:23:05.699] Packages needed by future strategies (n = 0): <none>
[13:23:05.700] {
[13:23:05.700]     {
[13:23:05.700]         {
[13:23:05.700]             ...future.startTime <- base::Sys.time()
[13:23:05.700]             {
[13:23:05.700]                 {
[13:23:05.700]                   {
[13:23:05.700]                     base::local({
[13:23:05.700]                       has_future <- base::requireNamespace("future", 
[13:23:05.700]                         quietly = TRUE)
[13:23:05.700]                       if (has_future) {
[13:23:05.700]                         ns <- base::getNamespace("future")
[13:23:05.700]                         version <- ns[[".package"]][["version"]]
[13:23:05.700]                         if (is.null(version)) 
[13:23:05.700]                           version <- utils::packageVersion("future")
[13:23:05.700]                       }
[13:23:05.700]                       else {
[13:23:05.700]                         version <- NULL
[13:23:05.700]                       }
[13:23:05.700]                       if (!has_future || version < "1.8.0") {
[13:23:05.700]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.700]                           "", base::R.version$version.string), 
[13:23:05.700]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.700]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.700]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.700]                             "release", "version")], collapse = " "), 
[13:23:05.700]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.700]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.700]                           info)
[13:23:05.700]                         info <- base::paste(info, collapse = "; ")
[13:23:05.700]                         if (!has_future) {
[13:23:05.700]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.700]                             info)
[13:23:05.700]                         }
[13:23:05.700]                         else {
[13:23:05.700]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.700]                             info, version)
[13:23:05.700]                         }
[13:23:05.700]                         base::stop(msg)
[13:23:05.700]                       }
[13:23:05.700]                     })
[13:23:05.700]                   }
[13:23:05.700]                   options(future.plan = NULL)
[13:23:05.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.700]                 }
[13:23:05.700]                 ...future.workdir <- getwd()
[13:23:05.700]             }
[13:23:05.700]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.700]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.700]         }
[13:23:05.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.700]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.700]             base::names(...future.oldOptions))
[13:23:05.700]     }
[13:23:05.700]     if (FALSE) {
[13:23:05.700]     }
[13:23:05.700]     else {
[13:23:05.700]         if (TRUE) {
[13:23:05.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.700]                 open = "w")
[13:23:05.700]         }
[13:23:05.700]         else {
[13:23:05.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.700]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.700]         }
[13:23:05.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.700]             base::sink(type = "output", split = FALSE)
[13:23:05.700]             base::close(...future.stdout)
[13:23:05.700]         }, add = TRUE)
[13:23:05.700]     }
[13:23:05.700]     ...future.frame <- base::sys.nframe()
[13:23:05.700]     ...future.conditions <- base::list()
[13:23:05.700]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.700]     if (FALSE) {
[13:23:05.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.700]     }
[13:23:05.700]     ...future.result <- base::tryCatch({
[13:23:05.700]         base::withCallingHandlers({
[13:23:05.700]             ...future.value <- base::withVisible(base::local(NULL))
[13:23:05.700]             future::FutureResult(value = ...future.value$value, 
[13:23:05.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.700]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.700]                     ...future.globalenv.names))
[13:23:05.700]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.700]         }, condition = base::local({
[13:23:05.700]             c <- base::c
[13:23:05.700]             inherits <- base::inherits
[13:23:05.700]             invokeRestart <- base::invokeRestart
[13:23:05.700]             length <- base::length
[13:23:05.700]             list <- base::list
[13:23:05.700]             seq.int <- base::seq.int
[13:23:05.700]             signalCondition <- base::signalCondition
[13:23:05.700]             sys.calls <- base::sys.calls
[13:23:05.700]             `[[` <- base::`[[`
[13:23:05.700]             `+` <- base::`+`
[13:23:05.700]             `<<-` <- base::`<<-`
[13:23:05.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.700]                   3L)]
[13:23:05.700]             }
[13:23:05.700]             function(cond) {
[13:23:05.700]                 is_error <- inherits(cond, "error")
[13:23:05.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.700]                   NULL)
[13:23:05.700]                 if (is_error) {
[13:23:05.700]                   sessionInformation <- function() {
[13:23:05.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.700]                       search = base::search(), system = base::Sys.info())
[13:23:05.700]                   }
[13:23:05.700]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.700]                     cond$call), session = sessionInformation(), 
[13:23:05.700]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.700]                   signalCondition(cond)
[13:23:05.700]                 }
[13:23:05.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.700]                 "immediateCondition"))) {
[13:23:05.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.700]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.700]                   if (TRUE && !signal) {
[13:23:05.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.700]                     {
[13:23:05.700]                       inherits <- base::inherits
[13:23:05.700]                       invokeRestart <- base::invokeRestart
[13:23:05.700]                       is.null <- base::is.null
[13:23:05.700]                       muffled <- FALSE
[13:23:05.700]                       if (inherits(cond, "message")) {
[13:23:05.700]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.700]                         if (muffled) 
[13:23:05.700]                           invokeRestart("muffleMessage")
[13:23:05.700]                       }
[13:23:05.700]                       else if (inherits(cond, "warning")) {
[13:23:05.700]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.700]                         if (muffled) 
[13:23:05.700]                           invokeRestart("muffleWarning")
[13:23:05.700]                       }
[13:23:05.700]                       else if (inherits(cond, "condition")) {
[13:23:05.700]                         if (!is.null(pattern)) {
[13:23:05.700]                           computeRestarts <- base::computeRestarts
[13:23:05.700]                           grepl <- base::grepl
[13:23:05.700]                           restarts <- computeRestarts(cond)
[13:23:05.700]                           for (restart in restarts) {
[13:23:05.700]                             name <- restart$name
[13:23:05.700]                             if (is.null(name)) 
[13:23:05.700]                               next
[13:23:05.700]                             if (!grepl(pattern, name)) 
[13:23:05.700]                               next
[13:23:05.700]                             invokeRestart(restart)
[13:23:05.700]                             muffled <- TRUE
[13:23:05.700]                             break
[13:23:05.700]                           }
[13:23:05.700]                         }
[13:23:05.700]                       }
[13:23:05.700]                       invisible(muffled)
[13:23:05.700]                     }
[13:23:05.700]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.700]                   }
[13:23:05.700]                 }
[13:23:05.700]                 else {
[13:23:05.700]                   if (TRUE) {
[13:23:05.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.700]                     {
[13:23:05.700]                       inherits <- base::inherits
[13:23:05.700]                       invokeRestart <- base::invokeRestart
[13:23:05.700]                       is.null <- base::is.null
[13:23:05.700]                       muffled <- FALSE
[13:23:05.700]                       if (inherits(cond, "message")) {
[13:23:05.700]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.700]                         if (muffled) 
[13:23:05.700]                           invokeRestart("muffleMessage")
[13:23:05.700]                       }
[13:23:05.700]                       else if (inherits(cond, "warning")) {
[13:23:05.700]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.700]                         if (muffled) 
[13:23:05.700]                           invokeRestart("muffleWarning")
[13:23:05.700]                       }
[13:23:05.700]                       else if (inherits(cond, "condition")) {
[13:23:05.700]                         if (!is.null(pattern)) {
[13:23:05.700]                           computeRestarts <- base::computeRestarts
[13:23:05.700]                           grepl <- base::grepl
[13:23:05.700]                           restarts <- computeRestarts(cond)
[13:23:05.700]                           for (restart in restarts) {
[13:23:05.700]                             name <- restart$name
[13:23:05.700]                             if (is.null(name)) 
[13:23:05.700]                               next
[13:23:05.700]                             if (!grepl(pattern, name)) 
[13:23:05.700]                               next
[13:23:05.700]                             invokeRestart(restart)
[13:23:05.700]                             muffled <- TRUE
[13:23:05.700]                             break
[13:23:05.700]                           }
[13:23:05.700]                         }
[13:23:05.700]                       }
[13:23:05.700]                       invisible(muffled)
[13:23:05.700]                     }
[13:23:05.700]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.700]                   }
[13:23:05.700]                 }
[13:23:05.700]             }
[13:23:05.700]         }))
[13:23:05.700]     }, error = function(ex) {
[13:23:05.700]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.700]                 ...future.rng), started = ...future.startTime, 
[13:23:05.700]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.700]             version = "1.8"), class = "FutureResult")
[13:23:05.700]     }, finally = {
[13:23:05.700]         if (!identical(...future.workdir, getwd())) 
[13:23:05.700]             setwd(...future.workdir)
[13:23:05.700]         {
[13:23:05.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.700]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.700]             }
[13:23:05.700]             base::options(...future.oldOptions)
[13:23:05.700]             if (.Platform$OS.type == "windows") {
[13:23:05.700]                 old_names <- names(...future.oldEnvVars)
[13:23:05.700]                 envs <- base::Sys.getenv()
[13:23:05.700]                 names <- names(envs)
[13:23:05.700]                 common <- intersect(names, old_names)
[13:23:05.700]                 added <- setdiff(names, old_names)
[13:23:05.700]                 removed <- setdiff(old_names, names)
[13:23:05.700]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.700]                   envs[common]]
[13:23:05.700]                 NAMES <- toupper(changed)
[13:23:05.700]                 args <- list()
[13:23:05.700]                 for (kk in seq_along(NAMES)) {
[13:23:05.700]                   name <- changed[[kk]]
[13:23:05.700]                   NAME <- NAMES[[kk]]
[13:23:05.700]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.700]                     next
[13:23:05.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.700]                 }
[13:23:05.700]                 NAMES <- toupper(added)
[13:23:05.700]                 for (kk in seq_along(NAMES)) {
[13:23:05.700]                   name <- added[[kk]]
[13:23:05.700]                   NAME <- NAMES[[kk]]
[13:23:05.700]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.700]                     next
[13:23:05.700]                   args[[name]] <- ""
[13:23:05.700]                 }
[13:23:05.700]                 NAMES <- toupper(removed)
[13:23:05.700]                 for (kk in seq_along(NAMES)) {
[13:23:05.700]                   name <- removed[[kk]]
[13:23:05.700]                   NAME <- NAMES[[kk]]
[13:23:05.700]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.700]                     next
[13:23:05.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.700]                 }
[13:23:05.700]                 if (length(args) > 0) 
[13:23:05.700]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.700]             }
[13:23:05.700]             else {
[13:23:05.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.700]             }
[13:23:05.700]             {
[13:23:05.700]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.700]                   0L) {
[13:23:05.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.700]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.700]                   base::options(opts)
[13:23:05.700]                 }
[13:23:05.700]                 {
[13:23:05.700]                   {
[13:23:05.700]                     NULL
[13:23:05.700]                     RNGkind("Mersenne-Twister")
[13:23:05.700]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.700]                       inherits = FALSE)
[13:23:05.700]                   }
[13:23:05.700]                   options(future.plan = NULL)
[13:23:05.700]                   if (is.na(NA_character_)) 
[13:23:05.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.700]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.700]                   {
[13:23:05.700]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.700]                     if (!future$lazy) 
[13:23:05.700]                       future <- run(future)
[13:23:05.700]                     invisible(future)
[13:23:05.700]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.700]                 }
[13:23:05.700]             }
[13:23:05.700]         }
[13:23:05.700]     })
[13:23:05.700]     if (TRUE) {
[13:23:05.700]         base::sink(type = "output", split = FALSE)
[13:23:05.700]         if (TRUE) {
[13:23:05.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.700]         }
[13:23:05.700]         else {
[13:23:05.700]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.700]         }
[13:23:05.700]         base::close(...future.stdout)
[13:23:05.700]         ...future.stdout <- NULL
[13:23:05.700]     }
[13:23:05.700]     ...future.result$conditions <- ...future.conditions
[13:23:05.700]     ...future.result$finished <- base::Sys.time()
[13:23:05.700]     ...future.result
[13:23:05.700] }
[13:23:05.702] plan(): Setting new future strategy stack:
[13:23:05.702] List of future strategies:
[13:23:05.702] 1. sequential:
[13:23:05.702]    - args: function (..., envir = parent.frame())
[13:23:05.702]    - tweaked: FALSE
[13:23:05.702]    - call: NULL
[13:23:05.702] plan(): nbrOfWorkers() = 1
[13:23:05.703] plan(): Setting new future strategy stack:
[13:23:05.703] List of future strategies:
[13:23:05.703] 1. sequential:
[13:23:05.703]    - args: function (..., envir = parent.frame())
[13:23:05.703]    - tweaked: FALSE
[13:23:05.703]    - call: plan(strategy)
[13:23:05.704] plan(): nbrOfWorkers() = 1
[13:23:05.704] SequentialFuture started (and completed)
[13:23:05.704] - Launch lazy future ... done
[13:23:05.704] run() for ‘SequentialFuture’ ... done
[13:23:05.704] getGlobalsAndPackages() ...
[13:23:05.704] Searching for globals...
[13:23:05.705] - globals found: [1] ‘{’
[13:23:05.705] Searching for globals ... DONE
[13:23:05.705] Resolving globals: FALSE
[13:23:05.706] 
[13:23:05.706] 
[13:23:05.706] getGlobalsAndPackages() ... DONE
[13:23:05.706] run() for ‘Future’ ...
[13:23:05.706] - state: ‘created’
[13:23:05.706] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:05.707] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:05.707] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:05.707]   - Field: ‘label’
[13:23:05.707]   - Field: ‘local’
[13:23:05.707]   - Field: ‘owner’
[13:23:05.707]   - Field: ‘envir’
[13:23:05.707]   - Field: ‘packages’
[13:23:05.707]   - Field: ‘gc’
[13:23:05.707]   - Field: ‘conditions’
[13:23:05.707]   - Field: ‘expr’
[13:23:05.708]   - Field: ‘uuid’
[13:23:05.708]   - Field: ‘seed’
[13:23:05.708]   - Field: ‘version’
[13:23:05.708]   - Field: ‘result’
[13:23:05.708]   - Field: ‘asynchronous’
[13:23:05.708]   - Field: ‘calls’
[13:23:05.708]   - Field: ‘globals’
[13:23:05.708]   - Field: ‘stdout’
[13:23:05.708]   - Field: ‘earlySignal’
[13:23:05.708]   - Field: ‘lazy’
[13:23:05.709]   - Field: ‘state’
[13:23:05.709] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:05.709] - Launch lazy future ...
[13:23:05.709] Packages needed by the future expression (n = 0): <none>
[13:23:05.709] Packages needed by future strategies (n = 0): <none>
[13:23:05.709] {
[13:23:05.709]     {
[13:23:05.709]         {
[13:23:05.709]             ...future.startTime <- base::Sys.time()
[13:23:05.709]             {
[13:23:05.709]                 {
[13:23:05.709]                   {
[13:23:05.709]                     base::local({
[13:23:05.709]                       has_future <- base::requireNamespace("future", 
[13:23:05.709]                         quietly = TRUE)
[13:23:05.709]                       if (has_future) {
[13:23:05.709]                         ns <- base::getNamespace("future")
[13:23:05.709]                         version <- ns[[".package"]][["version"]]
[13:23:05.709]                         if (is.null(version)) 
[13:23:05.709]                           version <- utils::packageVersion("future")
[13:23:05.709]                       }
[13:23:05.709]                       else {
[13:23:05.709]                         version <- NULL
[13:23:05.709]                       }
[13:23:05.709]                       if (!has_future || version < "1.8.0") {
[13:23:05.709]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.709]                           "", base::R.version$version.string), 
[13:23:05.709]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:05.709]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.709]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.709]                             "release", "version")], collapse = " "), 
[13:23:05.709]                           hostname = base::Sys.info()[["nodename"]])
[13:23:05.709]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.709]                           info)
[13:23:05.709]                         info <- base::paste(info, collapse = "; ")
[13:23:05.709]                         if (!has_future) {
[13:23:05.709]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.709]                             info)
[13:23:05.709]                         }
[13:23:05.709]                         else {
[13:23:05.709]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.709]                             info, version)
[13:23:05.709]                         }
[13:23:05.709]                         base::stop(msg)
[13:23:05.709]                       }
[13:23:05.709]                     })
[13:23:05.709]                   }
[13:23:05.709]                   options(future.plan = NULL)
[13:23:05.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.709]                 }
[13:23:05.709]                 ...future.workdir <- getwd()
[13:23:05.709]             }
[13:23:05.709]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.709]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.709]         }
[13:23:05.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.709]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.709]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.709]             base::names(...future.oldOptions))
[13:23:05.709]     }
[13:23:05.709]     if (FALSE) {
[13:23:05.709]     }
[13:23:05.709]     else {
[13:23:05.709]         if (TRUE) {
[13:23:05.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.709]                 open = "w")
[13:23:05.709]         }
[13:23:05.709]         else {
[13:23:05.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.709]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.709]         }
[13:23:05.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.709]             base::sink(type = "output", split = FALSE)
[13:23:05.709]             base::close(...future.stdout)
[13:23:05.709]         }, add = TRUE)
[13:23:05.709]     }
[13:23:05.709]     ...future.frame <- base::sys.nframe()
[13:23:05.709]     ...future.conditions <- base::list()
[13:23:05.709]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.709]     if (FALSE) {
[13:23:05.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.709]     }
[13:23:05.709]     ...future.result <- base::tryCatch({
[13:23:05.709]         base::withCallingHandlers({
[13:23:05.709]             ...future.value <- base::withVisible(base::local({
[13:23:05.709]                 4
[13:23:05.709]             }))
[13:23:05.709]             future::FutureResult(value = ...future.value$value, 
[13:23:05.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.709]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.709]                     ...future.globalenv.names))
[13:23:05.709]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.709]         }, condition = base::local({
[13:23:05.709]             c <- base::c
[13:23:05.709]             inherits <- base::inherits
[13:23:05.709]             invokeRestart <- base::invokeRestart
[13:23:05.709]             length <- base::length
[13:23:05.709]             list <- base::list
[13:23:05.709]             seq.int <- base::seq.int
[13:23:05.709]             signalCondition <- base::signalCondition
[13:23:05.709]             sys.calls <- base::sys.calls
[13:23:05.709]             `[[` <- base::`[[`
[13:23:05.709]             `+` <- base::`+`
[13:23:05.709]             `<<-` <- base::`<<-`
[13:23:05.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.709]                   3L)]
[13:23:05.709]             }
[13:23:05.709]             function(cond) {
[13:23:05.709]                 is_error <- inherits(cond, "error")
[13:23:05.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.709]                   NULL)
[13:23:05.709]                 if (is_error) {
[13:23:05.709]                   sessionInformation <- function() {
[13:23:05.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.709]                       search = base::search(), system = base::Sys.info())
[13:23:05.709]                   }
[13:23:05.709]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.709]                     cond$call), session = sessionInformation(), 
[13:23:05.709]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.709]                   signalCondition(cond)
[13:23:05.709]                 }
[13:23:05.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.709]                 "immediateCondition"))) {
[13:23:05.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.709]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.709]                   if (TRUE && !signal) {
[13:23:05.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.709]                     {
[13:23:05.709]                       inherits <- base::inherits
[13:23:05.709]                       invokeRestart <- base::invokeRestart
[13:23:05.709]                       is.null <- base::is.null
[13:23:05.709]                       muffled <- FALSE
[13:23:05.709]                       if (inherits(cond, "message")) {
[13:23:05.709]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.709]                         if (muffled) 
[13:23:05.709]                           invokeRestart("muffleMessage")
[13:23:05.709]                       }
[13:23:05.709]                       else if (inherits(cond, "warning")) {
[13:23:05.709]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.709]                         if (muffled) 
[13:23:05.709]                           invokeRestart("muffleWarning")
[13:23:05.709]                       }
[13:23:05.709]                       else if (inherits(cond, "condition")) {
[13:23:05.709]                         if (!is.null(pattern)) {
[13:23:05.709]                           computeRestarts <- base::computeRestarts
[13:23:05.709]                           grepl <- base::grepl
[13:23:05.709]                           restarts <- computeRestarts(cond)
[13:23:05.709]                           for (restart in restarts) {
[13:23:05.709]                             name <- restart$name
[13:23:05.709]                             if (is.null(name)) 
[13:23:05.709]                               next
[13:23:05.709]                             if (!grepl(pattern, name)) 
[13:23:05.709]                               next
[13:23:05.709]                             invokeRestart(restart)
[13:23:05.709]                             muffled <- TRUE
[13:23:05.709]                             break
[13:23:05.709]                           }
[13:23:05.709]                         }
[13:23:05.709]                       }
[13:23:05.709]                       invisible(muffled)
[13:23:05.709]                     }
[13:23:05.709]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.709]                   }
[13:23:05.709]                 }
[13:23:05.709]                 else {
[13:23:05.709]                   if (TRUE) {
[13:23:05.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.709]                     {
[13:23:05.709]                       inherits <- base::inherits
[13:23:05.709]                       invokeRestart <- base::invokeRestart
[13:23:05.709]                       is.null <- base::is.null
[13:23:05.709]                       muffled <- FALSE
[13:23:05.709]                       if (inherits(cond, "message")) {
[13:23:05.709]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.709]                         if (muffled) 
[13:23:05.709]                           invokeRestart("muffleMessage")
[13:23:05.709]                       }
[13:23:05.709]                       else if (inherits(cond, "warning")) {
[13:23:05.709]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.709]                         if (muffled) 
[13:23:05.709]                           invokeRestart("muffleWarning")
[13:23:05.709]                       }
[13:23:05.709]                       else if (inherits(cond, "condition")) {
[13:23:05.709]                         if (!is.null(pattern)) {
[13:23:05.709]                           computeRestarts <- base::computeRestarts
[13:23:05.709]                           grepl <- base::grepl
[13:23:05.709]                           restarts <- computeRestarts(cond)
[13:23:05.709]                           for (restart in restarts) {
[13:23:05.709]                             name <- restart$name
[13:23:05.709]                             if (is.null(name)) 
[13:23:05.709]                               next
[13:23:05.709]                             if (!grepl(pattern, name)) 
[13:23:05.709]                               next
[13:23:05.709]                             invokeRestart(restart)
[13:23:05.709]                             muffled <- TRUE
[13:23:05.709]                             break
[13:23:05.709]                           }
[13:23:05.709]                         }
[13:23:05.709]                       }
[13:23:05.709]                       invisible(muffled)
[13:23:05.709]                     }
[13:23:05.709]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.709]                   }
[13:23:05.709]                 }
[13:23:05.709]             }
[13:23:05.709]         }))
[13:23:05.709]     }, error = function(ex) {
[13:23:05.709]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.709]                 ...future.rng), started = ...future.startTime, 
[13:23:05.709]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.709]             version = "1.8"), class = "FutureResult")
[13:23:05.709]     }, finally = {
[13:23:05.709]         if (!identical(...future.workdir, getwd())) 
[13:23:05.709]             setwd(...future.workdir)
[13:23:05.709]         {
[13:23:05.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.709]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.709]             }
[13:23:05.709]             base::options(...future.oldOptions)
[13:23:05.709]             if (.Platform$OS.type == "windows") {
[13:23:05.709]                 old_names <- names(...future.oldEnvVars)
[13:23:05.709]                 envs <- base::Sys.getenv()
[13:23:05.709]                 names <- names(envs)
[13:23:05.709]                 common <- intersect(names, old_names)
[13:23:05.709]                 added <- setdiff(names, old_names)
[13:23:05.709]                 removed <- setdiff(old_names, names)
[13:23:05.709]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.709]                   envs[common]]
[13:23:05.709]                 NAMES <- toupper(changed)
[13:23:05.709]                 args <- list()
[13:23:05.709]                 for (kk in seq_along(NAMES)) {
[13:23:05.709]                   name <- changed[[kk]]
[13:23:05.709]                   NAME <- NAMES[[kk]]
[13:23:05.709]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.709]                     next
[13:23:05.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.709]                 }
[13:23:05.709]                 NAMES <- toupper(added)
[13:23:05.709]                 for (kk in seq_along(NAMES)) {
[13:23:05.709]                   name <- added[[kk]]
[13:23:05.709]                   NAME <- NAMES[[kk]]
[13:23:05.709]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.709]                     next
[13:23:05.709]                   args[[name]] <- ""
[13:23:05.709]                 }
[13:23:05.709]                 NAMES <- toupper(removed)
[13:23:05.709]                 for (kk in seq_along(NAMES)) {
[13:23:05.709]                   name <- removed[[kk]]
[13:23:05.709]                   NAME <- NAMES[[kk]]
[13:23:05.709]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.709]                     next
[13:23:05.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.709]                 }
[13:23:05.709]                 if (length(args) > 0) 
[13:23:05.709]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.709]             }
[13:23:05.709]             else {
[13:23:05.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.709]             }
[13:23:05.709]             {
[13:23:05.709]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.709]                   0L) {
[13:23:05.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.709]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.709]                   base::options(opts)
[13:23:05.709]                 }
[13:23:05.709]                 {
[13:23:05.709]                   {
[13:23:05.709]                     NULL
[13:23:05.709]                     RNGkind("Mersenne-Twister")
[13:23:05.709]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:05.709]                       inherits = FALSE)
[13:23:05.709]                   }
[13:23:05.709]                   options(future.plan = NULL)
[13:23:05.709]                   if (is.na(NA_character_)) 
[13:23:05.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.709]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:05.709]                   {
[13:23:05.709]                     future <- SequentialFuture(..., envir = envir)
[13:23:05.709]                     if (!future$lazy) 
[13:23:05.709]                       future <- run(future)
[13:23:05.709]                     invisible(future)
[13:23:05.709]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.709]                 }
[13:23:05.709]             }
[13:23:05.709]         }
[13:23:05.709]     })
[13:23:05.709]     if (TRUE) {
[13:23:05.709]         base::sink(type = "output", split = FALSE)
[13:23:05.709]         if (TRUE) {
[13:23:05.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.709]         }
[13:23:05.709]         else {
[13:23:05.709]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.709]         }
[13:23:05.709]         base::close(...future.stdout)
[13:23:05.709]         ...future.stdout <- NULL
[13:23:05.709]     }
[13:23:05.709]     ...future.result$conditions <- ...future.conditions
[13:23:05.709]     ...future.result$finished <- base::Sys.time()
[13:23:05.709]     ...future.result
[13:23:05.709] }
[13:23:05.711] plan(): Setting new future strategy stack:
[13:23:05.711] List of future strategies:
[13:23:05.711] 1. sequential:
[13:23:05.711]    - args: function (..., envir = parent.frame())
[13:23:05.711]    - tweaked: FALSE
[13:23:05.711]    - call: NULL
[13:23:05.712] plan(): nbrOfWorkers() = 1
[13:23:05.713] plan(): Setting new future strategy stack:
[13:23:05.713] List of future strategies:
[13:23:05.713] 1. sequential:
[13:23:05.713]    - args: function (..., envir = parent.frame())
[13:23:05.713]    - tweaked: FALSE
[13:23:05.713]    - call: plan(strategy)
[13:23:05.713] plan(): nbrOfWorkers() = 1
[13:23:05.713] SequentialFuture started (and completed)
[13:23:05.713] - Launch lazy future ... done
[13:23:05.713] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d59c4058> 
Classes 'listenv', 'environment' <environment: 0x5596d56ac540> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:23:05.718] resolved() for ‘SequentialFuture’ ...
[13:23:05.718] - state: ‘finished’
[13:23:05.718] - run: TRUE
[13:23:05.718] - result: ‘FutureResult’
[13:23:05.718] resolved() for ‘SequentialFuture’ ... done
[13:23:05.718] resolved() for ‘SequentialFuture’ ...
[13:23:05.718] - state: ‘finished’
[13:23:05.719] - run: TRUE
[13:23:05.719] - result: ‘FutureResult’
[13:23:05.719] resolved() for ‘SequentialFuture’ ... done
[13:23:05.719] resolved() for ‘SequentialFuture’ ...
[13:23:05.719] - state: ‘finished’
[13:23:05.719] - run: TRUE
[13:23:05.719] - result: ‘FutureResult’
[13:23:05.719] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:05.724] resolve() on list environment ...
[13:23:05.725]  recursive: 0
[13:23:05.726]  length: 6
[13:23:05.726]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:05.726] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.726] - nx: 6
[13:23:05.726] - relay: TRUE
[13:23:05.726] - stdout: TRUE
[13:23:05.726] - signal: TRUE
[13:23:05.726] - resignal: FALSE
[13:23:05.727] - force: TRUE
[13:23:05.727] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.727] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.727]  - until=2
[13:23:05.727]  - relaying element #2
[13:23:05.727] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.727] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.727] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.727]  length: 5 (resolved future 1)
[13:23:05.727] resolved() for ‘SequentialFuture’ ...
[13:23:05.728] - state: ‘finished’
[13:23:05.728] - run: TRUE
[13:23:05.728] - result: ‘FutureResult’
[13:23:05.728] resolved() for ‘SequentialFuture’ ... done
[13:23:05.728] Future #2
[13:23:05.728] signalConditionsASAP(SequentialFuture, pos=2) ...
[13:23:05.728] - nx: 6
[13:23:05.728] - relay: TRUE
[13:23:05.728] - stdout: TRUE
[13:23:05.729] - signal: TRUE
[13:23:05.729] - resignal: FALSE
[13:23:05.729] - force: TRUE
[13:23:05.729] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.729] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.729]  - until=2
[13:23:05.729]  - relaying element #2
[13:23:05.729] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.729] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.730] signalConditionsASAP(SequentialFuture, pos=2) ... done
[13:23:05.730]  length: 4 (resolved future 2)
[13:23:05.730] resolved() for ‘SequentialFuture’ ...
[13:23:05.730] - state: ‘finished’
[13:23:05.730] - run: TRUE
[13:23:05.730] - result: ‘FutureResult’
[13:23:05.730] resolved() for ‘SequentialFuture’ ... done
[13:23:05.730] Future #3
[13:23:05.730] signalConditionsASAP(SequentialFuture, pos=3) ...
[13:23:05.730] - nx: 6
[13:23:05.731] - relay: TRUE
[13:23:05.731] - stdout: TRUE
[13:23:05.731] - signal: TRUE
[13:23:05.731] - resignal: FALSE
[13:23:05.731] - force: TRUE
[13:23:05.731] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.731] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.731]  - until=3
[13:23:05.731]  - relaying element #3
[13:23:05.731] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.732] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.732] signalConditionsASAP(SequentialFuture, pos=3) ... done
[13:23:05.732]  length: 3 (resolved future 3)
[13:23:05.732] resolved() for ‘SequentialFuture’ ...
[13:23:05.732] - state: ‘finished’
[13:23:05.732] - run: TRUE
[13:23:05.732] - result: ‘FutureResult’
[13:23:05.732] resolved() for ‘SequentialFuture’ ... done
[13:23:05.732] Future #4
[13:23:05.733] signalConditionsASAP(SequentialFuture, pos=4) ...
[13:23:05.733] - nx: 6
[13:23:05.733] - relay: TRUE
[13:23:05.733] - stdout: TRUE
[13:23:05.733] - signal: TRUE
[13:23:05.733] - resignal: FALSE
[13:23:05.733] - force: TRUE
[13:23:05.733] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.733] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.733]  - until=4
[13:23:05.733]  - relaying element #4
[13:23:05.734] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.734] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.734] signalConditionsASAP(SequentialFuture, pos=4) ... done
[13:23:05.734]  length: 2 (resolved future 4)
[13:23:05.734] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.734] - nx: 6
[13:23:05.734] - relay: TRUE
[13:23:05.734] - stdout: TRUE
[13:23:05.734] - signal: TRUE
[13:23:05.734] - resignal: FALSE
[13:23:05.735] - force: TRUE
[13:23:05.735] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.735] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.735]  - until=6
[13:23:05.735]  - relaying element #6
[13:23:05.735] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.735] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.735] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.735]  length: 1 (resolved future 5)
[13:23:05.735] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.735] - nx: 6
[13:23:05.736] - relay: TRUE
[13:23:05.736] - stdout: TRUE
[13:23:05.736] - signal: TRUE
[13:23:05.736] - resignal: FALSE
[13:23:05.736] - force: TRUE
[13:23:05.736] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.736] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.736]  - until=6
[13:23:05.736] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.736] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.736] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.737]  length: 0 (resolved future 6)
[13:23:05.737] Relaying remaining futures
[13:23:05.737] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.737] - nx: 6
[13:23:05.737] - relay: TRUE
[13:23:05.737] - stdout: TRUE
[13:23:05.737] - signal: TRUE
[13:23:05.737] - resignal: FALSE
[13:23:05.737] - force: TRUE
[13:23:05.737] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.737] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:05.738] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.738] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.738] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.738] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x5596d53761b8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[13:23:05.741] plan(): Setting new future strategy stack:
[13:23:05.741] List of future strategies:
[13:23:05.741] 1. multicore:
[13:23:05.741]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:05.741]    - tweaked: FALSE
[13:23:05.741]    - call: plan(strategy)
[13:23:05.746] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:23:05.746] getGlobalsAndPackages() ...
[13:23:05.746] Searching for globals...
[13:23:05.746] 
[13:23:05.747] Searching for globals ... DONE
[13:23:05.747] - globals: [0] <none>
[13:23:05.747] getGlobalsAndPackages() ... DONE
[13:23:05.747] run() for ‘Future’ ...
[13:23:05.747] - state: ‘created’
[13:23:05.747] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:05.751] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:05.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:05.752]   - Field: ‘label’
[13:23:05.752]   - Field: ‘local’
[13:23:05.752]   - Field: ‘owner’
[13:23:05.752]   - Field: ‘envir’
[13:23:05.752]   - Field: ‘workers’
[13:23:05.752]   - Field: ‘packages’
[13:23:05.753]   - Field: ‘gc’
[13:23:05.753]   - Field: ‘job’
[13:23:05.753]   - Field: ‘conditions’
[13:23:05.753]   - Field: ‘expr’
[13:23:05.753]   - Field: ‘uuid’
[13:23:05.753]   - Field: ‘seed’
[13:23:05.753]   - Field: ‘version’
[13:23:05.753]   - Field: ‘result’
[13:23:05.754]   - Field: ‘asynchronous’
[13:23:05.754]   - Field: ‘calls’
[13:23:05.754]   - Field: ‘globals’
[13:23:05.754]   - Field: ‘stdout’
[13:23:05.754]   - Field: ‘earlySignal’
[13:23:05.754]   - Field: ‘lazy’
[13:23:05.754]   - Field: ‘state’
[13:23:05.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:05.754] - Launch lazy future ...
[13:23:05.755] Packages needed by the future expression (n = 0): <none>
[13:23:05.756] Packages needed by future strategies (n = 0): <none>
[13:23:05.758] {
[13:23:05.758]     {
[13:23:05.758]         {
[13:23:05.758]             ...future.startTime <- base::Sys.time()
[13:23:05.758]             {
[13:23:05.758]                 {
[13:23:05.758]                   {
[13:23:05.758]                     {
[13:23:05.758]                       base::local({
[13:23:05.758]                         has_future <- base::requireNamespace("future", 
[13:23:05.758]                           quietly = TRUE)
[13:23:05.758]                         if (has_future) {
[13:23:05.758]                           ns <- base::getNamespace("future")
[13:23:05.758]                           version <- ns[[".package"]][["version"]]
[13:23:05.758]                           if (is.null(version)) 
[13:23:05.758]                             version <- utils::packageVersion("future")
[13:23:05.758]                         }
[13:23:05.758]                         else {
[13:23:05.758]                           version <- NULL
[13:23:05.758]                         }
[13:23:05.758]                         if (!has_future || version < "1.8.0") {
[13:23:05.758]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.758]                             "", base::R.version$version.string), 
[13:23:05.758]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:05.758]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.758]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.758]                               "release", "version")], collapse = " "), 
[13:23:05.758]                             hostname = base::Sys.info()[["nodename"]])
[13:23:05.758]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.758]                             info)
[13:23:05.758]                           info <- base::paste(info, collapse = "; ")
[13:23:05.758]                           if (!has_future) {
[13:23:05.758]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.758]                               info)
[13:23:05.758]                           }
[13:23:05.758]                           else {
[13:23:05.758]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.758]                               info, version)
[13:23:05.758]                           }
[13:23:05.758]                           base::stop(msg)
[13:23:05.758]                         }
[13:23:05.758]                       })
[13:23:05.758]                     }
[13:23:05.758]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:05.758]                     base::options(mc.cores = 1L)
[13:23:05.758]                   }
[13:23:05.758]                   options(future.plan = NULL)
[13:23:05.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.758]                 }
[13:23:05.758]                 ...future.workdir <- getwd()
[13:23:05.758]             }
[13:23:05.758]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.758]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.758]         }
[13:23:05.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.758]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.758]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.758]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.758]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.758]             base::names(...future.oldOptions))
[13:23:05.758]     }
[13:23:05.758]     if (FALSE) {
[13:23:05.758]     }
[13:23:05.758]     else {
[13:23:05.758]         if (TRUE) {
[13:23:05.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.758]                 open = "w")
[13:23:05.758]         }
[13:23:05.758]         else {
[13:23:05.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.758]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.758]         }
[13:23:05.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.758]             base::sink(type = "output", split = FALSE)
[13:23:05.758]             base::close(...future.stdout)
[13:23:05.758]         }, add = TRUE)
[13:23:05.758]     }
[13:23:05.758]     ...future.frame <- base::sys.nframe()
[13:23:05.758]     ...future.conditions <- base::list()
[13:23:05.758]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.758]     if (FALSE) {
[13:23:05.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.758]     }
[13:23:05.758]     ...future.result <- base::tryCatch({
[13:23:05.758]         base::withCallingHandlers({
[13:23:05.758]             ...future.value <- base::withVisible(base::local({
[13:23:05.758]                 withCallingHandlers({
[13:23:05.758]                   2
[13:23:05.758]                 }, immediateCondition = function(cond) {
[13:23:05.758]                   save_rds <- function (object, pathname, ...) 
[13:23:05.758]                   {
[13:23:05.758]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:05.758]                     if (file_test("-f", pathname_tmp)) {
[13:23:05.758]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.758]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:05.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.758]                         fi_tmp[["mtime"]])
[13:23:05.758]                     }
[13:23:05.758]                     tryCatch({
[13:23:05.758]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:05.758]                     }, error = function(ex) {
[13:23:05.758]                       msg <- conditionMessage(ex)
[13:23:05.758]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.758]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:05.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.758]                         fi_tmp[["mtime"]], msg)
[13:23:05.758]                       ex$message <- msg
[13:23:05.758]                       stop(ex)
[13:23:05.758]                     })
[13:23:05.758]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:05.758]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:05.758]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:05.758]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.758]                       fi <- file.info(pathname)
[13:23:05.758]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:05.758]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.758]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:05.758]                         fi[["size"]], fi[["mtime"]])
[13:23:05.758]                       stop(msg)
[13:23:05.758]                     }
[13:23:05.758]                     invisible(pathname)
[13:23:05.758]                   }
[13:23:05.758]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:05.758]                     rootPath = tempdir()) 
[13:23:05.758]                   {
[13:23:05.758]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:05.758]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:05.758]                       tmpdir = path, fileext = ".rds")
[13:23:05.758]                     save_rds(obj, file)
[13:23:05.758]                   }
[13:23:05.758]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:05.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.758]                   {
[13:23:05.758]                     inherits <- base::inherits
[13:23:05.758]                     invokeRestart <- base::invokeRestart
[13:23:05.758]                     is.null <- base::is.null
[13:23:05.758]                     muffled <- FALSE
[13:23:05.758]                     if (inherits(cond, "message")) {
[13:23:05.758]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:05.758]                       if (muffled) 
[13:23:05.758]                         invokeRestart("muffleMessage")
[13:23:05.758]                     }
[13:23:05.758]                     else if (inherits(cond, "warning")) {
[13:23:05.758]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:05.758]                       if (muffled) 
[13:23:05.758]                         invokeRestart("muffleWarning")
[13:23:05.758]                     }
[13:23:05.758]                     else if (inherits(cond, "condition")) {
[13:23:05.758]                       if (!is.null(pattern)) {
[13:23:05.758]                         computeRestarts <- base::computeRestarts
[13:23:05.758]                         grepl <- base::grepl
[13:23:05.758]                         restarts <- computeRestarts(cond)
[13:23:05.758]                         for (restart in restarts) {
[13:23:05.758]                           name <- restart$name
[13:23:05.758]                           if (is.null(name)) 
[13:23:05.758]                             next
[13:23:05.758]                           if (!grepl(pattern, name)) 
[13:23:05.758]                             next
[13:23:05.758]                           invokeRestart(restart)
[13:23:05.758]                           muffled <- TRUE
[13:23:05.758]                           break
[13:23:05.758]                         }
[13:23:05.758]                       }
[13:23:05.758]                     }
[13:23:05.758]                     invisible(muffled)
[13:23:05.758]                   }
[13:23:05.758]                   muffleCondition(cond)
[13:23:05.758]                 })
[13:23:05.758]             }))
[13:23:05.758]             future::FutureResult(value = ...future.value$value, 
[13:23:05.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.758]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.758]                     ...future.globalenv.names))
[13:23:05.758]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.758]         }, condition = base::local({
[13:23:05.758]             c <- base::c
[13:23:05.758]             inherits <- base::inherits
[13:23:05.758]             invokeRestart <- base::invokeRestart
[13:23:05.758]             length <- base::length
[13:23:05.758]             list <- base::list
[13:23:05.758]             seq.int <- base::seq.int
[13:23:05.758]             signalCondition <- base::signalCondition
[13:23:05.758]             sys.calls <- base::sys.calls
[13:23:05.758]             `[[` <- base::`[[`
[13:23:05.758]             `+` <- base::`+`
[13:23:05.758]             `<<-` <- base::`<<-`
[13:23:05.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.758]                   3L)]
[13:23:05.758]             }
[13:23:05.758]             function(cond) {
[13:23:05.758]                 is_error <- inherits(cond, "error")
[13:23:05.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.758]                   NULL)
[13:23:05.758]                 if (is_error) {
[13:23:05.758]                   sessionInformation <- function() {
[13:23:05.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.758]                       search = base::search(), system = base::Sys.info())
[13:23:05.758]                   }
[13:23:05.758]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.758]                     cond$call), session = sessionInformation(), 
[13:23:05.758]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.758]                   signalCondition(cond)
[13:23:05.758]                 }
[13:23:05.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.758]                 "immediateCondition"))) {
[13:23:05.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.758]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.758]                   if (TRUE && !signal) {
[13:23:05.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.758]                     {
[13:23:05.758]                       inherits <- base::inherits
[13:23:05.758]                       invokeRestart <- base::invokeRestart
[13:23:05.758]                       is.null <- base::is.null
[13:23:05.758]                       muffled <- FALSE
[13:23:05.758]                       if (inherits(cond, "message")) {
[13:23:05.758]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.758]                         if (muffled) 
[13:23:05.758]                           invokeRestart("muffleMessage")
[13:23:05.758]                       }
[13:23:05.758]                       else if (inherits(cond, "warning")) {
[13:23:05.758]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.758]                         if (muffled) 
[13:23:05.758]                           invokeRestart("muffleWarning")
[13:23:05.758]                       }
[13:23:05.758]                       else if (inherits(cond, "condition")) {
[13:23:05.758]                         if (!is.null(pattern)) {
[13:23:05.758]                           computeRestarts <- base::computeRestarts
[13:23:05.758]                           grepl <- base::grepl
[13:23:05.758]                           restarts <- computeRestarts(cond)
[13:23:05.758]                           for (restart in restarts) {
[13:23:05.758]                             name <- restart$name
[13:23:05.758]                             if (is.null(name)) 
[13:23:05.758]                               next
[13:23:05.758]                             if (!grepl(pattern, name)) 
[13:23:05.758]                               next
[13:23:05.758]                             invokeRestart(restart)
[13:23:05.758]                             muffled <- TRUE
[13:23:05.758]                             break
[13:23:05.758]                           }
[13:23:05.758]                         }
[13:23:05.758]                       }
[13:23:05.758]                       invisible(muffled)
[13:23:05.758]                     }
[13:23:05.758]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.758]                   }
[13:23:05.758]                 }
[13:23:05.758]                 else {
[13:23:05.758]                   if (TRUE) {
[13:23:05.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.758]                     {
[13:23:05.758]                       inherits <- base::inherits
[13:23:05.758]                       invokeRestart <- base::invokeRestart
[13:23:05.758]                       is.null <- base::is.null
[13:23:05.758]                       muffled <- FALSE
[13:23:05.758]                       if (inherits(cond, "message")) {
[13:23:05.758]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.758]                         if (muffled) 
[13:23:05.758]                           invokeRestart("muffleMessage")
[13:23:05.758]                       }
[13:23:05.758]                       else if (inherits(cond, "warning")) {
[13:23:05.758]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.758]                         if (muffled) 
[13:23:05.758]                           invokeRestart("muffleWarning")
[13:23:05.758]                       }
[13:23:05.758]                       else if (inherits(cond, "condition")) {
[13:23:05.758]                         if (!is.null(pattern)) {
[13:23:05.758]                           computeRestarts <- base::computeRestarts
[13:23:05.758]                           grepl <- base::grepl
[13:23:05.758]                           restarts <- computeRestarts(cond)
[13:23:05.758]                           for (restart in restarts) {
[13:23:05.758]                             name <- restart$name
[13:23:05.758]                             if (is.null(name)) 
[13:23:05.758]                               next
[13:23:05.758]                             if (!grepl(pattern, name)) 
[13:23:05.758]                               next
[13:23:05.758]                             invokeRestart(restart)
[13:23:05.758]                             muffled <- TRUE
[13:23:05.758]                             break
[13:23:05.758]                           }
[13:23:05.758]                         }
[13:23:05.758]                       }
[13:23:05.758]                       invisible(muffled)
[13:23:05.758]                     }
[13:23:05.758]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.758]                   }
[13:23:05.758]                 }
[13:23:05.758]             }
[13:23:05.758]         }))
[13:23:05.758]     }, error = function(ex) {
[13:23:05.758]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.758]                 ...future.rng), started = ...future.startTime, 
[13:23:05.758]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.758]             version = "1.8"), class = "FutureResult")
[13:23:05.758]     }, finally = {
[13:23:05.758]         if (!identical(...future.workdir, getwd())) 
[13:23:05.758]             setwd(...future.workdir)
[13:23:05.758]         {
[13:23:05.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.758]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.758]             }
[13:23:05.758]             base::options(...future.oldOptions)
[13:23:05.758]             if (.Platform$OS.type == "windows") {
[13:23:05.758]                 old_names <- names(...future.oldEnvVars)
[13:23:05.758]                 envs <- base::Sys.getenv()
[13:23:05.758]                 names <- names(envs)
[13:23:05.758]                 common <- intersect(names, old_names)
[13:23:05.758]                 added <- setdiff(names, old_names)
[13:23:05.758]                 removed <- setdiff(old_names, names)
[13:23:05.758]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.758]                   envs[common]]
[13:23:05.758]                 NAMES <- toupper(changed)
[13:23:05.758]                 args <- list()
[13:23:05.758]                 for (kk in seq_along(NAMES)) {
[13:23:05.758]                   name <- changed[[kk]]
[13:23:05.758]                   NAME <- NAMES[[kk]]
[13:23:05.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.758]                     next
[13:23:05.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.758]                 }
[13:23:05.758]                 NAMES <- toupper(added)
[13:23:05.758]                 for (kk in seq_along(NAMES)) {
[13:23:05.758]                   name <- added[[kk]]
[13:23:05.758]                   NAME <- NAMES[[kk]]
[13:23:05.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.758]                     next
[13:23:05.758]                   args[[name]] <- ""
[13:23:05.758]                 }
[13:23:05.758]                 NAMES <- toupper(removed)
[13:23:05.758]                 for (kk in seq_along(NAMES)) {
[13:23:05.758]                   name <- removed[[kk]]
[13:23:05.758]                   NAME <- NAMES[[kk]]
[13:23:05.758]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.758]                     next
[13:23:05.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.758]                 }
[13:23:05.758]                 if (length(args) > 0) 
[13:23:05.758]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.758]             }
[13:23:05.758]             else {
[13:23:05.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.758]             }
[13:23:05.758]             {
[13:23:05.758]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.758]                   0L) {
[13:23:05.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.758]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.758]                   base::options(opts)
[13:23:05.758]                 }
[13:23:05.758]                 {
[13:23:05.758]                   {
[13:23:05.758]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:05.758]                     NULL
[13:23:05.758]                   }
[13:23:05.758]                   options(future.plan = NULL)
[13:23:05.758]                   if (is.na(NA_character_)) 
[13:23:05.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.758]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:05.758]                     envir = parent.frame()) 
[13:23:05.758]                   {
[13:23:05.758]                     default_workers <- missing(workers)
[13:23:05.758]                     if (is.function(workers)) 
[13:23:05.758]                       workers <- workers()
[13:23:05.758]                     workers <- structure(as.integer(workers), 
[13:23:05.758]                       class = class(workers))
[13:23:05.758]                     stop_if_not(is.finite(workers), workers >= 
[13:23:05.758]                       1L)
[13:23:05.758]                     if ((workers == 1L && !inherits(workers, 
[13:23:05.758]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:05.758]                       if (default_workers) 
[13:23:05.758]                         supportsMulticore(warn = TRUE)
[13:23:05.758]                       return(sequential(..., envir = envir))
[13:23:05.758]                     }
[13:23:05.758]                     oopts <- options(mc.cores = workers)
[13:23:05.758]                     on.exit(options(oopts))
[13:23:05.758]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:05.758]                       envir = envir)
[13:23:05.758]                     if (!future$lazy) 
[13:23:05.758]                       future <- run(future)
[13:23:05.758]                     invisible(future)
[13:23:05.758]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.758]                 }
[13:23:05.758]             }
[13:23:05.758]         }
[13:23:05.758]     })
[13:23:05.758]     if (TRUE) {
[13:23:05.758]         base::sink(type = "output", split = FALSE)
[13:23:05.758]         if (TRUE) {
[13:23:05.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.758]         }
[13:23:05.758]         else {
[13:23:05.758]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.758]         }
[13:23:05.758]         base::close(...future.stdout)
[13:23:05.758]         ...future.stdout <- NULL
[13:23:05.758]     }
[13:23:05.758]     ...future.result$conditions <- ...future.conditions
[13:23:05.758]     ...future.result$finished <- base::Sys.time()
[13:23:05.758]     ...future.result
[13:23:05.758] }
[13:23:05.761] requestCore(): workers = 2
[13:23:05.764] MulticoreFuture started
[13:23:05.765] - Launch lazy future ... done
[13:23:05.765] plan(): Setting new future strategy stack:
[13:23:05.766] run() for ‘MulticoreFuture’ ... done
[13:23:05.766] getGlobalsAndPackages() ...
[13:23:05.766] List of future strategies:
[13:23:05.766] 1. sequential:
[13:23:05.766]    - args: function (..., envir = parent.frame())
[13:23:05.766]    - tweaked: FALSE
[13:23:05.766]    - call: NULL
[13:23:05.767] Searching for globals...
[13:23:05.767] plan(): nbrOfWorkers() = 1
[13:23:05.769] 
[13:23:05.769] Searching for globals ... DONE
[13:23:05.769] - globals: [0] <none>
[13:23:05.769] getGlobalsAndPackages() ... DONE
[13:23:05.770] plan(): Setting new future strategy stack:
[13:23:05.770] run() for ‘Future’ ...
[13:23:05.770] - state: ‘created’
[13:23:05.770] List of future strategies:
[13:23:05.770] 1. multicore:
[13:23:05.770]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:05.770]    - tweaked: FALSE
[13:23:05.770]    - call: plan(strategy)
[13:23:05.771] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:05.776] plan(): nbrOfWorkers() = 2
[13:23:05.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:05.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:05.777]   - Field: ‘label’
[13:23:05.778]   - Field: ‘local’
[13:23:05.778]   - Field: ‘owner’
[13:23:05.778]   - Field: ‘envir’
[13:23:05.778]   - Field: ‘workers’
[13:23:05.778]   - Field: ‘packages’
[13:23:05.779]   - Field: ‘gc’
[13:23:05.779]   - Field: ‘job’
[13:23:05.779]   - Field: ‘conditions’
[13:23:05.779]   - Field: ‘expr’
[13:23:05.779]   - Field: ‘uuid’
[13:23:05.780]   - Field: ‘seed’
[13:23:05.780]   - Field: ‘version’
[13:23:05.780]   - Field: ‘result’
[13:23:05.780]   - Field: ‘asynchronous’
[13:23:05.780]   - Field: ‘calls’
[13:23:05.780]   - Field: ‘globals’
[13:23:05.781]   - Field: ‘stdout’
[13:23:05.781]   - Field: ‘earlySignal’
[13:23:05.781]   - Field: ‘lazy’
[13:23:05.781]   - Field: ‘state’
[13:23:05.781] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:05.781] - Launch lazy future ...
[13:23:05.782] Packages needed by the future expression (n = 0): <none>
[13:23:05.782] Packages needed by future strategies (n = 0): <none>
[13:23:05.783] {
[13:23:05.783]     {
[13:23:05.783]         {
[13:23:05.783]             ...future.startTime <- base::Sys.time()
[13:23:05.783]             {
[13:23:05.783]                 {
[13:23:05.783]                   {
[13:23:05.783]                     {
[13:23:05.783]                       base::local({
[13:23:05.783]                         has_future <- base::requireNamespace("future", 
[13:23:05.783]                           quietly = TRUE)
[13:23:05.783]                         if (has_future) {
[13:23:05.783]                           ns <- base::getNamespace("future")
[13:23:05.783]                           version <- ns[[".package"]][["version"]]
[13:23:05.783]                           if (is.null(version)) 
[13:23:05.783]                             version <- utils::packageVersion("future")
[13:23:05.783]                         }
[13:23:05.783]                         else {
[13:23:05.783]                           version <- NULL
[13:23:05.783]                         }
[13:23:05.783]                         if (!has_future || version < "1.8.0") {
[13:23:05.783]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.783]                             "", base::R.version$version.string), 
[13:23:05.783]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:05.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.783]                               "release", "version")], collapse = " "), 
[13:23:05.783]                             hostname = base::Sys.info()[["nodename"]])
[13:23:05.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.783]                             info)
[13:23:05.783]                           info <- base::paste(info, collapse = "; ")
[13:23:05.783]                           if (!has_future) {
[13:23:05.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.783]                               info)
[13:23:05.783]                           }
[13:23:05.783]                           else {
[13:23:05.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.783]                               info, version)
[13:23:05.783]                           }
[13:23:05.783]                           base::stop(msg)
[13:23:05.783]                         }
[13:23:05.783]                       })
[13:23:05.783]                     }
[13:23:05.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:05.783]                     base::options(mc.cores = 1L)
[13:23:05.783]                   }
[13:23:05.783]                   options(future.plan = NULL)
[13:23:05.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.783]                 }
[13:23:05.783]                 ...future.workdir <- getwd()
[13:23:05.783]             }
[13:23:05.783]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.783]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.783]         }
[13:23:05.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.783]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.783]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.783]             base::names(...future.oldOptions))
[13:23:05.783]     }
[13:23:05.783]     if (FALSE) {
[13:23:05.783]     }
[13:23:05.783]     else {
[13:23:05.783]         if (TRUE) {
[13:23:05.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.783]                 open = "w")
[13:23:05.783]         }
[13:23:05.783]         else {
[13:23:05.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.783]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.783]         }
[13:23:05.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.783]             base::sink(type = "output", split = FALSE)
[13:23:05.783]             base::close(...future.stdout)
[13:23:05.783]         }, add = TRUE)
[13:23:05.783]     }
[13:23:05.783]     ...future.frame <- base::sys.nframe()
[13:23:05.783]     ...future.conditions <- base::list()
[13:23:05.783]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.783]     if (FALSE) {
[13:23:05.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.783]     }
[13:23:05.783]     ...future.result <- base::tryCatch({
[13:23:05.783]         base::withCallingHandlers({
[13:23:05.783]             ...future.value <- base::withVisible(base::local({
[13:23:05.783]                 withCallingHandlers({
[13:23:05.783]                   NULL
[13:23:05.783]                 }, immediateCondition = function(cond) {
[13:23:05.783]                   save_rds <- function (object, pathname, ...) 
[13:23:05.783]                   {
[13:23:05.783]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:05.783]                     if (file_test("-f", pathname_tmp)) {
[13:23:05.783]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.783]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:05.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.783]                         fi_tmp[["mtime"]])
[13:23:05.783]                     }
[13:23:05.783]                     tryCatch({
[13:23:05.783]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:05.783]                     }, error = function(ex) {
[13:23:05.783]                       msg <- conditionMessage(ex)
[13:23:05.783]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.783]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:05.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.783]                         fi_tmp[["mtime"]], msg)
[13:23:05.783]                       ex$message <- msg
[13:23:05.783]                       stop(ex)
[13:23:05.783]                     })
[13:23:05.783]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:05.783]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:05.783]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:05.783]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.783]                       fi <- file.info(pathname)
[13:23:05.783]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:05.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.783]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:05.783]                         fi[["size"]], fi[["mtime"]])
[13:23:05.783]                       stop(msg)
[13:23:05.783]                     }
[13:23:05.783]                     invisible(pathname)
[13:23:05.783]                   }
[13:23:05.783]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:05.783]                     rootPath = tempdir()) 
[13:23:05.783]                   {
[13:23:05.783]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:05.783]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:05.783]                       tmpdir = path, fileext = ".rds")
[13:23:05.783]                     save_rds(obj, file)
[13:23:05.783]                   }
[13:23:05.783]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:05.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.783]                   {
[13:23:05.783]                     inherits <- base::inherits
[13:23:05.783]                     invokeRestart <- base::invokeRestart
[13:23:05.783]                     is.null <- base::is.null
[13:23:05.783]                     muffled <- FALSE
[13:23:05.783]                     if (inherits(cond, "message")) {
[13:23:05.783]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:05.783]                       if (muffled) 
[13:23:05.783]                         invokeRestart("muffleMessage")
[13:23:05.783]                     }
[13:23:05.783]                     else if (inherits(cond, "warning")) {
[13:23:05.783]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:05.783]                       if (muffled) 
[13:23:05.783]                         invokeRestart("muffleWarning")
[13:23:05.783]                     }
[13:23:05.783]                     else if (inherits(cond, "condition")) {
[13:23:05.783]                       if (!is.null(pattern)) {
[13:23:05.783]                         computeRestarts <- base::computeRestarts
[13:23:05.783]                         grepl <- base::grepl
[13:23:05.783]                         restarts <- computeRestarts(cond)
[13:23:05.783]                         for (restart in restarts) {
[13:23:05.783]                           name <- restart$name
[13:23:05.783]                           if (is.null(name)) 
[13:23:05.783]                             next
[13:23:05.783]                           if (!grepl(pattern, name)) 
[13:23:05.783]                             next
[13:23:05.783]                           invokeRestart(restart)
[13:23:05.783]                           muffled <- TRUE
[13:23:05.783]                           break
[13:23:05.783]                         }
[13:23:05.783]                       }
[13:23:05.783]                     }
[13:23:05.783]                     invisible(muffled)
[13:23:05.783]                   }
[13:23:05.783]                   muffleCondition(cond)
[13:23:05.783]                 })
[13:23:05.783]             }))
[13:23:05.783]             future::FutureResult(value = ...future.value$value, 
[13:23:05.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.783]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.783]                     ...future.globalenv.names))
[13:23:05.783]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.783]         }, condition = base::local({
[13:23:05.783]             c <- base::c
[13:23:05.783]             inherits <- base::inherits
[13:23:05.783]             invokeRestart <- base::invokeRestart
[13:23:05.783]             length <- base::length
[13:23:05.783]             list <- base::list
[13:23:05.783]             seq.int <- base::seq.int
[13:23:05.783]             signalCondition <- base::signalCondition
[13:23:05.783]             sys.calls <- base::sys.calls
[13:23:05.783]             `[[` <- base::`[[`
[13:23:05.783]             `+` <- base::`+`
[13:23:05.783]             `<<-` <- base::`<<-`
[13:23:05.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.783]                   3L)]
[13:23:05.783]             }
[13:23:05.783]             function(cond) {
[13:23:05.783]                 is_error <- inherits(cond, "error")
[13:23:05.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.783]                   NULL)
[13:23:05.783]                 if (is_error) {
[13:23:05.783]                   sessionInformation <- function() {
[13:23:05.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.783]                       search = base::search(), system = base::Sys.info())
[13:23:05.783]                   }
[13:23:05.783]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.783]                     cond$call), session = sessionInformation(), 
[13:23:05.783]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.783]                   signalCondition(cond)
[13:23:05.783]                 }
[13:23:05.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.783]                 "immediateCondition"))) {
[13:23:05.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.783]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.783]                   if (TRUE && !signal) {
[13:23:05.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.783]                     {
[13:23:05.783]                       inherits <- base::inherits
[13:23:05.783]                       invokeRestart <- base::invokeRestart
[13:23:05.783]                       is.null <- base::is.null
[13:23:05.783]                       muffled <- FALSE
[13:23:05.783]                       if (inherits(cond, "message")) {
[13:23:05.783]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.783]                         if (muffled) 
[13:23:05.783]                           invokeRestart("muffleMessage")
[13:23:05.783]                       }
[13:23:05.783]                       else if (inherits(cond, "warning")) {
[13:23:05.783]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.783]                         if (muffled) 
[13:23:05.783]                           invokeRestart("muffleWarning")
[13:23:05.783]                       }
[13:23:05.783]                       else if (inherits(cond, "condition")) {
[13:23:05.783]                         if (!is.null(pattern)) {
[13:23:05.783]                           computeRestarts <- base::computeRestarts
[13:23:05.783]                           grepl <- base::grepl
[13:23:05.783]                           restarts <- computeRestarts(cond)
[13:23:05.783]                           for (restart in restarts) {
[13:23:05.783]                             name <- restart$name
[13:23:05.783]                             if (is.null(name)) 
[13:23:05.783]                               next
[13:23:05.783]                             if (!grepl(pattern, name)) 
[13:23:05.783]                               next
[13:23:05.783]                             invokeRestart(restart)
[13:23:05.783]                             muffled <- TRUE
[13:23:05.783]                             break
[13:23:05.783]                           }
[13:23:05.783]                         }
[13:23:05.783]                       }
[13:23:05.783]                       invisible(muffled)
[13:23:05.783]                     }
[13:23:05.783]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.783]                   }
[13:23:05.783]                 }
[13:23:05.783]                 else {
[13:23:05.783]                   if (TRUE) {
[13:23:05.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.783]                     {
[13:23:05.783]                       inherits <- base::inherits
[13:23:05.783]                       invokeRestart <- base::invokeRestart
[13:23:05.783]                       is.null <- base::is.null
[13:23:05.783]                       muffled <- FALSE
[13:23:05.783]                       if (inherits(cond, "message")) {
[13:23:05.783]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.783]                         if (muffled) 
[13:23:05.783]                           invokeRestart("muffleMessage")
[13:23:05.783]                       }
[13:23:05.783]                       else if (inherits(cond, "warning")) {
[13:23:05.783]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.783]                         if (muffled) 
[13:23:05.783]                           invokeRestart("muffleWarning")
[13:23:05.783]                       }
[13:23:05.783]                       else if (inherits(cond, "condition")) {
[13:23:05.783]                         if (!is.null(pattern)) {
[13:23:05.783]                           computeRestarts <- base::computeRestarts
[13:23:05.783]                           grepl <- base::grepl
[13:23:05.783]                           restarts <- computeRestarts(cond)
[13:23:05.783]                           for (restart in restarts) {
[13:23:05.783]                             name <- restart$name
[13:23:05.783]                             if (is.null(name)) 
[13:23:05.783]                               next
[13:23:05.783]                             if (!grepl(pattern, name)) 
[13:23:05.783]                               next
[13:23:05.783]                             invokeRestart(restart)
[13:23:05.783]                             muffled <- TRUE
[13:23:05.783]                             break
[13:23:05.783]                           }
[13:23:05.783]                         }
[13:23:05.783]                       }
[13:23:05.783]                       invisible(muffled)
[13:23:05.783]                     }
[13:23:05.783]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.783]                   }
[13:23:05.783]                 }
[13:23:05.783]             }
[13:23:05.783]         }))
[13:23:05.783]     }, error = function(ex) {
[13:23:05.783]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.783]                 ...future.rng), started = ...future.startTime, 
[13:23:05.783]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.783]             version = "1.8"), class = "FutureResult")
[13:23:05.783]     }, finally = {
[13:23:05.783]         if (!identical(...future.workdir, getwd())) 
[13:23:05.783]             setwd(...future.workdir)
[13:23:05.783]         {
[13:23:05.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.783]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.783]             }
[13:23:05.783]             base::options(...future.oldOptions)
[13:23:05.783]             if (.Platform$OS.type == "windows") {
[13:23:05.783]                 old_names <- names(...future.oldEnvVars)
[13:23:05.783]                 envs <- base::Sys.getenv()
[13:23:05.783]                 names <- names(envs)
[13:23:05.783]                 common <- intersect(names, old_names)
[13:23:05.783]                 added <- setdiff(names, old_names)
[13:23:05.783]                 removed <- setdiff(old_names, names)
[13:23:05.783]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.783]                   envs[common]]
[13:23:05.783]                 NAMES <- toupper(changed)
[13:23:05.783]                 args <- list()
[13:23:05.783]                 for (kk in seq_along(NAMES)) {
[13:23:05.783]                   name <- changed[[kk]]
[13:23:05.783]                   NAME <- NAMES[[kk]]
[13:23:05.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.783]                     next
[13:23:05.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.783]                 }
[13:23:05.783]                 NAMES <- toupper(added)
[13:23:05.783]                 for (kk in seq_along(NAMES)) {
[13:23:05.783]                   name <- added[[kk]]
[13:23:05.783]                   NAME <- NAMES[[kk]]
[13:23:05.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.783]                     next
[13:23:05.783]                   args[[name]] <- ""
[13:23:05.783]                 }
[13:23:05.783]                 NAMES <- toupper(removed)
[13:23:05.783]                 for (kk in seq_along(NAMES)) {
[13:23:05.783]                   name <- removed[[kk]]
[13:23:05.783]                   NAME <- NAMES[[kk]]
[13:23:05.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.783]                     next
[13:23:05.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.783]                 }
[13:23:05.783]                 if (length(args) > 0) 
[13:23:05.783]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.783]             }
[13:23:05.783]             else {
[13:23:05.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.783]             }
[13:23:05.783]             {
[13:23:05.783]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.783]                   0L) {
[13:23:05.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.783]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.783]                   base::options(opts)
[13:23:05.783]                 }
[13:23:05.783]                 {
[13:23:05.783]                   {
[13:23:05.783]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:05.783]                     NULL
[13:23:05.783]                   }
[13:23:05.783]                   options(future.plan = NULL)
[13:23:05.783]                   if (is.na(NA_character_)) 
[13:23:05.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.783]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:05.783]                     envir = parent.frame()) 
[13:23:05.783]                   {
[13:23:05.783]                     default_workers <- missing(workers)
[13:23:05.783]                     if (is.function(workers)) 
[13:23:05.783]                       workers <- workers()
[13:23:05.783]                     workers <- structure(as.integer(workers), 
[13:23:05.783]                       class = class(workers))
[13:23:05.783]                     stop_if_not(is.finite(workers), workers >= 
[13:23:05.783]                       1L)
[13:23:05.783]                     if ((workers == 1L && !inherits(workers, 
[13:23:05.783]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:05.783]                       if (default_workers) 
[13:23:05.783]                         supportsMulticore(warn = TRUE)
[13:23:05.783]                       return(sequential(..., envir = envir))
[13:23:05.783]                     }
[13:23:05.783]                     oopts <- options(mc.cores = workers)
[13:23:05.783]                     on.exit(options(oopts))
[13:23:05.783]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:05.783]                       envir = envir)
[13:23:05.783]                     if (!future$lazy) 
[13:23:05.783]                       future <- run(future)
[13:23:05.783]                     invisible(future)
[13:23:05.783]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.783]                 }
[13:23:05.783]             }
[13:23:05.783]         }
[13:23:05.783]     })
[13:23:05.783]     if (TRUE) {
[13:23:05.783]         base::sink(type = "output", split = FALSE)
[13:23:05.783]         if (TRUE) {
[13:23:05.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.783]         }
[13:23:05.783]         else {
[13:23:05.783]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.783]         }
[13:23:05.783]         base::close(...future.stdout)
[13:23:05.783]         ...future.stdout <- NULL
[13:23:05.783]     }
[13:23:05.783]     ...future.result$conditions <- ...future.conditions
[13:23:05.783]     ...future.result$finished <- base::Sys.time()
[13:23:05.783]     ...future.result
[13:23:05.783] }
[13:23:05.787] requestCore(): workers = 2
[13:23:05.793] MulticoreFuture started
[13:23:05.794] - Launch lazy future ... done
[13:23:05.794] run() for ‘MulticoreFuture’ ... done
List of 6
[13:23:05.794] plan(): Setting new future strategy stack:
 $ a:[13:23:05.795] List of future strategies:
[13:23:05.795] 1. sequential:
[13:23:05.795]    - args: function (..., envir = parent.frame())
[13:23:05.795]    - tweaked: FALSE
[13:23:05.795]    - call: NULL
 num 1
 $ b:[13:23:05.796] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5906b80> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d4c0b1e8> 
 $  : NULL
 $  : NULL
 $  :[13:23:05.798] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[13:23:05.798] List of future strategies:
[13:23:05.798] 1. multicore:
[13:23:05.798]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:05.798]    - tweaked: FALSE
[13:23:05.798]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5906b80> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d4c0b1e8> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:23:05.803] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:05.805] resolve() on list ...
[13:23:05.805]  recursive: 0
[13:23:05.805]  length: 6
[13:23:05.805]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:05.805] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.805] - nx: 6
[13:23:05.805] - relay: TRUE
[13:23:05.806] - stdout: TRUE
[13:23:05.806] - signal: TRUE
[13:23:05.806] - resignal: FALSE
[13:23:05.806] - force: TRUE
[13:23:05.806] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.806] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.806]  - until=2
[13:23:05.807]  - relaying element #2
[13:23:05.807] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.807] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.807] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.807]  length: 5 (resolved future 1)
[13:23:05.807] Future #2
[13:23:05.808] result() for MulticoreFuture ...
[13:23:05.810] result() for MulticoreFuture ...
[13:23:05.810] result() for MulticoreFuture ... done
[13:23:05.810] result() for MulticoreFuture ... done
[13:23:05.810] result() for MulticoreFuture ...
[13:23:05.810] result() for MulticoreFuture ... done
[13:23:05.811] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:05.811] - nx: 6
[13:23:05.811] - relay: TRUE
[13:23:05.811] - stdout: TRUE
[13:23:05.811] - signal: TRUE
[13:23:05.811] - resignal: FALSE
[13:23:05.811] - force: TRUE
[13:23:05.812] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.812] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.812]  - until=2
[13:23:05.812]  - relaying element #2
[13:23:05.812] result() for MulticoreFuture ...
[13:23:05.812] result() for MulticoreFuture ... done
[13:23:05.812] result() for MulticoreFuture ...
[13:23:05.813] result() for MulticoreFuture ... done
[13:23:05.813] result() for MulticoreFuture ...
[13:23:05.813] result() for MulticoreFuture ... done
[13:23:05.813] result() for MulticoreFuture ...
[13:23:05.813] result() for MulticoreFuture ... done
[13:23:05.813] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.814] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.814] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:05.814]  length: 4 (resolved future 2)
[13:23:05.814] Future #3
[13:23:05.814] result() for MulticoreFuture ...
[13:23:05.815] result() for MulticoreFuture ...
[13:23:05.815] result() for MulticoreFuture ... done
[13:23:05.815] result() for MulticoreFuture ... done
[13:23:05.815] result() for MulticoreFuture ...
[13:23:05.816] result() for MulticoreFuture ... done
[13:23:05.816] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:05.816] - nx: 6
[13:23:05.816] - relay: TRUE
[13:23:05.816] - stdout: TRUE
[13:23:05.816] - signal: TRUE
[13:23:05.816] - resignal: FALSE
[13:23:05.817] - force: TRUE
[13:23:05.817] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.817] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.817]  - until=3
[13:23:05.817]  - relaying element #3
[13:23:05.817] result() for MulticoreFuture ...
[13:23:05.817] result() for MulticoreFuture ... done
[13:23:05.817] result() for MulticoreFuture ...
[13:23:05.818] result() for MulticoreFuture ... done
[13:23:05.818] result() for MulticoreFuture ...
[13:23:05.818] result() for MulticoreFuture ... done
[13:23:05.818] result() for MulticoreFuture ...
[13:23:05.818] result() for MulticoreFuture ... done
[13:23:05.818] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.818] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.818] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:05.822]  length: 3 (resolved future 3)
[13:23:05.822] signalConditionsASAP(NULL, pos=4) ...
[13:23:05.822] - nx: 6
[13:23:05.822] - relay: TRUE
[13:23:05.822] - stdout: TRUE
[13:23:05.822] - signal: TRUE
[13:23:05.823] - resignal: FALSE
[13:23:05.823] - force: TRUE
[13:23:05.823] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.823] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.823]  - until=5
[13:23:05.823]  - relaying element #5
[13:23:05.823] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.824] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.824] signalConditionsASAP(NULL, pos=4) ... done
[13:23:05.824]  length: 2 (resolved future 4)
[13:23:05.824] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.824] - nx: 6
[13:23:05.824] - relay: TRUE
[13:23:05.824] - stdout: TRUE
[13:23:05.824] - signal: TRUE
[13:23:05.825] - resignal: FALSE
[13:23:05.825] - force: TRUE
[13:23:05.825] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.825] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.825]  - until=6
[13:23:05.825]  - relaying element #6
[13:23:05.825] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.825] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.825] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.826]  length: 1 (resolved future 5)
[13:23:05.826] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.826] - nx: 6
[13:23:05.826] - relay: TRUE
[13:23:05.826] - stdout: TRUE
[13:23:05.826] - signal: TRUE
[13:23:05.826] - resignal: FALSE
[13:23:05.826] - force: TRUE
[13:23:05.827] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.827] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.827]  - until=6
[13:23:05.827] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.827] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.827] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.827]  length: 0 (resolved future 6)
[13:23:05.827] Relaying remaining futures
[13:23:05.828] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.828] - nx: 6
[13:23:05.828] - relay: TRUE
[13:23:05.828] - stdout: TRUE
[13:23:05.828] - signal: TRUE
[13:23:05.828] - resignal: FALSE
[13:23:05.828] - force: TRUE
[13:23:05.828] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.829] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:05.829] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.829] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.829] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.829] resolve() on list ... DONE
[13:23:05.829] result() for MulticoreFuture ...
[13:23:05.829] result() for MulticoreFuture ... done
[13:23:05.829] result() for MulticoreFuture ...
[13:23:05.830] result() for MulticoreFuture ... done
[13:23:05.830] result() for MulticoreFuture ...
[13:23:05.830] result() for MulticoreFuture ... done
[13:23:05.830] result() for MulticoreFuture ...
[13:23:05.830] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[13:23:05.833] getGlobalsAndPackages() ...
[13:23:05.833] Searching for globals...
[13:23:05.833] 
[13:23:05.834] Searching for globals ... DONE
[13:23:05.834] - globals: [0] <none>
[13:23:05.834] getGlobalsAndPackages() ... DONE
[13:23:05.834] run() for ‘Future’ ...
[13:23:05.834] - state: ‘created’
[13:23:05.834] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:05.839] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:05.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:05.839]   - Field: ‘label’
[13:23:05.839]   - Field: ‘local’
[13:23:05.839]   - Field: ‘owner’
[13:23:05.839]   - Field: ‘envir’
[13:23:05.839]   - Field: ‘workers’
[13:23:05.839]   - Field: ‘packages’
[13:23:05.840]   - Field: ‘gc’
[13:23:05.840]   - Field: ‘job’
[13:23:05.840]   - Field: ‘conditions’
[13:23:05.840]   - Field: ‘expr’
[13:23:05.840]   - Field: ‘uuid’
[13:23:05.840]   - Field: ‘seed’
[13:23:05.840]   - Field: ‘version’
[13:23:05.840]   - Field: ‘result’
[13:23:05.840]   - Field: ‘asynchronous’
[13:23:05.840]   - Field: ‘calls’
[13:23:05.841]   - Field: ‘globals’
[13:23:05.841]   - Field: ‘stdout’
[13:23:05.841]   - Field: ‘earlySignal’
[13:23:05.841]   - Field: ‘lazy’
[13:23:05.841]   - Field: ‘state’
[13:23:05.841] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:05.841] - Launch lazy future ...
[13:23:05.841] Packages needed by the future expression (n = 0): <none>
[13:23:05.842] Packages needed by future strategies (n = 0): <none>
[13:23:05.842] {
[13:23:05.842]     {
[13:23:05.842]         {
[13:23:05.842]             ...future.startTime <- base::Sys.time()
[13:23:05.842]             {
[13:23:05.842]                 {
[13:23:05.842]                   {
[13:23:05.842]                     {
[13:23:05.842]                       base::local({
[13:23:05.842]                         has_future <- base::requireNamespace("future", 
[13:23:05.842]                           quietly = TRUE)
[13:23:05.842]                         if (has_future) {
[13:23:05.842]                           ns <- base::getNamespace("future")
[13:23:05.842]                           version <- ns[[".package"]][["version"]]
[13:23:05.842]                           if (is.null(version)) 
[13:23:05.842]                             version <- utils::packageVersion("future")
[13:23:05.842]                         }
[13:23:05.842]                         else {
[13:23:05.842]                           version <- NULL
[13:23:05.842]                         }
[13:23:05.842]                         if (!has_future || version < "1.8.0") {
[13:23:05.842]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.842]                             "", base::R.version$version.string), 
[13:23:05.842]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:05.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.842]                               "release", "version")], collapse = " "), 
[13:23:05.842]                             hostname = base::Sys.info()[["nodename"]])
[13:23:05.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.842]                             info)
[13:23:05.842]                           info <- base::paste(info, collapse = "; ")
[13:23:05.842]                           if (!has_future) {
[13:23:05.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.842]                               info)
[13:23:05.842]                           }
[13:23:05.842]                           else {
[13:23:05.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.842]                               info, version)
[13:23:05.842]                           }
[13:23:05.842]                           base::stop(msg)
[13:23:05.842]                         }
[13:23:05.842]                       })
[13:23:05.842]                     }
[13:23:05.842]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:05.842]                     base::options(mc.cores = 1L)
[13:23:05.842]                   }
[13:23:05.842]                   options(future.plan = NULL)
[13:23:05.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.842]                 }
[13:23:05.842]                 ...future.workdir <- getwd()
[13:23:05.842]             }
[13:23:05.842]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.842]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.842]         }
[13:23:05.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.842]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.842]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.842]             base::names(...future.oldOptions))
[13:23:05.842]     }
[13:23:05.842]     if (FALSE) {
[13:23:05.842]     }
[13:23:05.842]     else {
[13:23:05.842]         if (TRUE) {
[13:23:05.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.842]                 open = "w")
[13:23:05.842]         }
[13:23:05.842]         else {
[13:23:05.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.842]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.842]         }
[13:23:05.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.842]             base::sink(type = "output", split = FALSE)
[13:23:05.842]             base::close(...future.stdout)
[13:23:05.842]         }, add = TRUE)
[13:23:05.842]     }
[13:23:05.842]     ...future.frame <- base::sys.nframe()
[13:23:05.842]     ...future.conditions <- base::list()
[13:23:05.842]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.842]     if (FALSE) {
[13:23:05.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.842]     }
[13:23:05.842]     ...future.result <- base::tryCatch({
[13:23:05.842]         base::withCallingHandlers({
[13:23:05.842]             ...future.value <- base::withVisible(base::local({
[13:23:05.842]                 withCallingHandlers({
[13:23:05.842]                   2
[13:23:05.842]                 }, immediateCondition = function(cond) {
[13:23:05.842]                   save_rds <- function (object, pathname, ...) 
[13:23:05.842]                   {
[13:23:05.842]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:05.842]                     if (file_test("-f", pathname_tmp)) {
[13:23:05.842]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.842]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:05.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.842]                         fi_tmp[["mtime"]])
[13:23:05.842]                     }
[13:23:05.842]                     tryCatch({
[13:23:05.842]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:05.842]                     }, error = function(ex) {
[13:23:05.842]                       msg <- conditionMessage(ex)
[13:23:05.842]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.842]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:05.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.842]                         fi_tmp[["mtime"]], msg)
[13:23:05.842]                       ex$message <- msg
[13:23:05.842]                       stop(ex)
[13:23:05.842]                     })
[13:23:05.842]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:05.842]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:05.842]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:05.842]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.842]                       fi <- file.info(pathname)
[13:23:05.842]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:05.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.842]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:05.842]                         fi[["size"]], fi[["mtime"]])
[13:23:05.842]                       stop(msg)
[13:23:05.842]                     }
[13:23:05.842]                     invisible(pathname)
[13:23:05.842]                   }
[13:23:05.842]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:05.842]                     rootPath = tempdir()) 
[13:23:05.842]                   {
[13:23:05.842]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:05.842]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:05.842]                       tmpdir = path, fileext = ".rds")
[13:23:05.842]                     save_rds(obj, file)
[13:23:05.842]                   }
[13:23:05.842]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:05.842]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.842]                   {
[13:23:05.842]                     inherits <- base::inherits
[13:23:05.842]                     invokeRestart <- base::invokeRestart
[13:23:05.842]                     is.null <- base::is.null
[13:23:05.842]                     muffled <- FALSE
[13:23:05.842]                     if (inherits(cond, "message")) {
[13:23:05.842]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:05.842]                       if (muffled) 
[13:23:05.842]                         invokeRestart("muffleMessage")
[13:23:05.842]                     }
[13:23:05.842]                     else if (inherits(cond, "warning")) {
[13:23:05.842]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:05.842]                       if (muffled) 
[13:23:05.842]                         invokeRestart("muffleWarning")
[13:23:05.842]                     }
[13:23:05.842]                     else if (inherits(cond, "condition")) {
[13:23:05.842]                       if (!is.null(pattern)) {
[13:23:05.842]                         computeRestarts <- base::computeRestarts
[13:23:05.842]                         grepl <- base::grepl
[13:23:05.842]                         restarts <- computeRestarts(cond)
[13:23:05.842]                         for (restart in restarts) {
[13:23:05.842]                           name <- restart$name
[13:23:05.842]                           if (is.null(name)) 
[13:23:05.842]                             next
[13:23:05.842]                           if (!grepl(pattern, name)) 
[13:23:05.842]                             next
[13:23:05.842]                           invokeRestart(restart)
[13:23:05.842]                           muffled <- TRUE
[13:23:05.842]                           break
[13:23:05.842]                         }
[13:23:05.842]                       }
[13:23:05.842]                     }
[13:23:05.842]                     invisible(muffled)
[13:23:05.842]                   }
[13:23:05.842]                   muffleCondition(cond)
[13:23:05.842]                 })
[13:23:05.842]             }))
[13:23:05.842]             future::FutureResult(value = ...future.value$value, 
[13:23:05.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.842]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.842]                     ...future.globalenv.names))
[13:23:05.842]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.842]         }, condition = base::local({
[13:23:05.842]             c <- base::c
[13:23:05.842]             inherits <- base::inherits
[13:23:05.842]             invokeRestart <- base::invokeRestart
[13:23:05.842]             length <- base::length
[13:23:05.842]             list <- base::list
[13:23:05.842]             seq.int <- base::seq.int
[13:23:05.842]             signalCondition <- base::signalCondition
[13:23:05.842]             sys.calls <- base::sys.calls
[13:23:05.842]             `[[` <- base::`[[`
[13:23:05.842]             `+` <- base::`+`
[13:23:05.842]             `<<-` <- base::`<<-`
[13:23:05.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.842]                   3L)]
[13:23:05.842]             }
[13:23:05.842]             function(cond) {
[13:23:05.842]                 is_error <- inherits(cond, "error")
[13:23:05.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.842]                   NULL)
[13:23:05.842]                 if (is_error) {
[13:23:05.842]                   sessionInformation <- function() {
[13:23:05.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.842]                       search = base::search(), system = base::Sys.info())
[13:23:05.842]                   }
[13:23:05.842]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.842]                     cond$call), session = sessionInformation(), 
[13:23:05.842]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.842]                   signalCondition(cond)
[13:23:05.842]                 }
[13:23:05.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.842]                 "immediateCondition"))) {
[13:23:05.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.842]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.842]                   if (TRUE && !signal) {
[13:23:05.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.842]                     {
[13:23:05.842]                       inherits <- base::inherits
[13:23:05.842]                       invokeRestart <- base::invokeRestart
[13:23:05.842]                       is.null <- base::is.null
[13:23:05.842]                       muffled <- FALSE
[13:23:05.842]                       if (inherits(cond, "message")) {
[13:23:05.842]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.842]                         if (muffled) 
[13:23:05.842]                           invokeRestart("muffleMessage")
[13:23:05.842]                       }
[13:23:05.842]                       else if (inherits(cond, "warning")) {
[13:23:05.842]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.842]                         if (muffled) 
[13:23:05.842]                           invokeRestart("muffleWarning")
[13:23:05.842]                       }
[13:23:05.842]                       else if (inherits(cond, "condition")) {
[13:23:05.842]                         if (!is.null(pattern)) {
[13:23:05.842]                           computeRestarts <- base::computeRestarts
[13:23:05.842]                           grepl <- base::grepl
[13:23:05.842]                           restarts <- computeRestarts(cond)
[13:23:05.842]                           for (restart in restarts) {
[13:23:05.842]                             name <- restart$name
[13:23:05.842]                             if (is.null(name)) 
[13:23:05.842]                               next
[13:23:05.842]                             if (!grepl(pattern, name)) 
[13:23:05.842]                               next
[13:23:05.842]                             invokeRestart(restart)
[13:23:05.842]                             muffled <- TRUE
[13:23:05.842]                             break
[13:23:05.842]                           }
[13:23:05.842]                         }
[13:23:05.842]                       }
[13:23:05.842]                       invisible(muffled)
[13:23:05.842]                     }
[13:23:05.842]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.842]                   }
[13:23:05.842]                 }
[13:23:05.842]                 else {
[13:23:05.842]                   if (TRUE) {
[13:23:05.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.842]                     {
[13:23:05.842]                       inherits <- base::inherits
[13:23:05.842]                       invokeRestart <- base::invokeRestart
[13:23:05.842]                       is.null <- base::is.null
[13:23:05.842]                       muffled <- FALSE
[13:23:05.842]                       if (inherits(cond, "message")) {
[13:23:05.842]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.842]                         if (muffled) 
[13:23:05.842]                           invokeRestart("muffleMessage")
[13:23:05.842]                       }
[13:23:05.842]                       else if (inherits(cond, "warning")) {
[13:23:05.842]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.842]                         if (muffled) 
[13:23:05.842]                           invokeRestart("muffleWarning")
[13:23:05.842]                       }
[13:23:05.842]                       else if (inherits(cond, "condition")) {
[13:23:05.842]                         if (!is.null(pattern)) {
[13:23:05.842]                           computeRestarts <- base::computeRestarts
[13:23:05.842]                           grepl <- base::grepl
[13:23:05.842]                           restarts <- computeRestarts(cond)
[13:23:05.842]                           for (restart in restarts) {
[13:23:05.842]                             name <- restart$name
[13:23:05.842]                             if (is.null(name)) 
[13:23:05.842]                               next
[13:23:05.842]                             if (!grepl(pattern, name)) 
[13:23:05.842]                               next
[13:23:05.842]                             invokeRestart(restart)
[13:23:05.842]                             muffled <- TRUE
[13:23:05.842]                             break
[13:23:05.842]                           }
[13:23:05.842]                         }
[13:23:05.842]                       }
[13:23:05.842]                       invisible(muffled)
[13:23:05.842]                     }
[13:23:05.842]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.842]                   }
[13:23:05.842]                 }
[13:23:05.842]             }
[13:23:05.842]         }))
[13:23:05.842]     }, error = function(ex) {
[13:23:05.842]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.842]                 ...future.rng), started = ...future.startTime, 
[13:23:05.842]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.842]             version = "1.8"), class = "FutureResult")
[13:23:05.842]     }, finally = {
[13:23:05.842]         if (!identical(...future.workdir, getwd())) 
[13:23:05.842]             setwd(...future.workdir)
[13:23:05.842]         {
[13:23:05.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.842]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.842]             }
[13:23:05.842]             base::options(...future.oldOptions)
[13:23:05.842]             if (.Platform$OS.type == "windows") {
[13:23:05.842]                 old_names <- names(...future.oldEnvVars)
[13:23:05.842]                 envs <- base::Sys.getenv()
[13:23:05.842]                 names <- names(envs)
[13:23:05.842]                 common <- intersect(names, old_names)
[13:23:05.842]                 added <- setdiff(names, old_names)
[13:23:05.842]                 removed <- setdiff(old_names, names)
[13:23:05.842]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.842]                   envs[common]]
[13:23:05.842]                 NAMES <- toupper(changed)
[13:23:05.842]                 args <- list()
[13:23:05.842]                 for (kk in seq_along(NAMES)) {
[13:23:05.842]                   name <- changed[[kk]]
[13:23:05.842]                   NAME <- NAMES[[kk]]
[13:23:05.842]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.842]                     next
[13:23:05.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.842]                 }
[13:23:05.842]                 NAMES <- toupper(added)
[13:23:05.842]                 for (kk in seq_along(NAMES)) {
[13:23:05.842]                   name <- added[[kk]]
[13:23:05.842]                   NAME <- NAMES[[kk]]
[13:23:05.842]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.842]                     next
[13:23:05.842]                   args[[name]] <- ""
[13:23:05.842]                 }
[13:23:05.842]                 NAMES <- toupper(removed)
[13:23:05.842]                 for (kk in seq_along(NAMES)) {
[13:23:05.842]                   name <- removed[[kk]]
[13:23:05.842]                   NAME <- NAMES[[kk]]
[13:23:05.842]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.842]                     next
[13:23:05.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.842]                 }
[13:23:05.842]                 if (length(args) > 0) 
[13:23:05.842]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.842]             }
[13:23:05.842]             else {
[13:23:05.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.842]             }
[13:23:05.842]             {
[13:23:05.842]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.842]                   0L) {
[13:23:05.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.842]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.842]                   base::options(opts)
[13:23:05.842]                 }
[13:23:05.842]                 {
[13:23:05.842]                   {
[13:23:05.842]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:05.842]                     NULL
[13:23:05.842]                   }
[13:23:05.842]                   options(future.plan = NULL)
[13:23:05.842]                   if (is.na(NA_character_)) 
[13:23:05.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.842]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:05.842]                     envir = parent.frame()) 
[13:23:05.842]                   {
[13:23:05.842]                     default_workers <- missing(workers)
[13:23:05.842]                     if (is.function(workers)) 
[13:23:05.842]                       workers <- workers()
[13:23:05.842]                     workers <- structure(as.integer(workers), 
[13:23:05.842]                       class = class(workers))
[13:23:05.842]                     stop_if_not(is.finite(workers), workers >= 
[13:23:05.842]                       1L)
[13:23:05.842]                     if ((workers == 1L && !inherits(workers, 
[13:23:05.842]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:05.842]                       if (default_workers) 
[13:23:05.842]                         supportsMulticore(warn = TRUE)
[13:23:05.842]                       return(sequential(..., envir = envir))
[13:23:05.842]                     }
[13:23:05.842]                     oopts <- options(mc.cores = workers)
[13:23:05.842]                     on.exit(options(oopts))
[13:23:05.842]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:05.842]                       envir = envir)
[13:23:05.842]                     if (!future$lazy) 
[13:23:05.842]                       future <- run(future)
[13:23:05.842]                     invisible(future)
[13:23:05.842]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.842]                 }
[13:23:05.842]             }
[13:23:05.842]         }
[13:23:05.842]     })
[13:23:05.842]     if (TRUE) {
[13:23:05.842]         base::sink(type = "output", split = FALSE)
[13:23:05.842]         if (TRUE) {
[13:23:05.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.842]         }
[13:23:05.842]         else {
[13:23:05.842]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.842]         }
[13:23:05.842]         base::close(...future.stdout)
[13:23:05.842]         ...future.stdout <- NULL
[13:23:05.842]     }
[13:23:05.842]     ...future.result$conditions <- ...future.conditions
[13:23:05.842]     ...future.result$finished <- base::Sys.time()
[13:23:05.842]     ...future.result
[13:23:05.842] }
[13:23:05.845] requestCore(): workers = 2
[13:23:05.847] MulticoreFuture started
[13:23:05.847] - Launch lazy future ... done
[13:23:05.848] run() for ‘MulticoreFuture’ ... done
[13:23:05.848] getGlobalsAndPackages() ...
[13:23:05.848] Searching for globals...
[13:23:05.848] plan(): Setting new future strategy stack:
[13:23:05.849] 
[13:23:05.849] Searching for globals ... DONE
[13:23:05.849] List of future strategies:
[13:23:05.849] 1. sequential:
[13:23:05.849]    - args: function (..., envir = parent.frame())
[13:23:05.849]    - tweaked: FALSE
[13:23:05.849]    - call: NULL
[13:23:05.850] - globals: [0] <none>
[13:23:05.850] plan(): nbrOfWorkers() = 1
[13:23:05.850] getGlobalsAndPackages() ... DONE
[13:23:05.850] run() for ‘Future’ ...
[13:23:05.850] - state: ‘created’
[13:23:05.851] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:05.852] plan(): Setting new future strategy stack:
[13:23:05.852] List of future strategies:
[13:23:05.852] 1. multicore:
[13:23:05.852]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:05.852]    - tweaked: FALSE
[13:23:05.852]    - call: plan(strategy)
[13:23:05.857] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:05.857] plan(): nbrOfWorkers() = 2
[13:23:05.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:05.857]   - Field: ‘label’
[13:23:05.857]   - Field: ‘local’
[13:23:05.858]   - Field: ‘owner’
[13:23:05.858]   - Field: ‘envir’
[13:23:05.858]   - Field: ‘workers’
[13:23:05.858]   - Field: ‘packages’
[13:23:05.858]   - Field: ‘gc’
[13:23:05.858]   - Field: ‘job’
[13:23:05.859]   - Field: ‘conditions’
[13:23:05.859]   - Field: ‘expr’
[13:23:05.859]   - Field: ‘uuid’
[13:23:05.859]   - Field: ‘seed’
[13:23:05.859]   - Field: ‘version’
[13:23:05.859]   - Field: ‘result’
[13:23:05.860]   - Field: ‘asynchronous’
[13:23:05.860]   - Field: ‘calls’
[13:23:05.860]   - Field: ‘globals’
[13:23:05.860]   - Field: ‘stdout’
[13:23:05.860]   - Field: ‘earlySignal’
[13:23:05.860]   - Field: ‘lazy’
[13:23:05.860]   - Field: ‘state’
[13:23:05.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:05.861] - Launch lazy future ...
[13:23:05.861] Packages needed by the future expression (n = 0): <none>
[13:23:05.862] Packages needed by future strategies (n = 0): <none>
[13:23:05.862] {
[13:23:05.862]     {
[13:23:05.862]         {
[13:23:05.862]             ...future.startTime <- base::Sys.time()
[13:23:05.862]             {
[13:23:05.862]                 {
[13:23:05.862]                   {
[13:23:05.862]                     {
[13:23:05.862]                       base::local({
[13:23:05.862]                         has_future <- base::requireNamespace("future", 
[13:23:05.862]                           quietly = TRUE)
[13:23:05.862]                         if (has_future) {
[13:23:05.862]                           ns <- base::getNamespace("future")
[13:23:05.862]                           version <- ns[[".package"]][["version"]]
[13:23:05.862]                           if (is.null(version)) 
[13:23:05.862]                             version <- utils::packageVersion("future")
[13:23:05.862]                         }
[13:23:05.862]                         else {
[13:23:05.862]                           version <- NULL
[13:23:05.862]                         }
[13:23:05.862]                         if (!has_future || version < "1.8.0") {
[13:23:05.862]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.862]                             "", base::R.version$version.string), 
[13:23:05.862]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:05.862]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.862]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.862]                               "release", "version")], collapse = " "), 
[13:23:05.862]                             hostname = base::Sys.info()[["nodename"]])
[13:23:05.862]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.862]                             info)
[13:23:05.862]                           info <- base::paste(info, collapse = "; ")
[13:23:05.862]                           if (!has_future) {
[13:23:05.862]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.862]                               info)
[13:23:05.862]                           }
[13:23:05.862]                           else {
[13:23:05.862]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.862]                               info, version)
[13:23:05.862]                           }
[13:23:05.862]                           base::stop(msg)
[13:23:05.862]                         }
[13:23:05.862]                       })
[13:23:05.862]                     }
[13:23:05.862]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:05.862]                     base::options(mc.cores = 1L)
[13:23:05.862]                   }
[13:23:05.862]                   options(future.plan = NULL)
[13:23:05.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.862]                 }
[13:23:05.862]                 ...future.workdir <- getwd()
[13:23:05.862]             }
[13:23:05.862]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.862]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.862]         }
[13:23:05.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.862]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.862]             base::names(...future.oldOptions))
[13:23:05.862]     }
[13:23:05.862]     if (FALSE) {
[13:23:05.862]     }
[13:23:05.862]     else {
[13:23:05.862]         if (TRUE) {
[13:23:05.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.862]                 open = "w")
[13:23:05.862]         }
[13:23:05.862]         else {
[13:23:05.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.862]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.862]         }
[13:23:05.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.862]             base::sink(type = "output", split = FALSE)
[13:23:05.862]             base::close(...future.stdout)
[13:23:05.862]         }, add = TRUE)
[13:23:05.862]     }
[13:23:05.862]     ...future.frame <- base::sys.nframe()
[13:23:05.862]     ...future.conditions <- base::list()
[13:23:05.862]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.862]     if (FALSE) {
[13:23:05.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.862]     }
[13:23:05.862]     ...future.result <- base::tryCatch({
[13:23:05.862]         base::withCallingHandlers({
[13:23:05.862]             ...future.value <- base::withVisible(base::local({
[13:23:05.862]                 withCallingHandlers({
[13:23:05.862]                   NULL
[13:23:05.862]                 }, immediateCondition = function(cond) {
[13:23:05.862]                   save_rds <- function (object, pathname, ...) 
[13:23:05.862]                   {
[13:23:05.862]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:05.862]                     if (file_test("-f", pathname_tmp)) {
[13:23:05.862]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.862]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:05.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.862]                         fi_tmp[["mtime"]])
[13:23:05.862]                     }
[13:23:05.862]                     tryCatch({
[13:23:05.862]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:05.862]                     }, error = function(ex) {
[13:23:05.862]                       msg <- conditionMessage(ex)
[13:23:05.862]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.862]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:05.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.862]                         fi_tmp[["mtime"]], msg)
[13:23:05.862]                       ex$message <- msg
[13:23:05.862]                       stop(ex)
[13:23:05.862]                     })
[13:23:05.862]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:05.862]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:05.862]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:05.862]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.862]                       fi <- file.info(pathname)
[13:23:05.862]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:05.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.862]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:05.862]                         fi[["size"]], fi[["mtime"]])
[13:23:05.862]                       stop(msg)
[13:23:05.862]                     }
[13:23:05.862]                     invisible(pathname)
[13:23:05.862]                   }
[13:23:05.862]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:05.862]                     rootPath = tempdir()) 
[13:23:05.862]                   {
[13:23:05.862]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:05.862]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:05.862]                       tmpdir = path, fileext = ".rds")
[13:23:05.862]                     save_rds(obj, file)
[13:23:05.862]                   }
[13:23:05.862]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:05.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.862]                   {
[13:23:05.862]                     inherits <- base::inherits
[13:23:05.862]                     invokeRestart <- base::invokeRestart
[13:23:05.862]                     is.null <- base::is.null
[13:23:05.862]                     muffled <- FALSE
[13:23:05.862]                     if (inherits(cond, "message")) {
[13:23:05.862]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:05.862]                       if (muffled) 
[13:23:05.862]                         invokeRestart("muffleMessage")
[13:23:05.862]                     }
[13:23:05.862]                     else if (inherits(cond, "warning")) {
[13:23:05.862]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:05.862]                       if (muffled) 
[13:23:05.862]                         invokeRestart("muffleWarning")
[13:23:05.862]                     }
[13:23:05.862]                     else if (inherits(cond, "condition")) {
[13:23:05.862]                       if (!is.null(pattern)) {
[13:23:05.862]                         computeRestarts <- base::computeRestarts
[13:23:05.862]                         grepl <- base::grepl
[13:23:05.862]                         restarts <- computeRestarts(cond)
[13:23:05.862]                         for (restart in restarts) {
[13:23:05.862]                           name <- restart$name
[13:23:05.862]                           if (is.null(name)) 
[13:23:05.862]                             next
[13:23:05.862]                           if (!grepl(pattern, name)) 
[13:23:05.862]                             next
[13:23:05.862]                           invokeRestart(restart)
[13:23:05.862]                           muffled <- TRUE
[13:23:05.862]                           break
[13:23:05.862]                         }
[13:23:05.862]                       }
[13:23:05.862]                     }
[13:23:05.862]                     invisible(muffled)
[13:23:05.862]                   }
[13:23:05.862]                   muffleCondition(cond)
[13:23:05.862]                 })
[13:23:05.862]             }))
[13:23:05.862]             future::FutureResult(value = ...future.value$value, 
[13:23:05.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.862]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.862]                     ...future.globalenv.names))
[13:23:05.862]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.862]         }, condition = base::local({
[13:23:05.862]             c <- base::c
[13:23:05.862]             inherits <- base::inherits
[13:23:05.862]             invokeRestart <- base::invokeRestart
[13:23:05.862]             length <- base::length
[13:23:05.862]             list <- base::list
[13:23:05.862]             seq.int <- base::seq.int
[13:23:05.862]             signalCondition <- base::signalCondition
[13:23:05.862]             sys.calls <- base::sys.calls
[13:23:05.862]             `[[` <- base::`[[`
[13:23:05.862]             `+` <- base::`+`
[13:23:05.862]             `<<-` <- base::`<<-`
[13:23:05.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.862]                   3L)]
[13:23:05.862]             }
[13:23:05.862]             function(cond) {
[13:23:05.862]                 is_error <- inherits(cond, "error")
[13:23:05.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.862]                   NULL)
[13:23:05.862]                 if (is_error) {
[13:23:05.862]                   sessionInformation <- function() {
[13:23:05.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.862]                       search = base::search(), system = base::Sys.info())
[13:23:05.862]                   }
[13:23:05.862]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.862]                     cond$call), session = sessionInformation(), 
[13:23:05.862]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.862]                   signalCondition(cond)
[13:23:05.862]                 }
[13:23:05.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.862]                 "immediateCondition"))) {
[13:23:05.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.862]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.862]                   if (TRUE && !signal) {
[13:23:05.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.862]                     {
[13:23:05.862]                       inherits <- base::inherits
[13:23:05.862]                       invokeRestart <- base::invokeRestart
[13:23:05.862]                       is.null <- base::is.null
[13:23:05.862]                       muffled <- FALSE
[13:23:05.862]                       if (inherits(cond, "message")) {
[13:23:05.862]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.862]                         if (muffled) 
[13:23:05.862]                           invokeRestart("muffleMessage")
[13:23:05.862]                       }
[13:23:05.862]                       else if (inherits(cond, "warning")) {
[13:23:05.862]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.862]                         if (muffled) 
[13:23:05.862]                           invokeRestart("muffleWarning")
[13:23:05.862]                       }
[13:23:05.862]                       else if (inherits(cond, "condition")) {
[13:23:05.862]                         if (!is.null(pattern)) {
[13:23:05.862]                           computeRestarts <- base::computeRestarts
[13:23:05.862]                           grepl <- base::grepl
[13:23:05.862]                           restarts <- computeRestarts(cond)
[13:23:05.862]                           for (restart in restarts) {
[13:23:05.862]                             name <- restart$name
[13:23:05.862]                             if (is.null(name)) 
[13:23:05.862]                               next
[13:23:05.862]                             if (!grepl(pattern, name)) 
[13:23:05.862]                               next
[13:23:05.862]                             invokeRestart(restart)
[13:23:05.862]                             muffled <- TRUE
[13:23:05.862]                             break
[13:23:05.862]                           }
[13:23:05.862]                         }
[13:23:05.862]                       }
[13:23:05.862]                       invisible(muffled)
[13:23:05.862]                     }
[13:23:05.862]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.862]                   }
[13:23:05.862]                 }
[13:23:05.862]                 else {
[13:23:05.862]                   if (TRUE) {
[13:23:05.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.862]                     {
[13:23:05.862]                       inherits <- base::inherits
[13:23:05.862]                       invokeRestart <- base::invokeRestart
[13:23:05.862]                       is.null <- base::is.null
[13:23:05.862]                       muffled <- FALSE
[13:23:05.862]                       if (inherits(cond, "message")) {
[13:23:05.862]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.862]                         if (muffled) 
[13:23:05.862]                           invokeRestart("muffleMessage")
[13:23:05.862]                       }
[13:23:05.862]                       else if (inherits(cond, "warning")) {
[13:23:05.862]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.862]                         if (muffled) 
[13:23:05.862]                           invokeRestart("muffleWarning")
[13:23:05.862]                       }
[13:23:05.862]                       else if (inherits(cond, "condition")) {
[13:23:05.862]                         if (!is.null(pattern)) {
[13:23:05.862]                           computeRestarts <- base::computeRestarts
[13:23:05.862]                           grepl <- base::grepl
[13:23:05.862]                           restarts <- computeRestarts(cond)
[13:23:05.862]                           for (restart in restarts) {
[13:23:05.862]                             name <- restart$name
[13:23:05.862]                             if (is.null(name)) 
[13:23:05.862]                               next
[13:23:05.862]                             if (!grepl(pattern, name)) 
[13:23:05.862]                               next
[13:23:05.862]                             invokeRestart(restart)
[13:23:05.862]                             muffled <- TRUE
[13:23:05.862]                             break
[13:23:05.862]                           }
[13:23:05.862]                         }
[13:23:05.862]                       }
[13:23:05.862]                       invisible(muffled)
[13:23:05.862]                     }
[13:23:05.862]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.862]                   }
[13:23:05.862]                 }
[13:23:05.862]             }
[13:23:05.862]         }))
[13:23:05.862]     }, error = function(ex) {
[13:23:05.862]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.862]                 ...future.rng), started = ...future.startTime, 
[13:23:05.862]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.862]             version = "1.8"), class = "FutureResult")
[13:23:05.862]     }, finally = {
[13:23:05.862]         if (!identical(...future.workdir, getwd())) 
[13:23:05.862]             setwd(...future.workdir)
[13:23:05.862]         {
[13:23:05.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.862]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.862]             }
[13:23:05.862]             base::options(...future.oldOptions)
[13:23:05.862]             if (.Platform$OS.type == "windows") {
[13:23:05.862]                 old_names <- names(...future.oldEnvVars)
[13:23:05.862]                 envs <- base::Sys.getenv()
[13:23:05.862]                 names <- names(envs)
[13:23:05.862]                 common <- intersect(names, old_names)
[13:23:05.862]                 added <- setdiff(names, old_names)
[13:23:05.862]                 removed <- setdiff(old_names, names)
[13:23:05.862]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.862]                   envs[common]]
[13:23:05.862]                 NAMES <- toupper(changed)
[13:23:05.862]                 args <- list()
[13:23:05.862]                 for (kk in seq_along(NAMES)) {
[13:23:05.862]                   name <- changed[[kk]]
[13:23:05.862]                   NAME <- NAMES[[kk]]
[13:23:05.862]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.862]                     next
[13:23:05.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.862]                 }
[13:23:05.862]                 NAMES <- toupper(added)
[13:23:05.862]                 for (kk in seq_along(NAMES)) {
[13:23:05.862]                   name <- added[[kk]]
[13:23:05.862]                   NAME <- NAMES[[kk]]
[13:23:05.862]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.862]                     next
[13:23:05.862]                   args[[name]] <- ""
[13:23:05.862]                 }
[13:23:05.862]                 NAMES <- toupper(removed)
[13:23:05.862]                 for (kk in seq_along(NAMES)) {
[13:23:05.862]                   name <- removed[[kk]]
[13:23:05.862]                   NAME <- NAMES[[kk]]
[13:23:05.862]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.862]                     next
[13:23:05.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.862]                 }
[13:23:05.862]                 if (length(args) > 0) 
[13:23:05.862]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.862]             }
[13:23:05.862]             else {
[13:23:05.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.862]             }
[13:23:05.862]             {
[13:23:05.862]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.862]                   0L) {
[13:23:05.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.862]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.862]                   base::options(opts)
[13:23:05.862]                 }
[13:23:05.862]                 {
[13:23:05.862]                   {
[13:23:05.862]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:05.862]                     NULL
[13:23:05.862]                   }
[13:23:05.862]                   options(future.plan = NULL)
[13:23:05.862]                   if (is.na(NA_character_)) 
[13:23:05.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.862]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:05.862]                     envir = parent.frame()) 
[13:23:05.862]                   {
[13:23:05.862]                     default_workers <- missing(workers)
[13:23:05.862]                     if (is.function(workers)) 
[13:23:05.862]                       workers <- workers()
[13:23:05.862]                     workers <- structure(as.integer(workers), 
[13:23:05.862]                       class = class(workers))
[13:23:05.862]                     stop_if_not(is.finite(workers), workers >= 
[13:23:05.862]                       1L)
[13:23:05.862]                     if ((workers == 1L && !inherits(workers, 
[13:23:05.862]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:05.862]                       if (default_workers) 
[13:23:05.862]                         supportsMulticore(warn = TRUE)
[13:23:05.862]                       return(sequential(..., envir = envir))
[13:23:05.862]                     }
[13:23:05.862]                     oopts <- options(mc.cores = workers)
[13:23:05.862]                     on.exit(options(oopts))
[13:23:05.862]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:05.862]                       envir = envir)
[13:23:05.862]                     if (!future$lazy) 
[13:23:05.862]                       future <- run(future)
[13:23:05.862]                     invisible(future)
[13:23:05.862]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.862]                 }
[13:23:05.862]             }
[13:23:05.862]         }
[13:23:05.862]     })
[13:23:05.862]     if (TRUE) {
[13:23:05.862]         base::sink(type = "output", split = FALSE)
[13:23:05.862]         if (TRUE) {
[13:23:05.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.862]         }
[13:23:05.862]         else {
[13:23:05.862]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.862]         }
[13:23:05.862]         base::close(...future.stdout)
[13:23:05.862]         ...future.stdout <- NULL
[13:23:05.862]     }
[13:23:05.862]     ...future.result$conditions <- ...future.conditions
[13:23:05.862]     ...future.result$finished <- base::Sys.time()
[13:23:05.862]     ...future.result
[13:23:05.862] }
[13:23:05.866] requestCore(): workers = 2
[13:23:05.869] MulticoreFuture started
[13:23:05.869] - Launch lazy future ... done
[13:23:05.870] run() for ‘MulticoreFuture’ ... done
List of 6
[13:23:05.870] plan(): Setting new future strategy stack:
 $ a:[13:23:05.870] List of future strategies:
[13:23:05.870] 1. sequential:
[13:23:05.870]    - args: function (..., envir = parent.frame())
[13:23:05.870]    - tweaked: FALSE
[13:23:05.870]    - call: NULL
 num 1
 $ b:[13:23:05.871] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d50f7498> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d561a8d0> 
 $  : NULL
 $  : NULL
 $  :[13:23:05.874] plan(): Setting new future strategy stack:
[13:23:05.874] List of future strategies:
[13:23:05.874] 1. multicore:
[13:23:05.874]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:05.874]    - tweaked: FALSE
[13:23:05.874]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d50f7498> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d561a8d0> 
 $  : NULL
 $  : NULL
 $  :[13:23:05.883] plan(): nbrOfWorkers() = 2
 num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:05.890] resolve() on list ...
[13:23:05.890]  recursive: 0
[13:23:05.890]  length: 6
[13:23:05.890]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:05.891] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.891] - nx: 6
[13:23:05.891] - relay: TRUE
[13:23:05.891] - stdout: TRUE
[13:23:05.891] - signal: TRUE
[13:23:05.891] - resignal: FALSE
[13:23:05.891] - force: TRUE
[13:23:05.892] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.892] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.892]  - until=2
[13:23:05.892]  - relaying element #2
[13:23:05.892] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.892] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.892] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.893]  length: 5 (resolved future 1)
[13:23:05.893] Future #2
[13:23:05.893] result() for MulticoreFuture ...
[13:23:05.894] result() for MulticoreFuture ...
[13:23:05.894] result() for MulticoreFuture ... done
[13:23:05.894] result() for MulticoreFuture ... done
[13:23:05.894] result() for MulticoreFuture ...
[13:23:05.895] result() for MulticoreFuture ... done
[13:23:05.895] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:05.895] - nx: 6
[13:23:05.895] - relay: TRUE
[13:23:05.895] - stdout: TRUE
[13:23:05.895] - signal: TRUE
[13:23:05.895] - resignal: FALSE
[13:23:05.896] - force: TRUE
[13:23:05.896] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.896] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.896]  - until=2
[13:23:05.896]  - relaying element #2
[13:23:05.896] result() for MulticoreFuture ...
[13:23:05.896] result() for MulticoreFuture ... done
[13:23:05.897] result() for MulticoreFuture ...
[13:23:05.897] result() for MulticoreFuture ... done
[13:23:05.897] result() for MulticoreFuture ...
[13:23:05.897] result() for MulticoreFuture ... done
[13:23:05.897] result() for MulticoreFuture ...
[13:23:05.897] result() for MulticoreFuture ... done
[13:23:05.897] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.898] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.898] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:05.898]  length: 4 (resolved future 2)
[13:23:05.898] Future #3
[13:23:05.898] result() for MulticoreFuture ...
[13:23:05.899] result() for MulticoreFuture ...
[13:23:05.899] result() for MulticoreFuture ... done
[13:23:05.899] result() for MulticoreFuture ... done
[13:23:05.899] result() for MulticoreFuture ...
[13:23:05.900] result() for MulticoreFuture ... done
[13:23:05.900] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:05.900] - nx: 6
[13:23:05.900] - relay: TRUE
[13:23:05.900] - stdout: TRUE
[13:23:05.900] - signal: TRUE
[13:23:05.900] - resignal: FALSE
[13:23:05.900] - force: TRUE
[13:23:05.901] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.901] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.901]  - until=3
[13:23:05.901]  - relaying element #3
[13:23:05.901] result() for MulticoreFuture ...
[13:23:05.901] result() for MulticoreFuture ... done
[13:23:05.901] result() for MulticoreFuture ...
[13:23:05.901] result() for MulticoreFuture ... done
[13:23:05.901] result() for MulticoreFuture ...
[13:23:05.902] result() for MulticoreFuture ... done
[13:23:05.902] result() for MulticoreFuture ...
[13:23:05.902] result() for MulticoreFuture ... done
[13:23:05.902] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.902] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.902] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:05.902]  length: 3 (resolved future 3)
[13:23:05.902] signalConditionsASAP(NULL, pos=4) ...
[13:23:05.902] - nx: 6
[13:23:05.903] - relay: TRUE
[13:23:05.903] - stdout: TRUE
[13:23:05.903] - signal: TRUE
[13:23:05.903] - resignal: FALSE
[13:23:05.903] - force: TRUE
[13:23:05.903] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.903] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.903]  - until=5
[13:23:05.903]  - relaying element #5
[13:23:05.903] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.904] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.904] signalConditionsASAP(NULL, pos=4) ... done
[13:23:05.904]  length: 2 (resolved future 4)
[13:23:05.904] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.904] - nx: 6
[13:23:05.904] - relay: TRUE
[13:23:05.904] - stdout: TRUE
[13:23:05.904] - signal: TRUE
[13:23:05.904] - resignal: FALSE
[13:23:05.905] - force: TRUE
[13:23:05.905] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.905] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.905]  - until=6
[13:23:05.905]  - relaying element #6
[13:23:05.905] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.905] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.905] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.905]  length: 1 (resolved future 5)
[13:23:05.905] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.906] - nx: 6
[13:23:05.906] - relay: TRUE
[13:23:05.906] - stdout: TRUE
[13:23:05.906] - signal: TRUE
[13:23:05.906] - resignal: FALSE
[13:23:05.906] - force: TRUE
[13:23:05.906] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.906] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.906]  - until=6
[13:23:05.906] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.906] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.907] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.907]  length: 0 (resolved future 6)
[13:23:05.907] Relaying remaining futures
[13:23:05.907] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.907] - nx: 6
[13:23:05.907] - relay: TRUE
[13:23:05.907] - stdout: TRUE
[13:23:05.907] - signal: TRUE
[13:23:05.907] - resignal: FALSE
[13:23:05.907] - force: TRUE
[13:23:05.908] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.908] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:05.908] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.908] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.908] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.908] resolve() on list ... DONE
[13:23:05.908] result() for MulticoreFuture ...
[13:23:05.908] result() for MulticoreFuture ... done
[13:23:05.909] result() for MulticoreFuture ...
[13:23:05.909] result() for MulticoreFuture ... done
[13:23:05.909] result() for MulticoreFuture ...
[13:23:05.909] result() for MulticoreFuture ... done
[13:23:05.909] result() for MulticoreFuture ...
[13:23:05.909] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:23:05.913] getGlobalsAndPackages() ...
[13:23:05.913] Searching for globals...
[13:23:05.915] 
[13:23:05.916] Searching for globals ... DONE
[13:23:05.916] - globals: [0] <none>
[13:23:05.916] getGlobalsAndPackages() ... DONE
[13:23:05.916] run() for ‘Future’ ...
[13:23:05.916] - state: ‘created’
[13:23:05.917] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:05.922] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:05.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:05.922]   - Field: ‘label’
[13:23:05.922]   - Field: ‘local’
[13:23:05.922]   - Field: ‘owner’
[13:23:05.922]   - Field: ‘envir’
[13:23:05.922]   - Field: ‘workers’
[13:23:05.922]   - Field: ‘packages’
[13:23:05.923]   - Field: ‘gc’
[13:23:05.923]   - Field: ‘job’
[13:23:05.923]   - Field: ‘conditions’
[13:23:05.923]   - Field: ‘expr’
[13:23:05.923]   - Field: ‘uuid’
[13:23:05.923]   - Field: ‘seed’
[13:23:05.923]   - Field: ‘version’
[13:23:05.923]   - Field: ‘result’
[13:23:05.923]   - Field: ‘asynchronous’
[13:23:05.923]   - Field: ‘calls’
[13:23:05.923]   - Field: ‘globals’
[13:23:05.924]   - Field: ‘stdout’
[13:23:05.924]   - Field: ‘earlySignal’
[13:23:05.924]   - Field: ‘lazy’
[13:23:05.924]   - Field: ‘state’
[13:23:05.924] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:05.924] - Launch lazy future ...
[13:23:05.924] Packages needed by the future expression (n = 0): <none>
[13:23:05.925] Packages needed by future strategies (n = 0): <none>
[13:23:05.925] {
[13:23:05.925]     {
[13:23:05.925]         {
[13:23:05.925]             ...future.startTime <- base::Sys.time()
[13:23:05.925]             {
[13:23:05.925]                 {
[13:23:05.925]                   {
[13:23:05.925]                     {
[13:23:05.925]                       base::local({
[13:23:05.925]                         has_future <- base::requireNamespace("future", 
[13:23:05.925]                           quietly = TRUE)
[13:23:05.925]                         if (has_future) {
[13:23:05.925]                           ns <- base::getNamespace("future")
[13:23:05.925]                           version <- ns[[".package"]][["version"]]
[13:23:05.925]                           if (is.null(version)) 
[13:23:05.925]                             version <- utils::packageVersion("future")
[13:23:05.925]                         }
[13:23:05.925]                         else {
[13:23:05.925]                           version <- NULL
[13:23:05.925]                         }
[13:23:05.925]                         if (!has_future || version < "1.8.0") {
[13:23:05.925]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.925]                             "", base::R.version$version.string), 
[13:23:05.925]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:05.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.925]                               "release", "version")], collapse = " "), 
[13:23:05.925]                             hostname = base::Sys.info()[["nodename"]])
[13:23:05.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.925]                             info)
[13:23:05.925]                           info <- base::paste(info, collapse = "; ")
[13:23:05.925]                           if (!has_future) {
[13:23:05.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.925]                               info)
[13:23:05.925]                           }
[13:23:05.925]                           else {
[13:23:05.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.925]                               info, version)
[13:23:05.925]                           }
[13:23:05.925]                           base::stop(msg)
[13:23:05.925]                         }
[13:23:05.925]                       })
[13:23:05.925]                     }
[13:23:05.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:05.925]                     base::options(mc.cores = 1L)
[13:23:05.925]                   }
[13:23:05.925]                   options(future.plan = NULL)
[13:23:05.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.925]                 }
[13:23:05.925]                 ...future.workdir <- getwd()
[13:23:05.925]             }
[13:23:05.925]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.925]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.925]         }
[13:23:05.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.925]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.925]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.925]             base::names(...future.oldOptions))
[13:23:05.925]     }
[13:23:05.925]     if (FALSE) {
[13:23:05.925]     }
[13:23:05.925]     else {
[13:23:05.925]         if (TRUE) {
[13:23:05.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.925]                 open = "w")
[13:23:05.925]         }
[13:23:05.925]         else {
[13:23:05.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.925]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.925]         }
[13:23:05.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.925]             base::sink(type = "output", split = FALSE)
[13:23:05.925]             base::close(...future.stdout)
[13:23:05.925]         }, add = TRUE)
[13:23:05.925]     }
[13:23:05.925]     ...future.frame <- base::sys.nframe()
[13:23:05.925]     ...future.conditions <- base::list()
[13:23:05.925]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.925]     if (FALSE) {
[13:23:05.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.925]     }
[13:23:05.925]     ...future.result <- base::tryCatch({
[13:23:05.925]         base::withCallingHandlers({
[13:23:05.925]             ...future.value <- base::withVisible(base::local({
[13:23:05.925]                 withCallingHandlers({
[13:23:05.925]                   2
[13:23:05.925]                 }, immediateCondition = function(cond) {
[13:23:05.925]                   save_rds <- function (object, pathname, ...) 
[13:23:05.925]                   {
[13:23:05.925]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:05.925]                     if (file_test("-f", pathname_tmp)) {
[13:23:05.925]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.925]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:05.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.925]                         fi_tmp[["mtime"]])
[13:23:05.925]                     }
[13:23:05.925]                     tryCatch({
[13:23:05.925]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:05.925]                     }, error = function(ex) {
[13:23:05.925]                       msg <- conditionMessage(ex)
[13:23:05.925]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.925]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:05.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.925]                         fi_tmp[["mtime"]], msg)
[13:23:05.925]                       ex$message <- msg
[13:23:05.925]                       stop(ex)
[13:23:05.925]                     })
[13:23:05.925]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:05.925]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:05.925]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:05.925]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.925]                       fi <- file.info(pathname)
[13:23:05.925]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:05.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.925]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:05.925]                         fi[["size"]], fi[["mtime"]])
[13:23:05.925]                       stop(msg)
[13:23:05.925]                     }
[13:23:05.925]                     invisible(pathname)
[13:23:05.925]                   }
[13:23:05.925]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:05.925]                     rootPath = tempdir()) 
[13:23:05.925]                   {
[13:23:05.925]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:05.925]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:05.925]                       tmpdir = path, fileext = ".rds")
[13:23:05.925]                     save_rds(obj, file)
[13:23:05.925]                   }
[13:23:05.925]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:05.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.925]                   {
[13:23:05.925]                     inherits <- base::inherits
[13:23:05.925]                     invokeRestart <- base::invokeRestart
[13:23:05.925]                     is.null <- base::is.null
[13:23:05.925]                     muffled <- FALSE
[13:23:05.925]                     if (inherits(cond, "message")) {
[13:23:05.925]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:05.925]                       if (muffled) 
[13:23:05.925]                         invokeRestart("muffleMessage")
[13:23:05.925]                     }
[13:23:05.925]                     else if (inherits(cond, "warning")) {
[13:23:05.925]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:05.925]                       if (muffled) 
[13:23:05.925]                         invokeRestart("muffleWarning")
[13:23:05.925]                     }
[13:23:05.925]                     else if (inherits(cond, "condition")) {
[13:23:05.925]                       if (!is.null(pattern)) {
[13:23:05.925]                         computeRestarts <- base::computeRestarts
[13:23:05.925]                         grepl <- base::grepl
[13:23:05.925]                         restarts <- computeRestarts(cond)
[13:23:05.925]                         for (restart in restarts) {
[13:23:05.925]                           name <- restart$name
[13:23:05.925]                           if (is.null(name)) 
[13:23:05.925]                             next
[13:23:05.925]                           if (!grepl(pattern, name)) 
[13:23:05.925]                             next
[13:23:05.925]                           invokeRestart(restart)
[13:23:05.925]                           muffled <- TRUE
[13:23:05.925]                           break
[13:23:05.925]                         }
[13:23:05.925]                       }
[13:23:05.925]                     }
[13:23:05.925]                     invisible(muffled)
[13:23:05.925]                   }
[13:23:05.925]                   muffleCondition(cond)
[13:23:05.925]                 })
[13:23:05.925]             }))
[13:23:05.925]             future::FutureResult(value = ...future.value$value, 
[13:23:05.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.925]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.925]                     ...future.globalenv.names))
[13:23:05.925]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.925]         }, condition = base::local({
[13:23:05.925]             c <- base::c
[13:23:05.925]             inherits <- base::inherits
[13:23:05.925]             invokeRestart <- base::invokeRestart
[13:23:05.925]             length <- base::length
[13:23:05.925]             list <- base::list
[13:23:05.925]             seq.int <- base::seq.int
[13:23:05.925]             signalCondition <- base::signalCondition
[13:23:05.925]             sys.calls <- base::sys.calls
[13:23:05.925]             `[[` <- base::`[[`
[13:23:05.925]             `+` <- base::`+`
[13:23:05.925]             `<<-` <- base::`<<-`
[13:23:05.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.925]                   3L)]
[13:23:05.925]             }
[13:23:05.925]             function(cond) {
[13:23:05.925]                 is_error <- inherits(cond, "error")
[13:23:05.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.925]                   NULL)
[13:23:05.925]                 if (is_error) {
[13:23:05.925]                   sessionInformation <- function() {
[13:23:05.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.925]                       search = base::search(), system = base::Sys.info())
[13:23:05.925]                   }
[13:23:05.925]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.925]                     cond$call), session = sessionInformation(), 
[13:23:05.925]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.925]                   signalCondition(cond)
[13:23:05.925]                 }
[13:23:05.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.925]                 "immediateCondition"))) {
[13:23:05.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.925]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.925]                   if (TRUE && !signal) {
[13:23:05.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.925]                     {
[13:23:05.925]                       inherits <- base::inherits
[13:23:05.925]                       invokeRestart <- base::invokeRestart
[13:23:05.925]                       is.null <- base::is.null
[13:23:05.925]                       muffled <- FALSE
[13:23:05.925]                       if (inherits(cond, "message")) {
[13:23:05.925]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.925]                         if (muffled) 
[13:23:05.925]                           invokeRestart("muffleMessage")
[13:23:05.925]                       }
[13:23:05.925]                       else if (inherits(cond, "warning")) {
[13:23:05.925]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.925]                         if (muffled) 
[13:23:05.925]                           invokeRestart("muffleWarning")
[13:23:05.925]                       }
[13:23:05.925]                       else if (inherits(cond, "condition")) {
[13:23:05.925]                         if (!is.null(pattern)) {
[13:23:05.925]                           computeRestarts <- base::computeRestarts
[13:23:05.925]                           grepl <- base::grepl
[13:23:05.925]                           restarts <- computeRestarts(cond)
[13:23:05.925]                           for (restart in restarts) {
[13:23:05.925]                             name <- restart$name
[13:23:05.925]                             if (is.null(name)) 
[13:23:05.925]                               next
[13:23:05.925]                             if (!grepl(pattern, name)) 
[13:23:05.925]                               next
[13:23:05.925]                             invokeRestart(restart)
[13:23:05.925]                             muffled <- TRUE
[13:23:05.925]                             break
[13:23:05.925]                           }
[13:23:05.925]                         }
[13:23:05.925]                       }
[13:23:05.925]                       invisible(muffled)
[13:23:05.925]                     }
[13:23:05.925]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.925]                   }
[13:23:05.925]                 }
[13:23:05.925]                 else {
[13:23:05.925]                   if (TRUE) {
[13:23:05.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.925]                     {
[13:23:05.925]                       inherits <- base::inherits
[13:23:05.925]                       invokeRestart <- base::invokeRestart
[13:23:05.925]                       is.null <- base::is.null
[13:23:05.925]                       muffled <- FALSE
[13:23:05.925]                       if (inherits(cond, "message")) {
[13:23:05.925]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.925]                         if (muffled) 
[13:23:05.925]                           invokeRestart("muffleMessage")
[13:23:05.925]                       }
[13:23:05.925]                       else if (inherits(cond, "warning")) {
[13:23:05.925]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.925]                         if (muffled) 
[13:23:05.925]                           invokeRestart("muffleWarning")
[13:23:05.925]                       }
[13:23:05.925]                       else if (inherits(cond, "condition")) {
[13:23:05.925]                         if (!is.null(pattern)) {
[13:23:05.925]                           computeRestarts <- base::computeRestarts
[13:23:05.925]                           grepl <- base::grepl
[13:23:05.925]                           restarts <- computeRestarts(cond)
[13:23:05.925]                           for (restart in restarts) {
[13:23:05.925]                             name <- restart$name
[13:23:05.925]                             if (is.null(name)) 
[13:23:05.925]                               next
[13:23:05.925]                             if (!grepl(pattern, name)) 
[13:23:05.925]                               next
[13:23:05.925]                             invokeRestart(restart)
[13:23:05.925]                             muffled <- TRUE
[13:23:05.925]                             break
[13:23:05.925]                           }
[13:23:05.925]                         }
[13:23:05.925]                       }
[13:23:05.925]                       invisible(muffled)
[13:23:05.925]                     }
[13:23:05.925]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.925]                   }
[13:23:05.925]                 }
[13:23:05.925]             }
[13:23:05.925]         }))
[13:23:05.925]     }, error = function(ex) {
[13:23:05.925]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.925]                 ...future.rng), started = ...future.startTime, 
[13:23:05.925]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.925]             version = "1.8"), class = "FutureResult")
[13:23:05.925]     }, finally = {
[13:23:05.925]         if (!identical(...future.workdir, getwd())) 
[13:23:05.925]             setwd(...future.workdir)
[13:23:05.925]         {
[13:23:05.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.925]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.925]             }
[13:23:05.925]             base::options(...future.oldOptions)
[13:23:05.925]             if (.Platform$OS.type == "windows") {
[13:23:05.925]                 old_names <- names(...future.oldEnvVars)
[13:23:05.925]                 envs <- base::Sys.getenv()
[13:23:05.925]                 names <- names(envs)
[13:23:05.925]                 common <- intersect(names, old_names)
[13:23:05.925]                 added <- setdiff(names, old_names)
[13:23:05.925]                 removed <- setdiff(old_names, names)
[13:23:05.925]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.925]                   envs[common]]
[13:23:05.925]                 NAMES <- toupper(changed)
[13:23:05.925]                 args <- list()
[13:23:05.925]                 for (kk in seq_along(NAMES)) {
[13:23:05.925]                   name <- changed[[kk]]
[13:23:05.925]                   NAME <- NAMES[[kk]]
[13:23:05.925]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.925]                     next
[13:23:05.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.925]                 }
[13:23:05.925]                 NAMES <- toupper(added)
[13:23:05.925]                 for (kk in seq_along(NAMES)) {
[13:23:05.925]                   name <- added[[kk]]
[13:23:05.925]                   NAME <- NAMES[[kk]]
[13:23:05.925]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.925]                     next
[13:23:05.925]                   args[[name]] <- ""
[13:23:05.925]                 }
[13:23:05.925]                 NAMES <- toupper(removed)
[13:23:05.925]                 for (kk in seq_along(NAMES)) {
[13:23:05.925]                   name <- removed[[kk]]
[13:23:05.925]                   NAME <- NAMES[[kk]]
[13:23:05.925]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.925]                     next
[13:23:05.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.925]                 }
[13:23:05.925]                 if (length(args) > 0) 
[13:23:05.925]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.925]             }
[13:23:05.925]             else {
[13:23:05.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.925]             }
[13:23:05.925]             {
[13:23:05.925]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.925]                   0L) {
[13:23:05.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.925]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.925]                   base::options(opts)
[13:23:05.925]                 }
[13:23:05.925]                 {
[13:23:05.925]                   {
[13:23:05.925]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:05.925]                     NULL
[13:23:05.925]                   }
[13:23:05.925]                   options(future.plan = NULL)
[13:23:05.925]                   if (is.na(NA_character_)) 
[13:23:05.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.925]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:05.925]                     envir = parent.frame()) 
[13:23:05.925]                   {
[13:23:05.925]                     default_workers <- missing(workers)
[13:23:05.925]                     if (is.function(workers)) 
[13:23:05.925]                       workers <- workers()
[13:23:05.925]                     workers <- structure(as.integer(workers), 
[13:23:05.925]                       class = class(workers))
[13:23:05.925]                     stop_if_not(is.finite(workers), workers >= 
[13:23:05.925]                       1L)
[13:23:05.925]                     if ((workers == 1L && !inherits(workers, 
[13:23:05.925]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:05.925]                       if (default_workers) 
[13:23:05.925]                         supportsMulticore(warn = TRUE)
[13:23:05.925]                       return(sequential(..., envir = envir))
[13:23:05.925]                     }
[13:23:05.925]                     oopts <- options(mc.cores = workers)
[13:23:05.925]                     on.exit(options(oopts))
[13:23:05.925]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:05.925]                       envir = envir)
[13:23:05.925]                     if (!future$lazy) 
[13:23:05.925]                       future <- run(future)
[13:23:05.925]                     invisible(future)
[13:23:05.925]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.925]                 }
[13:23:05.925]             }
[13:23:05.925]         }
[13:23:05.925]     })
[13:23:05.925]     if (TRUE) {
[13:23:05.925]         base::sink(type = "output", split = FALSE)
[13:23:05.925]         if (TRUE) {
[13:23:05.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.925]         }
[13:23:05.925]         else {
[13:23:05.925]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.925]         }
[13:23:05.925]         base::close(...future.stdout)
[13:23:05.925]         ...future.stdout <- NULL
[13:23:05.925]     }
[13:23:05.925]     ...future.result$conditions <- ...future.conditions
[13:23:05.925]     ...future.result$finished <- base::Sys.time()
[13:23:05.925]     ...future.result
[13:23:05.925] }
[13:23:05.928] requestCore(): workers = 2
[13:23:05.930] MulticoreFuture started
[13:23:05.930] - Launch lazy future ... done
[13:23:05.931] run() for ‘MulticoreFuture’ ... done
[13:23:05.931] getGlobalsAndPackages() ...
[13:23:05.931] Searching for globals...
[13:23:05.931] plan(): Setting new future strategy stack:
[13:23:05.932] 
[13:23:05.932] List of future strategies:
[13:23:05.932] 1. sequential:
[13:23:05.932]    - args: function (..., envir = parent.frame())
[13:23:05.932]    - tweaked: FALSE
[13:23:05.932]    - call: NULL
[13:23:05.932] Searching for globals ... DONE
[13:23:05.933] plan(): nbrOfWorkers() = 1
[13:23:05.933] - globals: [0] <none>
[13:23:05.933] getGlobalsAndPackages() ... DONE
[13:23:05.933] run() for ‘Future’ ...
[13:23:05.934] - state: ‘created’
[13:23:05.934] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:05.935] plan(): Setting new future strategy stack:
[13:23:05.935] List of future strategies:
[13:23:05.935] 1. multicore:
[13:23:05.935]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:05.935]    - tweaked: FALSE
[13:23:05.935]    - call: plan(strategy)
[13:23:05.940] plan(): nbrOfWorkers() = 2
[13:23:05.940] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:05.940] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:05.940]   - Field: ‘label’
[13:23:05.941]   - Field: ‘local’
[13:23:05.941]   - Field: ‘owner’
[13:23:05.941]   - Field: ‘envir’
[13:23:05.941]   - Field: ‘workers’
[13:23:05.941]   - Field: ‘packages’
[13:23:05.942]   - Field: ‘gc’
[13:23:05.942]   - Field: ‘job’
[13:23:05.942]   - Field: ‘conditions’
[13:23:05.942]   - Field: ‘expr’
[13:23:05.942]   - Field: ‘uuid’
[13:23:05.942]   - Field: ‘seed’
[13:23:05.942]   - Field: ‘version’
[13:23:05.943]   - Field: ‘result’
[13:23:05.943]   - Field: ‘asynchronous’
[13:23:05.943]   - Field: ‘calls’
[13:23:05.943]   - Field: ‘globals’
[13:23:05.943]   - Field: ‘stdout’
[13:23:05.943]   - Field: ‘earlySignal’
[13:23:05.944]   - Field: ‘lazy’
[13:23:05.944]   - Field: ‘state’
[13:23:05.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:05.944] - Launch lazy future ...
[13:23:05.945] Packages needed by the future expression (n = 0): <none>
[13:23:05.945] Packages needed by future strategies (n = 0): <none>
[13:23:05.946] {
[13:23:05.946]     {
[13:23:05.946]         {
[13:23:05.946]             ...future.startTime <- base::Sys.time()
[13:23:05.946]             {
[13:23:05.946]                 {
[13:23:05.946]                   {
[13:23:05.946]                     {
[13:23:05.946]                       base::local({
[13:23:05.946]                         has_future <- base::requireNamespace("future", 
[13:23:05.946]                           quietly = TRUE)
[13:23:05.946]                         if (has_future) {
[13:23:05.946]                           ns <- base::getNamespace("future")
[13:23:05.946]                           version <- ns[[".package"]][["version"]]
[13:23:05.946]                           if (is.null(version)) 
[13:23:05.946]                             version <- utils::packageVersion("future")
[13:23:05.946]                         }
[13:23:05.946]                         else {
[13:23:05.946]                           version <- NULL
[13:23:05.946]                         }
[13:23:05.946]                         if (!has_future || version < "1.8.0") {
[13:23:05.946]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:05.946]                             "", base::R.version$version.string), 
[13:23:05.946]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:05.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:05.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:05.946]                               "release", "version")], collapse = " "), 
[13:23:05.946]                             hostname = base::Sys.info()[["nodename"]])
[13:23:05.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:05.946]                             info)
[13:23:05.946]                           info <- base::paste(info, collapse = "; ")
[13:23:05.946]                           if (!has_future) {
[13:23:05.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:05.946]                               info)
[13:23:05.946]                           }
[13:23:05.946]                           else {
[13:23:05.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:05.946]                               info, version)
[13:23:05.946]                           }
[13:23:05.946]                           base::stop(msg)
[13:23:05.946]                         }
[13:23:05.946]                       })
[13:23:05.946]                     }
[13:23:05.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:05.946]                     base::options(mc.cores = 1L)
[13:23:05.946]                   }
[13:23:05.946]                   options(future.plan = NULL)
[13:23:05.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:05.946]                 }
[13:23:05.946]                 ...future.workdir <- getwd()
[13:23:05.946]             }
[13:23:05.946]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:05.946]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:05.946]         }
[13:23:05.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:05.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:05.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:05.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:05.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:05.946]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:05.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:05.946]             base::names(...future.oldOptions))
[13:23:05.946]     }
[13:23:05.946]     if (FALSE) {
[13:23:05.946]     }
[13:23:05.946]     else {
[13:23:05.946]         if (TRUE) {
[13:23:05.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:05.946]                 open = "w")
[13:23:05.946]         }
[13:23:05.946]         else {
[13:23:05.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:05.946]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:05.946]         }
[13:23:05.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:05.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:05.946]             base::sink(type = "output", split = FALSE)
[13:23:05.946]             base::close(...future.stdout)
[13:23:05.946]         }, add = TRUE)
[13:23:05.946]     }
[13:23:05.946]     ...future.frame <- base::sys.nframe()
[13:23:05.946]     ...future.conditions <- base::list()
[13:23:05.946]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:05.946]     if (FALSE) {
[13:23:05.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:05.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:05.946]     }
[13:23:05.946]     ...future.result <- base::tryCatch({
[13:23:05.946]         base::withCallingHandlers({
[13:23:05.946]             ...future.value <- base::withVisible(base::local({
[13:23:05.946]                 withCallingHandlers({
[13:23:05.946]                   NULL
[13:23:05.946]                 }, immediateCondition = function(cond) {
[13:23:05.946]                   save_rds <- function (object, pathname, ...) 
[13:23:05.946]                   {
[13:23:05.946]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:05.946]                     if (file_test("-f", pathname_tmp)) {
[13:23:05.946]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.946]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:05.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.946]                         fi_tmp[["mtime"]])
[13:23:05.946]                     }
[13:23:05.946]                     tryCatch({
[13:23:05.946]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:05.946]                     }, error = function(ex) {
[13:23:05.946]                       msg <- conditionMessage(ex)
[13:23:05.946]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.946]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:05.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.946]                         fi_tmp[["mtime"]], msg)
[13:23:05.946]                       ex$message <- msg
[13:23:05.946]                       stop(ex)
[13:23:05.946]                     })
[13:23:05.946]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:05.946]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:05.946]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:05.946]                       fi_tmp <- file.info(pathname_tmp)
[13:23:05.946]                       fi <- file.info(pathname)
[13:23:05.946]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:05.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:05.946]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:05.946]                         fi[["size"]], fi[["mtime"]])
[13:23:05.946]                       stop(msg)
[13:23:05.946]                     }
[13:23:05.946]                     invisible(pathname)
[13:23:05.946]                   }
[13:23:05.946]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:05.946]                     rootPath = tempdir()) 
[13:23:05.946]                   {
[13:23:05.946]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:05.946]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:05.946]                       tmpdir = path, fileext = ".rds")
[13:23:05.946]                     save_rds(obj, file)
[13:23:05.946]                   }
[13:23:05.946]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:05.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.946]                   {
[13:23:05.946]                     inherits <- base::inherits
[13:23:05.946]                     invokeRestart <- base::invokeRestart
[13:23:05.946]                     is.null <- base::is.null
[13:23:05.946]                     muffled <- FALSE
[13:23:05.946]                     if (inherits(cond, "message")) {
[13:23:05.946]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:05.946]                       if (muffled) 
[13:23:05.946]                         invokeRestart("muffleMessage")
[13:23:05.946]                     }
[13:23:05.946]                     else if (inherits(cond, "warning")) {
[13:23:05.946]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:05.946]                       if (muffled) 
[13:23:05.946]                         invokeRestart("muffleWarning")
[13:23:05.946]                     }
[13:23:05.946]                     else if (inherits(cond, "condition")) {
[13:23:05.946]                       if (!is.null(pattern)) {
[13:23:05.946]                         computeRestarts <- base::computeRestarts
[13:23:05.946]                         grepl <- base::grepl
[13:23:05.946]                         restarts <- computeRestarts(cond)
[13:23:05.946]                         for (restart in restarts) {
[13:23:05.946]                           name <- restart$name
[13:23:05.946]                           if (is.null(name)) 
[13:23:05.946]                             next
[13:23:05.946]                           if (!grepl(pattern, name)) 
[13:23:05.946]                             next
[13:23:05.946]                           invokeRestart(restart)
[13:23:05.946]                           muffled <- TRUE
[13:23:05.946]                           break
[13:23:05.946]                         }
[13:23:05.946]                       }
[13:23:05.946]                     }
[13:23:05.946]                     invisible(muffled)
[13:23:05.946]                   }
[13:23:05.946]                   muffleCondition(cond)
[13:23:05.946]                 })
[13:23:05.946]             }))
[13:23:05.946]             future::FutureResult(value = ...future.value$value, 
[13:23:05.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.946]                   ...future.rng), globalenv = if (FALSE) 
[13:23:05.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:05.946]                     ...future.globalenv.names))
[13:23:05.946]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:05.946]         }, condition = base::local({
[13:23:05.946]             c <- base::c
[13:23:05.946]             inherits <- base::inherits
[13:23:05.946]             invokeRestart <- base::invokeRestart
[13:23:05.946]             length <- base::length
[13:23:05.946]             list <- base::list
[13:23:05.946]             seq.int <- base::seq.int
[13:23:05.946]             signalCondition <- base::signalCondition
[13:23:05.946]             sys.calls <- base::sys.calls
[13:23:05.946]             `[[` <- base::`[[`
[13:23:05.946]             `+` <- base::`+`
[13:23:05.946]             `<<-` <- base::`<<-`
[13:23:05.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:05.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:05.946]                   3L)]
[13:23:05.946]             }
[13:23:05.946]             function(cond) {
[13:23:05.946]                 is_error <- inherits(cond, "error")
[13:23:05.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:05.946]                   NULL)
[13:23:05.946]                 if (is_error) {
[13:23:05.946]                   sessionInformation <- function() {
[13:23:05.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:05.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:05.946]                       search = base::search(), system = base::Sys.info())
[13:23:05.946]                   }
[13:23:05.946]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:05.946]                     cond$call), session = sessionInformation(), 
[13:23:05.946]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:05.946]                   signalCondition(cond)
[13:23:05.946]                 }
[13:23:05.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:05.946]                 "immediateCondition"))) {
[13:23:05.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:05.946]                   ...future.conditions[[length(...future.conditions) + 
[13:23:05.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:05.946]                   if (TRUE && !signal) {
[13:23:05.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.946]                     {
[13:23:05.946]                       inherits <- base::inherits
[13:23:05.946]                       invokeRestart <- base::invokeRestart
[13:23:05.946]                       is.null <- base::is.null
[13:23:05.946]                       muffled <- FALSE
[13:23:05.946]                       if (inherits(cond, "message")) {
[13:23:05.946]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.946]                         if (muffled) 
[13:23:05.946]                           invokeRestart("muffleMessage")
[13:23:05.946]                       }
[13:23:05.946]                       else if (inherits(cond, "warning")) {
[13:23:05.946]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.946]                         if (muffled) 
[13:23:05.946]                           invokeRestart("muffleWarning")
[13:23:05.946]                       }
[13:23:05.946]                       else if (inherits(cond, "condition")) {
[13:23:05.946]                         if (!is.null(pattern)) {
[13:23:05.946]                           computeRestarts <- base::computeRestarts
[13:23:05.946]                           grepl <- base::grepl
[13:23:05.946]                           restarts <- computeRestarts(cond)
[13:23:05.946]                           for (restart in restarts) {
[13:23:05.946]                             name <- restart$name
[13:23:05.946]                             if (is.null(name)) 
[13:23:05.946]                               next
[13:23:05.946]                             if (!grepl(pattern, name)) 
[13:23:05.946]                               next
[13:23:05.946]                             invokeRestart(restart)
[13:23:05.946]                             muffled <- TRUE
[13:23:05.946]                             break
[13:23:05.946]                           }
[13:23:05.946]                         }
[13:23:05.946]                       }
[13:23:05.946]                       invisible(muffled)
[13:23:05.946]                     }
[13:23:05.946]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.946]                   }
[13:23:05.946]                 }
[13:23:05.946]                 else {
[13:23:05.946]                   if (TRUE) {
[13:23:05.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:05.946]                     {
[13:23:05.946]                       inherits <- base::inherits
[13:23:05.946]                       invokeRestart <- base::invokeRestart
[13:23:05.946]                       is.null <- base::is.null
[13:23:05.946]                       muffled <- FALSE
[13:23:05.946]                       if (inherits(cond, "message")) {
[13:23:05.946]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:05.946]                         if (muffled) 
[13:23:05.946]                           invokeRestart("muffleMessage")
[13:23:05.946]                       }
[13:23:05.946]                       else if (inherits(cond, "warning")) {
[13:23:05.946]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:05.946]                         if (muffled) 
[13:23:05.946]                           invokeRestart("muffleWarning")
[13:23:05.946]                       }
[13:23:05.946]                       else if (inherits(cond, "condition")) {
[13:23:05.946]                         if (!is.null(pattern)) {
[13:23:05.946]                           computeRestarts <- base::computeRestarts
[13:23:05.946]                           grepl <- base::grepl
[13:23:05.946]                           restarts <- computeRestarts(cond)
[13:23:05.946]                           for (restart in restarts) {
[13:23:05.946]                             name <- restart$name
[13:23:05.946]                             if (is.null(name)) 
[13:23:05.946]                               next
[13:23:05.946]                             if (!grepl(pattern, name)) 
[13:23:05.946]                               next
[13:23:05.946]                             invokeRestart(restart)
[13:23:05.946]                             muffled <- TRUE
[13:23:05.946]                             break
[13:23:05.946]                           }
[13:23:05.946]                         }
[13:23:05.946]                       }
[13:23:05.946]                       invisible(muffled)
[13:23:05.946]                     }
[13:23:05.946]                     muffleCondition(cond, pattern = "^muffle")
[13:23:05.946]                   }
[13:23:05.946]                 }
[13:23:05.946]             }
[13:23:05.946]         }))
[13:23:05.946]     }, error = function(ex) {
[13:23:05.946]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:05.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:05.946]                 ...future.rng), started = ...future.startTime, 
[13:23:05.946]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:05.946]             version = "1.8"), class = "FutureResult")
[13:23:05.946]     }, finally = {
[13:23:05.946]         if (!identical(...future.workdir, getwd())) 
[13:23:05.946]             setwd(...future.workdir)
[13:23:05.946]         {
[13:23:05.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:05.946]                 ...future.oldOptions$nwarnings <- NULL
[13:23:05.946]             }
[13:23:05.946]             base::options(...future.oldOptions)
[13:23:05.946]             if (.Platform$OS.type == "windows") {
[13:23:05.946]                 old_names <- names(...future.oldEnvVars)
[13:23:05.946]                 envs <- base::Sys.getenv()
[13:23:05.946]                 names <- names(envs)
[13:23:05.946]                 common <- intersect(names, old_names)
[13:23:05.946]                 added <- setdiff(names, old_names)
[13:23:05.946]                 removed <- setdiff(old_names, names)
[13:23:05.946]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:05.946]                   envs[common]]
[13:23:05.946]                 NAMES <- toupper(changed)
[13:23:05.946]                 args <- list()
[13:23:05.946]                 for (kk in seq_along(NAMES)) {
[13:23:05.946]                   name <- changed[[kk]]
[13:23:05.946]                   NAME <- NAMES[[kk]]
[13:23:05.946]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.946]                     next
[13:23:05.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.946]                 }
[13:23:05.946]                 NAMES <- toupper(added)
[13:23:05.946]                 for (kk in seq_along(NAMES)) {
[13:23:05.946]                   name <- added[[kk]]
[13:23:05.946]                   NAME <- NAMES[[kk]]
[13:23:05.946]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.946]                     next
[13:23:05.946]                   args[[name]] <- ""
[13:23:05.946]                 }
[13:23:05.946]                 NAMES <- toupper(removed)
[13:23:05.946]                 for (kk in seq_along(NAMES)) {
[13:23:05.946]                   name <- removed[[kk]]
[13:23:05.946]                   NAME <- NAMES[[kk]]
[13:23:05.946]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:05.946]                     next
[13:23:05.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:05.946]                 }
[13:23:05.946]                 if (length(args) > 0) 
[13:23:05.946]                   base::do.call(base::Sys.setenv, args = args)
[13:23:05.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:05.946]             }
[13:23:05.946]             else {
[13:23:05.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:05.946]             }
[13:23:05.946]             {
[13:23:05.946]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:05.946]                   0L) {
[13:23:05.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:05.946]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:05.946]                   base::options(opts)
[13:23:05.946]                 }
[13:23:05.946]                 {
[13:23:05.946]                   {
[13:23:05.946]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:05.946]                     NULL
[13:23:05.946]                   }
[13:23:05.946]                   options(future.plan = NULL)
[13:23:05.946]                   if (is.na(NA_character_)) 
[13:23:05.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:05.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:05.946]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:05.946]                     envir = parent.frame()) 
[13:23:05.946]                   {
[13:23:05.946]                     default_workers <- missing(workers)
[13:23:05.946]                     if (is.function(workers)) 
[13:23:05.946]                       workers <- workers()
[13:23:05.946]                     workers <- structure(as.integer(workers), 
[13:23:05.946]                       class = class(workers))
[13:23:05.946]                     stop_if_not(is.finite(workers), workers >= 
[13:23:05.946]                       1L)
[13:23:05.946]                     if ((workers == 1L && !inherits(workers, 
[13:23:05.946]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:05.946]                       if (default_workers) 
[13:23:05.946]                         supportsMulticore(warn = TRUE)
[13:23:05.946]                       return(sequential(..., envir = envir))
[13:23:05.946]                     }
[13:23:05.946]                     oopts <- options(mc.cores = workers)
[13:23:05.946]                     on.exit(options(oopts))
[13:23:05.946]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:05.946]                       envir = envir)
[13:23:05.946]                     if (!future$lazy) 
[13:23:05.946]                       future <- run(future)
[13:23:05.946]                     invisible(future)
[13:23:05.946]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:05.946]                 }
[13:23:05.946]             }
[13:23:05.946]         }
[13:23:05.946]     })
[13:23:05.946]     if (TRUE) {
[13:23:05.946]         base::sink(type = "output", split = FALSE)
[13:23:05.946]         if (TRUE) {
[13:23:05.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:05.946]         }
[13:23:05.946]         else {
[13:23:05.946]             ...future.result["stdout"] <- base::list(NULL)
[13:23:05.946]         }
[13:23:05.946]         base::close(...future.stdout)
[13:23:05.946]         ...future.stdout <- NULL
[13:23:05.946]     }
[13:23:05.946]     ...future.result$conditions <- ...future.conditions
[13:23:05.946]     ...future.result$finished <- base::Sys.time()
[13:23:05.946]     ...future.result
[13:23:05.946] }
[13:23:05.950] requestCore(): workers = 2
[13:23:05.952] MulticoreFuture started
[13:23:05.953] - Launch lazy future ... done
[13:23:05.953] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[13:23:05.954] plan(): Setting new future strategy stack:
 num 1
 $ b:[13:23:05.954] List of future strategies:
[13:23:05.954] 1. sequential:
[13:23:05.954]    - args: function (..., envir = parent.frame())
[13:23:05.954]    - tweaked: FALSE
[13:23:05.954]    - call: NULL
[13:23:05.955] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d3c0f7b0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d355d170> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a:[13:23:05.957] plan(): Setting new future strategy stack:
 num 1
 $ b:[13:23:05.957] List of future strategies:
[13:23:05.957] 1. multicore:
[13:23:05.957]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:05.957]    - tweaked: FALSE
[13:23:05.957]    - call: plan(strategy)
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d3c0f7b0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d355d170> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:23:05.962] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:05.966] resolve() on list ...
[13:23:05.966]  recursive: 0
[13:23:05.966]  length: 6
[13:23:05.966]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:05.966] signalConditionsASAP(numeric, pos=1) ...
[13:23:05.967] - nx: 6
[13:23:05.967] - relay: TRUE
[13:23:05.967] - stdout: TRUE
[13:23:05.967] - signal: TRUE
[13:23:05.967] - resignal: FALSE
[13:23:05.967] - force: TRUE
[13:23:05.967] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.967] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.968]  - until=2
[13:23:05.968]  - relaying element #2
[13:23:05.968] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.968] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.968] signalConditionsASAP(NULL, pos=1) ... done
[13:23:05.968]  length: 5 (resolved future 1)
[13:23:05.969] Future #2
[13:23:05.969] result() for MulticoreFuture ...
[13:23:05.970] result() for MulticoreFuture ...
[13:23:05.970] result() for MulticoreFuture ... done
[13:23:05.970] result() for MulticoreFuture ... done
[13:23:05.971] result() for MulticoreFuture ...
[13:23:05.971] result() for MulticoreFuture ... done
[13:23:05.971] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:05.971] - nx: 6
[13:23:05.971] - relay: TRUE
[13:23:05.971] - stdout: TRUE
[13:23:05.971] - signal: TRUE
[13:23:05.972] - resignal: FALSE
[13:23:05.972] - force: TRUE
[13:23:05.972] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.972] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:05.972]  - until=2
[13:23:05.972]  - relaying element #2
[13:23:05.977] result() for MulticoreFuture ...
[13:23:05.977] result() for MulticoreFuture ... done
[13:23:05.977] result() for MulticoreFuture ...
[13:23:05.978] result() for MulticoreFuture ... done
[13:23:05.978] result() for MulticoreFuture ...
[13:23:05.978] result() for MulticoreFuture ... done
[13:23:05.979] result() for MulticoreFuture ...
[13:23:05.979] result() for MulticoreFuture ... done
[13:23:05.979] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.979] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.980] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:05.980]  length: 4 (resolved future 2)
[13:23:05.981] Future #3
[13:23:05.981] result() for MulticoreFuture ...
[13:23:05.982] result() for MulticoreFuture ...
[13:23:05.982] result() for MulticoreFuture ... done
[13:23:05.982] result() for MulticoreFuture ... done
[13:23:05.982] result() for MulticoreFuture ...
[13:23:05.982] result() for MulticoreFuture ... done
[13:23:05.982] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:05.983] - nx: 6
[13:23:05.983] - relay: TRUE
[13:23:05.983] - stdout: TRUE
[13:23:05.983] - signal: TRUE
[13:23:05.983] - resignal: FALSE
[13:23:05.983] - force: TRUE
[13:23:05.983] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.983] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:05.984]  - until=3
[13:23:05.984]  - relaying element #3
[13:23:05.984] result() for MulticoreFuture ...
[13:23:05.984] result() for MulticoreFuture ... done
[13:23:05.984] result() for MulticoreFuture ...
[13:23:05.984] result() for MulticoreFuture ... done
[13:23:05.985] result() for MulticoreFuture ...
[13:23:05.985] result() for MulticoreFuture ... done
[13:23:05.985] result() for MulticoreFuture ...
[13:23:05.985] result() for MulticoreFuture ... done
[13:23:05.985] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.985] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.985] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:05.986]  length: 3 (resolved future 3)
[13:23:05.986] signalConditionsASAP(NULL, pos=4) ...
[13:23:05.986] - nx: 6
[13:23:05.986] - relay: TRUE
[13:23:05.986] - stdout: TRUE
[13:23:05.986] - signal: TRUE
[13:23:05.986] - resignal: FALSE
[13:23:05.986] - force: TRUE
[13:23:05.986] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.987] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.987]  - until=5
[13:23:05.987]  - relaying element #5
[13:23:05.987] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.987] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.987] signalConditionsASAP(NULL, pos=4) ... done
[13:23:05.987]  length: 2 (resolved future 4)
[13:23:05.987] signalConditionsASAP(NULL, pos=5) ...
[13:23:05.987] - nx: 6
[13:23:05.988] - relay: TRUE
[13:23:05.988] - stdout: TRUE
[13:23:05.988] - signal: TRUE
[13:23:05.988] - resignal: FALSE
[13:23:05.988] - force: TRUE
[13:23:05.988] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:05.988] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.988]  - until=6
[13:23:05.988]  - relaying element #6
[13:23:05.989] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.989] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.989] signalConditionsASAP(NULL, pos=5) ... done
[13:23:05.989]  length: 1 (resolved future 5)
[13:23:05.989] signalConditionsASAP(numeric, pos=6) ...
[13:23:05.989] - nx: 6
[13:23:05.989] - relay: TRUE
[13:23:05.989] - stdout: TRUE
[13:23:05.989] - signal: TRUE
[13:23:05.989] - resignal: FALSE
[13:23:05.990] - force: TRUE
[13:23:05.990] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:05.990] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.990]  - until=6
[13:23:05.990] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.990] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.990] signalConditionsASAP(numeric, pos=6) ... done
[13:23:05.990]  length: 0 (resolved future 6)
[13:23:05.990] Relaying remaining futures
[13:23:05.991] signalConditionsASAP(NULL, pos=0) ...
[13:23:05.991] - nx: 6
[13:23:05.991] - relay: TRUE
[13:23:05.991] - stdout: TRUE
[13:23:05.991] - signal: TRUE
[13:23:05.991] - resignal: FALSE
[13:23:05.991] - force: TRUE
[13:23:05.991] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.991] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:05.992] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:05.992] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:05.992] signalConditionsASAP(NULL, pos=0) ... done
[13:23:05.992] resolve() on list ... DONE
[13:23:05.992] result() for MulticoreFuture ...
[13:23:05.992] result() for MulticoreFuture ... done
[13:23:05.992] result() for MulticoreFuture ...
[13:23:05.992] result() for MulticoreFuture ... done
[13:23:05.993] result() for MulticoreFuture ...
[13:23:05.993] result() for MulticoreFuture ... done
[13:23:05.993] result() for MulticoreFuture ...
[13:23:05.993] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:23:05.996] getGlobalsAndPackages() ...
[13:23:05.997] Searching for globals...
[13:23:05.997] 
[13:23:05.997] Searching for globals ... DONE
[13:23:05.997] - globals: [0] <none>
[13:23:05.997] getGlobalsAndPackages() ... DONE
[13:23:05.998] run() for ‘Future’ ...
[13:23:05.998] - state: ‘created’
[13:23:05.998] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:06.002] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:06.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:06.003]   - Field: ‘label’
[13:23:06.003]   - Field: ‘local’
[13:23:06.003]   - Field: ‘owner’
[13:23:06.003]   - Field: ‘envir’
[13:23:06.003]   - Field: ‘workers’
[13:23:06.003]   - Field: ‘packages’
[13:23:06.003]   - Field: ‘gc’
[13:23:06.004]   - Field: ‘job’
[13:23:06.004]   - Field: ‘conditions’
[13:23:06.004]   - Field: ‘expr’
[13:23:06.004]   - Field: ‘uuid’
[13:23:06.004]   - Field: ‘seed’
[13:23:06.004]   - Field: ‘version’
[13:23:06.004]   - Field: ‘result’
[13:23:06.004]   - Field: ‘asynchronous’
[13:23:06.004]   - Field: ‘calls’
[13:23:06.004]   - Field: ‘globals’
[13:23:06.005]   - Field: ‘stdout’
[13:23:06.005]   - Field: ‘earlySignal’
[13:23:06.005]   - Field: ‘lazy’
[13:23:06.005]   - Field: ‘state’
[13:23:06.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:06.005] - Launch lazy future ...
[13:23:06.005] Packages needed by the future expression (n = 0): <none>
[13:23:06.006] Packages needed by future strategies (n = 0): <none>
[13:23:06.006] {
[13:23:06.006]     {
[13:23:06.006]         {
[13:23:06.006]             ...future.startTime <- base::Sys.time()
[13:23:06.006]             {
[13:23:06.006]                 {
[13:23:06.006]                   {
[13:23:06.006]                     {
[13:23:06.006]                       base::local({
[13:23:06.006]                         has_future <- base::requireNamespace("future", 
[13:23:06.006]                           quietly = TRUE)
[13:23:06.006]                         if (has_future) {
[13:23:06.006]                           ns <- base::getNamespace("future")
[13:23:06.006]                           version <- ns[[".package"]][["version"]]
[13:23:06.006]                           if (is.null(version)) 
[13:23:06.006]                             version <- utils::packageVersion("future")
[13:23:06.006]                         }
[13:23:06.006]                         else {
[13:23:06.006]                           version <- NULL
[13:23:06.006]                         }
[13:23:06.006]                         if (!has_future || version < "1.8.0") {
[13:23:06.006]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:06.006]                             "", base::R.version$version.string), 
[13:23:06.006]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:06.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:06.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:06.006]                               "release", "version")], collapse = " "), 
[13:23:06.006]                             hostname = base::Sys.info()[["nodename"]])
[13:23:06.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:06.006]                             info)
[13:23:06.006]                           info <- base::paste(info, collapse = "; ")
[13:23:06.006]                           if (!has_future) {
[13:23:06.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:06.006]                               info)
[13:23:06.006]                           }
[13:23:06.006]                           else {
[13:23:06.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:06.006]                               info, version)
[13:23:06.006]                           }
[13:23:06.006]                           base::stop(msg)
[13:23:06.006]                         }
[13:23:06.006]                       })
[13:23:06.006]                     }
[13:23:06.006]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:06.006]                     base::options(mc.cores = 1L)
[13:23:06.006]                   }
[13:23:06.006]                   options(future.plan = NULL)
[13:23:06.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:06.006]                 }
[13:23:06.006]                 ...future.workdir <- getwd()
[13:23:06.006]             }
[13:23:06.006]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:06.006]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:06.006]         }
[13:23:06.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:06.006]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:06.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:06.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:06.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:06.006]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:06.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:06.006]             base::names(...future.oldOptions))
[13:23:06.006]     }
[13:23:06.006]     if (FALSE) {
[13:23:06.006]     }
[13:23:06.006]     else {
[13:23:06.006]         if (TRUE) {
[13:23:06.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:06.006]                 open = "w")
[13:23:06.006]         }
[13:23:06.006]         else {
[13:23:06.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:06.006]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:06.006]         }
[13:23:06.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:06.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:06.006]             base::sink(type = "output", split = FALSE)
[13:23:06.006]             base::close(...future.stdout)
[13:23:06.006]         }, add = TRUE)
[13:23:06.006]     }
[13:23:06.006]     ...future.frame <- base::sys.nframe()
[13:23:06.006]     ...future.conditions <- base::list()
[13:23:06.006]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:06.006]     if (FALSE) {
[13:23:06.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:06.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:06.006]     }
[13:23:06.006]     ...future.result <- base::tryCatch({
[13:23:06.006]         base::withCallingHandlers({
[13:23:06.006]             ...future.value <- base::withVisible(base::local({
[13:23:06.006]                 withCallingHandlers({
[13:23:06.006]                   2
[13:23:06.006]                 }, immediateCondition = function(cond) {
[13:23:06.006]                   save_rds <- function (object, pathname, ...) 
[13:23:06.006]                   {
[13:23:06.006]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:06.006]                     if (file_test("-f", pathname_tmp)) {
[13:23:06.006]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.006]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:06.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.006]                         fi_tmp[["mtime"]])
[13:23:06.006]                     }
[13:23:06.006]                     tryCatch({
[13:23:06.006]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:06.006]                     }, error = function(ex) {
[13:23:06.006]                       msg <- conditionMessage(ex)
[13:23:06.006]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.006]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:06.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.006]                         fi_tmp[["mtime"]], msg)
[13:23:06.006]                       ex$message <- msg
[13:23:06.006]                       stop(ex)
[13:23:06.006]                     })
[13:23:06.006]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:06.006]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:06.006]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:06.006]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.006]                       fi <- file.info(pathname)
[13:23:06.006]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:06.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.006]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:06.006]                         fi[["size"]], fi[["mtime"]])
[13:23:06.006]                       stop(msg)
[13:23:06.006]                     }
[13:23:06.006]                     invisible(pathname)
[13:23:06.006]                   }
[13:23:06.006]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:06.006]                     rootPath = tempdir()) 
[13:23:06.006]                   {
[13:23:06.006]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:06.006]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:06.006]                       tmpdir = path, fileext = ".rds")
[13:23:06.006]                     save_rds(obj, file)
[13:23:06.006]                   }
[13:23:06.006]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:06.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.006]                   {
[13:23:06.006]                     inherits <- base::inherits
[13:23:06.006]                     invokeRestart <- base::invokeRestart
[13:23:06.006]                     is.null <- base::is.null
[13:23:06.006]                     muffled <- FALSE
[13:23:06.006]                     if (inherits(cond, "message")) {
[13:23:06.006]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:06.006]                       if (muffled) 
[13:23:06.006]                         invokeRestart("muffleMessage")
[13:23:06.006]                     }
[13:23:06.006]                     else if (inherits(cond, "warning")) {
[13:23:06.006]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:06.006]                       if (muffled) 
[13:23:06.006]                         invokeRestart("muffleWarning")
[13:23:06.006]                     }
[13:23:06.006]                     else if (inherits(cond, "condition")) {
[13:23:06.006]                       if (!is.null(pattern)) {
[13:23:06.006]                         computeRestarts <- base::computeRestarts
[13:23:06.006]                         grepl <- base::grepl
[13:23:06.006]                         restarts <- computeRestarts(cond)
[13:23:06.006]                         for (restart in restarts) {
[13:23:06.006]                           name <- restart$name
[13:23:06.006]                           if (is.null(name)) 
[13:23:06.006]                             next
[13:23:06.006]                           if (!grepl(pattern, name)) 
[13:23:06.006]                             next
[13:23:06.006]                           invokeRestart(restart)
[13:23:06.006]                           muffled <- TRUE
[13:23:06.006]                           break
[13:23:06.006]                         }
[13:23:06.006]                       }
[13:23:06.006]                     }
[13:23:06.006]                     invisible(muffled)
[13:23:06.006]                   }
[13:23:06.006]                   muffleCondition(cond)
[13:23:06.006]                 })
[13:23:06.006]             }))
[13:23:06.006]             future::FutureResult(value = ...future.value$value, 
[13:23:06.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.006]                   ...future.rng), globalenv = if (FALSE) 
[13:23:06.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:06.006]                     ...future.globalenv.names))
[13:23:06.006]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:06.006]         }, condition = base::local({
[13:23:06.006]             c <- base::c
[13:23:06.006]             inherits <- base::inherits
[13:23:06.006]             invokeRestart <- base::invokeRestart
[13:23:06.006]             length <- base::length
[13:23:06.006]             list <- base::list
[13:23:06.006]             seq.int <- base::seq.int
[13:23:06.006]             signalCondition <- base::signalCondition
[13:23:06.006]             sys.calls <- base::sys.calls
[13:23:06.006]             `[[` <- base::`[[`
[13:23:06.006]             `+` <- base::`+`
[13:23:06.006]             `<<-` <- base::`<<-`
[13:23:06.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:06.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:06.006]                   3L)]
[13:23:06.006]             }
[13:23:06.006]             function(cond) {
[13:23:06.006]                 is_error <- inherits(cond, "error")
[13:23:06.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:06.006]                   NULL)
[13:23:06.006]                 if (is_error) {
[13:23:06.006]                   sessionInformation <- function() {
[13:23:06.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:06.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:06.006]                       search = base::search(), system = base::Sys.info())
[13:23:06.006]                   }
[13:23:06.006]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:06.006]                     cond$call), session = sessionInformation(), 
[13:23:06.006]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:06.006]                   signalCondition(cond)
[13:23:06.006]                 }
[13:23:06.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:06.006]                 "immediateCondition"))) {
[13:23:06.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:06.006]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:06.006]                   if (TRUE && !signal) {
[13:23:06.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.006]                     {
[13:23:06.006]                       inherits <- base::inherits
[13:23:06.006]                       invokeRestart <- base::invokeRestart
[13:23:06.006]                       is.null <- base::is.null
[13:23:06.006]                       muffled <- FALSE
[13:23:06.006]                       if (inherits(cond, "message")) {
[13:23:06.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.006]                         if (muffled) 
[13:23:06.006]                           invokeRestart("muffleMessage")
[13:23:06.006]                       }
[13:23:06.006]                       else if (inherits(cond, "warning")) {
[13:23:06.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.006]                         if (muffled) 
[13:23:06.006]                           invokeRestart("muffleWarning")
[13:23:06.006]                       }
[13:23:06.006]                       else if (inherits(cond, "condition")) {
[13:23:06.006]                         if (!is.null(pattern)) {
[13:23:06.006]                           computeRestarts <- base::computeRestarts
[13:23:06.006]                           grepl <- base::grepl
[13:23:06.006]                           restarts <- computeRestarts(cond)
[13:23:06.006]                           for (restart in restarts) {
[13:23:06.006]                             name <- restart$name
[13:23:06.006]                             if (is.null(name)) 
[13:23:06.006]                               next
[13:23:06.006]                             if (!grepl(pattern, name)) 
[13:23:06.006]                               next
[13:23:06.006]                             invokeRestart(restart)
[13:23:06.006]                             muffled <- TRUE
[13:23:06.006]                             break
[13:23:06.006]                           }
[13:23:06.006]                         }
[13:23:06.006]                       }
[13:23:06.006]                       invisible(muffled)
[13:23:06.006]                     }
[13:23:06.006]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.006]                   }
[13:23:06.006]                 }
[13:23:06.006]                 else {
[13:23:06.006]                   if (TRUE) {
[13:23:06.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.006]                     {
[13:23:06.006]                       inherits <- base::inherits
[13:23:06.006]                       invokeRestart <- base::invokeRestart
[13:23:06.006]                       is.null <- base::is.null
[13:23:06.006]                       muffled <- FALSE
[13:23:06.006]                       if (inherits(cond, "message")) {
[13:23:06.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.006]                         if (muffled) 
[13:23:06.006]                           invokeRestart("muffleMessage")
[13:23:06.006]                       }
[13:23:06.006]                       else if (inherits(cond, "warning")) {
[13:23:06.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.006]                         if (muffled) 
[13:23:06.006]                           invokeRestart("muffleWarning")
[13:23:06.006]                       }
[13:23:06.006]                       else if (inherits(cond, "condition")) {
[13:23:06.006]                         if (!is.null(pattern)) {
[13:23:06.006]                           computeRestarts <- base::computeRestarts
[13:23:06.006]                           grepl <- base::grepl
[13:23:06.006]                           restarts <- computeRestarts(cond)
[13:23:06.006]                           for (restart in restarts) {
[13:23:06.006]                             name <- restart$name
[13:23:06.006]                             if (is.null(name)) 
[13:23:06.006]                               next
[13:23:06.006]                             if (!grepl(pattern, name)) 
[13:23:06.006]                               next
[13:23:06.006]                             invokeRestart(restart)
[13:23:06.006]                             muffled <- TRUE
[13:23:06.006]                             break
[13:23:06.006]                           }
[13:23:06.006]                         }
[13:23:06.006]                       }
[13:23:06.006]                       invisible(muffled)
[13:23:06.006]                     }
[13:23:06.006]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.006]                   }
[13:23:06.006]                 }
[13:23:06.006]             }
[13:23:06.006]         }))
[13:23:06.006]     }, error = function(ex) {
[13:23:06.006]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:06.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.006]                 ...future.rng), started = ...future.startTime, 
[13:23:06.006]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:06.006]             version = "1.8"), class = "FutureResult")
[13:23:06.006]     }, finally = {
[13:23:06.006]         if (!identical(...future.workdir, getwd())) 
[13:23:06.006]             setwd(...future.workdir)
[13:23:06.006]         {
[13:23:06.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:06.006]                 ...future.oldOptions$nwarnings <- NULL
[13:23:06.006]             }
[13:23:06.006]             base::options(...future.oldOptions)
[13:23:06.006]             if (.Platform$OS.type == "windows") {
[13:23:06.006]                 old_names <- names(...future.oldEnvVars)
[13:23:06.006]                 envs <- base::Sys.getenv()
[13:23:06.006]                 names <- names(envs)
[13:23:06.006]                 common <- intersect(names, old_names)
[13:23:06.006]                 added <- setdiff(names, old_names)
[13:23:06.006]                 removed <- setdiff(old_names, names)
[13:23:06.006]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:06.006]                   envs[common]]
[13:23:06.006]                 NAMES <- toupper(changed)
[13:23:06.006]                 args <- list()
[13:23:06.006]                 for (kk in seq_along(NAMES)) {
[13:23:06.006]                   name <- changed[[kk]]
[13:23:06.006]                   NAME <- NAMES[[kk]]
[13:23:06.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.006]                     next
[13:23:06.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.006]                 }
[13:23:06.006]                 NAMES <- toupper(added)
[13:23:06.006]                 for (kk in seq_along(NAMES)) {
[13:23:06.006]                   name <- added[[kk]]
[13:23:06.006]                   NAME <- NAMES[[kk]]
[13:23:06.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.006]                     next
[13:23:06.006]                   args[[name]] <- ""
[13:23:06.006]                 }
[13:23:06.006]                 NAMES <- toupper(removed)
[13:23:06.006]                 for (kk in seq_along(NAMES)) {
[13:23:06.006]                   name <- removed[[kk]]
[13:23:06.006]                   NAME <- NAMES[[kk]]
[13:23:06.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.006]                     next
[13:23:06.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.006]                 }
[13:23:06.006]                 if (length(args) > 0) 
[13:23:06.006]                   base::do.call(base::Sys.setenv, args = args)
[13:23:06.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:06.006]             }
[13:23:06.006]             else {
[13:23:06.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:06.006]             }
[13:23:06.006]             {
[13:23:06.006]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:06.006]                   0L) {
[13:23:06.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:06.006]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:06.006]                   base::options(opts)
[13:23:06.006]                 }
[13:23:06.006]                 {
[13:23:06.006]                   {
[13:23:06.006]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:06.006]                     NULL
[13:23:06.006]                   }
[13:23:06.006]                   options(future.plan = NULL)
[13:23:06.006]                   if (is.na(NA_character_)) 
[13:23:06.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:06.006]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:06.006]                     envir = parent.frame()) 
[13:23:06.006]                   {
[13:23:06.006]                     default_workers <- missing(workers)
[13:23:06.006]                     if (is.function(workers)) 
[13:23:06.006]                       workers <- workers()
[13:23:06.006]                     workers <- structure(as.integer(workers), 
[13:23:06.006]                       class = class(workers))
[13:23:06.006]                     stop_if_not(is.finite(workers), workers >= 
[13:23:06.006]                       1L)
[13:23:06.006]                     if ((workers == 1L && !inherits(workers, 
[13:23:06.006]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:06.006]                       if (default_workers) 
[13:23:06.006]                         supportsMulticore(warn = TRUE)
[13:23:06.006]                       return(sequential(..., envir = envir))
[13:23:06.006]                     }
[13:23:06.006]                     oopts <- options(mc.cores = workers)
[13:23:06.006]                     on.exit(options(oopts))
[13:23:06.006]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:06.006]                       envir = envir)
[13:23:06.006]                     if (!future$lazy) 
[13:23:06.006]                       future <- run(future)
[13:23:06.006]                     invisible(future)
[13:23:06.006]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:06.006]                 }
[13:23:06.006]             }
[13:23:06.006]         }
[13:23:06.006]     })
[13:23:06.006]     if (TRUE) {
[13:23:06.006]         base::sink(type = "output", split = FALSE)
[13:23:06.006]         if (TRUE) {
[13:23:06.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:06.006]         }
[13:23:06.006]         else {
[13:23:06.006]             ...future.result["stdout"] <- base::list(NULL)
[13:23:06.006]         }
[13:23:06.006]         base::close(...future.stdout)
[13:23:06.006]         ...future.stdout <- NULL
[13:23:06.006]     }
[13:23:06.006]     ...future.result$conditions <- ...future.conditions
[13:23:06.006]     ...future.result$finished <- base::Sys.time()
[13:23:06.006]     ...future.result
[13:23:06.006] }
[13:23:06.009] requestCore(): workers = 2
[13:23:06.011] MulticoreFuture started
[13:23:06.011] - Launch lazy future ... done
[13:23:06.012] run() for ‘MulticoreFuture’ ... done
[13:23:06.012] getGlobalsAndPackages() ...
[13:23:06.012] Searching for globals...
[13:23:06.012] plan(): Setting new future strategy stack:
[13:23:06.013] 
[13:23:06.012] List of future strategies:
[13:23:06.012] 1. sequential:
[13:23:06.012]    - args: function (..., envir = parent.frame())
[13:23:06.012]    - tweaked: FALSE
[13:23:06.012]    - call: NULL
[13:23:06.013] Searching for globals ... DONE
[13:23:06.013] plan(): nbrOfWorkers() = 1
[13:23:06.013] - globals: [0] <none>
[13:23:06.014] getGlobalsAndPackages() ... DONE
[13:23:06.014] run() for ‘Future’ ...
[13:23:06.014] - state: ‘created’
[13:23:06.015] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:06.015] plan(): Setting new future strategy stack:
[13:23:06.016] List of future strategies:
[13:23:06.016] 1. multicore:
[13:23:06.016]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:06.016]    - tweaked: FALSE
[13:23:06.016]    - call: plan(strategy)
[13:23:06.020] plan(): nbrOfWorkers() = 2
[13:23:06.024] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:06.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:06.025]   - Field: ‘label’
[13:23:06.026]   - Field: ‘local’
[13:23:06.026]   - Field: ‘owner’
[13:23:06.026]   - Field: ‘envir’
[13:23:06.027]   - Field: ‘workers’
[13:23:06.027]   - Field: ‘packages’
[13:23:06.027]   - Field: ‘gc’
[13:23:06.028]   - Field: ‘job’
[13:23:06.028]   - Field: ‘conditions’
[13:23:06.029]   - Field: ‘expr’
[13:23:06.029]   - Field: ‘uuid’
[13:23:06.029]   - Field: ‘seed’
[13:23:06.029]   - Field: ‘version’
[13:23:06.030]   - Field: ‘result’
[13:23:06.030]   - Field: ‘asynchronous’
[13:23:06.030]   - Field: ‘calls’
[13:23:06.030]   - Field: ‘globals’
[13:23:06.030]   - Field: ‘stdout’
[13:23:06.031]   - Field: ‘earlySignal’
[13:23:06.031]   - Field: ‘lazy’
[13:23:06.031]   - Field: ‘state’
[13:23:06.031] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:06.031] - Launch lazy future ...
[13:23:06.032] Packages needed by the future expression (n = 0): <none>
[13:23:06.032] Packages needed by future strategies (n = 0): <none>
[13:23:06.033] {
[13:23:06.033]     {
[13:23:06.033]         {
[13:23:06.033]             ...future.startTime <- base::Sys.time()
[13:23:06.033]             {
[13:23:06.033]                 {
[13:23:06.033]                   {
[13:23:06.033]                     {
[13:23:06.033]                       base::local({
[13:23:06.033]                         has_future <- base::requireNamespace("future", 
[13:23:06.033]                           quietly = TRUE)
[13:23:06.033]                         if (has_future) {
[13:23:06.033]                           ns <- base::getNamespace("future")
[13:23:06.033]                           version <- ns[[".package"]][["version"]]
[13:23:06.033]                           if (is.null(version)) 
[13:23:06.033]                             version <- utils::packageVersion("future")
[13:23:06.033]                         }
[13:23:06.033]                         else {
[13:23:06.033]                           version <- NULL
[13:23:06.033]                         }
[13:23:06.033]                         if (!has_future || version < "1.8.0") {
[13:23:06.033]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:06.033]                             "", base::R.version$version.string), 
[13:23:06.033]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:06.033]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:06.033]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:06.033]                               "release", "version")], collapse = " "), 
[13:23:06.033]                             hostname = base::Sys.info()[["nodename"]])
[13:23:06.033]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:06.033]                             info)
[13:23:06.033]                           info <- base::paste(info, collapse = "; ")
[13:23:06.033]                           if (!has_future) {
[13:23:06.033]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:06.033]                               info)
[13:23:06.033]                           }
[13:23:06.033]                           else {
[13:23:06.033]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:06.033]                               info, version)
[13:23:06.033]                           }
[13:23:06.033]                           base::stop(msg)
[13:23:06.033]                         }
[13:23:06.033]                       })
[13:23:06.033]                     }
[13:23:06.033]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:06.033]                     base::options(mc.cores = 1L)
[13:23:06.033]                   }
[13:23:06.033]                   options(future.plan = NULL)
[13:23:06.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:06.033]                 }
[13:23:06.033]                 ...future.workdir <- getwd()
[13:23:06.033]             }
[13:23:06.033]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:06.033]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:06.033]         }
[13:23:06.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:06.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:06.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:06.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:06.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:06.033]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:06.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:06.033]             base::names(...future.oldOptions))
[13:23:06.033]     }
[13:23:06.033]     if (FALSE) {
[13:23:06.033]     }
[13:23:06.033]     else {
[13:23:06.033]         if (TRUE) {
[13:23:06.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:06.033]                 open = "w")
[13:23:06.033]         }
[13:23:06.033]         else {
[13:23:06.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:06.033]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:06.033]         }
[13:23:06.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:06.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:06.033]             base::sink(type = "output", split = FALSE)
[13:23:06.033]             base::close(...future.stdout)
[13:23:06.033]         }, add = TRUE)
[13:23:06.033]     }
[13:23:06.033]     ...future.frame <- base::sys.nframe()
[13:23:06.033]     ...future.conditions <- base::list()
[13:23:06.033]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:06.033]     if (FALSE) {
[13:23:06.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:06.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:06.033]     }
[13:23:06.033]     ...future.result <- base::tryCatch({
[13:23:06.033]         base::withCallingHandlers({
[13:23:06.033]             ...future.value <- base::withVisible(base::local({
[13:23:06.033]                 withCallingHandlers({
[13:23:06.033]                   NULL
[13:23:06.033]                 }, immediateCondition = function(cond) {
[13:23:06.033]                   save_rds <- function (object, pathname, ...) 
[13:23:06.033]                   {
[13:23:06.033]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:06.033]                     if (file_test("-f", pathname_tmp)) {
[13:23:06.033]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.033]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:06.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.033]                         fi_tmp[["mtime"]])
[13:23:06.033]                     }
[13:23:06.033]                     tryCatch({
[13:23:06.033]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:06.033]                     }, error = function(ex) {
[13:23:06.033]                       msg <- conditionMessage(ex)
[13:23:06.033]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.033]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:06.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.033]                         fi_tmp[["mtime"]], msg)
[13:23:06.033]                       ex$message <- msg
[13:23:06.033]                       stop(ex)
[13:23:06.033]                     })
[13:23:06.033]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:06.033]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:06.033]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:06.033]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.033]                       fi <- file.info(pathname)
[13:23:06.033]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:06.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.033]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:06.033]                         fi[["size"]], fi[["mtime"]])
[13:23:06.033]                       stop(msg)
[13:23:06.033]                     }
[13:23:06.033]                     invisible(pathname)
[13:23:06.033]                   }
[13:23:06.033]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:06.033]                     rootPath = tempdir()) 
[13:23:06.033]                   {
[13:23:06.033]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:06.033]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:06.033]                       tmpdir = path, fileext = ".rds")
[13:23:06.033]                     save_rds(obj, file)
[13:23:06.033]                   }
[13:23:06.033]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:06.033]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.033]                   {
[13:23:06.033]                     inherits <- base::inherits
[13:23:06.033]                     invokeRestart <- base::invokeRestart
[13:23:06.033]                     is.null <- base::is.null
[13:23:06.033]                     muffled <- FALSE
[13:23:06.033]                     if (inherits(cond, "message")) {
[13:23:06.033]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:06.033]                       if (muffled) 
[13:23:06.033]                         invokeRestart("muffleMessage")
[13:23:06.033]                     }
[13:23:06.033]                     else if (inherits(cond, "warning")) {
[13:23:06.033]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:06.033]                       if (muffled) 
[13:23:06.033]                         invokeRestart("muffleWarning")
[13:23:06.033]                     }
[13:23:06.033]                     else if (inherits(cond, "condition")) {
[13:23:06.033]                       if (!is.null(pattern)) {
[13:23:06.033]                         computeRestarts <- base::computeRestarts
[13:23:06.033]                         grepl <- base::grepl
[13:23:06.033]                         restarts <- computeRestarts(cond)
[13:23:06.033]                         for (restart in restarts) {
[13:23:06.033]                           name <- restart$name
[13:23:06.033]                           if (is.null(name)) 
[13:23:06.033]                             next
[13:23:06.033]                           if (!grepl(pattern, name)) 
[13:23:06.033]                             next
[13:23:06.033]                           invokeRestart(restart)
[13:23:06.033]                           muffled <- TRUE
[13:23:06.033]                           break
[13:23:06.033]                         }
[13:23:06.033]                       }
[13:23:06.033]                     }
[13:23:06.033]                     invisible(muffled)
[13:23:06.033]                   }
[13:23:06.033]                   muffleCondition(cond)
[13:23:06.033]                 })
[13:23:06.033]             }))
[13:23:06.033]             future::FutureResult(value = ...future.value$value, 
[13:23:06.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.033]                   ...future.rng), globalenv = if (FALSE) 
[13:23:06.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:06.033]                     ...future.globalenv.names))
[13:23:06.033]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:06.033]         }, condition = base::local({
[13:23:06.033]             c <- base::c
[13:23:06.033]             inherits <- base::inherits
[13:23:06.033]             invokeRestart <- base::invokeRestart
[13:23:06.033]             length <- base::length
[13:23:06.033]             list <- base::list
[13:23:06.033]             seq.int <- base::seq.int
[13:23:06.033]             signalCondition <- base::signalCondition
[13:23:06.033]             sys.calls <- base::sys.calls
[13:23:06.033]             `[[` <- base::`[[`
[13:23:06.033]             `+` <- base::`+`
[13:23:06.033]             `<<-` <- base::`<<-`
[13:23:06.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:06.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:06.033]                   3L)]
[13:23:06.033]             }
[13:23:06.033]             function(cond) {
[13:23:06.033]                 is_error <- inherits(cond, "error")
[13:23:06.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:06.033]                   NULL)
[13:23:06.033]                 if (is_error) {
[13:23:06.033]                   sessionInformation <- function() {
[13:23:06.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:06.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:06.033]                       search = base::search(), system = base::Sys.info())
[13:23:06.033]                   }
[13:23:06.033]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:06.033]                     cond$call), session = sessionInformation(), 
[13:23:06.033]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:06.033]                   signalCondition(cond)
[13:23:06.033]                 }
[13:23:06.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:06.033]                 "immediateCondition"))) {
[13:23:06.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:06.033]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:06.033]                   if (TRUE && !signal) {
[13:23:06.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.033]                     {
[13:23:06.033]                       inherits <- base::inherits
[13:23:06.033]                       invokeRestart <- base::invokeRestart
[13:23:06.033]                       is.null <- base::is.null
[13:23:06.033]                       muffled <- FALSE
[13:23:06.033]                       if (inherits(cond, "message")) {
[13:23:06.033]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.033]                         if (muffled) 
[13:23:06.033]                           invokeRestart("muffleMessage")
[13:23:06.033]                       }
[13:23:06.033]                       else if (inherits(cond, "warning")) {
[13:23:06.033]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.033]                         if (muffled) 
[13:23:06.033]                           invokeRestart("muffleWarning")
[13:23:06.033]                       }
[13:23:06.033]                       else if (inherits(cond, "condition")) {
[13:23:06.033]                         if (!is.null(pattern)) {
[13:23:06.033]                           computeRestarts <- base::computeRestarts
[13:23:06.033]                           grepl <- base::grepl
[13:23:06.033]                           restarts <- computeRestarts(cond)
[13:23:06.033]                           for (restart in restarts) {
[13:23:06.033]                             name <- restart$name
[13:23:06.033]                             if (is.null(name)) 
[13:23:06.033]                               next
[13:23:06.033]                             if (!grepl(pattern, name)) 
[13:23:06.033]                               next
[13:23:06.033]                             invokeRestart(restart)
[13:23:06.033]                             muffled <- TRUE
[13:23:06.033]                             break
[13:23:06.033]                           }
[13:23:06.033]                         }
[13:23:06.033]                       }
[13:23:06.033]                       invisible(muffled)
[13:23:06.033]                     }
[13:23:06.033]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.033]                   }
[13:23:06.033]                 }
[13:23:06.033]                 else {
[13:23:06.033]                   if (TRUE) {
[13:23:06.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.033]                     {
[13:23:06.033]                       inherits <- base::inherits
[13:23:06.033]                       invokeRestart <- base::invokeRestart
[13:23:06.033]                       is.null <- base::is.null
[13:23:06.033]                       muffled <- FALSE
[13:23:06.033]                       if (inherits(cond, "message")) {
[13:23:06.033]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.033]                         if (muffled) 
[13:23:06.033]                           invokeRestart("muffleMessage")
[13:23:06.033]                       }
[13:23:06.033]                       else if (inherits(cond, "warning")) {
[13:23:06.033]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.033]                         if (muffled) 
[13:23:06.033]                           invokeRestart("muffleWarning")
[13:23:06.033]                       }
[13:23:06.033]                       else if (inherits(cond, "condition")) {
[13:23:06.033]                         if (!is.null(pattern)) {
[13:23:06.033]                           computeRestarts <- base::computeRestarts
[13:23:06.033]                           grepl <- base::grepl
[13:23:06.033]                           restarts <- computeRestarts(cond)
[13:23:06.033]                           for (restart in restarts) {
[13:23:06.033]                             name <- restart$name
[13:23:06.033]                             if (is.null(name)) 
[13:23:06.033]                               next
[13:23:06.033]                             if (!grepl(pattern, name)) 
[13:23:06.033]                               next
[13:23:06.033]                             invokeRestart(restart)
[13:23:06.033]                             muffled <- TRUE
[13:23:06.033]                             break
[13:23:06.033]                           }
[13:23:06.033]                         }
[13:23:06.033]                       }
[13:23:06.033]                       invisible(muffled)
[13:23:06.033]                     }
[13:23:06.033]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.033]                   }
[13:23:06.033]                 }
[13:23:06.033]             }
[13:23:06.033]         }))
[13:23:06.033]     }, error = function(ex) {
[13:23:06.033]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:06.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.033]                 ...future.rng), started = ...future.startTime, 
[13:23:06.033]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:06.033]             version = "1.8"), class = "FutureResult")
[13:23:06.033]     }, finally = {
[13:23:06.033]         if (!identical(...future.workdir, getwd())) 
[13:23:06.033]             setwd(...future.workdir)
[13:23:06.033]         {
[13:23:06.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:06.033]                 ...future.oldOptions$nwarnings <- NULL
[13:23:06.033]             }
[13:23:06.033]             base::options(...future.oldOptions)
[13:23:06.033]             if (.Platform$OS.type == "windows") {
[13:23:06.033]                 old_names <- names(...future.oldEnvVars)
[13:23:06.033]                 envs <- base::Sys.getenv()
[13:23:06.033]                 names <- names(envs)
[13:23:06.033]                 common <- intersect(names, old_names)
[13:23:06.033]                 added <- setdiff(names, old_names)
[13:23:06.033]                 removed <- setdiff(old_names, names)
[13:23:06.033]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:06.033]                   envs[common]]
[13:23:06.033]                 NAMES <- toupper(changed)
[13:23:06.033]                 args <- list()
[13:23:06.033]                 for (kk in seq_along(NAMES)) {
[13:23:06.033]                   name <- changed[[kk]]
[13:23:06.033]                   NAME <- NAMES[[kk]]
[13:23:06.033]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.033]                     next
[13:23:06.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.033]                 }
[13:23:06.033]                 NAMES <- toupper(added)
[13:23:06.033]                 for (kk in seq_along(NAMES)) {
[13:23:06.033]                   name <- added[[kk]]
[13:23:06.033]                   NAME <- NAMES[[kk]]
[13:23:06.033]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.033]                     next
[13:23:06.033]                   args[[name]] <- ""
[13:23:06.033]                 }
[13:23:06.033]                 NAMES <- toupper(removed)
[13:23:06.033]                 for (kk in seq_along(NAMES)) {
[13:23:06.033]                   name <- removed[[kk]]
[13:23:06.033]                   NAME <- NAMES[[kk]]
[13:23:06.033]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.033]                     next
[13:23:06.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.033]                 }
[13:23:06.033]                 if (length(args) > 0) 
[13:23:06.033]                   base::do.call(base::Sys.setenv, args = args)
[13:23:06.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:06.033]             }
[13:23:06.033]             else {
[13:23:06.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:06.033]             }
[13:23:06.033]             {
[13:23:06.033]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:06.033]                   0L) {
[13:23:06.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:06.033]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:06.033]                   base::options(opts)
[13:23:06.033]                 }
[13:23:06.033]                 {
[13:23:06.033]                   {
[13:23:06.033]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:06.033]                     NULL
[13:23:06.033]                   }
[13:23:06.033]                   options(future.plan = NULL)
[13:23:06.033]                   if (is.na(NA_character_)) 
[13:23:06.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:06.033]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:06.033]                     envir = parent.frame()) 
[13:23:06.033]                   {
[13:23:06.033]                     default_workers <- missing(workers)
[13:23:06.033]                     if (is.function(workers)) 
[13:23:06.033]                       workers <- workers()
[13:23:06.033]                     workers <- structure(as.integer(workers), 
[13:23:06.033]                       class = class(workers))
[13:23:06.033]                     stop_if_not(is.finite(workers), workers >= 
[13:23:06.033]                       1L)
[13:23:06.033]                     if ((workers == 1L && !inherits(workers, 
[13:23:06.033]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:06.033]                       if (default_workers) 
[13:23:06.033]                         supportsMulticore(warn = TRUE)
[13:23:06.033]                       return(sequential(..., envir = envir))
[13:23:06.033]                     }
[13:23:06.033]                     oopts <- options(mc.cores = workers)
[13:23:06.033]                     on.exit(options(oopts))
[13:23:06.033]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:06.033]                       envir = envir)
[13:23:06.033]                     if (!future$lazy) 
[13:23:06.033]                       future <- run(future)
[13:23:06.033]                     invisible(future)
[13:23:06.033]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:06.033]                 }
[13:23:06.033]             }
[13:23:06.033]         }
[13:23:06.033]     })
[13:23:06.033]     if (TRUE) {
[13:23:06.033]         base::sink(type = "output", split = FALSE)
[13:23:06.033]         if (TRUE) {
[13:23:06.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:06.033]         }
[13:23:06.033]         else {
[13:23:06.033]             ...future.result["stdout"] <- base::list(NULL)
[13:23:06.033]         }
[13:23:06.033]         base::close(...future.stdout)
[13:23:06.033]         ...future.stdout <- NULL
[13:23:06.033]     }
[13:23:06.033]     ...future.result$conditions <- ...future.conditions
[13:23:06.033]     ...future.result$finished <- base::Sys.time()
[13:23:06.033]     ...future.result
[13:23:06.033] }
[13:23:06.036] requestCore(): workers = 2
[13:23:06.040] MulticoreFuture started
[13:23:06.040] - Launch lazy future ... done
[13:23:06.040] run() for ‘MulticoreFuture’ ... done
List of 6
[13:23:06.041] plan(): Setting new future strategy stack:
 $ a:[13:23:06.041] List of future strategies:
[13:23:06.041] 1. sequential:
[13:23:06.041]    - args: function (..., envir = parent.frame())
[13:23:06.041]    - tweaked: FALSE
[13:23:06.041]    - call: NULL
 num 1
 $ b:[13:23:06.042] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d55b2418> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5aeaa80> 
 $  : NULL
 $  : NULL
 $  :[13:23:06.045] plan(): Setting new future strategy stack:
 num 6
List of 6
[13:23:06.045] List of future strategies:
[13:23:06.045] 1. multicore:
[13:23:06.045]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:06.045]    - tweaked: FALSE
[13:23:06.045]    - call: plan(strategy)
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d55b2418> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5aeaa80> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] [13:23:06.051] plan(): nbrOfWorkers() = 2
"a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:06.056] resolve() on list ...
[13:23:06.056]  recursive: 0
[13:23:06.056]  length: 6
[13:23:06.056]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:06.056] signalConditionsASAP(numeric, pos=1) ...
[13:23:06.057] - nx: 6
[13:23:06.057] - relay: TRUE
[13:23:06.057] - stdout: TRUE
[13:23:06.057] - signal: TRUE
[13:23:06.057] - resignal: FALSE
[13:23:06.057] - force: TRUE
[13:23:06.057] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.058] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.058]  - until=2
[13:23:06.058]  - relaying element #2
[13:23:06.058] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.058] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.058] signalConditionsASAP(NULL, pos=1) ... done
[13:23:06.058]  length: 5 (resolved future 1)
[13:23:06.059] Future #2
[13:23:06.059] result() for MulticoreFuture ...
[13:23:06.060] result() for MulticoreFuture ...
[13:23:06.060] result() for MulticoreFuture ... done
[13:23:06.060] result() for MulticoreFuture ... done
[13:23:06.061] result() for MulticoreFuture ...
[13:23:06.061] result() for MulticoreFuture ... done
[13:23:06.061] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:06.061] - nx: 6
[13:23:06.061] - relay: TRUE
[13:23:06.061] - stdout: TRUE
[13:23:06.061] - signal: TRUE
[13:23:06.062] - resignal: FALSE
[13:23:06.062] - force: TRUE
[13:23:06.062] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.062] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.062]  - until=2
[13:23:06.062]  - relaying element #2
[13:23:06.062] result() for MulticoreFuture ...
[13:23:06.062] result() for MulticoreFuture ... done
[13:23:06.063] result() for MulticoreFuture ...
[13:23:06.063] result() for MulticoreFuture ... done
[13:23:06.063] result() for MulticoreFuture ...
[13:23:06.063] result() for MulticoreFuture ... done
[13:23:06.063] result() for MulticoreFuture ...
[13:23:06.063] result() for MulticoreFuture ... done
[13:23:06.064] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.064] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.064] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:06.064]  length: 4 (resolved future 2)
[13:23:06.064] Future #3
[13:23:06.065] result() for MulticoreFuture ...
[13:23:06.065] result() for MulticoreFuture ...
[13:23:06.065] result() for MulticoreFuture ... done
[13:23:06.066] result() for MulticoreFuture ... done
[13:23:06.066] result() for MulticoreFuture ...
[13:23:06.066] result() for MulticoreFuture ... done
[13:23:06.066] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:06.066] - nx: 6
[13:23:06.066] - relay: TRUE
[13:23:06.066] - stdout: TRUE
[13:23:06.067] - signal: TRUE
[13:23:06.067] - resignal: FALSE
[13:23:06.067] - force: TRUE
[13:23:06.067] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.067] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.067]  - until=3
[13:23:06.067]  - relaying element #3
[13:23:06.067] result() for MulticoreFuture ...
[13:23:06.068] result() for MulticoreFuture ... done
[13:23:06.068] result() for MulticoreFuture ...
[13:23:06.068] result() for MulticoreFuture ... done
[13:23:06.068] result() for MulticoreFuture ...
[13:23:06.068] result() for MulticoreFuture ... done
[13:23:06.068] result() for MulticoreFuture ...
[13:23:06.068] result() for MulticoreFuture ... done
[13:23:06.069] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.069] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.069] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:06.069]  length: 3 (resolved future 3)
[13:23:06.069] signalConditionsASAP(NULL, pos=4) ...
[13:23:06.069] - nx: 6
[13:23:06.069] - relay: TRUE
[13:23:06.069] - stdout: TRUE
[13:23:06.069] - signal: TRUE
[13:23:06.070] - resignal: FALSE
[13:23:06.070] - force: TRUE
[13:23:06.070] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.070] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.070]  - until=5
[13:23:06.070]  - relaying element #5
[13:23:06.070] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:06.070] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.070] signalConditionsASAP(NULL, pos=4) ... done
[13:23:06.071]  length: 2 (resolved future 4)
[13:23:06.071] signalConditionsASAP(NULL, pos=5) ...
[13:23:06.071] - nx: 6
[13:23:06.071] - relay: TRUE
[13:23:06.071] - stdout: TRUE
[13:23:06.071] - signal: TRUE
[13:23:06.071] - resignal: FALSE
[13:23:06.071] - force: TRUE
[13:23:06.071] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:06.071] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.072]  - until=6
[13:23:06.072]  - relaying element #6
[13:23:06.072] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:06.072] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.072] signalConditionsASAP(NULL, pos=5) ... done
[13:23:06.072]  length: 1 (resolved future 5)
[13:23:06.072] signalConditionsASAP(numeric, pos=6) ...
[13:23:06.072] - nx: 6
[13:23:06.075] - relay: TRUE
[13:23:06.075] - stdout: TRUE
[13:23:06.075] - signal: TRUE
[13:23:06.076] - resignal: FALSE
[13:23:06.076] - force: TRUE
[13:23:06.076] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:06.076] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.076]  - until=6
[13:23:06.076] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:06.077] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.077] signalConditionsASAP(numeric, pos=6) ... done
[13:23:06.077]  length: 0 (resolved future 6)
[13:23:06.077] Relaying remaining futures
[13:23:06.077] signalConditionsASAP(NULL, pos=0) ...
[13:23:06.077] - nx: 6
[13:23:06.077] - relay: TRUE
[13:23:06.078] - stdout: TRUE
[13:23:06.078] - signal: TRUE
[13:23:06.078] - resignal: FALSE
[13:23:06.078] - force: TRUE
[13:23:06.078] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:06.078] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:06.078] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:06.078] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.078] signalConditionsASAP(NULL, pos=0) ... done
[13:23:06.079] resolve() on list ... DONE
[13:23:06.079] result() for MulticoreFuture ...
[13:23:06.079] result() for MulticoreFuture ... done
[13:23:06.079] result() for MulticoreFuture ...
[13:23:06.079] result() for MulticoreFuture ... done
[13:23:06.079] result() for MulticoreFuture ...
[13:23:06.079] result() for MulticoreFuture ... done
[13:23:06.079] result() for MulticoreFuture ...
[13:23:06.080] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:23:06.084] getGlobalsAndPackages() ...
[13:23:06.084] Searching for globals...
[13:23:06.084] 
[13:23:06.084] Searching for globals ... DONE
[13:23:06.085] - globals: [0] <none>
[13:23:06.085] getGlobalsAndPackages() ... DONE
[13:23:06.085] run() for ‘Future’ ...
[13:23:06.085] - state: ‘created’
[13:23:06.085] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:06.090] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:06.090] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:06.090]   - Field: ‘label’
[13:23:06.090]   - Field: ‘local’
[13:23:06.090]   - Field: ‘owner’
[13:23:06.091]   - Field: ‘envir’
[13:23:06.091]   - Field: ‘workers’
[13:23:06.091]   - Field: ‘packages’
[13:23:06.091]   - Field: ‘gc’
[13:23:06.091]   - Field: ‘job’
[13:23:06.091]   - Field: ‘conditions’
[13:23:06.091]   - Field: ‘expr’
[13:23:06.091]   - Field: ‘uuid’
[13:23:06.091]   - Field: ‘seed’
[13:23:06.091]   - Field: ‘version’
[13:23:06.092]   - Field: ‘result’
[13:23:06.092]   - Field: ‘asynchronous’
[13:23:06.092]   - Field: ‘calls’
[13:23:06.092]   - Field: ‘globals’
[13:23:06.092]   - Field: ‘stdout’
[13:23:06.092]   - Field: ‘earlySignal’
[13:23:06.092]   - Field: ‘lazy’
[13:23:06.092]   - Field: ‘state’
[13:23:06.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:06.093] - Launch lazy future ...
[13:23:06.093] Packages needed by the future expression (n = 0): <none>
[13:23:06.093] Packages needed by future strategies (n = 0): <none>
[13:23:06.093] {
[13:23:06.093]     {
[13:23:06.093]         {
[13:23:06.093]             ...future.startTime <- base::Sys.time()
[13:23:06.093]             {
[13:23:06.093]                 {
[13:23:06.093]                   {
[13:23:06.093]                     {
[13:23:06.093]                       base::local({
[13:23:06.093]                         has_future <- base::requireNamespace("future", 
[13:23:06.093]                           quietly = TRUE)
[13:23:06.093]                         if (has_future) {
[13:23:06.093]                           ns <- base::getNamespace("future")
[13:23:06.093]                           version <- ns[[".package"]][["version"]]
[13:23:06.093]                           if (is.null(version)) 
[13:23:06.093]                             version <- utils::packageVersion("future")
[13:23:06.093]                         }
[13:23:06.093]                         else {
[13:23:06.093]                           version <- NULL
[13:23:06.093]                         }
[13:23:06.093]                         if (!has_future || version < "1.8.0") {
[13:23:06.093]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:06.093]                             "", base::R.version$version.string), 
[13:23:06.093]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:06.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:06.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:06.093]                               "release", "version")], collapse = " "), 
[13:23:06.093]                             hostname = base::Sys.info()[["nodename"]])
[13:23:06.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:06.093]                             info)
[13:23:06.093]                           info <- base::paste(info, collapse = "; ")
[13:23:06.093]                           if (!has_future) {
[13:23:06.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:06.093]                               info)
[13:23:06.093]                           }
[13:23:06.093]                           else {
[13:23:06.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:06.093]                               info, version)
[13:23:06.093]                           }
[13:23:06.093]                           base::stop(msg)
[13:23:06.093]                         }
[13:23:06.093]                       })
[13:23:06.093]                     }
[13:23:06.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:06.093]                     base::options(mc.cores = 1L)
[13:23:06.093]                   }
[13:23:06.093]                   options(future.plan = NULL)
[13:23:06.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:06.093]                 }
[13:23:06.093]                 ...future.workdir <- getwd()
[13:23:06.093]             }
[13:23:06.093]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:06.093]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:06.093]         }
[13:23:06.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:06.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:06.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:06.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:06.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:06.093]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:06.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:06.093]             base::names(...future.oldOptions))
[13:23:06.093]     }
[13:23:06.093]     if (FALSE) {
[13:23:06.093]     }
[13:23:06.093]     else {
[13:23:06.093]         if (TRUE) {
[13:23:06.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:06.093]                 open = "w")
[13:23:06.093]         }
[13:23:06.093]         else {
[13:23:06.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:06.093]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:06.093]         }
[13:23:06.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:06.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:06.093]             base::sink(type = "output", split = FALSE)
[13:23:06.093]             base::close(...future.stdout)
[13:23:06.093]         }, add = TRUE)
[13:23:06.093]     }
[13:23:06.093]     ...future.frame <- base::sys.nframe()
[13:23:06.093]     ...future.conditions <- base::list()
[13:23:06.093]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:06.093]     if (FALSE) {
[13:23:06.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:06.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:06.093]     }
[13:23:06.093]     ...future.result <- base::tryCatch({
[13:23:06.093]         base::withCallingHandlers({
[13:23:06.093]             ...future.value <- base::withVisible(base::local({
[13:23:06.093]                 withCallingHandlers({
[13:23:06.093]                   2
[13:23:06.093]                 }, immediateCondition = function(cond) {
[13:23:06.093]                   save_rds <- function (object, pathname, ...) 
[13:23:06.093]                   {
[13:23:06.093]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:06.093]                     if (file_test("-f", pathname_tmp)) {
[13:23:06.093]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.093]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:06.093]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.093]                         fi_tmp[["mtime"]])
[13:23:06.093]                     }
[13:23:06.093]                     tryCatch({
[13:23:06.093]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:06.093]                     }, error = function(ex) {
[13:23:06.093]                       msg <- conditionMessage(ex)
[13:23:06.093]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.093]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:06.093]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.093]                         fi_tmp[["mtime"]], msg)
[13:23:06.093]                       ex$message <- msg
[13:23:06.093]                       stop(ex)
[13:23:06.093]                     })
[13:23:06.093]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:06.093]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:06.093]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:06.093]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.093]                       fi <- file.info(pathname)
[13:23:06.093]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:06.093]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.093]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:06.093]                         fi[["size"]], fi[["mtime"]])
[13:23:06.093]                       stop(msg)
[13:23:06.093]                     }
[13:23:06.093]                     invisible(pathname)
[13:23:06.093]                   }
[13:23:06.093]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:06.093]                     rootPath = tempdir()) 
[13:23:06.093]                   {
[13:23:06.093]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:06.093]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:06.093]                       tmpdir = path, fileext = ".rds")
[13:23:06.093]                     save_rds(obj, file)
[13:23:06.093]                   }
[13:23:06.093]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:06.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.093]                   {
[13:23:06.093]                     inherits <- base::inherits
[13:23:06.093]                     invokeRestart <- base::invokeRestart
[13:23:06.093]                     is.null <- base::is.null
[13:23:06.093]                     muffled <- FALSE
[13:23:06.093]                     if (inherits(cond, "message")) {
[13:23:06.093]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:06.093]                       if (muffled) 
[13:23:06.093]                         invokeRestart("muffleMessage")
[13:23:06.093]                     }
[13:23:06.093]                     else if (inherits(cond, "warning")) {
[13:23:06.093]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:06.093]                       if (muffled) 
[13:23:06.093]                         invokeRestart("muffleWarning")
[13:23:06.093]                     }
[13:23:06.093]                     else if (inherits(cond, "condition")) {
[13:23:06.093]                       if (!is.null(pattern)) {
[13:23:06.093]                         computeRestarts <- base::computeRestarts
[13:23:06.093]                         grepl <- base::grepl
[13:23:06.093]                         restarts <- computeRestarts(cond)
[13:23:06.093]                         for (restart in restarts) {
[13:23:06.093]                           name <- restart$name
[13:23:06.093]                           if (is.null(name)) 
[13:23:06.093]                             next
[13:23:06.093]                           if (!grepl(pattern, name)) 
[13:23:06.093]                             next
[13:23:06.093]                           invokeRestart(restart)
[13:23:06.093]                           muffled <- TRUE
[13:23:06.093]                           break
[13:23:06.093]                         }
[13:23:06.093]                       }
[13:23:06.093]                     }
[13:23:06.093]                     invisible(muffled)
[13:23:06.093]                   }
[13:23:06.093]                   muffleCondition(cond)
[13:23:06.093]                 })
[13:23:06.093]             }))
[13:23:06.093]             future::FutureResult(value = ...future.value$value, 
[13:23:06.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.093]                   ...future.rng), globalenv = if (FALSE) 
[13:23:06.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:06.093]                     ...future.globalenv.names))
[13:23:06.093]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:06.093]         }, condition = base::local({
[13:23:06.093]             c <- base::c
[13:23:06.093]             inherits <- base::inherits
[13:23:06.093]             invokeRestart <- base::invokeRestart
[13:23:06.093]             length <- base::length
[13:23:06.093]             list <- base::list
[13:23:06.093]             seq.int <- base::seq.int
[13:23:06.093]             signalCondition <- base::signalCondition
[13:23:06.093]             sys.calls <- base::sys.calls
[13:23:06.093]             `[[` <- base::`[[`
[13:23:06.093]             `+` <- base::`+`
[13:23:06.093]             `<<-` <- base::`<<-`
[13:23:06.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:06.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:06.093]                   3L)]
[13:23:06.093]             }
[13:23:06.093]             function(cond) {
[13:23:06.093]                 is_error <- inherits(cond, "error")
[13:23:06.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:06.093]                   NULL)
[13:23:06.093]                 if (is_error) {
[13:23:06.093]                   sessionInformation <- function() {
[13:23:06.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:06.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:06.093]                       search = base::search(), system = base::Sys.info())
[13:23:06.093]                   }
[13:23:06.093]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:06.093]                     cond$call), session = sessionInformation(), 
[13:23:06.093]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:06.093]                   signalCondition(cond)
[13:23:06.093]                 }
[13:23:06.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:06.093]                 "immediateCondition"))) {
[13:23:06.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:06.093]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:06.093]                   if (TRUE && !signal) {
[13:23:06.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.093]                     {
[13:23:06.093]                       inherits <- base::inherits
[13:23:06.093]                       invokeRestart <- base::invokeRestart
[13:23:06.093]                       is.null <- base::is.null
[13:23:06.093]                       muffled <- FALSE
[13:23:06.093]                       if (inherits(cond, "message")) {
[13:23:06.093]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.093]                         if (muffled) 
[13:23:06.093]                           invokeRestart("muffleMessage")
[13:23:06.093]                       }
[13:23:06.093]                       else if (inherits(cond, "warning")) {
[13:23:06.093]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.093]                         if (muffled) 
[13:23:06.093]                           invokeRestart("muffleWarning")
[13:23:06.093]                       }
[13:23:06.093]                       else if (inherits(cond, "condition")) {
[13:23:06.093]                         if (!is.null(pattern)) {
[13:23:06.093]                           computeRestarts <- base::computeRestarts
[13:23:06.093]                           grepl <- base::grepl
[13:23:06.093]                           restarts <- computeRestarts(cond)
[13:23:06.093]                           for (restart in restarts) {
[13:23:06.093]                             name <- restart$name
[13:23:06.093]                             if (is.null(name)) 
[13:23:06.093]                               next
[13:23:06.093]                             if (!grepl(pattern, name)) 
[13:23:06.093]                               next
[13:23:06.093]                             invokeRestart(restart)
[13:23:06.093]                             muffled <- TRUE
[13:23:06.093]                             break
[13:23:06.093]                           }
[13:23:06.093]                         }
[13:23:06.093]                       }
[13:23:06.093]                       invisible(muffled)
[13:23:06.093]                     }
[13:23:06.093]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.093]                   }
[13:23:06.093]                 }
[13:23:06.093]                 else {
[13:23:06.093]                   if (TRUE) {
[13:23:06.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.093]                     {
[13:23:06.093]                       inherits <- base::inherits
[13:23:06.093]                       invokeRestart <- base::invokeRestart
[13:23:06.093]                       is.null <- base::is.null
[13:23:06.093]                       muffled <- FALSE
[13:23:06.093]                       if (inherits(cond, "message")) {
[13:23:06.093]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.093]                         if (muffled) 
[13:23:06.093]                           invokeRestart("muffleMessage")
[13:23:06.093]                       }
[13:23:06.093]                       else if (inherits(cond, "warning")) {
[13:23:06.093]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.093]                         if (muffled) 
[13:23:06.093]                           invokeRestart("muffleWarning")
[13:23:06.093]                       }
[13:23:06.093]                       else if (inherits(cond, "condition")) {
[13:23:06.093]                         if (!is.null(pattern)) {
[13:23:06.093]                           computeRestarts <- base::computeRestarts
[13:23:06.093]                           grepl <- base::grepl
[13:23:06.093]                           restarts <- computeRestarts(cond)
[13:23:06.093]                           for (restart in restarts) {
[13:23:06.093]                             name <- restart$name
[13:23:06.093]                             if (is.null(name)) 
[13:23:06.093]                               next
[13:23:06.093]                             if (!grepl(pattern, name)) 
[13:23:06.093]                               next
[13:23:06.093]                             invokeRestart(restart)
[13:23:06.093]                             muffled <- TRUE
[13:23:06.093]                             break
[13:23:06.093]                           }
[13:23:06.093]                         }
[13:23:06.093]                       }
[13:23:06.093]                       invisible(muffled)
[13:23:06.093]                     }
[13:23:06.093]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.093]                   }
[13:23:06.093]                 }
[13:23:06.093]             }
[13:23:06.093]         }))
[13:23:06.093]     }, error = function(ex) {
[13:23:06.093]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:06.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.093]                 ...future.rng), started = ...future.startTime, 
[13:23:06.093]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:06.093]             version = "1.8"), class = "FutureResult")
[13:23:06.093]     }, finally = {
[13:23:06.093]         if (!identical(...future.workdir, getwd())) 
[13:23:06.093]             setwd(...future.workdir)
[13:23:06.093]         {
[13:23:06.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:06.093]                 ...future.oldOptions$nwarnings <- NULL
[13:23:06.093]             }
[13:23:06.093]             base::options(...future.oldOptions)
[13:23:06.093]             if (.Platform$OS.type == "windows") {
[13:23:06.093]                 old_names <- names(...future.oldEnvVars)
[13:23:06.093]                 envs <- base::Sys.getenv()
[13:23:06.093]                 names <- names(envs)
[13:23:06.093]                 common <- intersect(names, old_names)
[13:23:06.093]                 added <- setdiff(names, old_names)
[13:23:06.093]                 removed <- setdiff(old_names, names)
[13:23:06.093]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:06.093]                   envs[common]]
[13:23:06.093]                 NAMES <- toupper(changed)
[13:23:06.093]                 args <- list()
[13:23:06.093]                 for (kk in seq_along(NAMES)) {
[13:23:06.093]                   name <- changed[[kk]]
[13:23:06.093]                   NAME <- NAMES[[kk]]
[13:23:06.093]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.093]                     next
[13:23:06.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.093]                 }
[13:23:06.093]                 NAMES <- toupper(added)
[13:23:06.093]                 for (kk in seq_along(NAMES)) {
[13:23:06.093]                   name <- added[[kk]]
[13:23:06.093]                   NAME <- NAMES[[kk]]
[13:23:06.093]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.093]                     next
[13:23:06.093]                   args[[name]] <- ""
[13:23:06.093]                 }
[13:23:06.093]                 NAMES <- toupper(removed)
[13:23:06.093]                 for (kk in seq_along(NAMES)) {
[13:23:06.093]                   name <- removed[[kk]]
[13:23:06.093]                   NAME <- NAMES[[kk]]
[13:23:06.093]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.093]                     next
[13:23:06.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.093]                 }
[13:23:06.093]                 if (length(args) > 0) 
[13:23:06.093]                   base::do.call(base::Sys.setenv, args = args)
[13:23:06.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:06.093]             }
[13:23:06.093]             else {
[13:23:06.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:06.093]             }
[13:23:06.093]             {
[13:23:06.093]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:06.093]                   0L) {
[13:23:06.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:06.093]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:06.093]                   base::options(opts)
[13:23:06.093]                 }
[13:23:06.093]                 {
[13:23:06.093]                   {
[13:23:06.093]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:06.093]                     NULL
[13:23:06.093]                   }
[13:23:06.093]                   options(future.plan = NULL)
[13:23:06.093]                   if (is.na(NA_character_)) 
[13:23:06.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:06.093]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:06.093]                     envir = parent.frame()) 
[13:23:06.093]                   {
[13:23:06.093]                     default_workers <- missing(workers)
[13:23:06.093]                     if (is.function(workers)) 
[13:23:06.093]                       workers <- workers()
[13:23:06.093]                     workers <- structure(as.integer(workers), 
[13:23:06.093]                       class = class(workers))
[13:23:06.093]                     stop_if_not(is.finite(workers), workers >= 
[13:23:06.093]                       1L)
[13:23:06.093]                     if ((workers == 1L && !inherits(workers, 
[13:23:06.093]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:06.093]                       if (default_workers) 
[13:23:06.093]                         supportsMulticore(warn = TRUE)
[13:23:06.093]                       return(sequential(..., envir = envir))
[13:23:06.093]                     }
[13:23:06.093]                     oopts <- options(mc.cores = workers)
[13:23:06.093]                     on.exit(options(oopts))
[13:23:06.093]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:06.093]                       envir = envir)
[13:23:06.093]                     if (!future$lazy) 
[13:23:06.093]                       future <- run(future)
[13:23:06.093]                     invisible(future)
[13:23:06.093]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:06.093]                 }
[13:23:06.093]             }
[13:23:06.093]         }
[13:23:06.093]     })
[13:23:06.093]     if (TRUE) {
[13:23:06.093]         base::sink(type = "output", split = FALSE)
[13:23:06.093]         if (TRUE) {
[13:23:06.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:06.093]         }
[13:23:06.093]         else {
[13:23:06.093]             ...future.result["stdout"] <- base::list(NULL)
[13:23:06.093]         }
[13:23:06.093]         base::close(...future.stdout)
[13:23:06.093]         ...future.stdout <- NULL
[13:23:06.093]     }
[13:23:06.093]     ...future.result$conditions <- ...future.conditions
[13:23:06.093]     ...future.result$finished <- base::Sys.time()
[13:23:06.093]     ...future.result
[13:23:06.093] }
[13:23:06.096] requestCore(): workers = 2
[13:23:06.099] MulticoreFuture started
[13:23:06.099] - Launch lazy future ... done
[13:23:06.099] run() for ‘MulticoreFuture’ ... done
[13:23:06.100] getGlobalsAndPackages() ...
[13:23:06.100] Searching for globals...
[13:23:06.100] plan(): Setting new future strategy stack:
[13:23:06.101] 
[13:23:06.100] List of future strategies:
[13:23:06.100] 1. sequential:
[13:23:06.100]    - args: function (..., envir = parent.frame())
[13:23:06.100]    - tweaked: FALSE
[13:23:06.100]    - call: NULL
[13:23:06.101] Searching for globals ... DONE
[13:23:06.101] - globals: [0] <none>
[13:23:06.101] plan(): nbrOfWorkers() = 1
[13:23:06.101] getGlobalsAndPackages() ... DONE
[13:23:06.102] run() for ‘Future’ ...
[13:23:06.102] - state: ‘created’
[13:23:06.102] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:06.103] plan(): Setting new future strategy stack:
[13:23:06.104] List of future strategies:
[13:23:06.104] 1. multicore:
[13:23:06.104]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:06.104]    - tweaked: FALSE
[13:23:06.104]    - call: plan(strategy)
[13:23:06.108] plan(): nbrOfWorkers() = 2
[13:23:06.108] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:06.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:06.109]   - Field: ‘label’
[13:23:06.109]   - Field: ‘local’
[13:23:06.109]   - Field: ‘owner’
[13:23:06.109]   - Field: ‘envir’
[13:23:06.110]   - Field: ‘workers’
[13:23:06.110]   - Field: ‘packages’
[13:23:06.110]   - Field: ‘gc’
[13:23:06.110]   - Field: ‘job’
[13:23:06.110]   - Field: ‘conditions’
[13:23:06.110]   - Field: ‘expr’
[13:23:06.110]   - Field: ‘uuid’
[13:23:06.111]   - Field: ‘seed’
[13:23:06.111]   - Field: ‘version’
[13:23:06.111]   - Field: ‘result’
[13:23:06.111]   - Field: ‘asynchronous’
[13:23:06.111]   - Field: ‘calls’
[13:23:06.111]   - Field: ‘globals’
[13:23:06.112]   - Field: ‘stdout’
[13:23:06.112]   - Field: ‘earlySignal’
[13:23:06.112]   - Field: ‘lazy’
[13:23:06.112]   - Field: ‘state’
[13:23:06.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:06.113] - Launch lazy future ...
[13:23:06.113] Packages needed by the future expression (n = 0): <none>
[13:23:06.113] Packages needed by future strategies (n = 0): <none>
[13:23:06.114] {
[13:23:06.114]     {
[13:23:06.114]         {
[13:23:06.114]             ...future.startTime <- base::Sys.time()
[13:23:06.114]             {
[13:23:06.114]                 {
[13:23:06.114]                   {
[13:23:06.114]                     {
[13:23:06.114]                       base::local({
[13:23:06.114]                         has_future <- base::requireNamespace("future", 
[13:23:06.114]                           quietly = TRUE)
[13:23:06.114]                         if (has_future) {
[13:23:06.114]                           ns <- base::getNamespace("future")
[13:23:06.114]                           version <- ns[[".package"]][["version"]]
[13:23:06.114]                           if (is.null(version)) 
[13:23:06.114]                             version <- utils::packageVersion("future")
[13:23:06.114]                         }
[13:23:06.114]                         else {
[13:23:06.114]                           version <- NULL
[13:23:06.114]                         }
[13:23:06.114]                         if (!has_future || version < "1.8.0") {
[13:23:06.114]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:06.114]                             "", base::R.version$version.string), 
[13:23:06.114]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:06.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:06.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:06.114]                               "release", "version")], collapse = " "), 
[13:23:06.114]                             hostname = base::Sys.info()[["nodename"]])
[13:23:06.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:06.114]                             info)
[13:23:06.114]                           info <- base::paste(info, collapse = "; ")
[13:23:06.114]                           if (!has_future) {
[13:23:06.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:06.114]                               info)
[13:23:06.114]                           }
[13:23:06.114]                           else {
[13:23:06.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:06.114]                               info, version)
[13:23:06.114]                           }
[13:23:06.114]                           base::stop(msg)
[13:23:06.114]                         }
[13:23:06.114]                       })
[13:23:06.114]                     }
[13:23:06.114]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:06.114]                     base::options(mc.cores = 1L)
[13:23:06.114]                   }
[13:23:06.114]                   options(future.plan = NULL)
[13:23:06.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:06.114]                 }
[13:23:06.114]                 ...future.workdir <- getwd()
[13:23:06.114]             }
[13:23:06.114]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:06.114]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:06.114]         }
[13:23:06.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:06.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:06.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:06.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:06.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:06.114]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:06.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:06.114]             base::names(...future.oldOptions))
[13:23:06.114]     }
[13:23:06.114]     if (FALSE) {
[13:23:06.114]     }
[13:23:06.114]     else {
[13:23:06.114]         if (TRUE) {
[13:23:06.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:06.114]                 open = "w")
[13:23:06.114]         }
[13:23:06.114]         else {
[13:23:06.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:06.114]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:06.114]         }
[13:23:06.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:06.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:06.114]             base::sink(type = "output", split = FALSE)
[13:23:06.114]             base::close(...future.stdout)
[13:23:06.114]         }, add = TRUE)
[13:23:06.114]     }
[13:23:06.114]     ...future.frame <- base::sys.nframe()
[13:23:06.114]     ...future.conditions <- base::list()
[13:23:06.114]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:06.114]     if (FALSE) {
[13:23:06.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:06.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:06.114]     }
[13:23:06.114]     ...future.result <- base::tryCatch({
[13:23:06.114]         base::withCallingHandlers({
[13:23:06.114]             ...future.value <- base::withVisible(base::local({
[13:23:06.114]                 withCallingHandlers({
[13:23:06.114]                   NULL
[13:23:06.114]                 }, immediateCondition = function(cond) {
[13:23:06.114]                   save_rds <- function (object, pathname, ...) 
[13:23:06.114]                   {
[13:23:06.114]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:06.114]                     if (file_test("-f", pathname_tmp)) {
[13:23:06.114]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.114]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:06.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.114]                         fi_tmp[["mtime"]])
[13:23:06.114]                     }
[13:23:06.114]                     tryCatch({
[13:23:06.114]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:06.114]                     }, error = function(ex) {
[13:23:06.114]                       msg <- conditionMessage(ex)
[13:23:06.114]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.114]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:06.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.114]                         fi_tmp[["mtime"]], msg)
[13:23:06.114]                       ex$message <- msg
[13:23:06.114]                       stop(ex)
[13:23:06.114]                     })
[13:23:06.114]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:06.114]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:06.114]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:06.114]                       fi_tmp <- file.info(pathname_tmp)
[13:23:06.114]                       fi <- file.info(pathname)
[13:23:06.114]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:06.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:06.114]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:06.114]                         fi[["size"]], fi[["mtime"]])
[13:23:06.114]                       stop(msg)
[13:23:06.114]                     }
[13:23:06.114]                     invisible(pathname)
[13:23:06.114]                   }
[13:23:06.114]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:06.114]                     rootPath = tempdir()) 
[13:23:06.114]                   {
[13:23:06.114]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:06.114]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:06.114]                       tmpdir = path, fileext = ".rds")
[13:23:06.114]                     save_rds(obj, file)
[13:23:06.114]                   }
[13:23:06.114]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:06.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.114]                   {
[13:23:06.114]                     inherits <- base::inherits
[13:23:06.114]                     invokeRestart <- base::invokeRestart
[13:23:06.114]                     is.null <- base::is.null
[13:23:06.114]                     muffled <- FALSE
[13:23:06.114]                     if (inherits(cond, "message")) {
[13:23:06.114]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:06.114]                       if (muffled) 
[13:23:06.114]                         invokeRestart("muffleMessage")
[13:23:06.114]                     }
[13:23:06.114]                     else if (inherits(cond, "warning")) {
[13:23:06.114]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:06.114]                       if (muffled) 
[13:23:06.114]                         invokeRestart("muffleWarning")
[13:23:06.114]                     }
[13:23:06.114]                     else if (inherits(cond, "condition")) {
[13:23:06.114]                       if (!is.null(pattern)) {
[13:23:06.114]                         computeRestarts <- base::computeRestarts
[13:23:06.114]                         grepl <- base::grepl
[13:23:06.114]                         restarts <- computeRestarts(cond)
[13:23:06.114]                         for (restart in restarts) {
[13:23:06.114]                           name <- restart$name
[13:23:06.114]                           if (is.null(name)) 
[13:23:06.114]                             next
[13:23:06.114]                           if (!grepl(pattern, name)) 
[13:23:06.114]                             next
[13:23:06.114]                           invokeRestart(restart)
[13:23:06.114]                           muffled <- TRUE
[13:23:06.114]                           break
[13:23:06.114]                         }
[13:23:06.114]                       }
[13:23:06.114]                     }
[13:23:06.114]                     invisible(muffled)
[13:23:06.114]                   }
[13:23:06.114]                   muffleCondition(cond)
[13:23:06.114]                 })
[13:23:06.114]             }))
[13:23:06.114]             future::FutureResult(value = ...future.value$value, 
[13:23:06.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.114]                   ...future.rng), globalenv = if (FALSE) 
[13:23:06.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:06.114]                     ...future.globalenv.names))
[13:23:06.114]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:06.114]         }, condition = base::local({
[13:23:06.114]             c <- base::c
[13:23:06.114]             inherits <- base::inherits
[13:23:06.114]             invokeRestart <- base::invokeRestart
[13:23:06.114]             length <- base::length
[13:23:06.114]             list <- base::list
[13:23:06.114]             seq.int <- base::seq.int
[13:23:06.114]             signalCondition <- base::signalCondition
[13:23:06.114]             sys.calls <- base::sys.calls
[13:23:06.114]             `[[` <- base::`[[`
[13:23:06.114]             `+` <- base::`+`
[13:23:06.114]             `<<-` <- base::`<<-`
[13:23:06.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:06.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:06.114]                   3L)]
[13:23:06.114]             }
[13:23:06.114]             function(cond) {
[13:23:06.114]                 is_error <- inherits(cond, "error")
[13:23:06.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:06.114]                   NULL)
[13:23:06.114]                 if (is_error) {
[13:23:06.114]                   sessionInformation <- function() {
[13:23:06.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:06.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:06.114]                       search = base::search(), system = base::Sys.info())
[13:23:06.114]                   }
[13:23:06.114]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:06.114]                     cond$call), session = sessionInformation(), 
[13:23:06.114]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:06.114]                   signalCondition(cond)
[13:23:06.114]                 }
[13:23:06.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:06.114]                 "immediateCondition"))) {
[13:23:06.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:06.114]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:06.114]                   if (TRUE && !signal) {
[13:23:06.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.114]                     {
[13:23:06.114]                       inherits <- base::inherits
[13:23:06.114]                       invokeRestart <- base::invokeRestart
[13:23:06.114]                       is.null <- base::is.null
[13:23:06.114]                       muffled <- FALSE
[13:23:06.114]                       if (inherits(cond, "message")) {
[13:23:06.114]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.114]                         if (muffled) 
[13:23:06.114]                           invokeRestart("muffleMessage")
[13:23:06.114]                       }
[13:23:06.114]                       else if (inherits(cond, "warning")) {
[13:23:06.114]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.114]                         if (muffled) 
[13:23:06.114]                           invokeRestart("muffleWarning")
[13:23:06.114]                       }
[13:23:06.114]                       else if (inherits(cond, "condition")) {
[13:23:06.114]                         if (!is.null(pattern)) {
[13:23:06.114]                           computeRestarts <- base::computeRestarts
[13:23:06.114]                           grepl <- base::grepl
[13:23:06.114]                           restarts <- computeRestarts(cond)
[13:23:06.114]                           for (restart in restarts) {
[13:23:06.114]                             name <- restart$name
[13:23:06.114]                             if (is.null(name)) 
[13:23:06.114]                               next
[13:23:06.114]                             if (!grepl(pattern, name)) 
[13:23:06.114]                               next
[13:23:06.114]                             invokeRestart(restart)
[13:23:06.114]                             muffled <- TRUE
[13:23:06.114]                             break
[13:23:06.114]                           }
[13:23:06.114]                         }
[13:23:06.114]                       }
[13:23:06.114]                       invisible(muffled)
[13:23:06.114]                     }
[13:23:06.114]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.114]                   }
[13:23:06.114]                 }
[13:23:06.114]                 else {
[13:23:06.114]                   if (TRUE) {
[13:23:06.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.114]                     {
[13:23:06.114]                       inherits <- base::inherits
[13:23:06.114]                       invokeRestart <- base::invokeRestart
[13:23:06.114]                       is.null <- base::is.null
[13:23:06.114]                       muffled <- FALSE
[13:23:06.114]                       if (inherits(cond, "message")) {
[13:23:06.114]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.114]                         if (muffled) 
[13:23:06.114]                           invokeRestart("muffleMessage")
[13:23:06.114]                       }
[13:23:06.114]                       else if (inherits(cond, "warning")) {
[13:23:06.114]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.114]                         if (muffled) 
[13:23:06.114]                           invokeRestart("muffleWarning")
[13:23:06.114]                       }
[13:23:06.114]                       else if (inherits(cond, "condition")) {
[13:23:06.114]                         if (!is.null(pattern)) {
[13:23:06.114]                           computeRestarts <- base::computeRestarts
[13:23:06.114]                           grepl <- base::grepl
[13:23:06.114]                           restarts <- computeRestarts(cond)
[13:23:06.114]                           for (restart in restarts) {
[13:23:06.114]                             name <- restart$name
[13:23:06.114]                             if (is.null(name)) 
[13:23:06.114]                               next
[13:23:06.114]                             if (!grepl(pattern, name)) 
[13:23:06.114]                               next
[13:23:06.114]                             invokeRestart(restart)
[13:23:06.114]                             muffled <- TRUE
[13:23:06.114]                             break
[13:23:06.114]                           }
[13:23:06.114]                         }
[13:23:06.114]                       }
[13:23:06.114]                       invisible(muffled)
[13:23:06.114]                     }
[13:23:06.114]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.114]                   }
[13:23:06.114]                 }
[13:23:06.114]             }
[13:23:06.114]         }))
[13:23:06.114]     }, error = function(ex) {
[13:23:06.114]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:06.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.114]                 ...future.rng), started = ...future.startTime, 
[13:23:06.114]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:06.114]             version = "1.8"), class = "FutureResult")
[13:23:06.114]     }, finally = {
[13:23:06.114]         if (!identical(...future.workdir, getwd())) 
[13:23:06.114]             setwd(...future.workdir)
[13:23:06.114]         {
[13:23:06.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:06.114]                 ...future.oldOptions$nwarnings <- NULL
[13:23:06.114]             }
[13:23:06.114]             base::options(...future.oldOptions)
[13:23:06.114]             if (.Platform$OS.type == "windows") {
[13:23:06.114]                 old_names <- names(...future.oldEnvVars)
[13:23:06.114]                 envs <- base::Sys.getenv()
[13:23:06.114]                 names <- names(envs)
[13:23:06.114]                 common <- intersect(names, old_names)
[13:23:06.114]                 added <- setdiff(names, old_names)
[13:23:06.114]                 removed <- setdiff(old_names, names)
[13:23:06.114]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:06.114]                   envs[common]]
[13:23:06.114]                 NAMES <- toupper(changed)
[13:23:06.114]                 args <- list()
[13:23:06.114]                 for (kk in seq_along(NAMES)) {
[13:23:06.114]                   name <- changed[[kk]]
[13:23:06.114]                   NAME <- NAMES[[kk]]
[13:23:06.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.114]                     next
[13:23:06.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.114]                 }
[13:23:06.114]                 NAMES <- toupper(added)
[13:23:06.114]                 for (kk in seq_along(NAMES)) {
[13:23:06.114]                   name <- added[[kk]]
[13:23:06.114]                   NAME <- NAMES[[kk]]
[13:23:06.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.114]                     next
[13:23:06.114]                   args[[name]] <- ""
[13:23:06.114]                 }
[13:23:06.114]                 NAMES <- toupper(removed)
[13:23:06.114]                 for (kk in seq_along(NAMES)) {
[13:23:06.114]                   name <- removed[[kk]]
[13:23:06.114]                   NAME <- NAMES[[kk]]
[13:23:06.114]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.114]                     next
[13:23:06.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.114]                 }
[13:23:06.114]                 if (length(args) > 0) 
[13:23:06.114]                   base::do.call(base::Sys.setenv, args = args)
[13:23:06.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:06.114]             }
[13:23:06.114]             else {
[13:23:06.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:06.114]             }
[13:23:06.114]             {
[13:23:06.114]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:06.114]                   0L) {
[13:23:06.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:06.114]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:06.114]                   base::options(opts)
[13:23:06.114]                 }
[13:23:06.114]                 {
[13:23:06.114]                   {
[13:23:06.114]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:06.114]                     NULL
[13:23:06.114]                   }
[13:23:06.114]                   options(future.plan = NULL)
[13:23:06.114]                   if (is.na(NA_character_)) 
[13:23:06.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:06.114]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:06.114]                     envir = parent.frame()) 
[13:23:06.114]                   {
[13:23:06.114]                     default_workers <- missing(workers)
[13:23:06.114]                     if (is.function(workers)) 
[13:23:06.114]                       workers <- workers()
[13:23:06.114]                     workers <- structure(as.integer(workers), 
[13:23:06.114]                       class = class(workers))
[13:23:06.114]                     stop_if_not(is.finite(workers), workers >= 
[13:23:06.114]                       1L)
[13:23:06.114]                     if ((workers == 1L && !inherits(workers, 
[13:23:06.114]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:06.114]                       if (default_workers) 
[13:23:06.114]                         supportsMulticore(warn = TRUE)
[13:23:06.114]                       return(sequential(..., envir = envir))
[13:23:06.114]                     }
[13:23:06.114]                     oopts <- options(mc.cores = workers)
[13:23:06.114]                     on.exit(options(oopts))
[13:23:06.114]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:06.114]                       envir = envir)
[13:23:06.114]                     if (!future$lazy) 
[13:23:06.114]                       future <- run(future)
[13:23:06.114]                     invisible(future)
[13:23:06.114]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:06.114]                 }
[13:23:06.114]             }
[13:23:06.114]         }
[13:23:06.114]     })
[13:23:06.114]     if (TRUE) {
[13:23:06.114]         base::sink(type = "output", split = FALSE)
[13:23:06.114]         if (TRUE) {
[13:23:06.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:06.114]         }
[13:23:06.114]         else {
[13:23:06.114]             ...future.result["stdout"] <- base::list(NULL)
[13:23:06.114]         }
[13:23:06.114]         base::close(...future.stdout)
[13:23:06.114]         ...future.stdout <- NULL
[13:23:06.114]     }
[13:23:06.114]     ...future.result$conditions <- ...future.conditions
[13:23:06.114]     ...future.result$finished <- base::Sys.time()
[13:23:06.114]     ...future.result
[13:23:06.114] }
[13:23:06.118] requestCore(): workers = 2
[13:23:06.121] MulticoreFuture started
[13:23:06.122] - Launch lazy future ... done
[13:23:06.122] run() for ‘MulticoreFuture’ ... done
List of 6
[13:23:06.122] plan(): Setting new future strategy stack:
 $ a:[13:23:06.123] List of future strategies:
[13:23:06.123] 1. sequential:
[13:23:06.123]    - args: function (..., envir = parent.frame())
[13:23:06.123]    - tweaked: FALSE
[13:23:06.123]    - call: NULL
 num 1
 $ b:[13:23:06.124] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d42143d8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5527110> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:23:06.126] plan(): Setting new future strategy stack:
List of 6
 $ a:[13:23:06.126] List of future strategies:
[13:23:06.126] 1. multicore:
[13:23:06.126]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:06.126]    - tweaked: FALSE
[13:23:06.126]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d42143d8> 
 $ c:[13:23:06.132] plan(): nbrOfWorkers() = 2
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5527110> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:06.144] resolve() on list ...
[13:23:06.145]  recursive: 0
[13:23:06.145]  length: 6
[13:23:06.145]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:06.145] signalConditionsASAP(numeric, pos=1) ...
[13:23:06.145] - nx: 6
[13:23:06.146] - relay: TRUE
[13:23:06.146] - stdout: TRUE
[13:23:06.146] - signal: TRUE
[13:23:06.146] - resignal: FALSE
[13:23:06.146] - force: TRUE
[13:23:06.146] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.146] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.147]  - until=2
[13:23:06.147]  - relaying element #2
[13:23:06.147] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.147] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.147] signalConditionsASAP(NULL, pos=1) ... done
[13:23:06.147]  length: 5 (resolved future 1)
[13:23:06.148] Future #2
[13:23:06.148] result() for MulticoreFuture ...
[13:23:06.149] result() for MulticoreFuture ...
[13:23:06.149] result() for MulticoreFuture ... done
[13:23:06.149] result() for MulticoreFuture ... done
[13:23:06.149] result() for MulticoreFuture ...
[13:23:06.149] result() for MulticoreFuture ... done
[13:23:06.150] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:06.150] - nx: 6
[13:23:06.150] - relay: TRUE
[13:23:06.150] - stdout: TRUE
[13:23:06.150] - signal: TRUE
[13:23:06.150] - resignal: FALSE
[13:23:06.150] - force: TRUE
[13:23:06.150] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.151] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.151]  - until=2
[13:23:06.151]  - relaying element #2
[13:23:06.151] result() for MulticoreFuture ...
[13:23:06.151] result() for MulticoreFuture ... done
[13:23:06.151] result() for MulticoreFuture ...
[13:23:06.151] result() for MulticoreFuture ... done
[13:23:06.152] result() for MulticoreFuture ...
[13:23:06.152] result() for MulticoreFuture ... done
[13:23:06.152] result() for MulticoreFuture ...
[13:23:06.152] result() for MulticoreFuture ... done
[13:23:06.152] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.152] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.152] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:06.153]  length: 4 (resolved future 2)
[13:23:06.153] Future #3
[13:23:06.153] result() for MulticoreFuture ...
[13:23:06.154] result() for MulticoreFuture ...
[13:23:06.154] result() for MulticoreFuture ... done
[13:23:06.154] result() for MulticoreFuture ... done
[13:23:06.154] result() for MulticoreFuture ...
[13:23:06.154] result() for MulticoreFuture ... done
[13:23:06.155] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:06.155] - nx: 6
[13:23:06.155] - relay: TRUE
[13:23:06.155] - stdout: TRUE
[13:23:06.155] - signal: TRUE
[13:23:06.155] - resignal: FALSE
[13:23:06.155] - force: TRUE
[13:23:06.155] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.155] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.156]  - until=3
[13:23:06.156]  - relaying element #3
[13:23:06.156] result() for MulticoreFuture ...
[13:23:06.156] result() for MulticoreFuture ... done
[13:23:06.156] result() for MulticoreFuture ...
[13:23:06.156] result() for MulticoreFuture ... done
[13:23:06.156] result() for MulticoreFuture ...
[13:23:06.156] result() for MulticoreFuture ... done
[13:23:06.157] result() for MulticoreFuture ...
[13:23:06.157] result() for MulticoreFuture ... done
[13:23:06.157] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.157] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.157] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:06.157]  length: 3 (resolved future 3)
[13:23:06.157] signalConditionsASAP(NULL, pos=4) ...
[13:23:06.157] - nx: 6
[13:23:06.157] - relay: TRUE
[13:23:06.158] - stdout: TRUE
[13:23:06.158] - signal: TRUE
[13:23:06.158] - resignal: FALSE
[13:23:06.158] - force: TRUE
[13:23:06.158] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.158] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.158]  - until=5
[13:23:06.158]  - relaying element #5
[13:23:06.158] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:06.158] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.159] signalConditionsASAP(NULL, pos=4) ... done
[13:23:06.159]  length: 2 (resolved future 4)
[13:23:06.159] signalConditionsASAP(NULL, pos=5) ...
[13:23:06.159] - nx: 6
[13:23:06.159] - relay: TRUE
[13:23:06.159] - stdout: TRUE
[13:23:06.159] - signal: TRUE
[13:23:06.159] - resignal: FALSE
[13:23:06.159] - force: TRUE
[13:23:06.159] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:06.160] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.160]  - until=6
[13:23:06.160]  - relaying element #6
[13:23:06.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:06.160] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.160] signalConditionsASAP(NULL, pos=5) ... done
[13:23:06.160]  length: 1 (resolved future 5)
[13:23:06.160] signalConditionsASAP(numeric, pos=6) ...
[13:23:06.161] - nx: 6
[13:23:06.161] - relay: TRUE
[13:23:06.161] - stdout: TRUE
[13:23:06.161] - signal: TRUE
[13:23:06.161] - resignal: FALSE
[13:23:06.161] - force: TRUE
[13:23:06.161] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:06.161] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.161]  - until=6
[13:23:06.161] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:06.161] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.162] signalConditionsASAP(numeric, pos=6) ... done
[13:23:06.162]  length: 0 (resolved future 6)
[13:23:06.162] Relaying remaining futures
[13:23:06.162] signalConditionsASAP(NULL, pos=0) ...
[13:23:06.162] - nx: 6
[13:23:06.162] - relay: TRUE
[13:23:06.162] - stdout: TRUE
[13:23:06.162] - signal: TRUE
[13:23:06.162] - resignal: FALSE
[13:23:06.162] - force: TRUE
[13:23:06.163] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:06.163] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:06.163] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:06.163] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:06.163] signalConditionsASAP(NULL, pos=0) ... done
[13:23:06.163] resolve() on list ... DONE
[13:23:06.163] result() for MulticoreFuture ...
[13:23:06.163] result() for MulticoreFuture ... done
[13:23:06.163] result() for MulticoreFuture ...
[13:23:06.164] result() for MulticoreFuture ... done
[13:23:06.164] result() for MulticoreFuture ...
[13:23:06.164] result() for MulticoreFuture ... done
[13:23:06.164] result() for MulticoreFuture ...
[13:23:06.164] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[13:23:06.171] plan(): Setting new future strategy stack:
[13:23:06.172] List of future strategies:
[13:23:06.172] 1. multisession:
[13:23:06.172]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:06.172]    - tweaked: FALSE
[13:23:06.172]    - call: plan(strategy)
[13:23:06.172] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:23:06.172] multisession:
[13:23:06.172] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:06.172] - tweaked: FALSE
[13:23:06.172] - call: plan(strategy)
[13:23:06.179] getGlobalsAndPackages() ...
[13:23:06.180] Not searching for globals
[13:23:06.180] - globals: [0] <none>
[13:23:06.180] getGlobalsAndPackages() ... DONE
[13:23:06.181] [local output] makeClusterPSOCK() ...
[13:23:06.234] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:23:06.235] [local output] Base port: 11867
[13:23:06.235] [local output] Getting setup options for 2 cluster nodes ...
[13:23:06.235] [local output]  - Node 1 of 2 ...
[13:23:06.236] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:06.236] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMODyD9/worker.rank=1.parallelly.parent=84369.149916fe16ed9.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpMODyD9/worker.rank=1.parallelly.parent=84369.149916fe16ed9.pid")'’
[13:23:06.435] - Possible to infer worker's PID: TRUE
[13:23:06.435] [local output] Rscript port: 11867

[13:23:06.435] [local output]  - Node 2 of 2 ...
[13:23:06.436] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:06.436] [local output] Rscript port: 11867

[13:23:06.437] [local output] Getting setup options for 2 cluster nodes ... done
[13:23:06.437] [local output]  - Parallel setup requested for some PSOCK nodes
[13:23:06.437] [local output] Setting up PSOCK nodes in parallel
[13:23:06.438] List of 36
[13:23:06.438]  $ worker          : chr "localhost"
[13:23:06.438]   ..- attr(*, "localhost")= logi TRUE
[13:23:06.438]  $ master          : chr "localhost"
[13:23:06.438]  $ port            : int 11867
[13:23:06.438]  $ connectTimeout  : num 120
[13:23:06.438]  $ timeout         : num 2592000
[13:23:06.438]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:23:06.438]  $ homogeneous     : logi TRUE
[13:23:06.438]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:23:06.438]  $ rscript_envs    : NULL
[13:23:06.438]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:06.438]  $ rscript_startup : NULL
[13:23:06.438]  $ rscript_sh      : chr "sh"
[13:23:06.438]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:06.438]  $ methods         : logi TRUE
[13:23:06.438]  $ socketOptions   : chr "no-delay"
[13:23:06.438]  $ useXDR          : logi FALSE
[13:23:06.438]  $ outfile         : chr "/dev/null"
[13:23:06.438]  $ renice          : int NA
[13:23:06.438]  $ rshcmd          : NULL
[13:23:06.438]  $ user            : chr(0) 
[13:23:06.438]  $ revtunnel       : logi FALSE
[13:23:06.438]  $ rshlogfile      : NULL
[13:23:06.438]  $ rshopts         : chr(0) 
[13:23:06.438]  $ rank            : int 1
[13:23:06.438]  $ manual          : logi FALSE
[13:23:06.438]  $ dryrun          : logi FALSE
[13:23:06.438]  $ quiet           : logi FALSE
[13:23:06.438]  $ setup_strategy  : chr "parallel"
[13:23:06.438]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:06.438]  $ pidfile         : chr "/tmp/RtmpMODyD9/worker.rank=1.parallelly.parent=84369.149916fe16ed9.pid"
[13:23:06.438]  $ rshcmd_label    : NULL
[13:23:06.438]  $ rsh_call        : NULL
[13:23:06.438]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:06.438]  $ localMachine    : logi TRUE
[13:23:06.438]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:23:06.438]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:23:06.438]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:23:06.438]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:23:06.438]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:23:06.438]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:23:06.438]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:23:06.438]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:23:06.438]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:23:06.438]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:23:06.438]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:23:06.438]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:23:06.438]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:23:06.438]  $ arguments       :List of 28
[13:23:06.438]   ..$ worker          : chr "localhost"
[13:23:06.438]   ..$ master          : NULL
[13:23:06.438]   ..$ port            : int 11867
[13:23:06.438]   ..$ connectTimeout  : num 120
[13:23:06.438]   ..$ timeout         : num 2592000
[13:23:06.438]   ..$ rscript         : NULL
[13:23:06.438]   ..$ homogeneous     : NULL
[13:23:06.438]   ..$ rscript_args    : NULL
[13:23:06.438]   ..$ rscript_envs    : NULL
[13:23:06.438]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:06.438]   ..$ rscript_startup : NULL
[13:23:06.438]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:23:06.438]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:06.438]   ..$ methods         : logi TRUE
[13:23:06.438]   ..$ socketOptions   : chr "no-delay"
[13:23:06.438]   ..$ useXDR          : logi FALSE
[13:23:06.438]   ..$ outfile         : chr "/dev/null"
[13:23:06.438]   ..$ renice          : int NA
[13:23:06.438]   ..$ rshcmd          : NULL
[13:23:06.438]   ..$ user            : NULL
[13:23:06.438]   ..$ revtunnel       : logi NA
[13:23:06.438]   ..$ rshlogfile      : NULL
[13:23:06.438]   ..$ rshopts         : NULL
[13:23:06.438]   ..$ rank            : int 1
[13:23:06.438]   ..$ manual          : logi FALSE
[13:23:06.438]   ..$ dryrun          : logi FALSE
[13:23:06.438]   ..$ quiet           : logi FALSE
[13:23:06.438]   ..$ setup_strategy  : chr "parallel"
[13:23:06.438]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:23:06.455] [local output] System call to launch all workers:
[13:23:06.455] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMODyD9/worker.rank=1.parallelly.parent=84369.149916fe16ed9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11867 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:23:06.456] [local output] Starting PSOCK main server
[13:23:06.462] [local output] Workers launched
[13:23:06.462] [local output] Waiting for workers to connect back
[13:23:06.462]  - [local output] 0 workers out of 2 ready
[13:23:06.716]  - [local output] 0 workers out of 2 ready
[13:23:06.717]  - [local output] 1 workers out of 2 ready
[13:23:06.721]  - [local output] 1 workers out of 2 ready
[13:23:06.721]  - [local output] 2 workers out of 2 ready
[13:23:06.722] [local output] Launching of workers completed
[13:23:06.722] [local output] Collecting session information from workers
[13:23:06.723] [local output]  - Worker #1 of 2
[13:23:06.723] [local output]  - Worker #2 of 2
[13:23:06.724] [local output] makeClusterPSOCK() ... done
[13:23:06.735] Packages needed by the future expression (n = 0): <none>
[13:23:06.735] Packages needed by future strategies (n = 0): <none>
[13:23:06.736] {
[13:23:06.736]     {
[13:23:06.736]         {
[13:23:06.736]             ...future.startTime <- base::Sys.time()
[13:23:06.736]             {
[13:23:06.736]                 {
[13:23:06.736]                   {
[13:23:06.736]                     {
[13:23:06.736]                       base::local({
[13:23:06.736]                         has_future <- base::requireNamespace("future", 
[13:23:06.736]                           quietly = TRUE)
[13:23:06.736]                         if (has_future) {
[13:23:06.736]                           ns <- base::getNamespace("future")
[13:23:06.736]                           version <- ns[[".package"]][["version"]]
[13:23:06.736]                           if (is.null(version)) 
[13:23:06.736]                             version <- utils::packageVersion("future")
[13:23:06.736]                         }
[13:23:06.736]                         else {
[13:23:06.736]                           version <- NULL
[13:23:06.736]                         }
[13:23:06.736]                         if (!has_future || version < "1.8.0") {
[13:23:06.736]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:06.736]                             "", base::R.version$version.string), 
[13:23:06.736]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:06.736]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:06.736]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:06.736]                               "release", "version")], collapse = " "), 
[13:23:06.736]                             hostname = base::Sys.info()[["nodename"]])
[13:23:06.736]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:06.736]                             info)
[13:23:06.736]                           info <- base::paste(info, collapse = "; ")
[13:23:06.736]                           if (!has_future) {
[13:23:06.736]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:06.736]                               info)
[13:23:06.736]                           }
[13:23:06.736]                           else {
[13:23:06.736]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:06.736]                               info, version)
[13:23:06.736]                           }
[13:23:06.736]                           base::stop(msg)
[13:23:06.736]                         }
[13:23:06.736]                       })
[13:23:06.736]                     }
[13:23:06.736]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:06.736]                     base::options(mc.cores = 1L)
[13:23:06.736]                   }
[13:23:06.736]                   options(future.plan = NULL)
[13:23:06.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:06.736]                 }
[13:23:06.736]                 ...future.workdir <- getwd()
[13:23:06.736]             }
[13:23:06.736]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:06.736]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:06.736]         }
[13:23:06.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:06.736]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:06.736]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:06.736]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:06.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:06.736]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:06.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:06.736]             base::names(...future.oldOptions))
[13:23:06.736]     }
[13:23:06.736]     if (FALSE) {
[13:23:06.736]     }
[13:23:06.736]     else {
[13:23:06.736]         if (TRUE) {
[13:23:06.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:06.736]                 open = "w")
[13:23:06.736]         }
[13:23:06.736]         else {
[13:23:06.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:06.736]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:06.736]         }
[13:23:06.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:06.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:06.736]             base::sink(type = "output", split = FALSE)
[13:23:06.736]             base::close(...future.stdout)
[13:23:06.736]         }, add = TRUE)
[13:23:06.736]     }
[13:23:06.736]     ...future.frame <- base::sys.nframe()
[13:23:06.736]     ...future.conditions <- base::list()
[13:23:06.736]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:06.736]     if (FALSE) {
[13:23:06.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:06.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:06.736]     }
[13:23:06.736]     ...future.result <- base::tryCatch({
[13:23:06.736]         base::withCallingHandlers({
[13:23:06.736]             ...future.value <- base::withVisible(base::local({
[13:23:06.736]                 ...future.makeSendCondition <- base::local({
[13:23:06.736]                   sendCondition <- NULL
[13:23:06.736]                   function(frame = 1L) {
[13:23:06.736]                     if (is.function(sendCondition)) 
[13:23:06.736]                       return(sendCondition)
[13:23:06.736]                     ns <- getNamespace("parallel")
[13:23:06.736]                     if (exists("sendData", mode = "function", 
[13:23:06.736]                       envir = ns)) {
[13:23:06.736]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:06.736]                         envir = ns)
[13:23:06.736]                       envir <- sys.frame(frame)
[13:23:06.736]                       master <- NULL
[13:23:06.736]                       while (!identical(envir, .GlobalEnv) && 
[13:23:06.736]                         !identical(envir, emptyenv())) {
[13:23:06.736]                         if (exists("master", mode = "list", envir = envir, 
[13:23:06.736]                           inherits = FALSE)) {
[13:23:06.736]                           master <- get("master", mode = "list", 
[13:23:06.736]                             envir = envir, inherits = FALSE)
[13:23:06.736]                           if (inherits(master, c("SOCKnode", 
[13:23:06.736]                             "SOCK0node"))) {
[13:23:06.736]                             sendCondition <<- function(cond) {
[13:23:06.736]                               data <- list(type = "VALUE", value = cond, 
[13:23:06.736]                                 success = TRUE)
[13:23:06.736]                               parallel_sendData(master, data)
[13:23:06.736]                             }
[13:23:06.736]                             return(sendCondition)
[13:23:06.736]                           }
[13:23:06.736]                         }
[13:23:06.736]                         frame <- frame + 1L
[13:23:06.736]                         envir <- sys.frame(frame)
[13:23:06.736]                       }
[13:23:06.736]                     }
[13:23:06.736]                     sendCondition <<- function(cond) NULL
[13:23:06.736]                   }
[13:23:06.736]                 })
[13:23:06.736]                 withCallingHandlers({
[13:23:06.736]                   NA
[13:23:06.736]                 }, immediateCondition = function(cond) {
[13:23:06.736]                   sendCondition <- ...future.makeSendCondition()
[13:23:06.736]                   sendCondition(cond)
[13:23:06.736]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.736]                   {
[13:23:06.736]                     inherits <- base::inherits
[13:23:06.736]                     invokeRestart <- base::invokeRestart
[13:23:06.736]                     is.null <- base::is.null
[13:23:06.736]                     muffled <- FALSE
[13:23:06.736]                     if (inherits(cond, "message")) {
[13:23:06.736]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:06.736]                       if (muffled) 
[13:23:06.736]                         invokeRestart("muffleMessage")
[13:23:06.736]                     }
[13:23:06.736]                     else if (inherits(cond, "warning")) {
[13:23:06.736]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:06.736]                       if (muffled) 
[13:23:06.736]                         invokeRestart("muffleWarning")
[13:23:06.736]                     }
[13:23:06.736]                     else if (inherits(cond, "condition")) {
[13:23:06.736]                       if (!is.null(pattern)) {
[13:23:06.736]                         computeRestarts <- base::computeRestarts
[13:23:06.736]                         grepl <- base::grepl
[13:23:06.736]                         restarts <- computeRestarts(cond)
[13:23:06.736]                         for (restart in restarts) {
[13:23:06.736]                           name <- restart$name
[13:23:06.736]                           if (is.null(name)) 
[13:23:06.736]                             next
[13:23:06.736]                           if (!grepl(pattern, name)) 
[13:23:06.736]                             next
[13:23:06.736]                           invokeRestart(restart)
[13:23:06.736]                           muffled <- TRUE
[13:23:06.736]                           break
[13:23:06.736]                         }
[13:23:06.736]                       }
[13:23:06.736]                     }
[13:23:06.736]                     invisible(muffled)
[13:23:06.736]                   }
[13:23:06.736]                   muffleCondition(cond)
[13:23:06.736]                 })
[13:23:06.736]             }))
[13:23:06.736]             future::FutureResult(value = ...future.value$value, 
[13:23:06.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.736]                   ...future.rng), globalenv = if (FALSE) 
[13:23:06.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:06.736]                     ...future.globalenv.names))
[13:23:06.736]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:06.736]         }, condition = base::local({
[13:23:06.736]             c <- base::c
[13:23:06.736]             inherits <- base::inherits
[13:23:06.736]             invokeRestart <- base::invokeRestart
[13:23:06.736]             length <- base::length
[13:23:06.736]             list <- base::list
[13:23:06.736]             seq.int <- base::seq.int
[13:23:06.736]             signalCondition <- base::signalCondition
[13:23:06.736]             sys.calls <- base::sys.calls
[13:23:06.736]             `[[` <- base::`[[`
[13:23:06.736]             `+` <- base::`+`
[13:23:06.736]             `<<-` <- base::`<<-`
[13:23:06.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:06.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:06.736]                   3L)]
[13:23:06.736]             }
[13:23:06.736]             function(cond) {
[13:23:06.736]                 is_error <- inherits(cond, "error")
[13:23:06.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:06.736]                   NULL)
[13:23:06.736]                 if (is_error) {
[13:23:06.736]                   sessionInformation <- function() {
[13:23:06.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:06.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:06.736]                       search = base::search(), system = base::Sys.info())
[13:23:06.736]                   }
[13:23:06.736]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:06.736]                     cond$call), session = sessionInformation(), 
[13:23:06.736]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:06.736]                   signalCondition(cond)
[13:23:06.736]                 }
[13:23:06.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:06.736]                 "immediateCondition"))) {
[13:23:06.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:06.736]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:06.736]                   if (TRUE && !signal) {
[13:23:06.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.736]                     {
[13:23:06.736]                       inherits <- base::inherits
[13:23:06.736]                       invokeRestart <- base::invokeRestart
[13:23:06.736]                       is.null <- base::is.null
[13:23:06.736]                       muffled <- FALSE
[13:23:06.736]                       if (inherits(cond, "message")) {
[13:23:06.736]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.736]                         if (muffled) 
[13:23:06.736]                           invokeRestart("muffleMessage")
[13:23:06.736]                       }
[13:23:06.736]                       else if (inherits(cond, "warning")) {
[13:23:06.736]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.736]                         if (muffled) 
[13:23:06.736]                           invokeRestart("muffleWarning")
[13:23:06.736]                       }
[13:23:06.736]                       else if (inherits(cond, "condition")) {
[13:23:06.736]                         if (!is.null(pattern)) {
[13:23:06.736]                           computeRestarts <- base::computeRestarts
[13:23:06.736]                           grepl <- base::grepl
[13:23:06.736]                           restarts <- computeRestarts(cond)
[13:23:06.736]                           for (restart in restarts) {
[13:23:06.736]                             name <- restart$name
[13:23:06.736]                             if (is.null(name)) 
[13:23:06.736]                               next
[13:23:06.736]                             if (!grepl(pattern, name)) 
[13:23:06.736]                               next
[13:23:06.736]                             invokeRestart(restart)
[13:23:06.736]                             muffled <- TRUE
[13:23:06.736]                             break
[13:23:06.736]                           }
[13:23:06.736]                         }
[13:23:06.736]                       }
[13:23:06.736]                       invisible(muffled)
[13:23:06.736]                     }
[13:23:06.736]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.736]                   }
[13:23:06.736]                 }
[13:23:06.736]                 else {
[13:23:06.736]                   if (TRUE) {
[13:23:06.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.736]                     {
[13:23:06.736]                       inherits <- base::inherits
[13:23:06.736]                       invokeRestart <- base::invokeRestart
[13:23:06.736]                       is.null <- base::is.null
[13:23:06.736]                       muffled <- FALSE
[13:23:06.736]                       if (inherits(cond, "message")) {
[13:23:06.736]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.736]                         if (muffled) 
[13:23:06.736]                           invokeRestart("muffleMessage")
[13:23:06.736]                       }
[13:23:06.736]                       else if (inherits(cond, "warning")) {
[13:23:06.736]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.736]                         if (muffled) 
[13:23:06.736]                           invokeRestart("muffleWarning")
[13:23:06.736]                       }
[13:23:06.736]                       else if (inherits(cond, "condition")) {
[13:23:06.736]                         if (!is.null(pattern)) {
[13:23:06.736]                           computeRestarts <- base::computeRestarts
[13:23:06.736]                           grepl <- base::grepl
[13:23:06.736]                           restarts <- computeRestarts(cond)
[13:23:06.736]                           for (restart in restarts) {
[13:23:06.736]                             name <- restart$name
[13:23:06.736]                             if (is.null(name)) 
[13:23:06.736]                               next
[13:23:06.736]                             if (!grepl(pattern, name)) 
[13:23:06.736]                               next
[13:23:06.736]                             invokeRestart(restart)
[13:23:06.736]                             muffled <- TRUE
[13:23:06.736]                             break
[13:23:06.736]                           }
[13:23:06.736]                         }
[13:23:06.736]                       }
[13:23:06.736]                       invisible(muffled)
[13:23:06.736]                     }
[13:23:06.736]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.736]                   }
[13:23:06.736]                 }
[13:23:06.736]             }
[13:23:06.736]         }))
[13:23:06.736]     }, error = function(ex) {
[13:23:06.736]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:06.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.736]                 ...future.rng), started = ...future.startTime, 
[13:23:06.736]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:06.736]             version = "1.8"), class = "FutureResult")
[13:23:06.736]     }, finally = {
[13:23:06.736]         if (!identical(...future.workdir, getwd())) 
[13:23:06.736]             setwd(...future.workdir)
[13:23:06.736]         {
[13:23:06.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:06.736]                 ...future.oldOptions$nwarnings <- NULL
[13:23:06.736]             }
[13:23:06.736]             base::options(...future.oldOptions)
[13:23:06.736]             if (.Platform$OS.type == "windows") {
[13:23:06.736]                 old_names <- names(...future.oldEnvVars)
[13:23:06.736]                 envs <- base::Sys.getenv()
[13:23:06.736]                 names <- names(envs)
[13:23:06.736]                 common <- intersect(names, old_names)
[13:23:06.736]                 added <- setdiff(names, old_names)
[13:23:06.736]                 removed <- setdiff(old_names, names)
[13:23:06.736]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:06.736]                   envs[common]]
[13:23:06.736]                 NAMES <- toupper(changed)
[13:23:06.736]                 args <- list()
[13:23:06.736]                 for (kk in seq_along(NAMES)) {
[13:23:06.736]                   name <- changed[[kk]]
[13:23:06.736]                   NAME <- NAMES[[kk]]
[13:23:06.736]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.736]                     next
[13:23:06.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.736]                 }
[13:23:06.736]                 NAMES <- toupper(added)
[13:23:06.736]                 for (kk in seq_along(NAMES)) {
[13:23:06.736]                   name <- added[[kk]]
[13:23:06.736]                   NAME <- NAMES[[kk]]
[13:23:06.736]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.736]                     next
[13:23:06.736]                   args[[name]] <- ""
[13:23:06.736]                 }
[13:23:06.736]                 NAMES <- toupper(removed)
[13:23:06.736]                 for (kk in seq_along(NAMES)) {
[13:23:06.736]                   name <- removed[[kk]]
[13:23:06.736]                   NAME <- NAMES[[kk]]
[13:23:06.736]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.736]                     next
[13:23:06.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.736]                 }
[13:23:06.736]                 if (length(args) > 0) 
[13:23:06.736]                   base::do.call(base::Sys.setenv, args = args)
[13:23:06.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:06.736]             }
[13:23:06.736]             else {
[13:23:06.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:06.736]             }
[13:23:06.736]             {
[13:23:06.736]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:06.736]                   0L) {
[13:23:06.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:06.736]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:06.736]                   base::options(opts)
[13:23:06.736]                 }
[13:23:06.736]                 {
[13:23:06.736]                   {
[13:23:06.736]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:06.736]                     NULL
[13:23:06.736]                   }
[13:23:06.736]                   options(future.plan = NULL)
[13:23:06.736]                   if (is.na(NA_character_)) 
[13:23:06.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:06.736]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:06.736]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:06.736]                     envir = parent.frame()) 
[13:23:06.736]                   {
[13:23:06.736]                     if (is.function(workers)) 
[13:23:06.736]                       workers <- workers()
[13:23:06.736]                     workers <- structure(as.integer(workers), 
[13:23:06.736]                       class = class(workers))
[13:23:06.736]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:06.736]                       workers >= 1)
[13:23:06.736]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:06.736]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:06.736]                     }
[13:23:06.736]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:06.736]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:06.736]                       envir = envir)
[13:23:06.736]                     if (!future$lazy) 
[13:23:06.736]                       future <- run(future)
[13:23:06.736]                     invisible(future)
[13:23:06.736]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:06.736]                 }
[13:23:06.736]             }
[13:23:06.736]         }
[13:23:06.736]     })
[13:23:06.736]     if (TRUE) {
[13:23:06.736]         base::sink(type = "output", split = FALSE)
[13:23:06.736]         if (TRUE) {
[13:23:06.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:06.736]         }
[13:23:06.736]         else {
[13:23:06.736]             ...future.result["stdout"] <- base::list(NULL)
[13:23:06.736]         }
[13:23:06.736]         base::close(...future.stdout)
[13:23:06.736]         ...future.stdout <- NULL
[13:23:06.736]     }
[13:23:06.736]     ...future.result$conditions <- ...future.conditions
[13:23:06.736]     ...future.result$finished <- base::Sys.time()
[13:23:06.736]     ...future.result
[13:23:06.736] }
[13:23:06.793] MultisessionFuture started
[13:23:06.794] result() for ClusterFuture ...
[13:23:06.794] receiveMessageFromWorker() for ClusterFuture ...
[13:23:06.795] - Validating connection of MultisessionFuture
[13:23:06.841] - received message: FutureResult
[13:23:06.841] - Received FutureResult
[13:23:06.842] - Erased future from FutureRegistry
[13:23:06.842] result() for ClusterFuture ...
[13:23:06.842] - result already collected: FutureResult
[13:23:06.842] result() for ClusterFuture ... done
[13:23:06.842] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:06.842] result() for ClusterFuture ... done
[13:23:06.842] result() for ClusterFuture ...
[13:23:06.842] - result already collected: FutureResult
[13:23:06.843] result() for ClusterFuture ... done
[13:23:06.843] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:23:06.847] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:23:06.847] getGlobalsAndPackages() ...
[13:23:06.847] Searching for globals...
[13:23:06.848] 
[13:23:06.848] Searching for globals ... DONE
[13:23:06.848] - globals: [0] <none>
[13:23:06.848] getGlobalsAndPackages() ... DONE
[13:23:06.848] run() for ‘Future’ ...
[13:23:06.848] - state: ‘created’
[13:23:06.849] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:06.863] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:06.864] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:06.864]   - Field: ‘node’
[13:23:06.864]   - Field: ‘label’
[13:23:06.864]   - Field: ‘local’
[13:23:06.864]   - Field: ‘owner’
[13:23:06.864]   - Field: ‘envir’
[13:23:06.864]   - Field: ‘workers’
[13:23:06.865]   - Field: ‘packages’
[13:23:06.865]   - Field: ‘gc’
[13:23:06.865]   - Field: ‘conditions’
[13:23:06.865]   - Field: ‘persistent’
[13:23:06.865]   - Field: ‘expr’
[13:23:06.865]   - Field: ‘uuid’
[13:23:06.865]   - Field: ‘seed’
[13:23:06.865]   - Field: ‘version’
[13:23:06.865]   - Field: ‘result’
[13:23:06.866]   - Field: ‘asynchronous’
[13:23:06.866]   - Field: ‘calls’
[13:23:06.866]   - Field: ‘globals’
[13:23:06.866]   - Field: ‘stdout’
[13:23:06.866]   - Field: ‘earlySignal’
[13:23:06.866]   - Field: ‘lazy’
[13:23:06.866]   - Field: ‘state’
[13:23:06.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:06.867] - Launch lazy future ...
[13:23:06.867] Packages needed by the future expression (n = 0): <none>
[13:23:06.867] Packages needed by future strategies (n = 0): <none>
[13:23:06.868] {
[13:23:06.868]     {
[13:23:06.868]         {
[13:23:06.868]             ...future.startTime <- base::Sys.time()
[13:23:06.868]             {
[13:23:06.868]                 {
[13:23:06.868]                   {
[13:23:06.868]                     {
[13:23:06.868]                       base::local({
[13:23:06.868]                         has_future <- base::requireNamespace("future", 
[13:23:06.868]                           quietly = TRUE)
[13:23:06.868]                         if (has_future) {
[13:23:06.868]                           ns <- base::getNamespace("future")
[13:23:06.868]                           version <- ns[[".package"]][["version"]]
[13:23:06.868]                           if (is.null(version)) 
[13:23:06.868]                             version <- utils::packageVersion("future")
[13:23:06.868]                         }
[13:23:06.868]                         else {
[13:23:06.868]                           version <- NULL
[13:23:06.868]                         }
[13:23:06.868]                         if (!has_future || version < "1.8.0") {
[13:23:06.868]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:06.868]                             "", base::R.version$version.string), 
[13:23:06.868]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:06.868]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:06.868]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:06.868]                               "release", "version")], collapse = " "), 
[13:23:06.868]                             hostname = base::Sys.info()[["nodename"]])
[13:23:06.868]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:06.868]                             info)
[13:23:06.868]                           info <- base::paste(info, collapse = "; ")
[13:23:06.868]                           if (!has_future) {
[13:23:06.868]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:06.868]                               info)
[13:23:06.868]                           }
[13:23:06.868]                           else {
[13:23:06.868]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:06.868]                               info, version)
[13:23:06.868]                           }
[13:23:06.868]                           base::stop(msg)
[13:23:06.868]                         }
[13:23:06.868]                       })
[13:23:06.868]                     }
[13:23:06.868]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:06.868]                     base::options(mc.cores = 1L)
[13:23:06.868]                   }
[13:23:06.868]                   options(future.plan = NULL)
[13:23:06.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:06.868]                 }
[13:23:06.868]                 ...future.workdir <- getwd()
[13:23:06.868]             }
[13:23:06.868]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:06.868]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:06.868]         }
[13:23:06.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:06.868]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:06.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:06.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:06.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:06.868]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:06.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:06.868]             base::names(...future.oldOptions))
[13:23:06.868]     }
[13:23:06.868]     if (FALSE) {
[13:23:06.868]     }
[13:23:06.868]     else {
[13:23:06.868]         if (TRUE) {
[13:23:06.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:06.868]                 open = "w")
[13:23:06.868]         }
[13:23:06.868]         else {
[13:23:06.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:06.868]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:06.868]         }
[13:23:06.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:06.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:06.868]             base::sink(type = "output", split = FALSE)
[13:23:06.868]             base::close(...future.stdout)
[13:23:06.868]         }, add = TRUE)
[13:23:06.868]     }
[13:23:06.868]     ...future.frame <- base::sys.nframe()
[13:23:06.868]     ...future.conditions <- base::list()
[13:23:06.868]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:06.868]     if (FALSE) {
[13:23:06.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:06.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:06.868]     }
[13:23:06.868]     ...future.result <- base::tryCatch({
[13:23:06.868]         base::withCallingHandlers({
[13:23:06.868]             ...future.value <- base::withVisible(base::local({
[13:23:06.868]                 ...future.makeSendCondition <- base::local({
[13:23:06.868]                   sendCondition <- NULL
[13:23:06.868]                   function(frame = 1L) {
[13:23:06.868]                     if (is.function(sendCondition)) 
[13:23:06.868]                       return(sendCondition)
[13:23:06.868]                     ns <- getNamespace("parallel")
[13:23:06.868]                     if (exists("sendData", mode = "function", 
[13:23:06.868]                       envir = ns)) {
[13:23:06.868]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:06.868]                         envir = ns)
[13:23:06.868]                       envir <- sys.frame(frame)
[13:23:06.868]                       master <- NULL
[13:23:06.868]                       while (!identical(envir, .GlobalEnv) && 
[13:23:06.868]                         !identical(envir, emptyenv())) {
[13:23:06.868]                         if (exists("master", mode = "list", envir = envir, 
[13:23:06.868]                           inherits = FALSE)) {
[13:23:06.868]                           master <- get("master", mode = "list", 
[13:23:06.868]                             envir = envir, inherits = FALSE)
[13:23:06.868]                           if (inherits(master, c("SOCKnode", 
[13:23:06.868]                             "SOCK0node"))) {
[13:23:06.868]                             sendCondition <<- function(cond) {
[13:23:06.868]                               data <- list(type = "VALUE", value = cond, 
[13:23:06.868]                                 success = TRUE)
[13:23:06.868]                               parallel_sendData(master, data)
[13:23:06.868]                             }
[13:23:06.868]                             return(sendCondition)
[13:23:06.868]                           }
[13:23:06.868]                         }
[13:23:06.868]                         frame <- frame + 1L
[13:23:06.868]                         envir <- sys.frame(frame)
[13:23:06.868]                       }
[13:23:06.868]                     }
[13:23:06.868]                     sendCondition <<- function(cond) NULL
[13:23:06.868]                   }
[13:23:06.868]                 })
[13:23:06.868]                 withCallingHandlers({
[13:23:06.868]                   2
[13:23:06.868]                 }, immediateCondition = function(cond) {
[13:23:06.868]                   sendCondition <- ...future.makeSendCondition()
[13:23:06.868]                   sendCondition(cond)
[13:23:06.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.868]                   {
[13:23:06.868]                     inherits <- base::inherits
[13:23:06.868]                     invokeRestart <- base::invokeRestart
[13:23:06.868]                     is.null <- base::is.null
[13:23:06.868]                     muffled <- FALSE
[13:23:06.868]                     if (inherits(cond, "message")) {
[13:23:06.868]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:06.868]                       if (muffled) 
[13:23:06.868]                         invokeRestart("muffleMessage")
[13:23:06.868]                     }
[13:23:06.868]                     else if (inherits(cond, "warning")) {
[13:23:06.868]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:06.868]                       if (muffled) 
[13:23:06.868]                         invokeRestart("muffleWarning")
[13:23:06.868]                     }
[13:23:06.868]                     else if (inherits(cond, "condition")) {
[13:23:06.868]                       if (!is.null(pattern)) {
[13:23:06.868]                         computeRestarts <- base::computeRestarts
[13:23:06.868]                         grepl <- base::grepl
[13:23:06.868]                         restarts <- computeRestarts(cond)
[13:23:06.868]                         for (restart in restarts) {
[13:23:06.868]                           name <- restart$name
[13:23:06.868]                           if (is.null(name)) 
[13:23:06.868]                             next
[13:23:06.868]                           if (!grepl(pattern, name)) 
[13:23:06.868]                             next
[13:23:06.868]                           invokeRestart(restart)
[13:23:06.868]                           muffled <- TRUE
[13:23:06.868]                           break
[13:23:06.868]                         }
[13:23:06.868]                       }
[13:23:06.868]                     }
[13:23:06.868]                     invisible(muffled)
[13:23:06.868]                   }
[13:23:06.868]                   muffleCondition(cond)
[13:23:06.868]                 })
[13:23:06.868]             }))
[13:23:06.868]             future::FutureResult(value = ...future.value$value, 
[13:23:06.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.868]                   ...future.rng), globalenv = if (FALSE) 
[13:23:06.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:06.868]                     ...future.globalenv.names))
[13:23:06.868]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:06.868]         }, condition = base::local({
[13:23:06.868]             c <- base::c
[13:23:06.868]             inherits <- base::inherits
[13:23:06.868]             invokeRestart <- base::invokeRestart
[13:23:06.868]             length <- base::length
[13:23:06.868]             list <- base::list
[13:23:06.868]             seq.int <- base::seq.int
[13:23:06.868]             signalCondition <- base::signalCondition
[13:23:06.868]             sys.calls <- base::sys.calls
[13:23:06.868]             `[[` <- base::`[[`
[13:23:06.868]             `+` <- base::`+`
[13:23:06.868]             `<<-` <- base::`<<-`
[13:23:06.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:06.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:06.868]                   3L)]
[13:23:06.868]             }
[13:23:06.868]             function(cond) {
[13:23:06.868]                 is_error <- inherits(cond, "error")
[13:23:06.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:06.868]                   NULL)
[13:23:06.868]                 if (is_error) {
[13:23:06.868]                   sessionInformation <- function() {
[13:23:06.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:06.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:06.868]                       search = base::search(), system = base::Sys.info())
[13:23:06.868]                   }
[13:23:06.868]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:06.868]                     cond$call), session = sessionInformation(), 
[13:23:06.868]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:06.868]                   signalCondition(cond)
[13:23:06.868]                 }
[13:23:06.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:06.868]                 "immediateCondition"))) {
[13:23:06.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:06.868]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:06.868]                   if (TRUE && !signal) {
[13:23:06.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.868]                     {
[13:23:06.868]                       inherits <- base::inherits
[13:23:06.868]                       invokeRestart <- base::invokeRestart
[13:23:06.868]                       is.null <- base::is.null
[13:23:06.868]                       muffled <- FALSE
[13:23:06.868]                       if (inherits(cond, "message")) {
[13:23:06.868]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.868]                         if (muffled) 
[13:23:06.868]                           invokeRestart("muffleMessage")
[13:23:06.868]                       }
[13:23:06.868]                       else if (inherits(cond, "warning")) {
[13:23:06.868]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.868]                         if (muffled) 
[13:23:06.868]                           invokeRestart("muffleWarning")
[13:23:06.868]                       }
[13:23:06.868]                       else if (inherits(cond, "condition")) {
[13:23:06.868]                         if (!is.null(pattern)) {
[13:23:06.868]                           computeRestarts <- base::computeRestarts
[13:23:06.868]                           grepl <- base::grepl
[13:23:06.868]                           restarts <- computeRestarts(cond)
[13:23:06.868]                           for (restart in restarts) {
[13:23:06.868]                             name <- restart$name
[13:23:06.868]                             if (is.null(name)) 
[13:23:06.868]                               next
[13:23:06.868]                             if (!grepl(pattern, name)) 
[13:23:06.868]                               next
[13:23:06.868]                             invokeRestart(restart)
[13:23:06.868]                             muffled <- TRUE
[13:23:06.868]                             break
[13:23:06.868]                           }
[13:23:06.868]                         }
[13:23:06.868]                       }
[13:23:06.868]                       invisible(muffled)
[13:23:06.868]                     }
[13:23:06.868]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.868]                   }
[13:23:06.868]                 }
[13:23:06.868]                 else {
[13:23:06.868]                   if (TRUE) {
[13:23:06.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.868]                     {
[13:23:06.868]                       inherits <- base::inherits
[13:23:06.868]                       invokeRestart <- base::invokeRestart
[13:23:06.868]                       is.null <- base::is.null
[13:23:06.868]                       muffled <- FALSE
[13:23:06.868]                       if (inherits(cond, "message")) {
[13:23:06.868]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.868]                         if (muffled) 
[13:23:06.868]                           invokeRestart("muffleMessage")
[13:23:06.868]                       }
[13:23:06.868]                       else if (inherits(cond, "warning")) {
[13:23:06.868]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.868]                         if (muffled) 
[13:23:06.868]                           invokeRestart("muffleWarning")
[13:23:06.868]                       }
[13:23:06.868]                       else if (inherits(cond, "condition")) {
[13:23:06.868]                         if (!is.null(pattern)) {
[13:23:06.868]                           computeRestarts <- base::computeRestarts
[13:23:06.868]                           grepl <- base::grepl
[13:23:06.868]                           restarts <- computeRestarts(cond)
[13:23:06.868]                           for (restart in restarts) {
[13:23:06.868]                             name <- restart$name
[13:23:06.868]                             if (is.null(name)) 
[13:23:06.868]                               next
[13:23:06.868]                             if (!grepl(pattern, name)) 
[13:23:06.868]                               next
[13:23:06.868]                             invokeRestart(restart)
[13:23:06.868]                             muffled <- TRUE
[13:23:06.868]                             break
[13:23:06.868]                           }
[13:23:06.868]                         }
[13:23:06.868]                       }
[13:23:06.868]                       invisible(muffled)
[13:23:06.868]                     }
[13:23:06.868]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.868]                   }
[13:23:06.868]                 }
[13:23:06.868]             }
[13:23:06.868]         }))
[13:23:06.868]     }, error = function(ex) {
[13:23:06.868]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:06.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.868]                 ...future.rng), started = ...future.startTime, 
[13:23:06.868]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:06.868]             version = "1.8"), class = "FutureResult")
[13:23:06.868]     }, finally = {
[13:23:06.868]         if (!identical(...future.workdir, getwd())) 
[13:23:06.868]             setwd(...future.workdir)
[13:23:06.868]         {
[13:23:06.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:06.868]                 ...future.oldOptions$nwarnings <- NULL
[13:23:06.868]             }
[13:23:06.868]             base::options(...future.oldOptions)
[13:23:06.868]             if (.Platform$OS.type == "windows") {
[13:23:06.868]                 old_names <- names(...future.oldEnvVars)
[13:23:06.868]                 envs <- base::Sys.getenv()
[13:23:06.868]                 names <- names(envs)
[13:23:06.868]                 common <- intersect(names, old_names)
[13:23:06.868]                 added <- setdiff(names, old_names)
[13:23:06.868]                 removed <- setdiff(old_names, names)
[13:23:06.868]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:06.868]                   envs[common]]
[13:23:06.868]                 NAMES <- toupper(changed)
[13:23:06.868]                 args <- list()
[13:23:06.868]                 for (kk in seq_along(NAMES)) {
[13:23:06.868]                   name <- changed[[kk]]
[13:23:06.868]                   NAME <- NAMES[[kk]]
[13:23:06.868]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.868]                     next
[13:23:06.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.868]                 }
[13:23:06.868]                 NAMES <- toupper(added)
[13:23:06.868]                 for (kk in seq_along(NAMES)) {
[13:23:06.868]                   name <- added[[kk]]
[13:23:06.868]                   NAME <- NAMES[[kk]]
[13:23:06.868]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.868]                     next
[13:23:06.868]                   args[[name]] <- ""
[13:23:06.868]                 }
[13:23:06.868]                 NAMES <- toupper(removed)
[13:23:06.868]                 for (kk in seq_along(NAMES)) {
[13:23:06.868]                   name <- removed[[kk]]
[13:23:06.868]                   NAME <- NAMES[[kk]]
[13:23:06.868]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.868]                     next
[13:23:06.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.868]                 }
[13:23:06.868]                 if (length(args) > 0) 
[13:23:06.868]                   base::do.call(base::Sys.setenv, args = args)
[13:23:06.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:06.868]             }
[13:23:06.868]             else {
[13:23:06.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:06.868]             }
[13:23:06.868]             {
[13:23:06.868]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:06.868]                   0L) {
[13:23:06.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:06.868]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:06.868]                   base::options(opts)
[13:23:06.868]                 }
[13:23:06.868]                 {
[13:23:06.868]                   {
[13:23:06.868]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:06.868]                     NULL
[13:23:06.868]                   }
[13:23:06.868]                   options(future.plan = NULL)
[13:23:06.868]                   if (is.na(NA_character_)) 
[13:23:06.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:06.868]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:06.868]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:06.868]                     envir = parent.frame()) 
[13:23:06.868]                   {
[13:23:06.868]                     if (is.function(workers)) 
[13:23:06.868]                       workers <- workers()
[13:23:06.868]                     workers <- structure(as.integer(workers), 
[13:23:06.868]                       class = class(workers))
[13:23:06.868]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:06.868]                       workers >= 1)
[13:23:06.868]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:06.868]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:06.868]                     }
[13:23:06.868]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:06.868]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:06.868]                       envir = envir)
[13:23:06.868]                     if (!future$lazy) 
[13:23:06.868]                       future <- run(future)
[13:23:06.868]                     invisible(future)
[13:23:06.868]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:06.868]                 }
[13:23:06.868]             }
[13:23:06.868]         }
[13:23:06.868]     })
[13:23:06.868]     if (TRUE) {
[13:23:06.868]         base::sink(type = "output", split = FALSE)
[13:23:06.868]         if (TRUE) {
[13:23:06.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:06.868]         }
[13:23:06.868]         else {
[13:23:06.868]             ...future.result["stdout"] <- base::list(NULL)
[13:23:06.868]         }
[13:23:06.868]         base::close(...future.stdout)
[13:23:06.868]         ...future.stdout <- NULL
[13:23:06.868]     }
[13:23:06.868]     ...future.result$conditions <- ...future.conditions
[13:23:06.868]     ...future.result$finished <- base::Sys.time()
[13:23:06.868]     ...future.result
[13:23:06.868] }
[13:23:06.871] MultisessionFuture started
[13:23:06.871] - Launch lazy future ... done
[13:23:06.872] run() for ‘MultisessionFuture’ ... done
[13:23:06.872] getGlobalsAndPackages() ...
[13:23:06.872] Searching for globals...
[13:23:06.872] 
[13:23:06.873] Searching for globals ... DONE
[13:23:06.873] - globals: [0] <none>
[13:23:06.873] getGlobalsAndPackages() ... DONE
[13:23:06.873] run() for ‘Future’ ...
[13:23:06.873] - state: ‘created’
[13:23:06.873] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:06.889] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:06.889] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:06.889]   - Field: ‘node’
[13:23:06.889]   - Field: ‘label’
[13:23:06.889]   - Field: ‘local’
[13:23:06.889]   - Field: ‘owner’
[13:23:06.889]   - Field: ‘envir’
[13:23:06.889]   - Field: ‘workers’
[13:23:06.889]   - Field: ‘packages’
[13:23:06.890]   - Field: ‘gc’
[13:23:06.890]   - Field: ‘conditions’
[13:23:06.890]   - Field: ‘persistent’
[13:23:06.890]   - Field: ‘expr’
[13:23:06.890]   - Field: ‘uuid’
[13:23:06.890]   - Field: ‘seed’
[13:23:06.890]   - Field: ‘version’
[13:23:06.890]   - Field: ‘result’
[13:23:06.891]   - Field: ‘asynchronous’
[13:23:06.891]   - Field: ‘calls’
[13:23:06.891]   - Field: ‘globals’
[13:23:06.891]   - Field: ‘stdout’
[13:23:06.891]   - Field: ‘earlySignal’
[13:23:06.891]   - Field: ‘lazy’
[13:23:06.891]   - Field: ‘state’
[13:23:06.891] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:06.891] - Launch lazy future ...
[13:23:06.892] Packages needed by the future expression (n = 0): <none>
[13:23:06.892] Packages needed by future strategies (n = 0): <none>
[13:23:06.893] {
[13:23:06.893]     {
[13:23:06.893]         {
[13:23:06.893]             ...future.startTime <- base::Sys.time()
[13:23:06.893]             {
[13:23:06.893]                 {
[13:23:06.893]                   {
[13:23:06.893]                     {
[13:23:06.893]                       base::local({
[13:23:06.893]                         has_future <- base::requireNamespace("future", 
[13:23:06.893]                           quietly = TRUE)
[13:23:06.893]                         if (has_future) {
[13:23:06.893]                           ns <- base::getNamespace("future")
[13:23:06.893]                           version <- ns[[".package"]][["version"]]
[13:23:06.893]                           if (is.null(version)) 
[13:23:06.893]                             version <- utils::packageVersion("future")
[13:23:06.893]                         }
[13:23:06.893]                         else {
[13:23:06.893]                           version <- NULL
[13:23:06.893]                         }
[13:23:06.893]                         if (!has_future || version < "1.8.0") {
[13:23:06.893]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:06.893]                             "", base::R.version$version.string), 
[13:23:06.893]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:06.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:06.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:06.893]                               "release", "version")], collapse = " "), 
[13:23:06.893]                             hostname = base::Sys.info()[["nodename"]])
[13:23:06.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:06.893]                             info)
[13:23:06.893]                           info <- base::paste(info, collapse = "; ")
[13:23:06.893]                           if (!has_future) {
[13:23:06.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:06.893]                               info)
[13:23:06.893]                           }
[13:23:06.893]                           else {
[13:23:06.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:06.893]                               info, version)
[13:23:06.893]                           }
[13:23:06.893]                           base::stop(msg)
[13:23:06.893]                         }
[13:23:06.893]                       })
[13:23:06.893]                     }
[13:23:06.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:06.893]                     base::options(mc.cores = 1L)
[13:23:06.893]                   }
[13:23:06.893]                   options(future.plan = NULL)
[13:23:06.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:06.893]                 }
[13:23:06.893]                 ...future.workdir <- getwd()
[13:23:06.893]             }
[13:23:06.893]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:06.893]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:06.893]         }
[13:23:06.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:06.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:06.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:06.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:06.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:06.893]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:06.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:06.893]             base::names(...future.oldOptions))
[13:23:06.893]     }
[13:23:06.893]     if (FALSE) {
[13:23:06.893]     }
[13:23:06.893]     else {
[13:23:06.893]         if (TRUE) {
[13:23:06.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:06.893]                 open = "w")
[13:23:06.893]         }
[13:23:06.893]         else {
[13:23:06.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:06.893]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:06.893]         }
[13:23:06.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:06.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:06.893]             base::sink(type = "output", split = FALSE)
[13:23:06.893]             base::close(...future.stdout)
[13:23:06.893]         }, add = TRUE)
[13:23:06.893]     }
[13:23:06.893]     ...future.frame <- base::sys.nframe()
[13:23:06.893]     ...future.conditions <- base::list()
[13:23:06.893]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:06.893]     if (FALSE) {
[13:23:06.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:06.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:06.893]     }
[13:23:06.893]     ...future.result <- base::tryCatch({
[13:23:06.893]         base::withCallingHandlers({
[13:23:06.893]             ...future.value <- base::withVisible(base::local({
[13:23:06.893]                 ...future.makeSendCondition <- base::local({
[13:23:06.893]                   sendCondition <- NULL
[13:23:06.893]                   function(frame = 1L) {
[13:23:06.893]                     if (is.function(sendCondition)) 
[13:23:06.893]                       return(sendCondition)
[13:23:06.893]                     ns <- getNamespace("parallel")
[13:23:06.893]                     if (exists("sendData", mode = "function", 
[13:23:06.893]                       envir = ns)) {
[13:23:06.893]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:06.893]                         envir = ns)
[13:23:06.893]                       envir <- sys.frame(frame)
[13:23:06.893]                       master <- NULL
[13:23:06.893]                       while (!identical(envir, .GlobalEnv) && 
[13:23:06.893]                         !identical(envir, emptyenv())) {
[13:23:06.893]                         if (exists("master", mode = "list", envir = envir, 
[13:23:06.893]                           inherits = FALSE)) {
[13:23:06.893]                           master <- get("master", mode = "list", 
[13:23:06.893]                             envir = envir, inherits = FALSE)
[13:23:06.893]                           if (inherits(master, c("SOCKnode", 
[13:23:06.893]                             "SOCK0node"))) {
[13:23:06.893]                             sendCondition <<- function(cond) {
[13:23:06.893]                               data <- list(type = "VALUE", value = cond, 
[13:23:06.893]                                 success = TRUE)
[13:23:06.893]                               parallel_sendData(master, data)
[13:23:06.893]                             }
[13:23:06.893]                             return(sendCondition)
[13:23:06.893]                           }
[13:23:06.893]                         }
[13:23:06.893]                         frame <- frame + 1L
[13:23:06.893]                         envir <- sys.frame(frame)
[13:23:06.893]                       }
[13:23:06.893]                     }
[13:23:06.893]                     sendCondition <<- function(cond) NULL
[13:23:06.893]                   }
[13:23:06.893]                 })
[13:23:06.893]                 withCallingHandlers({
[13:23:06.893]                   NULL
[13:23:06.893]                 }, immediateCondition = function(cond) {
[13:23:06.893]                   sendCondition <- ...future.makeSendCondition()
[13:23:06.893]                   sendCondition(cond)
[13:23:06.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.893]                   {
[13:23:06.893]                     inherits <- base::inherits
[13:23:06.893]                     invokeRestart <- base::invokeRestart
[13:23:06.893]                     is.null <- base::is.null
[13:23:06.893]                     muffled <- FALSE
[13:23:06.893]                     if (inherits(cond, "message")) {
[13:23:06.893]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:06.893]                       if (muffled) 
[13:23:06.893]                         invokeRestart("muffleMessage")
[13:23:06.893]                     }
[13:23:06.893]                     else if (inherits(cond, "warning")) {
[13:23:06.893]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:06.893]                       if (muffled) 
[13:23:06.893]                         invokeRestart("muffleWarning")
[13:23:06.893]                     }
[13:23:06.893]                     else if (inherits(cond, "condition")) {
[13:23:06.893]                       if (!is.null(pattern)) {
[13:23:06.893]                         computeRestarts <- base::computeRestarts
[13:23:06.893]                         grepl <- base::grepl
[13:23:06.893]                         restarts <- computeRestarts(cond)
[13:23:06.893]                         for (restart in restarts) {
[13:23:06.893]                           name <- restart$name
[13:23:06.893]                           if (is.null(name)) 
[13:23:06.893]                             next
[13:23:06.893]                           if (!grepl(pattern, name)) 
[13:23:06.893]                             next
[13:23:06.893]                           invokeRestart(restart)
[13:23:06.893]                           muffled <- TRUE
[13:23:06.893]                           break
[13:23:06.893]                         }
[13:23:06.893]                       }
[13:23:06.893]                     }
[13:23:06.893]                     invisible(muffled)
[13:23:06.893]                   }
[13:23:06.893]                   muffleCondition(cond)
[13:23:06.893]                 })
[13:23:06.893]             }))
[13:23:06.893]             future::FutureResult(value = ...future.value$value, 
[13:23:06.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.893]                   ...future.rng), globalenv = if (FALSE) 
[13:23:06.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:06.893]                     ...future.globalenv.names))
[13:23:06.893]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:06.893]         }, condition = base::local({
[13:23:06.893]             c <- base::c
[13:23:06.893]             inherits <- base::inherits
[13:23:06.893]             invokeRestart <- base::invokeRestart
[13:23:06.893]             length <- base::length
[13:23:06.893]             list <- base::list
[13:23:06.893]             seq.int <- base::seq.int
[13:23:06.893]             signalCondition <- base::signalCondition
[13:23:06.893]             sys.calls <- base::sys.calls
[13:23:06.893]             `[[` <- base::`[[`
[13:23:06.893]             `+` <- base::`+`
[13:23:06.893]             `<<-` <- base::`<<-`
[13:23:06.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:06.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:06.893]                   3L)]
[13:23:06.893]             }
[13:23:06.893]             function(cond) {
[13:23:06.893]                 is_error <- inherits(cond, "error")
[13:23:06.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:06.893]                   NULL)
[13:23:06.893]                 if (is_error) {
[13:23:06.893]                   sessionInformation <- function() {
[13:23:06.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:06.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:06.893]                       search = base::search(), system = base::Sys.info())
[13:23:06.893]                   }
[13:23:06.893]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:06.893]                     cond$call), session = sessionInformation(), 
[13:23:06.893]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:06.893]                   signalCondition(cond)
[13:23:06.893]                 }
[13:23:06.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:06.893]                 "immediateCondition"))) {
[13:23:06.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:06.893]                   ...future.conditions[[length(...future.conditions) + 
[13:23:06.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:06.893]                   if (TRUE && !signal) {
[13:23:06.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.893]                     {
[13:23:06.893]                       inherits <- base::inherits
[13:23:06.893]                       invokeRestart <- base::invokeRestart
[13:23:06.893]                       is.null <- base::is.null
[13:23:06.893]                       muffled <- FALSE
[13:23:06.893]                       if (inherits(cond, "message")) {
[13:23:06.893]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.893]                         if (muffled) 
[13:23:06.893]                           invokeRestart("muffleMessage")
[13:23:06.893]                       }
[13:23:06.893]                       else if (inherits(cond, "warning")) {
[13:23:06.893]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.893]                         if (muffled) 
[13:23:06.893]                           invokeRestart("muffleWarning")
[13:23:06.893]                       }
[13:23:06.893]                       else if (inherits(cond, "condition")) {
[13:23:06.893]                         if (!is.null(pattern)) {
[13:23:06.893]                           computeRestarts <- base::computeRestarts
[13:23:06.893]                           grepl <- base::grepl
[13:23:06.893]                           restarts <- computeRestarts(cond)
[13:23:06.893]                           for (restart in restarts) {
[13:23:06.893]                             name <- restart$name
[13:23:06.893]                             if (is.null(name)) 
[13:23:06.893]                               next
[13:23:06.893]                             if (!grepl(pattern, name)) 
[13:23:06.893]                               next
[13:23:06.893]                             invokeRestart(restart)
[13:23:06.893]                             muffled <- TRUE
[13:23:06.893]                             break
[13:23:06.893]                           }
[13:23:06.893]                         }
[13:23:06.893]                       }
[13:23:06.893]                       invisible(muffled)
[13:23:06.893]                     }
[13:23:06.893]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.893]                   }
[13:23:06.893]                 }
[13:23:06.893]                 else {
[13:23:06.893]                   if (TRUE) {
[13:23:06.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:06.893]                     {
[13:23:06.893]                       inherits <- base::inherits
[13:23:06.893]                       invokeRestart <- base::invokeRestart
[13:23:06.893]                       is.null <- base::is.null
[13:23:06.893]                       muffled <- FALSE
[13:23:06.893]                       if (inherits(cond, "message")) {
[13:23:06.893]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:06.893]                         if (muffled) 
[13:23:06.893]                           invokeRestart("muffleMessage")
[13:23:06.893]                       }
[13:23:06.893]                       else if (inherits(cond, "warning")) {
[13:23:06.893]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:06.893]                         if (muffled) 
[13:23:06.893]                           invokeRestart("muffleWarning")
[13:23:06.893]                       }
[13:23:06.893]                       else if (inherits(cond, "condition")) {
[13:23:06.893]                         if (!is.null(pattern)) {
[13:23:06.893]                           computeRestarts <- base::computeRestarts
[13:23:06.893]                           grepl <- base::grepl
[13:23:06.893]                           restarts <- computeRestarts(cond)
[13:23:06.893]                           for (restart in restarts) {
[13:23:06.893]                             name <- restart$name
[13:23:06.893]                             if (is.null(name)) 
[13:23:06.893]                               next
[13:23:06.893]                             if (!grepl(pattern, name)) 
[13:23:06.893]                               next
[13:23:06.893]                             invokeRestart(restart)
[13:23:06.893]                             muffled <- TRUE
[13:23:06.893]                             break
[13:23:06.893]                           }
[13:23:06.893]                         }
[13:23:06.893]                       }
[13:23:06.893]                       invisible(muffled)
[13:23:06.893]                     }
[13:23:06.893]                     muffleCondition(cond, pattern = "^muffle")
[13:23:06.893]                   }
[13:23:06.893]                 }
[13:23:06.893]             }
[13:23:06.893]         }))
[13:23:06.893]     }, error = function(ex) {
[13:23:06.893]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:06.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:06.893]                 ...future.rng), started = ...future.startTime, 
[13:23:06.893]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:06.893]             version = "1.8"), class = "FutureResult")
[13:23:06.893]     }, finally = {
[13:23:06.893]         if (!identical(...future.workdir, getwd())) 
[13:23:06.893]             setwd(...future.workdir)
[13:23:06.893]         {
[13:23:06.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:06.893]                 ...future.oldOptions$nwarnings <- NULL
[13:23:06.893]             }
[13:23:06.893]             base::options(...future.oldOptions)
[13:23:06.893]             if (.Platform$OS.type == "windows") {
[13:23:06.893]                 old_names <- names(...future.oldEnvVars)
[13:23:06.893]                 envs <- base::Sys.getenv()
[13:23:06.893]                 names <- names(envs)
[13:23:06.893]                 common <- intersect(names, old_names)
[13:23:06.893]                 added <- setdiff(names, old_names)
[13:23:06.893]                 removed <- setdiff(old_names, names)
[13:23:06.893]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:06.893]                   envs[common]]
[13:23:06.893]                 NAMES <- toupper(changed)
[13:23:06.893]                 args <- list()
[13:23:06.893]                 for (kk in seq_along(NAMES)) {
[13:23:06.893]                   name <- changed[[kk]]
[13:23:06.893]                   NAME <- NAMES[[kk]]
[13:23:06.893]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.893]                     next
[13:23:06.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.893]                 }
[13:23:06.893]                 NAMES <- toupper(added)
[13:23:06.893]                 for (kk in seq_along(NAMES)) {
[13:23:06.893]                   name <- added[[kk]]
[13:23:06.893]                   NAME <- NAMES[[kk]]
[13:23:06.893]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.893]                     next
[13:23:06.893]                   args[[name]] <- ""
[13:23:06.893]                 }
[13:23:06.893]                 NAMES <- toupper(removed)
[13:23:06.893]                 for (kk in seq_along(NAMES)) {
[13:23:06.893]                   name <- removed[[kk]]
[13:23:06.893]                   NAME <- NAMES[[kk]]
[13:23:06.893]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:06.893]                     next
[13:23:06.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:06.893]                 }
[13:23:06.893]                 if (length(args) > 0) 
[13:23:06.893]                   base::do.call(base::Sys.setenv, args = args)
[13:23:06.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:06.893]             }
[13:23:06.893]             else {
[13:23:06.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:06.893]             }
[13:23:06.893]             {
[13:23:06.893]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:06.893]                   0L) {
[13:23:06.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:06.893]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:06.893]                   base::options(opts)
[13:23:06.893]                 }
[13:23:06.893]                 {
[13:23:06.893]                   {
[13:23:06.893]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:06.893]                     NULL
[13:23:06.893]                   }
[13:23:06.893]                   options(future.plan = NULL)
[13:23:06.893]                   if (is.na(NA_character_)) 
[13:23:06.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:06.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:06.893]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:06.893]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:06.893]                     envir = parent.frame()) 
[13:23:06.893]                   {
[13:23:06.893]                     if (is.function(workers)) 
[13:23:06.893]                       workers <- workers()
[13:23:06.893]                     workers <- structure(as.integer(workers), 
[13:23:06.893]                       class = class(workers))
[13:23:06.893]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:06.893]                       workers >= 1)
[13:23:06.893]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:06.893]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:06.893]                     }
[13:23:06.893]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:06.893]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:06.893]                       envir = envir)
[13:23:06.893]                     if (!future$lazy) 
[13:23:06.893]                       future <- run(future)
[13:23:06.893]                     invisible(future)
[13:23:06.893]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:06.893]                 }
[13:23:06.893]             }
[13:23:06.893]         }
[13:23:06.893]     })
[13:23:06.893]     if (TRUE) {
[13:23:06.893]         base::sink(type = "output", split = FALSE)
[13:23:06.893]         if (TRUE) {
[13:23:06.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:06.893]         }
[13:23:06.893]         else {
[13:23:06.893]             ...future.result["stdout"] <- base::list(NULL)
[13:23:06.893]         }
[13:23:06.893]         base::close(...future.stdout)
[13:23:06.893]         ...future.stdout <- NULL
[13:23:06.893]     }
[13:23:06.893]     ...future.result$conditions <- ...future.conditions
[13:23:06.893]     ...future.result$finished <- base::Sys.time()
[13:23:06.893]     ...future.result
[13:23:06.893] }
[13:23:06.951] MultisessionFuture started
[13:23:06.952] - Launch lazy future ... done
[13:23:06.952] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d6773e48> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d6be4e98> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d6773e48> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d6be4e98> 
 $  : NULL
 $  : NULL
 $  : num 6
[13:23:06.961] receiveMessageFromWorker() for ClusterFuture ...
[13:23:06.961] - Validating connection of MultisessionFuture
[13:23:06.962] - received message: FutureResult
[13:23:06.962] - Received FutureResult
[13:23:06.962] - Erased future from FutureRegistry
[13:23:06.962] result() for ClusterFuture ...
[13:23:06.962] - result already collected: FutureResult
[13:23:06.962] result() for ClusterFuture ... done
[13:23:06.963] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:06.975] resolve() on list ...
[13:23:06.975]  recursive: 0
[13:23:06.975]  length: 6
[13:23:06.976]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:06.976] signalConditionsASAP(numeric, pos=1) ...
[13:23:06.976] - nx: 6
[13:23:06.976] - relay: TRUE
[13:23:06.976] - stdout: TRUE
[13:23:06.977] - signal: TRUE
[13:23:06.977] - resignal: FALSE
[13:23:06.977] - force: TRUE
[13:23:06.977] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.977] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.978]  - until=2
[13:23:06.978]  - relaying element #2
[13:23:06.978] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.978] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.978] signalConditionsASAP(NULL, pos=1) ... done
[13:23:06.979]  length: 5 (resolved future 1)
[13:23:06.979] Future #2
[13:23:06.979] result() for ClusterFuture ...
[13:23:06.979] - result already collected: FutureResult
[13:23:06.979] result() for ClusterFuture ... done
[13:23:06.980] result() for ClusterFuture ...
[13:23:06.980] - result already collected: FutureResult
[13:23:06.980] result() for ClusterFuture ... done
[13:23:06.980] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:06.980] - nx: 6
[13:23:06.981] - relay: TRUE
[13:23:06.981] - stdout: TRUE
[13:23:06.981] - signal: TRUE
[13:23:06.981] - resignal: FALSE
[13:23:06.981] - force: TRUE
[13:23:06.981] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.982] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:06.982]  - until=2
[13:23:06.982]  - relaying element #2
[13:23:06.982] result() for ClusterFuture ...
[13:23:06.982] - result already collected: FutureResult
[13:23:06.983] result() for ClusterFuture ... done
[13:23:06.983] result() for ClusterFuture ...
[13:23:06.983] - result already collected: FutureResult
[13:23:06.983] result() for ClusterFuture ... done
[13:23:06.984] result() for ClusterFuture ...
[13:23:06.984] - result already collected: FutureResult
[13:23:06.984] result() for ClusterFuture ... done
[13:23:06.984] result() for ClusterFuture ...
[13:23:06.984] - result already collected: FutureResult
[13:23:06.984] result() for ClusterFuture ... done
[13:23:06.985] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.985] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.985] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:06.985]  length: 4 (resolved future 2)
[13:23:06.996] signalConditionsASAP(NULL, pos=4) ...
[13:23:06.997] - nx: 6
[13:23:06.997] - relay: TRUE
[13:23:06.997] - stdout: TRUE
[13:23:06.997] - signal: TRUE
[13:23:06.997] - resignal: FALSE
[13:23:06.998] - force: TRUE
[13:23:06.998] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.998] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.998]  - until=5
[13:23:06.998]  - relaying element #3
[13:23:06.999]  - relaying element #5
[13:23:06.999] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:23:06.999] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:06.999] signalConditionsASAP(NULL, pos=4) ... done
[13:23:06.999]  length: 3 (resolved future 4)
[13:23:06.999] signalConditionsASAP(NULL, pos=5) ...
[13:23:07.000] - nx: 6
[13:23:07.000] - relay: TRUE
[13:23:07.000] - stdout: TRUE
[13:23:07.000] - signal: TRUE
[13:23:07.000] - resignal: FALSE
[13:23:07.000] - force: TRUE
[13:23:07.001] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:23:07.001] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.001]  - until=6
[13:23:07.001]  - relaying element #3
[13:23:07.001]  - relaying element #6
[13:23:07.001] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:23:07.001] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.002] signalConditionsASAP(NULL, pos=5) ... done
[13:23:07.002]  length: 2 (resolved future 5)
[13:23:07.002] signalConditionsASAP(numeric, pos=6) ...
[13:23:07.002] - nx: 6
[13:23:07.002] - relay: TRUE
[13:23:07.002] - stdout: TRUE
[13:23:07.002] - signal: TRUE
[13:23:07.002] - resignal: FALSE
[13:23:07.003] - force: TRUE
[13:23:07.003] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:23:07.003] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.003]  - until=6
[13:23:07.003]  - relaying element #3
[13:23:07.003] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:23:07.003] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.003] signalConditionsASAP(NULL, pos=6) ... done
[13:23:07.004]  length: 1 (resolved future 6)
[13:23:07.015] receiveMessageFromWorker() for ClusterFuture ...
[13:23:07.015] - Validating connection of MultisessionFuture
[13:23:07.015] - received message: FutureResult
[13:23:07.015] - Received FutureResult
[13:23:07.015] - Erased future from FutureRegistry
[13:23:07.016] result() for ClusterFuture ...
[13:23:07.016] - result already collected: FutureResult
[13:23:07.016] result() for ClusterFuture ... done
[13:23:07.016] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:07.016] Future #3
[13:23:07.016] result() for ClusterFuture ...
[13:23:07.016] - result already collected: FutureResult
[13:23:07.016] result() for ClusterFuture ... done
[13:23:07.017] result() for ClusterFuture ...
[13:23:07.017] - result already collected: FutureResult
[13:23:07.017] result() for ClusterFuture ... done
[13:23:07.017] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:07.017] - nx: 6
[13:23:07.017] - relay: TRUE
[13:23:07.017] - stdout: TRUE
[13:23:07.017] - signal: TRUE
[13:23:07.017] - resignal: FALSE
[13:23:07.018] - force: TRUE
[13:23:07.018] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:23:07.018] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.018]  - until=6
[13:23:07.018]  - relaying element #3
[13:23:07.018] result() for ClusterFuture ...
[13:23:07.018] - result already collected: FutureResult
[13:23:07.018] result() for ClusterFuture ... done
[13:23:07.018] result() for ClusterFuture ...
[13:23:07.019] - result already collected: FutureResult
[13:23:07.019] result() for ClusterFuture ... done
[13:23:07.019] result() for ClusterFuture ...
[13:23:07.019] - result already collected: FutureResult
[13:23:07.019] result() for ClusterFuture ... done
[13:23:07.019] result() for ClusterFuture ...
[13:23:07.019] - result already collected: FutureResult
[13:23:07.019] result() for ClusterFuture ... done
[13:23:07.019] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.020] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.020] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:07.020]  length: 0 (resolved future 3)
[13:23:07.022] Relaying remaining futures
[13:23:07.023] signalConditionsASAP(NULL, pos=0) ...
[13:23:07.023] - nx: 6
[13:23:07.023] - relay: TRUE
[13:23:07.023] - stdout: TRUE
[13:23:07.023] - signal: TRUE
[13:23:07.023] - resignal: FALSE
[13:23:07.023] - force: TRUE
[13:23:07.023] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.023] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:07.023] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.023] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.024] signalConditionsASAP(NULL, pos=0) ... done
[13:23:07.024] resolve() on list ... DONE
[13:23:07.024] result() for ClusterFuture ...
[13:23:07.024] - result already collected: FutureResult
[13:23:07.024] result() for ClusterFuture ... done
[13:23:07.024] result() for ClusterFuture ...
[13:23:07.024] - result already collected: FutureResult
[13:23:07.024] result() for ClusterFuture ... done
[13:23:07.024] result() for ClusterFuture ...
[13:23:07.024] - result already collected: FutureResult
[13:23:07.025] result() for ClusterFuture ... done
[13:23:07.025] result() for ClusterFuture ...
[13:23:07.025] - result already collected: FutureResult
[13:23:07.025] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[13:23:07.027] getGlobalsAndPackages() ...
[13:23:07.027] Searching for globals...
[13:23:07.027] 
[13:23:07.028] Searching for globals ... DONE
[13:23:07.028] - globals: [0] <none>
[13:23:07.028] getGlobalsAndPackages() ... DONE
[13:23:07.028] run() for ‘Future’ ...
[13:23:07.028] - state: ‘created’
[13:23:07.028] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.043] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.043] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:07.043]   - Field: ‘node’
[13:23:07.043]   - Field: ‘label’
[13:23:07.043]   - Field: ‘local’
[13:23:07.043]   - Field: ‘owner’
[13:23:07.043]   - Field: ‘envir’
[13:23:07.043]   - Field: ‘workers’
[13:23:07.044]   - Field: ‘packages’
[13:23:07.044]   - Field: ‘gc’
[13:23:07.044]   - Field: ‘conditions’
[13:23:07.044]   - Field: ‘persistent’
[13:23:07.044]   - Field: ‘expr’
[13:23:07.044]   - Field: ‘uuid’
[13:23:07.044]   - Field: ‘seed’
[13:23:07.044]   - Field: ‘version’
[13:23:07.044]   - Field: ‘result’
[13:23:07.044]   - Field: ‘asynchronous’
[13:23:07.045]   - Field: ‘calls’
[13:23:07.045]   - Field: ‘globals’
[13:23:07.045]   - Field: ‘stdout’
[13:23:07.045]   - Field: ‘earlySignal’
[13:23:07.045]   - Field: ‘lazy’
[13:23:07.045]   - Field: ‘state’
[13:23:07.045] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:07.045] - Launch lazy future ...
[13:23:07.045] Packages needed by the future expression (n = 0): <none>
[13:23:07.046] Packages needed by future strategies (n = 0): <none>
[13:23:07.046] {
[13:23:07.046]     {
[13:23:07.046]         {
[13:23:07.046]             ...future.startTime <- base::Sys.time()
[13:23:07.046]             {
[13:23:07.046]                 {
[13:23:07.046]                   {
[13:23:07.046]                     {
[13:23:07.046]                       base::local({
[13:23:07.046]                         has_future <- base::requireNamespace("future", 
[13:23:07.046]                           quietly = TRUE)
[13:23:07.046]                         if (has_future) {
[13:23:07.046]                           ns <- base::getNamespace("future")
[13:23:07.046]                           version <- ns[[".package"]][["version"]]
[13:23:07.046]                           if (is.null(version)) 
[13:23:07.046]                             version <- utils::packageVersion("future")
[13:23:07.046]                         }
[13:23:07.046]                         else {
[13:23:07.046]                           version <- NULL
[13:23:07.046]                         }
[13:23:07.046]                         if (!has_future || version < "1.8.0") {
[13:23:07.046]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.046]                             "", base::R.version$version.string), 
[13:23:07.046]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.046]                               "release", "version")], collapse = " "), 
[13:23:07.046]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.046]                             info)
[13:23:07.046]                           info <- base::paste(info, collapse = "; ")
[13:23:07.046]                           if (!has_future) {
[13:23:07.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.046]                               info)
[13:23:07.046]                           }
[13:23:07.046]                           else {
[13:23:07.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.046]                               info, version)
[13:23:07.046]                           }
[13:23:07.046]                           base::stop(msg)
[13:23:07.046]                         }
[13:23:07.046]                       })
[13:23:07.046]                     }
[13:23:07.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.046]                     base::options(mc.cores = 1L)
[13:23:07.046]                   }
[13:23:07.046]                   options(future.plan = NULL)
[13:23:07.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.046]                 }
[13:23:07.046]                 ...future.workdir <- getwd()
[13:23:07.046]             }
[13:23:07.046]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.046]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.046]         }
[13:23:07.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.046]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.046]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.046]             base::names(...future.oldOptions))
[13:23:07.046]     }
[13:23:07.046]     if (FALSE) {
[13:23:07.046]     }
[13:23:07.046]     else {
[13:23:07.046]         if (TRUE) {
[13:23:07.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.046]                 open = "w")
[13:23:07.046]         }
[13:23:07.046]         else {
[13:23:07.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.046]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.046]         }
[13:23:07.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.046]             base::sink(type = "output", split = FALSE)
[13:23:07.046]             base::close(...future.stdout)
[13:23:07.046]         }, add = TRUE)
[13:23:07.046]     }
[13:23:07.046]     ...future.frame <- base::sys.nframe()
[13:23:07.046]     ...future.conditions <- base::list()
[13:23:07.046]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.046]     if (FALSE) {
[13:23:07.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.046]     }
[13:23:07.046]     ...future.result <- base::tryCatch({
[13:23:07.046]         base::withCallingHandlers({
[13:23:07.046]             ...future.value <- base::withVisible(base::local({
[13:23:07.046]                 ...future.makeSendCondition <- base::local({
[13:23:07.046]                   sendCondition <- NULL
[13:23:07.046]                   function(frame = 1L) {
[13:23:07.046]                     if (is.function(sendCondition)) 
[13:23:07.046]                       return(sendCondition)
[13:23:07.046]                     ns <- getNamespace("parallel")
[13:23:07.046]                     if (exists("sendData", mode = "function", 
[13:23:07.046]                       envir = ns)) {
[13:23:07.046]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:07.046]                         envir = ns)
[13:23:07.046]                       envir <- sys.frame(frame)
[13:23:07.046]                       master <- NULL
[13:23:07.046]                       while (!identical(envir, .GlobalEnv) && 
[13:23:07.046]                         !identical(envir, emptyenv())) {
[13:23:07.046]                         if (exists("master", mode = "list", envir = envir, 
[13:23:07.046]                           inherits = FALSE)) {
[13:23:07.046]                           master <- get("master", mode = "list", 
[13:23:07.046]                             envir = envir, inherits = FALSE)
[13:23:07.046]                           if (inherits(master, c("SOCKnode", 
[13:23:07.046]                             "SOCK0node"))) {
[13:23:07.046]                             sendCondition <<- function(cond) {
[13:23:07.046]                               data <- list(type = "VALUE", value = cond, 
[13:23:07.046]                                 success = TRUE)
[13:23:07.046]                               parallel_sendData(master, data)
[13:23:07.046]                             }
[13:23:07.046]                             return(sendCondition)
[13:23:07.046]                           }
[13:23:07.046]                         }
[13:23:07.046]                         frame <- frame + 1L
[13:23:07.046]                         envir <- sys.frame(frame)
[13:23:07.046]                       }
[13:23:07.046]                     }
[13:23:07.046]                     sendCondition <<- function(cond) NULL
[13:23:07.046]                   }
[13:23:07.046]                 })
[13:23:07.046]                 withCallingHandlers({
[13:23:07.046]                   2
[13:23:07.046]                 }, immediateCondition = function(cond) {
[13:23:07.046]                   sendCondition <- ...future.makeSendCondition()
[13:23:07.046]                   sendCondition(cond)
[13:23:07.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.046]                   {
[13:23:07.046]                     inherits <- base::inherits
[13:23:07.046]                     invokeRestart <- base::invokeRestart
[13:23:07.046]                     is.null <- base::is.null
[13:23:07.046]                     muffled <- FALSE
[13:23:07.046]                     if (inherits(cond, "message")) {
[13:23:07.046]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.046]                       if (muffled) 
[13:23:07.046]                         invokeRestart("muffleMessage")
[13:23:07.046]                     }
[13:23:07.046]                     else if (inherits(cond, "warning")) {
[13:23:07.046]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.046]                       if (muffled) 
[13:23:07.046]                         invokeRestart("muffleWarning")
[13:23:07.046]                     }
[13:23:07.046]                     else if (inherits(cond, "condition")) {
[13:23:07.046]                       if (!is.null(pattern)) {
[13:23:07.046]                         computeRestarts <- base::computeRestarts
[13:23:07.046]                         grepl <- base::grepl
[13:23:07.046]                         restarts <- computeRestarts(cond)
[13:23:07.046]                         for (restart in restarts) {
[13:23:07.046]                           name <- restart$name
[13:23:07.046]                           if (is.null(name)) 
[13:23:07.046]                             next
[13:23:07.046]                           if (!grepl(pattern, name)) 
[13:23:07.046]                             next
[13:23:07.046]                           invokeRestart(restart)
[13:23:07.046]                           muffled <- TRUE
[13:23:07.046]                           break
[13:23:07.046]                         }
[13:23:07.046]                       }
[13:23:07.046]                     }
[13:23:07.046]                     invisible(muffled)
[13:23:07.046]                   }
[13:23:07.046]                   muffleCondition(cond)
[13:23:07.046]                 })
[13:23:07.046]             }))
[13:23:07.046]             future::FutureResult(value = ...future.value$value, 
[13:23:07.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.046]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.046]                     ...future.globalenv.names))
[13:23:07.046]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.046]         }, condition = base::local({
[13:23:07.046]             c <- base::c
[13:23:07.046]             inherits <- base::inherits
[13:23:07.046]             invokeRestart <- base::invokeRestart
[13:23:07.046]             length <- base::length
[13:23:07.046]             list <- base::list
[13:23:07.046]             seq.int <- base::seq.int
[13:23:07.046]             signalCondition <- base::signalCondition
[13:23:07.046]             sys.calls <- base::sys.calls
[13:23:07.046]             `[[` <- base::`[[`
[13:23:07.046]             `+` <- base::`+`
[13:23:07.046]             `<<-` <- base::`<<-`
[13:23:07.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.046]                   3L)]
[13:23:07.046]             }
[13:23:07.046]             function(cond) {
[13:23:07.046]                 is_error <- inherits(cond, "error")
[13:23:07.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.046]                   NULL)
[13:23:07.046]                 if (is_error) {
[13:23:07.046]                   sessionInformation <- function() {
[13:23:07.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.046]                       search = base::search(), system = base::Sys.info())
[13:23:07.046]                   }
[13:23:07.046]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.046]                     cond$call), session = sessionInformation(), 
[13:23:07.046]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.046]                   signalCondition(cond)
[13:23:07.046]                 }
[13:23:07.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.046]                 "immediateCondition"))) {
[13:23:07.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.046]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.046]                   if (TRUE && !signal) {
[13:23:07.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.046]                     {
[13:23:07.046]                       inherits <- base::inherits
[13:23:07.046]                       invokeRestart <- base::invokeRestart
[13:23:07.046]                       is.null <- base::is.null
[13:23:07.046]                       muffled <- FALSE
[13:23:07.046]                       if (inherits(cond, "message")) {
[13:23:07.046]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.046]                         if (muffled) 
[13:23:07.046]                           invokeRestart("muffleMessage")
[13:23:07.046]                       }
[13:23:07.046]                       else if (inherits(cond, "warning")) {
[13:23:07.046]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.046]                         if (muffled) 
[13:23:07.046]                           invokeRestart("muffleWarning")
[13:23:07.046]                       }
[13:23:07.046]                       else if (inherits(cond, "condition")) {
[13:23:07.046]                         if (!is.null(pattern)) {
[13:23:07.046]                           computeRestarts <- base::computeRestarts
[13:23:07.046]                           grepl <- base::grepl
[13:23:07.046]                           restarts <- computeRestarts(cond)
[13:23:07.046]                           for (restart in restarts) {
[13:23:07.046]                             name <- restart$name
[13:23:07.046]                             if (is.null(name)) 
[13:23:07.046]                               next
[13:23:07.046]                             if (!grepl(pattern, name)) 
[13:23:07.046]                               next
[13:23:07.046]                             invokeRestart(restart)
[13:23:07.046]                             muffled <- TRUE
[13:23:07.046]                             break
[13:23:07.046]                           }
[13:23:07.046]                         }
[13:23:07.046]                       }
[13:23:07.046]                       invisible(muffled)
[13:23:07.046]                     }
[13:23:07.046]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.046]                   }
[13:23:07.046]                 }
[13:23:07.046]                 else {
[13:23:07.046]                   if (TRUE) {
[13:23:07.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.046]                     {
[13:23:07.046]                       inherits <- base::inherits
[13:23:07.046]                       invokeRestart <- base::invokeRestart
[13:23:07.046]                       is.null <- base::is.null
[13:23:07.046]                       muffled <- FALSE
[13:23:07.046]                       if (inherits(cond, "message")) {
[13:23:07.046]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.046]                         if (muffled) 
[13:23:07.046]                           invokeRestart("muffleMessage")
[13:23:07.046]                       }
[13:23:07.046]                       else if (inherits(cond, "warning")) {
[13:23:07.046]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.046]                         if (muffled) 
[13:23:07.046]                           invokeRestart("muffleWarning")
[13:23:07.046]                       }
[13:23:07.046]                       else if (inherits(cond, "condition")) {
[13:23:07.046]                         if (!is.null(pattern)) {
[13:23:07.046]                           computeRestarts <- base::computeRestarts
[13:23:07.046]                           grepl <- base::grepl
[13:23:07.046]                           restarts <- computeRestarts(cond)
[13:23:07.046]                           for (restart in restarts) {
[13:23:07.046]                             name <- restart$name
[13:23:07.046]                             if (is.null(name)) 
[13:23:07.046]                               next
[13:23:07.046]                             if (!grepl(pattern, name)) 
[13:23:07.046]                               next
[13:23:07.046]                             invokeRestart(restart)
[13:23:07.046]                             muffled <- TRUE
[13:23:07.046]                             break
[13:23:07.046]                           }
[13:23:07.046]                         }
[13:23:07.046]                       }
[13:23:07.046]                       invisible(muffled)
[13:23:07.046]                     }
[13:23:07.046]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.046]                   }
[13:23:07.046]                 }
[13:23:07.046]             }
[13:23:07.046]         }))
[13:23:07.046]     }, error = function(ex) {
[13:23:07.046]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.046]                 ...future.rng), started = ...future.startTime, 
[13:23:07.046]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.046]             version = "1.8"), class = "FutureResult")
[13:23:07.046]     }, finally = {
[13:23:07.046]         if (!identical(...future.workdir, getwd())) 
[13:23:07.046]             setwd(...future.workdir)
[13:23:07.046]         {
[13:23:07.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.046]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.046]             }
[13:23:07.046]             base::options(...future.oldOptions)
[13:23:07.046]             if (.Platform$OS.type == "windows") {
[13:23:07.046]                 old_names <- names(...future.oldEnvVars)
[13:23:07.046]                 envs <- base::Sys.getenv()
[13:23:07.046]                 names <- names(envs)
[13:23:07.046]                 common <- intersect(names, old_names)
[13:23:07.046]                 added <- setdiff(names, old_names)
[13:23:07.046]                 removed <- setdiff(old_names, names)
[13:23:07.046]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.046]                   envs[common]]
[13:23:07.046]                 NAMES <- toupper(changed)
[13:23:07.046]                 args <- list()
[13:23:07.046]                 for (kk in seq_along(NAMES)) {
[13:23:07.046]                   name <- changed[[kk]]
[13:23:07.046]                   NAME <- NAMES[[kk]]
[13:23:07.046]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.046]                     next
[13:23:07.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.046]                 }
[13:23:07.046]                 NAMES <- toupper(added)
[13:23:07.046]                 for (kk in seq_along(NAMES)) {
[13:23:07.046]                   name <- added[[kk]]
[13:23:07.046]                   NAME <- NAMES[[kk]]
[13:23:07.046]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.046]                     next
[13:23:07.046]                   args[[name]] <- ""
[13:23:07.046]                 }
[13:23:07.046]                 NAMES <- toupper(removed)
[13:23:07.046]                 for (kk in seq_along(NAMES)) {
[13:23:07.046]                   name <- removed[[kk]]
[13:23:07.046]                   NAME <- NAMES[[kk]]
[13:23:07.046]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.046]                     next
[13:23:07.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.046]                 }
[13:23:07.046]                 if (length(args) > 0) 
[13:23:07.046]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.046]             }
[13:23:07.046]             else {
[13:23:07.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.046]             }
[13:23:07.046]             {
[13:23:07.046]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.046]                   0L) {
[13:23:07.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.046]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.046]                   base::options(opts)
[13:23:07.046]                 }
[13:23:07.046]                 {
[13:23:07.046]                   {
[13:23:07.046]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.046]                     NULL
[13:23:07.046]                   }
[13:23:07.046]                   options(future.plan = NULL)
[13:23:07.046]                   if (is.na(NA_character_)) 
[13:23:07.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.046]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:07.046]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:07.046]                     envir = parent.frame()) 
[13:23:07.046]                   {
[13:23:07.046]                     if (is.function(workers)) 
[13:23:07.046]                       workers <- workers()
[13:23:07.046]                     workers <- structure(as.integer(workers), 
[13:23:07.046]                       class = class(workers))
[13:23:07.046]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:07.046]                       workers >= 1)
[13:23:07.046]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:07.046]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:07.046]                     }
[13:23:07.046]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:07.046]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:07.046]                       envir = envir)
[13:23:07.046]                     if (!future$lazy) 
[13:23:07.046]                       future <- run(future)
[13:23:07.046]                     invisible(future)
[13:23:07.046]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.046]                 }
[13:23:07.046]             }
[13:23:07.046]         }
[13:23:07.046]     })
[13:23:07.046]     if (TRUE) {
[13:23:07.046]         base::sink(type = "output", split = FALSE)
[13:23:07.046]         if (TRUE) {
[13:23:07.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.046]         }
[13:23:07.046]         else {
[13:23:07.046]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.046]         }
[13:23:07.046]         base::close(...future.stdout)
[13:23:07.046]         ...future.stdout <- NULL
[13:23:07.046]     }
[13:23:07.046]     ...future.result$conditions <- ...future.conditions
[13:23:07.046]     ...future.result$finished <- base::Sys.time()
[13:23:07.046]     ...future.result
[13:23:07.046] }
[13:23:07.049] MultisessionFuture started
[13:23:07.049] - Launch lazy future ... done
[13:23:07.050] run() for ‘MultisessionFuture’ ... done
[13:23:07.050] getGlobalsAndPackages() ...
[13:23:07.050] Searching for globals...
[13:23:07.050] 
[13:23:07.050] Searching for globals ... DONE
[13:23:07.050] - globals: [0] <none>
[13:23:07.050] getGlobalsAndPackages() ... DONE
[13:23:07.051] run() for ‘Future’ ...
[13:23:07.051] - state: ‘created’
[13:23:07.051] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:07.066]   - Field: ‘node’
[13:23:07.066]   - Field: ‘label’
[13:23:07.066]   - Field: ‘local’
[13:23:07.066]   - Field: ‘owner’
[13:23:07.066]   - Field: ‘envir’
[13:23:07.066]   - Field: ‘workers’
[13:23:07.066]   - Field: ‘packages’
[13:23:07.066]   - Field: ‘gc’
[13:23:07.066]   - Field: ‘conditions’
[13:23:07.066]   - Field: ‘persistent’
[13:23:07.066]   - Field: ‘expr’
[13:23:07.067]   - Field: ‘uuid’
[13:23:07.067]   - Field: ‘seed’
[13:23:07.067]   - Field: ‘version’
[13:23:07.067]   - Field: ‘result’
[13:23:07.067]   - Field: ‘asynchronous’
[13:23:07.067]   - Field: ‘calls’
[13:23:07.067]   - Field: ‘globals’
[13:23:07.067]   - Field: ‘stdout’
[13:23:07.067]   - Field: ‘earlySignal’
[13:23:07.067]   - Field: ‘lazy’
[13:23:07.068]   - Field: ‘state’
[13:23:07.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:07.068] - Launch lazy future ...
[13:23:07.068] Packages needed by the future expression (n = 0): <none>
[13:23:07.068] Packages needed by future strategies (n = 0): <none>
[13:23:07.069] {
[13:23:07.069]     {
[13:23:07.069]         {
[13:23:07.069]             ...future.startTime <- base::Sys.time()
[13:23:07.069]             {
[13:23:07.069]                 {
[13:23:07.069]                   {
[13:23:07.069]                     {
[13:23:07.069]                       base::local({
[13:23:07.069]                         has_future <- base::requireNamespace("future", 
[13:23:07.069]                           quietly = TRUE)
[13:23:07.069]                         if (has_future) {
[13:23:07.069]                           ns <- base::getNamespace("future")
[13:23:07.069]                           version <- ns[[".package"]][["version"]]
[13:23:07.069]                           if (is.null(version)) 
[13:23:07.069]                             version <- utils::packageVersion("future")
[13:23:07.069]                         }
[13:23:07.069]                         else {
[13:23:07.069]                           version <- NULL
[13:23:07.069]                         }
[13:23:07.069]                         if (!has_future || version < "1.8.0") {
[13:23:07.069]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.069]                             "", base::R.version$version.string), 
[13:23:07.069]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.069]                               "release", "version")], collapse = " "), 
[13:23:07.069]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.069]                             info)
[13:23:07.069]                           info <- base::paste(info, collapse = "; ")
[13:23:07.069]                           if (!has_future) {
[13:23:07.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.069]                               info)
[13:23:07.069]                           }
[13:23:07.069]                           else {
[13:23:07.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.069]                               info, version)
[13:23:07.069]                           }
[13:23:07.069]                           base::stop(msg)
[13:23:07.069]                         }
[13:23:07.069]                       })
[13:23:07.069]                     }
[13:23:07.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.069]                     base::options(mc.cores = 1L)
[13:23:07.069]                   }
[13:23:07.069]                   options(future.plan = NULL)
[13:23:07.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.069]                 }
[13:23:07.069]                 ...future.workdir <- getwd()
[13:23:07.069]             }
[13:23:07.069]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.069]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.069]         }
[13:23:07.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.069]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.069]             base::names(...future.oldOptions))
[13:23:07.069]     }
[13:23:07.069]     if (FALSE) {
[13:23:07.069]     }
[13:23:07.069]     else {
[13:23:07.069]         if (TRUE) {
[13:23:07.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.069]                 open = "w")
[13:23:07.069]         }
[13:23:07.069]         else {
[13:23:07.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.069]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.069]         }
[13:23:07.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.069]             base::sink(type = "output", split = FALSE)
[13:23:07.069]             base::close(...future.stdout)
[13:23:07.069]         }, add = TRUE)
[13:23:07.069]     }
[13:23:07.069]     ...future.frame <- base::sys.nframe()
[13:23:07.069]     ...future.conditions <- base::list()
[13:23:07.069]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.069]     if (FALSE) {
[13:23:07.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.069]     }
[13:23:07.069]     ...future.result <- base::tryCatch({
[13:23:07.069]         base::withCallingHandlers({
[13:23:07.069]             ...future.value <- base::withVisible(base::local({
[13:23:07.069]                 ...future.makeSendCondition <- base::local({
[13:23:07.069]                   sendCondition <- NULL
[13:23:07.069]                   function(frame = 1L) {
[13:23:07.069]                     if (is.function(sendCondition)) 
[13:23:07.069]                       return(sendCondition)
[13:23:07.069]                     ns <- getNamespace("parallel")
[13:23:07.069]                     if (exists("sendData", mode = "function", 
[13:23:07.069]                       envir = ns)) {
[13:23:07.069]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:07.069]                         envir = ns)
[13:23:07.069]                       envir <- sys.frame(frame)
[13:23:07.069]                       master <- NULL
[13:23:07.069]                       while (!identical(envir, .GlobalEnv) && 
[13:23:07.069]                         !identical(envir, emptyenv())) {
[13:23:07.069]                         if (exists("master", mode = "list", envir = envir, 
[13:23:07.069]                           inherits = FALSE)) {
[13:23:07.069]                           master <- get("master", mode = "list", 
[13:23:07.069]                             envir = envir, inherits = FALSE)
[13:23:07.069]                           if (inherits(master, c("SOCKnode", 
[13:23:07.069]                             "SOCK0node"))) {
[13:23:07.069]                             sendCondition <<- function(cond) {
[13:23:07.069]                               data <- list(type = "VALUE", value = cond, 
[13:23:07.069]                                 success = TRUE)
[13:23:07.069]                               parallel_sendData(master, data)
[13:23:07.069]                             }
[13:23:07.069]                             return(sendCondition)
[13:23:07.069]                           }
[13:23:07.069]                         }
[13:23:07.069]                         frame <- frame + 1L
[13:23:07.069]                         envir <- sys.frame(frame)
[13:23:07.069]                       }
[13:23:07.069]                     }
[13:23:07.069]                     sendCondition <<- function(cond) NULL
[13:23:07.069]                   }
[13:23:07.069]                 })
[13:23:07.069]                 withCallingHandlers({
[13:23:07.069]                   NULL
[13:23:07.069]                 }, immediateCondition = function(cond) {
[13:23:07.069]                   sendCondition <- ...future.makeSendCondition()
[13:23:07.069]                   sendCondition(cond)
[13:23:07.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.069]                   {
[13:23:07.069]                     inherits <- base::inherits
[13:23:07.069]                     invokeRestart <- base::invokeRestart
[13:23:07.069]                     is.null <- base::is.null
[13:23:07.069]                     muffled <- FALSE
[13:23:07.069]                     if (inherits(cond, "message")) {
[13:23:07.069]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.069]                       if (muffled) 
[13:23:07.069]                         invokeRestart("muffleMessage")
[13:23:07.069]                     }
[13:23:07.069]                     else if (inherits(cond, "warning")) {
[13:23:07.069]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.069]                       if (muffled) 
[13:23:07.069]                         invokeRestart("muffleWarning")
[13:23:07.069]                     }
[13:23:07.069]                     else if (inherits(cond, "condition")) {
[13:23:07.069]                       if (!is.null(pattern)) {
[13:23:07.069]                         computeRestarts <- base::computeRestarts
[13:23:07.069]                         grepl <- base::grepl
[13:23:07.069]                         restarts <- computeRestarts(cond)
[13:23:07.069]                         for (restart in restarts) {
[13:23:07.069]                           name <- restart$name
[13:23:07.069]                           if (is.null(name)) 
[13:23:07.069]                             next
[13:23:07.069]                           if (!grepl(pattern, name)) 
[13:23:07.069]                             next
[13:23:07.069]                           invokeRestart(restart)
[13:23:07.069]                           muffled <- TRUE
[13:23:07.069]                           break
[13:23:07.069]                         }
[13:23:07.069]                       }
[13:23:07.069]                     }
[13:23:07.069]                     invisible(muffled)
[13:23:07.069]                   }
[13:23:07.069]                   muffleCondition(cond)
[13:23:07.069]                 })
[13:23:07.069]             }))
[13:23:07.069]             future::FutureResult(value = ...future.value$value, 
[13:23:07.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.069]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.069]                     ...future.globalenv.names))
[13:23:07.069]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.069]         }, condition = base::local({
[13:23:07.069]             c <- base::c
[13:23:07.069]             inherits <- base::inherits
[13:23:07.069]             invokeRestart <- base::invokeRestart
[13:23:07.069]             length <- base::length
[13:23:07.069]             list <- base::list
[13:23:07.069]             seq.int <- base::seq.int
[13:23:07.069]             signalCondition <- base::signalCondition
[13:23:07.069]             sys.calls <- base::sys.calls
[13:23:07.069]             `[[` <- base::`[[`
[13:23:07.069]             `+` <- base::`+`
[13:23:07.069]             `<<-` <- base::`<<-`
[13:23:07.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.069]                   3L)]
[13:23:07.069]             }
[13:23:07.069]             function(cond) {
[13:23:07.069]                 is_error <- inherits(cond, "error")
[13:23:07.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.069]                   NULL)
[13:23:07.069]                 if (is_error) {
[13:23:07.069]                   sessionInformation <- function() {
[13:23:07.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.069]                       search = base::search(), system = base::Sys.info())
[13:23:07.069]                   }
[13:23:07.069]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.069]                     cond$call), session = sessionInformation(), 
[13:23:07.069]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.069]                   signalCondition(cond)
[13:23:07.069]                 }
[13:23:07.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.069]                 "immediateCondition"))) {
[13:23:07.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.069]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.069]                   if (TRUE && !signal) {
[13:23:07.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.069]                     {
[13:23:07.069]                       inherits <- base::inherits
[13:23:07.069]                       invokeRestart <- base::invokeRestart
[13:23:07.069]                       is.null <- base::is.null
[13:23:07.069]                       muffled <- FALSE
[13:23:07.069]                       if (inherits(cond, "message")) {
[13:23:07.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.069]                         if (muffled) 
[13:23:07.069]                           invokeRestart("muffleMessage")
[13:23:07.069]                       }
[13:23:07.069]                       else if (inherits(cond, "warning")) {
[13:23:07.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.069]                         if (muffled) 
[13:23:07.069]                           invokeRestart("muffleWarning")
[13:23:07.069]                       }
[13:23:07.069]                       else if (inherits(cond, "condition")) {
[13:23:07.069]                         if (!is.null(pattern)) {
[13:23:07.069]                           computeRestarts <- base::computeRestarts
[13:23:07.069]                           grepl <- base::grepl
[13:23:07.069]                           restarts <- computeRestarts(cond)
[13:23:07.069]                           for (restart in restarts) {
[13:23:07.069]                             name <- restart$name
[13:23:07.069]                             if (is.null(name)) 
[13:23:07.069]                               next
[13:23:07.069]                             if (!grepl(pattern, name)) 
[13:23:07.069]                               next
[13:23:07.069]                             invokeRestart(restart)
[13:23:07.069]                             muffled <- TRUE
[13:23:07.069]                             break
[13:23:07.069]                           }
[13:23:07.069]                         }
[13:23:07.069]                       }
[13:23:07.069]                       invisible(muffled)
[13:23:07.069]                     }
[13:23:07.069]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.069]                   }
[13:23:07.069]                 }
[13:23:07.069]                 else {
[13:23:07.069]                   if (TRUE) {
[13:23:07.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.069]                     {
[13:23:07.069]                       inherits <- base::inherits
[13:23:07.069]                       invokeRestart <- base::invokeRestart
[13:23:07.069]                       is.null <- base::is.null
[13:23:07.069]                       muffled <- FALSE
[13:23:07.069]                       if (inherits(cond, "message")) {
[13:23:07.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.069]                         if (muffled) 
[13:23:07.069]                           invokeRestart("muffleMessage")
[13:23:07.069]                       }
[13:23:07.069]                       else if (inherits(cond, "warning")) {
[13:23:07.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.069]                         if (muffled) 
[13:23:07.069]                           invokeRestart("muffleWarning")
[13:23:07.069]                       }
[13:23:07.069]                       else if (inherits(cond, "condition")) {
[13:23:07.069]                         if (!is.null(pattern)) {
[13:23:07.069]                           computeRestarts <- base::computeRestarts
[13:23:07.069]                           grepl <- base::grepl
[13:23:07.069]                           restarts <- computeRestarts(cond)
[13:23:07.069]                           for (restart in restarts) {
[13:23:07.069]                             name <- restart$name
[13:23:07.069]                             if (is.null(name)) 
[13:23:07.069]                               next
[13:23:07.069]                             if (!grepl(pattern, name)) 
[13:23:07.069]                               next
[13:23:07.069]                             invokeRestart(restart)
[13:23:07.069]                             muffled <- TRUE
[13:23:07.069]                             break
[13:23:07.069]                           }
[13:23:07.069]                         }
[13:23:07.069]                       }
[13:23:07.069]                       invisible(muffled)
[13:23:07.069]                     }
[13:23:07.069]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.069]                   }
[13:23:07.069]                 }
[13:23:07.069]             }
[13:23:07.069]         }))
[13:23:07.069]     }, error = function(ex) {
[13:23:07.069]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.069]                 ...future.rng), started = ...future.startTime, 
[13:23:07.069]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.069]             version = "1.8"), class = "FutureResult")
[13:23:07.069]     }, finally = {
[13:23:07.069]         if (!identical(...future.workdir, getwd())) 
[13:23:07.069]             setwd(...future.workdir)
[13:23:07.069]         {
[13:23:07.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.069]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.069]             }
[13:23:07.069]             base::options(...future.oldOptions)
[13:23:07.069]             if (.Platform$OS.type == "windows") {
[13:23:07.069]                 old_names <- names(...future.oldEnvVars)
[13:23:07.069]                 envs <- base::Sys.getenv()
[13:23:07.069]                 names <- names(envs)
[13:23:07.069]                 common <- intersect(names, old_names)
[13:23:07.069]                 added <- setdiff(names, old_names)
[13:23:07.069]                 removed <- setdiff(old_names, names)
[13:23:07.069]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.069]                   envs[common]]
[13:23:07.069]                 NAMES <- toupper(changed)
[13:23:07.069]                 args <- list()
[13:23:07.069]                 for (kk in seq_along(NAMES)) {
[13:23:07.069]                   name <- changed[[kk]]
[13:23:07.069]                   NAME <- NAMES[[kk]]
[13:23:07.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.069]                     next
[13:23:07.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.069]                 }
[13:23:07.069]                 NAMES <- toupper(added)
[13:23:07.069]                 for (kk in seq_along(NAMES)) {
[13:23:07.069]                   name <- added[[kk]]
[13:23:07.069]                   NAME <- NAMES[[kk]]
[13:23:07.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.069]                     next
[13:23:07.069]                   args[[name]] <- ""
[13:23:07.069]                 }
[13:23:07.069]                 NAMES <- toupper(removed)
[13:23:07.069]                 for (kk in seq_along(NAMES)) {
[13:23:07.069]                   name <- removed[[kk]]
[13:23:07.069]                   NAME <- NAMES[[kk]]
[13:23:07.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.069]                     next
[13:23:07.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.069]                 }
[13:23:07.069]                 if (length(args) > 0) 
[13:23:07.069]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.069]             }
[13:23:07.069]             else {
[13:23:07.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.069]             }
[13:23:07.069]             {
[13:23:07.069]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.069]                   0L) {
[13:23:07.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.069]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.069]                   base::options(opts)
[13:23:07.069]                 }
[13:23:07.069]                 {
[13:23:07.069]                   {
[13:23:07.069]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.069]                     NULL
[13:23:07.069]                   }
[13:23:07.069]                   options(future.plan = NULL)
[13:23:07.069]                   if (is.na(NA_character_)) 
[13:23:07.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.069]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:07.069]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:07.069]                     envir = parent.frame()) 
[13:23:07.069]                   {
[13:23:07.069]                     if (is.function(workers)) 
[13:23:07.069]                       workers <- workers()
[13:23:07.069]                     workers <- structure(as.integer(workers), 
[13:23:07.069]                       class = class(workers))
[13:23:07.069]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:07.069]                       workers >= 1)
[13:23:07.069]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:07.069]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:07.069]                     }
[13:23:07.069]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:07.069]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:07.069]                       envir = envir)
[13:23:07.069]                     if (!future$lazy) 
[13:23:07.069]                       future <- run(future)
[13:23:07.069]                     invisible(future)
[13:23:07.069]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.069]                 }
[13:23:07.069]             }
[13:23:07.069]         }
[13:23:07.069]     })
[13:23:07.069]     if (TRUE) {
[13:23:07.069]         base::sink(type = "output", split = FALSE)
[13:23:07.069]         if (TRUE) {
[13:23:07.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.069]         }
[13:23:07.069]         else {
[13:23:07.069]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.069]         }
[13:23:07.069]         base::close(...future.stdout)
[13:23:07.069]         ...future.stdout <- NULL
[13:23:07.069]     }
[13:23:07.069]     ...future.result$conditions <- ...future.conditions
[13:23:07.069]     ...future.result$finished <- base::Sys.time()
[13:23:07.069]     ...future.result
[13:23:07.069] }
[13:23:07.072] MultisessionFuture started
[13:23:07.072] - Launch lazy future ... done
[13:23:07.072] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5aa6db8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d54b9fc0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5aa6db8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d54b9fc0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:07.101] resolve() on list ...
[13:23:07.101]  recursive: 0
[13:23:07.101]  length: 6
[13:23:07.101]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:07.101] signalConditionsASAP(numeric, pos=1) ...
[13:23:07.101] - nx: 6
[13:23:07.101] - relay: TRUE
[13:23:07.101] - stdout: TRUE
[13:23:07.101] - signal: TRUE
[13:23:07.102] - resignal: FALSE
[13:23:07.102] - force: TRUE
[13:23:07.102] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.102] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.102]  - until=2
[13:23:07.102]  - relaying element #2
[13:23:07.102] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.102] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.102] signalConditionsASAP(NULL, pos=1) ... done
[13:23:07.102]  length: 5 (resolved future 1)
[13:23:07.103] receiveMessageFromWorker() for ClusterFuture ...
[13:23:07.103] - Validating connection of MultisessionFuture
[13:23:07.103] - received message: FutureResult
[13:23:07.103] - Received FutureResult
[13:23:07.104] - Erased future from FutureRegistry
[13:23:07.104] result() for ClusterFuture ...
[13:23:07.104] - result already collected: FutureResult
[13:23:07.104] result() for ClusterFuture ... done
[13:23:07.104] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:07.104] Future #2
[13:23:07.104] result() for ClusterFuture ...
[13:23:07.104] - result already collected: FutureResult
[13:23:07.104] result() for ClusterFuture ... done
[13:23:07.104] result() for ClusterFuture ...
[13:23:07.105] - result already collected: FutureResult
[13:23:07.105] result() for ClusterFuture ... done
[13:23:07.105] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:07.105] - nx: 6
[13:23:07.105] - relay: TRUE
[13:23:07.105] - stdout: TRUE
[13:23:07.105] - signal: TRUE
[13:23:07.105] - resignal: FALSE
[13:23:07.105] - force: TRUE
[13:23:07.105] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.105] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.106]  - until=2
[13:23:07.106]  - relaying element #2
[13:23:07.106] result() for ClusterFuture ...
[13:23:07.106] - result already collected: FutureResult
[13:23:07.106] result() for ClusterFuture ... done
[13:23:07.106] result() for ClusterFuture ...
[13:23:07.106] - result already collected: FutureResult
[13:23:07.106] result() for ClusterFuture ... done
[13:23:07.106] result() for ClusterFuture ...
[13:23:07.106] - result already collected: FutureResult
[13:23:07.107] result() for ClusterFuture ... done
[13:23:07.107] result() for ClusterFuture ...
[13:23:07.107] - result already collected: FutureResult
[13:23:07.107] result() for ClusterFuture ... done
[13:23:07.107] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.107] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.107] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:07.107]  length: 4 (resolved future 2)
[13:23:07.118] signalConditionsASAP(NULL, pos=4) ...
[13:23:07.118] - nx: 6
[13:23:07.118] - relay: TRUE
[13:23:07.118] - stdout: TRUE
[13:23:07.118] - signal: TRUE
[13:23:07.119] - resignal: FALSE
[13:23:07.119] - force: TRUE
[13:23:07.119] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.119] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.119]  - until=5
[13:23:07.119]  - relaying element #3
[13:23:07.119]  - relaying element #5
[13:23:07.119] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:23:07.119] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.119] signalConditionsASAP(NULL, pos=4) ... done
[13:23:07.120]  length: 3 (resolved future 4)
[13:23:07.120] signalConditionsASAP(NULL, pos=5) ...
[13:23:07.120] - nx: 6
[13:23:07.120] - relay: TRUE
[13:23:07.120] - stdout: TRUE
[13:23:07.120] - signal: TRUE
[13:23:07.120] - resignal: FALSE
[13:23:07.120] - force: TRUE
[13:23:07.120] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:23:07.121] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.121]  - until=6
[13:23:07.121]  - relaying element #3
[13:23:07.121]  - relaying element #6
[13:23:07.121] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:23:07.121] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.122] signalConditionsASAP(NULL, pos=5) ... done
[13:23:07.122]  length: 2 (resolved future 5)
[13:23:07.122] signalConditionsASAP(numeric, pos=6) ...
[13:23:07.122] - nx: 6
[13:23:07.122] - relay: TRUE
[13:23:07.122] - stdout: TRUE
[13:23:07.122] - signal: TRUE
[13:23:07.123] - resignal: FALSE
[13:23:07.123] - force: TRUE
[13:23:07.123] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:23:07.123] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.123]  - until=6
[13:23:07.123]  - relaying element #3
[13:23:07.123] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:23:07.123] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.123] signalConditionsASAP(NULL, pos=6) ... done
[13:23:07.123]  length: 1 (resolved future 6)
[13:23:07.134] receiveMessageFromWorker() for ClusterFuture ...
[13:23:07.134] - Validating connection of MultisessionFuture
[13:23:07.135] - received message: FutureResult
[13:23:07.135] - Received FutureResult
[13:23:07.135] - Erased future from FutureRegistry
[13:23:07.135] result() for ClusterFuture ...
[13:23:07.135] - result already collected: FutureResult
[13:23:07.135] result() for ClusterFuture ... done
[13:23:07.135] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:07.135] Future #3
[13:23:07.135] result() for ClusterFuture ...
[13:23:07.135] - result already collected: FutureResult
[13:23:07.136] result() for ClusterFuture ... done
[13:23:07.136] result() for ClusterFuture ...
[13:23:07.136] - result already collected: FutureResult
[13:23:07.136] result() for ClusterFuture ... done
[13:23:07.136] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:07.136] - nx: 6
[13:23:07.136] - relay: TRUE
[13:23:07.136] - stdout: TRUE
[13:23:07.136] - signal: TRUE
[13:23:07.136] - resignal: FALSE
[13:23:07.137] - force: TRUE
[13:23:07.137] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:23:07.137] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.137]  - until=6
[13:23:07.137]  - relaying element #3
[13:23:07.137] result() for ClusterFuture ...
[13:23:07.137] - result already collected: FutureResult
[13:23:07.137] result() for ClusterFuture ... done
[13:23:07.137] result() for ClusterFuture ...
[13:23:07.137] - result already collected: FutureResult
[13:23:07.137] result() for ClusterFuture ... done
[13:23:07.138] result() for ClusterFuture ...
[13:23:07.138] - result already collected: FutureResult
[13:23:07.138] result() for ClusterFuture ... done
[13:23:07.138] result() for ClusterFuture ...
[13:23:07.138] - result already collected: FutureResult
[13:23:07.138] result() for ClusterFuture ... done
[13:23:07.138] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.138] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.138] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:07.138]  length: 0 (resolved future 3)
[13:23:07.138] Relaying remaining futures
[13:23:07.139] signalConditionsASAP(NULL, pos=0) ...
[13:23:07.139] - nx: 6
[13:23:07.139] - relay: TRUE
[13:23:07.139] - stdout: TRUE
[13:23:07.139] - signal: TRUE
[13:23:07.139] - resignal: FALSE
[13:23:07.139] - force: TRUE
[13:23:07.139] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.139] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:07.139] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.139] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.140] signalConditionsASAP(NULL, pos=0) ... done
[13:23:07.140] resolve() on list ... DONE
[13:23:07.140] result() for ClusterFuture ...
[13:23:07.140] - result already collected: FutureResult
[13:23:07.140] result() for ClusterFuture ... done
[13:23:07.140] result() for ClusterFuture ...
[13:23:07.140] - result already collected: FutureResult
[13:23:07.140] result() for ClusterFuture ... done
[13:23:07.140] result() for ClusterFuture ...
[13:23:07.140] - result already collected: FutureResult
[13:23:07.141] result() for ClusterFuture ... done
[13:23:07.141] result() for ClusterFuture ...
[13:23:07.141] - result already collected: FutureResult
[13:23:07.141] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:23:07.144] getGlobalsAndPackages() ...
[13:23:07.144] Searching for globals...
[13:23:07.145] 
[13:23:07.145] Searching for globals ... DONE
[13:23:07.145] - globals: [0] <none>
[13:23:07.145] getGlobalsAndPackages() ... DONE
[13:23:07.145] run() for ‘Future’ ...
[13:23:07.145] - state: ‘created’
[13:23:07.146] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.160] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.160] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:07.161]   - Field: ‘node’
[13:23:07.161]   - Field: ‘label’
[13:23:07.161]   - Field: ‘local’
[13:23:07.161]   - Field: ‘owner’
[13:23:07.161]   - Field: ‘envir’
[13:23:07.161]   - Field: ‘workers’
[13:23:07.161]   - Field: ‘packages’
[13:23:07.161]   - Field: ‘gc’
[13:23:07.161]   - Field: ‘conditions’
[13:23:07.161]   - Field: ‘persistent’
[13:23:07.161]   - Field: ‘expr’
[13:23:07.162]   - Field: ‘uuid’
[13:23:07.162]   - Field: ‘seed’
[13:23:07.162]   - Field: ‘version’
[13:23:07.162]   - Field: ‘result’
[13:23:07.162]   - Field: ‘asynchronous’
[13:23:07.162]   - Field: ‘calls’
[13:23:07.162]   - Field: ‘globals’
[13:23:07.162]   - Field: ‘stdout’
[13:23:07.162]   - Field: ‘earlySignal’
[13:23:07.162]   - Field: ‘lazy’
[13:23:07.163]   - Field: ‘state’
[13:23:07.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:07.163] - Launch lazy future ...
[13:23:07.163] Packages needed by the future expression (n = 0): <none>
[13:23:07.163] Packages needed by future strategies (n = 0): <none>
[13:23:07.164] {
[13:23:07.164]     {
[13:23:07.164]         {
[13:23:07.164]             ...future.startTime <- base::Sys.time()
[13:23:07.164]             {
[13:23:07.164]                 {
[13:23:07.164]                   {
[13:23:07.164]                     {
[13:23:07.164]                       base::local({
[13:23:07.164]                         has_future <- base::requireNamespace("future", 
[13:23:07.164]                           quietly = TRUE)
[13:23:07.164]                         if (has_future) {
[13:23:07.164]                           ns <- base::getNamespace("future")
[13:23:07.164]                           version <- ns[[".package"]][["version"]]
[13:23:07.164]                           if (is.null(version)) 
[13:23:07.164]                             version <- utils::packageVersion("future")
[13:23:07.164]                         }
[13:23:07.164]                         else {
[13:23:07.164]                           version <- NULL
[13:23:07.164]                         }
[13:23:07.164]                         if (!has_future || version < "1.8.0") {
[13:23:07.164]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.164]                             "", base::R.version$version.string), 
[13:23:07.164]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.164]                               "release", "version")], collapse = " "), 
[13:23:07.164]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.164]                             info)
[13:23:07.164]                           info <- base::paste(info, collapse = "; ")
[13:23:07.164]                           if (!has_future) {
[13:23:07.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.164]                               info)
[13:23:07.164]                           }
[13:23:07.164]                           else {
[13:23:07.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.164]                               info, version)
[13:23:07.164]                           }
[13:23:07.164]                           base::stop(msg)
[13:23:07.164]                         }
[13:23:07.164]                       })
[13:23:07.164]                     }
[13:23:07.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.164]                     base::options(mc.cores = 1L)
[13:23:07.164]                   }
[13:23:07.164]                   options(future.plan = NULL)
[13:23:07.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.164]                 }
[13:23:07.164]                 ...future.workdir <- getwd()
[13:23:07.164]             }
[13:23:07.164]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.164]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.164]         }
[13:23:07.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.164]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.164]             base::names(...future.oldOptions))
[13:23:07.164]     }
[13:23:07.164]     if (FALSE) {
[13:23:07.164]     }
[13:23:07.164]     else {
[13:23:07.164]         if (TRUE) {
[13:23:07.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.164]                 open = "w")
[13:23:07.164]         }
[13:23:07.164]         else {
[13:23:07.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.164]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.164]         }
[13:23:07.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.164]             base::sink(type = "output", split = FALSE)
[13:23:07.164]             base::close(...future.stdout)
[13:23:07.164]         }, add = TRUE)
[13:23:07.164]     }
[13:23:07.164]     ...future.frame <- base::sys.nframe()
[13:23:07.164]     ...future.conditions <- base::list()
[13:23:07.164]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.164]     if (FALSE) {
[13:23:07.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.164]     }
[13:23:07.164]     ...future.result <- base::tryCatch({
[13:23:07.164]         base::withCallingHandlers({
[13:23:07.164]             ...future.value <- base::withVisible(base::local({
[13:23:07.164]                 ...future.makeSendCondition <- base::local({
[13:23:07.164]                   sendCondition <- NULL
[13:23:07.164]                   function(frame = 1L) {
[13:23:07.164]                     if (is.function(sendCondition)) 
[13:23:07.164]                       return(sendCondition)
[13:23:07.164]                     ns <- getNamespace("parallel")
[13:23:07.164]                     if (exists("sendData", mode = "function", 
[13:23:07.164]                       envir = ns)) {
[13:23:07.164]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:07.164]                         envir = ns)
[13:23:07.164]                       envir <- sys.frame(frame)
[13:23:07.164]                       master <- NULL
[13:23:07.164]                       while (!identical(envir, .GlobalEnv) && 
[13:23:07.164]                         !identical(envir, emptyenv())) {
[13:23:07.164]                         if (exists("master", mode = "list", envir = envir, 
[13:23:07.164]                           inherits = FALSE)) {
[13:23:07.164]                           master <- get("master", mode = "list", 
[13:23:07.164]                             envir = envir, inherits = FALSE)
[13:23:07.164]                           if (inherits(master, c("SOCKnode", 
[13:23:07.164]                             "SOCK0node"))) {
[13:23:07.164]                             sendCondition <<- function(cond) {
[13:23:07.164]                               data <- list(type = "VALUE", value = cond, 
[13:23:07.164]                                 success = TRUE)
[13:23:07.164]                               parallel_sendData(master, data)
[13:23:07.164]                             }
[13:23:07.164]                             return(sendCondition)
[13:23:07.164]                           }
[13:23:07.164]                         }
[13:23:07.164]                         frame <- frame + 1L
[13:23:07.164]                         envir <- sys.frame(frame)
[13:23:07.164]                       }
[13:23:07.164]                     }
[13:23:07.164]                     sendCondition <<- function(cond) NULL
[13:23:07.164]                   }
[13:23:07.164]                 })
[13:23:07.164]                 withCallingHandlers({
[13:23:07.164]                   2
[13:23:07.164]                 }, immediateCondition = function(cond) {
[13:23:07.164]                   sendCondition <- ...future.makeSendCondition()
[13:23:07.164]                   sendCondition(cond)
[13:23:07.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.164]                   {
[13:23:07.164]                     inherits <- base::inherits
[13:23:07.164]                     invokeRestart <- base::invokeRestart
[13:23:07.164]                     is.null <- base::is.null
[13:23:07.164]                     muffled <- FALSE
[13:23:07.164]                     if (inherits(cond, "message")) {
[13:23:07.164]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.164]                       if (muffled) 
[13:23:07.164]                         invokeRestart("muffleMessage")
[13:23:07.164]                     }
[13:23:07.164]                     else if (inherits(cond, "warning")) {
[13:23:07.164]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.164]                       if (muffled) 
[13:23:07.164]                         invokeRestart("muffleWarning")
[13:23:07.164]                     }
[13:23:07.164]                     else if (inherits(cond, "condition")) {
[13:23:07.164]                       if (!is.null(pattern)) {
[13:23:07.164]                         computeRestarts <- base::computeRestarts
[13:23:07.164]                         grepl <- base::grepl
[13:23:07.164]                         restarts <- computeRestarts(cond)
[13:23:07.164]                         for (restart in restarts) {
[13:23:07.164]                           name <- restart$name
[13:23:07.164]                           if (is.null(name)) 
[13:23:07.164]                             next
[13:23:07.164]                           if (!grepl(pattern, name)) 
[13:23:07.164]                             next
[13:23:07.164]                           invokeRestart(restart)
[13:23:07.164]                           muffled <- TRUE
[13:23:07.164]                           break
[13:23:07.164]                         }
[13:23:07.164]                       }
[13:23:07.164]                     }
[13:23:07.164]                     invisible(muffled)
[13:23:07.164]                   }
[13:23:07.164]                   muffleCondition(cond)
[13:23:07.164]                 })
[13:23:07.164]             }))
[13:23:07.164]             future::FutureResult(value = ...future.value$value, 
[13:23:07.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.164]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.164]                     ...future.globalenv.names))
[13:23:07.164]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.164]         }, condition = base::local({
[13:23:07.164]             c <- base::c
[13:23:07.164]             inherits <- base::inherits
[13:23:07.164]             invokeRestart <- base::invokeRestart
[13:23:07.164]             length <- base::length
[13:23:07.164]             list <- base::list
[13:23:07.164]             seq.int <- base::seq.int
[13:23:07.164]             signalCondition <- base::signalCondition
[13:23:07.164]             sys.calls <- base::sys.calls
[13:23:07.164]             `[[` <- base::`[[`
[13:23:07.164]             `+` <- base::`+`
[13:23:07.164]             `<<-` <- base::`<<-`
[13:23:07.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.164]                   3L)]
[13:23:07.164]             }
[13:23:07.164]             function(cond) {
[13:23:07.164]                 is_error <- inherits(cond, "error")
[13:23:07.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.164]                   NULL)
[13:23:07.164]                 if (is_error) {
[13:23:07.164]                   sessionInformation <- function() {
[13:23:07.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.164]                       search = base::search(), system = base::Sys.info())
[13:23:07.164]                   }
[13:23:07.164]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.164]                     cond$call), session = sessionInformation(), 
[13:23:07.164]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.164]                   signalCondition(cond)
[13:23:07.164]                 }
[13:23:07.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.164]                 "immediateCondition"))) {
[13:23:07.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.164]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.164]                   if (TRUE && !signal) {
[13:23:07.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.164]                     {
[13:23:07.164]                       inherits <- base::inherits
[13:23:07.164]                       invokeRestart <- base::invokeRestart
[13:23:07.164]                       is.null <- base::is.null
[13:23:07.164]                       muffled <- FALSE
[13:23:07.164]                       if (inherits(cond, "message")) {
[13:23:07.164]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.164]                         if (muffled) 
[13:23:07.164]                           invokeRestart("muffleMessage")
[13:23:07.164]                       }
[13:23:07.164]                       else if (inherits(cond, "warning")) {
[13:23:07.164]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.164]                         if (muffled) 
[13:23:07.164]                           invokeRestart("muffleWarning")
[13:23:07.164]                       }
[13:23:07.164]                       else if (inherits(cond, "condition")) {
[13:23:07.164]                         if (!is.null(pattern)) {
[13:23:07.164]                           computeRestarts <- base::computeRestarts
[13:23:07.164]                           grepl <- base::grepl
[13:23:07.164]                           restarts <- computeRestarts(cond)
[13:23:07.164]                           for (restart in restarts) {
[13:23:07.164]                             name <- restart$name
[13:23:07.164]                             if (is.null(name)) 
[13:23:07.164]                               next
[13:23:07.164]                             if (!grepl(pattern, name)) 
[13:23:07.164]                               next
[13:23:07.164]                             invokeRestart(restart)
[13:23:07.164]                             muffled <- TRUE
[13:23:07.164]                             break
[13:23:07.164]                           }
[13:23:07.164]                         }
[13:23:07.164]                       }
[13:23:07.164]                       invisible(muffled)
[13:23:07.164]                     }
[13:23:07.164]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.164]                   }
[13:23:07.164]                 }
[13:23:07.164]                 else {
[13:23:07.164]                   if (TRUE) {
[13:23:07.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.164]                     {
[13:23:07.164]                       inherits <- base::inherits
[13:23:07.164]                       invokeRestart <- base::invokeRestart
[13:23:07.164]                       is.null <- base::is.null
[13:23:07.164]                       muffled <- FALSE
[13:23:07.164]                       if (inherits(cond, "message")) {
[13:23:07.164]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.164]                         if (muffled) 
[13:23:07.164]                           invokeRestart("muffleMessage")
[13:23:07.164]                       }
[13:23:07.164]                       else if (inherits(cond, "warning")) {
[13:23:07.164]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.164]                         if (muffled) 
[13:23:07.164]                           invokeRestart("muffleWarning")
[13:23:07.164]                       }
[13:23:07.164]                       else if (inherits(cond, "condition")) {
[13:23:07.164]                         if (!is.null(pattern)) {
[13:23:07.164]                           computeRestarts <- base::computeRestarts
[13:23:07.164]                           grepl <- base::grepl
[13:23:07.164]                           restarts <- computeRestarts(cond)
[13:23:07.164]                           for (restart in restarts) {
[13:23:07.164]                             name <- restart$name
[13:23:07.164]                             if (is.null(name)) 
[13:23:07.164]                               next
[13:23:07.164]                             if (!grepl(pattern, name)) 
[13:23:07.164]                               next
[13:23:07.164]                             invokeRestart(restart)
[13:23:07.164]                             muffled <- TRUE
[13:23:07.164]                             break
[13:23:07.164]                           }
[13:23:07.164]                         }
[13:23:07.164]                       }
[13:23:07.164]                       invisible(muffled)
[13:23:07.164]                     }
[13:23:07.164]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.164]                   }
[13:23:07.164]                 }
[13:23:07.164]             }
[13:23:07.164]         }))
[13:23:07.164]     }, error = function(ex) {
[13:23:07.164]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.164]                 ...future.rng), started = ...future.startTime, 
[13:23:07.164]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.164]             version = "1.8"), class = "FutureResult")
[13:23:07.164]     }, finally = {
[13:23:07.164]         if (!identical(...future.workdir, getwd())) 
[13:23:07.164]             setwd(...future.workdir)
[13:23:07.164]         {
[13:23:07.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.164]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.164]             }
[13:23:07.164]             base::options(...future.oldOptions)
[13:23:07.164]             if (.Platform$OS.type == "windows") {
[13:23:07.164]                 old_names <- names(...future.oldEnvVars)
[13:23:07.164]                 envs <- base::Sys.getenv()
[13:23:07.164]                 names <- names(envs)
[13:23:07.164]                 common <- intersect(names, old_names)
[13:23:07.164]                 added <- setdiff(names, old_names)
[13:23:07.164]                 removed <- setdiff(old_names, names)
[13:23:07.164]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.164]                   envs[common]]
[13:23:07.164]                 NAMES <- toupper(changed)
[13:23:07.164]                 args <- list()
[13:23:07.164]                 for (kk in seq_along(NAMES)) {
[13:23:07.164]                   name <- changed[[kk]]
[13:23:07.164]                   NAME <- NAMES[[kk]]
[13:23:07.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.164]                     next
[13:23:07.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.164]                 }
[13:23:07.164]                 NAMES <- toupper(added)
[13:23:07.164]                 for (kk in seq_along(NAMES)) {
[13:23:07.164]                   name <- added[[kk]]
[13:23:07.164]                   NAME <- NAMES[[kk]]
[13:23:07.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.164]                     next
[13:23:07.164]                   args[[name]] <- ""
[13:23:07.164]                 }
[13:23:07.164]                 NAMES <- toupper(removed)
[13:23:07.164]                 for (kk in seq_along(NAMES)) {
[13:23:07.164]                   name <- removed[[kk]]
[13:23:07.164]                   NAME <- NAMES[[kk]]
[13:23:07.164]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.164]                     next
[13:23:07.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.164]                 }
[13:23:07.164]                 if (length(args) > 0) 
[13:23:07.164]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.164]             }
[13:23:07.164]             else {
[13:23:07.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.164]             }
[13:23:07.164]             {
[13:23:07.164]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.164]                   0L) {
[13:23:07.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.164]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.164]                   base::options(opts)
[13:23:07.164]                 }
[13:23:07.164]                 {
[13:23:07.164]                   {
[13:23:07.164]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.164]                     NULL
[13:23:07.164]                   }
[13:23:07.164]                   options(future.plan = NULL)
[13:23:07.164]                   if (is.na(NA_character_)) 
[13:23:07.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.164]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:07.164]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:07.164]                     envir = parent.frame()) 
[13:23:07.164]                   {
[13:23:07.164]                     if (is.function(workers)) 
[13:23:07.164]                       workers <- workers()
[13:23:07.164]                     workers <- structure(as.integer(workers), 
[13:23:07.164]                       class = class(workers))
[13:23:07.164]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:07.164]                       workers >= 1)
[13:23:07.164]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:07.164]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:07.164]                     }
[13:23:07.164]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:07.164]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:07.164]                       envir = envir)
[13:23:07.164]                     if (!future$lazy) 
[13:23:07.164]                       future <- run(future)
[13:23:07.164]                     invisible(future)
[13:23:07.164]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.164]                 }
[13:23:07.164]             }
[13:23:07.164]         }
[13:23:07.164]     })
[13:23:07.164]     if (TRUE) {
[13:23:07.164]         base::sink(type = "output", split = FALSE)
[13:23:07.164]         if (TRUE) {
[13:23:07.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.164]         }
[13:23:07.164]         else {
[13:23:07.164]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.164]         }
[13:23:07.164]         base::close(...future.stdout)
[13:23:07.164]         ...future.stdout <- NULL
[13:23:07.164]     }
[13:23:07.164]     ...future.result$conditions <- ...future.conditions
[13:23:07.164]     ...future.result$finished <- base::Sys.time()
[13:23:07.164]     ...future.result
[13:23:07.164] }
[13:23:07.167] MultisessionFuture started
[13:23:07.167] - Launch lazy future ... done
[13:23:07.167] run() for ‘MultisessionFuture’ ... done
[13:23:07.168] getGlobalsAndPackages() ...
[13:23:07.168] Searching for globals...
[13:23:07.168] 
[13:23:07.168] Searching for globals ... DONE
[13:23:07.168] - globals: [0] <none>
[13:23:07.168] getGlobalsAndPackages() ... DONE
[13:23:07.169] run() for ‘Future’ ...
[13:23:07.169] - state: ‘created’
[13:23:07.169] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.184] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:07.184]   - Field: ‘node’
[13:23:07.184]   - Field: ‘label’
[13:23:07.184]   - Field: ‘local’
[13:23:07.185]   - Field: ‘owner’
[13:23:07.185]   - Field: ‘envir’
[13:23:07.185]   - Field: ‘workers’
[13:23:07.185]   - Field: ‘packages’
[13:23:07.185]   - Field: ‘gc’
[13:23:07.185]   - Field: ‘conditions’
[13:23:07.185]   - Field: ‘persistent’
[13:23:07.185]   - Field: ‘expr’
[13:23:07.185]   - Field: ‘uuid’
[13:23:07.185]   - Field: ‘seed’
[13:23:07.186]   - Field: ‘version’
[13:23:07.186]   - Field: ‘result’
[13:23:07.186]   - Field: ‘asynchronous’
[13:23:07.186]   - Field: ‘calls’
[13:23:07.186]   - Field: ‘globals’
[13:23:07.186]   - Field: ‘stdout’
[13:23:07.186]   - Field: ‘earlySignal’
[13:23:07.186]   - Field: ‘lazy’
[13:23:07.186]   - Field: ‘state’
[13:23:07.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:07.186] - Launch lazy future ...
[13:23:07.187] Packages needed by the future expression (n = 0): <none>
[13:23:07.187] Packages needed by future strategies (n = 0): <none>
[13:23:07.187] {
[13:23:07.187]     {
[13:23:07.187]         {
[13:23:07.187]             ...future.startTime <- base::Sys.time()
[13:23:07.187]             {
[13:23:07.187]                 {
[13:23:07.187]                   {
[13:23:07.187]                     {
[13:23:07.187]                       base::local({
[13:23:07.187]                         has_future <- base::requireNamespace("future", 
[13:23:07.187]                           quietly = TRUE)
[13:23:07.187]                         if (has_future) {
[13:23:07.187]                           ns <- base::getNamespace("future")
[13:23:07.187]                           version <- ns[[".package"]][["version"]]
[13:23:07.187]                           if (is.null(version)) 
[13:23:07.187]                             version <- utils::packageVersion("future")
[13:23:07.187]                         }
[13:23:07.187]                         else {
[13:23:07.187]                           version <- NULL
[13:23:07.187]                         }
[13:23:07.187]                         if (!has_future || version < "1.8.0") {
[13:23:07.187]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.187]                             "", base::R.version$version.string), 
[13:23:07.187]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.187]                               "release", "version")], collapse = " "), 
[13:23:07.187]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.187]                             info)
[13:23:07.187]                           info <- base::paste(info, collapse = "; ")
[13:23:07.187]                           if (!has_future) {
[13:23:07.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.187]                               info)
[13:23:07.187]                           }
[13:23:07.187]                           else {
[13:23:07.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.187]                               info, version)
[13:23:07.187]                           }
[13:23:07.187]                           base::stop(msg)
[13:23:07.187]                         }
[13:23:07.187]                       })
[13:23:07.187]                     }
[13:23:07.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.187]                     base::options(mc.cores = 1L)
[13:23:07.187]                   }
[13:23:07.187]                   options(future.plan = NULL)
[13:23:07.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.187]                 }
[13:23:07.187]                 ...future.workdir <- getwd()
[13:23:07.187]             }
[13:23:07.187]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.187]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.187]         }
[13:23:07.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.187]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.187]             base::names(...future.oldOptions))
[13:23:07.187]     }
[13:23:07.187]     if (FALSE) {
[13:23:07.187]     }
[13:23:07.187]     else {
[13:23:07.187]         if (TRUE) {
[13:23:07.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.187]                 open = "w")
[13:23:07.187]         }
[13:23:07.187]         else {
[13:23:07.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.187]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.187]         }
[13:23:07.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.187]             base::sink(type = "output", split = FALSE)
[13:23:07.187]             base::close(...future.stdout)
[13:23:07.187]         }, add = TRUE)
[13:23:07.187]     }
[13:23:07.187]     ...future.frame <- base::sys.nframe()
[13:23:07.187]     ...future.conditions <- base::list()
[13:23:07.187]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.187]     if (FALSE) {
[13:23:07.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.187]     }
[13:23:07.187]     ...future.result <- base::tryCatch({
[13:23:07.187]         base::withCallingHandlers({
[13:23:07.187]             ...future.value <- base::withVisible(base::local({
[13:23:07.187]                 ...future.makeSendCondition <- base::local({
[13:23:07.187]                   sendCondition <- NULL
[13:23:07.187]                   function(frame = 1L) {
[13:23:07.187]                     if (is.function(sendCondition)) 
[13:23:07.187]                       return(sendCondition)
[13:23:07.187]                     ns <- getNamespace("parallel")
[13:23:07.187]                     if (exists("sendData", mode = "function", 
[13:23:07.187]                       envir = ns)) {
[13:23:07.187]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:07.187]                         envir = ns)
[13:23:07.187]                       envir <- sys.frame(frame)
[13:23:07.187]                       master <- NULL
[13:23:07.187]                       while (!identical(envir, .GlobalEnv) && 
[13:23:07.187]                         !identical(envir, emptyenv())) {
[13:23:07.187]                         if (exists("master", mode = "list", envir = envir, 
[13:23:07.187]                           inherits = FALSE)) {
[13:23:07.187]                           master <- get("master", mode = "list", 
[13:23:07.187]                             envir = envir, inherits = FALSE)
[13:23:07.187]                           if (inherits(master, c("SOCKnode", 
[13:23:07.187]                             "SOCK0node"))) {
[13:23:07.187]                             sendCondition <<- function(cond) {
[13:23:07.187]                               data <- list(type = "VALUE", value = cond, 
[13:23:07.187]                                 success = TRUE)
[13:23:07.187]                               parallel_sendData(master, data)
[13:23:07.187]                             }
[13:23:07.187]                             return(sendCondition)
[13:23:07.187]                           }
[13:23:07.187]                         }
[13:23:07.187]                         frame <- frame + 1L
[13:23:07.187]                         envir <- sys.frame(frame)
[13:23:07.187]                       }
[13:23:07.187]                     }
[13:23:07.187]                     sendCondition <<- function(cond) NULL
[13:23:07.187]                   }
[13:23:07.187]                 })
[13:23:07.187]                 withCallingHandlers({
[13:23:07.187]                   NULL
[13:23:07.187]                 }, immediateCondition = function(cond) {
[13:23:07.187]                   sendCondition <- ...future.makeSendCondition()
[13:23:07.187]                   sendCondition(cond)
[13:23:07.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.187]                   {
[13:23:07.187]                     inherits <- base::inherits
[13:23:07.187]                     invokeRestart <- base::invokeRestart
[13:23:07.187]                     is.null <- base::is.null
[13:23:07.187]                     muffled <- FALSE
[13:23:07.187]                     if (inherits(cond, "message")) {
[13:23:07.187]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.187]                       if (muffled) 
[13:23:07.187]                         invokeRestart("muffleMessage")
[13:23:07.187]                     }
[13:23:07.187]                     else if (inherits(cond, "warning")) {
[13:23:07.187]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.187]                       if (muffled) 
[13:23:07.187]                         invokeRestart("muffleWarning")
[13:23:07.187]                     }
[13:23:07.187]                     else if (inherits(cond, "condition")) {
[13:23:07.187]                       if (!is.null(pattern)) {
[13:23:07.187]                         computeRestarts <- base::computeRestarts
[13:23:07.187]                         grepl <- base::grepl
[13:23:07.187]                         restarts <- computeRestarts(cond)
[13:23:07.187]                         for (restart in restarts) {
[13:23:07.187]                           name <- restart$name
[13:23:07.187]                           if (is.null(name)) 
[13:23:07.187]                             next
[13:23:07.187]                           if (!grepl(pattern, name)) 
[13:23:07.187]                             next
[13:23:07.187]                           invokeRestart(restart)
[13:23:07.187]                           muffled <- TRUE
[13:23:07.187]                           break
[13:23:07.187]                         }
[13:23:07.187]                       }
[13:23:07.187]                     }
[13:23:07.187]                     invisible(muffled)
[13:23:07.187]                   }
[13:23:07.187]                   muffleCondition(cond)
[13:23:07.187]                 })
[13:23:07.187]             }))
[13:23:07.187]             future::FutureResult(value = ...future.value$value, 
[13:23:07.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.187]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.187]                     ...future.globalenv.names))
[13:23:07.187]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.187]         }, condition = base::local({
[13:23:07.187]             c <- base::c
[13:23:07.187]             inherits <- base::inherits
[13:23:07.187]             invokeRestart <- base::invokeRestart
[13:23:07.187]             length <- base::length
[13:23:07.187]             list <- base::list
[13:23:07.187]             seq.int <- base::seq.int
[13:23:07.187]             signalCondition <- base::signalCondition
[13:23:07.187]             sys.calls <- base::sys.calls
[13:23:07.187]             `[[` <- base::`[[`
[13:23:07.187]             `+` <- base::`+`
[13:23:07.187]             `<<-` <- base::`<<-`
[13:23:07.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.187]                   3L)]
[13:23:07.187]             }
[13:23:07.187]             function(cond) {
[13:23:07.187]                 is_error <- inherits(cond, "error")
[13:23:07.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.187]                   NULL)
[13:23:07.187]                 if (is_error) {
[13:23:07.187]                   sessionInformation <- function() {
[13:23:07.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.187]                       search = base::search(), system = base::Sys.info())
[13:23:07.187]                   }
[13:23:07.187]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.187]                     cond$call), session = sessionInformation(), 
[13:23:07.187]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.187]                   signalCondition(cond)
[13:23:07.187]                 }
[13:23:07.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.187]                 "immediateCondition"))) {
[13:23:07.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.187]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.187]                   if (TRUE && !signal) {
[13:23:07.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.187]                     {
[13:23:07.187]                       inherits <- base::inherits
[13:23:07.187]                       invokeRestart <- base::invokeRestart
[13:23:07.187]                       is.null <- base::is.null
[13:23:07.187]                       muffled <- FALSE
[13:23:07.187]                       if (inherits(cond, "message")) {
[13:23:07.187]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.187]                         if (muffled) 
[13:23:07.187]                           invokeRestart("muffleMessage")
[13:23:07.187]                       }
[13:23:07.187]                       else if (inherits(cond, "warning")) {
[13:23:07.187]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.187]                         if (muffled) 
[13:23:07.187]                           invokeRestart("muffleWarning")
[13:23:07.187]                       }
[13:23:07.187]                       else if (inherits(cond, "condition")) {
[13:23:07.187]                         if (!is.null(pattern)) {
[13:23:07.187]                           computeRestarts <- base::computeRestarts
[13:23:07.187]                           grepl <- base::grepl
[13:23:07.187]                           restarts <- computeRestarts(cond)
[13:23:07.187]                           for (restart in restarts) {
[13:23:07.187]                             name <- restart$name
[13:23:07.187]                             if (is.null(name)) 
[13:23:07.187]                               next
[13:23:07.187]                             if (!grepl(pattern, name)) 
[13:23:07.187]                               next
[13:23:07.187]                             invokeRestart(restart)
[13:23:07.187]                             muffled <- TRUE
[13:23:07.187]                             break
[13:23:07.187]                           }
[13:23:07.187]                         }
[13:23:07.187]                       }
[13:23:07.187]                       invisible(muffled)
[13:23:07.187]                     }
[13:23:07.187]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.187]                   }
[13:23:07.187]                 }
[13:23:07.187]                 else {
[13:23:07.187]                   if (TRUE) {
[13:23:07.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.187]                     {
[13:23:07.187]                       inherits <- base::inherits
[13:23:07.187]                       invokeRestart <- base::invokeRestart
[13:23:07.187]                       is.null <- base::is.null
[13:23:07.187]                       muffled <- FALSE
[13:23:07.187]                       if (inherits(cond, "message")) {
[13:23:07.187]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.187]                         if (muffled) 
[13:23:07.187]                           invokeRestart("muffleMessage")
[13:23:07.187]                       }
[13:23:07.187]                       else if (inherits(cond, "warning")) {
[13:23:07.187]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.187]                         if (muffled) 
[13:23:07.187]                           invokeRestart("muffleWarning")
[13:23:07.187]                       }
[13:23:07.187]                       else if (inherits(cond, "condition")) {
[13:23:07.187]                         if (!is.null(pattern)) {
[13:23:07.187]                           computeRestarts <- base::computeRestarts
[13:23:07.187]                           grepl <- base::grepl
[13:23:07.187]                           restarts <- computeRestarts(cond)
[13:23:07.187]                           for (restart in restarts) {
[13:23:07.187]                             name <- restart$name
[13:23:07.187]                             if (is.null(name)) 
[13:23:07.187]                               next
[13:23:07.187]                             if (!grepl(pattern, name)) 
[13:23:07.187]                               next
[13:23:07.187]                             invokeRestart(restart)
[13:23:07.187]                             muffled <- TRUE
[13:23:07.187]                             break
[13:23:07.187]                           }
[13:23:07.187]                         }
[13:23:07.187]                       }
[13:23:07.187]                       invisible(muffled)
[13:23:07.187]                     }
[13:23:07.187]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.187]                   }
[13:23:07.187]                 }
[13:23:07.187]             }
[13:23:07.187]         }))
[13:23:07.187]     }, error = function(ex) {
[13:23:07.187]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.187]                 ...future.rng), started = ...future.startTime, 
[13:23:07.187]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.187]             version = "1.8"), class = "FutureResult")
[13:23:07.187]     }, finally = {
[13:23:07.187]         if (!identical(...future.workdir, getwd())) 
[13:23:07.187]             setwd(...future.workdir)
[13:23:07.187]         {
[13:23:07.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.187]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.187]             }
[13:23:07.187]             base::options(...future.oldOptions)
[13:23:07.187]             if (.Platform$OS.type == "windows") {
[13:23:07.187]                 old_names <- names(...future.oldEnvVars)
[13:23:07.187]                 envs <- base::Sys.getenv()
[13:23:07.187]                 names <- names(envs)
[13:23:07.187]                 common <- intersect(names, old_names)
[13:23:07.187]                 added <- setdiff(names, old_names)
[13:23:07.187]                 removed <- setdiff(old_names, names)
[13:23:07.187]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.187]                   envs[common]]
[13:23:07.187]                 NAMES <- toupper(changed)
[13:23:07.187]                 args <- list()
[13:23:07.187]                 for (kk in seq_along(NAMES)) {
[13:23:07.187]                   name <- changed[[kk]]
[13:23:07.187]                   NAME <- NAMES[[kk]]
[13:23:07.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.187]                     next
[13:23:07.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.187]                 }
[13:23:07.187]                 NAMES <- toupper(added)
[13:23:07.187]                 for (kk in seq_along(NAMES)) {
[13:23:07.187]                   name <- added[[kk]]
[13:23:07.187]                   NAME <- NAMES[[kk]]
[13:23:07.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.187]                     next
[13:23:07.187]                   args[[name]] <- ""
[13:23:07.187]                 }
[13:23:07.187]                 NAMES <- toupper(removed)
[13:23:07.187]                 for (kk in seq_along(NAMES)) {
[13:23:07.187]                   name <- removed[[kk]]
[13:23:07.187]                   NAME <- NAMES[[kk]]
[13:23:07.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.187]                     next
[13:23:07.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.187]                 }
[13:23:07.187]                 if (length(args) > 0) 
[13:23:07.187]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.187]             }
[13:23:07.187]             else {
[13:23:07.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.187]             }
[13:23:07.187]             {
[13:23:07.187]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.187]                   0L) {
[13:23:07.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.187]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.187]                   base::options(opts)
[13:23:07.187]                 }
[13:23:07.187]                 {
[13:23:07.187]                   {
[13:23:07.187]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.187]                     NULL
[13:23:07.187]                   }
[13:23:07.187]                   options(future.plan = NULL)
[13:23:07.187]                   if (is.na(NA_character_)) 
[13:23:07.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.187]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:07.187]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:07.187]                     envir = parent.frame()) 
[13:23:07.187]                   {
[13:23:07.187]                     if (is.function(workers)) 
[13:23:07.187]                       workers <- workers()
[13:23:07.187]                     workers <- structure(as.integer(workers), 
[13:23:07.187]                       class = class(workers))
[13:23:07.187]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:07.187]                       workers >= 1)
[13:23:07.187]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:07.187]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:07.187]                     }
[13:23:07.187]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:07.187]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:07.187]                       envir = envir)
[13:23:07.187]                     if (!future$lazy) 
[13:23:07.187]                       future <- run(future)
[13:23:07.187]                     invisible(future)
[13:23:07.187]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.187]                 }
[13:23:07.187]             }
[13:23:07.187]         }
[13:23:07.187]     })
[13:23:07.187]     if (TRUE) {
[13:23:07.187]         base::sink(type = "output", split = FALSE)
[13:23:07.187]         if (TRUE) {
[13:23:07.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.187]         }
[13:23:07.187]         else {
[13:23:07.187]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.187]         }
[13:23:07.187]         base::close(...future.stdout)
[13:23:07.187]         ...future.stdout <- NULL
[13:23:07.187]     }
[13:23:07.187]     ...future.result$conditions <- ...future.conditions
[13:23:07.187]     ...future.result$finished <- base::Sys.time()
[13:23:07.187]     ...future.result
[13:23:07.187] }
[13:23:07.191] MultisessionFuture started
[13:23:07.191] - Launch lazy future ... done
[13:23:07.192] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d7040230> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d7395580> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d7040230> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d7395580> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:07.222] resolve() on list ...
[13:23:07.222]  recursive: 0
[13:23:07.222]  length: 6
[13:23:07.222]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:07.223] signalConditionsASAP(numeric, pos=1) ...
[13:23:07.223] - nx: 6
[13:23:07.223] - relay: TRUE
[13:23:07.223] - stdout: TRUE
[13:23:07.223] - signal: TRUE
[13:23:07.223] - resignal: FALSE
[13:23:07.223] - force: TRUE
[13:23:07.223] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.223] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.223]  - until=2
[13:23:07.223]  - relaying element #2
[13:23:07.224] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.224] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.224] signalConditionsASAP(NULL, pos=1) ... done
[13:23:07.224]  length: 5 (resolved future 1)
[13:23:07.224] receiveMessageFromWorker() for ClusterFuture ...
[13:23:07.225] - Validating connection of MultisessionFuture
[13:23:07.225] - received message: FutureResult
[13:23:07.225] - Received FutureResult
[13:23:07.225] - Erased future from FutureRegistry
[13:23:07.225] result() for ClusterFuture ...
[13:23:07.225] - result already collected: FutureResult
[13:23:07.225] result() for ClusterFuture ... done
[13:23:07.225] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:07.225] Future #2
[13:23:07.226] result() for ClusterFuture ...
[13:23:07.226] - result already collected: FutureResult
[13:23:07.226] result() for ClusterFuture ... done
[13:23:07.226] result() for ClusterFuture ...
[13:23:07.226] - result already collected: FutureResult
[13:23:07.226] result() for ClusterFuture ... done
[13:23:07.226] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:07.226] - nx: 6
[13:23:07.226] - relay: TRUE
[13:23:07.226] - stdout: TRUE
[13:23:07.226] - signal: TRUE
[13:23:07.227] - resignal: FALSE
[13:23:07.227] - force: TRUE
[13:23:07.227] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.227] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.227]  - until=2
[13:23:07.227]  - relaying element #2
[13:23:07.227] result() for ClusterFuture ...
[13:23:07.227] - result already collected: FutureResult
[13:23:07.227] result() for ClusterFuture ... done
[13:23:07.227] result() for ClusterFuture ...
[13:23:07.227] - result already collected: FutureResult
[13:23:07.227] result() for ClusterFuture ... done
[13:23:07.228] result() for ClusterFuture ...
[13:23:07.228] - result already collected: FutureResult
[13:23:07.228] result() for ClusterFuture ... done
[13:23:07.228] result() for ClusterFuture ...
[13:23:07.228] - result already collected: FutureResult
[13:23:07.228] result() for ClusterFuture ... done
[13:23:07.228] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.228] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.228] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:07.228]  length: 4 (resolved future 2)
[13:23:07.237] receiveMessageFromWorker() for ClusterFuture ...
[13:23:07.237] - Validating connection of MultisessionFuture
[13:23:07.237] - received message: FutureResult
[13:23:07.237] - Received FutureResult
[13:23:07.238] - Erased future from FutureRegistry
[13:23:07.238] result() for ClusterFuture ...
[13:23:07.238] - result already collected: FutureResult
[13:23:07.238] result() for ClusterFuture ... done
[13:23:07.238] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:07.238] Future #3
[13:23:07.238] result() for ClusterFuture ...
[13:23:07.238] - result already collected: FutureResult
[13:23:07.238] result() for ClusterFuture ... done
[13:23:07.238] result() for ClusterFuture ...
[13:23:07.238] - result already collected: FutureResult
[13:23:07.239] result() for ClusterFuture ... done
[13:23:07.239] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:07.239] - nx: 6
[13:23:07.239] - relay: TRUE
[13:23:07.239] - stdout: TRUE
[13:23:07.239] - signal: TRUE
[13:23:07.239] - resignal: FALSE
[13:23:07.239] - force: TRUE
[13:23:07.239] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.239] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.239]  - until=3
[13:23:07.240]  - relaying element #3
[13:23:07.240] result() for ClusterFuture ...
[13:23:07.240] - result already collected: FutureResult
[13:23:07.240] result() for ClusterFuture ... done
[13:23:07.240] result() for ClusterFuture ...
[13:23:07.240] - result already collected: FutureResult
[13:23:07.240] result() for ClusterFuture ... done
[13:23:07.240] result() for ClusterFuture ...
[13:23:07.240] - result already collected: FutureResult
[13:23:07.240] result() for ClusterFuture ... done
[13:23:07.240] result() for ClusterFuture ...
[13:23:07.241] - result already collected: FutureResult
[13:23:07.241] result() for ClusterFuture ... done
[13:23:07.241] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.241] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.241] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:07.241]  length: 3 (resolved future 3)
[13:23:07.241] signalConditionsASAP(NULL, pos=4) ...
[13:23:07.241] - nx: 6
[13:23:07.241] - relay: TRUE
[13:23:07.241] - stdout: TRUE
[13:23:07.241] - signal: TRUE
[13:23:07.241] - resignal: FALSE
[13:23:07.242] - force: TRUE
[13:23:07.242] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.242] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.242]  - until=5
[13:23:07.242]  - relaying element #5
[13:23:07.242] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:07.242] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.242] signalConditionsASAP(NULL, pos=4) ... done
[13:23:07.242]  length: 2 (resolved future 4)
[13:23:07.242] signalConditionsASAP(NULL, pos=5) ...
[13:23:07.242] - nx: 6
[13:23:07.243] - relay: TRUE
[13:23:07.243] - stdout: TRUE
[13:23:07.243] - signal: TRUE
[13:23:07.243] - resignal: FALSE
[13:23:07.243] - force: TRUE
[13:23:07.243] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:07.243] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.243]  - until=6
[13:23:07.243]  - relaying element #6
[13:23:07.243] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:07.243] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.243] signalConditionsASAP(NULL, pos=5) ... done
[13:23:07.244]  length: 1 (resolved future 5)
[13:23:07.244] signalConditionsASAP(numeric, pos=6) ...
[13:23:07.244] - nx: 6
[13:23:07.244] - relay: TRUE
[13:23:07.244] - stdout: TRUE
[13:23:07.244] - signal: TRUE
[13:23:07.244] - resignal: FALSE
[13:23:07.244] - force: TRUE
[13:23:07.244] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:07.244] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.244]  - until=6
[13:23:07.244] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.245] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.245] signalConditionsASAP(numeric, pos=6) ... done
[13:23:07.245]  length: 0 (resolved future 6)
[13:23:07.245] Relaying remaining futures
[13:23:07.245] signalConditionsASAP(NULL, pos=0) ...
[13:23:07.245] - nx: 6
[13:23:07.245] - relay: TRUE
[13:23:07.245] - stdout: TRUE
[13:23:07.245] - signal: TRUE
[13:23:07.245] - resignal: FALSE
[13:23:07.245] - force: TRUE
[13:23:07.245] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.246] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:07.246] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.246] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.246] signalConditionsASAP(NULL, pos=0) ... done
[13:23:07.246] resolve() on list ... DONE
[13:23:07.246] result() for ClusterFuture ...
[13:23:07.246] - result already collected: FutureResult
[13:23:07.246] result() for ClusterFuture ... done
[13:23:07.246] result() for ClusterFuture ...
[13:23:07.246] - result already collected: FutureResult
[13:23:07.247] result() for ClusterFuture ... done
[13:23:07.247] result() for ClusterFuture ...
[13:23:07.247] - result already collected: FutureResult
[13:23:07.247] result() for ClusterFuture ... done
[13:23:07.247] result() for ClusterFuture ...
[13:23:07.247] - result already collected: FutureResult
[13:23:07.247] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:23:07.250] getGlobalsAndPackages() ...
[13:23:07.251] Searching for globals...
[13:23:07.251] 
[13:23:07.251] Searching for globals ... DONE
[13:23:07.251] - globals: [0] <none>
[13:23:07.251] getGlobalsAndPackages() ... DONE
[13:23:07.252] run() for ‘Future’ ...
[13:23:07.252] - state: ‘created’
[13:23:07.252] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.266] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:07.266]   - Field: ‘node’
[13:23:07.267]   - Field: ‘label’
[13:23:07.267]   - Field: ‘local’
[13:23:07.267]   - Field: ‘owner’
[13:23:07.267]   - Field: ‘envir’
[13:23:07.267]   - Field: ‘workers’
[13:23:07.267]   - Field: ‘packages’
[13:23:07.267]   - Field: ‘gc’
[13:23:07.267]   - Field: ‘conditions’
[13:23:07.267]   - Field: ‘persistent’
[13:23:07.267]   - Field: ‘expr’
[13:23:07.268]   - Field: ‘uuid’
[13:23:07.268]   - Field: ‘seed’
[13:23:07.268]   - Field: ‘version’
[13:23:07.268]   - Field: ‘result’
[13:23:07.268]   - Field: ‘asynchronous’
[13:23:07.268]   - Field: ‘calls’
[13:23:07.268]   - Field: ‘globals’
[13:23:07.268]   - Field: ‘stdout’
[13:23:07.268]   - Field: ‘earlySignal’
[13:23:07.268]   - Field: ‘lazy’
[13:23:07.269]   - Field: ‘state’
[13:23:07.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:07.269] - Launch lazy future ...
[13:23:07.269] Packages needed by the future expression (n = 0): <none>
[13:23:07.269] Packages needed by future strategies (n = 0): <none>
[13:23:07.270] {
[13:23:07.270]     {
[13:23:07.270]         {
[13:23:07.270]             ...future.startTime <- base::Sys.time()
[13:23:07.270]             {
[13:23:07.270]                 {
[13:23:07.270]                   {
[13:23:07.270]                     {
[13:23:07.270]                       base::local({
[13:23:07.270]                         has_future <- base::requireNamespace("future", 
[13:23:07.270]                           quietly = TRUE)
[13:23:07.270]                         if (has_future) {
[13:23:07.270]                           ns <- base::getNamespace("future")
[13:23:07.270]                           version <- ns[[".package"]][["version"]]
[13:23:07.270]                           if (is.null(version)) 
[13:23:07.270]                             version <- utils::packageVersion("future")
[13:23:07.270]                         }
[13:23:07.270]                         else {
[13:23:07.270]                           version <- NULL
[13:23:07.270]                         }
[13:23:07.270]                         if (!has_future || version < "1.8.0") {
[13:23:07.270]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.270]                             "", base::R.version$version.string), 
[13:23:07.270]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.270]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.270]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.270]                               "release", "version")], collapse = " "), 
[13:23:07.270]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.270]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.270]                             info)
[13:23:07.270]                           info <- base::paste(info, collapse = "; ")
[13:23:07.270]                           if (!has_future) {
[13:23:07.270]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.270]                               info)
[13:23:07.270]                           }
[13:23:07.270]                           else {
[13:23:07.270]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.270]                               info, version)
[13:23:07.270]                           }
[13:23:07.270]                           base::stop(msg)
[13:23:07.270]                         }
[13:23:07.270]                       })
[13:23:07.270]                     }
[13:23:07.270]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.270]                     base::options(mc.cores = 1L)
[13:23:07.270]                   }
[13:23:07.270]                   options(future.plan = NULL)
[13:23:07.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.270]                 }
[13:23:07.270]                 ...future.workdir <- getwd()
[13:23:07.270]             }
[13:23:07.270]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.270]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.270]         }
[13:23:07.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.270]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.270]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.270]             base::names(...future.oldOptions))
[13:23:07.270]     }
[13:23:07.270]     if (FALSE) {
[13:23:07.270]     }
[13:23:07.270]     else {
[13:23:07.270]         if (TRUE) {
[13:23:07.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.270]                 open = "w")
[13:23:07.270]         }
[13:23:07.270]         else {
[13:23:07.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.270]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.270]         }
[13:23:07.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.270]             base::sink(type = "output", split = FALSE)
[13:23:07.270]             base::close(...future.stdout)
[13:23:07.270]         }, add = TRUE)
[13:23:07.270]     }
[13:23:07.270]     ...future.frame <- base::sys.nframe()
[13:23:07.270]     ...future.conditions <- base::list()
[13:23:07.270]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.270]     if (FALSE) {
[13:23:07.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.270]     }
[13:23:07.270]     ...future.result <- base::tryCatch({
[13:23:07.270]         base::withCallingHandlers({
[13:23:07.270]             ...future.value <- base::withVisible(base::local({
[13:23:07.270]                 ...future.makeSendCondition <- base::local({
[13:23:07.270]                   sendCondition <- NULL
[13:23:07.270]                   function(frame = 1L) {
[13:23:07.270]                     if (is.function(sendCondition)) 
[13:23:07.270]                       return(sendCondition)
[13:23:07.270]                     ns <- getNamespace("parallel")
[13:23:07.270]                     if (exists("sendData", mode = "function", 
[13:23:07.270]                       envir = ns)) {
[13:23:07.270]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:07.270]                         envir = ns)
[13:23:07.270]                       envir <- sys.frame(frame)
[13:23:07.270]                       master <- NULL
[13:23:07.270]                       while (!identical(envir, .GlobalEnv) && 
[13:23:07.270]                         !identical(envir, emptyenv())) {
[13:23:07.270]                         if (exists("master", mode = "list", envir = envir, 
[13:23:07.270]                           inherits = FALSE)) {
[13:23:07.270]                           master <- get("master", mode = "list", 
[13:23:07.270]                             envir = envir, inherits = FALSE)
[13:23:07.270]                           if (inherits(master, c("SOCKnode", 
[13:23:07.270]                             "SOCK0node"))) {
[13:23:07.270]                             sendCondition <<- function(cond) {
[13:23:07.270]                               data <- list(type = "VALUE", value = cond, 
[13:23:07.270]                                 success = TRUE)
[13:23:07.270]                               parallel_sendData(master, data)
[13:23:07.270]                             }
[13:23:07.270]                             return(sendCondition)
[13:23:07.270]                           }
[13:23:07.270]                         }
[13:23:07.270]                         frame <- frame + 1L
[13:23:07.270]                         envir <- sys.frame(frame)
[13:23:07.270]                       }
[13:23:07.270]                     }
[13:23:07.270]                     sendCondition <<- function(cond) NULL
[13:23:07.270]                   }
[13:23:07.270]                 })
[13:23:07.270]                 withCallingHandlers({
[13:23:07.270]                   2
[13:23:07.270]                 }, immediateCondition = function(cond) {
[13:23:07.270]                   sendCondition <- ...future.makeSendCondition()
[13:23:07.270]                   sendCondition(cond)
[13:23:07.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.270]                   {
[13:23:07.270]                     inherits <- base::inherits
[13:23:07.270]                     invokeRestart <- base::invokeRestart
[13:23:07.270]                     is.null <- base::is.null
[13:23:07.270]                     muffled <- FALSE
[13:23:07.270]                     if (inherits(cond, "message")) {
[13:23:07.270]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.270]                       if (muffled) 
[13:23:07.270]                         invokeRestart("muffleMessage")
[13:23:07.270]                     }
[13:23:07.270]                     else if (inherits(cond, "warning")) {
[13:23:07.270]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.270]                       if (muffled) 
[13:23:07.270]                         invokeRestart("muffleWarning")
[13:23:07.270]                     }
[13:23:07.270]                     else if (inherits(cond, "condition")) {
[13:23:07.270]                       if (!is.null(pattern)) {
[13:23:07.270]                         computeRestarts <- base::computeRestarts
[13:23:07.270]                         grepl <- base::grepl
[13:23:07.270]                         restarts <- computeRestarts(cond)
[13:23:07.270]                         for (restart in restarts) {
[13:23:07.270]                           name <- restart$name
[13:23:07.270]                           if (is.null(name)) 
[13:23:07.270]                             next
[13:23:07.270]                           if (!grepl(pattern, name)) 
[13:23:07.270]                             next
[13:23:07.270]                           invokeRestart(restart)
[13:23:07.270]                           muffled <- TRUE
[13:23:07.270]                           break
[13:23:07.270]                         }
[13:23:07.270]                       }
[13:23:07.270]                     }
[13:23:07.270]                     invisible(muffled)
[13:23:07.270]                   }
[13:23:07.270]                   muffleCondition(cond)
[13:23:07.270]                 })
[13:23:07.270]             }))
[13:23:07.270]             future::FutureResult(value = ...future.value$value, 
[13:23:07.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.270]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.270]                     ...future.globalenv.names))
[13:23:07.270]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.270]         }, condition = base::local({
[13:23:07.270]             c <- base::c
[13:23:07.270]             inherits <- base::inherits
[13:23:07.270]             invokeRestart <- base::invokeRestart
[13:23:07.270]             length <- base::length
[13:23:07.270]             list <- base::list
[13:23:07.270]             seq.int <- base::seq.int
[13:23:07.270]             signalCondition <- base::signalCondition
[13:23:07.270]             sys.calls <- base::sys.calls
[13:23:07.270]             `[[` <- base::`[[`
[13:23:07.270]             `+` <- base::`+`
[13:23:07.270]             `<<-` <- base::`<<-`
[13:23:07.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.270]                   3L)]
[13:23:07.270]             }
[13:23:07.270]             function(cond) {
[13:23:07.270]                 is_error <- inherits(cond, "error")
[13:23:07.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.270]                   NULL)
[13:23:07.270]                 if (is_error) {
[13:23:07.270]                   sessionInformation <- function() {
[13:23:07.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.270]                       search = base::search(), system = base::Sys.info())
[13:23:07.270]                   }
[13:23:07.270]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.270]                     cond$call), session = sessionInformation(), 
[13:23:07.270]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.270]                   signalCondition(cond)
[13:23:07.270]                 }
[13:23:07.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.270]                 "immediateCondition"))) {
[13:23:07.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.270]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.270]                   if (TRUE && !signal) {
[13:23:07.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.270]                     {
[13:23:07.270]                       inherits <- base::inherits
[13:23:07.270]                       invokeRestart <- base::invokeRestart
[13:23:07.270]                       is.null <- base::is.null
[13:23:07.270]                       muffled <- FALSE
[13:23:07.270]                       if (inherits(cond, "message")) {
[13:23:07.270]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.270]                         if (muffled) 
[13:23:07.270]                           invokeRestart("muffleMessage")
[13:23:07.270]                       }
[13:23:07.270]                       else if (inherits(cond, "warning")) {
[13:23:07.270]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.270]                         if (muffled) 
[13:23:07.270]                           invokeRestart("muffleWarning")
[13:23:07.270]                       }
[13:23:07.270]                       else if (inherits(cond, "condition")) {
[13:23:07.270]                         if (!is.null(pattern)) {
[13:23:07.270]                           computeRestarts <- base::computeRestarts
[13:23:07.270]                           grepl <- base::grepl
[13:23:07.270]                           restarts <- computeRestarts(cond)
[13:23:07.270]                           for (restart in restarts) {
[13:23:07.270]                             name <- restart$name
[13:23:07.270]                             if (is.null(name)) 
[13:23:07.270]                               next
[13:23:07.270]                             if (!grepl(pattern, name)) 
[13:23:07.270]                               next
[13:23:07.270]                             invokeRestart(restart)
[13:23:07.270]                             muffled <- TRUE
[13:23:07.270]                             break
[13:23:07.270]                           }
[13:23:07.270]                         }
[13:23:07.270]                       }
[13:23:07.270]                       invisible(muffled)
[13:23:07.270]                     }
[13:23:07.270]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.270]                   }
[13:23:07.270]                 }
[13:23:07.270]                 else {
[13:23:07.270]                   if (TRUE) {
[13:23:07.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.270]                     {
[13:23:07.270]                       inherits <- base::inherits
[13:23:07.270]                       invokeRestart <- base::invokeRestart
[13:23:07.270]                       is.null <- base::is.null
[13:23:07.270]                       muffled <- FALSE
[13:23:07.270]                       if (inherits(cond, "message")) {
[13:23:07.270]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.270]                         if (muffled) 
[13:23:07.270]                           invokeRestart("muffleMessage")
[13:23:07.270]                       }
[13:23:07.270]                       else if (inherits(cond, "warning")) {
[13:23:07.270]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.270]                         if (muffled) 
[13:23:07.270]                           invokeRestart("muffleWarning")
[13:23:07.270]                       }
[13:23:07.270]                       else if (inherits(cond, "condition")) {
[13:23:07.270]                         if (!is.null(pattern)) {
[13:23:07.270]                           computeRestarts <- base::computeRestarts
[13:23:07.270]                           grepl <- base::grepl
[13:23:07.270]                           restarts <- computeRestarts(cond)
[13:23:07.270]                           for (restart in restarts) {
[13:23:07.270]                             name <- restart$name
[13:23:07.270]                             if (is.null(name)) 
[13:23:07.270]                               next
[13:23:07.270]                             if (!grepl(pattern, name)) 
[13:23:07.270]                               next
[13:23:07.270]                             invokeRestart(restart)
[13:23:07.270]                             muffled <- TRUE
[13:23:07.270]                             break
[13:23:07.270]                           }
[13:23:07.270]                         }
[13:23:07.270]                       }
[13:23:07.270]                       invisible(muffled)
[13:23:07.270]                     }
[13:23:07.270]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.270]                   }
[13:23:07.270]                 }
[13:23:07.270]             }
[13:23:07.270]         }))
[13:23:07.270]     }, error = function(ex) {
[13:23:07.270]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.270]                 ...future.rng), started = ...future.startTime, 
[13:23:07.270]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.270]             version = "1.8"), class = "FutureResult")
[13:23:07.270]     }, finally = {
[13:23:07.270]         if (!identical(...future.workdir, getwd())) 
[13:23:07.270]             setwd(...future.workdir)
[13:23:07.270]         {
[13:23:07.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.270]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.270]             }
[13:23:07.270]             base::options(...future.oldOptions)
[13:23:07.270]             if (.Platform$OS.type == "windows") {
[13:23:07.270]                 old_names <- names(...future.oldEnvVars)
[13:23:07.270]                 envs <- base::Sys.getenv()
[13:23:07.270]                 names <- names(envs)
[13:23:07.270]                 common <- intersect(names, old_names)
[13:23:07.270]                 added <- setdiff(names, old_names)
[13:23:07.270]                 removed <- setdiff(old_names, names)
[13:23:07.270]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.270]                   envs[common]]
[13:23:07.270]                 NAMES <- toupper(changed)
[13:23:07.270]                 args <- list()
[13:23:07.270]                 for (kk in seq_along(NAMES)) {
[13:23:07.270]                   name <- changed[[kk]]
[13:23:07.270]                   NAME <- NAMES[[kk]]
[13:23:07.270]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.270]                     next
[13:23:07.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.270]                 }
[13:23:07.270]                 NAMES <- toupper(added)
[13:23:07.270]                 for (kk in seq_along(NAMES)) {
[13:23:07.270]                   name <- added[[kk]]
[13:23:07.270]                   NAME <- NAMES[[kk]]
[13:23:07.270]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.270]                     next
[13:23:07.270]                   args[[name]] <- ""
[13:23:07.270]                 }
[13:23:07.270]                 NAMES <- toupper(removed)
[13:23:07.270]                 for (kk in seq_along(NAMES)) {
[13:23:07.270]                   name <- removed[[kk]]
[13:23:07.270]                   NAME <- NAMES[[kk]]
[13:23:07.270]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.270]                     next
[13:23:07.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.270]                 }
[13:23:07.270]                 if (length(args) > 0) 
[13:23:07.270]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.270]             }
[13:23:07.270]             else {
[13:23:07.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.270]             }
[13:23:07.270]             {
[13:23:07.270]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.270]                   0L) {
[13:23:07.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.270]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.270]                   base::options(opts)
[13:23:07.270]                 }
[13:23:07.270]                 {
[13:23:07.270]                   {
[13:23:07.270]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.270]                     NULL
[13:23:07.270]                   }
[13:23:07.270]                   options(future.plan = NULL)
[13:23:07.270]                   if (is.na(NA_character_)) 
[13:23:07.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.270]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:07.270]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:07.270]                     envir = parent.frame()) 
[13:23:07.270]                   {
[13:23:07.270]                     if (is.function(workers)) 
[13:23:07.270]                       workers <- workers()
[13:23:07.270]                     workers <- structure(as.integer(workers), 
[13:23:07.270]                       class = class(workers))
[13:23:07.270]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:07.270]                       workers >= 1)
[13:23:07.270]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:07.270]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:07.270]                     }
[13:23:07.270]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:07.270]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:07.270]                       envir = envir)
[13:23:07.270]                     if (!future$lazy) 
[13:23:07.270]                       future <- run(future)
[13:23:07.270]                     invisible(future)
[13:23:07.270]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.270]                 }
[13:23:07.270]             }
[13:23:07.270]         }
[13:23:07.270]     })
[13:23:07.270]     if (TRUE) {
[13:23:07.270]         base::sink(type = "output", split = FALSE)
[13:23:07.270]         if (TRUE) {
[13:23:07.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.270]         }
[13:23:07.270]         else {
[13:23:07.270]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.270]         }
[13:23:07.270]         base::close(...future.stdout)
[13:23:07.270]         ...future.stdout <- NULL
[13:23:07.270]     }
[13:23:07.270]     ...future.result$conditions <- ...future.conditions
[13:23:07.270]     ...future.result$finished <- base::Sys.time()
[13:23:07.270]     ...future.result
[13:23:07.270] }
[13:23:07.273] MultisessionFuture started
[13:23:07.273] - Launch lazy future ... done
[13:23:07.273] run() for ‘MultisessionFuture’ ... done
[13:23:07.273] getGlobalsAndPackages() ...
[13:23:07.273] Searching for globals...
[13:23:07.274] 
[13:23:07.274] Searching for globals ... DONE
[13:23:07.274] - globals: [0] <none>
[13:23:07.274] getGlobalsAndPackages() ... DONE
[13:23:07.274] run() for ‘Future’ ...
[13:23:07.274] - state: ‘created’
[13:23:07.274] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.289] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:07.289]   - Field: ‘node’
[13:23:07.289]   - Field: ‘label’
[13:23:07.289]   - Field: ‘local’
[13:23:07.289]   - Field: ‘owner’
[13:23:07.290]   - Field: ‘envir’
[13:23:07.290]   - Field: ‘workers’
[13:23:07.290]   - Field: ‘packages’
[13:23:07.290]   - Field: ‘gc’
[13:23:07.290]   - Field: ‘conditions’
[13:23:07.290]   - Field: ‘persistent’
[13:23:07.290]   - Field: ‘expr’
[13:23:07.290]   - Field: ‘uuid’
[13:23:07.290]   - Field: ‘seed’
[13:23:07.290]   - Field: ‘version’
[13:23:07.291]   - Field: ‘result’
[13:23:07.291]   - Field: ‘asynchronous’
[13:23:07.291]   - Field: ‘calls’
[13:23:07.291]   - Field: ‘globals’
[13:23:07.291]   - Field: ‘stdout’
[13:23:07.291]   - Field: ‘earlySignal’
[13:23:07.291]   - Field: ‘lazy’
[13:23:07.291]   - Field: ‘state’
[13:23:07.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:07.291] - Launch lazy future ...
[13:23:07.292] Packages needed by the future expression (n = 0): <none>
[13:23:07.292] Packages needed by future strategies (n = 0): <none>
[13:23:07.292] {
[13:23:07.292]     {
[13:23:07.292]         {
[13:23:07.292]             ...future.startTime <- base::Sys.time()
[13:23:07.292]             {
[13:23:07.292]                 {
[13:23:07.292]                   {
[13:23:07.292]                     {
[13:23:07.292]                       base::local({
[13:23:07.292]                         has_future <- base::requireNamespace("future", 
[13:23:07.292]                           quietly = TRUE)
[13:23:07.292]                         if (has_future) {
[13:23:07.292]                           ns <- base::getNamespace("future")
[13:23:07.292]                           version <- ns[[".package"]][["version"]]
[13:23:07.292]                           if (is.null(version)) 
[13:23:07.292]                             version <- utils::packageVersion("future")
[13:23:07.292]                         }
[13:23:07.292]                         else {
[13:23:07.292]                           version <- NULL
[13:23:07.292]                         }
[13:23:07.292]                         if (!has_future || version < "1.8.0") {
[13:23:07.292]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.292]                             "", base::R.version$version.string), 
[13:23:07.292]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.292]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.292]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.292]                               "release", "version")], collapse = " "), 
[13:23:07.292]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.292]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.292]                             info)
[13:23:07.292]                           info <- base::paste(info, collapse = "; ")
[13:23:07.292]                           if (!has_future) {
[13:23:07.292]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.292]                               info)
[13:23:07.292]                           }
[13:23:07.292]                           else {
[13:23:07.292]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.292]                               info, version)
[13:23:07.292]                           }
[13:23:07.292]                           base::stop(msg)
[13:23:07.292]                         }
[13:23:07.292]                       })
[13:23:07.292]                     }
[13:23:07.292]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.292]                     base::options(mc.cores = 1L)
[13:23:07.292]                   }
[13:23:07.292]                   options(future.plan = NULL)
[13:23:07.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.292]                 }
[13:23:07.292]                 ...future.workdir <- getwd()
[13:23:07.292]             }
[13:23:07.292]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.292]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.292]         }
[13:23:07.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.292]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.292]             base::names(...future.oldOptions))
[13:23:07.292]     }
[13:23:07.292]     if (FALSE) {
[13:23:07.292]     }
[13:23:07.292]     else {
[13:23:07.292]         if (TRUE) {
[13:23:07.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.292]                 open = "w")
[13:23:07.292]         }
[13:23:07.292]         else {
[13:23:07.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.292]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.292]         }
[13:23:07.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.292]             base::sink(type = "output", split = FALSE)
[13:23:07.292]             base::close(...future.stdout)
[13:23:07.292]         }, add = TRUE)
[13:23:07.292]     }
[13:23:07.292]     ...future.frame <- base::sys.nframe()
[13:23:07.292]     ...future.conditions <- base::list()
[13:23:07.292]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.292]     if (FALSE) {
[13:23:07.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.292]     }
[13:23:07.292]     ...future.result <- base::tryCatch({
[13:23:07.292]         base::withCallingHandlers({
[13:23:07.292]             ...future.value <- base::withVisible(base::local({
[13:23:07.292]                 ...future.makeSendCondition <- base::local({
[13:23:07.292]                   sendCondition <- NULL
[13:23:07.292]                   function(frame = 1L) {
[13:23:07.292]                     if (is.function(sendCondition)) 
[13:23:07.292]                       return(sendCondition)
[13:23:07.292]                     ns <- getNamespace("parallel")
[13:23:07.292]                     if (exists("sendData", mode = "function", 
[13:23:07.292]                       envir = ns)) {
[13:23:07.292]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:07.292]                         envir = ns)
[13:23:07.292]                       envir <- sys.frame(frame)
[13:23:07.292]                       master <- NULL
[13:23:07.292]                       while (!identical(envir, .GlobalEnv) && 
[13:23:07.292]                         !identical(envir, emptyenv())) {
[13:23:07.292]                         if (exists("master", mode = "list", envir = envir, 
[13:23:07.292]                           inherits = FALSE)) {
[13:23:07.292]                           master <- get("master", mode = "list", 
[13:23:07.292]                             envir = envir, inherits = FALSE)
[13:23:07.292]                           if (inherits(master, c("SOCKnode", 
[13:23:07.292]                             "SOCK0node"))) {
[13:23:07.292]                             sendCondition <<- function(cond) {
[13:23:07.292]                               data <- list(type = "VALUE", value = cond, 
[13:23:07.292]                                 success = TRUE)
[13:23:07.292]                               parallel_sendData(master, data)
[13:23:07.292]                             }
[13:23:07.292]                             return(sendCondition)
[13:23:07.292]                           }
[13:23:07.292]                         }
[13:23:07.292]                         frame <- frame + 1L
[13:23:07.292]                         envir <- sys.frame(frame)
[13:23:07.292]                       }
[13:23:07.292]                     }
[13:23:07.292]                     sendCondition <<- function(cond) NULL
[13:23:07.292]                   }
[13:23:07.292]                 })
[13:23:07.292]                 withCallingHandlers({
[13:23:07.292]                   NULL
[13:23:07.292]                 }, immediateCondition = function(cond) {
[13:23:07.292]                   sendCondition <- ...future.makeSendCondition()
[13:23:07.292]                   sendCondition(cond)
[13:23:07.292]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.292]                   {
[13:23:07.292]                     inherits <- base::inherits
[13:23:07.292]                     invokeRestart <- base::invokeRestart
[13:23:07.292]                     is.null <- base::is.null
[13:23:07.292]                     muffled <- FALSE
[13:23:07.292]                     if (inherits(cond, "message")) {
[13:23:07.292]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.292]                       if (muffled) 
[13:23:07.292]                         invokeRestart("muffleMessage")
[13:23:07.292]                     }
[13:23:07.292]                     else if (inherits(cond, "warning")) {
[13:23:07.292]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.292]                       if (muffled) 
[13:23:07.292]                         invokeRestart("muffleWarning")
[13:23:07.292]                     }
[13:23:07.292]                     else if (inherits(cond, "condition")) {
[13:23:07.292]                       if (!is.null(pattern)) {
[13:23:07.292]                         computeRestarts <- base::computeRestarts
[13:23:07.292]                         grepl <- base::grepl
[13:23:07.292]                         restarts <- computeRestarts(cond)
[13:23:07.292]                         for (restart in restarts) {
[13:23:07.292]                           name <- restart$name
[13:23:07.292]                           if (is.null(name)) 
[13:23:07.292]                             next
[13:23:07.292]                           if (!grepl(pattern, name)) 
[13:23:07.292]                             next
[13:23:07.292]                           invokeRestart(restart)
[13:23:07.292]                           muffled <- TRUE
[13:23:07.292]                           break
[13:23:07.292]                         }
[13:23:07.292]                       }
[13:23:07.292]                     }
[13:23:07.292]                     invisible(muffled)
[13:23:07.292]                   }
[13:23:07.292]                   muffleCondition(cond)
[13:23:07.292]                 })
[13:23:07.292]             }))
[13:23:07.292]             future::FutureResult(value = ...future.value$value, 
[13:23:07.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.292]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.292]                     ...future.globalenv.names))
[13:23:07.292]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.292]         }, condition = base::local({
[13:23:07.292]             c <- base::c
[13:23:07.292]             inherits <- base::inherits
[13:23:07.292]             invokeRestart <- base::invokeRestart
[13:23:07.292]             length <- base::length
[13:23:07.292]             list <- base::list
[13:23:07.292]             seq.int <- base::seq.int
[13:23:07.292]             signalCondition <- base::signalCondition
[13:23:07.292]             sys.calls <- base::sys.calls
[13:23:07.292]             `[[` <- base::`[[`
[13:23:07.292]             `+` <- base::`+`
[13:23:07.292]             `<<-` <- base::`<<-`
[13:23:07.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.292]                   3L)]
[13:23:07.292]             }
[13:23:07.292]             function(cond) {
[13:23:07.292]                 is_error <- inherits(cond, "error")
[13:23:07.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.292]                   NULL)
[13:23:07.292]                 if (is_error) {
[13:23:07.292]                   sessionInformation <- function() {
[13:23:07.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.292]                       search = base::search(), system = base::Sys.info())
[13:23:07.292]                   }
[13:23:07.292]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.292]                     cond$call), session = sessionInformation(), 
[13:23:07.292]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.292]                   signalCondition(cond)
[13:23:07.292]                 }
[13:23:07.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.292]                 "immediateCondition"))) {
[13:23:07.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.292]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.292]                   if (TRUE && !signal) {
[13:23:07.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.292]                     {
[13:23:07.292]                       inherits <- base::inherits
[13:23:07.292]                       invokeRestart <- base::invokeRestart
[13:23:07.292]                       is.null <- base::is.null
[13:23:07.292]                       muffled <- FALSE
[13:23:07.292]                       if (inherits(cond, "message")) {
[13:23:07.292]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.292]                         if (muffled) 
[13:23:07.292]                           invokeRestart("muffleMessage")
[13:23:07.292]                       }
[13:23:07.292]                       else if (inherits(cond, "warning")) {
[13:23:07.292]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.292]                         if (muffled) 
[13:23:07.292]                           invokeRestart("muffleWarning")
[13:23:07.292]                       }
[13:23:07.292]                       else if (inherits(cond, "condition")) {
[13:23:07.292]                         if (!is.null(pattern)) {
[13:23:07.292]                           computeRestarts <- base::computeRestarts
[13:23:07.292]                           grepl <- base::grepl
[13:23:07.292]                           restarts <- computeRestarts(cond)
[13:23:07.292]                           for (restart in restarts) {
[13:23:07.292]                             name <- restart$name
[13:23:07.292]                             if (is.null(name)) 
[13:23:07.292]                               next
[13:23:07.292]                             if (!grepl(pattern, name)) 
[13:23:07.292]                               next
[13:23:07.292]                             invokeRestart(restart)
[13:23:07.292]                             muffled <- TRUE
[13:23:07.292]                             break
[13:23:07.292]                           }
[13:23:07.292]                         }
[13:23:07.292]                       }
[13:23:07.292]                       invisible(muffled)
[13:23:07.292]                     }
[13:23:07.292]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.292]                   }
[13:23:07.292]                 }
[13:23:07.292]                 else {
[13:23:07.292]                   if (TRUE) {
[13:23:07.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.292]                     {
[13:23:07.292]                       inherits <- base::inherits
[13:23:07.292]                       invokeRestart <- base::invokeRestart
[13:23:07.292]                       is.null <- base::is.null
[13:23:07.292]                       muffled <- FALSE
[13:23:07.292]                       if (inherits(cond, "message")) {
[13:23:07.292]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.292]                         if (muffled) 
[13:23:07.292]                           invokeRestart("muffleMessage")
[13:23:07.292]                       }
[13:23:07.292]                       else if (inherits(cond, "warning")) {
[13:23:07.292]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.292]                         if (muffled) 
[13:23:07.292]                           invokeRestart("muffleWarning")
[13:23:07.292]                       }
[13:23:07.292]                       else if (inherits(cond, "condition")) {
[13:23:07.292]                         if (!is.null(pattern)) {
[13:23:07.292]                           computeRestarts <- base::computeRestarts
[13:23:07.292]                           grepl <- base::grepl
[13:23:07.292]                           restarts <- computeRestarts(cond)
[13:23:07.292]                           for (restart in restarts) {
[13:23:07.292]                             name <- restart$name
[13:23:07.292]                             if (is.null(name)) 
[13:23:07.292]                               next
[13:23:07.292]                             if (!grepl(pattern, name)) 
[13:23:07.292]                               next
[13:23:07.292]                             invokeRestart(restart)
[13:23:07.292]                             muffled <- TRUE
[13:23:07.292]                             break
[13:23:07.292]                           }
[13:23:07.292]                         }
[13:23:07.292]                       }
[13:23:07.292]                       invisible(muffled)
[13:23:07.292]                     }
[13:23:07.292]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.292]                   }
[13:23:07.292]                 }
[13:23:07.292]             }
[13:23:07.292]         }))
[13:23:07.292]     }, error = function(ex) {
[13:23:07.292]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.292]                 ...future.rng), started = ...future.startTime, 
[13:23:07.292]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.292]             version = "1.8"), class = "FutureResult")
[13:23:07.292]     }, finally = {
[13:23:07.292]         if (!identical(...future.workdir, getwd())) 
[13:23:07.292]             setwd(...future.workdir)
[13:23:07.292]         {
[13:23:07.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.292]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.292]             }
[13:23:07.292]             base::options(...future.oldOptions)
[13:23:07.292]             if (.Platform$OS.type == "windows") {
[13:23:07.292]                 old_names <- names(...future.oldEnvVars)
[13:23:07.292]                 envs <- base::Sys.getenv()
[13:23:07.292]                 names <- names(envs)
[13:23:07.292]                 common <- intersect(names, old_names)
[13:23:07.292]                 added <- setdiff(names, old_names)
[13:23:07.292]                 removed <- setdiff(old_names, names)
[13:23:07.292]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.292]                   envs[common]]
[13:23:07.292]                 NAMES <- toupper(changed)
[13:23:07.292]                 args <- list()
[13:23:07.292]                 for (kk in seq_along(NAMES)) {
[13:23:07.292]                   name <- changed[[kk]]
[13:23:07.292]                   NAME <- NAMES[[kk]]
[13:23:07.292]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.292]                     next
[13:23:07.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.292]                 }
[13:23:07.292]                 NAMES <- toupper(added)
[13:23:07.292]                 for (kk in seq_along(NAMES)) {
[13:23:07.292]                   name <- added[[kk]]
[13:23:07.292]                   NAME <- NAMES[[kk]]
[13:23:07.292]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.292]                     next
[13:23:07.292]                   args[[name]] <- ""
[13:23:07.292]                 }
[13:23:07.292]                 NAMES <- toupper(removed)
[13:23:07.292]                 for (kk in seq_along(NAMES)) {
[13:23:07.292]                   name <- removed[[kk]]
[13:23:07.292]                   NAME <- NAMES[[kk]]
[13:23:07.292]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.292]                     next
[13:23:07.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.292]                 }
[13:23:07.292]                 if (length(args) > 0) 
[13:23:07.292]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.292]             }
[13:23:07.292]             else {
[13:23:07.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.292]             }
[13:23:07.292]             {
[13:23:07.292]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.292]                   0L) {
[13:23:07.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.292]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.292]                   base::options(opts)
[13:23:07.292]                 }
[13:23:07.292]                 {
[13:23:07.292]                   {
[13:23:07.292]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.292]                     NULL
[13:23:07.292]                   }
[13:23:07.292]                   options(future.plan = NULL)
[13:23:07.292]                   if (is.na(NA_character_)) 
[13:23:07.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.292]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:07.292]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:07.292]                     envir = parent.frame()) 
[13:23:07.292]                   {
[13:23:07.292]                     if (is.function(workers)) 
[13:23:07.292]                       workers <- workers()
[13:23:07.292]                     workers <- structure(as.integer(workers), 
[13:23:07.292]                       class = class(workers))
[13:23:07.292]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:07.292]                       workers >= 1)
[13:23:07.292]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:07.292]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:07.292]                     }
[13:23:07.292]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:07.292]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:07.292]                       envir = envir)
[13:23:07.292]                     if (!future$lazy) 
[13:23:07.292]                       future <- run(future)
[13:23:07.292]                     invisible(future)
[13:23:07.292]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.292]                 }
[13:23:07.292]             }
[13:23:07.292]         }
[13:23:07.292]     })
[13:23:07.292]     if (TRUE) {
[13:23:07.292]         base::sink(type = "output", split = FALSE)
[13:23:07.292]         if (TRUE) {
[13:23:07.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.292]         }
[13:23:07.292]         else {
[13:23:07.292]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.292]         }
[13:23:07.292]         base::close(...future.stdout)
[13:23:07.292]         ...future.stdout <- NULL
[13:23:07.292]     }
[13:23:07.292]     ...future.result$conditions <- ...future.conditions
[13:23:07.292]     ...future.result$finished <- base::Sys.time()
[13:23:07.292]     ...future.result
[13:23:07.292] }
[13:23:07.296] MultisessionFuture started
[13:23:07.296] - Launch lazy future ... done
[13:23:07.296] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d34d1e38> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d6695118> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d34d1e38> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d6695118> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:07.325] resolve() on list ...
[13:23:07.325]  recursive: 0
[13:23:07.325]  length: 6
[13:23:07.325]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:07.325] signalConditionsASAP(numeric, pos=1) ...
[13:23:07.325] - nx: 6
[13:23:07.326] - relay: TRUE
[13:23:07.326] - stdout: TRUE
[13:23:07.326] - signal: TRUE
[13:23:07.326] - resignal: FALSE
[13:23:07.326] - force: TRUE
[13:23:07.326] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.326] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.326]  - until=2
[13:23:07.326]  - relaying element #2
[13:23:07.326] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.326] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.327] signalConditionsASAP(NULL, pos=1) ... done
[13:23:07.327]  length: 5 (resolved future 1)
[13:23:07.327] receiveMessageFromWorker() for ClusterFuture ...
[13:23:07.327] - Validating connection of MultisessionFuture
[13:23:07.328] - received message: FutureResult
[13:23:07.328] - Received FutureResult
[13:23:07.328] - Erased future from FutureRegistry
[13:23:07.328] result() for ClusterFuture ...
[13:23:07.328] - result already collected: FutureResult
[13:23:07.328] result() for ClusterFuture ... done
[13:23:07.328] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:07.328] Future #2
[13:23:07.328] result() for ClusterFuture ...
[13:23:07.329] - result already collected: FutureResult
[13:23:07.329] result() for ClusterFuture ... done
[13:23:07.329] result() for ClusterFuture ...
[13:23:07.329] - result already collected: FutureResult
[13:23:07.329] result() for ClusterFuture ... done
[13:23:07.329] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:07.329] - nx: 6
[13:23:07.329] - relay: TRUE
[13:23:07.329] - stdout: TRUE
[13:23:07.329] - signal: TRUE
[13:23:07.329] - resignal: FALSE
[13:23:07.329] - force: TRUE
[13:23:07.330] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.330] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.330]  - until=2
[13:23:07.330]  - relaying element #2
[13:23:07.330] result() for ClusterFuture ...
[13:23:07.330] - result already collected: FutureResult
[13:23:07.330] result() for ClusterFuture ... done
[13:23:07.330] result() for ClusterFuture ...
[13:23:07.330] - result already collected: FutureResult
[13:23:07.330] result() for ClusterFuture ... done
[13:23:07.331] result() for ClusterFuture ...
[13:23:07.331] - result already collected: FutureResult
[13:23:07.331] result() for ClusterFuture ... done
[13:23:07.331] result() for ClusterFuture ...
[13:23:07.331] - result already collected: FutureResult
[13:23:07.331] result() for ClusterFuture ... done
[13:23:07.331] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.331] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.331] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:07.331]  length: 4 (resolved future 2)
[13:23:07.342] signalConditionsASAP(NULL, pos=4) ...
[13:23:07.342] - nx: 6
[13:23:07.343] - relay: TRUE
[13:23:07.343] - stdout: TRUE
[13:23:07.343] - signal: TRUE
[13:23:07.343] - resignal: FALSE
[13:23:07.343] - force: TRUE
[13:23:07.343] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.343] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.343]  - until=5
[13:23:07.343]  - relaying element #3
[13:23:07.343]  - relaying element #5
[13:23:07.344] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:23:07.344] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.344] signalConditionsASAP(NULL, pos=4) ... done
[13:23:07.344]  length: 3 (resolved future 4)
[13:23:07.344] signalConditionsASAP(NULL, pos=5) ...
[13:23:07.344] - nx: 6
[13:23:07.344] - relay: TRUE
[13:23:07.344] - stdout: TRUE
[13:23:07.345] - signal: TRUE
[13:23:07.345] - resignal: FALSE
[13:23:07.345] - force: TRUE
[13:23:07.345] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:23:07.345] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.345]  - until=6
[13:23:07.345]  - relaying element #3
[13:23:07.346]  - relaying element #6
[13:23:07.346] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:23:07.346] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.346] signalConditionsASAP(NULL, pos=5) ... done
[13:23:07.346]  length: 2 (resolved future 5)
[13:23:07.346] signalConditionsASAP(numeric, pos=6) ...
[13:23:07.346] - nx: 6
[13:23:07.346] - relay: TRUE
[13:23:07.347] - stdout: TRUE
[13:23:07.347] - signal: TRUE
[13:23:07.347] - resignal: FALSE
[13:23:07.347] - force: TRUE
[13:23:07.347] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:23:07.347] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.347]  - until=6
[13:23:07.347]  - relaying element #3
[13:23:07.347] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:23:07.347] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.347] signalConditionsASAP(NULL, pos=6) ... done
[13:23:07.348]  length: 1 (resolved future 6)
[13:23:07.358] receiveMessageFromWorker() for ClusterFuture ...
[13:23:07.359] - Validating connection of MultisessionFuture
[13:23:07.359] - received message: FutureResult
[13:23:07.359] - Received FutureResult
[13:23:07.359] - Erased future from FutureRegistry
[13:23:07.359] result() for ClusterFuture ...
[13:23:07.359] - result already collected: FutureResult
[13:23:07.359] result() for ClusterFuture ... done
[13:23:07.359] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:07.360] Future #3
[13:23:07.360] result() for ClusterFuture ...
[13:23:07.360] - result already collected: FutureResult
[13:23:07.360] result() for ClusterFuture ... done
[13:23:07.360] result() for ClusterFuture ...
[13:23:07.360] - result already collected: FutureResult
[13:23:07.360] result() for ClusterFuture ... done
[13:23:07.360] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:07.360] - nx: 6
[13:23:07.360] - relay: TRUE
[13:23:07.361] - stdout: TRUE
[13:23:07.361] - signal: TRUE
[13:23:07.361] - resignal: FALSE
[13:23:07.361] - force: TRUE
[13:23:07.361] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:23:07.361] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.361]  - until=6
[13:23:07.361]  - relaying element #3
[13:23:07.361] result() for ClusterFuture ...
[13:23:07.361] - result already collected: FutureResult
[13:23:07.361] result() for ClusterFuture ... done
[13:23:07.362] result() for ClusterFuture ...
[13:23:07.362] - result already collected: FutureResult
[13:23:07.362] result() for ClusterFuture ... done
[13:23:07.362] result() for ClusterFuture ...
[13:23:07.362] - result already collected: FutureResult
[13:23:07.362] result() for ClusterFuture ... done
[13:23:07.362] result() for ClusterFuture ...
[13:23:07.362] - result already collected: FutureResult
[13:23:07.362] result() for ClusterFuture ... done
[13:23:07.362] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.362] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.363] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:07.363]  length: 0 (resolved future 3)
[13:23:07.363] Relaying remaining futures
[13:23:07.363] signalConditionsASAP(NULL, pos=0) ...
[13:23:07.363] - nx: 6
[13:23:07.363] - relay: TRUE
[13:23:07.363] - stdout: TRUE
[13:23:07.363] - signal: TRUE
[13:23:07.363] - resignal: FALSE
[13:23:07.363] - force: TRUE
[13:23:07.363] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.363] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:07.364] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.364] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.364] signalConditionsASAP(NULL, pos=0) ... done
[13:23:07.364] resolve() on list ... DONE
[13:23:07.364] result() for ClusterFuture ...
[13:23:07.364] - result already collected: FutureResult
[13:23:07.364] result() for ClusterFuture ... done
[13:23:07.364] result() for ClusterFuture ...
[13:23:07.364] - result already collected: FutureResult
[13:23:07.364] result() for ClusterFuture ... done
[13:23:07.365] result() for ClusterFuture ...
[13:23:07.365] - result already collected: FutureResult
[13:23:07.365] result() for ClusterFuture ... done
[13:23:07.365] result() for ClusterFuture ...
[13:23:07.365] - result already collected: FutureResult
[13:23:07.365] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:23:07.371] getGlobalsAndPackages() ...
[13:23:07.371] Searching for globals...
[13:23:07.371] 
[13:23:07.371] Searching for globals ... DONE
[13:23:07.371] - globals: [0] <none>
[13:23:07.371] getGlobalsAndPackages() ... DONE
[13:23:07.372] run() for ‘Future’ ...
[13:23:07.372] - state: ‘created’
[13:23:07.372] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.387] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:07.387]   - Field: ‘node’
[13:23:07.387]   - Field: ‘label’
[13:23:07.387]   - Field: ‘local’
[13:23:07.388]   - Field: ‘owner’
[13:23:07.388]   - Field: ‘envir’
[13:23:07.388]   - Field: ‘workers’
[13:23:07.388]   - Field: ‘packages’
[13:23:07.388]   - Field: ‘gc’
[13:23:07.388]   - Field: ‘conditions’
[13:23:07.388]   - Field: ‘persistent’
[13:23:07.389]   - Field: ‘expr’
[13:23:07.389]   - Field: ‘uuid’
[13:23:07.389]   - Field: ‘seed’
[13:23:07.389]   - Field: ‘version’
[13:23:07.389]   - Field: ‘result’
[13:23:07.389]   - Field: ‘asynchronous’
[13:23:07.389]   - Field: ‘calls’
[13:23:07.389]   - Field: ‘globals’
[13:23:07.389]   - Field: ‘stdout’
[13:23:07.389]   - Field: ‘earlySignal’
[13:23:07.389]   - Field: ‘lazy’
[13:23:07.390]   - Field: ‘state’
[13:23:07.390] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:07.390] - Launch lazy future ...
[13:23:07.390] Packages needed by the future expression (n = 0): <none>
[13:23:07.390] Packages needed by future strategies (n = 0): <none>
[13:23:07.391] {
[13:23:07.391]     {
[13:23:07.391]         {
[13:23:07.391]             ...future.startTime <- base::Sys.time()
[13:23:07.391]             {
[13:23:07.391]                 {
[13:23:07.391]                   {
[13:23:07.391]                     {
[13:23:07.391]                       base::local({
[13:23:07.391]                         has_future <- base::requireNamespace("future", 
[13:23:07.391]                           quietly = TRUE)
[13:23:07.391]                         if (has_future) {
[13:23:07.391]                           ns <- base::getNamespace("future")
[13:23:07.391]                           version <- ns[[".package"]][["version"]]
[13:23:07.391]                           if (is.null(version)) 
[13:23:07.391]                             version <- utils::packageVersion("future")
[13:23:07.391]                         }
[13:23:07.391]                         else {
[13:23:07.391]                           version <- NULL
[13:23:07.391]                         }
[13:23:07.391]                         if (!has_future || version < "1.8.0") {
[13:23:07.391]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.391]                             "", base::R.version$version.string), 
[13:23:07.391]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.391]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.391]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.391]                               "release", "version")], collapse = " "), 
[13:23:07.391]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.391]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.391]                             info)
[13:23:07.391]                           info <- base::paste(info, collapse = "; ")
[13:23:07.391]                           if (!has_future) {
[13:23:07.391]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.391]                               info)
[13:23:07.391]                           }
[13:23:07.391]                           else {
[13:23:07.391]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.391]                               info, version)
[13:23:07.391]                           }
[13:23:07.391]                           base::stop(msg)
[13:23:07.391]                         }
[13:23:07.391]                       })
[13:23:07.391]                     }
[13:23:07.391]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.391]                     base::options(mc.cores = 1L)
[13:23:07.391]                   }
[13:23:07.391]                   options(future.plan = NULL)
[13:23:07.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.391]                 }
[13:23:07.391]                 ...future.workdir <- getwd()
[13:23:07.391]             }
[13:23:07.391]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.391]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.391]         }
[13:23:07.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.391]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.391]             base::names(...future.oldOptions))
[13:23:07.391]     }
[13:23:07.391]     if (FALSE) {
[13:23:07.391]     }
[13:23:07.391]     else {
[13:23:07.391]         if (TRUE) {
[13:23:07.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.391]                 open = "w")
[13:23:07.391]         }
[13:23:07.391]         else {
[13:23:07.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.391]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.391]         }
[13:23:07.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.391]             base::sink(type = "output", split = FALSE)
[13:23:07.391]             base::close(...future.stdout)
[13:23:07.391]         }, add = TRUE)
[13:23:07.391]     }
[13:23:07.391]     ...future.frame <- base::sys.nframe()
[13:23:07.391]     ...future.conditions <- base::list()
[13:23:07.391]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.391]     if (FALSE) {
[13:23:07.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.391]     }
[13:23:07.391]     ...future.result <- base::tryCatch({
[13:23:07.391]         base::withCallingHandlers({
[13:23:07.391]             ...future.value <- base::withVisible(base::local({
[13:23:07.391]                 ...future.makeSendCondition <- base::local({
[13:23:07.391]                   sendCondition <- NULL
[13:23:07.391]                   function(frame = 1L) {
[13:23:07.391]                     if (is.function(sendCondition)) 
[13:23:07.391]                       return(sendCondition)
[13:23:07.391]                     ns <- getNamespace("parallel")
[13:23:07.391]                     if (exists("sendData", mode = "function", 
[13:23:07.391]                       envir = ns)) {
[13:23:07.391]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:07.391]                         envir = ns)
[13:23:07.391]                       envir <- sys.frame(frame)
[13:23:07.391]                       master <- NULL
[13:23:07.391]                       while (!identical(envir, .GlobalEnv) && 
[13:23:07.391]                         !identical(envir, emptyenv())) {
[13:23:07.391]                         if (exists("master", mode = "list", envir = envir, 
[13:23:07.391]                           inherits = FALSE)) {
[13:23:07.391]                           master <- get("master", mode = "list", 
[13:23:07.391]                             envir = envir, inherits = FALSE)
[13:23:07.391]                           if (inherits(master, c("SOCKnode", 
[13:23:07.391]                             "SOCK0node"))) {
[13:23:07.391]                             sendCondition <<- function(cond) {
[13:23:07.391]                               data <- list(type = "VALUE", value = cond, 
[13:23:07.391]                                 success = TRUE)
[13:23:07.391]                               parallel_sendData(master, data)
[13:23:07.391]                             }
[13:23:07.391]                             return(sendCondition)
[13:23:07.391]                           }
[13:23:07.391]                         }
[13:23:07.391]                         frame <- frame + 1L
[13:23:07.391]                         envir <- sys.frame(frame)
[13:23:07.391]                       }
[13:23:07.391]                     }
[13:23:07.391]                     sendCondition <<- function(cond) NULL
[13:23:07.391]                   }
[13:23:07.391]                 })
[13:23:07.391]                 withCallingHandlers({
[13:23:07.391]                   2
[13:23:07.391]                 }, immediateCondition = function(cond) {
[13:23:07.391]                   sendCondition <- ...future.makeSendCondition()
[13:23:07.391]                   sendCondition(cond)
[13:23:07.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.391]                   {
[13:23:07.391]                     inherits <- base::inherits
[13:23:07.391]                     invokeRestart <- base::invokeRestart
[13:23:07.391]                     is.null <- base::is.null
[13:23:07.391]                     muffled <- FALSE
[13:23:07.391]                     if (inherits(cond, "message")) {
[13:23:07.391]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.391]                       if (muffled) 
[13:23:07.391]                         invokeRestart("muffleMessage")
[13:23:07.391]                     }
[13:23:07.391]                     else if (inherits(cond, "warning")) {
[13:23:07.391]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.391]                       if (muffled) 
[13:23:07.391]                         invokeRestart("muffleWarning")
[13:23:07.391]                     }
[13:23:07.391]                     else if (inherits(cond, "condition")) {
[13:23:07.391]                       if (!is.null(pattern)) {
[13:23:07.391]                         computeRestarts <- base::computeRestarts
[13:23:07.391]                         grepl <- base::grepl
[13:23:07.391]                         restarts <- computeRestarts(cond)
[13:23:07.391]                         for (restart in restarts) {
[13:23:07.391]                           name <- restart$name
[13:23:07.391]                           if (is.null(name)) 
[13:23:07.391]                             next
[13:23:07.391]                           if (!grepl(pattern, name)) 
[13:23:07.391]                             next
[13:23:07.391]                           invokeRestart(restart)
[13:23:07.391]                           muffled <- TRUE
[13:23:07.391]                           break
[13:23:07.391]                         }
[13:23:07.391]                       }
[13:23:07.391]                     }
[13:23:07.391]                     invisible(muffled)
[13:23:07.391]                   }
[13:23:07.391]                   muffleCondition(cond)
[13:23:07.391]                 })
[13:23:07.391]             }))
[13:23:07.391]             future::FutureResult(value = ...future.value$value, 
[13:23:07.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.391]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.391]                     ...future.globalenv.names))
[13:23:07.391]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.391]         }, condition = base::local({
[13:23:07.391]             c <- base::c
[13:23:07.391]             inherits <- base::inherits
[13:23:07.391]             invokeRestart <- base::invokeRestart
[13:23:07.391]             length <- base::length
[13:23:07.391]             list <- base::list
[13:23:07.391]             seq.int <- base::seq.int
[13:23:07.391]             signalCondition <- base::signalCondition
[13:23:07.391]             sys.calls <- base::sys.calls
[13:23:07.391]             `[[` <- base::`[[`
[13:23:07.391]             `+` <- base::`+`
[13:23:07.391]             `<<-` <- base::`<<-`
[13:23:07.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.391]                   3L)]
[13:23:07.391]             }
[13:23:07.391]             function(cond) {
[13:23:07.391]                 is_error <- inherits(cond, "error")
[13:23:07.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.391]                   NULL)
[13:23:07.391]                 if (is_error) {
[13:23:07.391]                   sessionInformation <- function() {
[13:23:07.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.391]                       search = base::search(), system = base::Sys.info())
[13:23:07.391]                   }
[13:23:07.391]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.391]                     cond$call), session = sessionInformation(), 
[13:23:07.391]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.391]                   signalCondition(cond)
[13:23:07.391]                 }
[13:23:07.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.391]                 "immediateCondition"))) {
[13:23:07.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.391]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.391]                   if (TRUE && !signal) {
[13:23:07.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.391]                     {
[13:23:07.391]                       inherits <- base::inherits
[13:23:07.391]                       invokeRestart <- base::invokeRestart
[13:23:07.391]                       is.null <- base::is.null
[13:23:07.391]                       muffled <- FALSE
[13:23:07.391]                       if (inherits(cond, "message")) {
[13:23:07.391]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.391]                         if (muffled) 
[13:23:07.391]                           invokeRestart("muffleMessage")
[13:23:07.391]                       }
[13:23:07.391]                       else if (inherits(cond, "warning")) {
[13:23:07.391]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.391]                         if (muffled) 
[13:23:07.391]                           invokeRestart("muffleWarning")
[13:23:07.391]                       }
[13:23:07.391]                       else if (inherits(cond, "condition")) {
[13:23:07.391]                         if (!is.null(pattern)) {
[13:23:07.391]                           computeRestarts <- base::computeRestarts
[13:23:07.391]                           grepl <- base::grepl
[13:23:07.391]                           restarts <- computeRestarts(cond)
[13:23:07.391]                           for (restart in restarts) {
[13:23:07.391]                             name <- restart$name
[13:23:07.391]                             if (is.null(name)) 
[13:23:07.391]                               next
[13:23:07.391]                             if (!grepl(pattern, name)) 
[13:23:07.391]                               next
[13:23:07.391]                             invokeRestart(restart)
[13:23:07.391]                             muffled <- TRUE
[13:23:07.391]                             break
[13:23:07.391]                           }
[13:23:07.391]                         }
[13:23:07.391]                       }
[13:23:07.391]                       invisible(muffled)
[13:23:07.391]                     }
[13:23:07.391]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.391]                   }
[13:23:07.391]                 }
[13:23:07.391]                 else {
[13:23:07.391]                   if (TRUE) {
[13:23:07.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.391]                     {
[13:23:07.391]                       inherits <- base::inherits
[13:23:07.391]                       invokeRestart <- base::invokeRestart
[13:23:07.391]                       is.null <- base::is.null
[13:23:07.391]                       muffled <- FALSE
[13:23:07.391]                       if (inherits(cond, "message")) {
[13:23:07.391]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.391]                         if (muffled) 
[13:23:07.391]                           invokeRestart("muffleMessage")
[13:23:07.391]                       }
[13:23:07.391]                       else if (inherits(cond, "warning")) {
[13:23:07.391]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.391]                         if (muffled) 
[13:23:07.391]                           invokeRestart("muffleWarning")
[13:23:07.391]                       }
[13:23:07.391]                       else if (inherits(cond, "condition")) {
[13:23:07.391]                         if (!is.null(pattern)) {
[13:23:07.391]                           computeRestarts <- base::computeRestarts
[13:23:07.391]                           grepl <- base::grepl
[13:23:07.391]                           restarts <- computeRestarts(cond)
[13:23:07.391]                           for (restart in restarts) {
[13:23:07.391]                             name <- restart$name
[13:23:07.391]                             if (is.null(name)) 
[13:23:07.391]                               next
[13:23:07.391]                             if (!grepl(pattern, name)) 
[13:23:07.391]                               next
[13:23:07.391]                             invokeRestart(restart)
[13:23:07.391]                             muffled <- TRUE
[13:23:07.391]                             break
[13:23:07.391]                           }
[13:23:07.391]                         }
[13:23:07.391]                       }
[13:23:07.391]                       invisible(muffled)
[13:23:07.391]                     }
[13:23:07.391]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.391]                   }
[13:23:07.391]                 }
[13:23:07.391]             }
[13:23:07.391]         }))
[13:23:07.391]     }, error = function(ex) {
[13:23:07.391]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.391]                 ...future.rng), started = ...future.startTime, 
[13:23:07.391]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.391]             version = "1.8"), class = "FutureResult")
[13:23:07.391]     }, finally = {
[13:23:07.391]         if (!identical(...future.workdir, getwd())) 
[13:23:07.391]             setwd(...future.workdir)
[13:23:07.391]         {
[13:23:07.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.391]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.391]             }
[13:23:07.391]             base::options(...future.oldOptions)
[13:23:07.391]             if (.Platform$OS.type == "windows") {
[13:23:07.391]                 old_names <- names(...future.oldEnvVars)
[13:23:07.391]                 envs <- base::Sys.getenv()
[13:23:07.391]                 names <- names(envs)
[13:23:07.391]                 common <- intersect(names, old_names)
[13:23:07.391]                 added <- setdiff(names, old_names)
[13:23:07.391]                 removed <- setdiff(old_names, names)
[13:23:07.391]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.391]                   envs[common]]
[13:23:07.391]                 NAMES <- toupper(changed)
[13:23:07.391]                 args <- list()
[13:23:07.391]                 for (kk in seq_along(NAMES)) {
[13:23:07.391]                   name <- changed[[kk]]
[13:23:07.391]                   NAME <- NAMES[[kk]]
[13:23:07.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.391]                     next
[13:23:07.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.391]                 }
[13:23:07.391]                 NAMES <- toupper(added)
[13:23:07.391]                 for (kk in seq_along(NAMES)) {
[13:23:07.391]                   name <- added[[kk]]
[13:23:07.391]                   NAME <- NAMES[[kk]]
[13:23:07.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.391]                     next
[13:23:07.391]                   args[[name]] <- ""
[13:23:07.391]                 }
[13:23:07.391]                 NAMES <- toupper(removed)
[13:23:07.391]                 for (kk in seq_along(NAMES)) {
[13:23:07.391]                   name <- removed[[kk]]
[13:23:07.391]                   NAME <- NAMES[[kk]]
[13:23:07.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.391]                     next
[13:23:07.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.391]                 }
[13:23:07.391]                 if (length(args) > 0) 
[13:23:07.391]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.391]             }
[13:23:07.391]             else {
[13:23:07.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.391]             }
[13:23:07.391]             {
[13:23:07.391]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.391]                   0L) {
[13:23:07.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.391]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.391]                   base::options(opts)
[13:23:07.391]                 }
[13:23:07.391]                 {
[13:23:07.391]                   {
[13:23:07.391]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.391]                     NULL
[13:23:07.391]                   }
[13:23:07.391]                   options(future.plan = NULL)
[13:23:07.391]                   if (is.na(NA_character_)) 
[13:23:07.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.391]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:07.391]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:07.391]                     envir = parent.frame()) 
[13:23:07.391]                   {
[13:23:07.391]                     if (is.function(workers)) 
[13:23:07.391]                       workers <- workers()
[13:23:07.391]                     workers <- structure(as.integer(workers), 
[13:23:07.391]                       class = class(workers))
[13:23:07.391]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:07.391]                       workers >= 1)
[13:23:07.391]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:07.391]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:07.391]                     }
[13:23:07.391]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:07.391]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:07.391]                       envir = envir)
[13:23:07.391]                     if (!future$lazy) 
[13:23:07.391]                       future <- run(future)
[13:23:07.391]                     invisible(future)
[13:23:07.391]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.391]                 }
[13:23:07.391]             }
[13:23:07.391]         }
[13:23:07.391]     })
[13:23:07.391]     if (TRUE) {
[13:23:07.391]         base::sink(type = "output", split = FALSE)
[13:23:07.391]         if (TRUE) {
[13:23:07.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.391]         }
[13:23:07.391]         else {
[13:23:07.391]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.391]         }
[13:23:07.391]         base::close(...future.stdout)
[13:23:07.391]         ...future.stdout <- NULL
[13:23:07.391]     }
[13:23:07.391]     ...future.result$conditions <- ...future.conditions
[13:23:07.391]     ...future.result$finished <- base::Sys.time()
[13:23:07.391]     ...future.result
[13:23:07.391] }
[13:23:07.394] MultisessionFuture started
[13:23:07.394] - Launch lazy future ... done
[13:23:07.394] run() for ‘MultisessionFuture’ ... done
[13:23:07.394] getGlobalsAndPackages() ...
[13:23:07.395] Searching for globals...
[13:23:07.395] 
[13:23:07.395] Searching for globals ... DONE
[13:23:07.395] - globals: [0] <none>
[13:23:07.395] getGlobalsAndPackages() ... DONE
[13:23:07.395] run() for ‘Future’ ...
[13:23:07.396] - state: ‘created’
[13:23:07.396] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.410] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:07.410]   - Field: ‘node’
[13:23:07.411]   - Field: ‘label’
[13:23:07.411]   - Field: ‘local’
[13:23:07.411]   - Field: ‘owner’
[13:23:07.411]   - Field: ‘envir’
[13:23:07.411]   - Field: ‘workers’
[13:23:07.411]   - Field: ‘packages’
[13:23:07.411]   - Field: ‘gc’
[13:23:07.411]   - Field: ‘conditions’
[13:23:07.411]   - Field: ‘persistent’
[13:23:07.411]   - Field: ‘expr’
[13:23:07.411]   - Field: ‘uuid’
[13:23:07.412]   - Field: ‘seed’
[13:23:07.412]   - Field: ‘version’
[13:23:07.412]   - Field: ‘result’
[13:23:07.412]   - Field: ‘asynchronous’
[13:23:07.412]   - Field: ‘calls’
[13:23:07.412]   - Field: ‘globals’
[13:23:07.412]   - Field: ‘stdout’
[13:23:07.412]   - Field: ‘earlySignal’
[13:23:07.412]   - Field: ‘lazy’
[13:23:07.412]   - Field: ‘state’
[13:23:07.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:07.413] - Launch lazy future ...
[13:23:07.413] Packages needed by the future expression (n = 0): <none>
[13:23:07.413] Packages needed by future strategies (n = 0): <none>
[13:23:07.414] {
[13:23:07.414]     {
[13:23:07.414]         {
[13:23:07.414]             ...future.startTime <- base::Sys.time()
[13:23:07.414]             {
[13:23:07.414]                 {
[13:23:07.414]                   {
[13:23:07.414]                     {
[13:23:07.414]                       base::local({
[13:23:07.414]                         has_future <- base::requireNamespace("future", 
[13:23:07.414]                           quietly = TRUE)
[13:23:07.414]                         if (has_future) {
[13:23:07.414]                           ns <- base::getNamespace("future")
[13:23:07.414]                           version <- ns[[".package"]][["version"]]
[13:23:07.414]                           if (is.null(version)) 
[13:23:07.414]                             version <- utils::packageVersion("future")
[13:23:07.414]                         }
[13:23:07.414]                         else {
[13:23:07.414]                           version <- NULL
[13:23:07.414]                         }
[13:23:07.414]                         if (!has_future || version < "1.8.0") {
[13:23:07.414]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.414]                             "", base::R.version$version.string), 
[13:23:07.414]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.414]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.414]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.414]                               "release", "version")], collapse = " "), 
[13:23:07.414]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.414]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.414]                             info)
[13:23:07.414]                           info <- base::paste(info, collapse = "; ")
[13:23:07.414]                           if (!has_future) {
[13:23:07.414]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.414]                               info)
[13:23:07.414]                           }
[13:23:07.414]                           else {
[13:23:07.414]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.414]                               info, version)
[13:23:07.414]                           }
[13:23:07.414]                           base::stop(msg)
[13:23:07.414]                         }
[13:23:07.414]                       })
[13:23:07.414]                     }
[13:23:07.414]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.414]                     base::options(mc.cores = 1L)
[13:23:07.414]                   }
[13:23:07.414]                   options(future.plan = NULL)
[13:23:07.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.414]                 }
[13:23:07.414]                 ...future.workdir <- getwd()
[13:23:07.414]             }
[13:23:07.414]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.414]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.414]         }
[13:23:07.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.414]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.414]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.414]             base::names(...future.oldOptions))
[13:23:07.414]     }
[13:23:07.414]     if (FALSE) {
[13:23:07.414]     }
[13:23:07.414]     else {
[13:23:07.414]         if (TRUE) {
[13:23:07.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.414]                 open = "w")
[13:23:07.414]         }
[13:23:07.414]         else {
[13:23:07.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.414]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.414]         }
[13:23:07.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.414]             base::sink(type = "output", split = FALSE)
[13:23:07.414]             base::close(...future.stdout)
[13:23:07.414]         }, add = TRUE)
[13:23:07.414]     }
[13:23:07.414]     ...future.frame <- base::sys.nframe()
[13:23:07.414]     ...future.conditions <- base::list()
[13:23:07.414]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.414]     if (FALSE) {
[13:23:07.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.414]     }
[13:23:07.414]     ...future.result <- base::tryCatch({
[13:23:07.414]         base::withCallingHandlers({
[13:23:07.414]             ...future.value <- base::withVisible(base::local({
[13:23:07.414]                 ...future.makeSendCondition <- base::local({
[13:23:07.414]                   sendCondition <- NULL
[13:23:07.414]                   function(frame = 1L) {
[13:23:07.414]                     if (is.function(sendCondition)) 
[13:23:07.414]                       return(sendCondition)
[13:23:07.414]                     ns <- getNamespace("parallel")
[13:23:07.414]                     if (exists("sendData", mode = "function", 
[13:23:07.414]                       envir = ns)) {
[13:23:07.414]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:07.414]                         envir = ns)
[13:23:07.414]                       envir <- sys.frame(frame)
[13:23:07.414]                       master <- NULL
[13:23:07.414]                       while (!identical(envir, .GlobalEnv) && 
[13:23:07.414]                         !identical(envir, emptyenv())) {
[13:23:07.414]                         if (exists("master", mode = "list", envir = envir, 
[13:23:07.414]                           inherits = FALSE)) {
[13:23:07.414]                           master <- get("master", mode = "list", 
[13:23:07.414]                             envir = envir, inherits = FALSE)
[13:23:07.414]                           if (inherits(master, c("SOCKnode", 
[13:23:07.414]                             "SOCK0node"))) {
[13:23:07.414]                             sendCondition <<- function(cond) {
[13:23:07.414]                               data <- list(type = "VALUE", value = cond, 
[13:23:07.414]                                 success = TRUE)
[13:23:07.414]                               parallel_sendData(master, data)
[13:23:07.414]                             }
[13:23:07.414]                             return(sendCondition)
[13:23:07.414]                           }
[13:23:07.414]                         }
[13:23:07.414]                         frame <- frame + 1L
[13:23:07.414]                         envir <- sys.frame(frame)
[13:23:07.414]                       }
[13:23:07.414]                     }
[13:23:07.414]                     sendCondition <<- function(cond) NULL
[13:23:07.414]                   }
[13:23:07.414]                 })
[13:23:07.414]                 withCallingHandlers({
[13:23:07.414]                   NULL
[13:23:07.414]                 }, immediateCondition = function(cond) {
[13:23:07.414]                   sendCondition <- ...future.makeSendCondition()
[13:23:07.414]                   sendCondition(cond)
[13:23:07.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.414]                   {
[13:23:07.414]                     inherits <- base::inherits
[13:23:07.414]                     invokeRestart <- base::invokeRestart
[13:23:07.414]                     is.null <- base::is.null
[13:23:07.414]                     muffled <- FALSE
[13:23:07.414]                     if (inherits(cond, "message")) {
[13:23:07.414]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.414]                       if (muffled) 
[13:23:07.414]                         invokeRestart("muffleMessage")
[13:23:07.414]                     }
[13:23:07.414]                     else if (inherits(cond, "warning")) {
[13:23:07.414]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.414]                       if (muffled) 
[13:23:07.414]                         invokeRestart("muffleWarning")
[13:23:07.414]                     }
[13:23:07.414]                     else if (inherits(cond, "condition")) {
[13:23:07.414]                       if (!is.null(pattern)) {
[13:23:07.414]                         computeRestarts <- base::computeRestarts
[13:23:07.414]                         grepl <- base::grepl
[13:23:07.414]                         restarts <- computeRestarts(cond)
[13:23:07.414]                         for (restart in restarts) {
[13:23:07.414]                           name <- restart$name
[13:23:07.414]                           if (is.null(name)) 
[13:23:07.414]                             next
[13:23:07.414]                           if (!grepl(pattern, name)) 
[13:23:07.414]                             next
[13:23:07.414]                           invokeRestart(restart)
[13:23:07.414]                           muffled <- TRUE
[13:23:07.414]                           break
[13:23:07.414]                         }
[13:23:07.414]                       }
[13:23:07.414]                     }
[13:23:07.414]                     invisible(muffled)
[13:23:07.414]                   }
[13:23:07.414]                   muffleCondition(cond)
[13:23:07.414]                 })
[13:23:07.414]             }))
[13:23:07.414]             future::FutureResult(value = ...future.value$value, 
[13:23:07.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.414]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.414]                     ...future.globalenv.names))
[13:23:07.414]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.414]         }, condition = base::local({
[13:23:07.414]             c <- base::c
[13:23:07.414]             inherits <- base::inherits
[13:23:07.414]             invokeRestart <- base::invokeRestart
[13:23:07.414]             length <- base::length
[13:23:07.414]             list <- base::list
[13:23:07.414]             seq.int <- base::seq.int
[13:23:07.414]             signalCondition <- base::signalCondition
[13:23:07.414]             sys.calls <- base::sys.calls
[13:23:07.414]             `[[` <- base::`[[`
[13:23:07.414]             `+` <- base::`+`
[13:23:07.414]             `<<-` <- base::`<<-`
[13:23:07.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.414]                   3L)]
[13:23:07.414]             }
[13:23:07.414]             function(cond) {
[13:23:07.414]                 is_error <- inherits(cond, "error")
[13:23:07.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.414]                   NULL)
[13:23:07.414]                 if (is_error) {
[13:23:07.414]                   sessionInformation <- function() {
[13:23:07.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.414]                       search = base::search(), system = base::Sys.info())
[13:23:07.414]                   }
[13:23:07.414]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.414]                     cond$call), session = sessionInformation(), 
[13:23:07.414]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.414]                   signalCondition(cond)
[13:23:07.414]                 }
[13:23:07.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.414]                 "immediateCondition"))) {
[13:23:07.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.414]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.414]                   if (TRUE && !signal) {
[13:23:07.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.414]                     {
[13:23:07.414]                       inherits <- base::inherits
[13:23:07.414]                       invokeRestart <- base::invokeRestart
[13:23:07.414]                       is.null <- base::is.null
[13:23:07.414]                       muffled <- FALSE
[13:23:07.414]                       if (inherits(cond, "message")) {
[13:23:07.414]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.414]                         if (muffled) 
[13:23:07.414]                           invokeRestart("muffleMessage")
[13:23:07.414]                       }
[13:23:07.414]                       else if (inherits(cond, "warning")) {
[13:23:07.414]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.414]                         if (muffled) 
[13:23:07.414]                           invokeRestart("muffleWarning")
[13:23:07.414]                       }
[13:23:07.414]                       else if (inherits(cond, "condition")) {
[13:23:07.414]                         if (!is.null(pattern)) {
[13:23:07.414]                           computeRestarts <- base::computeRestarts
[13:23:07.414]                           grepl <- base::grepl
[13:23:07.414]                           restarts <- computeRestarts(cond)
[13:23:07.414]                           for (restart in restarts) {
[13:23:07.414]                             name <- restart$name
[13:23:07.414]                             if (is.null(name)) 
[13:23:07.414]                               next
[13:23:07.414]                             if (!grepl(pattern, name)) 
[13:23:07.414]                               next
[13:23:07.414]                             invokeRestart(restart)
[13:23:07.414]                             muffled <- TRUE
[13:23:07.414]                             break
[13:23:07.414]                           }
[13:23:07.414]                         }
[13:23:07.414]                       }
[13:23:07.414]                       invisible(muffled)
[13:23:07.414]                     }
[13:23:07.414]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.414]                   }
[13:23:07.414]                 }
[13:23:07.414]                 else {
[13:23:07.414]                   if (TRUE) {
[13:23:07.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.414]                     {
[13:23:07.414]                       inherits <- base::inherits
[13:23:07.414]                       invokeRestart <- base::invokeRestart
[13:23:07.414]                       is.null <- base::is.null
[13:23:07.414]                       muffled <- FALSE
[13:23:07.414]                       if (inherits(cond, "message")) {
[13:23:07.414]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.414]                         if (muffled) 
[13:23:07.414]                           invokeRestart("muffleMessage")
[13:23:07.414]                       }
[13:23:07.414]                       else if (inherits(cond, "warning")) {
[13:23:07.414]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.414]                         if (muffled) 
[13:23:07.414]                           invokeRestart("muffleWarning")
[13:23:07.414]                       }
[13:23:07.414]                       else if (inherits(cond, "condition")) {
[13:23:07.414]                         if (!is.null(pattern)) {
[13:23:07.414]                           computeRestarts <- base::computeRestarts
[13:23:07.414]                           grepl <- base::grepl
[13:23:07.414]                           restarts <- computeRestarts(cond)
[13:23:07.414]                           for (restart in restarts) {
[13:23:07.414]                             name <- restart$name
[13:23:07.414]                             if (is.null(name)) 
[13:23:07.414]                               next
[13:23:07.414]                             if (!grepl(pattern, name)) 
[13:23:07.414]                               next
[13:23:07.414]                             invokeRestart(restart)
[13:23:07.414]                             muffled <- TRUE
[13:23:07.414]                             break
[13:23:07.414]                           }
[13:23:07.414]                         }
[13:23:07.414]                       }
[13:23:07.414]                       invisible(muffled)
[13:23:07.414]                     }
[13:23:07.414]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.414]                   }
[13:23:07.414]                 }
[13:23:07.414]             }
[13:23:07.414]         }))
[13:23:07.414]     }, error = function(ex) {
[13:23:07.414]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.414]                 ...future.rng), started = ...future.startTime, 
[13:23:07.414]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.414]             version = "1.8"), class = "FutureResult")
[13:23:07.414]     }, finally = {
[13:23:07.414]         if (!identical(...future.workdir, getwd())) 
[13:23:07.414]             setwd(...future.workdir)
[13:23:07.414]         {
[13:23:07.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.414]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.414]             }
[13:23:07.414]             base::options(...future.oldOptions)
[13:23:07.414]             if (.Platform$OS.type == "windows") {
[13:23:07.414]                 old_names <- names(...future.oldEnvVars)
[13:23:07.414]                 envs <- base::Sys.getenv()
[13:23:07.414]                 names <- names(envs)
[13:23:07.414]                 common <- intersect(names, old_names)
[13:23:07.414]                 added <- setdiff(names, old_names)
[13:23:07.414]                 removed <- setdiff(old_names, names)
[13:23:07.414]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.414]                   envs[common]]
[13:23:07.414]                 NAMES <- toupper(changed)
[13:23:07.414]                 args <- list()
[13:23:07.414]                 for (kk in seq_along(NAMES)) {
[13:23:07.414]                   name <- changed[[kk]]
[13:23:07.414]                   NAME <- NAMES[[kk]]
[13:23:07.414]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.414]                     next
[13:23:07.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.414]                 }
[13:23:07.414]                 NAMES <- toupper(added)
[13:23:07.414]                 for (kk in seq_along(NAMES)) {
[13:23:07.414]                   name <- added[[kk]]
[13:23:07.414]                   NAME <- NAMES[[kk]]
[13:23:07.414]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.414]                     next
[13:23:07.414]                   args[[name]] <- ""
[13:23:07.414]                 }
[13:23:07.414]                 NAMES <- toupper(removed)
[13:23:07.414]                 for (kk in seq_along(NAMES)) {
[13:23:07.414]                   name <- removed[[kk]]
[13:23:07.414]                   NAME <- NAMES[[kk]]
[13:23:07.414]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.414]                     next
[13:23:07.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.414]                 }
[13:23:07.414]                 if (length(args) > 0) 
[13:23:07.414]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.414]             }
[13:23:07.414]             else {
[13:23:07.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.414]             }
[13:23:07.414]             {
[13:23:07.414]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.414]                   0L) {
[13:23:07.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.414]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.414]                   base::options(opts)
[13:23:07.414]                 }
[13:23:07.414]                 {
[13:23:07.414]                   {
[13:23:07.414]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.414]                     NULL
[13:23:07.414]                   }
[13:23:07.414]                   options(future.plan = NULL)
[13:23:07.414]                   if (is.na(NA_character_)) 
[13:23:07.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.414]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:07.414]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:07.414]                     envir = parent.frame()) 
[13:23:07.414]                   {
[13:23:07.414]                     if (is.function(workers)) 
[13:23:07.414]                       workers <- workers()
[13:23:07.414]                     workers <- structure(as.integer(workers), 
[13:23:07.414]                       class = class(workers))
[13:23:07.414]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:07.414]                       workers >= 1)
[13:23:07.414]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:07.414]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:07.414]                     }
[13:23:07.414]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:07.414]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:07.414]                       envir = envir)
[13:23:07.414]                     if (!future$lazy) 
[13:23:07.414]                       future <- run(future)
[13:23:07.414]                     invisible(future)
[13:23:07.414]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.414]                 }
[13:23:07.414]             }
[13:23:07.414]         }
[13:23:07.414]     })
[13:23:07.414]     if (TRUE) {
[13:23:07.414]         base::sink(type = "output", split = FALSE)
[13:23:07.414]         if (TRUE) {
[13:23:07.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.414]         }
[13:23:07.414]         else {
[13:23:07.414]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.414]         }
[13:23:07.414]         base::close(...future.stdout)
[13:23:07.414]         ...future.stdout <- NULL
[13:23:07.414]     }
[13:23:07.414]     ...future.result$conditions <- ...future.conditions
[13:23:07.414]     ...future.result$finished <- base::Sys.time()
[13:23:07.414]     ...future.result
[13:23:07.414] }
[13:23:07.417] MultisessionFuture started
[13:23:07.417] - Launch lazy future ... done
[13:23:07.417] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5ee93b8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5812030> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5ee93b8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x5596d5812030> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[13:23:07.447] resolve() on list ...
[13:23:07.447]  recursive: 0
[13:23:07.447]  length: 6
[13:23:07.447]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[13:23:07.447] signalConditionsASAP(numeric, pos=1) ...
[13:23:07.447] - nx: 6
[13:23:07.447] - relay: TRUE
[13:23:07.448] - stdout: TRUE
[13:23:07.448] - signal: TRUE
[13:23:07.448] - resignal: FALSE
[13:23:07.448] - force: TRUE
[13:23:07.448] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.448] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.448]  - until=2
[13:23:07.448]  - relaying element #2
[13:23:07.448] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.448] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.448] signalConditionsASAP(NULL, pos=1) ... done
[13:23:07.449]  length: 5 (resolved future 1)
[13:23:07.449] receiveMessageFromWorker() for ClusterFuture ...
[13:23:07.449] - Validating connection of MultisessionFuture
[13:23:07.449] - received message: FutureResult
[13:23:07.450] - Received FutureResult
[13:23:07.450] - Erased future from FutureRegistry
[13:23:07.450] result() for ClusterFuture ...
[13:23:07.450] - result already collected: FutureResult
[13:23:07.450] result() for ClusterFuture ... done
[13:23:07.450] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:07.450] Future #2
[13:23:07.450] result() for ClusterFuture ...
[13:23:07.450] - result already collected: FutureResult
[13:23:07.450] result() for ClusterFuture ... done
[13:23:07.451] result() for ClusterFuture ...
[13:23:07.451] - result already collected: FutureResult
[13:23:07.451] result() for ClusterFuture ... done
[13:23:07.451] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:07.451] - nx: 6
[13:23:07.451] - relay: TRUE
[13:23:07.451] - stdout: TRUE
[13:23:07.451] - signal: TRUE
[13:23:07.451] - resignal: FALSE
[13:23:07.451] - force: TRUE
[13:23:07.451] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.452] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:07.452]  - until=2
[13:23:07.452]  - relaying element #2
[13:23:07.452] result() for ClusterFuture ...
[13:23:07.452] - result already collected: FutureResult
[13:23:07.452] result() for ClusterFuture ... done
[13:23:07.452] result() for ClusterFuture ...
[13:23:07.452] - result already collected: FutureResult
[13:23:07.452] result() for ClusterFuture ... done
[13:23:07.452] result() for ClusterFuture ...
[13:23:07.452] - result already collected: FutureResult
[13:23:07.453] result() for ClusterFuture ... done
[13:23:07.453] result() for ClusterFuture ...
[13:23:07.453] - result already collected: FutureResult
[13:23:07.453] result() for ClusterFuture ... done
[13:23:07.453] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.453] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.453] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:07.453]  length: 4 (resolved future 2)
[13:23:07.464] signalConditionsASAP(NULL, pos=4) ...
[13:23:07.464] - nx: 6
[13:23:07.464] - relay: TRUE
[13:23:07.464] - stdout: TRUE
[13:23:07.465] - signal: TRUE
[13:23:07.465] - resignal: FALSE
[13:23:07.465] - force: TRUE
[13:23:07.465] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.465] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.465]  - until=5
[13:23:07.466]  - relaying element #3
[13:23:07.466]  - relaying element #5
[13:23:07.466] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:23:07.466] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.466] signalConditionsASAP(NULL, pos=4) ... done
[13:23:07.466]  length: 3 (resolved future 4)
[13:23:07.466] signalConditionsASAP(NULL, pos=5) ...
[13:23:07.466] - nx: 6
[13:23:07.466] - relay: TRUE
[13:23:07.467] - stdout: TRUE
[13:23:07.467] - signal: TRUE
[13:23:07.467] - resignal: FALSE
[13:23:07.467] - force: TRUE
[13:23:07.467] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[13:23:07.467] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.467]  - until=6
[13:23:07.467]  - relaying element #3
[13:23:07.467]  - relaying element #6
[13:23:07.467] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:23:07.467] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.468] signalConditionsASAP(NULL, pos=5) ... done
[13:23:07.468]  length: 2 (resolved future 5)
[13:23:07.468] signalConditionsASAP(numeric, pos=6) ...
[13:23:07.468] - nx: 6
[13:23:07.468] - relay: TRUE
[13:23:07.468] - stdout: TRUE
[13:23:07.468] - signal: TRUE
[13:23:07.468] - resignal: FALSE
[13:23:07.468] - force: TRUE
[13:23:07.468] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[13:23:07.468] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.468]  - until=6
[13:23:07.469]  - relaying element #3
[13:23:07.469] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:23:07.469] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.469] signalConditionsASAP(NULL, pos=6) ... done
[13:23:07.469]  length: 1 (resolved future 6)
[13:23:07.480] receiveMessageFromWorker() for ClusterFuture ...
[13:23:07.480] - Validating connection of MultisessionFuture
[13:23:07.480] - received message: FutureResult
[13:23:07.480] - Received FutureResult
[13:23:07.481] - Erased future from FutureRegistry
[13:23:07.481] result() for ClusterFuture ...
[13:23:07.481] - result already collected: FutureResult
[13:23:07.481] result() for ClusterFuture ... done
[13:23:07.481] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:07.481] Future #3
[13:23:07.481] result() for ClusterFuture ...
[13:23:07.481] - result already collected: FutureResult
[13:23:07.481] result() for ClusterFuture ... done
[13:23:07.481] result() for ClusterFuture ...
[13:23:07.482] - result already collected: FutureResult
[13:23:07.482] result() for ClusterFuture ... done
[13:23:07.482] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:07.482] - nx: 6
[13:23:07.482] - relay: TRUE
[13:23:07.482] - stdout: TRUE
[13:23:07.482] - signal: TRUE
[13:23:07.482] - resignal: FALSE
[13:23:07.482] - force: TRUE
[13:23:07.482] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[13:23:07.482] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:07.483]  - until=6
[13:23:07.483]  - relaying element #3
[13:23:07.483] result() for ClusterFuture ...
[13:23:07.483] - result already collected: FutureResult
[13:23:07.483] result() for ClusterFuture ... done
[13:23:07.483] result() for ClusterFuture ...
[13:23:07.483] - result already collected: FutureResult
[13:23:07.483] result() for ClusterFuture ... done
[13:23:07.483] result() for ClusterFuture ...
[13:23:07.483] - result already collected: FutureResult
[13:23:07.483] result() for ClusterFuture ... done
[13:23:07.484] result() for ClusterFuture ...
[13:23:07.484] - result already collected: FutureResult
[13:23:07.484] result() for ClusterFuture ... done
[13:23:07.484] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.484] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.484] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:07.484]  length: 0 (resolved future 3)
[13:23:07.484] Relaying remaining futures
[13:23:07.484] signalConditionsASAP(NULL, pos=0) ...
[13:23:07.484] - nx: 6
[13:23:07.485] - relay: TRUE
[13:23:07.485] - stdout: TRUE
[13:23:07.485] - signal: TRUE
[13:23:07.485] - resignal: FALSE
[13:23:07.485] - force: TRUE
[13:23:07.485] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.485] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[13:23:07.485] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:07.485] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:07.485] signalConditionsASAP(NULL, pos=0) ... done
[13:23:07.485] resolve() on list ... DONE
[13:23:07.486] result() for ClusterFuture ...
[13:23:07.486] - result already collected: FutureResult
[13:23:07.486] result() for ClusterFuture ... done
[13:23:07.486] result() for ClusterFuture ...
[13:23:07.486] - result already collected: FutureResult
[13:23:07.486] result() for ClusterFuture ... done
[13:23:07.486] result() for ClusterFuture ...
[13:23:07.486] - result already collected: FutureResult
[13:23:07.486] result() for ClusterFuture ... done
[13:23:07.487] result() for ClusterFuture ...
[13:23:07.487] - result already collected: FutureResult
[13:23:07.487] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[13:23:07.491] plan(): Setting new future strategy stack:
[13:23:07.491] List of future strategies:
[13:23:07.491] 1. multicore:
[13:23:07.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.491]    - tweaked: FALSE
[13:23:07.491]    - call: plan(strategy)
[13:23:07.496] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:23:07.496] getGlobalsAndPackages() ...
[13:23:07.496] Searching for globals...
[13:23:07.497] 
[13:23:07.497] Searching for globals ... DONE
[13:23:07.497] - globals: [0] <none>
[13:23:07.497] getGlobalsAndPackages() ... DONE
[13:23:07.497] run() for ‘Future’ ...
[13:23:07.497] - state: ‘created’
[13:23:07.497] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.501] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.502]   - Field: ‘label’
[13:23:07.502]   - Field: ‘local’
[13:23:07.502]   - Field: ‘owner’
[13:23:07.502]   - Field: ‘envir’
[13:23:07.502]   - Field: ‘workers’
[13:23:07.502]   - Field: ‘packages’
[13:23:07.502]   - Field: ‘gc’
[13:23:07.503]   - Field: ‘job’
[13:23:07.503]   - Field: ‘conditions’
[13:23:07.503]   - Field: ‘expr’
[13:23:07.503]   - Field: ‘uuid’
[13:23:07.503]   - Field: ‘seed’
[13:23:07.503]   - Field: ‘version’
[13:23:07.503]   - Field: ‘result’
[13:23:07.503]   - Field: ‘asynchronous’
[13:23:07.503]   - Field: ‘calls’
[13:23:07.503]   - Field: ‘globals’
[13:23:07.503]   - Field: ‘stdout’
[13:23:07.504]   - Field: ‘earlySignal’
[13:23:07.504]   - Field: ‘lazy’
[13:23:07.504]   - Field: ‘state’
[13:23:07.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.504] - Launch lazy future ...
[13:23:07.504] Packages needed by the future expression (n = 0): <none>
[13:23:07.504] Packages needed by future strategies (n = 0): <none>
[13:23:07.505] {
[13:23:07.505]     {
[13:23:07.505]         {
[13:23:07.505]             ...future.startTime <- base::Sys.time()
[13:23:07.505]             {
[13:23:07.505]                 {
[13:23:07.505]                   {
[13:23:07.505]                     {
[13:23:07.505]                       base::local({
[13:23:07.505]                         has_future <- base::requireNamespace("future", 
[13:23:07.505]                           quietly = TRUE)
[13:23:07.505]                         if (has_future) {
[13:23:07.505]                           ns <- base::getNamespace("future")
[13:23:07.505]                           version <- ns[[".package"]][["version"]]
[13:23:07.505]                           if (is.null(version)) 
[13:23:07.505]                             version <- utils::packageVersion("future")
[13:23:07.505]                         }
[13:23:07.505]                         else {
[13:23:07.505]                           version <- NULL
[13:23:07.505]                         }
[13:23:07.505]                         if (!has_future || version < "1.8.0") {
[13:23:07.505]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.505]                             "", base::R.version$version.string), 
[13:23:07.505]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.505]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.505]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.505]                               "release", "version")], collapse = " "), 
[13:23:07.505]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.505]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.505]                             info)
[13:23:07.505]                           info <- base::paste(info, collapse = "; ")
[13:23:07.505]                           if (!has_future) {
[13:23:07.505]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.505]                               info)
[13:23:07.505]                           }
[13:23:07.505]                           else {
[13:23:07.505]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.505]                               info, version)
[13:23:07.505]                           }
[13:23:07.505]                           base::stop(msg)
[13:23:07.505]                         }
[13:23:07.505]                       })
[13:23:07.505]                     }
[13:23:07.505]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.505]                     base::options(mc.cores = 1L)
[13:23:07.505]                   }
[13:23:07.505]                   options(future.plan = NULL)
[13:23:07.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.505]                 }
[13:23:07.505]                 ...future.workdir <- getwd()
[13:23:07.505]             }
[13:23:07.505]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.505]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.505]         }
[13:23:07.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.505]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.505]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.505]             base::names(...future.oldOptions))
[13:23:07.505]     }
[13:23:07.505]     if (FALSE) {
[13:23:07.505]     }
[13:23:07.505]     else {
[13:23:07.505]         if (TRUE) {
[13:23:07.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.505]                 open = "w")
[13:23:07.505]         }
[13:23:07.505]         else {
[13:23:07.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.505]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.505]         }
[13:23:07.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.505]             base::sink(type = "output", split = FALSE)
[13:23:07.505]             base::close(...future.stdout)
[13:23:07.505]         }, add = TRUE)
[13:23:07.505]     }
[13:23:07.505]     ...future.frame <- base::sys.nframe()
[13:23:07.505]     ...future.conditions <- base::list()
[13:23:07.505]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.505]     if (FALSE) {
[13:23:07.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.505]     }
[13:23:07.505]     ...future.result <- base::tryCatch({
[13:23:07.505]         base::withCallingHandlers({
[13:23:07.505]             ...future.value <- base::withVisible(base::local({
[13:23:07.505]                 withCallingHandlers({
[13:23:07.505]                   2
[13:23:07.505]                 }, immediateCondition = function(cond) {
[13:23:07.505]                   save_rds <- function (object, pathname, ...) 
[13:23:07.505]                   {
[13:23:07.505]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.505]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.505]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.505]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.505]                         fi_tmp[["mtime"]])
[13:23:07.505]                     }
[13:23:07.505]                     tryCatch({
[13:23:07.505]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.505]                     }, error = function(ex) {
[13:23:07.505]                       msg <- conditionMessage(ex)
[13:23:07.505]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.505]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.505]                         fi_tmp[["mtime"]], msg)
[13:23:07.505]                       ex$message <- msg
[13:23:07.505]                       stop(ex)
[13:23:07.505]                     })
[13:23:07.505]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.505]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.505]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.505]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.505]                       fi <- file.info(pathname)
[13:23:07.505]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.505]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.505]                         fi[["size"]], fi[["mtime"]])
[13:23:07.505]                       stop(msg)
[13:23:07.505]                     }
[13:23:07.505]                     invisible(pathname)
[13:23:07.505]                   }
[13:23:07.505]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.505]                     rootPath = tempdir()) 
[13:23:07.505]                   {
[13:23:07.505]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.505]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.505]                       tmpdir = path, fileext = ".rds")
[13:23:07.505]                     save_rds(obj, file)
[13:23:07.505]                   }
[13:23:07.505]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.505]                   {
[13:23:07.505]                     inherits <- base::inherits
[13:23:07.505]                     invokeRestart <- base::invokeRestart
[13:23:07.505]                     is.null <- base::is.null
[13:23:07.505]                     muffled <- FALSE
[13:23:07.505]                     if (inherits(cond, "message")) {
[13:23:07.505]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.505]                       if (muffled) 
[13:23:07.505]                         invokeRestart("muffleMessage")
[13:23:07.505]                     }
[13:23:07.505]                     else if (inherits(cond, "warning")) {
[13:23:07.505]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.505]                       if (muffled) 
[13:23:07.505]                         invokeRestart("muffleWarning")
[13:23:07.505]                     }
[13:23:07.505]                     else if (inherits(cond, "condition")) {
[13:23:07.505]                       if (!is.null(pattern)) {
[13:23:07.505]                         computeRestarts <- base::computeRestarts
[13:23:07.505]                         grepl <- base::grepl
[13:23:07.505]                         restarts <- computeRestarts(cond)
[13:23:07.505]                         for (restart in restarts) {
[13:23:07.505]                           name <- restart$name
[13:23:07.505]                           if (is.null(name)) 
[13:23:07.505]                             next
[13:23:07.505]                           if (!grepl(pattern, name)) 
[13:23:07.505]                             next
[13:23:07.505]                           invokeRestart(restart)
[13:23:07.505]                           muffled <- TRUE
[13:23:07.505]                           break
[13:23:07.505]                         }
[13:23:07.505]                       }
[13:23:07.505]                     }
[13:23:07.505]                     invisible(muffled)
[13:23:07.505]                   }
[13:23:07.505]                   muffleCondition(cond)
[13:23:07.505]                 })
[13:23:07.505]             }))
[13:23:07.505]             future::FutureResult(value = ...future.value$value, 
[13:23:07.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.505]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.505]                     ...future.globalenv.names))
[13:23:07.505]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.505]         }, condition = base::local({
[13:23:07.505]             c <- base::c
[13:23:07.505]             inherits <- base::inherits
[13:23:07.505]             invokeRestart <- base::invokeRestart
[13:23:07.505]             length <- base::length
[13:23:07.505]             list <- base::list
[13:23:07.505]             seq.int <- base::seq.int
[13:23:07.505]             signalCondition <- base::signalCondition
[13:23:07.505]             sys.calls <- base::sys.calls
[13:23:07.505]             `[[` <- base::`[[`
[13:23:07.505]             `+` <- base::`+`
[13:23:07.505]             `<<-` <- base::`<<-`
[13:23:07.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.505]                   3L)]
[13:23:07.505]             }
[13:23:07.505]             function(cond) {
[13:23:07.505]                 is_error <- inherits(cond, "error")
[13:23:07.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.505]                   NULL)
[13:23:07.505]                 if (is_error) {
[13:23:07.505]                   sessionInformation <- function() {
[13:23:07.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.505]                       search = base::search(), system = base::Sys.info())
[13:23:07.505]                   }
[13:23:07.505]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.505]                     cond$call), session = sessionInformation(), 
[13:23:07.505]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.505]                   signalCondition(cond)
[13:23:07.505]                 }
[13:23:07.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.505]                 "immediateCondition"))) {
[13:23:07.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.505]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.505]                   if (TRUE && !signal) {
[13:23:07.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.505]                     {
[13:23:07.505]                       inherits <- base::inherits
[13:23:07.505]                       invokeRestart <- base::invokeRestart
[13:23:07.505]                       is.null <- base::is.null
[13:23:07.505]                       muffled <- FALSE
[13:23:07.505]                       if (inherits(cond, "message")) {
[13:23:07.505]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.505]                         if (muffled) 
[13:23:07.505]                           invokeRestart("muffleMessage")
[13:23:07.505]                       }
[13:23:07.505]                       else if (inherits(cond, "warning")) {
[13:23:07.505]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.505]                         if (muffled) 
[13:23:07.505]                           invokeRestart("muffleWarning")
[13:23:07.505]                       }
[13:23:07.505]                       else if (inherits(cond, "condition")) {
[13:23:07.505]                         if (!is.null(pattern)) {
[13:23:07.505]                           computeRestarts <- base::computeRestarts
[13:23:07.505]                           grepl <- base::grepl
[13:23:07.505]                           restarts <- computeRestarts(cond)
[13:23:07.505]                           for (restart in restarts) {
[13:23:07.505]                             name <- restart$name
[13:23:07.505]                             if (is.null(name)) 
[13:23:07.505]                               next
[13:23:07.505]                             if (!grepl(pattern, name)) 
[13:23:07.505]                               next
[13:23:07.505]                             invokeRestart(restart)
[13:23:07.505]                             muffled <- TRUE
[13:23:07.505]                             break
[13:23:07.505]                           }
[13:23:07.505]                         }
[13:23:07.505]                       }
[13:23:07.505]                       invisible(muffled)
[13:23:07.505]                     }
[13:23:07.505]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.505]                   }
[13:23:07.505]                 }
[13:23:07.505]                 else {
[13:23:07.505]                   if (TRUE) {
[13:23:07.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.505]                     {
[13:23:07.505]                       inherits <- base::inherits
[13:23:07.505]                       invokeRestart <- base::invokeRestart
[13:23:07.505]                       is.null <- base::is.null
[13:23:07.505]                       muffled <- FALSE
[13:23:07.505]                       if (inherits(cond, "message")) {
[13:23:07.505]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.505]                         if (muffled) 
[13:23:07.505]                           invokeRestart("muffleMessage")
[13:23:07.505]                       }
[13:23:07.505]                       else if (inherits(cond, "warning")) {
[13:23:07.505]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.505]                         if (muffled) 
[13:23:07.505]                           invokeRestart("muffleWarning")
[13:23:07.505]                       }
[13:23:07.505]                       else if (inherits(cond, "condition")) {
[13:23:07.505]                         if (!is.null(pattern)) {
[13:23:07.505]                           computeRestarts <- base::computeRestarts
[13:23:07.505]                           grepl <- base::grepl
[13:23:07.505]                           restarts <- computeRestarts(cond)
[13:23:07.505]                           for (restart in restarts) {
[13:23:07.505]                             name <- restart$name
[13:23:07.505]                             if (is.null(name)) 
[13:23:07.505]                               next
[13:23:07.505]                             if (!grepl(pattern, name)) 
[13:23:07.505]                               next
[13:23:07.505]                             invokeRestart(restart)
[13:23:07.505]                             muffled <- TRUE
[13:23:07.505]                             break
[13:23:07.505]                           }
[13:23:07.505]                         }
[13:23:07.505]                       }
[13:23:07.505]                       invisible(muffled)
[13:23:07.505]                     }
[13:23:07.505]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.505]                   }
[13:23:07.505]                 }
[13:23:07.505]             }
[13:23:07.505]         }))
[13:23:07.505]     }, error = function(ex) {
[13:23:07.505]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.505]                 ...future.rng), started = ...future.startTime, 
[13:23:07.505]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.505]             version = "1.8"), class = "FutureResult")
[13:23:07.505]     }, finally = {
[13:23:07.505]         if (!identical(...future.workdir, getwd())) 
[13:23:07.505]             setwd(...future.workdir)
[13:23:07.505]         {
[13:23:07.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.505]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.505]             }
[13:23:07.505]             base::options(...future.oldOptions)
[13:23:07.505]             if (.Platform$OS.type == "windows") {
[13:23:07.505]                 old_names <- names(...future.oldEnvVars)
[13:23:07.505]                 envs <- base::Sys.getenv()
[13:23:07.505]                 names <- names(envs)
[13:23:07.505]                 common <- intersect(names, old_names)
[13:23:07.505]                 added <- setdiff(names, old_names)
[13:23:07.505]                 removed <- setdiff(old_names, names)
[13:23:07.505]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.505]                   envs[common]]
[13:23:07.505]                 NAMES <- toupper(changed)
[13:23:07.505]                 args <- list()
[13:23:07.505]                 for (kk in seq_along(NAMES)) {
[13:23:07.505]                   name <- changed[[kk]]
[13:23:07.505]                   NAME <- NAMES[[kk]]
[13:23:07.505]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.505]                     next
[13:23:07.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.505]                 }
[13:23:07.505]                 NAMES <- toupper(added)
[13:23:07.505]                 for (kk in seq_along(NAMES)) {
[13:23:07.505]                   name <- added[[kk]]
[13:23:07.505]                   NAME <- NAMES[[kk]]
[13:23:07.505]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.505]                     next
[13:23:07.505]                   args[[name]] <- ""
[13:23:07.505]                 }
[13:23:07.505]                 NAMES <- toupper(removed)
[13:23:07.505]                 for (kk in seq_along(NAMES)) {
[13:23:07.505]                   name <- removed[[kk]]
[13:23:07.505]                   NAME <- NAMES[[kk]]
[13:23:07.505]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.505]                     next
[13:23:07.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.505]                 }
[13:23:07.505]                 if (length(args) > 0) 
[13:23:07.505]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.505]             }
[13:23:07.505]             else {
[13:23:07.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.505]             }
[13:23:07.505]             {
[13:23:07.505]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.505]                   0L) {
[13:23:07.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.505]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.505]                   base::options(opts)
[13:23:07.505]                 }
[13:23:07.505]                 {
[13:23:07.505]                   {
[13:23:07.505]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.505]                     NULL
[13:23:07.505]                   }
[13:23:07.505]                   options(future.plan = NULL)
[13:23:07.505]                   if (is.na(NA_character_)) 
[13:23:07.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.505]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.505]                     envir = parent.frame()) 
[13:23:07.505]                   {
[13:23:07.505]                     default_workers <- missing(workers)
[13:23:07.505]                     if (is.function(workers)) 
[13:23:07.505]                       workers <- workers()
[13:23:07.505]                     workers <- structure(as.integer(workers), 
[13:23:07.505]                       class = class(workers))
[13:23:07.505]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.505]                       1L)
[13:23:07.505]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.505]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.505]                       if (default_workers) 
[13:23:07.505]                         supportsMulticore(warn = TRUE)
[13:23:07.505]                       return(sequential(..., envir = envir))
[13:23:07.505]                     }
[13:23:07.505]                     oopts <- options(mc.cores = workers)
[13:23:07.505]                     on.exit(options(oopts))
[13:23:07.505]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.505]                       envir = envir)
[13:23:07.505]                     if (!future$lazy) 
[13:23:07.505]                       future <- run(future)
[13:23:07.505]                     invisible(future)
[13:23:07.505]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.505]                 }
[13:23:07.505]             }
[13:23:07.505]         }
[13:23:07.505]     })
[13:23:07.505]     if (TRUE) {
[13:23:07.505]         base::sink(type = "output", split = FALSE)
[13:23:07.505]         if (TRUE) {
[13:23:07.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.505]         }
[13:23:07.505]         else {
[13:23:07.505]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.505]         }
[13:23:07.505]         base::close(...future.stdout)
[13:23:07.505]         ...future.stdout <- NULL
[13:23:07.505]     }
[13:23:07.505]     ...future.result$conditions <- ...future.conditions
[13:23:07.505]     ...future.result$finished <- base::Sys.time()
[13:23:07.505]     ...future.result
[13:23:07.505] }
[13:23:07.507] requestCore(): workers = 2
[13:23:07.510] MulticoreFuture started
[13:23:07.511] - Launch lazy future ... done
[13:23:07.511] run() for ‘MulticoreFuture’ ... done
[13:23:07.511] getGlobalsAndPackages() ...
[13:23:07.511] Searching for globals...
[13:23:07.511] plan(): Setting new future strategy stack:
[13:23:07.512] 
[13:23:07.512] Searching for globals ... DONE
[13:23:07.512] - globals: [0] <none>
[13:23:07.512] List of future strategies:
[13:23:07.512] 1. sequential:
[13:23:07.512]    - args: function (..., envir = parent.frame())
[13:23:07.512]    - tweaked: FALSE
[13:23:07.512]    - call: NULL
[13:23:07.513] getGlobalsAndPackages() ... DONE
[13:23:07.513] plan(): nbrOfWorkers() = 1
[13:23:07.513] run() for ‘Future’ ...
[13:23:07.513] - state: ‘created’
[13:23:07.514] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.515] plan(): Setting new future strategy stack:
[13:23:07.515] List of future strategies:
[13:23:07.515] 1. multicore:
[13:23:07.515]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.515]    - tweaked: FALSE
[13:23:07.515]    - call: plan(strategy)
[13:23:07.520] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.520] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.520] plan(): nbrOfWorkers() = 2
[13:23:07.520]   - Field: ‘label’
[13:23:07.520]   - Field: ‘local’
[13:23:07.520]   - Field: ‘owner’
[13:23:07.521]   - Field: ‘envir’
[13:23:07.521]   - Field: ‘workers’
[13:23:07.521]   - Field: ‘packages’
[13:23:07.521]   - Field: ‘gc’
[13:23:07.521]   - Field: ‘job’
[13:23:07.521]   - Field: ‘conditions’
[13:23:07.521]   - Field: ‘expr’
[13:23:07.522]   - Field: ‘uuid’
[13:23:07.522]   - Field: ‘seed’
[13:23:07.522]   - Field: ‘version’
[13:23:07.522]   - Field: ‘result’
[13:23:07.522]   - Field: ‘asynchronous’
[13:23:07.522]   - Field: ‘calls’
[13:23:07.522]   - Field: ‘globals’
[13:23:07.523]   - Field: ‘stdout’
[13:23:07.523]   - Field: ‘earlySignal’
[13:23:07.523]   - Field: ‘lazy’
[13:23:07.523]   - Field: ‘state’
[13:23:07.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.523] - Launch lazy future ...
[13:23:07.524] Packages needed by the future expression (n = 0): <none>
[13:23:07.524] Packages needed by future strategies (n = 0): <none>
[13:23:07.525] {
[13:23:07.525]     {
[13:23:07.525]         {
[13:23:07.525]             ...future.startTime <- base::Sys.time()
[13:23:07.525]             {
[13:23:07.525]                 {
[13:23:07.525]                   {
[13:23:07.525]                     {
[13:23:07.525]                       base::local({
[13:23:07.525]                         has_future <- base::requireNamespace("future", 
[13:23:07.525]                           quietly = TRUE)
[13:23:07.525]                         if (has_future) {
[13:23:07.525]                           ns <- base::getNamespace("future")
[13:23:07.525]                           version <- ns[[".package"]][["version"]]
[13:23:07.525]                           if (is.null(version)) 
[13:23:07.525]                             version <- utils::packageVersion("future")
[13:23:07.525]                         }
[13:23:07.525]                         else {
[13:23:07.525]                           version <- NULL
[13:23:07.525]                         }
[13:23:07.525]                         if (!has_future || version < "1.8.0") {
[13:23:07.525]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.525]                             "", base::R.version$version.string), 
[13:23:07.525]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.525]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.525]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.525]                               "release", "version")], collapse = " "), 
[13:23:07.525]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.525]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.525]                             info)
[13:23:07.525]                           info <- base::paste(info, collapse = "; ")
[13:23:07.525]                           if (!has_future) {
[13:23:07.525]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.525]                               info)
[13:23:07.525]                           }
[13:23:07.525]                           else {
[13:23:07.525]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.525]                               info, version)
[13:23:07.525]                           }
[13:23:07.525]                           base::stop(msg)
[13:23:07.525]                         }
[13:23:07.525]                       })
[13:23:07.525]                     }
[13:23:07.525]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.525]                     base::options(mc.cores = 1L)
[13:23:07.525]                   }
[13:23:07.525]                   options(future.plan = NULL)
[13:23:07.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.525]                 }
[13:23:07.525]                 ...future.workdir <- getwd()
[13:23:07.525]             }
[13:23:07.525]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.525]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.525]         }
[13:23:07.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.525]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.525]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.525]             base::names(...future.oldOptions))
[13:23:07.525]     }
[13:23:07.525]     if (FALSE) {
[13:23:07.525]     }
[13:23:07.525]     else {
[13:23:07.525]         if (TRUE) {
[13:23:07.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.525]                 open = "w")
[13:23:07.525]         }
[13:23:07.525]         else {
[13:23:07.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.525]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.525]         }
[13:23:07.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.525]             base::sink(type = "output", split = FALSE)
[13:23:07.525]             base::close(...future.stdout)
[13:23:07.525]         }, add = TRUE)
[13:23:07.525]     }
[13:23:07.525]     ...future.frame <- base::sys.nframe()
[13:23:07.525]     ...future.conditions <- base::list()
[13:23:07.525]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.525]     if (FALSE) {
[13:23:07.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.525]     }
[13:23:07.525]     ...future.result <- base::tryCatch({
[13:23:07.525]         base::withCallingHandlers({
[13:23:07.525]             ...future.value <- base::withVisible(base::local({
[13:23:07.525]                 withCallingHandlers({
[13:23:07.525]                   NULL
[13:23:07.525]                 }, immediateCondition = function(cond) {
[13:23:07.525]                   save_rds <- function (object, pathname, ...) 
[13:23:07.525]                   {
[13:23:07.525]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.525]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.525]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.525]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.525]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.525]                         fi_tmp[["mtime"]])
[13:23:07.525]                     }
[13:23:07.525]                     tryCatch({
[13:23:07.525]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.525]                     }, error = function(ex) {
[13:23:07.525]                       msg <- conditionMessage(ex)
[13:23:07.525]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.525]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.525]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.525]                         fi_tmp[["mtime"]], msg)
[13:23:07.525]                       ex$message <- msg
[13:23:07.525]                       stop(ex)
[13:23:07.525]                     })
[13:23:07.525]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.525]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.525]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.525]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.525]                       fi <- file.info(pathname)
[13:23:07.525]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.525]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.525]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.525]                         fi[["size"]], fi[["mtime"]])
[13:23:07.525]                       stop(msg)
[13:23:07.525]                     }
[13:23:07.525]                     invisible(pathname)
[13:23:07.525]                   }
[13:23:07.525]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.525]                     rootPath = tempdir()) 
[13:23:07.525]                   {
[13:23:07.525]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.525]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.525]                       tmpdir = path, fileext = ".rds")
[13:23:07.525]                     save_rds(obj, file)
[13:23:07.525]                   }
[13:23:07.525]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.525]                   {
[13:23:07.525]                     inherits <- base::inherits
[13:23:07.525]                     invokeRestart <- base::invokeRestart
[13:23:07.525]                     is.null <- base::is.null
[13:23:07.525]                     muffled <- FALSE
[13:23:07.525]                     if (inherits(cond, "message")) {
[13:23:07.525]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.525]                       if (muffled) 
[13:23:07.525]                         invokeRestart("muffleMessage")
[13:23:07.525]                     }
[13:23:07.525]                     else if (inherits(cond, "warning")) {
[13:23:07.525]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.525]                       if (muffled) 
[13:23:07.525]                         invokeRestart("muffleWarning")
[13:23:07.525]                     }
[13:23:07.525]                     else if (inherits(cond, "condition")) {
[13:23:07.525]                       if (!is.null(pattern)) {
[13:23:07.525]                         computeRestarts <- base::computeRestarts
[13:23:07.525]                         grepl <- base::grepl
[13:23:07.525]                         restarts <- computeRestarts(cond)
[13:23:07.525]                         for (restart in restarts) {
[13:23:07.525]                           name <- restart$name
[13:23:07.525]                           if (is.null(name)) 
[13:23:07.525]                             next
[13:23:07.525]                           if (!grepl(pattern, name)) 
[13:23:07.525]                             next
[13:23:07.525]                           invokeRestart(restart)
[13:23:07.525]                           muffled <- TRUE
[13:23:07.525]                           break
[13:23:07.525]                         }
[13:23:07.525]                       }
[13:23:07.525]                     }
[13:23:07.525]                     invisible(muffled)
[13:23:07.525]                   }
[13:23:07.525]                   muffleCondition(cond)
[13:23:07.525]                 })
[13:23:07.525]             }))
[13:23:07.525]             future::FutureResult(value = ...future.value$value, 
[13:23:07.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.525]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.525]                     ...future.globalenv.names))
[13:23:07.525]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.525]         }, condition = base::local({
[13:23:07.525]             c <- base::c
[13:23:07.525]             inherits <- base::inherits
[13:23:07.525]             invokeRestart <- base::invokeRestart
[13:23:07.525]             length <- base::length
[13:23:07.525]             list <- base::list
[13:23:07.525]             seq.int <- base::seq.int
[13:23:07.525]             signalCondition <- base::signalCondition
[13:23:07.525]             sys.calls <- base::sys.calls
[13:23:07.525]             `[[` <- base::`[[`
[13:23:07.525]             `+` <- base::`+`
[13:23:07.525]             `<<-` <- base::`<<-`
[13:23:07.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.525]                   3L)]
[13:23:07.525]             }
[13:23:07.525]             function(cond) {
[13:23:07.525]                 is_error <- inherits(cond, "error")
[13:23:07.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.525]                   NULL)
[13:23:07.525]                 if (is_error) {
[13:23:07.525]                   sessionInformation <- function() {
[13:23:07.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.525]                       search = base::search(), system = base::Sys.info())
[13:23:07.525]                   }
[13:23:07.525]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.525]                     cond$call), session = sessionInformation(), 
[13:23:07.525]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.525]                   signalCondition(cond)
[13:23:07.525]                 }
[13:23:07.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.525]                 "immediateCondition"))) {
[13:23:07.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.525]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.525]                   if (TRUE && !signal) {
[13:23:07.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.525]                     {
[13:23:07.525]                       inherits <- base::inherits
[13:23:07.525]                       invokeRestart <- base::invokeRestart
[13:23:07.525]                       is.null <- base::is.null
[13:23:07.525]                       muffled <- FALSE
[13:23:07.525]                       if (inherits(cond, "message")) {
[13:23:07.525]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.525]                         if (muffled) 
[13:23:07.525]                           invokeRestart("muffleMessage")
[13:23:07.525]                       }
[13:23:07.525]                       else if (inherits(cond, "warning")) {
[13:23:07.525]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.525]                         if (muffled) 
[13:23:07.525]                           invokeRestart("muffleWarning")
[13:23:07.525]                       }
[13:23:07.525]                       else if (inherits(cond, "condition")) {
[13:23:07.525]                         if (!is.null(pattern)) {
[13:23:07.525]                           computeRestarts <- base::computeRestarts
[13:23:07.525]                           grepl <- base::grepl
[13:23:07.525]                           restarts <- computeRestarts(cond)
[13:23:07.525]                           for (restart in restarts) {
[13:23:07.525]                             name <- restart$name
[13:23:07.525]                             if (is.null(name)) 
[13:23:07.525]                               next
[13:23:07.525]                             if (!grepl(pattern, name)) 
[13:23:07.525]                               next
[13:23:07.525]                             invokeRestart(restart)
[13:23:07.525]                             muffled <- TRUE
[13:23:07.525]                             break
[13:23:07.525]                           }
[13:23:07.525]                         }
[13:23:07.525]                       }
[13:23:07.525]                       invisible(muffled)
[13:23:07.525]                     }
[13:23:07.525]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.525]                   }
[13:23:07.525]                 }
[13:23:07.525]                 else {
[13:23:07.525]                   if (TRUE) {
[13:23:07.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.525]                     {
[13:23:07.525]                       inherits <- base::inherits
[13:23:07.525]                       invokeRestart <- base::invokeRestart
[13:23:07.525]                       is.null <- base::is.null
[13:23:07.525]                       muffled <- FALSE
[13:23:07.525]                       if (inherits(cond, "message")) {
[13:23:07.525]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.525]                         if (muffled) 
[13:23:07.525]                           invokeRestart("muffleMessage")
[13:23:07.525]                       }
[13:23:07.525]                       else if (inherits(cond, "warning")) {
[13:23:07.525]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.525]                         if (muffled) 
[13:23:07.525]                           invokeRestart("muffleWarning")
[13:23:07.525]                       }
[13:23:07.525]                       else if (inherits(cond, "condition")) {
[13:23:07.525]                         if (!is.null(pattern)) {
[13:23:07.525]                           computeRestarts <- base::computeRestarts
[13:23:07.525]                           grepl <- base::grepl
[13:23:07.525]                           restarts <- computeRestarts(cond)
[13:23:07.525]                           for (restart in restarts) {
[13:23:07.525]                             name <- restart$name
[13:23:07.525]                             if (is.null(name)) 
[13:23:07.525]                               next
[13:23:07.525]                             if (!grepl(pattern, name)) 
[13:23:07.525]                               next
[13:23:07.525]                             invokeRestart(restart)
[13:23:07.525]                             muffled <- TRUE
[13:23:07.525]                             break
[13:23:07.525]                           }
[13:23:07.525]                         }
[13:23:07.525]                       }
[13:23:07.525]                       invisible(muffled)
[13:23:07.525]                     }
[13:23:07.525]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.525]                   }
[13:23:07.525]                 }
[13:23:07.525]             }
[13:23:07.525]         }))
[13:23:07.525]     }, error = function(ex) {
[13:23:07.525]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.525]                 ...future.rng), started = ...future.startTime, 
[13:23:07.525]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.525]             version = "1.8"), class = "FutureResult")
[13:23:07.525]     }, finally = {
[13:23:07.525]         if (!identical(...future.workdir, getwd())) 
[13:23:07.525]             setwd(...future.workdir)
[13:23:07.525]         {
[13:23:07.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.525]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.525]             }
[13:23:07.525]             base::options(...future.oldOptions)
[13:23:07.525]             if (.Platform$OS.type == "windows") {
[13:23:07.525]                 old_names <- names(...future.oldEnvVars)
[13:23:07.525]                 envs <- base::Sys.getenv()
[13:23:07.525]                 names <- names(envs)
[13:23:07.525]                 common <- intersect(names, old_names)
[13:23:07.525]                 added <- setdiff(names, old_names)
[13:23:07.525]                 removed <- setdiff(old_names, names)
[13:23:07.525]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.525]                   envs[common]]
[13:23:07.525]                 NAMES <- toupper(changed)
[13:23:07.525]                 args <- list()
[13:23:07.525]                 for (kk in seq_along(NAMES)) {
[13:23:07.525]                   name <- changed[[kk]]
[13:23:07.525]                   NAME <- NAMES[[kk]]
[13:23:07.525]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.525]                     next
[13:23:07.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.525]                 }
[13:23:07.525]                 NAMES <- toupper(added)
[13:23:07.525]                 for (kk in seq_along(NAMES)) {
[13:23:07.525]                   name <- added[[kk]]
[13:23:07.525]                   NAME <- NAMES[[kk]]
[13:23:07.525]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.525]                     next
[13:23:07.525]                   args[[name]] <- ""
[13:23:07.525]                 }
[13:23:07.525]                 NAMES <- toupper(removed)
[13:23:07.525]                 for (kk in seq_along(NAMES)) {
[13:23:07.525]                   name <- removed[[kk]]
[13:23:07.525]                   NAME <- NAMES[[kk]]
[13:23:07.525]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.525]                     next
[13:23:07.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.525]                 }
[13:23:07.525]                 if (length(args) > 0) 
[13:23:07.525]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.525]             }
[13:23:07.525]             else {
[13:23:07.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.525]             }
[13:23:07.525]             {
[13:23:07.525]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.525]                   0L) {
[13:23:07.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.525]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.525]                   base::options(opts)
[13:23:07.525]                 }
[13:23:07.525]                 {
[13:23:07.525]                   {
[13:23:07.525]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.525]                     NULL
[13:23:07.525]                   }
[13:23:07.525]                   options(future.plan = NULL)
[13:23:07.525]                   if (is.na(NA_character_)) 
[13:23:07.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.525]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.525]                     envir = parent.frame()) 
[13:23:07.525]                   {
[13:23:07.525]                     default_workers <- missing(workers)
[13:23:07.525]                     if (is.function(workers)) 
[13:23:07.525]                       workers <- workers()
[13:23:07.525]                     workers <- structure(as.integer(workers), 
[13:23:07.525]                       class = class(workers))
[13:23:07.525]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.525]                       1L)
[13:23:07.525]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.525]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.525]                       if (default_workers) 
[13:23:07.525]                         supportsMulticore(warn = TRUE)
[13:23:07.525]                       return(sequential(..., envir = envir))
[13:23:07.525]                     }
[13:23:07.525]                     oopts <- options(mc.cores = workers)
[13:23:07.525]                     on.exit(options(oopts))
[13:23:07.525]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.525]                       envir = envir)
[13:23:07.525]                     if (!future$lazy) 
[13:23:07.525]                       future <- run(future)
[13:23:07.525]                     invisible(future)
[13:23:07.525]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.525]                 }
[13:23:07.525]             }
[13:23:07.525]         }
[13:23:07.525]     })
[13:23:07.525]     if (TRUE) {
[13:23:07.525]         base::sink(type = "output", split = FALSE)
[13:23:07.525]         if (TRUE) {
[13:23:07.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.525]         }
[13:23:07.525]         else {
[13:23:07.525]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.525]         }
[13:23:07.525]         base::close(...future.stdout)
[13:23:07.525]         ...future.stdout <- NULL
[13:23:07.525]     }
[13:23:07.525]     ...future.result$conditions <- ...future.conditions
[13:23:07.525]     ...future.result$finished <- base::Sys.time()
[13:23:07.525]     ...future.result
[13:23:07.525] }
[13:23:07.529] requestCore(): workers = 2
[13:23:07.533] MulticoreFuture started
[13:23:07.533] - Launch lazy future ... done
[13:23:07.534] run() for ‘MulticoreFuture’ ... done
[13:23:07.534] plan(): Setting new future strategy stack:
[13:23:07.534] List of future strategies:
[13:23:07.534] 1. sequential:
[13:23:07.534]    - args: function (..., envir = parent.frame())
[13:23:07.534]    - tweaked: FALSE
[13:23:07.534]    - call: NULL
[13:23:07.535] getGlobalsAndPackages() ...
[13:23:07.535] plan(): nbrOfWorkers() = 1
[13:23:07.535] Searching for globals...
[13:23:07.537] - globals found: [1] ‘{’
[13:23:07.537] Searching for globals ... DONE
[13:23:07.537] plan(): Setting new future strategy stack:
[13:23:07.537] Resolving globals: FALSE
[13:23:07.537] List of future strategies:
[13:23:07.537] 1. multicore:
[13:23:07.537]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.537]    - tweaked: FALSE
[13:23:07.537]    - call: plan(strategy)
[13:23:07.538] 
[13:23:07.538] 
[13:23:07.538] getGlobalsAndPackages() ... DONE
[13:23:07.539] run() for ‘Future’ ...
[13:23:07.539] - state: ‘created’
[13:23:07.540] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.543] plan(): nbrOfWorkers() = 2
[13:23:07.545] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.546]   - Field: ‘label’
[13:23:07.546]   - Field: ‘local’
[13:23:07.546]   - Field: ‘owner’
[13:23:07.546]   - Field: ‘envir’
[13:23:07.546]   - Field: ‘workers’
[13:23:07.546]   - Field: ‘packages’
[13:23:07.546]   - Field: ‘gc’
[13:23:07.547]   - Field: ‘job’
[13:23:07.547]   - Field: ‘conditions’
[13:23:07.547]   - Field: ‘expr’
[13:23:07.547]   - Field: ‘uuid’
[13:23:07.547]   - Field: ‘seed’
[13:23:07.547]   - Field: ‘version’
[13:23:07.547]   - Field: ‘result’
[13:23:07.548]   - Field: ‘asynchronous’
[13:23:07.548]   - Field: ‘calls’
[13:23:07.548]   - Field: ‘globals’
[13:23:07.548]   - Field: ‘stdout’
[13:23:07.548]   - Field: ‘earlySignal’
[13:23:07.548]   - Field: ‘lazy’
[13:23:07.548]   - Field: ‘state’
[13:23:07.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.549] - Launch lazy future ...
[13:23:07.549] Packages needed by the future expression (n = 0): <none>
[13:23:07.549] Packages needed by future strategies (n = 0): <none>
[13:23:07.550] {
[13:23:07.550]     {
[13:23:07.550]         {
[13:23:07.550]             ...future.startTime <- base::Sys.time()
[13:23:07.550]             {
[13:23:07.550]                 {
[13:23:07.550]                   {
[13:23:07.550]                     {
[13:23:07.550]                       base::local({
[13:23:07.550]                         has_future <- base::requireNamespace("future", 
[13:23:07.550]                           quietly = TRUE)
[13:23:07.550]                         if (has_future) {
[13:23:07.550]                           ns <- base::getNamespace("future")
[13:23:07.550]                           version <- ns[[".package"]][["version"]]
[13:23:07.550]                           if (is.null(version)) 
[13:23:07.550]                             version <- utils::packageVersion("future")
[13:23:07.550]                         }
[13:23:07.550]                         else {
[13:23:07.550]                           version <- NULL
[13:23:07.550]                         }
[13:23:07.550]                         if (!has_future || version < "1.8.0") {
[13:23:07.550]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.550]                             "", base::R.version$version.string), 
[13:23:07.550]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.550]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.550]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.550]                               "release", "version")], collapse = " "), 
[13:23:07.550]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.550]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.550]                             info)
[13:23:07.550]                           info <- base::paste(info, collapse = "; ")
[13:23:07.550]                           if (!has_future) {
[13:23:07.550]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.550]                               info)
[13:23:07.550]                           }
[13:23:07.550]                           else {
[13:23:07.550]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.550]                               info, version)
[13:23:07.550]                           }
[13:23:07.550]                           base::stop(msg)
[13:23:07.550]                         }
[13:23:07.550]                       })
[13:23:07.550]                     }
[13:23:07.550]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.550]                     base::options(mc.cores = 1L)
[13:23:07.550]                   }
[13:23:07.550]                   options(future.plan = NULL)
[13:23:07.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.550]                 }
[13:23:07.550]                 ...future.workdir <- getwd()
[13:23:07.550]             }
[13:23:07.550]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.550]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.550]         }
[13:23:07.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.550]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.550]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.550]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.550]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.550]             base::names(...future.oldOptions))
[13:23:07.550]     }
[13:23:07.550]     if (FALSE) {
[13:23:07.550]     }
[13:23:07.550]     else {
[13:23:07.550]         if (TRUE) {
[13:23:07.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.550]                 open = "w")
[13:23:07.550]         }
[13:23:07.550]         else {
[13:23:07.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.550]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.550]         }
[13:23:07.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.550]             base::sink(type = "output", split = FALSE)
[13:23:07.550]             base::close(...future.stdout)
[13:23:07.550]         }, add = TRUE)
[13:23:07.550]     }
[13:23:07.550]     ...future.frame <- base::sys.nframe()
[13:23:07.550]     ...future.conditions <- base::list()
[13:23:07.550]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.550]     if (FALSE) {
[13:23:07.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.550]     }
[13:23:07.550]     ...future.result <- base::tryCatch({
[13:23:07.550]         base::withCallingHandlers({
[13:23:07.550]             ...future.value <- base::withVisible(base::local({
[13:23:07.550]                 withCallingHandlers({
[13:23:07.550]                   {
[13:23:07.550]                     4
[13:23:07.550]                   }
[13:23:07.550]                 }, immediateCondition = function(cond) {
[13:23:07.550]                   save_rds <- function (object, pathname, ...) 
[13:23:07.550]                   {
[13:23:07.550]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.550]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.550]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.550]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.550]                         fi_tmp[["mtime"]])
[13:23:07.550]                     }
[13:23:07.550]                     tryCatch({
[13:23:07.550]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.550]                     }, error = function(ex) {
[13:23:07.550]                       msg <- conditionMessage(ex)
[13:23:07.550]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.550]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.550]                         fi_tmp[["mtime"]], msg)
[13:23:07.550]                       ex$message <- msg
[13:23:07.550]                       stop(ex)
[13:23:07.550]                     })
[13:23:07.550]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.550]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.550]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.550]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.550]                       fi <- file.info(pathname)
[13:23:07.550]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.550]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.550]                         fi[["size"]], fi[["mtime"]])
[13:23:07.550]                       stop(msg)
[13:23:07.550]                     }
[13:23:07.550]                     invisible(pathname)
[13:23:07.550]                   }
[13:23:07.550]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.550]                     rootPath = tempdir()) 
[13:23:07.550]                   {
[13:23:07.550]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.550]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.550]                       tmpdir = path, fileext = ".rds")
[13:23:07.550]                     save_rds(obj, file)
[13:23:07.550]                   }
[13:23:07.550]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.550]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.550]                   {
[13:23:07.550]                     inherits <- base::inherits
[13:23:07.550]                     invokeRestart <- base::invokeRestart
[13:23:07.550]                     is.null <- base::is.null
[13:23:07.550]                     muffled <- FALSE
[13:23:07.550]                     if (inherits(cond, "message")) {
[13:23:07.550]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.550]                       if (muffled) 
[13:23:07.550]                         invokeRestart("muffleMessage")
[13:23:07.550]                     }
[13:23:07.550]                     else if (inherits(cond, "warning")) {
[13:23:07.550]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.550]                       if (muffled) 
[13:23:07.550]                         invokeRestart("muffleWarning")
[13:23:07.550]                     }
[13:23:07.550]                     else if (inherits(cond, "condition")) {
[13:23:07.550]                       if (!is.null(pattern)) {
[13:23:07.550]                         computeRestarts <- base::computeRestarts
[13:23:07.550]                         grepl <- base::grepl
[13:23:07.550]                         restarts <- computeRestarts(cond)
[13:23:07.550]                         for (restart in restarts) {
[13:23:07.550]                           name <- restart$name
[13:23:07.550]                           if (is.null(name)) 
[13:23:07.550]                             next
[13:23:07.550]                           if (!grepl(pattern, name)) 
[13:23:07.550]                             next
[13:23:07.550]                           invokeRestart(restart)
[13:23:07.550]                           muffled <- TRUE
[13:23:07.550]                           break
[13:23:07.550]                         }
[13:23:07.550]                       }
[13:23:07.550]                     }
[13:23:07.550]                     invisible(muffled)
[13:23:07.550]                   }
[13:23:07.550]                   muffleCondition(cond)
[13:23:07.550]                 })
[13:23:07.550]             }))
[13:23:07.550]             future::FutureResult(value = ...future.value$value, 
[13:23:07.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.550]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.550]                     ...future.globalenv.names))
[13:23:07.550]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.550]         }, condition = base::local({
[13:23:07.550]             c <- base::c
[13:23:07.550]             inherits <- base::inherits
[13:23:07.550]             invokeRestart <- base::invokeRestart
[13:23:07.550]             length <- base::length
[13:23:07.550]             list <- base::list
[13:23:07.550]             seq.int <- base::seq.int
[13:23:07.550]             signalCondition <- base::signalCondition
[13:23:07.550]             sys.calls <- base::sys.calls
[13:23:07.550]             `[[` <- base::`[[`
[13:23:07.550]             `+` <- base::`+`
[13:23:07.550]             `<<-` <- base::`<<-`
[13:23:07.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.550]                   3L)]
[13:23:07.550]             }
[13:23:07.550]             function(cond) {
[13:23:07.550]                 is_error <- inherits(cond, "error")
[13:23:07.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.550]                   NULL)
[13:23:07.550]                 if (is_error) {
[13:23:07.550]                   sessionInformation <- function() {
[13:23:07.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.550]                       search = base::search(), system = base::Sys.info())
[13:23:07.550]                   }
[13:23:07.550]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.550]                     cond$call), session = sessionInformation(), 
[13:23:07.550]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.550]                   signalCondition(cond)
[13:23:07.550]                 }
[13:23:07.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.550]                 "immediateCondition"))) {
[13:23:07.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.550]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.550]                   if (TRUE && !signal) {
[13:23:07.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.550]                     {
[13:23:07.550]                       inherits <- base::inherits
[13:23:07.550]                       invokeRestart <- base::invokeRestart
[13:23:07.550]                       is.null <- base::is.null
[13:23:07.550]                       muffled <- FALSE
[13:23:07.550]                       if (inherits(cond, "message")) {
[13:23:07.550]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.550]                         if (muffled) 
[13:23:07.550]                           invokeRestart("muffleMessage")
[13:23:07.550]                       }
[13:23:07.550]                       else if (inherits(cond, "warning")) {
[13:23:07.550]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.550]                         if (muffled) 
[13:23:07.550]                           invokeRestart("muffleWarning")
[13:23:07.550]                       }
[13:23:07.550]                       else if (inherits(cond, "condition")) {
[13:23:07.550]                         if (!is.null(pattern)) {
[13:23:07.550]                           computeRestarts <- base::computeRestarts
[13:23:07.550]                           grepl <- base::grepl
[13:23:07.550]                           restarts <- computeRestarts(cond)
[13:23:07.550]                           for (restart in restarts) {
[13:23:07.550]                             name <- restart$name
[13:23:07.550]                             if (is.null(name)) 
[13:23:07.550]                               next
[13:23:07.550]                             if (!grepl(pattern, name)) 
[13:23:07.550]                               next
[13:23:07.550]                             invokeRestart(restart)
[13:23:07.550]                             muffled <- TRUE
[13:23:07.550]                             break
[13:23:07.550]                           }
[13:23:07.550]                         }
[13:23:07.550]                       }
[13:23:07.550]                       invisible(muffled)
[13:23:07.550]                     }
[13:23:07.550]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.550]                   }
[13:23:07.550]                 }
[13:23:07.550]                 else {
[13:23:07.550]                   if (TRUE) {
[13:23:07.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.550]                     {
[13:23:07.550]                       inherits <- base::inherits
[13:23:07.550]                       invokeRestart <- base::invokeRestart
[13:23:07.550]                       is.null <- base::is.null
[13:23:07.550]                       muffled <- FALSE
[13:23:07.550]                       if (inherits(cond, "message")) {
[13:23:07.550]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.550]                         if (muffled) 
[13:23:07.550]                           invokeRestart("muffleMessage")
[13:23:07.550]                       }
[13:23:07.550]                       else if (inherits(cond, "warning")) {
[13:23:07.550]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.550]                         if (muffled) 
[13:23:07.550]                           invokeRestart("muffleWarning")
[13:23:07.550]                       }
[13:23:07.550]                       else if (inherits(cond, "condition")) {
[13:23:07.550]                         if (!is.null(pattern)) {
[13:23:07.550]                           computeRestarts <- base::computeRestarts
[13:23:07.550]                           grepl <- base::grepl
[13:23:07.550]                           restarts <- computeRestarts(cond)
[13:23:07.550]                           for (restart in restarts) {
[13:23:07.550]                             name <- restart$name
[13:23:07.550]                             if (is.null(name)) 
[13:23:07.550]                               next
[13:23:07.550]                             if (!grepl(pattern, name)) 
[13:23:07.550]                               next
[13:23:07.550]                             invokeRestart(restart)
[13:23:07.550]                             muffled <- TRUE
[13:23:07.550]                             break
[13:23:07.550]                           }
[13:23:07.550]                         }
[13:23:07.550]                       }
[13:23:07.550]                       invisible(muffled)
[13:23:07.550]                     }
[13:23:07.550]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.550]                   }
[13:23:07.550]                 }
[13:23:07.550]             }
[13:23:07.550]         }))
[13:23:07.550]     }, error = function(ex) {
[13:23:07.550]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.550]                 ...future.rng), started = ...future.startTime, 
[13:23:07.550]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.550]             version = "1.8"), class = "FutureResult")
[13:23:07.550]     }, finally = {
[13:23:07.550]         if (!identical(...future.workdir, getwd())) 
[13:23:07.550]             setwd(...future.workdir)
[13:23:07.550]         {
[13:23:07.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.550]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.550]             }
[13:23:07.550]             base::options(...future.oldOptions)
[13:23:07.550]             if (.Platform$OS.type == "windows") {
[13:23:07.550]                 old_names <- names(...future.oldEnvVars)
[13:23:07.550]                 envs <- base::Sys.getenv()
[13:23:07.550]                 names <- names(envs)
[13:23:07.550]                 common <- intersect(names, old_names)
[13:23:07.550]                 added <- setdiff(names, old_names)
[13:23:07.550]                 removed <- setdiff(old_names, names)
[13:23:07.550]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.550]                   envs[common]]
[13:23:07.550]                 NAMES <- toupper(changed)
[13:23:07.550]                 args <- list()
[13:23:07.550]                 for (kk in seq_along(NAMES)) {
[13:23:07.550]                   name <- changed[[kk]]
[13:23:07.550]                   NAME <- NAMES[[kk]]
[13:23:07.550]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.550]                     next
[13:23:07.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.550]                 }
[13:23:07.550]                 NAMES <- toupper(added)
[13:23:07.550]                 for (kk in seq_along(NAMES)) {
[13:23:07.550]                   name <- added[[kk]]
[13:23:07.550]                   NAME <- NAMES[[kk]]
[13:23:07.550]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.550]                     next
[13:23:07.550]                   args[[name]] <- ""
[13:23:07.550]                 }
[13:23:07.550]                 NAMES <- toupper(removed)
[13:23:07.550]                 for (kk in seq_along(NAMES)) {
[13:23:07.550]                   name <- removed[[kk]]
[13:23:07.550]                   NAME <- NAMES[[kk]]
[13:23:07.550]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.550]                     next
[13:23:07.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.550]                 }
[13:23:07.550]                 if (length(args) > 0) 
[13:23:07.550]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.550]             }
[13:23:07.550]             else {
[13:23:07.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.550]             }
[13:23:07.550]             {
[13:23:07.550]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.550]                   0L) {
[13:23:07.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.550]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.550]                   base::options(opts)
[13:23:07.550]                 }
[13:23:07.550]                 {
[13:23:07.550]                   {
[13:23:07.550]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.550]                     NULL
[13:23:07.550]                   }
[13:23:07.550]                   options(future.plan = NULL)
[13:23:07.550]                   if (is.na(NA_character_)) 
[13:23:07.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.550]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.550]                     envir = parent.frame()) 
[13:23:07.550]                   {
[13:23:07.550]                     default_workers <- missing(workers)
[13:23:07.550]                     if (is.function(workers)) 
[13:23:07.550]                       workers <- workers()
[13:23:07.550]                     workers <- structure(as.integer(workers), 
[13:23:07.550]                       class = class(workers))
[13:23:07.550]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.550]                       1L)
[13:23:07.550]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.550]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.550]                       if (default_workers) 
[13:23:07.550]                         supportsMulticore(warn = TRUE)
[13:23:07.550]                       return(sequential(..., envir = envir))
[13:23:07.550]                     }
[13:23:07.550]                     oopts <- options(mc.cores = workers)
[13:23:07.550]                     on.exit(options(oopts))
[13:23:07.550]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.550]                       envir = envir)
[13:23:07.550]                     if (!future$lazy) 
[13:23:07.550]                       future <- run(future)
[13:23:07.550]                     invisible(future)
[13:23:07.550]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.550]                 }
[13:23:07.550]             }
[13:23:07.550]         }
[13:23:07.550]     })
[13:23:07.550]     if (TRUE) {
[13:23:07.550]         base::sink(type = "output", split = FALSE)
[13:23:07.550]         if (TRUE) {
[13:23:07.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.550]         }
[13:23:07.550]         else {
[13:23:07.550]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.550]         }
[13:23:07.550]         base::close(...future.stdout)
[13:23:07.550]         ...future.stdout <- NULL
[13:23:07.550]     }
[13:23:07.550]     ...future.result$conditions <- ...future.conditions
[13:23:07.550]     ...future.result$finished <- base::Sys.time()
[13:23:07.550]     ...future.result
[13:23:07.550] }
[13:23:07.554] requestCore(): workers = 2
[13:23:07.554] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:07.571] result() for MulticoreFuture ...
[13:23:07.573] result() for MulticoreFuture ...
[13:23:07.573] result() for MulticoreFuture ... done
[13:23:07.573] result() for MulticoreFuture ... done
[13:23:07.573] result() for MulticoreFuture ...
[13:23:07.573] result() for MulticoreFuture ... done
[13:23:07.576] MulticoreFuture started
[13:23:07.577] - Launch lazy future ... done
[13:23:07.577] run() for ‘MulticoreFuture’ ... done
[13:23:07.578] plan(): Setting new future strategy stack:
<environment: 0x5596d6ed9498> 
[13:23:07.578] List of future strategies:
[13:23:07.578] 1. sequential:
[13:23:07.578]    - args: function (..., envir = parent.frame())
[13:23:07.578]    - tweaked: FALSE
[13:23:07.578]    - call: NULL
[13:23:07.579] plan(): nbrOfWorkers() = 1
<environment: 0x5596d5d91a00> 
[13:23:07.582] plan(): Setting new future strategy stack:
[13:23:07.582] List of future strategies:
[13:23:07.582] 1. multicore:
[13:23:07.582]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.582]    - tweaked: FALSE
[13:23:07.582]    - call: plan(strategy)
[13:23:07.588] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:07.590] resolve() on environment ...
[13:23:07.591]  recursive: 0
[13:23:07.591]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:07.592] signalConditionsASAP(numeric, pos=1) ...
[13:23:07.592] - nx: 4
[13:23:07.592] - relay: TRUE
[13:23:07.592] - stdout: TRUE
[13:23:07.592] - signal: TRUE
[13:23:07.592] - resignal: FALSE
[13:23:07.592] - force: TRUE
[13:23:07.593] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.593] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.593]  - until=2
[13:23:07.593]  - relaying element #2
[13:23:07.593] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:07.593] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.593] signalConditionsASAP(NULL, pos=1) ... done
[13:23:07.594]  length: 3 (resolved future 1)
[13:23:07.594] Future #2
[13:23:07.594] result() for MulticoreFuture ...
[13:23:07.594] result() for MulticoreFuture ... done
[13:23:07.594] result() for MulticoreFuture ...
[13:23:07.594] result() for MulticoreFuture ... done
[13:23:07.595] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:07.595] - nx: 4
[13:23:07.595] - relay: TRUE
[13:23:07.595] - stdout: TRUE
[13:23:07.595] - signal: TRUE
[13:23:07.595] - resignal: FALSE
[13:23:07.595] - force: TRUE
[13:23:07.596] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:07.596] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.596]  - until=2
[13:23:07.596]  - relaying element #2
[13:23:07.596] result() for MulticoreFuture ...
[13:23:07.596] result() for MulticoreFuture ... done
[13:23:07.597] result() for MulticoreFuture ...
[13:23:07.597] result() for MulticoreFuture ... done
[13:23:07.597] result() for MulticoreFuture ...
[13:23:07.597] result() for MulticoreFuture ... done
[13:23:07.597] result() for MulticoreFuture ...
[13:23:07.597] result() for MulticoreFuture ... done
[13:23:07.597] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:07.597] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:07.598] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:07.598]  length: 2 (resolved future 2)
[13:23:07.598] Future #3
[13:23:07.598] result() for MulticoreFuture ...
[13:23:07.599] result() for MulticoreFuture ...
[13:23:07.599] result() for MulticoreFuture ... done
[13:23:07.600] result() for MulticoreFuture ... done
[13:23:07.600] result() for MulticoreFuture ...
[13:23:07.600] result() for MulticoreFuture ... done
[13:23:07.600] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:07.600] - nx: 4
[13:23:07.601] - relay: TRUE
[13:23:07.601] - stdout: TRUE
[13:23:07.601] - signal: TRUE
[13:23:07.601] - resignal: FALSE
[13:23:07.601] - force: TRUE
[13:23:07.601] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:07.602] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:07.602]  - until=3
[13:23:07.602]  - relaying element #3
[13:23:07.602] result() for MulticoreFuture ...
[13:23:07.602] result() for MulticoreFuture ... done
[13:23:07.602] result() for MulticoreFuture ...
[13:23:07.603] result() for MulticoreFuture ... done
[13:23:07.603] result() for MulticoreFuture ...
[13:23:07.603] result() for MulticoreFuture ... done
[13:23:07.603] result() for MulticoreFuture ...
[13:23:07.603] result() for MulticoreFuture ... done
[13:23:07.604] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:07.604] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:07.604] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:07.604]  length: 1 (resolved future 3)
[13:23:07.605] Future #4
[13:23:07.605] result() for MulticoreFuture ...
[13:23:07.606] result() for MulticoreFuture ...
[13:23:07.606] result() for MulticoreFuture ... done
[13:23:07.606] result() for MulticoreFuture ... done
[13:23:07.606] result() for MulticoreFuture ...
[13:23:07.607] result() for MulticoreFuture ... done
[13:23:07.607] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:07.607] - nx: 4
[13:23:07.607] - relay: TRUE
[13:23:07.607] - stdout: TRUE
[13:23:07.608] - signal: TRUE
[13:23:07.608] - resignal: FALSE
[13:23:07.608] - force: TRUE
[13:23:07.608] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:07.608] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:07.608]  - until=4
[13:23:07.608]  - relaying element #4
[13:23:07.609] result() for MulticoreFuture ...
[13:23:07.609] result() for MulticoreFuture ... done
[13:23:07.609] result() for MulticoreFuture ...
[13:23:07.609] result() for MulticoreFuture ... done
[13:23:07.609] result() for MulticoreFuture ...
[13:23:07.609] result() for MulticoreFuture ... done
[13:23:07.610] result() for MulticoreFuture ...
[13:23:07.610] result() for MulticoreFuture ... done
[13:23:07.610] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.610] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:07.610] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:07.610]  length: 0 (resolved future 4)
[13:23:07.611] Relaying remaining futures
[13:23:07.611] signalConditionsASAP(NULL, pos=0) ...
[13:23:07.611] - nx: 4
[13:23:07.611] - relay: TRUE
[13:23:07.611] - stdout: TRUE
[13:23:07.611] - signal: TRUE
[13:23:07.611] - resignal: FALSE
[13:23:07.611] - force: TRUE
[13:23:07.611] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.611] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:07.612] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.612] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:07.612] signalConditionsASAP(NULL, pos=0) ... done
[13:23:07.612] resolve() on environment ... DONE
[13:23:07.612] result() for MulticoreFuture ...
[13:23:07.612] result() for MulticoreFuture ... done
[13:23:07.612] result() for MulticoreFuture ...
[13:23:07.613] result() for MulticoreFuture ... done
[13:23:07.613] result() for MulticoreFuture ...
[13:23:07.613] result() for MulticoreFuture ... done
[13:23:07.613] result() for MulticoreFuture ...
[13:23:07.613] result() for MulticoreFuture ... done
[13:23:07.613] result() for MulticoreFuture ...
[13:23:07.613] result() for MulticoreFuture ... done
[13:23:07.613] result() for MulticoreFuture ...
[13:23:07.613] result() for MulticoreFuture ... done
<environment: 0x5596d5c56510> 
Dimensions: c(1, 6)
[13:23:07.614] getGlobalsAndPackages() ...
[13:23:07.614] Searching for globals...
[13:23:07.615] 
[13:23:07.615] Searching for globals ... DONE
[13:23:07.615] - globals: [0] <none>
[13:23:07.615] getGlobalsAndPackages() ... DONE
[13:23:07.615] run() for ‘Future’ ...
[13:23:07.616] - state: ‘created’
[13:23:07.616] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.620] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.621]   - Field: ‘label’
[13:23:07.621]   - Field: ‘local’
[13:23:07.621]   - Field: ‘owner’
[13:23:07.621]   - Field: ‘envir’
[13:23:07.621]   - Field: ‘workers’
[13:23:07.621]   - Field: ‘packages’
[13:23:07.621]   - Field: ‘gc’
[13:23:07.621]   - Field: ‘job’
[13:23:07.622]   - Field: ‘conditions’
[13:23:07.622]   - Field: ‘expr’
[13:23:07.622]   - Field: ‘uuid’
[13:23:07.622]   - Field: ‘seed’
[13:23:07.622]   - Field: ‘version’
[13:23:07.622]   - Field: ‘result’
[13:23:07.622]   - Field: ‘asynchronous’
[13:23:07.622]   - Field: ‘calls’
[13:23:07.623]   - Field: ‘globals’
[13:23:07.623]   - Field: ‘stdout’
[13:23:07.623]   - Field: ‘earlySignal’
[13:23:07.623]   - Field: ‘lazy’
[13:23:07.623]   - Field: ‘state’
[13:23:07.623] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.623] - Launch lazy future ...
[13:23:07.624] Packages needed by the future expression (n = 0): <none>
[13:23:07.624] Packages needed by future strategies (n = 0): <none>
[13:23:07.625] {
[13:23:07.625]     {
[13:23:07.625]         {
[13:23:07.625]             ...future.startTime <- base::Sys.time()
[13:23:07.625]             {
[13:23:07.625]                 {
[13:23:07.625]                   {
[13:23:07.625]                     {
[13:23:07.625]                       base::local({
[13:23:07.625]                         has_future <- base::requireNamespace("future", 
[13:23:07.625]                           quietly = TRUE)
[13:23:07.625]                         if (has_future) {
[13:23:07.625]                           ns <- base::getNamespace("future")
[13:23:07.625]                           version <- ns[[".package"]][["version"]]
[13:23:07.625]                           if (is.null(version)) 
[13:23:07.625]                             version <- utils::packageVersion("future")
[13:23:07.625]                         }
[13:23:07.625]                         else {
[13:23:07.625]                           version <- NULL
[13:23:07.625]                         }
[13:23:07.625]                         if (!has_future || version < "1.8.0") {
[13:23:07.625]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.625]                             "", base::R.version$version.string), 
[13:23:07.625]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.625]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.625]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.625]                               "release", "version")], collapse = " "), 
[13:23:07.625]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.625]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.625]                             info)
[13:23:07.625]                           info <- base::paste(info, collapse = "; ")
[13:23:07.625]                           if (!has_future) {
[13:23:07.625]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.625]                               info)
[13:23:07.625]                           }
[13:23:07.625]                           else {
[13:23:07.625]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.625]                               info, version)
[13:23:07.625]                           }
[13:23:07.625]                           base::stop(msg)
[13:23:07.625]                         }
[13:23:07.625]                       })
[13:23:07.625]                     }
[13:23:07.625]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.625]                     base::options(mc.cores = 1L)
[13:23:07.625]                   }
[13:23:07.625]                   options(future.plan = NULL)
[13:23:07.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.625]                 }
[13:23:07.625]                 ...future.workdir <- getwd()
[13:23:07.625]             }
[13:23:07.625]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.625]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.625]         }
[13:23:07.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.625]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.625]             base::names(...future.oldOptions))
[13:23:07.625]     }
[13:23:07.625]     if (FALSE) {
[13:23:07.625]     }
[13:23:07.625]     else {
[13:23:07.625]         if (TRUE) {
[13:23:07.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.625]                 open = "w")
[13:23:07.625]         }
[13:23:07.625]         else {
[13:23:07.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.625]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.625]         }
[13:23:07.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.625]             base::sink(type = "output", split = FALSE)
[13:23:07.625]             base::close(...future.stdout)
[13:23:07.625]         }, add = TRUE)
[13:23:07.625]     }
[13:23:07.625]     ...future.frame <- base::sys.nframe()
[13:23:07.625]     ...future.conditions <- base::list()
[13:23:07.625]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.625]     if (FALSE) {
[13:23:07.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.625]     }
[13:23:07.625]     ...future.result <- base::tryCatch({
[13:23:07.625]         base::withCallingHandlers({
[13:23:07.625]             ...future.value <- base::withVisible(base::local({
[13:23:07.625]                 withCallingHandlers({
[13:23:07.625]                   2
[13:23:07.625]                 }, immediateCondition = function(cond) {
[13:23:07.625]                   save_rds <- function (object, pathname, ...) 
[13:23:07.625]                   {
[13:23:07.625]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.625]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.625]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.625]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.625]                         fi_tmp[["mtime"]])
[13:23:07.625]                     }
[13:23:07.625]                     tryCatch({
[13:23:07.625]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.625]                     }, error = function(ex) {
[13:23:07.625]                       msg <- conditionMessage(ex)
[13:23:07.625]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.625]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.625]                         fi_tmp[["mtime"]], msg)
[13:23:07.625]                       ex$message <- msg
[13:23:07.625]                       stop(ex)
[13:23:07.625]                     })
[13:23:07.625]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.625]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.625]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.625]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.625]                       fi <- file.info(pathname)
[13:23:07.625]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.625]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.625]                         fi[["size"]], fi[["mtime"]])
[13:23:07.625]                       stop(msg)
[13:23:07.625]                     }
[13:23:07.625]                     invisible(pathname)
[13:23:07.625]                   }
[13:23:07.625]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.625]                     rootPath = tempdir()) 
[13:23:07.625]                   {
[13:23:07.625]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.625]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.625]                       tmpdir = path, fileext = ".rds")
[13:23:07.625]                     save_rds(obj, file)
[13:23:07.625]                   }
[13:23:07.625]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.625]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.625]                   {
[13:23:07.625]                     inherits <- base::inherits
[13:23:07.625]                     invokeRestart <- base::invokeRestart
[13:23:07.625]                     is.null <- base::is.null
[13:23:07.625]                     muffled <- FALSE
[13:23:07.625]                     if (inherits(cond, "message")) {
[13:23:07.625]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.625]                       if (muffled) 
[13:23:07.625]                         invokeRestart("muffleMessage")
[13:23:07.625]                     }
[13:23:07.625]                     else if (inherits(cond, "warning")) {
[13:23:07.625]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.625]                       if (muffled) 
[13:23:07.625]                         invokeRestart("muffleWarning")
[13:23:07.625]                     }
[13:23:07.625]                     else if (inherits(cond, "condition")) {
[13:23:07.625]                       if (!is.null(pattern)) {
[13:23:07.625]                         computeRestarts <- base::computeRestarts
[13:23:07.625]                         grepl <- base::grepl
[13:23:07.625]                         restarts <- computeRestarts(cond)
[13:23:07.625]                         for (restart in restarts) {
[13:23:07.625]                           name <- restart$name
[13:23:07.625]                           if (is.null(name)) 
[13:23:07.625]                             next
[13:23:07.625]                           if (!grepl(pattern, name)) 
[13:23:07.625]                             next
[13:23:07.625]                           invokeRestart(restart)
[13:23:07.625]                           muffled <- TRUE
[13:23:07.625]                           break
[13:23:07.625]                         }
[13:23:07.625]                       }
[13:23:07.625]                     }
[13:23:07.625]                     invisible(muffled)
[13:23:07.625]                   }
[13:23:07.625]                   muffleCondition(cond)
[13:23:07.625]                 })
[13:23:07.625]             }))
[13:23:07.625]             future::FutureResult(value = ...future.value$value, 
[13:23:07.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.625]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.625]                     ...future.globalenv.names))
[13:23:07.625]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.625]         }, condition = base::local({
[13:23:07.625]             c <- base::c
[13:23:07.625]             inherits <- base::inherits
[13:23:07.625]             invokeRestart <- base::invokeRestart
[13:23:07.625]             length <- base::length
[13:23:07.625]             list <- base::list
[13:23:07.625]             seq.int <- base::seq.int
[13:23:07.625]             signalCondition <- base::signalCondition
[13:23:07.625]             sys.calls <- base::sys.calls
[13:23:07.625]             `[[` <- base::`[[`
[13:23:07.625]             `+` <- base::`+`
[13:23:07.625]             `<<-` <- base::`<<-`
[13:23:07.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.625]                   3L)]
[13:23:07.625]             }
[13:23:07.625]             function(cond) {
[13:23:07.625]                 is_error <- inherits(cond, "error")
[13:23:07.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.625]                   NULL)
[13:23:07.625]                 if (is_error) {
[13:23:07.625]                   sessionInformation <- function() {
[13:23:07.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.625]                       search = base::search(), system = base::Sys.info())
[13:23:07.625]                   }
[13:23:07.625]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.625]                     cond$call), session = sessionInformation(), 
[13:23:07.625]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.625]                   signalCondition(cond)
[13:23:07.625]                 }
[13:23:07.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.625]                 "immediateCondition"))) {
[13:23:07.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.625]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.625]                   if (TRUE && !signal) {
[13:23:07.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.625]                     {
[13:23:07.625]                       inherits <- base::inherits
[13:23:07.625]                       invokeRestart <- base::invokeRestart
[13:23:07.625]                       is.null <- base::is.null
[13:23:07.625]                       muffled <- FALSE
[13:23:07.625]                       if (inherits(cond, "message")) {
[13:23:07.625]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.625]                         if (muffled) 
[13:23:07.625]                           invokeRestart("muffleMessage")
[13:23:07.625]                       }
[13:23:07.625]                       else if (inherits(cond, "warning")) {
[13:23:07.625]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.625]                         if (muffled) 
[13:23:07.625]                           invokeRestart("muffleWarning")
[13:23:07.625]                       }
[13:23:07.625]                       else if (inherits(cond, "condition")) {
[13:23:07.625]                         if (!is.null(pattern)) {
[13:23:07.625]                           computeRestarts <- base::computeRestarts
[13:23:07.625]                           grepl <- base::grepl
[13:23:07.625]                           restarts <- computeRestarts(cond)
[13:23:07.625]                           for (restart in restarts) {
[13:23:07.625]                             name <- restart$name
[13:23:07.625]                             if (is.null(name)) 
[13:23:07.625]                               next
[13:23:07.625]                             if (!grepl(pattern, name)) 
[13:23:07.625]                               next
[13:23:07.625]                             invokeRestart(restart)
[13:23:07.625]                             muffled <- TRUE
[13:23:07.625]                             break
[13:23:07.625]                           }
[13:23:07.625]                         }
[13:23:07.625]                       }
[13:23:07.625]                       invisible(muffled)
[13:23:07.625]                     }
[13:23:07.625]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.625]                   }
[13:23:07.625]                 }
[13:23:07.625]                 else {
[13:23:07.625]                   if (TRUE) {
[13:23:07.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.625]                     {
[13:23:07.625]                       inherits <- base::inherits
[13:23:07.625]                       invokeRestart <- base::invokeRestart
[13:23:07.625]                       is.null <- base::is.null
[13:23:07.625]                       muffled <- FALSE
[13:23:07.625]                       if (inherits(cond, "message")) {
[13:23:07.625]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.625]                         if (muffled) 
[13:23:07.625]                           invokeRestart("muffleMessage")
[13:23:07.625]                       }
[13:23:07.625]                       else if (inherits(cond, "warning")) {
[13:23:07.625]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.625]                         if (muffled) 
[13:23:07.625]                           invokeRestart("muffleWarning")
[13:23:07.625]                       }
[13:23:07.625]                       else if (inherits(cond, "condition")) {
[13:23:07.625]                         if (!is.null(pattern)) {
[13:23:07.625]                           computeRestarts <- base::computeRestarts
[13:23:07.625]                           grepl <- base::grepl
[13:23:07.625]                           restarts <- computeRestarts(cond)
[13:23:07.625]                           for (restart in restarts) {
[13:23:07.625]                             name <- restart$name
[13:23:07.625]                             if (is.null(name)) 
[13:23:07.625]                               next
[13:23:07.625]                             if (!grepl(pattern, name)) 
[13:23:07.625]                               next
[13:23:07.625]                             invokeRestart(restart)
[13:23:07.625]                             muffled <- TRUE
[13:23:07.625]                             break
[13:23:07.625]                           }
[13:23:07.625]                         }
[13:23:07.625]                       }
[13:23:07.625]                       invisible(muffled)
[13:23:07.625]                     }
[13:23:07.625]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.625]                   }
[13:23:07.625]                 }
[13:23:07.625]             }
[13:23:07.625]         }))
[13:23:07.625]     }, error = function(ex) {
[13:23:07.625]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.625]                 ...future.rng), started = ...future.startTime, 
[13:23:07.625]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.625]             version = "1.8"), class = "FutureResult")
[13:23:07.625]     }, finally = {
[13:23:07.625]         if (!identical(...future.workdir, getwd())) 
[13:23:07.625]             setwd(...future.workdir)
[13:23:07.625]         {
[13:23:07.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.625]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.625]             }
[13:23:07.625]             base::options(...future.oldOptions)
[13:23:07.625]             if (.Platform$OS.type == "windows") {
[13:23:07.625]                 old_names <- names(...future.oldEnvVars)
[13:23:07.625]                 envs <- base::Sys.getenv()
[13:23:07.625]                 names <- names(envs)
[13:23:07.625]                 common <- intersect(names, old_names)
[13:23:07.625]                 added <- setdiff(names, old_names)
[13:23:07.625]                 removed <- setdiff(old_names, names)
[13:23:07.625]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.625]                   envs[common]]
[13:23:07.625]                 NAMES <- toupper(changed)
[13:23:07.625]                 args <- list()
[13:23:07.625]                 for (kk in seq_along(NAMES)) {
[13:23:07.625]                   name <- changed[[kk]]
[13:23:07.625]                   NAME <- NAMES[[kk]]
[13:23:07.625]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.625]                     next
[13:23:07.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.625]                 }
[13:23:07.625]                 NAMES <- toupper(added)
[13:23:07.625]                 for (kk in seq_along(NAMES)) {
[13:23:07.625]                   name <- added[[kk]]
[13:23:07.625]                   NAME <- NAMES[[kk]]
[13:23:07.625]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.625]                     next
[13:23:07.625]                   args[[name]] <- ""
[13:23:07.625]                 }
[13:23:07.625]                 NAMES <- toupper(removed)
[13:23:07.625]                 for (kk in seq_along(NAMES)) {
[13:23:07.625]                   name <- removed[[kk]]
[13:23:07.625]                   NAME <- NAMES[[kk]]
[13:23:07.625]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.625]                     next
[13:23:07.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.625]                 }
[13:23:07.625]                 if (length(args) > 0) 
[13:23:07.625]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.625]             }
[13:23:07.625]             else {
[13:23:07.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.625]             }
[13:23:07.625]             {
[13:23:07.625]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.625]                   0L) {
[13:23:07.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.625]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.625]                   base::options(opts)
[13:23:07.625]                 }
[13:23:07.625]                 {
[13:23:07.625]                   {
[13:23:07.625]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.625]                     NULL
[13:23:07.625]                   }
[13:23:07.625]                   options(future.plan = NULL)
[13:23:07.625]                   if (is.na(NA_character_)) 
[13:23:07.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.625]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.625]                     envir = parent.frame()) 
[13:23:07.625]                   {
[13:23:07.625]                     default_workers <- missing(workers)
[13:23:07.625]                     if (is.function(workers)) 
[13:23:07.625]                       workers <- workers()
[13:23:07.625]                     workers <- structure(as.integer(workers), 
[13:23:07.625]                       class = class(workers))
[13:23:07.625]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.625]                       1L)
[13:23:07.625]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.625]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.625]                       if (default_workers) 
[13:23:07.625]                         supportsMulticore(warn = TRUE)
[13:23:07.625]                       return(sequential(..., envir = envir))
[13:23:07.625]                     }
[13:23:07.625]                     oopts <- options(mc.cores = workers)
[13:23:07.625]                     on.exit(options(oopts))
[13:23:07.625]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.625]                       envir = envir)
[13:23:07.625]                     if (!future$lazy) 
[13:23:07.625]                       future <- run(future)
[13:23:07.625]                     invisible(future)
[13:23:07.625]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.625]                 }
[13:23:07.625]             }
[13:23:07.625]         }
[13:23:07.625]     })
[13:23:07.625]     if (TRUE) {
[13:23:07.625]         base::sink(type = "output", split = FALSE)
[13:23:07.625]         if (TRUE) {
[13:23:07.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.625]         }
[13:23:07.625]         else {
[13:23:07.625]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.625]         }
[13:23:07.625]         base::close(...future.stdout)
[13:23:07.625]         ...future.stdout <- NULL
[13:23:07.625]     }
[13:23:07.625]     ...future.result$conditions <- ...future.conditions
[13:23:07.625]     ...future.result$finished <- base::Sys.time()
[13:23:07.625]     ...future.result
[13:23:07.625] }
[13:23:07.628] requestCore(): workers = 2
[13:23:07.630] MulticoreFuture started
[13:23:07.631] - Launch lazy future ... done
[13:23:07.631] run() for ‘MulticoreFuture’ ... done
[13:23:07.631] getGlobalsAndPackages() ...
[13:23:07.632] Searching for globals...
[13:23:07.632] plan(): Setting new future strategy stack:
[13:23:07.633] 
[13:23:07.633] Searching for globals ... DONE
[13:23:07.632] List of future strategies:
[13:23:07.632] 1. sequential:
[13:23:07.632]    - args: function (..., envir = parent.frame())
[13:23:07.632]    - tweaked: FALSE
[13:23:07.632]    - call: NULL
[13:23:07.633] - globals: [0] <none>
[13:23:07.633] getGlobalsAndPackages() ... DONE
[13:23:07.633] plan(): nbrOfWorkers() = 1
[13:23:07.634] run() for ‘Future’ ...
[13:23:07.634] - state: ‘created’
[13:23:07.634] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.635] plan(): Setting new future strategy stack:
[13:23:07.635] List of future strategies:
[13:23:07.635] 1. multicore:
[13:23:07.635]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.635]    - tweaked: FALSE
[13:23:07.635]    - call: plan(strategy)
[13:23:07.640] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.640] plan(): nbrOfWorkers() = 2
[13:23:07.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.640]   - Field: ‘label’
[13:23:07.641]   - Field: ‘local’
[13:23:07.641]   - Field: ‘owner’
[13:23:07.641]   - Field: ‘envir’
[13:23:07.641]   - Field: ‘workers’
[13:23:07.641]   - Field: ‘packages’
[13:23:07.641]   - Field: ‘gc’
[13:23:07.642]   - Field: ‘job’
[13:23:07.642]   - Field: ‘conditions’
[13:23:07.642]   - Field: ‘expr’
[13:23:07.642]   - Field: ‘uuid’
[13:23:07.642]   - Field: ‘seed’
[13:23:07.642]   - Field: ‘version’
[13:23:07.643]   - Field: ‘result’
[13:23:07.643]   - Field: ‘asynchronous’
[13:23:07.643]   - Field: ‘calls’
[13:23:07.643]   - Field: ‘globals’
[13:23:07.643]   - Field: ‘stdout’
[13:23:07.643]   - Field: ‘earlySignal’
[13:23:07.643]   - Field: ‘lazy’
[13:23:07.644]   - Field: ‘state’
[13:23:07.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.644] - Launch lazy future ...
[13:23:07.645] Packages needed by the future expression (n = 0): <none>
[13:23:07.645] Packages needed by future strategies (n = 0): <none>
[13:23:07.646] {
[13:23:07.646]     {
[13:23:07.646]         {
[13:23:07.646]             ...future.startTime <- base::Sys.time()
[13:23:07.646]             {
[13:23:07.646]                 {
[13:23:07.646]                   {
[13:23:07.646]                     {
[13:23:07.646]                       base::local({
[13:23:07.646]                         has_future <- base::requireNamespace("future", 
[13:23:07.646]                           quietly = TRUE)
[13:23:07.646]                         if (has_future) {
[13:23:07.646]                           ns <- base::getNamespace("future")
[13:23:07.646]                           version <- ns[[".package"]][["version"]]
[13:23:07.646]                           if (is.null(version)) 
[13:23:07.646]                             version <- utils::packageVersion("future")
[13:23:07.646]                         }
[13:23:07.646]                         else {
[13:23:07.646]                           version <- NULL
[13:23:07.646]                         }
[13:23:07.646]                         if (!has_future || version < "1.8.0") {
[13:23:07.646]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.646]                             "", base::R.version$version.string), 
[13:23:07.646]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.646]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.646]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.646]                               "release", "version")], collapse = " "), 
[13:23:07.646]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.646]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.646]                             info)
[13:23:07.646]                           info <- base::paste(info, collapse = "; ")
[13:23:07.646]                           if (!has_future) {
[13:23:07.646]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.646]                               info)
[13:23:07.646]                           }
[13:23:07.646]                           else {
[13:23:07.646]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.646]                               info, version)
[13:23:07.646]                           }
[13:23:07.646]                           base::stop(msg)
[13:23:07.646]                         }
[13:23:07.646]                       })
[13:23:07.646]                     }
[13:23:07.646]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.646]                     base::options(mc.cores = 1L)
[13:23:07.646]                   }
[13:23:07.646]                   options(future.plan = NULL)
[13:23:07.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.646]                 }
[13:23:07.646]                 ...future.workdir <- getwd()
[13:23:07.646]             }
[13:23:07.646]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.646]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.646]         }
[13:23:07.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.646]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.646]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.646]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.646]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.646]             base::names(...future.oldOptions))
[13:23:07.646]     }
[13:23:07.646]     if (FALSE) {
[13:23:07.646]     }
[13:23:07.646]     else {
[13:23:07.646]         if (TRUE) {
[13:23:07.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.646]                 open = "w")
[13:23:07.646]         }
[13:23:07.646]         else {
[13:23:07.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.646]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.646]         }
[13:23:07.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.646]             base::sink(type = "output", split = FALSE)
[13:23:07.646]             base::close(...future.stdout)
[13:23:07.646]         }, add = TRUE)
[13:23:07.646]     }
[13:23:07.646]     ...future.frame <- base::sys.nframe()
[13:23:07.646]     ...future.conditions <- base::list()
[13:23:07.646]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.646]     if (FALSE) {
[13:23:07.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.646]     }
[13:23:07.646]     ...future.result <- base::tryCatch({
[13:23:07.646]         base::withCallingHandlers({
[13:23:07.646]             ...future.value <- base::withVisible(base::local({
[13:23:07.646]                 withCallingHandlers({
[13:23:07.646]                   NULL
[13:23:07.646]                 }, immediateCondition = function(cond) {
[13:23:07.646]                   save_rds <- function (object, pathname, ...) 
[13:23:07.646]                   {
[13:23:07.646]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.646]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.646]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.646]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.646]                         fi_tmp[["mtime"]])
[13:23:07.646]                     }
[13:23:07.646]                     tryCatch({
[13:23:07.646]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.646]                     }, error = function(ex) {
[13:23:07.646]                       msg <- conditionMessage(ex)
[13:23:07.646]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.646]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.646]                         fi_tmp[["mtime"]], msg)
[13:23:07.646]                       ex$message <- msg
[13:23:07.646]                       stop(ex)
[13:23:07.646]                     })
[13:23:07.646]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.646]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.646]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.646]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.646]                       fi <- file.info(pathname)
[13:23:07.646]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.646]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.646]                         fi[["size"]], fi[["mtime"]])
[13:23:07.646]                       stop(msg)
[13:23:07.646]                     }
[13:23:07.646]                     invisible(pathname)
[13:23:07.646]                   }
[13:23:07.646]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.646]                     rootPath = tempdir()) 
[13:23:07.646]                   {
[13:23:07.646]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.646]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.646]                       tmpdir = path, fileext = ".rds")
[13:23:07.646]                     save_rds(obj, file)
[13:23:07.646]                   }
[13:23:07.646]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.646]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.646]                   {
[13:23:07.646]                     inherits <- base::inherits
[13:23:07.646]                     invokeRestart <- base::invokeRestart
[13:23:07.646]                     is.null <- base::is.null
[13:23:07.646]                     muffled <- FALSE
[13:23:07.646]                     if (inherits(cond, "message")) {
[13:23:07.646]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.646]                       if (muffled) 
[13:23:07.646]                         invokeRestart("muffleMessage")
[13:23:07.646]                     }
[13:23:07.646]                     else if (inherits(cond, "warning")) {
[13:23:07.646]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.646]                       if (muffled) 
[13:23:07.646]                         invokeRestart("muffleWarning")
[13:23:07.646]                     }
[13:23:07.646]                     else if (inherits(cond, "condition")) {
[13:23:07.646]                       if (!is.null(pattern)) {
[13:23:07.646]                         computeRestarts <- base::computeRestarts
[13:23:07.646]                         grepl <- base::grepl
[13:23:07.646]                         restarts <- computeRestarts(cond)
[13:23:07.646]                         for (restart in restarts) {
[13:23:07.646]                           name <- restart$name
[13:23:07.646]                           if (is.null(name)) 
[13:23:07.646]                             next
[13:23:07.646]                           if (!grepl(pattern, name)) 
[13:23:07.646]                             next
[13:23:07.646]                           invokeRestart(restart)
[13:23:07.646]                           muffled <- TRUE
[13:23:07.646]                           break
[13:23:07.646]                         }
[13:23:07.646]                       }
[13:23:07.646]                     }
[13:23:07.646]                     invisible(muffled)
[13:23:07.646]                   }
[13:23:07.646]                   muffleCondition(cond)
[13:23:07.646]                 })
[13:23:07.646]             }))
[13:23:07.646]             future::FutureResult(value = ...future.value$value, 
[13:23:07.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.646]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.646]                     ...future.globalenv.names))
[13:23:07.646]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.646]         }, condition = base::local({
[13:23:07.646]             c <- base::c
[13:23:07.646]             inherits <- base::inherits
[13:23:07.646]             invokeRestart <- base::invokeRestart
[13:23:07.646]             length <- base::length
[13:23:07.646]             list <- base::list
[13:23:07.646]             seq.int <- base::seq.int
[13:23:07.646]             signalCondition <- base::signalCondition
[13:23:07.646]             sys.calls <- base::sys.calls
[13:23:07.646]             `[[` <- base::`[[`
[13:23:07.646]             `+` <- base::`+`
[13:23:07.646]             `<<-` <- base::`<<-`
[13:23:07.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.646]                   3L)]
[13:23:07.646]             }
[13:23:07.646]             function(cond) {
[13:23:07.646]                 is_error <- inherits(cond, "error")
[13:23:07.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.646]                   NULL)
[13:23:07.646]                 if (is_error) {
[13:23:07.646]                   sessionInformation <- function() {
[13:23:07.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.646]                       search = base::search(), system = base::Sys.info())
[13:23:07.646]                   }
[13:23:07.646]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.646]                     cond$call), session = sessionInformation(), 
[13:23:07.646]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.646]                   signalCondition(cond)
[13:23:07.646]                 }
[13:23:07.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.646]                 "immediateCondition"))) {
[13:23:07.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.646]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.646]                   if (TRUE && !signal) {
[13:23:07.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.646]                     {
[13:23:07.646]                       inherits <- base::inherits
[13:23:07.646]                       invokeRestart <- base::invokeRestart
[13:23:07.646]                       is.null <- base::is.null
[13:23:07.646]                       muffled <- FALSE
[13:23:07.646]                       if (inherits(cond, "message")) {
[13:23:07.646]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.646]                         if (muffled) 
[13:23:07.646]                           invokeRestart("muffleMessage")
[13:23:07.646]                       }
[13:23:07.646]                       else if (inherits(cond, "warning")) {
[13:23:07.646]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.646]                         if (muffled) 
[13:23:07.646]                           invokeRestart("muffleWarning")
[13:23:07.646]                       }
[13:23:07.646]                       else if (inherits(cond, "condition")) {
[13:23:07.646]                         if (!is.null(pattern)) {
[13:23:07.646]                           computeRestarts <- base::computeRestarts
[13:23:07.646]                           grepl <- base::grepl
[13:23:07.646]                           restarts <- computeRestarts(cond)
[13:23:07.646]                           for (restart in restarts) {
[13:23:07.646]                             name <- restart$name
[13:23:07.646]                             if (is.null(name)) 
[13:23:07.646]                               next
[13:23:07.646]                             if (!grepl(pattern, name)) 
[13:23:07.646]                               next
[13:23:07.646]                             invokeRestart(restart)
[13:23:07.646]                             muffled <- TRUE
[13:23:07.646]                             break
[13:23:07.646]                           }
[13:23:07.646]                         }
[13:23:07.646]                       }
[13:23:07.646]                       invisible(muffled)
[13:23:07.646]                     }
[13:23:07.646]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.646]                   }
[13:23:07.646]                 }
[13:23:07.646]                 else {
[13:23:07.646]                   if (TRUE) {
[13:23:07.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.646]                     {
[13:23:07.646]                       inherits <- base::inherits
[13:23:07.646]                       invokeRestart <- base::invokeRestart
[13:23:07.646]                       is.null <- base::is.null
[13:23:07.646]                       muffled <- FALSE
[13:23:07.646]                       if (inherits(cond, "message")) {
[13:23:07.646]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.646]                         if (muffled) 
[13:23:07.646]                           invokeRestart("muffleMessage")
[13:23:07.646]                       }
[13:23:07.646]                       else if (inherits(cond, "warning")) {
[13:23:07.646]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.646]                         if (muffled) 
[13:23:07.646]                           invokeRestart("muffleWarning")
[13:23:07.646]                       }
[13:23:07.646]                       else if (inherits(cond, "condition")) {
[13:23:07.646]                         if (!is.null(pattern)) {
[13:23:07.646]                           computeRestarts <- base::computeRestarts
[13:23:07.646]                           grepl <- base::grepl
[13:23:07.646]                           restarts <- computeRestarts(cond)
[13:23:07.646]                           for (restart in restarts) {
[13:23:07.646]                             name <- restart$name
[13:23:07.646]                             if (is.null(name)) 
[13:23:07.646]                               next
[13:23:07.646]                             if (!grepl(pattern, name)) 
[13:23:07.646]                               next
[13:23:07.646]                             invokeRestart(restart)
[13:23:07.646]                             muffled <- TRUE
[13:23:07.646]                             break
[13:23:07.646]                           }
[13:23:07.646]                         }
[13:23:07.646]                       }
[13:23:07.646]                       invisible(muffled)
[13:23:07.646]                     }
[13:23:07.646]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.646]                   }
[13:23:07.646]                 }
[13:23:07.646]             }
[13:23:07.646]         }))
[13:23:07.646]     }, error = function(ex) {
[13:23:07.646]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.646]                 ...future.rng), started = ...future.startTime, 
[13:23:07.646]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.646]             version = "1.8"), class = "FutureResult")
[13:23:07.646]     }, finally = {
[13:23:07.646]         if (!identical(...future.workdir, getwd())) 
[13:23:07.646]             setwd(...future.workdir)
[13:23:07.646]         {
[13:23:07.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.646]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.646]             }
[13:23:07.646]             base::options(...future.oldOptions)
[13:23:07.646]             if (.Platform$OS.type == "windows") {
[13:23:07.646]                 old_names <- names(...future.oldEnvVars)
[13:23:07.646]                 envs <- base::Sys.getenv()
[13:23:07.646]                 names <- names(envs)
[13:23:07.646]                 common <- intersect(names, old_names)
[13:23:07.646]                 added <- setdiff(names, old_names)
[13:23:07.646]                 removed <- setdiff(old_names, names)
[13:23:07.646]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.646]                   envs[common]]
[13:23:07.646]                 NAMES <- toupper(changed)
[13:23:07.646]                 args <- list()
[13:23:07.646]                 for (kk in seq_along(NAMES)) {
[13:23:07.646]                   name <- changed[[kk]]
[13:23:07.646]                   NAME <- NAMES[[kk]]
[13:23:07.646]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.646]                     next
[13:23:07.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.646]                 }
[13:23:07.646]                 NAMES <- toupper(added)
[13:23:07.646]                 for (kk in seq_along(NAMES)) {
[13:23:07.646]                   name <- added[[kk]]
[13:23:07.646]                   NAME <- NAMES[[kk]]
[13:23:07.646]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.646]                     next
[13:23:07.646]                   args[[name]] <- ""
[13:23:07.646]                 }
[13:23:07.646]                 NAMES <- toupper(removed)
[13:23:07.646]                 for (kk in seq_along(NAMES)) {
[13:23:07.646]                   name <- removed[[kk]]
[13:23:07.646]                   NAME <- NAMES[[kk]]
[13:23:07.646]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.646]                     next
[13:23:07.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.646]                 }
[13:23:07.646]                 if (length(args) > 0) 
[13:23:07.646]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.646]             }
[13:23:07.646]             else {
[13:23:07.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.646]             }
[13:23:07.646]             {
[13:23:07.646]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.646]                   0L) {
[13:23:07.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.646]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.646]                   base::options(opts)
[13:23:07.646]                 }
[13:23:07.646]                 {
[13:23:07.646]                   {
[13:23:07.646]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.646]                     NULL
[13:23:07.646]                   }
[13:23:07.646]                   options(future.plan = NULL)
[13:23:07.646]                   if (is.na(NA_character_)) 
[13:23:07.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.646]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.646]                     envir = parent.frame()) 
[13:23:07.646]                   {
[13:23:07.646]                     default_workers <- missing(workers)
[13:23:07.646]                     if (is.function(workers)) 
[13:23:07.646]                       workers <- workers()
[13:23:07.646]                     workers <- structure(as.integer(workers), 
[13:23:07.646]                       class = class(workers))
[13:23:07.646]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.646]                       1L)
[13:23:07.646]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.646]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.646]                       if (default_workers) 
[13:23:07.646]                         supportsMulticore(warn = TRUE)
[13:23:07.646]                       return(sequential(..., envir = envir))
[13:23:07.646]                     }
[13:23:07.646]                     oopts <- options(mc.cores = workers)
[13:23:07.646]                     on.exit(options(oopts))
[13:23:07.646]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.646]                       envir = envir)
[13:23:07.646]                     if (!future$lazy) 
[13:23:07.646]                       future <- run(future)
[13:23:07.646]                     invisible(future)
[13:23:07.646]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.646]                 }
[13:23:07.646]             }
[13:23:07.646]         }
[13:23:07.646]     })
[13:23:07.646]     if (TRUE) {
[13:23:07.646]         base::sink(type = "output", split = FALSE)
[13:23:07.646]         if (TRUE) {
[13:23:07.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.646]         }
[13:23:07.646]         else {
[13:23:07.646]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.646]         }
[13:23:07.646]         base::close(...future.stdout)
[13:23:07.646]         ...future.stdout <- NULL
[13:23:07.646]     }
[13:23:07.646]     ...future.result$conditions <- ...future.conditions
[13:23:07.646]     ...future.result$finished <- base::Sys.time()
[13:23:07.646]     ...future.result
[13:23:07.646] }
[13:23:07.650] requestCore(): workers = 2
[13:23:07.653] MulticoreFuture started
[13:23:07.653] - Launch lazy future ... done
[13:23:07.654] run() for ‘MulticoreFuture’ ... done
[13:23:07.654] plan(): Setting new future strategy stack:
[13:23:07.654] getGlobalsAndPackages() ...
[13:23:07.655] Searching for globals...
[13:23:07.654] List of future strategies:
[13:23:07.654] 1. sequential:
[13:23:07.654]    - args: function (..., envir = parent.frame())
[13:23:07.654]    - tweaked: FALSE
[13:23:07.654]    - call: NULL
[13:23:07.655] plan(): nbrOfWorkers() = 1
[13:23:07.656] - globals found: [1] ‘{’
[13:23:07.656] Searching for globals ... DONE
[13:23:07.656] Resolving globals: FALSE
[13:23:07.657] 
[13:23:07.657] 
[13:23:07.657] getGlobalsAndPackages() ... DONE
[13:23:07.657] plan(): Setting new future strategy stack:
[13:23:07.658] run() for ‘Future’ ...
[13:23:07.658] - state: ‘created’
[13:23:07.658] List of future strategies:
[13:23:07.658] 1. multicore:
[13:23:07.658]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.658]    - tweaked: FALSE
[13:23:07.658]    - call: plan(strategy)
[13:23:07.658] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.663] plan(): nbrOfWorkers() = 2
[13:23:07.663] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.664]   - Field: ‘label’
[13:23:07.664]   - Field: ‘local’
[13:23:07.664]   - Field: ‘owner’
[13:23:07.664]   - Field: ‘envir’
[13:23:07.664]   - Field: ‘workers’
[13:23:07.664]   - Field: ‘packages’
[13:23:07.664]   - Field: ‘gc’
[13:23:07.665]   - Field: ‘job’
[13:23:07.665]   - Field: ‘conditions’
[13:23:07.665]   - Field: ‘expr’
[13:23:07.665]   - Field: ‘uuid’
[13:23:07.665]   - Field: ‘seed’
[13:23:07.665]   - Field: ‘version’
[13:23:07.665]   - Field: ‘result’
[13:23:07.666]   - Field: ‘asynchronous’
[13:23:07.666]   - Field: ‘calls’
[13:23:07.666]   - Field: ‘globals’
[13:23:07.666]   - Field: ‘stdout’
[13:23:07.666]   - Field: ‘earlySignal’
[13:23:07.666]   - Field: ‘lazy’
[13:23:07.666]   - Field: ‘state’
[13:23:07.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.667] - Launch lazy future ...
[13:23:07.667] Packages needed by the future expression (n = 0): <none>
[13:23:07.667] Packages needed by future strategies (n = 0): <none>
[13:23:07.668] {
[13:23:07.668]     {
[13:23:07.668]         {
[13:23:07.668]             ...future.startTime <- base::Sys.time()
[13:23:07.668]             {
[13:23:07.668]                 {
[13:23:07.668]                   {
[13:23:07.668]                     {
[13:23:07.668]                       base::local({
[13:23:07.668]                         has_future <- base::requireNamespace("future", 
[13:23:07.668]                           quietly = TRUE)
[13:23:07.668]                         if (has_future) {
[13:23:07.668]                           ns <- base::getNamespace("future")
[13:23:07.668]                           version <- ns[[".package"]][["version"]]
[13:23:07.668]                           if (is.null(version)) 
[13:23:07.668]                             version <- utils::packageVersion("future")
[13:23:07.668]                         }
[13:23:07.668]                         else {
[13:23:07.668]                           version <- NULL
[13:23:07.668]                         }
[13:23:07.668]                         if (!has_future || version < "1.8.0") {
[13:23:07.668]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.668]                             "", base::R.version$version.string), 
[13:23:07.668]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.668]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.668]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.668]                               "release", "version")], collapse = " "), 
[13:23:07.668]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.668]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.668]                             info)
[13:23:07.668]                           info <- base::paste(info, collapse = "; ")
[13:23:07.668]                           if (!has_future) {
[13:23:07.668]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.668]                               info)
[13:23:07.668]                           }
[13:23:07.668]                           else {
[13:23:07.668]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.668]                               info, version)
[13:23:07.668]                           }
[13:23:07.668]                           base::stop(msg)
[13:23:07.668]                         }
[13:23:07.668]                       })
[13:23:07.668]                     }
[13:23:07.668]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.668]                     base::options(mc.cores = 1L)
[13:23:07.668]                   }
[13:23:07.668]                   options(future.plan = NULL)
[13:23:07.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.668]                 }
[13:23:07.668]                 ...future.workdir <- getwd()
[13:23:07.668]             }
[13:23:07.668]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.668]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.668]         }
[13:23:07.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.668]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.668]             base::names(...future.oldOptions))
[13:23:07.668]     }
[13:23:07.668]     if (FALSE) {
[13:23:07.668]     }
[13:23:07.668]     else {
[13:23:07.668]         if (TRUE) {
[13:23:07.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.668]                 open = "w")
[13:23:07.668]         }
[13:23:07.668]         else {
[13:23:07.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.668]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.668]         }
[13:23:07.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.668]             base::sink(type = "output", split = FALSE)
[13:23:07.668]             base::close(...future.stdout)
[13:23:07.668]         }, add = TRUE)
[13:23:07.668]     }
[13:23:07.668]     ...future.frame <- base::sys.nframe()
[13:23:07.668]     ...future.conditions <- base::list()
[13:23:07.668]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.668]     if (FALSE) {
[13:23:07.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.668]     }
[13:23:07.668]     ...future.result <- base::tryCatch({
[13:23:07.668]         base::withCallingHandlers({
[13:23:07.668]             ...future.value <- base::withVisible(base::local({
[13:23:07.668]                 withCallingHandlers({
[13:23:07.668]                   {
[13:23:07.668]                     4
[13:23:07.668]                   }
[13:23:07.668]                 }, immediateCondition = function(cond) {
[13:23:07.668]                   save_rds <- function (object, pathname, ...) 
[13:23:07.668]                   {
[13:23:07.668]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.668]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.668]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.668]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.668]                         fi_tmp[["mtime"]])
[13:23:07.668]                     }
[13:23:07.668]                     tryCatch({
[13:23:07.668]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.668]                     }, error = function(ex) {
[13:23:07.668]                       msg <- conditionMessage(ex)
[13:23:07.668]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.668]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.668]                         fi_tmp[["mtime"]], msg)
[13:23:07.668]                       ex$message <- msg
[13:23:07.668]                       stop(ex)
[13:23:07.668]                     })
[13:23:07.668]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.668]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.668]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.668]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.668]                       fi <- file.info(pathname)
[13:23:07.668]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.668]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.668]                         fi[["size"]], fi[["mtime"]])
[13:23:07.668]                       stop(msg)
[13:23:07.668]                     }
[13:23:07.668]                     invisible(pathname)
[13:23:07.668]                   }
[13:23:07.668]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.668]                     rootPath = tempdir()) 
[13:23:07.668]                   {
[13:23:07.668]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.668]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.668]                       tmpdir = path, fileext = ".rds")
[13:23:07.668]                     save_rds(obj, file)
[13:23:07.668]                   }
[13:23:07.668]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.668]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.668]                   {
[13:23:07.668]                     inherits <- base::inherits
[13:23:07.668]                     invokeRestart <- base::invokeRestart
[13:23:07.668]                     is.null <- base::is.null
[13:23:07.668]                     muffled <- FALSE
[13:23:07.668]                     if (inherits(cond, "message")) {
[13:23:07.668]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.668]                       if (muffled) 
[13:23:07.668]                         invokeRestart("muffleMessage")
[13:23:07.668]                     }
[13:23:07.668]                     else if (inherits(cond, "warning")) {
[13:23:07.668]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.668]                       if (muffled) 
[13:23:07.668]                         invokeRestart("muffleWarning")
[13:23:07.668]                     }
[13:23:07.668]                     else if (inherits(cond, "condition")) {
[13:23:07.668]                       if (!is.null(pattern)) {
[13:23:07.668]                         computeRestarts <- base::computeRestarts
[13:23:07.668]                         grepl <- base::grepl
[13:23:07.668]                         restarts <- computeRestarts(cond)
[13:23:07.668]                         for (restart in restarts) {
[13:23:07.668]                           name <- restart$name
[13:23:07.668]                           if (is.null(name)) 
[13:23:07.668]                             next
[13:23:07.668]                           if (!grepl(pattern, name)) 
[13:23:07.668]                             next
[13:23:07.668]                           invokeRestart(restart)
[13:23:07.668]                           muffled <- TRUE
[13:23:07.668]                           break
[13:23:07.668]                         }
[13:23:07.668]                       }
[13:23:07.668]                     }
[13:23:07.668]                     invisible(muffled)
[13:23:07.668]                   }
[13:23:07.668]                   muffleCondition(cond)
[13:23:07.668]                 })
[13:23:07.668]             }))
[13:23:07.668]             future::FutureResult(value = ...future.value$value, 
[13:23:07.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.668]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.668]                     ...future.globalenv.names))
[13:23:07.668]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.668]         }, condition = base::local({
[13:23:07.668]             c <- base::c
[13:23:07.668]             inherits <- base::inherits
[13:23:07.668]             invokeRestart <- base::invokeRestart
[13:23:07.668]             length <- base::length
[13:23:07.668]             list <- base::list
[13:23:07.668]             seq.int <- base::seq.int
[13:23:07.668]             signalCondition <- base::signalCondition
[13:23:07.668]             sys.calls <- base::sys.calls
[13:23:07.668]             `[[` <- base::`[[`
[13:23:07.668]             `+` <- base::`+`
[13:23:07.668]             `<<-` <- base::`<<-`
[13:23:07.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.668]                   3L)]
[13:23:07.668]             }
[13:23:07.668]             function(cond) {
[13:23:07.668]                 is_error <- inherits(cond, "error")
[13:23:07.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.668]                   NULL)
[13:23:07.668]                 if (is_error) {
[13:23:07.668]                   sessionInformation <- function() {
[13:23:07.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.668]                       search = base::search(), system = base::Sys.info())
[13:23:07.668]                   }
[13:23:07.668]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.668]                     cond$call), session = sessionInformation(), 
[13:23:07.668]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.668]                   signalCondition(cond)
[13:23:07.668]                 }
[13:23:07.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.668]                 "immediateCondition"))) {
[13:23:07.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.668]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.668]                   if (TRUE && !signal) {
[13:23:07.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.668]                     {
[13:23:07.668]                       inherits <- base::inherits
[13:23:07.668]                       invokeRestart <- base::invokeRestart
[13:23:07.668]                       is.null <- base::is.null
[13:23:07.668]                       muffled <- FALSE
[13:23:07.668]                       if (inherits(cond, "message")) {
[13:23:07.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.668]                         if (muffled) 
[13:23:07.668]                           invokeRestart("muffleMessage")
[13:23:07.668]                       }
[13:23:07.668]                       else if (inherits(cond, "warning")) {
[13:23:07.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.668]                         if (muffled) 
[13:23:07.668]                           invokeRestart("muffleWarning")
[13:23:07.668]                       }
[13:23:07.668]                       else if (inherits(cond, "condition")) {
[13:23:07.668]                         if (!is.null(pattern)) {
[13:23:07.668]                           computeRestarts <- base::computeRestarts
[13:23:07.668]                           grepl <- base::grepl
[13:23:07.668]                           restarts <- computeRestarts(cond)
[13:23:07.668]                           for (restart in restarts) {
[13:23:07.668]                             name <- restart$name
[13:23:07.668]                             if (is.null(name)) 
[13:23:07.668]                               next
[13:23:07.668]                             if (!grepl(pattern, name)) 
[13:23:07.668]                               next
[13:23:07.668]                             invokeRestart(restart)
[13:23:07.668]                             muffled <- TRUE
[13:23:07.668]                             break
[13:23:07.668]                           }
[13:23:07.668]                         }
[13:23:07.668]                       }
[13:23:07.668]                       invisible(muffled)
[13:23:07.668]                     }
[13:23:07.668]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.668]                   }
[13:23:07.668]                 }
[13:23:07.668]                 else {
[13:23:07.668]                   if (TRUE) {
[13:23:07.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.668]                     {
[13:23:07.668]                       inherits <- base::inherits
[13:23:07.668]                       invokeRestart <- base::invokeRestart
[13:23:07.668]                       is.null <- base::is.null
[13:23:07.668]                       muffled <- FALSE
[13:23:07.668]                       if (inherits(cond, "message")) {
[13:23:07.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.668]                         if (muffled) 
[13:23:07.668]                           invokeRestart("muffleMessage")
[13:23:07.668]                       }
[13:23:07.668]                       else if (inherits(cond, "warning")) {
[13:23:07.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.668]                         if (muffled) 
[13:23:07.668]                           invokeRestart("muffleWarning")
[13:23:07.668]                       }
[13:23:07.668]                       else if (inherits(cond, "condition")) {
[13:23:07.668]                         if (!is.null(pattern)) {
[13:23:07.668]                           computeRestarts <- base::computeRestarts
[13:23:07.668]                           grepl <- base::grepl
[13:23:07.668]                           restarts <- computeRestarts(cond)
[13:23:07.668]                           for (restart in restarts) {
[13:23:07.668]                             name <- restart$name
[13:23:07.668]                             if (is.null(name)) 
[13:23:07.668]                               next
[13:23:07.668]                             if (!grepl(pattern, name)) 
[13:23:07.668]                               next
[13:23:07.668]                             invokeRestart(restart)
[13:23:07.668]                             muffled <- TRUE
[13:23:07.668]                             break
[13:23:07.668]                           }
[13:23:07.668]                         }
[13:23:07.668]                       }
[13:23:07.668]                       invisible(muffled)
[13:23:07.668]                     }
[13:23:07.668]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.668]                   }
[13:23:07.668]                 }
[13:23:07.668]             }
[13:23:07.668]         }))
[13:23:07.668]     }, error = function(ex) {
[13:23:07.668]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.668]                 ...future.rng), started = ...future.startTime, 
[13:23:07.668]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.668]             version = "1.8"), class = "FutureResult")
[13:23:07.668]     }, finally = {
[13:23:07.668]         if (!identical(...future.workdir, getwd())) 
[13:23:07.668]             setwd(...future.workdir)
[13:23:07.668]         {
[13:23:07.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.668]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.668]             }
[13:23:07.668]             base::options(...future.oldOptions)
[13:23:07.668]             if (.Platform$OS.type == "windows") {
[13:23:07.668]                 old_names <- names(...future.oldEnvVars)
[13:23:07.668]                 envs <- base::Sys.getenv()
[13:23:07.668]                 names <- names(envs)
[13:23:07.668]                 common <- intersect(names, old_names)
[13:23:07.668]                 added <- setdiff(names, old_names)
[13:23:07.668]                 removed <- setdiff(old_names, names)
[13:23:07.668]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.668]                   envs[common]]
[13:23:07.668]                 NAMES <- toupper(changed)
[13:23:07.668]                 args <- list()
[13:23:07.668]                 for (kk in seq_along(NAMES)) {
[13:23:07.668]                   name <- changed[[kk]]
[13:23:07.668]                   NAME <- NAMES[[kk]]
[13:23:07.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.668]                     next
[13:23:07.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.668]                 }
[13:23:07.668]                 NAMES <- toupper(added)
[13:23:07.668]                 for (kk in seq_along(NAMES)) {
[13:23:07.668]                   name <- added[[kk]]
[13:23:07.668]                   NAME <- NAMES[[kk]]
[13:23:07.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.668]                     next
[13:23:07.668]                   args[[name]] <- ""
[13:23:07.668]                 }
[13:23:07.668]                 NAMES <- toupper(removed)
[13:23:07.668]                 for (kk in seq_along(NAMES)) {
[13:23:07.668]                   name <- removed[[kk]]
[13:23:07.668]                   NAME <- NAMES[[kk]]
[13:23:07.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.668]                     next
[13:23:07.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.668]                 }
[13:23:07.668]                 if (length(args) > 0) 
[13:23:07.668]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.668]             }
[13:23:07.668]             else {
[13:23:07.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.668]             }
[13:23:07.668]             {
[13:23:07.668]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.668]                   0L) {
[13:23:07.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.668]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.668]                   base::options(opts)
[13:23:07.668]                 }
[13:23:07.668]                 {
[13:23:07.668]                   {
[13:23:07.668]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.668]                     NULL
[13:23:07.668]                   }
[13:23:07.668]                   options(future.plan = NULL)
[13:23:07.668]                   if (is.na(NA_character_)) 
[13:23:07.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.668]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.668]                     envir = parent.frame()) 
[13:23:07.668]                   {
[13:23:07.668]                     default_workers <- missing(workers)
[13:23:07.668]                     if (is.function(workers)) 
[13:23:07.668]                       workers <- workers()
[13:23:07.668]                     workers <- structure(as.integer(workers), 
[13:23:07.668]                       class = class(workers))
[13:23:07.668]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.668]                       1L)
[13:23:07.668]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.668]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.668]                       if (default_workers) 
[13:23:07.668]                         supportsMulticore(warn = TRUE)
[13:23:07.668]                       return(sequential(..., envir = envir))
[13:23:07.668]                     }
[13:23:07.668]                     oopts <- options(mc.cores = workers)
[13:23:07.668]                     on.exit(options(oopts))
[13:23:07.668]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.668]                       envir = envir)
[13:23:07.668]                     if (!future$lazy) 
[13:23:07.668]                       future <- run(future)
[13:23:07.668]                     invisible(future)
[13:23:07.668]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.668]                 }
[13:23:07.668]             }
[13:23:07.668]         }
[13:23:07.668]     })
[13:23:07.668]     if (TRUE) {
[13:23:07.668]         base::sink(type = "output", split = FALSE)
[13:23:07.668]         if (TRUE) {
[13:23:07.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.668]         }
[13:23:07.668]         else {
[13:23:07.668]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.668]         }
[13:23:07.668]         base::close(...future.stdout)
[13:23:07.668]         ...future.stdout <- NULL
[13:23:07.668]     }
[13:23:07.668]     ...future.result$conditions <- ...future.conditions
[13:23:07.668]     ...future.result$finished <- base::Sys.time()
[13:23:07.668]     ...future.result
[13:23:07.668] }
[13:23:07.672] requestCore(): workers = 2
[13:23:07.672] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:07.697] result() for MulticoreFuture ...
[13:23:07.698] result() for MulticoreFuture ...
[13:23:07.698] result() for MulticoreFuture ... done
[13:23:07.698] result() for MulticoreFuture ... done
[13:23:07.698] result() for MulticoreFuture ...
[13:23:07.698] result() for MulticoreFuture ... done
[13:23:07.701] MulticoreFuture started
[13:23:07.702] - Launch lazy future ... done
[13:23:07.702] run() for ‘MulticoreFuture’ ... done
[13:23:07.703] plan(): Setting new future strategy stack:
<environment: 0x5596d392dde0> 
[13:23:07.703] List of future strategies:
[13:23:07.703] 1. sequential:
[13:23:07.703]    - args: function (..., envir = parent.frame())
[13:23:07.703]    - tweaked: FALSE
[13:23:07.703]    - call: NULL
[13:23:07.704] plan(): nbrOfWorkers() = 1
<environment: 0x5596d70ac2c8> 
[13:23:07.707] plan(): Setting new future strategy stack:
[13:23:07.707] List of future strategies:
[13:23:07.707] 1. multicore:
[13:23:07.707]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.707]    - tweaked: FALSE
[13:23:07.707]    - call: plan(strategy)
[13:23:07.712] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:07.715] resolve() on environment ...
[13:23:07.715]  recursive: 0
[13:23:07.716]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:07.716] signalConditionsASAP(numeric, pos=1) ...
[13:23:07.716] - nx: 4
[13:23:07.716] - relay: TRUE
[13:23:07.716] - stdout: TRUE
[13:23:07.716] - signal: TRUE
[13:23:07.717] - resignal: FALSE
[13:23:07.717] - force: TRUE
[13:23:07.717] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.717] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.717]  - until=2
[13:23:07.717]  - relaying element #2
[13:23:07.717] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:07.718] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.718] signalConditionsASAP(NULL, pos=1) ... done
[13:23:07.718]  length: 3 (resolved future 1)
[13:23:07.718] Future #2
[13:23:07.718] result() for MulticoreFuture ...
[13:23:07.718] result() for MulticoreFuture ... done
[13:23:07.718] result() for MulticoreFuture ...
[13:23:07.719] result() for MulticoreFuture ... done
[13:23:07.719] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:07.719] - nx: 4
[13:23:07.719] - relay: TRUE
[13:23:07.719] - stdout: TRUE
[13:23:07.719] - signal: TRUE
[13:23:07.719] - resignal: FALSE
[13:23:07.720] - force: TRUE
[13:23:07.720] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:07.720] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.720]  - until=2
[13:23:07.720]  - relaying element #2
[13:23:07.720] result() for MulticoreFuture ...
[13:23:07.720] result() for MulticoreFuture ... done
[13:23:07.721] result() for MulticoreFuture ...
[13:23:07.721] result() for MulticoreFuture ... done
[13:23:07.721] result() for MulticoreFuture ...
[13:23:07.721] result() for MulticoreFuture ... done
[13:23:07.721] result() for MulticoreFuture ...
[13:23:07.721] result() for MulticoreFuture ... done
[13:23:07.721] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:07.721] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:07.722] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:07.722]  length: 2 (resolved future 2)
[13:23:07.722] Future #3
[13:23:07.722] result() for MulticoreFuture ...
[13:23:07.723] result() for MulticoreFuture ...
[13:23:07.723] result() for MulticoreFuture ... done
[13:23:07.724] result() for MulticoreFuture ... done
[13:23:07.724] result() for MulticoreFuture ...
[13:23:07.724] result() for MulticoreFuture ... done
[13:23:07.724] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:07.724] - nx: 4
[13:23:07.724] - relay: TRUE
[13:23:07.724] - stdout: TRUE
[13:23:07.724] - signal: TRUE
[13:23:07.725] - resignal: FALSE
[13:23:07.725] - force: TRUE
[13:23:07.725] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:07.725] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:07.725]  - until=3
[13:23:07.725]  - relaying element #3
[13:23:07.725] result() for MulticoreFuture ...
[13:23:07.725] result() for MulticoreFuture ... done
[13:23:07.726] result() for MulticoreFuture ...
[13:23:07.726] result() for MulticoreFuture ... done
[13:23:07.726] result() for MulticoreFuture ...
[13:23:07.726] result() for MulticoreFuture ... done
[13:23:07.726] result() for MulticoreFuture ...
[13:23:07.726] result() for MulticoreFuture ... done
[13:23:07.726] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:07.726] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:07.727] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:07.727]  length: 1 (resolved future 3)
[13:23:07.727] Future #4
[13:23:07.727] result() for MulticoreFuture ...
[13:23:07.728] result() for MulticoreFuture ...
[13:23:07.728] result() for MulticoreFuture ... done
[13:23:07.728] result() for MulticoreFuture ... done
[13:23:07.729] result() for MulticoreFuture ...
[13:23:07.729] result() for MulticoreFuture ... done
[13:23:07.729] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:07.729] - nx: 4
[13:23:07.729] - relay: TRUE
[13:23:07.730] - stdout: TRUE
[13:23:07.730] - signal: TRUE
[13:23:07.730] - resignal: FALSE
[13:23:07.730] - force: TRUE
[13:23:07.730] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:07.730] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:07.730]  - until=4
[13:23:07.731]  - relaying element #4
[13:23:07.731] result() for MulticoreFuture ...
[13:23:07.731] result() for MulticoreFuture ... done
[13:23:07.731] result() for MulticoreFuture ...
[13:23:07.731] result() for MulticoreFuture ... done
[13:23:07.732] result() for MulticoreFuture ...
[13:23:07.732] result() for MulticoreFuture ... done
[13:23:07.732] result() for MulticoreFuture ...
[13:23:07.732] result() for MulticoreFuture ... done
[13:23:07.732] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.732] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:07.732] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:07.733]  length: 0 (resolved future 4)
[13:23:07.733] Relaying remaining futures
[13:23:07.733] signalConditionsASAP(NULL, pos=0) ...
[13:23:07.733] - nx: 4
[13:23:07.733] - relay: TRUE
[13:23:07.733] - stdout: TRUE
[13:23:07.733] - signal: TRUE
[13:23:07.733] - resignal: FALSE
[13:23:07.733] - force: TRUE
[13:23:07.733] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.733] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:07.734] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.734] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:07.734] signalConditionsASAP(NULL, pos=0) ... done
[13:23:07.734] resolve() on environment ... DONE
[13:23:07.734] result() for MulticoreFuture ...
[13:23:07.734] result() for MulticoreFuture ... done
[13:23:07.734] result() for MulticoreFuture ...
[13:23:07.734] result() for MulticoreFuture ... done
[13:23:07.735] result() for MulticoreFuture ...
[13:23:07.735] result() for MulticoreFuture ... done
[13:23:07.735] result() for MulticoreFuture ...
[13:23:07.735] result() for MulticoreFuture ... done
[13:23:07.735] result() for MulticoreFuture ...
[13:23:07.735] result() for MulticoreFuture ... done
[13:23:07.735] result() for MulticoreFuture ...
[13:23:07.735] result() for MulticoreFuture ... done
<environment: 0x5596d7155b48> 
Dimensions: c(2, 3)
[13:23:07.736] getGlobalsAndPackages() ...
[13:23:07.736] Searching for globals...
[13:23:07.737] 
[13:23:07.737] Searching for globals ... DONE
[13:23:07.737] - globals: [0] <none>
[13:23:07.737] getGlobalsAndPackages() ... DONE
[13:23:07.741] run() for ‘Future’ ...
[13:23:07.741] - state: ‘created’
[13:23:07.741] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.745] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.746]   - Field: ‘label’
[13:23:07.746]   - Field: ‘local’
[13:23:07.746]   - Field: ‘owner’
[13:23:07.746]   - Field: ‘envir’
[13:23:07.746]   - Field: ‘workers’
[13:23:07.746]   - Field: ‘packages’
[13:23:07.746]   - Field: ‘gc’
[13:23:07.747]   - Field: ‘job’
[13:23:07.747]   - Field: ‘conditions’
[13:23:07.747]   - Field: ‘expr’
[13:23:07.747]   - Field: ‘uuid’
[13:23:07.747]   - Field: ‘seed’
[13:23:07.747]   - Field: ‘version’
[13:23:07.747]   - Field: ‘result’
[13:23:07.747]   - Field: ‘asynchronous’
[13:23:07.747]   - Field: ‘calls’
[13:23:07.748]   - Field: ‘globals’
[13:23:07.748]   - Field: ‘stdout’
[13:23:07.748]   - Field: ‘earlySignal’
[13:23:07.748]   - Field: ‘lazy’
[13:23:07.748]   - Field: ‘state’
[13:23:07.748] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.748] - Launch lazy future ...
[13:23:07.749] Packages needed by the future expression (n = 0): <none>
[13:23:07.749] Packages needed by future strategies (n = 0): <none>
[13:23:07.749] {
[13:23:07.749]     {
[13:23:07.749]         {
[13:23:07.749]             ...future.startTime <- base::Sys.time()
[13:23:07.749]             {
[13:23:07.749]                 {
[13:23:07.749]                   {
[13:23:07.749]                     {
[13:23:07.749]                       base::local({
[13:23:07.749]                         has_future <- base::requireNamespace("future", 
[13:23:07.749]                           quietly = TRUE)
[13:23:07.749]                         if (has_future) {
[13:23:07.749]                           ns <- base::getNamespace("future")
[13:23:07.749]                           version <- ns[[".package"]][["version"]]
[13:23:07.749]                           if (is.null(version)) 
[13:23:07.749]                             version <- utils::packageVersion("future")
[13:23:07.749]                         }
[13:23:07.749]                         else {
[13:23:07.749]                           version <- NULL
[13:23:07.749]                         }
[13:23:07.749]                         if (!has_future || version < "1.8.0") {
[13:23:07.749]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.749]                             "", base::R.version$version.string), 
[13:23:07.749]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.749]                               "release", "version")], collapse = " "), 
[13:23:07.749]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.749]                             info)
[13:23:07.749]                           info <- base::paste(info, collapse = "; ")
[13:23:07.749]                           if (!has_future) {
[13:23:07.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.749]                               info)
[13:23:07.749]                           }
[13:23:07.749]                           else {
[13:23:07.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.749]                               info, version)
[13:23:07.749]                           }
[13:23:07.749]                           base::stop(msg)
[13:23:07.749]                         }
[13:23:07.749]                       })
[13:23:07.749]                     }
[13:23:07.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.749]                     base::options(mc.cores = 1L)
[13:23:07.749]                   }
[13:23:07.749]                   options(future.plan = NULL)
[13:23:07.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.749]                 }
[13:23:07.749]                 ...future.workdir <- getwd()
[13:23:07.749]             }
[13:23:07.749]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.749]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.749]         }
[13:23:07.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.749]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.749]             base::names(...future.oldOptions))
[13:23:07.749]     }
[13:23:07.749]     if (FALSE) {
[13:23:07.749]     }
[13:23:07.749]     else {
[13:23:07.749]         if (TRUE) {
[13:23:07.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.749]                 open = "w")
[13:23:07.749]         }
[13:23:07.749]         else {
[13:23:07.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.749]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.749]         }
[13:23:07.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.749]             base::sink(type = "output", split = FALSE)
[13:23:07.749]             base::close(...future.stdout)
[13:23:07.749]         }, add = TRUE)
[13:23:07.749]     }
[13:23:07.749]     ...future.frame <- base::sys.nframe()
[13:23:07.749]     ...future.conditions <- base::list()
[13:23:07.749]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.749]     if (FALSE) {
[13:23:07.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.749]     }
[13:23:07.749]     ...future.result <- base::tryCatch({
[13:23:07.749]         base::withCallingHandlers({
[13:23:07.749]             ...future.value <- base::withVisible(base::local({
[13:23:07.749]                 withCallingHandlers({
[13:23:07.749]                   2
[13:23:07.749]                 }, immediateCondition = function(cond) {
[13:23:07.749]                   save_rds <- function (object, pathname, ...) 
[13:23:07.749]                   {
[13:23:07.749]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.749]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.749]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.749]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.749]                         fi_tmp[["mtime"]])
[13:23:07.749]                     }
[13:23:07.749]                     tryCatch({
[13:23:07.749]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.749]                     }, error = function(ex) {
[13:23:07.749]                       msg <- conditionMessage(ex)
[13:23:07.749]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.749]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.749]                         fi_tmp[["mtime"]], msg)
[13:23:07.749]                       ex$message <- msg
[13:23:07.749]                       stop(ex)
[13:23:07.749]                     })
[13:23:07.749]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.749]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.749]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.749]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.749]                       fi <- file.info(pathname)
[13:23:07.749]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.749]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.749]                         fi[["size"]], fi[["mtime"]])
[13:23:07.749]                       stop(msg)
[13:23:07.749]                     }
[13:23:07.749]                     invisible(pathname)
[13:23:07.749]                   }
[13:23:07.749]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.749]                     rootPath = tempdir()) 
[13:23:07.749]                   {
[13:23:07.749]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.749]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.749]                       tmpdir = path, fileext = ".rds")
[13:23:07.749]                     save_rds(obj, file)
[13:23:07.749]                   }
[13:23:07.749]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.749]                   {
[13:23:07.749]                     inherits <- base::inherits
[13:23:07.749]                     invokeRestart <- base::invokeRestart
[13:23:07.749]                     is.null <- base::is.null
[13:23:07.749]                     muffled <- FALSE
[13:23:07.749]                     if (inherits(cond, "message")) {
[13:23:07.749]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.749]                       if (muffled) 
[13:23:07.749]                         invokeRestart("muffleMessage")
[13:23:07.749]                     }
[13:23:07.749]                     else if (inherits(cond, "warning")) {
[13:23:07.749]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.749]                       if (muffled) 
[13:23:07.749]                         invokeRestart("muffleWarning")
[13:23:07.749]                     }
[13:23:07.749]                     else if (inherits(cond, "condition")) {
[13:23:07.749]                       if (!is.null(pattern)) {
[13:23:07.749]                         computeRestarts <- base::computeRestarts
[13:23:07.749]                         grepl <- base::grepl
[13:23:07.749]                         restarts <- computeRestarts(cond)
[13:23:07.749]                         for (restart in restarts) {
[13:23:07.749]                           name <- restart$name
[13:23:07.749]                           if (is.null(name)) 
[13:23:07.749]                             next
[13:23:07.749]                           if (!grepl(pattern, name)) 
[13:23:07.749]                             next
[13:23:07.749]                           invokeRestart(restart)
[13:23:07.749]                           muffled <- TRUE
[13:23:07.749]                           break
[13:23:07.749]                         }
[13:23:07.749]                       }
[13:23:07.749]                     }
[13:23:07.749]                     invisible(muffled)
[13:23:07.749]                   }
[13:23:07.749]                   muffleCondition(cond)
[13:23:07.749]                 })
[13:23:07.749]             }))
[13:23:07.749]             future::FutureResult(value = ...future.value$value, 
[13:23:07.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.749]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.749]                     ...future.globalenv.names))
[13:23:07.749]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.749]         }, condition = base::local({
[13:23:07.749]             c <- base::c
[13:23:07.749]             inherits <- base::inherits
[13:23:07.749]             invokeRestart <- base::invokeRestart
[13:23:07.749]             length <- base::length
[13:23:07.749]             list <- base::list
[13:23:07.749]             seq.int <- base::seq.int
[13:23:07.749]             signalCondition <- base::signalCondition
[13:23:07.749]             sys.calls <- base::sys.calls
[13:23:07.749]             `[[` <- base::`[[`
[13:23:07.749]             `+` <- base::`+`
[13:23:07.749]             `<<-` <- base::`<<-`
[13:23:07.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.749]                   3L)]
[13:23:07.749]             }
[13:23:07.749]             function(cond) {
[13:23:07.749]                 is_error <- inherits(cond, "error")
[13:23:07.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.749]                   NULL)
[13:23:07.749]                 if (is_error) {
[13:23:07.749]                   sessionInformation <- function() {
[13:23:07.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.749]                       search = base::search(), system = base::Sys.info())
[13:23:07.749]                   }
[13:23:07.749]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.749]                     cond$call), session = sessionInformation(), 
[13:23:07.749]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.749]                   signalCondition(cond)
[13:23:07.749]                 }
[13:23:07.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.749]                 "immediateCondition"))) {
[13:23:07.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.749]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.749]                   if (TRUE && !signal) {
[13:23:07.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.749]                     {
[13:23:07.749]                       inherits <- base::inherits
[13:23:07.749]                       invokeRestart <- base::invokeRestart
[13:23:07.749]                       is.null <- base::is.null
[13:23:07.749]                       muffled <- FALSE
[13:23:07.749]                       if (inherits(cond, "message")) {
[13:23:07.749]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.749]                         if (muffled) 
[13:23:07.749]                           invokeRestart("muffleMessage")
[13:23:07.749]                       }
[13:23:07.749]                       else if (inherits(cond, "warning")) {
[13:23:07.749]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.749]                         if (muffled) 
[13:23:07.749]                           invokeRestart("muffleWarning")
[13:23:07.749]                       }
[13:23:07.749]                       else if (inherits(cond, "condition")) {
[13:23:07.749]                         if (!is.null(pattern)) {
[13:23:07.749]                           computeRestarts <- base::computeRestarts
[13:23:07.749]                           grepl <- base::grepl
[13:23:07.749]                           restarts <- computeRestarts(cond)
[13:23:07.749]                           for (restart in restarts) {
[13:23:07.749]                             name <- restart$name
[13:23:07.749]                             if (is.null(name)) 
[13:23:07.749]                               next
[13:23:07.749]                             if (!grepl(pattern, name)) 
[13:23:07.749]                               next
[13:23:07.749]                             invokeRestart(restart)
[13:23:07.749]                             muffled <- TRUE
[13:23:07.749]                             break
[13:23:07.749]                           }
[13:23:07.749]                         }
[13:23:07.749]                       }
[13:23:07.749]                       invisible(muffled)
[13:23:07.749]                     }
[13:23:07.749]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.749]                   }
[13:23:07.749]                 }
[13:23:07.749]                 else {
[13:23:07.749]                   if (TRUE) {
[13:23:07.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.749]                     {
[13:23:07.749]                       inherits <- base::inherits
[13:23:07.749]                       invokeRestart <- base::invokeRestart
[13:23:07.749]                       is.null <- base::is.null
[13:23:07.749]                       muffled <- FALSE
[13:23:07.749]                       if (inherits(cond, "message")) {
[13:23:07.749]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.749]                         if (muffled) 
[13:23:07.749]                           invokeRestart("muffleMessage")
[13:23:07.749]                       }
[13:23:07.749]                       else if (inherits(cond, "warning")) {
[13:23:07.749]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.749]                         if (muffled) 
[13:23:07.749]                           invokeRestart("muffleWarning")
[13:23:07.749]                       }
[13:23:07.749]                       else if (inherits(cond, "condition")) {
[13:23:07.749]                         if (!is.null(pattern)) {
[13:23:07.749]                           computeRestarts <- base::computeRestarts
[13:23:07.749]                           grepl <- base::grepl
[13:23:07.749]                           restarts <- computeRestarts(cond)
[13:23:07.749]                           for (restart in restarts) {
[13:23:07.749]                             name <- restart$name
[13:23:07.749]                             if (is.null(name)) 
[13:23:07.749]                               next
[13:23:07.749]                             if (!grepl(pattern, name)) 
[13:23:07.749]                               next
[13:23:07.749]                             invokeRestart(restart)
[13:23:07.749]                             muffled <- TRUE
[13:23:07.749]                             break
[13:23:07.749]                           }
[13:23:07.749]                         }
[13:23:07.749]                       }
[13:23:07.749]                       invisible(muffled)
[13:23:07.749]                     }
[13:23:07.749]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.749]                   }
[13:23:07.749]                 }
[13:23:07.749]             }
[13:23:07.749]         }))
[13:23:07.749]     }, error = function(ex) {
[13:23:07.749]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.749]                 ...future.rng), started = ...future.startTime, 
[13:23:07.749]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.749]             version = "1.8"), class = "FutureResult")
[13:23:07.749]     }, finally = {
[13:23:07.749]         if (!identical(...future.workdir, getwd())) 
[13:23:07.749]             setwd(...future.workdir)
[13:23:07.749]         {
[13:23:07.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.749]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.749]             }
[13:23:07.749]             base::options(...future.oldOptions)
[13:23:07.749]             if (.Platform$OS.type == "windows") {
[13:23:07.749]                 old_names <- names(...future.oldEnvVars)
[13:23:07.749]                 envs <- base::Sys.getenv()
[13:23:07.749]                 names <- names(envs)
[13:23:07.749]                 common <- intersect(names, old_names)
[13:23:07.749]                 added <- setdiff(names, old_names)
[13:23:07.749]                 removed <- setdiff(old_names, names)
[13:23:07.749]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.749]                   envs[common]]
[13:23:07.749]                 NAMES <- toupper(changed)
[13:23:07.749]                 args <- list()
[13:23:07.749]                 for (kk in seq_along(NAMES)) {
[13:23:07.749]                   name <- changed[[kk]]
[13:23:07.749]                   NAME <- NAMES[[kk]]
[13:23:07.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.749]                     next
[13:23:07.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.749]                 }
[13:23:07.749]                 NAMES <- toupper(added)
[13:23:07.749]                 for (kk in seq_along(NAMES)) {
[13:23:07.749]                   name <- added[[kk]]
[13:23:07.749]                   NAME <- NAMES[[kk]]
[13:23:07.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.749]                     next
[13:23:07.749]                   args[[name]] <- ""
[13:23:07.749]                 }
[13:23:07.749]                 NAMES <- toupper(removed)
[13:23:07.749]                 for (kk in seq_along(NAMES)) {
[13:23:07.749]                   name <- removed[[kk]]
[13:23:07.749]                   NAME <- NAMES[[kk]]
[13:23:07.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.749]                     next
[13:23:07.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.749]                 }
[13:23:07.749]                 if (length(args) > 0) 
[13:23:07.749]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.749]             }
[13:23:07.749]             else {
[13:23:07.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.749]             }
[13:23:07.749]             {
[13:23:07.749]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.749]                   0L) {
[13:23:07.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.749]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.749]                   base::options(opts)
[13:23:07.749]                 }
[13:23:07.749]                 {
[13:23:07.749]                   {
[13:23:07.749]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.749]                     NULL
[13:23:07.749]                   }
[13:23:07.749]                   options(future.plan = NULL)
[13:23:07.749]                   if (is.na(NA_character_)) 
[13:23:07.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.749]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.749]                     envir = parent.frame()) 
[13:23:07.749]                   {
[13:23:07.749]                     default_workers <- missing(workers)
[13:23:07.749]                     if (is.function(workers)) 
[13:23:07.749]                       workers <- workers()
[13:23:07.749]                     workers <- structure(as.integer(workers), 
[13:23:07.749]                       class = class(workers))
[13:23:07.749]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.749]                       1L)
[13:23:07.749]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.749]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.749]                       if (default_workers) 
[13:23:07.749]                         supportsMulticore(warn = TRUE)
[13:23:07.749]                       return(sequential(..., envir = envir))
[13:23:07.749]                     }
[13:23:07.749]                     oopts <- options(mc.cores = workers)
[13:23:07.749]                     on.exit(options(oopts))
[13:23:07.749]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.749]                       envir = envir)
[13:23:07.749]                     if (!future$lazy) 
[13:23:07.749]                       future <- run(future)
[13:23:07.749]                     invisible(future)
[13:23:07.749]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.749]                 }
[13:23:07.749]             }
[13:23:07.749]         }
[13:23:07.749]     })
[13:23:07.749]     if (TRUE) {
[13:23:07.749]         base::sink(type = "output", split = FALSE)
[13:23:07.749]         if (TRUE) {
[13:23:07.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.749]         }
[13:23:07.749]         else {
[13:23:07.749]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.749]         }
[13:23:07.749]         base::close(...future.stdout)
[13:23:07.749]         ...future.stdout <- NULL
[13:23:07.749]     }
[13:23:07.749]     ...future.result$conditions <- ...future.conditions
[13:23:07.749]     ...future.result$finished <- base::Sys.time()
[13:23:07.749]     ...future.result
[13:23:07.749] }
[13:23:07.752] requestCore(): workers = 2
[13:23:07.755] MulticoreFuture started
[13:23:07.755] - Launch lazy future ... done
[13:23:07.756] run() for ‘MulticoreFuture’ ... done
[13:23:07.756] getGlobalsAndPackages() ...
[13:23:07.756] Searching for globals...
[13:23:07.756] plan(): Setting new future strategy stack:
[13:23:07.757] 
[13:23:07.757] Searching for globals ... DONE
[13:23:07.757] List of future strategies:
[13:23:07.757] 1. sequential:
[13:23:07.757]    - args: function (..., envir = parent.frame())
[13:23:07.757]    - tweaked: FALSE
[13:23:07.757]    - call: NULL
[13:23:07.757] - globals: [0] <none>
[13:23:07.757] plan(): nbrOfWorkers() = 1
[13:23:07.757] getGlobalsAndPackages() ... DONE
[13:23:07.758] run() for ‘Future’ ...
[13:23:07.758] - state: ‘created’
[13:23:07.758] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.759] plan(): Setting new future strategy stack:
[13:23:07.760] List of future strategies:
[13:23:07.760] 1. multicore:
[13:23:07.760]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.760]    - tweaked: FALSE
[13:23:07.760]    - call: plan(strategy)
[13:23:07.765] plan(): nbrOfWorkers() = 2
[13:23:07.765] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.765] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.766]   - Field: ‘label’
[13:23:07.766]   - Field: ‘local’
[13:23:07.766]   - Field: ‘owner’
[13:23:07.766]   - Field: ‘envir’
[13:23:07.766]   - Field: ‘workers’
[13:23:07.766]   - Field: ‘packages’
[13:23:07.766]   - Field: ‘gc’
[13:23:07.767]   - Field: ‘job’
[13:23:07.767]   - Field: ‘conditions’
[13:23:07.767]   - Field: ‘expr’
[13:23:07.767]   - Field: ‘uuid’
[13:23:07.767]   - Field: ‘seed’
[13:23:07.767]   - Field: ‘version’
[13:23:07.767]   - Field: ‘result’
[13:23:07.768]   - Field: ‘asynchronous’
[13:23:07.768]   - Field: ‘calls’
[13:23:07.768]   - Field: ‘globals’
[13:23:07.768]   - Field: ‘stdout’
[13:23:07.768]   - Field: ‘earlySignal’
[13:23:07.769]   - Field: ‘lazy’
[13:23:07.769]   - Field: ‘state’
[13:23:07.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.769] - Launch lazy future ...
[13:23:07.770] Packages needed by the future expression (n = 0): <none>
[13:23:07.770] Packages needed by future strategies (n = 0): <none>
[13:23:07.770] {
[13:23:07.770]     {
[13:23:07.770]         {
[13:23:07.770]             ...future.startTime <- base::Sys.time()
[13:23:07.770]             {
[13:23:07.770]                 {
[13:23:07.770]                   {
[13:23:07.770]                     {
[13:23:07.770]                       base::local({
[13:23:07.770]                         has_future <- base::requireNamespace("future", 
[13:23:07.770]                           quietly = TRUE)
[13:23:07.770]                         if (has_future) {
[13:23:07.770]                           ns <- base::getNamespace("future")
[13:23:07.770]                           version <- ns[[".package"]][["version"]]
[13:23:07.770]                           if (is.null(version)) 
[13:23:07.770]                             version <- utils::packageVersion("future")
[13:23:07.770]                         }
[13:23:07.770]                         else {
[13:23:07.770]                           version <- NULL
[13:23:07.770]                         }
[13:23:07.770]                         if (!has_future || version < "1.8.0") {
[13:23:07.770]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.770]                             "", base::R.version$version.string), 
[13:23:07.770]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.770]                               "release", "version")], collapse = " "), 
[13:23:07.770]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.770]                             info)
[13:23:07.770]                           info <- base::paste(info, collapse = "; ")
[13:23:07.770]                           if (!has_future) {
[13:23:07.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.770]                               info)
[13:23:07.770]                           }
[13:23:07.770]                           else {
[13:23:07.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.770]                               info, version)
[13:23:07.770]                           }
[13:23:07.770]                           base::stop(msg)
[13:23:07.770]                         }
[13:23:07.770]                       })
[13:23:07.770]                     }
[13:23:07.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.770]                     base::options(mc.cores = 1L)
[13:23:07.770]                   }
[13:23:07.770]                   options(future.plan = NULL)
[13:23:07.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.770]                 }
[13:23:07.770]                 ...future.workdir <- getwd()
[13:23:07.770]             }
[13:23:07.770]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.770]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.770]         }
[13:23:07.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.770]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.770]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.770]             base::names(...future.oldOptions))
[13:23:07.770]     }
[13:23:07.770]     if (FALSE) {
[13:23:07.770]     }
[13:23:07.770]     else {
[13:23:07.770]         if (TRUE) {
[13:23:07.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.770]                 open = "w")
[13:23:07.770]         }
[13:23:07.770]         else {
[13:23:07.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.770]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.770]         }
[13:23:07.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.770]             base::sink(type = "output", split = FALSE)
[13:23:07.770]             base::close(...future.stdout)
[13:23:07.770]         }, add = TRUE)
[13:23:07.770]     }
[13:23:07.770]     ...future.frame <- base::sys.nframe()
[13:23:07.770]     ...future.conditions <- base::list()
[13:23:07.770]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.770]     if (FALSE) {
[13:23:07.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.770]     }
[13:23:07.770]     ...future.result <- base::tryCatch({
[13:23:07.770]         base::withCallingHandlers({
[13:23:07.770]             ...future.value <- base::withVisible(base::local({
[13:23:07.770]                 withCallingHandlers({
[13:23:07.770]                   NULL
[13:23:07.770]                 }, immediateCondition = function(cond) {
[13:23:07.770]                   save_rds <- function (object, pathname, ...) 
[13:23:07.770]                   {
[13:23:07.770]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.770]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.770]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.770]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.770]                         fi_tmp[["mtime"]])
[13:23:07.770]                     }
[13:23:07.770]                     tryCatch({
[13:23:07.770]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.770]                     }, error = function(ex) {
[13:23:07.770]                       msg <- conditionMessage(ex)
[13:23:07.770]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.770]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.770]                         fi_tmp[["mtime"]], msg)
[13:23:07.770]                       ex$message <- msg
[13:23:07.770]                       stop(ex)
[13:23:07.770]                     })
[13:23:07.770]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.770]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.770]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.770]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.770]                       fi <- file.info(pathname)
[13:23:07.770]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.770]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.770]                         fi[["size"]], fi[["mtime"]])
[13:23:07.770]                       stop(msg)
[13:23:07.770]                     }
[13:23:07.770]                     invisible(pathname)
[13:23:07.770]                   }
[13:23:07.770]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.770]                     rootPath = tempdir()) 
[13:23:07.770]                   {
[13:23:07.770]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.770]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.770]                       tmpdir = path, fileext = ".rds")
[13:23:07.770]                     save_rds(obj, file)
[13:23:07.770]                   }
[13:23:07.770]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.770]                   {
[13:23:07.770]                     inherits <- base::inherits
[13:23:07.770]                     invokeRestart <- base::invokeRestart
[13:23:07.770]                     is.null <- base::is.null
[13:23:07.770]                     muffled <- FALSE
[13:23:07.770]                     if (inherits(cond, "message")) {
[13:23:07.770]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.770]                       if (muffled) 
[13:23:07.770]                         invokeRestart("muffleMessage")
[13:23:07.770]                     }
[13:23:07.770]                     else if (inherits(cond, "warning")) {
[13:23:07.770]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.770]                       if (muffled) 
[13:23:07.770]                         invokeRestart("muffleWarning")
[13:23:07.770]                     }
[13:23:07.770]                     else if (inherits(cond, "condition")) {
[13:23:07.770]                       if (!is.null(pattern)) {
[13:23:07.770]                         computeRestarts <- base::computeRestarts
[13:23:07.770]                         grepl <- base::grepl
[13:23:07.770]                         restarts <- computeRestarts(cond)
[13:23:07.770]                         for (restart in restarts) {
[13:23:07.770]                           name <- restart$name
[13:23:07.770]                           if (is.null(name)) 
[13:23:07.770]                             next
[13:23:07.770]                           if (!grepl(pattern, name)) 
[13:23:07.770]                             next
[13:23:07.770]                           invokeRestart(restart)
[13:23:07.770]                           muffled <- TRUE
[13:23:07.770]                           break
[13:23:07.770]                         }
[13:23:07.770]                       }
[13:23:07.770]                     }
[13:23:07.770]                     invisible(muffled)
[13:23:07.770]                   }
[13:23:07.770]                   muffleCondition(cond)
[13:23:07.770]                 })
[13:23:07.770]             }))
[13:23:07.770]             future::FutureResult(value = ...future.value$value, 
[13:23:07.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.770]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.770]                     ...future.globalenv.names))
[13:23:07.770]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.770]         }, condition = base::local({
[13:23:07.770]             c <- base::c
[13:23:07.770]             inherits <- base::inherits
[13:23:07.770]             invokeRestart <- base::invokeRestart
[13:23:07.770]             length <- base::length
[13:23:07.770]             list <- base::list
[13:23:07.770]             seq.int <- base::seq.int
[13:23:07.770]             signalCondition <- base::signalCondition
[13:23:07.770]             sys.calls <- base::sys.calls
[13:23:07.770]             `[[` <- base::`[[`
[13:23:07.770]             `+` <- base::`+`
[13:23:07.770]             `<<-` <- base::`<<-`
[13:23:07.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.770]                   3L)]
[13:23:07.770]             }
[13:23:07.770]             function(cond) {
[13:23:07.770]                 is_error <- inherits(cond, "error")
[13:23:07.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.770]                   NULL)
[13:23:07.770]                 if (is_error) {
[13:23:07.770]                   sessionInformation <- function() {
[13:23:07.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.770]                       search = base::search(), system = base::Sys.info())
[13:23:07.770]                   }
[13:23:07.770]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.770]                     cond$call), session = sessionInformation(), 
[13:23:07.770]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.770]                   signalCondition(cond)
[13:23:07.770]                 }
[13:23:07.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.770]                 "immediateCondition"))) {
[13:23:07.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.770]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.770]                   if (TRUE && !signal) {
[13:23:07.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.770]                     {
[13:23:07.770]                       inherits <- base::inherits
[13:23:07.770]                       invokeRestart <- base::invokeRestart
[13:23:07.770]                       is.null <- base::is.null
[13:23:07.770]                       muffled <- FALSE
[13:23:07.770]                       if (inherits(cond, "message")) {
[13:23:07.770]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.770]                         if (muffled) 
[13:23:07.770]                           invokeRestart("muffleMessage")
[13:23:07.770]                       }
[13:23:07.770]                       else if (inherits(cond, "warning")) {
[13:23:07.770]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.770]                         if (muffled) 
[13:23:07.770]                           invokeRestart("muffleWarning")
[13:23:07.770]                       }
[13:23:07.770]                       else if (inherits(cond, "condition")) {
[13:23:07.770]                         if (!is.null(pattern)) {
[13:23:07.770]                           computeRestarts <- base::computeRestarts
[13:23:07.770]                           grepl <- base::grepl
[13:23:07.770]                           restarts <- computeRestarts(cond)
[13:23:07.770]                           for (restart in restarts) {
[13:23:07.770]                             name <- restart$name
[13:23:07.770]                             if (is.null(name)) 
[13:23:07.770]                               next
[13:23:07.770]                             if (!grepl(pattern, name)) 
[13:23:07.770]                               next
[13:23:07.770]                             invokeRestart(restart)
[13:23:07.770]                             muffled <- TRUE
[13:23:07.770]                             break
[13:23:07.770]                           }
[13:23:07.770]                         }
[13:23:07.770]                       }
[13:23:07.770]                       invisible(muffled)
[13:23:07.770]                     }
[13:23:07.770]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.770]                   }
[13:23:07.770]                 }
[13:23:07.770]                 else {
[13:23:07.770]                   if (TRUE) {
[13:23:07.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.770]                     {
[13:23:07.770]                       inherits <- base::inherits
[13:23:07.770]                       invokeRestart <- base::invokeRestart
[13:23:07.770]                       is.null <- base::is.null
[13:23:07.770]                       muffled <- FALSE
[13:23:07.770]                       if (inherits(cond, "message")) {
[13:23:07.770]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.770]                         if (muffled) 
[13:23:07.770]                           invokeRestart("muffleMessage")
[13:23:07.770]                       }
[13:23:07.770]                       else if (inherits(cond, "warning")) {
[13:23:07.770]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.770]                         if (muffled) 
[13:23:07.770]                           invokeRestart("muffleWarning")
[13:23:07.770]                       }
[13:23:07.770]                       else if (inherits(cond, "condition")) {
[13:23:07.770]                         if (!is.null(pattern)) {
[13:23:07.770]                           computeRestarts <- base::computeRestarts
[13:23:07.770]                           grepl <- base::grepl
[13:23:07.770]                           restarts <- computeRestarts(cond)
[13:23:07.770]                           for (restart in restarts) {
[13:23:07.770]                             name <- restart$name
[13:23:07.770]                             if (is.null(name)) 
[13:23:07.770]                               next
[13:23:07.770]                             if (!grepl(pattern, name)) 
[13:23:07.770]                               next
[13:23:07.770]                             invokeRestart(restart)
[13:23:07.770]                             muffled <- TRUE
[13:23:07.770]                             break
[13:23:07.770]                           }
[13:23:07.770]                         }
[13:23:07.770]                       }
[13:23:07.770]                       invisible(muffled)
[13:23:07.770]                     }
[13:23:07.770]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.770]                   }
[13:23:07.770]                 }
[13:23:07.770]             }
[13:23:07.770]         }))
[13:23:07.770]     }, error = function(ex) {
[13:23:07.770]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.770]                 ...future.rng), started = ...future.startTime, 
[13:23:07.770]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.770]             version = "1.8"), class = "FutureResult")
[13:23:07.770]     }, finally = {
[13:23:07.770]         if (!identical(...future.workdir, getwd())) 
[13:23:07.770]             setwd(...future.workdir)
[13:23:07.770]         {
[13:23:07.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.770]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.770]             }
[13:23:07.770]             base::options(...future.oldOptions)
[13:23:07.770]             if (.Platform$OS.type == "windows") {
[13:23:07.770]                 old_names <- names(...future.oldEnvVars)
[13:23:07.770]                 envs <- base::Sys.getenv()
[13:23:07.770]                 names <- names(envs)
[13:23:07.770]                 common <- intersect(names, old_names)
[13:23:07.770]                 added <- setdiff(names, old_names)
[13:23:07.770]                 removed <- setdiff(old_names, names)
[13:23:07.770]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.770]                   envs[common]]
[13:23:07.770]                 NAMES <- toupper(changed)
[13:23:07.770]                 args <- list()
[13:23:07.770]                 for (kk in seq_along(NAMES)) {
[13:23:07.770]                   name <- changed[[kk]]
[13:23:07.770]                   NAME <- NAMES[[kk]]
[13:23:07.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.770]                     next
[13:23:07.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.770]                 }
[13:23:07.770]                 NAMES <- toupper(added)
[13:23:07.770]                 for (kk in seq_along(NAMES)) {
[13:23:07.770]                   name <- added[[kk]]
[13:23:07.770]                   NAME <- NAMES[[kk]]
[13:23:07.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.770]                     next
[13:23:07.770]                   args[[name]] <- ""
[13:23:07.770]                 }
[13:23:07.770]                 NAMES <- toupper(removed)
[13:23:07.770]                 for (kk in seq_along(NAMES)) {
[13:23:07.770]                   name <- removed[[kk]]
[13:23:07.770]                   NAME <- NAMES[[kk]]
[13:23:07.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.770]                     next
[13:23:07.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.770]                 }
[13:23:07.770]                 if (length(args) > 0) 
[13:23:07.770]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.770]             }
[13:23:07.770]             else {
[13:23:07.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.770]             }
[13:23:07.770]             {
[13:23:07.770]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.770]                   0L) {
[13:23:07.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.770]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.770]                   base::options(opts)
[13:23:07.770]                 }
[13:23:07.770]                 {
[13:23:07.770]                   {
[13:23:07.770]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.770]                     NULL
[13:23:07.770]                   }
[13:23:07.770]                   options(future.plan = NULL)
[13:23:07.770]                   if (is.na(NA_character_)) 
[13:23:07.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.770]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.770]                     envir = parent.frame()) 
[13:23:07.770]                   {
[13:23:07.770]                     default_workers <- missing(workers)
[13:23:07.770]                     if (is.function(workers)) 
[13:23:07.770]                       workers <- workers()
[13:23:07.770]                     workers <- structure(as.integer(workers), 
[13:23:07.770]                       class = class(workers))
[13:23:07.770]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.770]                       1L)
[13:23:07.770]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.770]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.770]                       if (default_workers) 
[13:23:07.770]                         supportsMulticore(warn = TRUE)
[13:23:07.770]                       return(sequential(..., envir = envir))
[13:23:07.770]                     }
[13:23:07.770]                     oopts <- options(mc.cores = workers)
[13:23:07.770]                     on.exit(options(oopts))
[13:23:07.770]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.770]                       envir = envir)
[13:23:07.770]                     if (!future$lazy) 
[13:23:07.770]                       future <- run(future)
[13:23:07.770]                     invisible(future)
[13:23:07.770]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.770]                 }
[13:23:07.770]             }
[13:23:07.770]         }
[13:23:07.770]     })
[13:23:07.770]     if (TRUE) {
[13:23:07.770]         base::sink(type = "output", split = FALSE)
[13:23:07.770]         if (TRUE) {
[13:23:07.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.770]         }
[13:23:07.770]         else {
[13:23:07.770]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.770]         }
[13:23:07.770]         base::close(...future.stdout)
[13:23:07.770]         ...future.stdout <- NULL
[13:23:07.770]     }
[13:23:07.770]     ...future.result$conditions <- ...future.conditions
[13:23:07.770]     ...future.result$finished <- base::Sys.time()
[13:23:07.770]     ...future.result
[13:23:07.770] }
[13:23:07.774] requestCore(): workers = 2
[13:23:07.778] MulticoreFuture started
[13:23:07.778] - Launch lazy future ... done
[13:23:07.778] run() for ‘MulticoreFuture’ ... done
[13:23:07.779] plan(): Setting new future strategy stack:
[13:23:07.779] getGlobalsAndPackages() ...
[13:23:07.779] Searching for globals...
[13:23:07.779] List of future strategies:
[13:23:07.779] 1. sequential:
[13:23:07.779]    - args: function (..., envir = parent.frame())
[13:23:07.779]    - tweaked: FALSE
[13:23:07.779]    - call: NULL
[13:23:07.780] plan(): nbrOfWorkers() = 1
[13:23:07.781] - globals found: [1] ‘{’
[13:23:07.781] Searching for globals ... DONE
[13:23:07.781] Resolving globals: FALSE
[13:23:07.782] 
[13:23:07.782] 
[13:23:07.782] getGlobalsAndPackages() ... DONE
[13:23:07.782] plan(): Setting new future strategy stack:
[13:23:07.782] run() for ‘Future’ ...
[13:23:07.782] - state: ‘created’
[13:23:07.782] List of future strategies:
[13:23:07.782] 1. multicore:
[13:23:07.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.782]    - tweaked: FALSE
[13:23:07.782]    - call: plan(strategy)
[13:23:07.783] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.787] plan(): nbrOfWorkers() = 2
[13:23:07.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.789]   - Field: ‘label’
[13:23:07.789]   - Field: ‘local’
[13:23:07.789]   - Field: ‘owner’
[13:23:07.789]   - Field: ‘envir’
[13:23:07.789]   - Field: ‘workers’
[13:23:07.789]   - Field: ‘packages’
[13:23:07.790]   - Field: ‘gc’
[13:23:07.790]   - Field: ‘job’
[13:23:07.790]   - Field: ‘conditions’
[13:23:07.790]   - Field: ‘expr’
[13:23:07.790]   - Field: ‘uuid’
[13:23:07.790]   - Field: ‘seed’
[13:23:07.791]   - Field: ‘version’
[13:23:07.791]   - Field: ‘result’
[13:23:07.791]   - Field: ‘asynchronous’
[13:23:07.791]   - Field: ‘calls’
[13:23:07.791]   - Field: ‘globals’
[13:23:07.791]   - Field: ‘stdout’
[13:23:07.792]   - Field: ‘earlySignal’
[13:23:07.792]   - Field: ‘lazy’
[13:23:07.792]   - Field: ‘state’
[13:23:07.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.792] - Launch lazy future ...
[13:23:07.793] Packages needed by the future expression (n = 0): <none>
[13:23:07.793] Packages needed by future strategies (n = 0): <none>
[13:23:07.794] {
[13:23:07.794]     {
[13:23:07.794]         {
[13:23:07.794]             ...future.startTime <- base::Sys.time()
[13:23:07.794]             {
[13:23:07.794]                 {
[13:23:07.794]                   {
[13:23:07.794]                     {
[13:23:07.794]                       base::local({
[13:23:07.794]                         has_future <- base::requireNamespace("future", 
[13:23:07.794]                           quietly = TRUE)
[13:23:07.794]                         if (has_future) {
[13:23:07.794]                           ns <- base::getNamespace("future")
[13:23:07.794]                           version <- ns[[".package"]][["version"]]
[13:23:07.794]                           if (is.null(version)) 
[13:23:07.794]                             version <- utils::packageVersion("future")
[13:23:07.794]                         }
[13:23:07.794]                         else {
[13:23:07.794]                           version <- NULL
[13:23:07.794]                         }
[13:23:07.794]                         if (!has_future || version < "1.8.0") {
[13:23:07.794]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.794]                             "", base::R.version$version.string), 
[13:23:07.794]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.794]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.794]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.794]                               "release", "version")], collapse = " "), 
[13:23:07.794]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.794]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.794]                             info)
[13:23:07.794]                           info <- base::paste(info, collapse = "; ")
[13:23:07.794]                           if (!has_future) {
[13:23:07.794]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.794]                               info)
[13:23:07.794]                           }
[13:23:07.794]                           else {
[13:23:07.794]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.794]                               info, version)
[13:23:07.794]                           }
[13:23:07.794]                           base::stop(msg)
[13:23:07.794]                         }
[13:23:07.794]                       })
[13:23:07.794]                     }
[13:23:07.794]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.794]                     base::options(mc.cores = 1L)
[13:23:07.794]                   }
[13:23:07.794]                   options(future.plan = NULL)
[13:23:07.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.794]                 }
[13:23:07.794]                 ...future.workdir <- getwd()
[13:23:07.794]             }
[13:23:07.794]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.794]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.794]         }
[13:23:07.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.794]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.794]             base::names(...future.oldOptions))
[13:23:07.794]     }
[13:23:07.794]     if (FALSE) {
[13:23:07.794]     }
[13:23:07.794]     else {
[13:23:07.794]         if (TRUE) {
[13:23:07.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.794]                 open = "w")
[13:23:07.794]         }
[13:23:07.794]         else {
[13:23:07.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.794]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.794]         }
[13:23:07.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.794]             base::sink(type = "output", split = FALSE)
[13:23:07.794]             base::close(...future.stdout)
[13:23:07.794]         }, add = TRUE)
[13:23:07.794]     }
[13:23:07.794]     ...future.frame <- base::sys.nframe()
[13:23:07.794]     ...future.conditions <- base::list()
[13:23:07.794]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.794]     if (FALSE) {
[13:23:07.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.794]     }
[13:23:07.794]     ...future.result <- base::tryCatch({
[13:23:07.794]         base::withCallingHandlers({
[13:23:07.794]             ...future.value <- base::withVisible(base::local({
[13:23:07.794]                 withCallingHandlers({
[13:23:07.794]                   {
[13:23:07.794]                     4
[13:23:07.794]                   }
[13:23:07.794]                 }, immediateCondition = function(cond) {
[13:23:07.794]                   save_rds <- function (object, pathname, ...) 
[13:23:07.794]                   {
[13:23:07.794]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.794]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.794]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.794]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.794]                         fi_tmp[["mtime"]])
[13:23:07.794]                     }
[13:23:07.794]                     tryCatch({
[13:23:07.794]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.794]                     }, error = function(ex) {
[13:23:07.794]                       msg <- conditionMessage(ex)
[13:23:07.794]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.794]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.794]                         fi_tmp[["mtime"]], msg)
[13:23:07.794]                       ex$message <- msg
[13:23:07.794]                       stop(ex)
[13:23:07.794]                     })
[13:23:07.794]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.794]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.794]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.794]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.794]                       fi <- file.info(pathname)
[13:23:07.794]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.794]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.794]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.794]                         fi[["size"]], fi[["mtime"]])
[13:23:07.794]                       stop(msg)
[13:23:07.794]                     }
[13:23:07.794]                     invisible(pathname)
[13:23:07.794]                   }
[13:23:07.794]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.794]                     rootPath = tempdir()) 
[13:23:07.794]                   {
[13:23:07.794]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.794]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.794]                       tmpdir = path, fileext = ".rds")
[13:23:07.794]                     save_rds(obj, file)
[13:23:07.794]                   }
[13:23:07.794]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.794]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.794]                   {
[13:23:07.794]                     inherits <- base::inherits
[13:23:07.794]                     invokeRestart <- base::invokeRestart
[13:23:07.794]                     is.null <- base::is.null
[13:23:07.794]                     muffled <- FALSE
[13:23:07.794]                     if (inherits(cond, "message")) {
[13:23:07.794]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.794]                       if (muffled) 
[13:23:07.794]                         invokeRestart("muffleMessage")
[13:23:07.794]                     }
[13:23:07.794]                     else if (inherits(cond, "warning")) {
[13:23:07.794]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.794]                       if (muffled) 
[13:23:07.794]                         invokeRestart("muffleWarning")
[13:23:07.794]                     }
[13:23:07.794]                     else if (inherits(cond, "condition")) {
[13:23:07.794]                       if (!is.null(pattern)) {
[13:23:07.794]                         computeRestarts <- base::computeRestarts
[13:23:07.794]                         grepl <- base::grepl
[13:23:07.794]                         restarts <- computeRestarts(cond)
[13:23:07.794]                         for (restart in restarts) {
[13:23:07.794]                           name <- restart$name
[13:23:07.794]                           if (is.null(name)) 
[13:23:07.794]                             next
[13:23:07.794]                           if (!grepl(pattern, name)) 
[13:23:07.794]                             next
[13:23:07.794]                           invokeRestart(restart)
[13:23:07.794]                           muffled <- TRUE
[13:23:07.794]                           break
[13:23:07.794]                         }
[13:23:07.794]                       }
[13:23:07.794]                     }
[13:23:07.794]                     invisible(muffled)
[13:23:07.794]                   }
[13:23:07.794]                   muffleCondition(cond)
[13:23:07.794]                 })
[13:23:07.794]             }))
[13:23:07.794]             future::FutureResult(value = ...future.value$value, 
[13:23:07.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.794]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.794]                     ...future.globalenv.names))
[13:23:07.794]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.794]         }, condition = base::local({
[13:23:07.794]             c <- base::c
[13:23:07.794]             inherits <- base::inherits
[13:23:07.794]             invokeRestart <- base::invokeRestart
[13:23:07.794]             length <- base::length
[13:23:07.794]             list <- base::list
[13:23:07.794]             seq.int <- base::seq.int
[13:23:07.794]             signalCondition <- base::signalCondition
[13:23:07.794]             sys.calls <- base::sys.calls
[13:23:07.794]             `[[` <- base::`[[`
[13:23:07.794]             `+` <- base::`+`
[13:23:07.794]             `<<-` <- base::`<<-`
[13:23:07.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.794]                   3L)]
[13:23:07.794]             }
[13:23:07.794]             function(cond) {
[13:23:07.794]                 is_error <- inherits(cond, "error")
[13:23:07.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.794]                   NULL)
[13:23:07.794]                 if (is_error) {
[13:23:07.794]                   sessionInformation <- function() {
[13:23:07.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.794]                       search = base::search(), system = base::Sys.info())
[13:23:07.794]                   }
[13:23:07.794]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.794]                     cond$call), session = sessionInformation(), 
[13:23:07.794]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.794]                   signalCondition(cond)
[13:23:07.794]                 }
[13:23:07.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.794]                 "immediateCondition"))) {
[13:23:07.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.794]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.794]                   if (TRUE && !signal) {
[13:23:07.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.794]                     {
[13:23:07.794]                       inherits <- base::inherits
[13:23:07.794]                       invokeRestart <- base::invokeRestart
[13:23:07.794]                       is.null <- base::is.null
[13:23:07.794]                       muffled <- FALSE
[13:23:07.794]                       if (inherits(cond, "message")) {
[13:23:07.794]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.794]                         if (muffled) 
[13:23:07.794]                           invokeRestart("muffleMessage")
[13:23:07.794]                       }
[13:23:07.794]                       else if (inherits(cond, "warning")) {
[13:23:07.794]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.794]                         if (muffled) 
[13:23:07.794]                           invokeRestart("muffleWarning")
[13:23:07.794]                       }
[13:23:07.794]                       else if (inherits(cond, "condition")) {
[13:23:07.794]                         if (!is.null(pattern)) {
[13:23:07.794]                           computeRestarts <- base::computeRestarts
[13:23:07.794]                           grepl <- base::grepl
[13:23:07.794]                           restarts <- computeRestarts(cond)
[13:23:07.794]                           for (restart in restarts) {
[13:23:07.794]                             name <- restart$name
[13:23:07.794]                             if (is.null(name)) 
[13:23:07.794]                               next
[13:23:07.794]                             if (!grepl(pattern, name)) 
[13:23:07.794]                               next
[13:23:07.794]                             invokeRestart(restart)
[13:23:07.794]                             muffled <- TRUE
[13:23:07.794]                             break
[13:23:07.794]                           }
[13:23:07.794]                         }
[13:23:07.794]                       }
[13:23:07.794]                       invisible(muffled)
[13:23:07.794]                     }
[13:23:07.794]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.794]                   }
[13:23:07.794]                 }
[13:23:07.794]                 else {
[13:23:07.794]                   if (TRUE) {
[13:23:07.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.794]                     {
[13:23:07.794]                       inherits <- base::inherits
[13:23:07.794]                       invokeRestart <- base::invokeRestart
[13:23:07.794]                       is.null <- base::is.null
[13:23:07.794]                       muffled <- FALSE
[13:23:07.794]                       if (inherits(cond, "message")) {
[13:23:07.794]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.794]                         if (muffled) 
[13:23:07.794]                           invokeRestart("muffleMessage")
[13:23:07.794]                       }
[13:23:07.794]                       else if (inherits(cond, "warning")) {
[13:23:07.794]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.794]                         if (muffled) 
[13:23:07.794]                           invokeRestart("muffleWarning")
[13:23:07.794]                       }
[13:23:07.794]                       else if (inherits(cond, "condition")) {
[13:23:07.794]                         if (!is.null(pattern)) {
[13:23:07.794]                           computeRestarts <- base::computeRestarts
[13:23:07.794]                           grepl <- base::grepl
[13:23:07.794]                           restarts <- computeRestarts(cond)
[13:23:07.794]                           for (restart in restarts) {
[13:23:07.794]                             name <- restart$name
[13:23:07.794]                             if (is.null(name)) 
[13:23:07.794]                               next
[13:23:07.794]                             if (!grepl(pattern, name)) 
[13:23:07.794]                               next
[13:23:07.794]                             invokeRestart(restart)
[13:23:07.794]                             muffled <- TRUE
[13:23:07.794]                             break
[13:23:07.794]                           }
[13:23:07.794]                         }
[13:23:07.794]                       }
[13:23:07.794]                       invisible(muffled)
[13:23:07.794]                     }
[13:23:07.794]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.794]                   }
[13:23:07.794]                 }
[13:23:07.794]             }
[13:23:07.794]         }))
[13:23:07.794]     }, error = function(ex) {
[13:23:07.794]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.794]                 ...future.rng), started = ...future.startTime, 
[13:23:07.794]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.794]             version = "1.8"), class = "FutureResult")
[13:23:07.794]     }, finally = {
[13:23:07.794]         if (!identical(...future.workdir, getwd())) 
[13:23:07.794]             setwd(...future.workdir)
[13:23:07.794]         {
[13:23:07.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.794]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.794]             }
[13:23:07.794]             base::options(...future.oldOptions)
[13:23:07.794]             if (.Platform$OS.type == "windows") {
[13:23:07.794]                 old_names <- names(...future.oldEnvVars)
[13:23:07.794]                 envs <- base::Sys.getenv()
[13:23:07.794]                 names <- names(envs)
[13:23:07.794]                 common <- intersect(names, old_names)
[13:23:07.794]                 added <- setdiff(names, old_names)
[13:23:07.794]                 removed <- setdiff(old_names, names)
[13:23:07.794]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.794]                   envs[common]]
[13:23:07.794]                 NAMES <- toupper(changed)
[13:23:07.794]                 args <- list()
[13:23:07.794]                 for (kk in seq_along(NAMES)) {
[13:23:07.794]                   name <- changed[[kk]]
[13:23:07.794]                   NAME <- NAMES[[kk]]
[13:23:07.794]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.794]                     next
[13:23:07.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.794]                 }
[13:23:07.794]                 NAMES <- toupper(added)
[13:23:07.794]                 for (kk in seq_along(NAMES)) {
[13:23:07.794]                   name <- added[[kk]]
[13:23:07.794]                   NAME <- NAMES[[kk]]
[13:23:07.794]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.794]                     next
[13:23:07.794]                   args[[name]] <- ""
[13:23:07.794]                 }
[13:23:07.794]                 NAMES <- toupper(removed)
[13:23:07.794]                 for (kk in seq_along(NAMES)) {
[13:23:07.794]                   name <- removed[[kk]]
[13:23:07.794]                   NAME <- NAMES[[kk]]
[13:23:07.794]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.794]                     next
[13:23:07.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.794]                 }
[13:23:07.794]                 if (length(args) > 0) 
[13:23:07.794]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.794]             }
[13:23:07.794]             else {
[13:23:07.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.794]             }
[13:23:07.794]             {
[13:23:07.794]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.794]                   0L) {
[13:23:07.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.794]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.794]                   base::options(opts)
[13:23:07.794]                 }
[13:23:07.794]                 {
[13:23:07.794]                   {
[13:23:07.794]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.794]                     NULL
[13:23:07.794]                   }
[13:23:07.794]                   options(future.plan = NULL)
[13:23:07.794]                   if (is.na(NA_character_)) 
[13:23:07.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.794]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.794]                     envir = parent.frame()) 
[13:23:07.794]                   {
[13:23:07.794]                     default_workers <- missing(workers)
[13:23:07.794]                     if (is.function(workers)) 
[13:23:07.794]                       workers <- workers()
[13:23:07.794]                     workers <- structure(as.integer(workers), 
[13:23:07.794]                       class = class(workers))
[13:23:07.794]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.794]                       1L)
[13:23:07.794]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.794]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.794]                       if (default_workers) 
[13:23:07.794]                         supportsMulticore(warn = TRUE)
[13:23:07.794]                       return(sequential(..., envir = envir))
[13:23:07.794]                     }
[13:23:07.794]                     oopts <- options(mc.cores = workers)
[13:23:07.794]                     on.exit(options(oopts))
[13:23:07.794]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.794]                       envir = envir)
[13:23:07.794]                     if (!future$lazy) 
[13:23:07.794]                       future <- run(future)
[13:23:07.794]                     invisible(future)
[13:23:07.794]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.794]                 }
[13:23:07.794]             }
[13:23:07.794]         }
[13:23:07.794]     })
[13:23:07.794]     if (TRUE) {
[13:23:07.794]         base::sink(type = "output", split = FALSE)
[13:23:07.794]         if (TRUE) {
[13:23:07.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.794]         }
[13:23:07.794]         else {
[13:23:07.794]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.794]         }
[13:23:07.794]         base::close(...future.stdout)
[13:23:07.794]         ...future.stdout <- NULL
[13:23:07.794]     }
[13:23:07.794]     ...future.result$conditions <- ...future.conditions
[13:23:07.794]     ...future.result$finished <- base::Sys.time()
[13:23:07.794]     ...future.result
[13:23:07.794] }
[13:23:07.798] requestCore(): workers = 2
[13:23:07.798] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:07.809] result() for MulticoreFuture ...
[13:23:07.810] result() for MulticoreFuture ...
[13:23:07.810] result() for MulticoreFuture ... done
[13:23:07.811] result() for MulticoreFuture ... done
[13:23:07.811] result() for MulticoreFuture ...
[13:23:07.811] result() for MulticoreFuture ... done
[13:23:07.815] MulticoreFuture started
[13:23:07.815] - Launch lazy future ... done
[13:23:07.816] run() for ‘MulticoreFuture’ ... done
[13:23:07.816] plan(): Setting new future strategy stack:
<environment: 0x5596d77a0588> 
[13:23:07.817] List of future strategies:
[13:23:07.817] 1. sequential:
[13:23:07.817]    - args: function (..., envir = parent.frame())
[13:23:07.817]    - tweaked: FALSE
[13:23:07.817]    - call: NULL
[13:23:07.818] plan(): nbrOfWorkers() = 1
<environment: 0x5596d42528c8> 
[13:23:07.820] plan(): Setting new future strategy stack:
[13:23:07.820] List of future strategies:
[13:23:07.820] 1. multicore:
[13:23:07.820]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.820]    - tweaked: FALSE
[13:23:07.820]    - call: plan(strategy)
[13:23:07.826] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:07.829] resolve() on environment ...
[13:23:07.829]  recursive: 0
[13:23:07.830]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:07.830] signalConditionsASAP(numeric, pos=1) ...
[13:23:07.830] - nx: 4
[13:23:07.830] - relay: TRUE
[13:23:07.831] - stdout: TRUE
[13:23:07.831] - signal: TRUE
[13:23:07.831] - resignal: FALSE
[13:23:07.831] - force: TRUE
[13:23:07.831] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.831] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.832]  - until=2
[13:23:07.832]  - relaying element #2
[13:23:07.832] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:07.832] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.832] signalConditionsASAP(NULL, pos=1) ... done
[13:23:07.833]  length: 3 (resolved future 1)
[13:23:07.833] Future #2
[13:23:07.833] result() for MulticoreFuture ...
[13:23:07.833] result() for MulticoreFuture ... done
[13:23:07.833] result() for MulticoreFuture ...
[13:23:07.833] result() for MulticoreFuture ... done
[13:23:07.834] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:07.834] - nx: 4
[13:23:07.834] - relay: TRUE
[13:23:07.834] - stdout: TRUE
[13:23:07.834] - signal: TRUE
[13:23:07.834] - resignal: FALSE
[13:23:07.834] - force: TRUE
[13:23:07.835] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:07.835] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.835]  - until=2
[13:23:07.835]  - relaying element #2
[13:23:07.835] result() for MulticoreFuture ...
[13:23:07.835] result() for MulticoreFuture ... done
[13:23:07.835] result() for MulticoreFuture ...
[13:23:07.836] result() for MulticoreFuture ... done
[13:23:07.836] result() for MulticoreFuture ...
[13:23:07.836] result() for MulticoreFuture ... done
[13:23:07.836] result() for MulticoreFuture ...
[13:23:07.836] result() for MulticoreFuture ... done
[13:23:07.836] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:07.837] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:07.837] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:07.837]  length: 2 (resolved future 2)
[13:23:07.837] Future #3
[13:23:07.838] result() for MulticoreFuture ...
[13:23:07.839] result() for MulticoreFuture ...
[13:23:07.839] result() for MulticoreFuture ... done
[13:23:07.839] result() for MulticoreFuture ... done
[13:23:07.839] result() for MulticoreFuture ...
[13:23:07.839] result() for MulticoreFuture ... done
[13:23:07.839] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:07.839] - nx: 4
[13:23:07.840] - relay: TRUE
[13:23:07.840] - stdout: TRUE
[13:23:07.840] - signal: TRUE
[13:23:07.840] - resignal: FALSE
[13:23:07.840] - force: TRUE
[13:23:07.840] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:07.840] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:07.841]  - until=3
[13:23:07.841]  - relaying element #3
[13:23:07.841] result() for MulticoreFuture ...
[13:23:07.841] result() for MulticoreFuture ... done
[13:23:07.841] result() for MulticoreFuture ...
[13:23:07.841] result() for MulticoreFuture ... done
[13:23:07.842] result() for MulticoreFuture ...
[13:23:07.842] result() for MulticoreFuture ... done
[13:23:07.842] result() for MulticoreFuture ...
[13:23:07.842] result() for MulticoreFuture ... done
[13:23:07.842] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:07.842] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:07.842] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:07.843]  length: 1 (resolved future 3)
[13:23:07.843] Future #4
[13:23:07.843] result() for MulticoreFuture ...
[13:23:07.844] result() for MulticoreFuture ...
[13:23:07.844] result() for MulticoreFuture ... done
[13:23:07.844] result() for MulticoreFuture ... done
[13:23:07.845] result() for MulticoreFuture ...
[13:23:07.845] result() for MulticoreFuture ... done
[13:23:07.845] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:07.845] - nx: 4
[13:23:07.845] - relay: TRUE
[13:23:07.845] - stdout: TRUE
[13:23:07.846] - signal: TRUE
[13:23:07.846] - resignal: FALSE
[13:23:07.846] - force: TRUE
[13:23:07.846] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:07.846] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:07.846]  - until=4
[13:23:07.847]  - relaying element #4
[13:23:07.847] result() for MulticoreFuture ...
[13:23:07.847] result() for MulticoreFuture ... done
[13:23:07.847] result() for MulticoreFuture ...
[13:23:07.847] result() for MulticoreFuture ... done
[13:23:07.847] result() for MulticoreFuture ...
[13:23:07.848] result() for MulticoreFuture ... done
[13:23:07.848] result() for MulticoreFuture ...
[13:23:07.848] result() for MulticoreFuture ... done
[13:23:07.848] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.848] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:07.848] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:07.848]  length: 0 (resolved future 4)
[13:23:07.849] Relaying remaining futures
[13:23:07.849] signalConditionsASAP(NULL, pos=0) ...
[13:23:07.849] - nx: 4
[13:23:07.849] - relay: TRUE
[13:23:07.849] - stdout: TRUE
[13:23:07.849] - signal: TRUE
[13:23:07.849] - resignal: FALSE
[13:23:07.849] - force: TRUE
[13:23:07.849] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.849] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:07.850] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.850] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:07.850] signalConditionsASAP(NULL, pos=0) ... done
[13:23:07.850] resolve() on environment ... DONE
[13:23:07.850] result() for MulticoreFuture ...
[13:23:07.850] result() for MulticoreFuture ... done
[13:23:07.850] result() for MulticoreFuture ...
[13:23:07.850] result() for MulticoreFuture ... done
[13:23:07.851] result() for MulticoreFuture ...
[13:23:07.851] result() for MulticoreFuture ... done
[13:23:07.851] result() for MulticoreFuture ...
[13:23:07.851] result() for MulticoreFuture ... done
[13:23:07.851] result() for MulticoreFuture ...
[13:23:07.851] result() for MulticoreFuture ... done
[13:23:07.851] result() for MulticoreFuture ...
[13:23:07.851] result() for MulticoreFuture ... done
<environment: 0x5596d4298e30> 
Dimensions: c(2, 3, 1)
[13:23:07.852] getGlobalsAndPackages() ...
[13:23:07.852] Searching for globals...
[13:23:07.853] 
[13:23:07.853] Searching for globals ... DONE
[13:23:07.853] - globals: [0] <none>
[13:23:07.853] getGlobalsAndPackages() ... DONE
[13:23:07.853] run() for ‘Future’ ...
[13:23:07.853] - state: ‘created’
[13:23:07.853] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.858] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.858] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.858]   - Field: ‘label’
[13:23:07.858]   - Field: ‘local’
[13:23:07.858]   - Field: ‘owner’
[13:23:07.859]   - Field: ‘envir’
[13:23:07.859]   - Field: ‘workers’
[13:23:07.859]   - Field: ‘packages’
[13:23:07.859]   - Field: ‘gc’
[13:23:07.859]   - Field: ‘job’
[13:23:07.859]   - Field: ‘conditions’
[13:23:07.859]   - Field: ‘expr’
[13:23:07.859]   - Field: ‘uuid’
[13:23:07.859]   - Field: ‘seed’
[13:23:07.860]   - Field: ‘version’
[13:23:07.860]   - Field: ‘result’
[13:23:07.860]   - Field: ‘asynchronous’
[13:23:07.860]   - Field: ‘calls’
[13:23:07.860]   - Field: ‘globals’
[13:23:07.860]   - Field: ‘stdout’
[13:23:07.860]   - Field: ‘earlySignal’
[13:23:07.860]   - Field: ‘lazy’
[13:23:07.861]   - Field: ‘state’
[13:23:07.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.861] - Launch lazy future ...
[13:23:07.861] Packages needed by the future expression (n = 0): <none>
[13:23:07.861] Packages needed by future strategies (n = 0): <none>
[13:23:07.862] {
[13:23:07.862]     {
[13:23:07.862]         {
[13:23:07.862]             ...future.startTime <- base::Sys.time()
[13:23:07.862]             {
[13:23:07.862]                 {
[13:23:07.862]                   {
[13:23:07.862]                     {
[13:23:07.862]                       base::local({
[13:23:07.862]                         has_future <- base::requireNamespace("future", 
[13:23:07.862]                           quietly = TRUE)
[13:23:07.862]                         if (has_future) {
[13:23:07.862]                           ns <- base::getNamespace("future")
[13:23:07.862]                           version <- ns[[".package"]][["version"]]
[13:23:07.862]                           if (is.null(version)) 
[13:23:07.862]                             version <- utils::packageVersion("future")
[13:23:07.862]                         }
[13:23:07.862]                         else {
[13:23:07.862]                           version <- NULL
[13:23:07.862]                         }
[13:23:07.862]                         if (!has_future || version < "1.8.0") {
[13:23:07.862]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.862]                             "", base::R.version$version.string), 
[13:23:07.862]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.862]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.862]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.862]                               "release", "version")], collapse = " "), 
[13:23:07.862]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.862]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.862]                             info)
[13:23:07.862]                           info <- base::paste(info, collapse = "; ")
[13:23:07.862]                           if (!has_future) {
[13:23:07.862]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.862]                               info)
[13:23:07.862]                           }
[13:23:07.862]                           else {
[13:23:07.862]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.862]                               info, version)
[13:23:07.862]                           }
[13:23:07.862]                           base::stop(msg)
[13:23:07.862]                         }
[13:23:07.862]                       })
[13:23:07.862]                     }
[13:23:07.862]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.862]                     base::options(mc.cores = 1L)
[13:23:07.862]                   }
[13:23:07.862]                   options(future.plan = NULL)
[13:23:07.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.862]                 }
[13:23:07.862]                 ...future.workdir <- getwd()
[13:23:07.862]             }
[13:23:07.862]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.862]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.862]         }
[13:23:07.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.862]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.862]             base::names(...future.oldOptions))
[13:23:07.862]     }
[13:23:07.862]     if (FALSE) {
[13:23:07.862]     }
[13:23:07.862]     else {
[13:23:07.862]         if (TRUE) {
[13:23:07.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.862]                 open = "w")
[13:23:07.862]         }
[13:23:07.862]         else {
[13:23:07.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.862]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.862]         }
[13:23:07.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.862]             base::sink(type = "output", split = FALSE)
[13:23:07.862]             base::close(...future.stdout)
[13:23:07.862]         }, add = TRUE)
[13:23:07.862]     }
[13:23:07.862]     ...future.frame <- base::sys.nframe()
[13:23:07.862]     ...future.conditions <- base::list()
[13:23:07.862]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.862]     if (FALSE) {
[13:23:07.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.862]     }
[13:23:07.862]     ...future.result <- base::tryCatch({
[13:23:07.862]         base::withCallingHandlers({
[13:23:07.862]             ...future.value <- base::withVisible(base::local({
[13:23:07.862]                 withCallingHandlers({
[13:23:07.862]                   2
[13:23:07.862]                 }, immediateCondition = function(cond) {
[13:23:07.862]                   save_rds <- function (object, pathname, ...) 
[13:23:07.862]                   {
[13:23:07.862]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.862]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.862]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.862]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.862]                         fi_tmp[["mtime"]])
[13:23:07.862]                     }
[13:23:07.862]                     tryCatch({
[13:23:07.862]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.862]                     }, error = function(ex) {
[13:23:07.862]                       msg <- conditionMessage(ex)
[13:23:07.862]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.862]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.862]                         fi_tmp[["mtime"]], msg)
[13:23:07.862]                       ex$message <- msg
[13:23:07.862]                       stop(ex)
[13:23:07.862]                     })
[13:23:07.862]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.862]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.862]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.862]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.862]                       fi <- file.info(pathname)
[13:23:07.862]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.862]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.862]                         fi[["size"]], fi[["mtime"]])
[13:23:07.862]                       stop(msg)
[13:23:07.862]                     }
[13:23:07.862]                     invisible(pathname)
[13:23:07.862]                   }
[13:23:07.862]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.862]                     rootPath = tempdir()) 
[13:23:07.862]                   {
[13:23:07.862]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.862]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.862]                       tmpdir = path, fileext = ".rds")
[13:23:07.862]                     save_rds(obj, file)
[13:23:07.862]                   }
[13:23:07.862]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.862]                   {
[13:23:07.862]                     inherits <- base::inherits
[13:23:07.862]                     invokeRestart <- base::invokeRestart
[13:23:07.862]                     is.null <- base::is.null
[13:23:07.862]                     muffled <- FALSE
[13:23:07.862]                     if (inherits(cond, "message")) {
[13:23:07.862]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.862]                       if (muffled) 
[13:23:07.862]                         invokeRestart("muffleMessage")
[13:23:07.862]                     }
[13:23:07.862]                     else if (inherits(cond, "warning")) {
[13:23:07.862]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.862]                       if (muffled) 
[13:23:07.862]                         invokeRestart("muffleWarning")
[13:23:07.862]                     }
[13:23:07.862]                     else if (inherits(cond, "condition")) {
[13:23:07.862]                       if (!is.null(pattern)) {
[13:23:07.862]                         computeRestarts <- base::computeRestarts
[13:23:07.862]                         grepl <- base::grepl
[13:23:07.862]                         restarts <- computeRestarts(cond)
[13:23:07.862]                         for (restart in restarts) {
[13:23:07.862]                           name <- restart$name
[13:23:07.862]                           if (is.null(name)) 
[13:23:07.862]                             next
[13:23:07.862]                           if (!grepl(pattern, name)) 
[13:23:07.862]                             next
[13:23:07.862]                           invokeRestart(restart)
[13:23:07.862]                           muffled <- TRUE
[13:23:07.862]                           break
[13:23:07.862]                         }
[13:23:07.862]                       }
[13:23:07.862]                     }
[13:23:07.862]                     invisible(muffled)
[13:23:07.862]                   }
[13:23:07.862]                   muffleCondition(cond)
[13:23:07.862]                 })
[13:23:07.862]             }))
[13:23:07.862]             future::FutureResult(value = ...future.value$value, 
[13:23:07.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.862]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.862]                     ...future.globalenv.names))
[13:23:07.862]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.862]         }, condition = base::local({
[13:23:07.862]             c <- base::c
[13:23:07.862]             inherits <- base::inherits
[13:23:07.862]             invokeRestart <- base::invokeRestart
[13:23:07.862]             length <- base::length
[13:23:07.862]             list <- base::list
[13:23:07.862]             seq.int <- base::seq.int
[13:23:07.862]             signalCondition <- base::signalCondition
[13:23:07.862]             sys.calls <- base::sys.calls
[13:23:07.862]             `[[` <- base::`[[`
[13:23:07.862]             `+` <- base::`+`
[13:23:07.862]             `<<-` <- base::`<<-`
[13:23:07.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.862]                   3L)]
[13:23:07.862]             }
[13:23:07.862]             function(cond) {
[13:23:07.862]                 is_error <- inherits(cond, "error")
[13:23:07.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.862]                   NULL)
[13:23:07.862]                 if (is_error) {
[13:23:07.862]                   sessionInformation <- function() {
[13:23:07.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.862]                       search = base::search(), system = base::Sys.info())
[13:23:07.862]                   }
[13:23:07.862]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.862]                     cond$call), session = sessionInformation(), 
[13:23:07.862]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.862]                   signalCondition(cond)
[13:23:07.862]                 }
[13:23:07.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.862]                 "immediateCondition"))) {
[13:23:07.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.862]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.862]                   if (TRUE && !signal) {
[13:23:07.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.862]                     {
[13:23:07.862]                       inherits <- base::inherits
[13:23:07.862]                       invokeRestart <- base::invokeRestart
[13:23:07.862]                       is.null <- base::is.null
[13:23:07.862]                       muffled <- FALSE
[13:23:07.862]                       if (inherits(cond, "message")) {
[13:23:07.862]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.862]                         if (muffled) 
[13:23:07.862]                           invokeRestart("muffleMessage")
[13:23:07.862]                       }
[13:23:07.862]                       else if (inherits(cond, "warning")) {
[13:23:07.862]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.862]                         if (muffled) 
[13:23:07.862]                           invokeRestart("muffleWarning")
[13:23:07.862]                       }
[13:23:07.862]                       else if (inherits(cond, "condition")) {
[13:23:07.862]                         if (!is.null(pattern)) {
[13:23:07.862]                           computeRestarts <- base::computeRestarts
[13:23:07.862]                           grepl <- base::grepl
[13:23:07.862]                           restarts <- computeRestarts(cond)
[13:23:07.862]                           for (restart in restarts) {
[13:23:07.862]                             name <- restart$name
[13:23:07.862]                             if (is.null(name)) 
[13:23:07.862]                               next
[13:23:07.862]                             if (!grepl(pattern, name)) 
[13:23:07.862]                               next
[13:23:07.862]                             invokeRestart(restart)
[13:23:07.862]                             muffled <- TRUE
[13:23:07.862]                             break
[13:23:07.862]                           }
[13:23:07.862]                         }
[13:23:07.862]                       }
[13:23:07.862]                       invisible(muffled)
[13:23:07.862]                     }
[13:23:07.862]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.862]                   }
[13:23:07.862]                 }
[13:23:07.862]                 else {
[13:23:07.862]                   if (TRUE) {
[13:23:07.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.862]                     {
[13:23:07.862]                       inherits <- base::inherits
[13:23:07.862]                       invokeRestart <- base::invokeRestart
[13:23:07.862]                       is.null <- base::is.null
[13:23:07.862]                       muffled <- FALSE
[13:23:07.862]                       if (inherits(cond, "message")) {
[13:23:07.862]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.862]                         if (muffled) 
[13:23:07.862]                           invokeRestart("muffleMessage")
[13:23:07.862]                       }
[13:23:07.862]                       else if (inherits(cond, "warning")) {
[13:23:07.862]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.862]                         if (muffled) 
[13:23:07.862]                           invokeRestart("muffleWarning")
[13:23:07.862]                       }
[13:23:07.862]                       else if (inherits(cond, "condition")) {
[13:23:07.862]                         if (!is.null(pattern)) {
[13:23:07.862]                           computeRestarts <- base::computeRestarts
[13:23:07.862]                           grepl <- base::grepl
[13:23:07.862]                           restarts <- computeRestarts(cond)
[13:23:07.862]                           for (restart in restarts) {
[13:23:07.862]                             name <- restart$name
[13:23:07.862]                             if (is.null(name)) 
[13:23:07.862]                               next
[13:23:07.862]                             if (!grepl(pattern, name)) 
[13:23:07.862]                               next
[13:23:07.862]                             invokeRestart(restart)
[13:23:07.862]                             muffled <- TRUE
[13:23:07.862]                             break
[13:23:07.862]                           }
[13:23:07.862]                         }
[13:23:07.862]                       }
[13:23:07.862]                       invisible(muffled)
[13:23:07.862]                     }
[13:23:07.862]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.862]                   }
[13:23:07.862]                 }
[13:23:07.862]             }
[13:23:07.862]         }))
[13:23:07.862]     }, error = function(ex) {
[13:23:07.862]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.862]                 ...future.rng), started = ...future.startTime, 
[13:23:07.862]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.862]             version = "1.8"), class = "FutureResult")
[13:23:07.862]     }, finally = {
[13:23:07.862]         if (!identical(...future.workdir, getwd())) 
[13:23:07.862]             setwd(...future.workdir)
[13:23:07.862]         {
[13:23:07.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.862]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.862]             }
[13:23:07.862]             base::options(...future.oldOptions)
[13:23:07.862]             if (.Platform$OS.type == "windows") {
[13:23:07.862]                 old_names <- names(...future.oldEnvVars)
[13:23:07.862]                 envs <- base::Sys.getenv()
[13:23:07.862]                 names <- names(envs)
[13:23:07.862]                 common <- intersect(names, old_names)
[13:23:07.862]                 added <- setdiff(names, old_names)
[13:23:07.862]                 removed <- setdiff(old_names, names)
[13:23:07.862]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.862]                   envs[common]]
[13:23:07.862]                 NAMES <- toupper(changed)
[13:23:07.862]                 args <- list()
[13:23:07.862]                 for (kk in seq_along(NAMES)) {
[13:23:07.862]                   name <- changed[[kk]]
[13:23:07.862]                   NAME <- NAMES[[kk]]
[13:23:07.862]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.862]                     next
[13:23:07.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.862]                 }
[13:23:07.862]                 NAMES <- toupper(added)
[13:23:07.862]                 for (kk in seq_along(NAMES)) {
[13:23:07.862]                   name <- added[[kk]]
[13:23:07.862]                   NAME <- NAMES[[kk]]
[13:23:07.862]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.862]                     next
[13:23:07.862]                   args[[name]] <- ""
[13:23:07.862]                 }
[13:23:07.862]                 NAMES <- toupper(removed)
[13:23:07.862]                 for (kk in seq_along(NAMES)) {
[13:23:07.862]                   name <- removed[[kk]]
[13:23:07.862]                   NAME <- NAMES[[kk]]
[13:23:07.862]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.862]                     next
[13:23:07.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.862]                 }
[13:23:07.862]                 if (length(args) > 0) 
[13:23:07.862]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.862]             }
[13:23:07.862]             else {
[13:23:07.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.862]             }
[13:23:07.862]             {
[13:23:07.862]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.862]                   0L) {
[13:23:07.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.862]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.862]                   base::options(opts)
[13:23:07.862]                 }
[13:23:07.862]                 {
[13:23:07.862]                   {
[13:23:07.862]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.862]                     NULL
[13:23:07.862]                   }
[13:23:07.862]                   options(future.plan = NULL)
[13:23:07.862]                   if (is.na(NA_character_)) 
[13:23:07.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.862]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.862]                     envir = parent.frame()) 
[13:23:07.862]                   {
[13:23:07.862]                     default_workers <- missing(workers)
[13:23:07.862]                     if (is.function(workers)) 
[13:23:07.862]                       workers <- workers()
[13:23:07.862]                     workers <- structure(as.integer(workers), 
[13:23:07.862]                       class = class(workers))
[13:23:07.862]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.862]                       1L)
[13:23:07.862]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.862]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.862]                       if (default_workers) 
[13:23:07.862]                         supportsMulticore(warn = TRUE)
[13:23:07.862]                       return(sequential(..., envir = envir))
[13:23:07.862]                     }
[13:23:07.862]                     oopts <- options(mc.cores = workers)
[13:23:07.862]                     on.exit(options(oopts))
[13:23:07.862]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.862]                       envir = envir)
[13:23:07.862]                     if (!future$lazy) 
[13:23:07.862]                       future <- run(future)
[13:23:07.862]                     invisible(future)
[13:23:07.862]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.862]                 }
[13:23:07.862]             }
[13:23:07.862]         }
[13:23:07.862]     })
[13:23:07.862]     if (TRUE) {
[13:23:07.862]         base::sink(type = "output", split = FALSE)
[13:23:07.862]         if (TRUE) {
[13:23:07.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.862]         }
[13:23:07.862]         else {
[13:23:07.862]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.862]         }
[13:23:07.862]         base::close(...future.stdout)
[13:23:07.862]         ...future.stdout <- NULL
[13:23:07.862]     }
[13:23:07.862]     ...future.result$conditions <- ...future.conditions
[13:23:07.862]     ...future.result$finished <- base::Sys.time()
[13:23:07.862]     ...future.result
[13:23:07.862] }
[13:23:07.865] requestCore(): workers = 2
[13:23:07.868] MulticoreFuture started
[13:23:07.868] - Launch lazy future ... done
[13:23:07.868] run() for ‘MulticoreFuture’ ... done
[13:23:07.869] getGlobalsAndPackages() ...
[13:23:07.869] Searching for globals...
[13:23:07.869] plan(): Setting new future strategy stack:
[13:23:07.870] 
[13:23:07.870] Searching for globals ... DONE
[13:23:07.870] - globals: [0] <none>
[13:23:07.869] List of future strategies:
[13:23:07.869] 1. sequential:
[13:23:07.869]    - args: function (..., envir = parent.frame())
[13:23:07.869]    - tweaked: FALSE
[13:23:07.869]    - call: NULL
[13:23:07.870] getGlobalsAndPackages() ... DONE
[13:23:07.870] plan(): nbrOfWorkers() = 1
[13:23:07.871] run() for ‘Future’ ...
[13:23:07.871] - state: ‘created’
[13:23:07.871] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.872] plan(): Setting new future strategy stack:
[13:23:07.872] List of future strategies:
[13:23:07.872] 1. multicore:
[13:23:07.872]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.872]    - tweaked: FALSE
[13:23:07.872]    - call: plan(strategy)
[13:23:07.877] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.877] plan(): nbrOfWorkers() = 2
[13:23:07.877] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.877]   - Field: ‘label’
[13:23:07.878]   - Field: ‘local’
[13:23:07.878]   - Field: ‘owner’
[13:23:07.878]   - Field: ‘envir’
[13:23:07.878]   - Field: ‘workers’
[13:23:07.878]   - Field: ‘packages’
[13:23:07.878]   - Field: ‘gc’
[13:23:07.878]   - Field: ‘job’
[13:23:07.879]   - Field: ‘conditions’
[13:23:07.879]   - Field: ‘expr’
[13:23:07.879]   - Field: ‘uuid’
[13:23:07.879]   - Field: ‘seed’
[13:23:07.879]   - Field: ‘version’
[13:23:07.879]   - Field: ‘result’
[13:23:07.879]   - Field: ‘asynchronous’
[13:23:07.880]   - Field: ‘calls’
[13:23:07.880]   - Field: ‘globals’
[13:23:07.880]   - Field: ‘stdout’
[13:23:07.880]   - Field: ‘earlySignal’
[13:23:07.880]   - Field: ‘lazy’
[13:23:07.880]   - Field: ‘state’
[13:23:07.881] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.881] - Launch lazy future ...
[13:23:07.881] Packages needed by the future expression (n = 0): <none>
[13:23:07.881] Packages needed by future strategies (n = 0): <none>
[13:23:07.882] {
[13:23:07.882]     {
[13:23:07.882]         {
[13:23:07.882]             ...future.startTime <- base::Sys.time()
[13:23:07.882]             {
[13:23:07.882]                 {
[13:23:07.882]                   {
[13:23:07.882]                     {
[13:23:07.882]                       base::local({
[13:23:07.882]                         has_future <- base::requireNamespace("future", 
[13:23:07.882]                           quietly = TRUE)
[13:23:07.882]                         if (has_future) {
[13:23:07.882]                           ns <- base::getNamespace("future")
[13:23:07.882]                           version <- ns[[".package"]][["version"]]
[13:23:07.882]                           if (is.null(version)) 
[13:23:07.882]                             version <- utils::packageVersion("future")
[13:23:07.882]                         }
[13:23:07.882]                         else {
[13:23:07.882]                           version <- NULL
[13:23:07.882]                         }
[13:23:07.882]                         if (!has_future || version < "1.8.0") {
[13:23:07.882]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.882]                             "", base::R.version$version.string), 
[13:23:07.882]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.882]                               "release", "version")], collapse = " "), 
[13:23:07.882]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.882]                             info)
[13:23:07.882]                           info <- base::paste(info, collapse = "; ")
[13:23:07.882]                           if (!has_future) {
[13:23:07.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.882]                               info)
[13:23:07.882]                           }
[13:23:07.882]                           else {
[13:23:07.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.882]                               info, version)
[13:23:07.882]                           }
[13:23:07.882]                           base::stop(msg)
[13:23:07.882]                         }
[13:23:07.882]                       })
[13:23:07.882]                     }
[13:23:07.882]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.882]                     base::options(mc.cores = 1L)
[13:23:07.882]                   }
[13:23:07.882]                   options(future.plan = NULL)
[13:23:07.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.882]                 }
[13:23:07.882]                 ...future.workdir <- getwd()
[13:23:07.882]             }
[13:23:07.882]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.882]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.882]         }
[13:23:07.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.882]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.882]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.882]             base::names(...future.oldOptions))
[13:23:07.882]     }
[13:23:07.882]     if (FALSE) {
[13:23:07.882]     }
[13:23:07.882]     else {
[13:23:07.882]         if (TRUE) {
[13:23:07.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.882]                 open = "w")
[13:23:07.882]         }
[13:23:07.882]         else {
[13:23:07.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.882]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.882]         }
[13:23:07.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.882]             base::sink(type = "output", split = FALSE)
[13:23:07.882]             base::close(...future.stdout)
[13:23:07.882]         }, add = TRUE)
[13:23:07.882]     }
[13:23:07.882]     ...future.frame <- base::sys.nframe()
[13:23:07.882]     ...future.conditions <- base::list()
[13:23:07.882]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.882]     if (FALSE) {
[13:23:07.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.882]     }
[13:23:07.882]     ...future.result <- base::tryCatch({
[13:23:07.882]         base::withCallingHandlers({
[13:23:07.882]             ...future.value <- base::withVisible(base::local({
[13:23:07.882]                 withCallingHandlers({
[13:23:07.882]                   NULL
[13:23:07.882]                 }, immediateCondition = function(cond) {
[13:23:07.882]                   save_rds <- function (object, pathname, ...) 
[13:23:07.882]                   {
[13:23:07.882]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.882]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.882]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.882]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.882]                         fi_tmp[["mtime"]])
[13:23:07.882]                     }
[13:23:07.882]                     tryCatch({
[13:23:07.882]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.882]                     }, error = function(ex) {
[13:23:07.882]                       msg <- conditionMessage(ex)
[13:23:07.882]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.882]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.882]                         fi_tmp[["mtime"]], msg)
[13:23:07.882]                       ex$message <- msg
[13:23:07.882]                       stop(ex)
[13:23:07.882]                     })
[13:23:07.882]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.882]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.882]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.882]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.882]                       fi <- file.info(pathname)
[13:23:07.882]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.882]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.882]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.882]                         fi[["size"]], fi[["mtime"]])
[13:23:07.882]                       stop(msg)
[13:23:07.882]                     }
[13:23:07.882]                     invisible(pathname)
[13:23:07.882]                   }
[13:23:07.882]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.882]                     rootPath = tempdir()) 
[13:23:07.882]                   {
[13:23:07.882]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.882]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.882]                       tmpdir = path, fileext = ".rds")
[13:23:07.882]                     save_rds(obj, file)
[13:23:07.882]                   }
[13:23:07.882]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.882]                   {
[13:23:07.882]                     inherits <- base::inherits
[13:23:07.882]                     invokeRestart <- base::invokeRestart
[13:23:07.882]                     is.null <- base::is.null
[13:23:07.882]                     muffled <- FALSE
[13:23:07.882]                     if (inherits(cond, "message")) {
[13:23:07.882]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.882]                       if (muffled) 
[13:23:07.882]                         invokeRestart("muffleMessage")
[13:23:07.882]                     }
[13:23:07.882]                     else if (inherits(cond, "warning")) {
[13:23:07.882]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.882]                       if (muffled) 
[13:23:07.882]                         invokeRestart("muffleWarning")
[13:23:07.882]                     }
[13:23:07.882]                     else if (inherits(cond, "condition")) {
[13:23:07.882]                       if (!is.null(pattern)) {
[13:23:07.882]                         computeRestarts <- base::computeRestarts
[13:23:07.882]                         grepl <- base::grepl
[13:23:07.882]                         restarts <- computeRestarts(cond)
[13:23:07.882]                         for (restart in restarts) {
[13:23:07.882]                           name <- restart$name
[13:23:07.882]                           if (is.null(name)) 
[13:23:07.882]                             next
[13:23:07.882]                           if (!grepl(pattern, name)) 
[13:23:07.882]                             next
[13:23:07.882]                           invokeRestart(restart)
[13:23:07.882]                           muffled <- TRUE
[13:23:07.882]                           break
[13:23:07.882]                         }
[13:23:07.882]                       }
[13:23:07.882]                     }
[13:23:07.882]                     invisible(muffled)
[13:23:07.882]                   }
[13:23:07.882]                   muffleCondition(cond)
[13:23:07.882]                 })
[13:23:07.882]             }))
[13:23:07.882]             future::FutureResult(value = ...future.value$value, 
[13:23:07.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.882]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.882]                     ...future.globalenv.names))
[13:23:07.882]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.882]         }, condition = base::local({
[13:23:07.882]             c <- base::c
[13:23:07.882]             inherits <- base::inherits
[13:23:07.882]             invokeRestart <- base::invokeRestart
[13:23:07.882]             length <- base::length
[13:23:07.882]             list <- base::list
[13:23:07.882]             seq.int <- base::seq.int
[13:23:07.882]             signalCondition <- base::signalCondition
[13:23:07.882]             sys.calls <- base::sys.calls
[13:23:07.882]             `[[` <- base::`[[`
[13:23:07.882]             `+` <- base::`+`
[13:23:07.882]             `<<-` <- base::`<<-`
[13:23:07.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.882]                   3L)]
[13:23:07.882]             }
[13:23:07.882]             function(cond) {
[13:23:07.882]                 is_error <- inherits(cond, "error")
[13:23:07.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.882]                   NULL)
[13:23:07.882]                 if (is_error) {
[13:23:07.882]                   sessionInformation <- function() {
[13:23:07.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.882]                       search = base::search(), system = base::Sys.info())
[13:23:07.882]                   }
[13:23:07.882]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.882]                     cond$call), session = sessionInformation(), 
[13:23:07.882]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.882]                   signalCondition(cond)
[13:23:07.882]                 }
[13:23:07.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.882]                 "immediateCondition"))) {
[13:23:07.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.882]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.882]                   if (TRUE && !signal) {
[13:23:07.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.882]                     {
[13:23:07.882]                       inherits <- base::inherits
[13:23:07.882]                       invokeRestart <- base::invokeRestart
[13:23:07.882]                       is.null <- base::is.null
[13:23:07.882]                       muffled <- FALSE
[13:23:07.882]                       if (inherits(cond, "message")) {
[13:23:07.882]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.882]                         if (muffled) 
[13:23:07.882]                           invokeRestart("muffleMessage")
[13:23:07.882]                       }
[13:23:07.882]                       else if (inherits(cond, "warning")) {
[13:23:07.882]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.882]                         if (muffled) 
[13:23:07.882]                           invokeRestart("muffleWarning")
[13:23:07.882]                       }
[13:23:07.882]                       else if (inherits(cond, "condition")) {
[13:23:07.882]                         if (!is.null(pattern)) {
[13:23:07.882]                           computeRestarts <- base::computeRestarts
[13:23:07.882]                           grepl <- base::grepl
[13:23:07.882]                           restarts <- computeRestarts(cond)
[13:23:07.882]                           for (restart in restarts) {
[13:23:07.882]                             name <- restart$name
[13:23:07.882]                             if (is.null(name)) 
[13:23:07.882]                               next
[13:23:07.882]                             if (!grepl(pattern, name)) 
[13:23:07.882]                               next
[13:23:07.882]                             invokeRestart(restart)
[13:23:07.882]                             muffled <- TRUE
[13:23:07.882]                             break
[13:23:07.882]                           }
[13:23:07.882]                         }
[13:23:07.882]                       }
[13:23:07.882]                       invisible(muffled)
[13:23:07.882]                     }
[13:23:07.882]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.882]                   }
[13:23:07.882]                 }
[13:23:07.882]                 else {
[13:23:07.882]                   if (TRUE) {
[13:23:07.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.882]                     {
[13:23:07.882]                       inherits <- base::inherits
[13:23:07.882]                       invokeRestart <- base::invokeRestart
[13:23:07.882]                       is.null <- base::is.null
[13:23:07.882]                       muffled <- FALSE
[13:23:07.882]                       if (inherits(cond, "message")) {
[13:23:07.882]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.882]                         if (muffled) 
[13:23:07.882]                           invokeRestart("muffleMessage")
[13:23:07.882]                       }
[13:23:07.882]                       else if (inherits(cond, "warning")) {
[13:23:07.882]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.882]                         if (muffled) 
[13:23:07.882]                           invokeRestart("muffleWarning")
[13:23:07.882]                       }
[13:23:07.882]                       else if (inherits(cond, "condition")) {
[13:23:07.882]                         if (!is.null(pattern)) {
[13:23:07.882]                           computeRestarts <- base::computeRestarts
[13:23:07.882]                           grepl <- base::grepl
[13:23:07.882]                           restarts <- computeRestarts(cond)
[13:23:07.882]                           for (restart in restarts) {
[13:23:07.882]                             name <- restart$name
[13:23:07.882]                             if (is.null(name)) 
[13:23:07.882]                               next
[13:23:07.882]                             if (!grepl(pattern, name)) 
[13:23:07.882]                               next
[13:23:07.882]                             invokeRestart(restart)
[13:23:07.882]                             muffled <- TRUE
[13:23:07.882]                             break
[13:23:07.882]                           }
[13:23:07.882]                         }
[13:23:07.882]                       }
[13:23:07.882]                       invisible(muffled)
[13:23:07.882]                     }
[13:23:07.882]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.882]                   }
[13:23:07.882]                 }
[13:23:07.882]             }
[13:23:07.882]         }))
[13:23:07.882]     }, error = function(ex) {
[13:23:07.882]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.882]                 ...future.rng), started = ...future.startTime, 
[13:23:07.882]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.882]             version = "1.8"), class = "FutureResult")
[13:23:07.882]     }, finally = {
[13:23:07.882]         if (!identical(...future.workdir, getwd())) 
[13:23:07.882]             setwd(...future.workdir)
[13:23:07.882]         {
[13:23:07.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.882]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.882]             }
[13:23:07.882]             base::options(...future.oldOptions)
[13:23:07.882]             if (.Platform$OS.type == "windows") {
[13:23:07.882]                 old_names <- names(...future.oldEnvVars)
[13:23:07.882]                 envs <- base::Sys.getenv()
[13:23:07.882]                 names <- names(envs)
[13:23:07.882]                 common <- intersect(names, old_names)
[13:23:07.882]                 added <- setdiff(names, old_names)
[13:23:07.882]                 removed <- setdiff(old_names, names)
[13:23:07.882]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.882]                   envs[common]]
[13:23:07.882]                 NAMES <- toupper(changed)
[13:23:07.882]                 args <- list()
[13:23:07.882]                 for (kk in seq_along(NAMES)) {
[13:23:07.882]                   name <- changed[[kk]]
[13:23:07.882]                   NAME <- NAMES[[kk]]
[13:23:07.882]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.882]                     next
[13:23:07.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.882]                 }
[13:23:07.882]                 NAMES <- toupper(added)
[13:23:07.882]                 for (kk in seq_along(NAMES)) {
[13:23:07.882]                   name <- added[[kk]]
[13:23:07.882]                   NAME <- NAMES[[kk]]
[13:23:07.882]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.882]                     next
[13:23:07.882]                   args[[name]] <- ""
[13:23:07.882]                 }
[13:23:07.882]                 NAMES <- toupper(removed)
[13:23:07.882]                 for (kk in seq_along(NAMES)) {
[13:23:07.882]                   name <- removed[[kk]]
[13:23:07.882]                   NAME <- NAMES[[kk]]
[13:23:07.882]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.882]                     next
[13:23:07.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.882]                 }
[13:23:07.882]                 if (length(args) > 0) 
[13:23:07.882]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.882]             }
[13:23:07.882]             else {
[13:23:07.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.882]             }
[13:23:07.882]             {
[13:23:07.882]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.882]                   0L) {
[13:23:07.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.882]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.882]                   base::options(opts)
[13:23:07.882]                 }
[13:23:07.882]                 {
[13:23:07.882]                   {
[13:23:07.882]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.882]                     NULL
[13:23:07.882]                   }
[13:23:07.882]                   options(future.plan = NULL)
[13:23:07.882]                   if (is.na(NA_character_)) 
[13:23:07.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.882]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.882]                     envir = parent.frame()) 
[13:23:07.882]                   {
[13:23:07.882]                     default_workers <- missing(workers)
[13:23:07.882]                     if (is.function(workers)) 
[13:23:07.882]                       workers <- workers()
[13:23:07.882]                     workers <- structure(as.integer(workers), 
[13:23:07.882]                       class = class(workers))
[13:23:07.882]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.882]                       1L)
[13:23:07.882]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.882]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.882]                       if (default_workers) 
[13:23:07.882]                         supportsMulticore(warn = TRUE)
[13:23:07.882]                       return(sequential(..., envir = envir))
[13:23:07.882]                     }
[13:23:07.882]                     oopts <- options(mc.cores = workers)
[13:23:07.882]                     on.exit(options(oopts))
[13:23:07.882]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.882]                       envir = envir)
[13:23:07.882]                     if (!future$lazy) 
[13:23:07.882]                       future <- run(future)
[13:23:07.882]                     invisible(future)
[13:23:07.882]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.882]                 }
[13:23:07.882]             }
[13:23:07.882]         }
[13:23:07.882]     })
[13:23:07.882]     if (TRUE) {
[13:23:07.882]         base::sink(type = "output", split = FALSE)
[13:23:07.882]         if (TRUE) {
[13:23:07.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.882]         }
[13:23:07.882]         else {
[13:23:07.882]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.882]         }
[13:23:07.882]         base::close(...future.stdout)
[13:23:07.882]         ...future.stdout <- NULL
[13:23:07.882]     }
[13:23:07.882]     ...future.result$conditions <- ...future.conditions
[13:23:07.882]     ...future.result$finished <- base::Sys.time()
[13:23:07.882]     ...future.result
[13:23:07.882] }
[13:23:07.886] requestCore(): workers = 2
[13:23:07.889] MulticoreFuture started
[13:23:07.890] - Launch lazy future ... done
[13:23:07.890] run() for ‘MulticoreFuture’ ... done
[13:23:07.890] plan(): Setting new future strategy stack:
[13:23:07.891] getGlobalsAndPackages() ...
[13:23:07.891] Searching for globals...
[13:23:07.891] List of future strategies:
[13:23:07.891] 1. sequential:
[13:23:07.891]    - args: function (..., envir = parent.frame())
[13:23:07.891]    - tweaked: FALSE
[13:23:07.891]    - call: NULL
[13:23:07.891] plan(): nbrOfWorkers() = 1
[13:23:07.892] - globals found: [1] ‘{’
[13:23:07.892] Searching for globals ... DONE
[13:23:07.893] Resolving globals: FALSE
[13:23:07.893] 
[13:23:07.893] 
[13:23:07.893] getGlobalsAndPackages() ... DONE
[13:23:07.894] plan(): Setting new future strategy stack:
[13:23:07.894] run() for ‘Future’ ...
[13:23:07.894] - state: ‘created’
[13:23:07.894] List of future strategies:
[13:23:07.894] 1. multicore:
[13:23:07.894]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.894]    - tweaked: FALSE
[13:23:07.894]    - call: plan(strategy)
[13:23:07.894] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.900] plan(): nbrOfWorkers() = 2
[13:23:07.900] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.901]   - Field: ‘label’
[13:23:07.901]   - Field: ‘local’
[13:23:07.901]   - Field: ‘owner’
[13:23:07.901]   - Field: ‘envir’
[13:23:07.901]   - Field: ‘workers’
[13:23:07.901]   - Field: ‘packages’
[13:23:07.902]   - Field: ‘gc’
[13:23:07.902]   - Field: ‘job’
[13:23:07.902]   - Field: ‘conditions’
[13:23:07.902]   - Field: ‘expr’
[13:23:07.902]   - Field: ‘uuid’
[13:23:07.902]   - Field: ‘seed’
[13:23:07.902]   - Field: ‘version’
[13:23:07.903]   - Field: ‘result’
[13:23:07.903]   - Field: ‘asynchronous’
[13:23:07.903]   - Field: ‘calls’
[13:23:07.903]   - Field: ‘globals’
[13:23:07.903]   - Field: ‘stdout’
[13:23:07.903]   - Field: ‘earlySignal’
[13:23:07.903]   - Field: ‘lazy’
[13:23:07.904]   - Field: ‘state’
[13:23:07.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.904] - Launch lazy future ...
[13:23:07.904] Packages needed by the future expression (n = 0): <none>
[13:23:07.905] Packages needed by future strategies (n = 0): <none>
[13:23:07.905] {
[13:23:07.905]     {
[13:23:07.905]         {
[13:23:07.905]             ...future.startTime <- base::Sys.time()
[13:23:07.905]             {
[13:23:07.905]                 {
[13:23:07.905]                   {
[13:23:07.905]                     {
[13:23:07.905]                       base::local({
[13:23:07.905]                         has_future <- base::requireNamespace("future", 
[13:23:07.905]                           quietly = TRUE)
[13:23:07.905]                         if (has_future) {
[13:23:07.905]                           ns <- base::getNamespace("future")
[13:23:07.905]                           version <- ns[[".package"]][["version"]]
[13:23:07.905]                           if (is.null(version)) 
[13:23:07.905]                             version <- utils::packageVersion("future")
[13:23:07.905]                         }
[13:23:07.905]                         else {
[13:23:07.905]                           version <- NULL
[13:23:07.905]                         }
[13:23:07.905]                         if (!has_future || version < "1.8.0") {
[13:23:07.905]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.905]                             "", base::R.version$version.string), 
[13:23:07.905]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.905]                               "release", "version")], collapse = " "), 
[13:23:07.905]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.905]                             info)
[13:23:07.905]                           info <- base::paste(info, collapse = "; ")
[13:23:07.905]                           if (!has_future) {
[13:23:07.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.905]                               info)
[13:23:07.905]                           }
[13:23:07.905]                           else {
[13:23:07.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.905]                               info, version)
[13:23:07.905]                           }
[13:23:07.905]                           base::stop(msg)
[13:23:07.905]                         }
[13:23:07.905]                       })
[13:23:07.905]                     }
[13:23:07.905]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.905]                     base::options(mc.cores = 1L)
[13:23:07.905]                   }
[13:23:07.905]                   options(future.plan = NULL)
[13:23:07.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.905]                 }
[13:23:07.905]                 ...future.workdir <- getwd()
[13:23:07.905]             }
[13:23:07.905]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.905]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.905]         }
[13:23:07.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.905]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.905]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.905]             base::names(...future.oldOptions))
[13:23:07.905]     }
[13:23:07.905]     if (FALSE) {
[13:23:07.905]     }
[13:23:07.905]     else {
[13:23:07.905]         if (TRUE) {
[13:23:07.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.905]                 open = "w")
[13:23:07.905]         }
[13:23:07.905]         else {
[13:23:07.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.905]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.905]         }
[13:23:07.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.905]             base::sink(type = "output", split = FALSE)
[13:23:07.905]             base::close(...future.stdout)
[13:23:07.905]         }, add = TRUE)
[13:23:07.905]     }
[13:23:07.905]     ...future.frame <- base::sys.nframe()
[13:23:07.905]     ...future.conditions <- base::list()
[13:23:07.905]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.905]     if (FALSE) {
[13:23:07.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.905]     }
[13:23:07.905]     ...future.result <- base::tryCatch({
[13:23:07.905]         base::withCallingHandlers({
[13:23:07.905]             ...future.value <- base::withVisible(base::local({
[13:23:07.905]                 withCallingHandlers({
[13:23:07.905]                   {
[13:23:07.905]                     4
[13:23:07.905]                   }
[13:23:07.905]                 }, immediateCondition = function(cond) {
[13:23:07.905]                   save_rds <- function (object, pathname, ...) 
[13:23:07.905]                   {
[13:23:07.905]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.905]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.905]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.905]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.905]                         fi_tmp[["mtime"]])
[13:23:07.905]                     }
[13:23:07.905]                     tryCatch({
[13:23:07.905]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.905]                     }, error = function(ex) {
[13:23:07.905]                       msg <- conditionMessage(ex)
[13:23:07.905]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.905]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.905]                         fi_tmp[["mtime"]], msg)
[13:23:07.905]                       ex$message <- msg
[13:23:07.905]                       stop(ex)
[13:23:07.905]                     })
[13:23:07.905]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.905]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.905]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.905]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.905]                       fi <- file.info(pathname)
[13:23:07.905]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.905]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.905]                         fi[["size"]], fi[["mtime"]])
[13:23:07.905]                       stop(msg)
[13:23:07.905]                     }
[13:23:07.905]                     invisible(pathname)
[13:23:07.905]                   }
[13:23:07.905]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.905]                     rootPath = tempdir()) 
[13:23:07.905]                   {
[13:23:07.905]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.905]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.905]                       tmpdir = path, fileext = ".rds")
[13:23:07.905]                     save_rds(obj, file)
[13:23:07.905]                   }
[13:23:07.905]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.905]                   {
[13:23:07.905]                     inherits <- base::inherits
[13:23:07.905]                     invokeRestart <- base::invokeRestart
[13:23:07.905]                     is.null <- base::is.null
[13:23:07.905]                     muffled <- FALSE
[13:23:07.905]                     if (inherits(cond, "message")) {
[13:23:07.905]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.905]                       if (muffled) 
[13:23:07.905]                         invokeRestart("muffleMessage")
[13:23:07.905]                     }
[13:23:07.905]                     else if (inherits(cond, "warning")) {
[13:23:07.905]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.905]                       if (muffled) 
[13:23:07.905]                         invokeRestart("muffleWarning")
[13:23:07.905]                     }
[13:23:07.905]                     else if (inherits(cond, "condition")) {
[13:23:07.905]                       if (!is.null(pattern)) {
[13:23:07.905]                         computeRestarts <- base::computeRestarts
[13:23:07.905]                         grepl <- base::grepl
[13:23:07.905]                         restarts <- computeRestarts(cond)
[13:23:07.905]                         for (restart in restarts) {
[13:23:07.905]                           name <- restart$name
[13:23:07.905]                           if (is.null(name)) 
[13:23:07.905]                             next
[13:23:07.905]                           if (!grepl(pattern, name)) 
[13:23:07.905]                             next
[13:23:07.905]                           invokeRestart(restart)
[13:23:07.905]                           muffled <- TRUE
[13:23:07.905]                           break
[13:23:07.905]                         }
[13:23:07.905]                       }
[13:23:07.905]                     }
[13:23:07.905]                     invisible(muffled)
[13:23:07.905]                   }
[13:23:07.905]                   muffleCondition(cond)
[13:23:07.905]                 })
[13:23:07.905]             }))
[13:23:07.905]             future::FutureResult(value = ...future.value$value, 
[13:23:07.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.905]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.905]                     ...future.globalenv.names))
[13:23:07.905]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.905]         }, condition = base::local({
[13:23:07.905]             c <- base::c
[13:23:07.905]             inherits <- base::inherits
[13:23:07.905]             invokeRestart <- base::invokeRestart
[13:23:07.905]             length <- base::length
[13:23:07.905]             list <- base::list
[13:23:07.905]             seq.int <- base::seq.int
[13:23:07.905]             signalCondition <- base::signalCondition
[13:23:07.905]             sys.calls <- base::sys.calls
[13:23:07.905]             `[[` <- base::`[[`
[13:23:07.905]             `+` <- base::`+`
[13:23:07.905]             `<<-` <- base::`<<-`
[13:23:07.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.905]                   3L)]
[13:23:07.905]             }
[13:23:07.905]             function(cond) {
[13:23:07.905]                 is_error <- inherits(cond, "error")
[13:23:07.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.905]                   NULL)
[13:23:07.905]                 if (is_error) {
[13:23:07.905]                   sessionInformation <- function() {
[13:23:07.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.905]                       search = base::search(), system = base::Sys.info())
[13:23:07.905]                   }
[13:23:07.905]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.905]                     cond$call), session = sessionInformation(), 
[13:23:07.905]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.905]                   signalCondition(cond)
[13:23:07.905]                 }
[13:23:07.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.905]                 "immediateCondition"))) {
[13:23:07.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.905]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.905]                   if (TRUE && !signal) {
[13:23:07.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.905]                     {
[13:23:07.905]                       inherits <- base::inherits
[13:23:07.905]                       invokeRestart <- base::invokeRestart
[13:23:07.905]                       is.null <- base::is.null
[13:23:07.905]                       muffled <- FALSE
[13:23:07.905]                       if (inherits(cond, "message")) {
[13:23:07.905]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.905]                         if (muffled) 
[13:23:07.905]                           invokeRestart("muffleMessage")
[13:23:07.905]                       }
[13:23:07.905]                       else if (inherits(cond, "warning")) {
[13:23:07.905]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.905]                         if (muffled) 
[13:23:07.905]                           invokeRestart("muffleWarning")
[13:23:07.905]                       }
[13:23:07.905]                       else if (inherits(cond, "condition")) {
[13:23:07.905]                         if (!is.null(pattern)) {
[13:23:07.905]                           computeRestarts <- base::computeRestarts
[13:23:07.905]                           grepl <- base::grepl
[13:23:07.905]                           restarts <- computeRestarts(cond)
[13:23:07.905]                           for (restart in restarts) {
[13:23:07.905]                             name <- restart$name
[13:23:07.905]                             if (is.null(name)) 
[13:23:07.905]                               next
[13:23:07.905]                             if (!grepl(pattern, name)) 
[13:23:07.905]                               next
[13:23:07.905]                             invokeRestart(restart)
[13:23:07.905]                             muffled <- TRUE
[13:23:07.905]                             break
[13:23:07.905]                           }
[13:23:07.905]                         }
[13:23:07.905]                       }
[13:23:07.905]                       invisible(muffled)
[13:23:07.905]                     }
[13:23:07.905]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.905]                   }
[13:23:07.905]                 }
[13:23:07.905]                 else {
[13:23:07.905]                   if (TRUE) {
[13:23:07.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.905]                     {
[13:23:07.905]                       inherits <- base::inherits
[13:23:07.905]                       invokeRestart <- base::invokeRestart
[13:23:07.905]                       is.null <- base::is.null
[13:23:07.905]                       muffled <- FALSE
[13:23:07.905]                       if (inherits(cond, "message")) {
[13:23:07.905]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.905]                         if (muffled) 
[13:23:07.905]                           invokeRestart("muffleMessage")
[13:23:07.905]                       }
[13:23:07.905]                       else if (inherits(cond, "warning")) {
[13:23:07.905]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.905]                         if (muffled) 
[13:23:07.905]                           invokeRestart("muffleWarning")
[13:23:07.905]                       }
[13:23:07.905]                       else if (inherits(cond, "condition")) {
[13:23:07.905]                         if (!is.null(pattern)) {
[13:23:07.905]                           computeRestarts <- base::computeRestarts
[13:23:07.905]                           grepl <- base::grepl
[13:23:07.905]                           restarts <- computeRestarts(cond)
[13:23:07.905]                           for (restart in restarts) {
[13:23:07.905]                             name <- restart$name
[13:23:07.905]                             if (is.null(name)) 
[13:23:07.905]                               next
[13:23:07.905]                             if (!grepl(pattern, name)) 
[13:23:07.905]                               next
[13:23:07.905]                             invokeRestart(restart)
[13:23:07.905]                             muffled <- TRUE
[13:23:07.905]                             break
[13:23:07.905]                           }
[13:23:07.905]                         }
[13:23:07.905]                       }
[13:23:07.905]                       invisible(muffled)
[13:23:07.905]                     }
[13:23:07.905]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.905]                   }
[13:23:07.905]                 }
[13:23:07.905]             }
[13:23:07.905]         }))
[13:23:07.905]     }, error = function(ex) {
[13:23:07.905]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.905]                 ...future.rng), started = ...future.startTime, 
[13:23:07.905]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.905]             version = "1.8"), class = "FutureResult")
[13:23:07.905]     }, finally = {
[13:23:07.905]         if (!identical(...future.workdir, getwd())) 
[13:23:07.905]             setwd(...future.workdir)
[13:23:07.905]         {
[13:23:07.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.905]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.905]             }
[13:23:07.905]             base::options(...future.oldOptions)
[13:23:07.905]             if (.Platform$OS.type == "windows") {
[13:23:07.905]                 old_names <- names(...future.oldEnvVars)
[13:23:07.905]                 envs <- base::Sys.getenv()
[13:23:07.905]                 names <- names(envs)
[13:23:07.905]                 common <- intersect(names, old_names)
[13:23:07.905]                 added <- setdiff(names, old_names)
[13:23:07.905]                 removed <- setdiff(old_names, names)
[13:23:07.905]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.905]                   envs[common]]
[13:23:07.905]                 NAMES <- toupper(changed)
[13:23:07.905]                 args <- list()
[13:23:07.905]                 for (kk in seq_along(NAMES)) {
[13:23:07.905]                   name <- changed[[kk]]
[13:23:07.905]                   NAME <- NAMES[[kk]]
[13:23:07.905]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.905]                     next
[13:23:07.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.905]                 }
[13:23:07.905]                 NAMES <- toupper(added)
[13:23:07.905]                 for (kk in seq_along(NAMES)) {
[13:23:07.905]                   name <- added[[kk]]
[13:23:07.905]                   NAME <- NAMES[[kk]]
[13:23:07.905]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.905]                     next
[13:23:07.905]                   args[[name]] <- ""
[13:23:07.905]                 }
[13:23:07.905]                 NAMES <- toupper(removed)
[13:23:07.905]                 for (kk in seq_along(NAMES)) {
[13:23:07.905]                   name <- removed[[kk]]
[13:23:07.905]                   NAME <- NAMES[[kk]]
[13:23:07.905]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.905]                     next
[13:23:07.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.905]                 }
[13:23:07.905]                 if (length(args) > 0) 
[13:23:07.905]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.905]             }
[13:23:07.905]             else {
[13:23:07.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.905]             }
[13:23:07.905]             {
[13:23:07.905]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.905]                   0L) {
[13:23:07.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.905]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.905]                   base::options(opts)
[13:23:07.905]                 }
[13:23:07.905]                 {
[13:23:07.905]                   {
[13:23:07.905]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.905]                     NULL
[13:23:07.905]                   }
[13:23:07.905]                   options(future.plan = NULL)
[13:23:07.905]                   if (is.na(NA_character_)) 
[13:23:07.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.905]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.905]                     envir = parent.frame()) 
[13:23:07.905]                   {
[13:23:07.905]                     default_workers <- missing(workers)
[13:23:07.905]                     if (is.function(workers)) 
[13:23:07.905]                       workers <- workers()
[13:23:07.905]                     workers <- structure(as.integer(workers), 
[13:23:07.905]                       class = class(workers))
[13:23:07.905]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.905]                       1L)
[13:23:07.905]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.905]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.905]                       if (default_workers) 
[13:23:07.905]                         supportsMulticore(warn = TRUE)
[13:23:07.905]                       return(sequential(..., envir = envir))
[13:23:07.905]                     }
[13:23:07.905]                     oopts <- options(mc.cores = workers)
[13:23:07.905]                     on.exit(options(oopts))
[13:23:07.905]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.905]                       envir = envir)
[13:23:07.905]                     if (!future$lazy) 
[13:23:07.905]                       future <- run(future)
[13:23:07.905]                     invisible(future)
[13:23:07.905]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.905]                 }
[13:23:07.905]             }
[13:23:07.905]         }
[13:23:07.905]     })
[13:23:07.905]     if (TRUE) {
[13:23:07.905]         base::sink(type = "output", split = FALSE)
[13:23:07.905]         if (TRUE) {
[13:23:07.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.905]         }
[13:23:07.905]         else {
[13:23:07.905]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.905]         }
[13:23:07.905]         base::close(...future.stdout)
[13:23:07.905]         ...future.stdout <- NULL
[13:23:07.905]     }
[13:23:07.905]     ...future.result$conditions <- ...future.conditions
[13:23:07.905]     ...future.result$finished <- base::Sys.time()
[13:23:07.905]     ...future.result
[13:23:07.905] }
[13:23:07.909] requestCore(): workers = 2
[13:23:07.910] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:07.921] result() for MulticoreFuture ...
[13:23:07.922] result() for MulticoreFuture ...
[13:23:07.922] result() for MulticoreFuture ... done
[13:23:07.922] result() for MulticoreFuture ... done
[13:23:07.922] result() for MulticoreFuture ...
[13:23:07.923] result() for MulticoreFuture ... done
[13:23:07.926] MulticoreFuture started
[13:23:07.927] - Launch lazy future ... done
[13:23:07.927] run() for ‘MulticoreFuture’ ... done
[13:23:07.928] plan(): Setting new future strategy stack:
<environment: 0x5596d68a8580> 
[13:23:07.928] List of future strategies:
[13:23:07.928] 1. sequential:
[13:23:07.928]    - args: function (..., envir = parent.frame())
[13:23:07.928]    - tweaked: FALSE
[13:23:07.928]    - call: NULL
[13:23:07.929] plan(): nbrOfWorkers() = 1
<environment: 0x5596d745fc40> 
[13:23:07.931] plan(): Setting new future strategy stack:
[13:23:07.931] List of future strategies:
[13:23:07.931] 1. multicore:
[13:23:07.931]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.931]    - tweaked: FALSE
[13:23:07.931]    - call: plan(strategy)
[13:23:07.936] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:07.939] resolve() on environment ...
[13:23:07.939]  recursive: 0
[13:23:07.940]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:07.940] signalConditionsASAP(numeric, pos=1) ...
[13:23:07.940] - nx: 4
[13:23:07.940] - relay: TRUE
[13:23:07.940] - stdout: TRUE
[13:23:07.941] - signal: TRUE
[13:23:07.941] - resignal: FALSE
[13:23:07.941] - force: TRUE
[13:23:07.941] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.941] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.941]  - until=2
[13:23:07.941]  - relaying element #2
[13:23:07.942] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:07.942] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.942] signalConditionsASAP(NULL, pos=1) ... done
[13:23:07.942]  length: 3 (resolved future 1)
[13:23:07.942] Future #2
[13:23:07.942] result() for MulticoreFuture ...
[13:23:07.942] result() for MulticoreFuture ... done
[13:23:07.943] result() for MulticoreFuture ...
[13:23:07.943] result() for MulticoreFuture ... done
[13:23:07.943] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:07.943] - nx: 4
[13:23:07.943] - relay: TRUE
[13:23:07.943] - stdout: TRUE
[13:23:07.943] - signal: TRUE
[13:23:07.944] - resignal: FALSE
[13:23:07.944] - force: TRUE
[13:23:07.944] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:07.944] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:07.944]  - until=2
[13:23:07.944]  - relaying element #2
[13:23:07.944] result() for MulticoreFuture ...
[13:23:07.944] result() for MulticoreFuture ... done
[13:23:07.945] result() for MulticoreFuture ...
[13:23:07.945] result() for MulticoreFuture ... done
[13:23:07.945] result() for MulticoreFuture ...
[13:23:07.945] result() for MulticoreFuture ... done
[13:23:07.945] result() for MulticoreFuture ...
[13:23:07.945] result() for MulticoreFuture ... done
[13:23:07.945] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:07.946] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:07.946] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:07.946]  length: 2 (resolved future 2)
[13:23:07.946] Future #3
[13:23:07.946] result() for MulticoreFuture ...
[13:23:07.947] result() for MulticoreFuture ...
[13:23:07.947] result() for MulticoreFuture ... done
[13:23:07.948] result() for MulticoreFuture ... done
[13:23:07.948] result() for MulticoreFuture ...
[13:23:07.961] result() for MulticoreFuture ... done
[13:23:07.962] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:07.962] - nx: 4
[13:23:07.962] - relay: TRUE
[13:23:07.962] - stdout: TRUE
[13:23:07.962] - signal: TRUE
[13:23:07.962] - resignal: FALSE
[13:23:07.963] - force: TRUE
[13:23:07.963] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:07.963] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:07.963]  - until=3
[13:23:07.963]  - relaying element #3
[13:23:07.963] result() for MulticoreFuture ...
[13:23:07.963] result() for MulticoreFuture ... done
[13:23:07.964] result() for MulticoreFuture ...
[13:23:07.964] result() for MulticoreFuture ... done
[13:23:07.964] result() for MulticoreFuture ...
[13:23:07.964] result() for MulticoreFuture ... done
[13:23:07.964] result() for MulticoreFuture ...
[13:23:07.964] result() for MulticoreFuture ... done
[13:23:07.964] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:07.965] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:07.965] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:07.965]  length: 1 (resolved future 3)
[13:23:07.965] Future #4
[13:23:07.966] result() for MulticoreFuture ...
[13:23:07.966] result() for MulticoreFuture ...
[13:23:07.966] result() for MulticoreFuture ... done
[13:23:07.967] result() for MulticoreFuture ... done
[13:23:07.967] result() for MulticoreFuture ...
[13:23:07.967] result() for MulticoreFuture ... done
[13:23:07.967] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:07.967] - nx: 4
[13:23:07.967] - relay: TRUE
[13:23:07.967] - stdout: TRUE
[13:23:07.967] - signal: TRUE
[13:23:07.968] - resignal: FALSE
[13:23:07.968] - force: TRUE
[13:23:07.968] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:07.968] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:07.968]  - until=4
[13:23:07.968]  - relaying element #4
[13:23:07.968] result() for MulticoreFuture ...
[13:23:07.968] result() for MulticoreFuture ... done
[13:23:07.969] result() for MulticoreFuture ...
[13:23:07.969] result() for MulticoreFuture ... done
[13:23:07.969] result() for MulticoreFuture ...
[13:23:07.969] result() for MulticoreFuture ... done
[13:23:07.969] result() for MulticoreFuture ...
[13:23:07.969] result() for MulticoreFuture ... done
[13:23:07.969] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.969] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:07.970] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:07.970]  length: 0 (resolved future 4)
[13:23:07.970] Relaying remaining futures
[13:23:07.970] signalConditionsASAP(NULL, pos=0) ...
[13:23:07.970] - nx: 4
[13:23:07.970] - relay: TRUE
[13:23:07.970] - stdout: TRUE
[13:23:07.970] - signal: TRUE
[13:23:07.970] - resignal: FALSE
[13:23:07.970] - force: TRUE
[13:23:07.970] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.971] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:07.971] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:07.971] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:07.971] signalConditionsASAP(NULL, pos=0) ... done
[13:23:07.971] resolve() on environment ... DONE
[13:23:07.971] result() for MulticoreFuture ...
[13:23:07.971] result() for MulticoreFuture ... done
[13:23:07.971] result() for MulticoreFuture ...
[13:23:07.972] result() for MulticoreFuture ... done
[13:23:07.972] result() for MulticoreFuture ...
[13:23:07.972] result() for MulticoreFuture ... done
[13:23:07.972] result() for MulticoreFuture ...
[13:23:07.972] result() for MulticoreFuture ... done
[13:23:07.972] result() for MulticoreFuture ...
[13:23:07.972] result() for MulticoreFuture ... done
[13:23:07.972] result() for MulticoreFuture ...
[13:23:07.973] result() for MulticoreFuture ... done
<environment: 0x5596d7516258> 
Dimensions: c(2, 1, 3, 1)
[13:23:07.973] getGlobalsAndPackages() ...
[13:23:07.973] Searching for globals...
[13:23:07.974] 
[13:23:07.974] Searching for globals ... DONE
[13:23:07.974] - globals: [0] <none>
[13:23:07.974] getGlobalsAndPackages() ... DONE
[13:23:07.974] run() for ‘Future’ ...
[13:23:07.974] - state: ‘created’
[13:23:07.975] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.980] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.980] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.980]   - Field: ‘label’
[13:23:07.980]   - Field: ‘local’
[13:23:07.980]   - Field: ‘owner’
[13:23:07.981]   - Field: ‘envir’
[13:23:07.981]   - Field: ‘workers’
[13:23:07.981]   - Field: ‘packages’
[13:23:07.981]   - Field: ‘gc’
[13:23:07.981]   - Field: ‘job’
[13:23:07.981]   - Field: ‘conditions’
[13:23:07.981]   - Field: ‘expr’
[13:23:07.981]   - Field: ‘uuid’
[13:23:07.981]   - Field: ‘seed’
[13:23:07.981]   - Field: ‘version’
[13:23:07.982]   - Field: ‘result’
[13:23:07.982]   - Field: ‘asynchronous’
[13:23:07.982]   - Field: ‘calls’
[13:23:07.982]   - Field: ‘globals’
[13:23:07.982]   - Field: ‘stdout’
[13:23:07.982]   - Field: ‘earlySignal’
[13:23:07.982]   - Field: ‘lazy’
[13:23:07.982]   - Field: ‘state’
[13:23:07.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:07.983] - Launch lazy future ...
[13:23:07.983] Packages needed by the future expression (n = 0): <none>
[13:23:07.983] Packages needed by future strategies (n = 0): <none>
[13:23:07.984] {
[13:23:07.984]     {
[13:23:07.984]         {
[13:23:07.984]             ...future.startTime <- base::Sys.time()
[13:23:07.984]             {
[13:23:07.984]                 {
[13:23:07.984]                   {
[13:23:07.984]                     {
[13:23:07.984]                       base::local({
[13:23:07.984]                         has_future <- base::requireNamespace("future", 
[13:23:07.984]                           quietly = TRUE)
[13:23:07.984]                         if (has_future) {
[13:23:07.984]                           ns <- base::getNamespace("future")
[13:23:07.984]                           version <- ns[[".package"]][["version"]]
[13:23:07.984]                           if (is.null(version)) 
[13:23:07.984]                             version <- utils::packageVersion("future")
[13:23:07.984]                         }
[13:23:07.984]                         else {
[13:23:07.984]                           version <- NULL
[13:23:07.984]                         }
[13:23:07.984]                         if (!has_future || version < "1.8.0") {
[13:23:07.984]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:07.984]                             "", base::R.version$version.string), 
[13:23:07.984]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:07.984]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:07.984]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:07.984]                               "release", "version")], collapse = " "), 
[13:23:07.984]                             hostname = base::Sys.info()[["nodename"]])
[13:23:07.984]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:07.984]                             info)
[13:23:07.984]                           info <- base::paste(info, collapse = "; ")
[13:23:07.984]                           if (!has_future) {
[13:23:07.984]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:07.984]                               info)
[13:23:07.984]                           }
[13:23:07.984]                           else {
[13:23:07.984]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:07.984]                               info, version)
[13:23:07.984]                           }
[13:23:07.984]                           base::stop(msg)
[13:23:07.984]                         }
[13:23:07.984]                       })
[13:23:07.984]                     }
[13:23:07.984]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:07.984]                     base::options(mc.cores = 1L)
[13:23:07.984]                   }
[13:23:07.984]                   options(future.plan = NULL)
[13:23:07.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:07.984]                 }
[13:23:07.984]                 ...future.workdir <- getwd()
[13:23:07.984]             }
[13:23:07.984]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:07.984]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:07.984]         }
[13:23:07.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:07.984]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:07.984]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:07.984]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:07.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:07.984]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:07.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:07.984]             base::names(...future.oldOptions))
[13:23:07.984]     }
[13:23:07.984]     if (FALSE) {
[13:23:07.984]     }
[13:23:07.984]     else {
[13:23:07.984]         if (TRUE) {
[13:23:07.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:07.984]                 open = "w")
[13:23:07.984]         }
[13:23:07.984]         else {
[13:23:07.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:07.984]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:07.984]         }
[13:23:07.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:07.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:07.984]             base::sink(type = "output", split = FALSE)
[13:23:07.984]             base::close(...future.stdout)
[13:23:07.984]         }, add = TRUE)
[13:23:07.984]     }
[13:23:07.984]     ...future.frame <- base::sys.nframe()
[13:23:07.984]     ...future.conditions <- base::list()
[13:23:07.984]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:07.984]     if (FALSE) {
[13:23:07.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:07.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:07.984]     }
[13:23:07.984]     ...future.result <- base::tryCatch({
[13:23:07.984]         base::withCallingHandlers({
[13:23:07.984]             ...future.value <- base::withVisible(base::local({
[13:23:07.984]                 withCallingHandlers({
[13:23:07.984]                   2
[13:23:07.984]                 }, immediateCondition = function(cond) {
[13:23:07.984]                   save_rds <- function (object, pathname, ...) 
[13:23:07.984]                   {
[13:23:07.984]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:07.984]                     if (file_test("-f", pathname_tmp)) {
[13:23:07.984]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.984]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:07.984]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.984]                         fi_tmp[["mtime"]])
[13:23:07.984]                     }
[13:23:07.984]                     tryCatch({
[13:23:07.984]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:07.984]                     }, error = function(ex) {
[13:23:07.984]                       msg <- conditionMessage(ex)
[13:23:07.984]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.984]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:07.984]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.984]                         fi_tmp[["mtime"]], msg)
[13:23:07.984]                       ex$message <- msg
[13:23:07.984]                       stop(ex)
[13:23:07.984]                     })
[13:23:07.984]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:07.984]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:07.984]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:07.984]                       fi_tmp <- file.info(pathname_tmp)
[13:23:07.984]                       fi <- file.info(pathname)
[13:23:07.984]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:07.984]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:07.984]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:07.984]                         fi[["size"]], fi[["mtime"]])
[13:23:07.984]                       stop(msg)
[13:23:07.984]                     }
[13:23:07.984]                     invisible(pathname)
[13:23:07.984]                   }
[13:23:07.984]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:07.984]                     rootPath = tempdir()) 
[13:23:07.984]                   {
[13:23:07.984]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:07.984]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:07.984]                       tmpdir = path, fileext = ".rds")
[13:23:07.984]                     save_rds(obj, file)
[13:23:07.984]                   }
[13:23:07.984]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:07.984]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.984]                   {
[13:23:07.984]                     inherits <- base::inherits
[13:23:07.984]                     invokeRestart <- base::invokeRestart
[13:23:07.984]                     is.null <- base::is.null
[13:23:07.984]                     muffled <- FALSE
[13:23:07.984]                     if (inherits(cond, "message")) {
[13:23:07.984]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:07.984]                       if (muffled) 
[13:23:07.984]                         invokeRestart("muffleMessage")
[13:23:07.984]                     }
[13:23:07.984]                     else if (inherits(cond, "warning")) {
[13:23:07.984]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:07.984]                       if (muffled) 
[13:23:07.984]                         invokeRestart("muffleWarning")
[13:23:07.984]                     }
[13:23:07.984]                     else if (inherits(cond, "condition")) {
[13:23:07.984]                       if (!is.null(pattern)) {
[13:23:07.984]                         computeRestarts <- base::computeRestarts
[13:23:07.984]                         grepl <- base::grepl
[13:23:07.984]                         restarts <- computeRestarts(cond)
[13:23:07.984]                         for (restart in restarts) {
[13:23:07.984]                           name <- restart$name
[13:23:07.984]                           if (is.null(name)) 
[13:23:07.984]                             next
[13:23:07.984]                           if (!grepl(pattern, name)) 
[13:23:07.984]                             next
[13:23:07.984]                           invokeRestart(restart)
[13:23:07.984]                           muffled <- TRUE
[13:23:07.984]                           break
[13:23:07.984]                         }
[13:23:07.984]                       }
[13:23:07.984]                     }
[13:23:07.984]                     invisible(muffled)
[13:23:07.984]                   }
[13:23:07.984]                   muffleCondition(cond)
[13:23:07.984]                 })
[13:23:07.984]             }))
[13:23:07.984]             future::FutureResult(value = ...future.value$value, 
[13:23:07.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.984]                   ...future.rng), globalenv = if (FALSE) 
[13:23:07.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:07.984]                     ...future.globalenv.names))
[13:23:07.984]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:07.984]         }, condition = base::local({
[13:23:07.984]             c <- base::c
[13:23:07.984]             inherits <- base::inherits
[13:23:07.984]             invokeRestart <- base::invokeRestart
[13:23:07.984]             length <- base::length
[13:23:07.984]             list <- base::list
[13:23:07.984]             seq.int <- base::seq.int
[13:23:07.984]             signalCondition <- base::signalCondition
[13:23:07.984]             sys.calls <- base::sys.calls
[13:23:07.984]             `[[` <- base::`[[`
[13:23:07.984]             `+` <- base::`+`
[13:23:07.984]             `<<-` <- base::`<<-`
[13:23:07.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:07.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:07.984]                   3L)]
[13:23:07.984]             }
[13:23:07.984]             function(cond) {
[13:23:07.984]                 is_error <- inherits(cond, "error")
[13:23:07.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:07.984]                   NULL)
[13:23:07.984]                 if (is_error) {
[13:23:07.984]                   sessionInformation <- function() {
[13:23:07.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:07.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:07.984]                       search = base::search(), system = base::Sys.info())
[13:23:07.984]                   }
[13:23:07.984]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:07.984]                     cond$call), session = sessionInformation(), 
[13:23:07.984]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:07.984]                   signalCondition(cond)
[13:23:07.984]                 }
[13:23:07.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:07.984]                 "immediateCondition"))) {
[13:23:07.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:07.984]                   ...future.conditions[[length(...future.conditions) + 
[13:23:07.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:07.984]                   if (TRUE && !signal) {
[13:23:07.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.984]                     {
[13:23:07.984]                       inherits <- base::inherits
[13:23:07.984]                       invokeRestart <- base::invokeRestart
[13:23:07.984]                       is.null <- base::is.null
[13:23:07.984]                       muffled <- FALSE
[13:23:07.984]                       if (inherits(cond, "message")) {
[13:23:07.984]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.984]                         if (muffled) 
[13:23:07.984]                           invokeRestart("muffleMessage")
[13:23:07.984]                       }
[13:23:07.984]                       else if (inherits(cond, "warning")) {
[13:23:07.984]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.984]                         if (muffled) 
[13:23:07.984]                           invokeRestart("muffleWarning")
[13:23:07.984]                       }
[13:23:07.984]                       else if (inherits(cond, "condition")) {
[13:23:07.984]                         if (!is.null(pattern)) {
[13:23:07.984]                           computeRestarts <- base::computeRestarts
[13:23:07.984]                           grepl <- base::grepl
[13:23:07.984]                           restarts <- computeRestarts(cond)
[13:23:07.984]                           for (restart in restarts) {
[13:23:07.984]                             name <- restart$name
[13:23:07.984]                             if (is.null(name)) 
[13:23:07.984]                               next
[13:23:07.984]                             if (!grepl(pattern, name)) 
[13:23:07.984]                               next
[13:23:07.984]                             invokeRestart(restart)
[13:23:07.984]                             muffled <- TRUE
[13:23:07.984]                             break
[13:23:07.984]                           }
[13:23:07.984]                         }
[13:23:07.984]                       }
[13:23:07.984]                       invisible(muffled)
[13:23:07.984]                     }
[13:23:07.984]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.984]                   }
[13:23:07.984]                 }
[13:23:07.984]                 else {
[13:23:07.984]                   if (TRUE) {
[13:23:07.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:07.984]                     {
[13:23:07.984]                       inherits <- base::inherits
[13:23:07.984]                       invokeRestart <- base::invokeRestart
[13:23:07.984]                       is.null <- base::is.null
[13:23:07.984]                       muffled <- FALSE
[13:23:07.984]                       if (inherits(cond, "message")) {
[13:23:07.984]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:07.984]                         if (muffled) 
[13:23:07.984]                           invokeRestart("muffleMessage")
[13:23:07.984]                       }
[13:23:07.984]                       else if (inherits(cond, "warning")) {
[13:23:07.984]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:07.984]                         if (muffled) 
[13:23:07.984]                           invokeRestart("muffleWarning")
[13:23:07.984]                       }
[13:23:07.984]                       else if (inherits(cond, "condition")) {
[13:23:07.984]                         if (!is.null(pattern)) {
[13:23:07.984]                           computeRestarts <- base::computeRestarts
[13:23:07.984]                           grepl <- base::grepl
[13:23:07.984]                           restarts <- computeRestarts(cond)
[13:23:07.984]                           for (restart in restarts) {
[13:23:07.984]                             name <- restart$name
[13:23:07.984]                             if (is.null(name)) 
[13:23:07.984]                               next
[13:23:07.984]                             if (!grepl(pattern, name)) 
[13:23:07.984]                               next
[13:23:07.984]                             invokeRestart(restart)
[13:23:07.984]                             muffled <- TRUE
[13:23:07.984]                             break
[13:23:07.984]                           }
[13:23:07.984]                         }
[13:23:07.984]                       }
[13:23:07.984]                       invisible(muffled)
[13:23:07.984]                     }
[13:23:07.984]                     muffleCondition(cond, pattern = "^muffle")
[13:23:07.984]                   }
[13:23:07.984]                 }
[13:23:07.984]             }
[13:23:07.984]         }))
[13:23:07.984]     }, error = function(ex) {
[13:23:07.984]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:07.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:07.984]                 ...future.rng), started = ...future.startTime, 
[13:23:07.984]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:07.984]             version = "1.8"), class = "FutureResult")
[13:23:07.984]     }, finally = {
[13:23:07.984]         if (!identical(...future.workdir, getwd())) 
[13:23:07.984]             setwd(...future.workdir)
[13:23:07.984]         {
[13:23:07.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:07.984]                 ...future.oldOptions$nwarnings <- NULL
[13:23:07.984]             }
[13:23:07.984]             base::options(...future.oldOptions)
[13:23:07.984]             if (.Platform$OS.type == "windows") {
[13:23:07.984]                 old_names <- names(...future.oldEnvVars)
[13:23:07.984]                 envs <- base::Sys.getenv()
[13:23:07.984]                 names <- names(envs)
[13:23:07.984]                 common <- intersect(names, old_names)
[13:23:07.984]                 added <- setdiff(names, old_names)
[13:23:07.984]                 removed <- setdiff(old_names, names)
[13:23:07.984]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:07.984]                   envs[common]]
[13:23:07.984]                 NAMES <- toupper(changed)
[13:23:07.984]                 args <- list()
[13:23:07.984]                 for (kk in seq_along(NAMES)) {
[13:23:07.984]                   name <- changed[[kk]]
[13:23:07.984]                   NAME <- NAMES[[kk]]
[13:23:07.984]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.984]                     next
[13:23:07.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.984]                 }
[13:23:07.984]                 NAMES <- toupper(added)
[13:23:07.984]                 for (kk in seq_along(NAMES)) {
[13:23:07.984]                   name <- added[[kk]]
[13:23:07.984]                   NAME <- NAMES[[kk]]
[13:23:07.984]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.984]                     next
[13:23:07.984]                   args[[name]] <- ""
[13:23:07.984]                 }
[13:23:07.984]                 NAMES <- toupper(removed)
[13:23:07.984]                 for (kk in seq_along(NAMES)) {
[13:23:07.984]                   name <- removed[[kk]]
[13:23:07.984]                   NAME <- NAMES[[kk]]
[13:23:07.984]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:07.984]                     next
[13:23:07.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:07.984]                 }
[13:23:07.984]                 if (length(args) > 0) 
[13:23:07.984]                   base::do.call(base::Sys.setenv, args = args)
[13:23:07.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:07.984]             }
[13:23:07.984]             else {
[13:23:07.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:07.984]             }
[13:23:07.984]             {
[13:23:07.984]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:07.984]                   0L) {
[13:23:07.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:07.984]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:07.984]                   base::options(opts)
[13:23:07.984]                 }
[13:23:07.984]                 {
[13:23:07.984]                   {
[13:23:07.984]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:07.984]                     NULL
[13:23:07.984]                   }
[13:23:07.984]                   options(future.plan = NULL)
[13:23:07.984]                   if (is.na(NA_character_)) 
[13:23:07.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:07.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:07.984]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:07.984]                     envir = parent.frame()) 
[13:23:07.984]                   {
[13:23:07.984]                     default_workers <- missing(workers)
[13:23:07.984]                     if (is.function(workers)) 
[13:23:07.984]                       workers <- workers()
[13:23:07.984]                     workers <- structure(as.integer(workers), 
[13:23:07.984]                       class = class(workers))
[13:23:07.984]                     stop_if_not(is.finite(workers), workers >= 
[13:23:07.984]                       1L)
[13:23:07.984]                     if ((workers == 1L && !inherits(workers, 
[13:23:07.984]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:07.984]                       if (default_workers) 
[13:23:07.984]                         supportsMulticore(warn = TRUE)
[13:23:07.984]                       return(sequential(..., envir = envir))
[13:23:07.984]                     }
[13:23:07.984]                     oopts <- options(mc.cores = workers)
[13:23:07.984]                     on.exit(options(oopts))
[13:23:07.984]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:07.984]                       envir = envir)
[13:23:07.984]                     if (!future$lazy) 
[13:23:07.984]                       future <- run(future)
[13:23:07.984]                     invisible(future)
[13:23:07.984]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:07.984]                 }
[13:23:07.984]             }
[13:23:07.984]         }
[13:23:07.984]     })
[13:23:07.984]     if (TRUE) {
[13:23:07.984]         base::sink(type = "output", split = FALSE)
[13:23:07.984]         if (TRUE) {
[13:23:07.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:07.984]         }
[13:23:07.984]         else {
[13:23:07.984]             ...future.result["stdout"] <- base::list(NULL)
[13:23:07.984]         }
[13:23:07.984]         base::close(...future.stdout)
[13:23:07.984]         ...future.stdout <- NULL
[13:23:07.984]     }
[13:23:07.984]     ...future.result$conditions <- ...future.conditions
[13:23:07.984]     ...future.result$finished <- base::Sys.time()
[13:23:07.984]     ...future.result
[13:23:07.984] }
[13:23:07.986] requestCore(): workers = 2
[13:23:07.989] MulticoreFuture started
[13:23:07.989] - Launch lazy future ... done
[13:23:07.990] run() for ‘MulticoreFuture’ ... done
[13:23:07.990] getGlobalsAndPackages() ...
[13:23:07.990] Searching for globals...
[13:23:07.990] plan(): Setting new future strategy stack:
[13:23:07.991] 
[13:23:07.990] List of future strategies:
[13:23:07.990] 1. sequential:
[13:23:07.990]    - args: function (..., envir = parent.frame())
[13:23:07.990]    - tweaked: FALSE
[13:23:07.990]    - call: NULL
[13:23:07.991] Searching for globals ... DONE
[13:23:07.991] - globals: [0] <none>
[13:23:07.991] plan(): nbrOfWorkers() = 1
[13:23:07.991] getGlobalsAndPackages() ... DONE
[13:23:07.992] run() for ‘Future’ ...
[13:23:07.992] - state: ‘created’
[13:23:07.993] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:07.993] plan(): Setting new future strategy stack:
[13:23:07.993] List of future strategies:
[13:23:07.993] 1. multicore:
[13:23:07.993]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:07.993]    - tweaked: FALSE
[13:23:07.993]    - call: plan(strategy)
[13:23:07.998] plan(): nbrOfWorkers() = 2
[13:23:07.999] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:07.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:07.999]   - Field: ‘label’
[13:23:07.999]   - Field: ‘local’
[13:23:08.000]   - Field: ‘owner’
[13:23:08.000]   - Field: ‘envir’
[13:23:08.000]   - Field: ‘workers’
[13:23:08.000]   - Field: ‘packages’
[13:23:08.000]   - Field: ‘gc’
[13:23:08.000]   - Field: ‘job’
[13:23:08.001]   - Field: ‘conditions’
[13:23:08.001]   - Field: ‘expr’
[13:23:08.001]   - Field: ‘uuid’
[13:23:08.001]   - Field: ‘seed’
[13:23:08.001]   - Field: ‘version’
[13:23:08.001]   - Field: ‘result’
[13:23:08.002]   - Field: ‘asynchronous’
[13:23:08.002]   - Field: ‘calls’
[13:23:08.002]   - Field: ‘globals’
[13:23:08.002]   - Field: ‘stdout’
[13:23:08.002]   - Field: ‘earlySignal’
[13:23:08.002]   - Field: ‘lazy’
[13:23:08.003]   - Field: ‘state’
[13:23:08.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:08.003] - Launch lazy future ...
[13:23:08.003] Packages needed by the future expression (n = 0): <none>
[13:23:08.004] Packages needed by future strategies (n = 0): <none>
[13:23:08.004] {
[13:23:08.004]     {
[13:23:08.004]         {
[13:23:08.004]             ...future.startTime <- base::Sys.time()
[13:23:08.004]             {
[13:23:08.004]                 {
[13:23:08.004]                   {
[13:23:08.004]                     {
[13:23:08.004]                       base::local({
[13:23:08.004]                         has_future <- base::requireNamespace("future", 
[13:23:08.004]                           quietly = TRUE)
[13:23:08.004]                         if (has_future) {
[13:23:08.004]                           ns <- base::getNamespace("future")
[13:23:08.004]                           version <- ns[[".package"]][["version"]]
[13:23:08.004]                           if (is.null(version)) 
[13:23:08.004]                             version <- utils::packageVersion("future")
[13:23:08.004]                         }
[13:23:08.004]                         else {
[13:23:08.004]                           version <- NULL
[13:23:08.004]                         }
[13:23:08.004]                         if (!has_future || version < "1.8.0") {
[13:23:08.004]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.004]                             "", base::R.version$version.string), 
[13:23:08.004]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.004]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.004]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.004]                               "release", "version")], collapse = " "), 
[13:23:08.004]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.004]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.004]                             info)
[13:23:08.004]                           info <- base::paste(info, collapse = "; ")
[13:23:08.004]                           if (!has_future) {
[13:23:08.004]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.004]                               info)
[13:23:08.004]                           }
[13:23:08.004]                           else {
[13:23:08.004]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.004]                               info, version)
[13:23:08.004]                           }
[13:23:08.004]                           base::stop(msg)
[13:23:08.004]                         }
[13:23:08.004]                       })
[13:23:08.004]                     }
[13:23:08.004]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.004]                     base::options(mc.cores = 1L)
[13:23:08.004]                   }
[13:23:08.004]                   options(future.plan = NULL)
[13:23:08.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.004]                 }
[13:23:08.004]                 ...future.workdir <- getwd()
[13:23:08.004]             }
[13:23:08.004]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.004]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.004]         }
[13:23:08.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.004]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.004]             base::names(...future.oldOptions))
[13:23:08.004]     }
[13:23:08.004]     if (FALSE) {
[13:23:08.004]     }
[13:23:08.004]     else {
[13:23:08.004]         if (TRUE) {
[13:23:08.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.004]                 open = "w")
[13:23:08.004]         }
[13:23:08.004]         else {
[13:23:08.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.004]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.004]         }
[13:23:08.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.004]             base::sink(type = "output", split = FALSE)
[13:23:08.004]             base::close(...future.stdout)
[13:23:08.004]         }, add = TRUE)
[13:23:08.004]     }
[13:23:08.004]     ...future.frame <- base::sys.nframe()
[13:23:08.004]     ...future.conditions <- base::list()
[13:23:08.004]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.004]     if (FALSE) {
[13:23:08.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.004]     }
[13:23:08.004]     ...future.result <- base::tryCatch({
[13:23:08.004]         base::withCallingHandlers({
[13:23:08.004]             ...future.value <- base::withVisible(base::local({
[13:23:08.004]                 withCallingHandlers({
[13:23:08.004]                   NULL
[13:23:08.004]                 }, immediateCondition = function(cond) {
[13:23:08.004]                   save_rds <- function (object, pathname, ...) 
[13:23:08.004]                   {
[13:23:08.004]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:08.004]                     if (file_test("-f", pathname_tmp)) {
[13:23:08.004]                       fi_tmp <- file.info(pathname_tmp)
[13:23:08.004]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:08.004]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:08.004]                         fi_tmp[["mtime"]])
[13:23:08.004]                     }
[13:23:08.004]                     tryCatch({
[13:23:08.004]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:08.004]                     }, error = function(ex) {
[13:23:08.004]                       msg <- conditionMessage(ex)
[13:23:08.004]                       fi_tmp <- file.info(pathname_tmp)
[13:23:08.004]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:08.004]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:08.004]                         fi_tmp[["mtime"]], msg)
[13:23:08.004]                       ex$message <- msg
[13:23:08.004]                       stop(ex)
[13:23:08.004]                     })
[13:23:08.004]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:08.004]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:08.004]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:08.004]                       fi_tmp <- file.info(pathname_tmp)
[13:23:08.004]                       fi <- file.info(pathname)
[13:23:08.004]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:08.004]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:08.004]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:08.004]                         fi[["size"]], fi[["mtime"]])
[13:23:08.004]                       stop(msg)
[13:23:08.004]                     }
[13:23:08.004]                     invisible(pathname)
[13:23:08.004]                   }
[13:23:08.004]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:08.004]                     rootPath = tempdir()) 
[13:23:08.004]                   {
[13:23:08.004]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:08.004]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:08.004]                       tmpdir = path, fileext = ".rds")
[13:23:08.004]                     save_rds(obj, file)
[13:23:08.004]                   }
[13:23:08.004]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:08.004]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.004]                   {
[13:23:08.004]                     inherits <- base::inherits
[13:23:08.004]                     invokeRestart <- base::invokeRestart
[13:23:08.004]                     is.null <- base::is.null
[13:23:08.004]                     muffled <- FALSE
[13:23:08.004]                     if (inherits(cond, "message")) {
[13:23:08.004]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.004]                       if (muffled) 
[13:23:08.004]                         invokeRestart("muffleMessage")
[13:23:08.004]                     }
[13:23:08.004]                     else if (inherits(cond, "warning")) {
[13:23:08.004]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.004]                       if (muffled) 
[13:23:08.004]                         invokeRestart("muffleWarning")
[13:23:08.004]                     }
[13:23:08.004]                     else if (inherits(cond, "condition")) {
[13:23:08.004]                       if (!is.null(pattern)) {
[13:23:08.004]                         computeRestarts <- base::computeRestarts
[13:23:08.004]                         grepl <- base::grepl
[13:23:08.004]                         restarts <- computeRestarts(cond)
[13:23:08.004]                         for (restart in restarts) {
[13:23:08.004]                           name <- restart$name
[13:23:08.004]                           if (is.null(name)) 
[13:23:08.004]                             next
[13:23:08.004]                           if (!grepl(pattern, name)) 
[13:23:08.004]                             next
[13:23:08.004]                           invokeRestart(restart)
[13:23:08.004]                           muffled <- TRUE
[13:23:08.004]                           break
[13:23:08.004]                         }
[13:23:08.004]                       }
[13:23:08.004]                     }
[13:23:08.004]                     invisible(muffled)
[13:23:08.004]                   }
[13:23:08.004]                   muffleCondition(cond)
[13:23:08.004]                 })
[13:23:08.004]             }))
[13:23:08.004]             future::FutureResult(value = ...future.value$value, 
[13:23:08.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.004]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.004]                     ...future.globalenv.names))
[13:23:08.004]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.004]         }, condition = base::local({
[13:23:08.004]             c <- base::c
[13:23:08.004]             inherits <- base::inherits
[13:23:08.004]             invokeRestart <- base::invokeRestart
[13:23:08.004]             length <- base::length
[13:23:08.004]             list <- base::list
[13:23:08.004]             seq.int <- base::seq.int
[13:23:08.004]             signalCondition <- base::signalCondition
[13:23:08.004]             sys.calls <- base::sys.calls
[13:23:08.004]             `[[` <- base::`[[`
[13:23:08.004]             `+` <- base::`+`
[13:23:08.004]             `<<-` <- base::`<<-`
[13:23:08.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.004]                   3L)]
[13:23:08.004]             }
[13:23:08.004]             function(cond) {
[13:23:08.004]                 is_error <- inherits(cond, "error")
[13:23:08.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.004]                   NULL)
[13:23:08.004]                 if (is_error) {
[13:23:08.004]                   sessionInformation <- function() {
[13:23:08.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.004]                       search = base::search(), system = base::Sys.info())
[13:23:08.004]                   }
[13:23:08.004]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.004]                     cond$call), session = sessionInformation(), 
[13:23:08.004]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.004]                   signalCondition(cond)
[13:23:08.004]                 }
[13:23:08.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.004]                 "immediateCondition"))) {
[13:23:08.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.004]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.004]                   if (TRUE && !signal) {
[13:23:08.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.004]                     {
[13:23:08.004]                       inherits <- base::inherits
[13:23:08.004]                       invokeRestart <- base::invokeRestart
[13:23:08.004]                       is.null <- base::is.null
[13:23:08.004]                       muffled <- FALSE
[13:23:08.004]                       if (inherits(cond, "message")) {
[13:23:08.004]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.004]                         if (muffled) 
[13:23:08.004]                           invokeRestart("muffleMessage")
[13:23:08.004]                       }
[13:23:08.004]                       else if (inherits(cond, "warning")) {
[13:23:08.004]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.004]                         if (muffled) 
[13:23:08.004]                           invokeRestart("muffleWarning")
[13:23:08.004]                       }
[13:23:08.004]                       else if (inherits(cond, "condition")) {
[13:23:08.004]                         if (!is.null(pattern)) {
[13:23:08.004]                           computeRestarts <- base::computeRestarts
[13:23:08.004]                           grepl <- base::grepl
[13:23:08.004]                           restarts <- computeRestarts(cond)
[13:23:08.004]                           for (restart in restarts) {
[13:23:08.004]                             name <- restart$name
[13:23:08.004]                             if (is.null(name)) 
[13:23:08.004]                               next
[13:23:08.004]                             if (!grepl(pattern, name)) 
[13:23:08.004]                               next
[13:23:08.004]                             invokeRestart(restart)
[13:23:08.004]                             muffled <- TRUE
[13:23:08.004]                             break
[13:23:08.004]                           }
[13:23:08.004]                         }
[13:23:08.004]                       }
[13:23:08.004]                       invisible(muffled)
[13:23:08.004]                     }
[13:23:08.004]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.004]                   }
[13:23:08.004]                 }
[13:23:08.004]                 else {
[13:23:08.004]                   if (TRUE) {
[13:23:08.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.004]                     {
[13:23:08.004]                       inherits <- base::inherits
[13:23:08.004]                       invokeRestart <- base::invokeRestart
[13:23:08.004]                       is.null <- base::is.null
[13:23:08.004]                       muffled <- FALSE
[13:23:08.004]                       if (inherits(cond, "message")) {
[13:23:08.004]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.004]                         if (muffled) 
[13:23:08.004]                           invokeRestart("muffleMessage")
[13:23:08.004]                       }
[13:23:08.004]                       else if (inherits(cond, "warning")) {
[13:23:08.004]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.004]                         if (muffled) 
[13:23:08.004]                           invokeRestart("muffleWarning")
[13:23:08.004]                       }
[13:23:08.004]                       else if (inherits(cond, "condition")) {
[13:23:08.004]                         if (!is.null(pattern)) {
[13:23:08.004]                           computeRestarts <- base::computeRestarts
[13:23:08.004]                           grepl <- base::grepl
[13:23:08.004]                           restarts <- computeRestarts(cond)
[13:23:08.004]                           for (restart in restarts) {
[13:23:08.004]                             name <- restart$name
[13:23:08.004]                             if (is.null(name)) 
[13:23:08.004]                               next
[13:23:08.004]                             if (!grepl(pattern, name)) 
[13:23:08.004]                               next
[13:23:08.004]                             invokeRestart(restart)
[13:23:08.004]                             muffled <- TRUE
[13:23:08.004]                             break
[13:23:08.004]                           }
[13:23:08.004]                         }
[13:23:08.004]                       }
[13:23:08.004]                       invisible(muffled)
[13:23:08.004]                     }
[13:23:08.004]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.004]                   }
[13:23:08.004]                 }
[13:23:08.004]             }
[13:23:08.004]         }))
[13:23:08.004]     }, error = function(ex) {
[13:23:08.004]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.004]                 ...future.rng), started = ...future.startTime, 
[13:23:08.004]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.004]             version = "1.8"), class = "FutureResult")
[13:23:08.004]     }, finally = {
[13:23:08.004]         if (!identical(...future.workdir, getwd())) 
[13:23:08.004]             setwd(...future.workdir)
[13:23:08.004]         {
[13:23:08.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.004]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.004]             }
[13:23:08.004]             base::options(...future.oldOptions)
[13:23:08.004]             if (.Platform$OS.type == "windows") {
[13:23:08.004]                 old_names <- names(...future.oldEnvVars)
[13:23:08.004]                 envs <- base::Sys.getenv()
[13:23:08.004]                 names <- names(envs)
[13:23:08.004]                 common <- intersect(names, old_names)
[13:23:08.004]                 added <- setdiff(names, old_names)
[13:23:08.004]                 removed <- setdiff(old_names, names)
[13:23:08.004]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.004]                   envs[common]]
[13:23:08.004]                 NAMES <- toupper(changed)
[13:23:08.004]                 args <- list()
[13:23:08.004]                 for (kk in seq_along(NAMES)) {
[13:23:08.004]                   name <- changed[[kk]]
[13:23:08.004]                   NAME <- NAMES[[kk]]
[13:23:08.004]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.004]                     next
[13:23:08.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.004]                 }
[13:23:08.004]                 NAMES <- toupper(added)
[13:23:08.004]                 for (kk in seq_along(NAMES)) {
[13:23:08.004]                   name <- added[[kk]]
[13:23:08.004]                   NAME <- NAMES[[kk]]
[13:23:08.004]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.004]                     next
[13:23:08.004]                   args[[name]] <- ""
[13:23:08.004]                 }
[13:23:08.004]                 NAMES <- toupper(removed)
[13:23:08.004]                 for (kk in seq_along(NAMES)) {
[13:23:08.004]                   name <- removed[[kk]]
[13:23:08.004]                   NAME <- NAMES[[kk]]
[13:23:08.004]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.004]                     next
[13:23:08.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.004]                 }
[13:23:08.004]                 if (length(args) > 0) 
[13:23:08.004]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.004]             }
[13:23:08.004]             else {
[13:23:08.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.004]             }
[13:23:08.004]             {
[13:23:08.004]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.004]                   0L) {
[13:23:08.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.004]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.004]                   base::options(opts)
[13:23:08.004]                 }
[13:23:08.004]                 {
[13:23:08.004]                   {
[13:23:08.004]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.004]                     NULL
[13:23:08.004]                   }
[13:23:08.004]                   options(future.plan = NULL)
[13:23:08.004]                   if (is.na(NA_character_)) 
[13:23:08.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.004]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:08.004]                     envir = parent.frame()) 
[13:23:08.004]                   {
[13:23:08.004]                     default_workers <- missing(workers)
[13:23:08.004]                     if (is.function(workers)) 
[13:23:08.004]                       workers <- workers()
[13:23:08.004]                     workers <- structure(as.integer(workers), 
[13:23:08.004]                       class = class(workers))
[13:23:08.004]                     stop_if_not(is.finite(workers), workers >= 
[13:23:08.004]                       1L)
[13:23:08.004]                     if ((workers == 1L && !inherits(workers, 
[13:23:08.004]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:08.004]                       if (default_workers) 
[13:23:08.004]                         supportsMulticore(warn = TRUE)
[13:23:08.004]                       return(sequential(..., envir = envir))
[13:23:08.004]                     }
[13:23:08.004]                     oopts <- options(mc.cores = workers)
[13:23:08.004]                     on.exit(options(oopts))
[13:23:08.004]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:08.004]                       envir = envir)
[13:23:08.004]                     if (!future$lazy) 
[13:23:08.004]                       future <- run(future)
[13:23:08.004]                     invisible(future)
[13:23:08.004]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.004]                 }
[13:23:08.004]             }
[13:23:08.004]         }
[13:23:08.004]     })
[13:23:08.004]     if (TRUE) {
[13:23:08.004]         base::sink(type = "output", split = FALSE)
[13:23:08.004]         if (TRUE) {
[13:23:08.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.004]         }
[13:23:08.004]         else {
[13:23:08.004]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.004]         }
[13:23:08.004]         base::close(...future.stdout)
[13:23:08.004]         ...future.stdout <- NULL
[13:23:08.004]     }
[13:23:08.004]     ...future.result$conditions <- ...future.conditions
[13:23:08.004]     ...future.result$finished <- base::Sys.time()
[13:23:08.004]     ...future.result
[13:23:08.004] }
[13:23:08.009] requestCore(): workers = 2
[13:23:08.013] MulticoreFuture started
[13:23:08.013] - Launch lazy future ... done
[13:23:08.014] run() for ‘MulticoreFuture’ ... done
[13:23:08.014] plan(): Setting new future strategy stack:
[13:23:08.015] getGlobalsAndPackages() ...
[13:23:08.015] Searching for globals...
[13:23:08.014] List of future strategies:
[13:23:08.014] 1. sequential:
[13:23:08.014]    - args: function (..., envir = parent.frame())
[13:23:08.014]    - tweaked: FALSE
[13:23:08.014]    - call: NULL
[13:23:08.015] plan(): nbrOfWorkers() = 1
[13:23:08.016] - globals found: [1] ‘{’
[13:23:08.017] Searching for globals ... DONE
[13:23:08.017] Resolving globals: FALSE
[13:23:08.018] 
[13:23:08.018] 
[13:23:08.018] plan(): Setting new future strategy stack:
[13:23:08.018] getGlobalsAndPackages() ... DONE
[13:23:08.018] List of future strategies:
[13:23:08.018] 1. multicore:
[13:23:08.018]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:08.018]    - tweaked: FALSE
[13:23:08.018]    - call: plan(strategy)
[13:23:08.019] run() for ‘Future’ ...
[13:23:08.019] - state: ‘created’
[13:23:08.019] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.024] plan(): nbrOfWorkers() = 2
[13:23:08.025] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:08.026]   - Field: ‘label’
[13:23:08.026]   - Field: ‘local’
[13:23:08.026]   - Field: ‘owner’
[13:23:08.026]   - Field: ‘envir’
[13:23:08.026]   - Field: ‘workers’
[13:23:08.026]   - Field: ‘packages’
[13:23:08.027]   - Field: ‘gc’
[13:23:08.027]   - Field: ‘job’
[13:23:08.027]   - Field: ‘conditions’
[13:23:08.027]   - Field: ‘expr’
[13:23:08.027]   - Field: ‘uuid’
[13:23:08.027]   - Field: ‘seed’
[13:23:08.028]   - Field: ‘version’
[13:23:08.028]   - Field: ‘result’
[13:23:08.028]   - Field: ‘asynchronous’
[13:23:08.028]   - Field: ‘calls’
[13:23:08.028]   - Field: ‘globals’
[13:23:08.028]   - Field: ‘stdout’
[13:23:08.029]   - Field: ‘earlySignal’
[13:23:08.029]   - Field: ‘lazy’
[13:23:08.029]   - Field: ‘state’
[13:23:08.029] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:08.029] - Launch lazy future ...
[13:23:08.030] Packages needed by the future expression (n = 0): <none>
[13:23:08.030] Packages needed by future strategies (n = 0): <none>
[13:23:08.031] {
[13:23:08.031]     {
[13:23:08.031]         {
[13:23:08.031]             ...future.startTime <- base::Sys.time()
[13:23:08.031]             {
[13:23:08.031]                 {
[13:23:08.031]                   {
[13:23:08.031]                     {
[13:23:08.031]                       base::local({
[13:23:08.031]                         has_future <- base::requireNamespace("future", 
[13:23:08.031]                           quietly = TRUE)
[13:23:08.031]                         if (has_future) {
[13:23:08.031]                           ns <- base::getNamespace("future")
[13:23:08.031]                           version <- ns[[".package"]][["version"]]
[13:23:08.031]                           if (is.null(version)) 
[13:23:08.031]                             version <- utils::packageVersion("future")
[13:23:08.031]                         }
[13:23:08.031]                         else {
[13:23:08.031]                           version <- NULL
[13:23:08.031]                         }
[13:23:08.031]                         if (!has_future || version < "1.8.0") {
[13:23:08.031]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.031]                             "", base::R.version$version.string), 
[13:23:08.031]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.031]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.031]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.031]                               "release", "version")], collapse = " "), 
[13:23:08.031]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.031]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.031]                             info)
[13:23:08.031]                           info <- base::paste(info, collapse = "; ")
[13:23:08.031]                           if (!has_future) {
[13:23:08.031]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.031]                               info)
[13:23:08.031]                           }
[13:23:08.031]                           else {
[13:23:08.031]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.031]                               info, version)
[13:23:08.031]                           }
[13:23:08.031]                           base::stop(msg)
[13:23:08.031]                         }
[13:23:08.031]                       })
[13:23:08.031]                     }
[13:23:08.031]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.031]                     base::options(mc.cores = 1L)
[13:23:08.031]                   }
[13:23:08.031]                   options(future.plan = NULL)
[13:23:08.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.031]                 }
[13:23:08.031]                 ...future.workdir <- getwd()
[13:23:08.031]             }
[13:23:08.031]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.031]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.031]         }
[13:23:08.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.031]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.031]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.031]             base::names(...future.oldOptions))
[13:23:08.031]     }
[13:23:08.031]     if (FALSE) {
[13:23:08.031]     }
[13:23:08.031]     else {
[13:23:08.031]         if (TRUE) {
[13:23:08.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.031]                 open = "w")
[13:23:08.031]         }
[13:23:08.031]         else {
[13:23:08.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.031]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.031]         }
[13:23:08.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.031]             base::sink(type = "output", split = FALSE)
[13:23:08.031]             base::close(...future.stdout)
[13:23:08.031]         }, add = TRUE)
[13:23:08.031]     }
[13:23:08.031]     ...future.frame <- base::sys.nframe()
[13:23:08.031]     ...future.conditions <- base::list()
[13:23:08.031]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.031]     if (FALSE) {
[13:23:08.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.031]     }
[13:23:08.031]     ...future.result <- base::tryCatch({
[13:23:08.031]         base::withCallingHandlers({
[13:23:08.031]             ...future.value <- base::withVisible(base::local({
[13:23:08.031]                 withCallingHandlers({
[13:23:08.031]                   {
[13:23:08.031]                     4
[13:23:08.031]                   }
[13:23:08.031]                 }, immediateCondition = function(cond) {
[13:23:08.031]                   save_rds <- function (object, pathname, ...) 
[13:23:08.031]                   {
[13:23:08.031]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:08.031]                     if (file_test("-f", pathname_tmp)) {
[13:23:08.031]                       fi_tmp <- file.info(pathname_tmp)
[13:23:08.031]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:08.031]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:08.031]                         fi_tmp[["mtime"]])
[13:23:08.031]                     }
[13:23:08.031]                     tryCatch({
[13:23:08.031]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:08.031]                     }, error = function(ex) {
[13:23:08.031]                       msg <- conditionMessage(ex)
[13:23:08.031]                       fi_tmp <- file.info(pathname_tmp)
[13:23:08.031]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:08.031]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:08.031]                         fi_tmp[["mtime"]], msg)
[13:23:08.031]                       ex$message <- msg
[13:23:08.031]                       stop(ex)
[13:23:08.031]                     })
[13:23:08.031]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:08.031]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:08.031]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:08.031]                       fi_tmp <- file.info(pathname_tmp)
[13:23:08.031]                       fi <- file.info(pathname)
[13:23:08.031]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:08.031]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:08.031]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:08.031]                         fi[["size"]], fi[["mtime"]])
[13:23:08.031]                       stop(msg)
[13:23:08.031]                     }
[13:23:08.031]                     invisible(pathname)
[13:23:08.031]                   }
[13:23:08.031]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:08.031]                     rootPath = tempdir()) 
[13:23:08.031]                   {
[13:23:08.031]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:08.031]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:08.031]                       tmpdir = path, fileext = ".rds")
[13:23:08.031]                     save_rds(obj, file)
[13:23:08.031]                   }
[13:23:08.031]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:08.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.031]                   {
[13:23:08.031]                     inherits <- base::inherits
[13:23:08.031]                     invokeRestart <- base::invokeRestart
[13:23:08.031]                     is.null <- base::is.null
[13:23:08.031]                     muffled <- FALSE
[13:23:08.031]                     if (inherits(cond, "message")) {
[13:23:08.031]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.031]                       if (muffled) 
[13:23:08.031]                         invokeRestart("muffleMessage")
[13:23:08.031]                     }
[13:23:08.031]                     else if (inherits(cond, "warning")) {
[13:23:08.031]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.031]                       if (muffled) 
[13:23:08.031]                         invokeRestart("muffleWarning")
[13:23:08.031]                     }
[13:23:08.031]                     else if (inherits(cond, "condition")) {
[13:23:08.031]                       if (!is.null(pattern)) {
[13:23:08.031]                         computeRestarts <- base::computeRestarts
[13:23:08.031]                         grepl <- base::grepl
[13:23:08.031]                         restarts <- computeRestarts(cond)
[13:23:08.031]                         for (restart in restarts) {
[13:23:08.031]                           name <- restart$name
[13:23:08.031]                           if (is.null(name)) 
[13:23:08.031]                             next
[13:23:08.031]                           if (!grepl(pattern, name)) 
[13:23:08.031]                             next
[13:23:08.031]                           invokeRestart(restart)
[13:23:08.031]                           muffled <- TRUE
[13:23:08.031]                           break
[13:23:08.031]                         }
[13:23:08.031]                       }
[13:23:08.031]                     }
[13:23:08.031]                     invisible(muffled)
[13:23:08.031]                   }
[13:23:08.031]                   muffleCondition(cond)
[13:23:08.031]                 })
[13:23:08.031]             }))
[13:23:08.031]             future::FutureResult(value = ...future.value$value, 
[13:23:08.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.031]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.031]                     ...future.globalenv.names))
[13:23:08.031]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.031]         }, condition = base::local({
[13:23:08.031]             c <- base::c
[13:23:08.031]             inherits <- base::inherits
[13:23:08.031]             invokeRestart <- base::invokeRestart
[13:23:08.031]             length <- base::length
[13:23:08.031]             list <- base::list
[13:23:08.031]             seq.int <- base::seq.int
[13:23:08.031]             signalCondition <- base::signalCondition
[13:23:08.031]             sys.calls <- base::sys.calls
[13:23:08.031]             `[[` <- base::`[[`
[13:23:08.031]             `+` <- base::`+`
[13:23:08.031]             `<<-` <- base::`<<-`
[13:23:08.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.031]                   3L)]
[13:23:08.031]             }
[13:23:08.031]             function(cond) {
[13:23:08.031]                 is_error <- inherits(cond, "error")
[13:23:08.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.031]                   NULL)
[13:23:08.031]                 if (is_error) {
[13:23:08.031]                   sessionInformation <- function() {
[13:23:08.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.031]                       search = base::search(), system = base::Sys.info())
[13:23:08.031]                   }
[13:23:08.031]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.031]                     cond$call), session = sessionInformation(), 
[13:23:08.031]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.031]                   signalCondition(cond)
[13:23:08.031]                 }
[13:23:08.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.031]                 "immediateCondition"))) {
[13:23:08.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.031]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.031]                   if (TRUE && !signal) {
[13:23:08.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.031]                     {
[13:23:08.031]                       inherits <- base::inherits
[13:23:08.031]                       invokeRestart <- base::invokeRestart
[13:23:08.031]                       is.null <- base::is.null
[13:23:08.031]                       muffled <- FALSE
[13:23:08.031]                       if (inherits(cond, "message")) {
[13:23:08.031]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.031]                         if (muffled) 
[13:23:08.031]                           invokeRestart("muffleMessage")
[13:23:08.031]                       }
[13:23:08.031]                       else if (inherits(cond, "warning")) {
[13:23:08.031]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.031]                         if (muffled) 
[13:23:08.031]                           invokeRestart("muffleWarning")
[13:23:08.031]                       }
[13:23:08.031]                       else if (inherits(cond, "condition")) {
[13:23:08.031]                         if (!is.null(pattern)) {
[13:23:08.031]                           computeRestarts <- base::computeRestarts
[13:23:08.031]                           grepl <- base::grepl
[13:23:08.031]                           restarts <- computeRestarts(cond)
[13:23:08.031]                           for (restart in restarts) {
[13:23:08.031]                             name <- restart$name
[13:23:08.031]                             if (is.null(name)) 
[13:23:08.031]                               next
[13:23:08.031]                             if (!grepl(pattern, name)) 
[13:23:08.031]                               next
[13:23:08.031]                             invokeRestart(restart)
[13:23:08.031]                             muffled <- TRUE
[13:23:08.031]                             break
[13:23:08.031]                           }
[13:23:08.031]                         }
[13:23:08.031]                       }
[13:23:08.031]                       invisible(muffled)
[13:23:08.031]                     }
[13:23:08.031]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.031]                   }
[13:23:08.031]                 }
[13:23:08.031]                 else {
[13:23:08.031]                   if (TRUE) {
[13:23:08.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.031]                     {
[13:23:08.031]                       inherits <- base::inherits
[13:23:08.031]                       invokeRestart <- base::invokeRestart
[13:23:08.031]                       is.null <- base::is.null
[13:23:08.031]                       muffled <- FALSE
[13:23:08.031]                       if (inherits(cond, "message")) {
[13:23:08.031]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.031]                         if (muffled) 
[13:23:08.031]                           invokeRestart("muffleMessage")
[13:23:08.031]                       }
[13:23:08.031]                       else if (inherits(cond, "warning")) {
[13:23:08.031]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.031]                         if (muffled) 
[13:23:08.031]                           invokeRestart("muffleWarning")
[13:23:08.031]                       }
[13:23:08.031]                       else if (inherits(cond, "condition")) {
[13:23:08.031]                         if (!is.null(pattern)) {
[13:23:08.031]                           computeRestarts <- base::computeRestarts
[13:23:08.031]                           grepl <- base::grepl
[13:23:08.031]                           restarts <- computeRestarts(cond)
[13:23:08.031]                           for (restart in restarts) {
[13:23:08.031]                             name <- restart$name
[13:23:08.031]                             if (is.null(name)) 
[13:23:08.031]                               next
[13:23:08.031]                             if (!grepl(pattern, name)) 
[13:23:08.031]                               next
[13:23:08.031]                             invokeRestart(restart)
[13:23:08.031]                             muffled <- TRUE
[13:23:08.031]                             break
[13:23:08.031]                           }
[13:23:08.031]                         }
[13:23:08.031]                       }
[13:23:08.031]                       invisible(muffled)
[13:23:08.031]                     }
[13:23:08.031]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.031]                   }
[13:23:08.031]                 }
[13:23:08.031]             }
[13:23:08.031]         }))
[13:23:08.031]     }, error = function(ex) {
[13:23:08.031]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.031]                 ...future.rng), started = ...future.startTime, 
[13:23:08.031]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.031]             version = "1.8"), class = "FutureResult")
[13:23:08.031]     }, finally = {
[13:23:08.031]         if (!identical(...future.workdir, getwd())) 
[13:23:08.031]             setwd(...future.workdir)
[13:23:08.031]         {
[13:23:08.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.031]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.031]             }
[13:23:08.031]             base::options(...future.oldOptions)
[13:23:08.031]             if (.Platform$OS.type == "windows") {
[13:23:08.031]                 old_names <- names(...future.oldEnvVars)
[13:23:08.031]                 envs <- base::Sys.getenv()
[13:23:08.031]                 names <- names(envs)
[13:23:08.031]                 common <- intersect(names, old_names)
[13:23:08.031]                 added <- setdiff(names, old_names)
[13:23:08.031]                 removed <- setdiff(old_names, names)
[13:23:08.031]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.031]                   envs[common]]
[13:23:08.031]                 NAMES <- toupper(changed)
[13:23:08.031]                 args <- list()
[13:23:08.031]                 for (kk in seq_along(NAMES)) {
[13:23:08.031]                   name <- changed[[kk]]
[13:23:08.031]                   NAME <- NAMES[[kk]]
[13:23:08.031]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.031]                     next
[13:23:08.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.031]                 }
[13:23:08.031]                 NAMES <- toupper(added)
[13:23:08.031]                 for (kk in seq_along(NAMES)) {
[13:23:08.031]                   name <- added[[kk]]
[13:23:08.031]                   NAME <- NAMES[[kk]]
[13:23:08.031]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.031]                     next
[13:23:08.031]                   args[[name]] <- ""
[13:23:08.031]                 }
[13:23:08.031]                 NAMES <- toupper(removed)
[13:23:08.031]                 for (kk in seq_along(NAMES)) {
[13:23:08.031]                   name <- removed[[kk]]
[13:23:08.031]                   NAME <- NAMES[[kk]]
[13:23:08.031]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.031]                     next
[13:23:08.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.031]                 }
[13:23:08.031]                 if (length(args) > 0) 
[13:23:08.031]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.031]             }
[13:23:08.031]             else {
[13:23:08.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.031]             }
[13:23:08.031]             {
[13:23:08.031]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.031]                   0L) {
[13:23:08.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.031]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.031]                   base::options(opts)
[13:23:08.031]                 }
[13:23:08.031]                 {
[13:23:08.031]                   {
[13:23:08.031]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.031]                     NULL
[13:23:08.031]                   }
[13:23:08.031]                   options(future.plan = NULL)
[13:23:08.031]                   if (is.na(NA_character_)) 
[13:23:08.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.031]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:08.031]                     envir = parent.frame()) 
[13:23:08.031]                   {
[13:23:08.031]                     default_workers <- missing(workers)
[13:23:08.031]                     if (is.function(workers)) 
[13:23:08.031]                       workers <- workers()
[13:23:08.031]                     workers <- structure(as.integer(workers), 
[13:23:08.031]                       class = class(workers))
[13:23:08.031]                     stop_if_not(is.finite(workers), workers >= 
[13:23:08.031]                       1L)
[13:23:08.031]                     if ((workers == 1L && !inherits(workers, 
[13:23:08.031]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:08.031]                       if (default_workers) 
[13:23:08.031]                         supportsMulticore(warn = TRUE)
[13:23:08.031]                       return(sequential(..., envir = envir))
[13:23:08.031]                     }
[13:23:08.031]                     oopts <- options(mc.cores = workers)
[13:23:08.031]                     on.exit(options(oopts))
[13:23:08.031]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:08.031]                       envir = envir)
[13:23:08.031]                     if (!future$lazy) 
[13:23:08.031]                       future <- run(future)
[13:23:08.031]                     invisible(future)
[13:23:08.031]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.031]                 }
[13:23:08.031]             }
[13:23:08.031]         }
[13:23:08.031]     })
[13:23:08.031]     if (TRUE) {
[13:23:08.031]         base::sink(type = "output", split = FALSE)
[13:23:08.031]         if (TRUE) {
[13:23:08.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.031]         }
[13:23:08.031]         else {
[13:23:08.031]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.031]         }
[13:23:08.031]         base::close(...future.stdout)
[13:23:08.031]         ...future.stdout <- NULL
[13:23:08.031]     }
[13:23:08.031]     ...future.result$conditions <- ...future.conditions
[13:23:08.031]     ...future.result$finished <- base::Sys.time()
[13:23:08.031]     ...future.result
[13:23:08.031] }
[13:23:08.035] requestCore(): workers = 2
[13:23:08.035] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:08.046] result() for MulticoreFuture ...
[13:23:08.047] result() for MulticoreFuture ...
[13:23:08.048] result() for MulticoreFuture ... done
[13:23:08.048] result() for MulticoreFuture ... done
[13:23:08.048] result() for MulticoreFuture ...
[13:23:08.048] result() for MulticoreFuture ... done
[13:23:08.051] MulticoreFuture started
[13:23:08.052] - Launch lazy future ... done
[13:23:08.052] run() for ‘MulticoreFuture’ ... done
[13:23:08.053] plan(): Setting new future strategy stack:
<environment: 0x5596d5894b80> 
[13:23:08.053] List of future strategies:
[13:23:08.053] 1. sequential:
[13:23:08.053]    - args: function (..., envir = parent.frame())
[13:23:08.053]    - tweaked: FALSE
[13:23:08.053]    - call: NULL
[13:23:08.054] plan(): nbrOfWorkers() = 1
<environment: 0x5596d6176ff0> 
[13:23:08.057] plan(): Setting new future strategy stack:
[13:23:08.057] List of future strategies:
[13:23:08.057] 1. multicore:
[13:23:08.057]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:08.057]    - tweaked: FALSE
[13:23:08.057]    - call: plan(strategy)
[13:23:08.063] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:08.066] resolve() on environment ...
[13:23:08.066]  recursive: 0
[13:23:08.067]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:08.067] signalConditionsASAP(numeric, pos=1) ...
[13:23:08.067] - nx: 4
[13:23:08.067] - relay: TRUE
[13:23:08.067] - stdout: TRUE
[13:23:08.068] - signal: TRUE
[13:23:08.068] - resignal: FALSE
[13:23:08.068] - force: TRUE
[13:23:08.068] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.068] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.068]  - until=2
[13:23:08.068]  - relaying element #2
[13:23:08.068] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:08.069] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.069] signalConditionsASAP(NULL, pos=1) ... done
[13:23:08.069]  length: 3 (resolved future 1)
[13:23:08.069] Future #2
[13:23:08.069] result() for MulticoreFuture ...
[13:23:08.069] result() for MulticoreFuture ... done
[13:23:08.070] result() for MulticoreFuture ...
[13:23:08.070] result() for MulticoreFuture ... done
[13:23:08.070] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:08.070] - nx: 4
[13:23:08.070] - relay: TRUE
[13:23:08.070] - stdout: TRUE
[13:23:08.070] - signal: TRUE
[13:23:08.071] - resignal: FALSE
[13:23:08.071] - force: TRUE
[13:23:08.071] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:08.071] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.071]  - until=2
[13:23:08.071]  - relaying element #2
[13:23:08.071] result() for MulticoreFuture ...
[13:23:08.071] result() for MulticoreFuture ... done
[13:23:08.072] result() for MulticoreFuture ...
[13:23:08.072] result() for MulticoreFuture ... done
[13:23:08.072] result() for MulticoreFuture ...
[13:23:08.072] result() for MulticoreFuture ... done
[13:23:08.072] result() for MulticoreFuture ...
[13:23:08.072] result() for MulticoreFuture ... done
[13:23:08.072] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:08.073] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:08.073] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:08.073]  length: 2 (resolved future 2)
[13:23:08.073] Future #3
[13:23:08.073] result() for MulticoreFuture ...
[13:23:08.074] result() for MulticoreFuture ...
[13:23:08.074] result() for MulticoreFuture ... done
[13:23:08.075] result() for MulticoreFuture ... done
[13:23:08.075] result() for MulticoreFuture ...
[13:23:08.075] result() for MulticoreFuture ... done
[13:23:08.075] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:08.075] - nx: 4
[13:23:08.075] - relay: TRUE
[13:23:08.075] - stdout: TRUE
[13:23:08.075] - signal: TRUE
[13:23:08.076] - resignal: FALSE
[13:23:08.076] - force: TRUE
[13:23:08.076] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:08.076] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:08.076]  - until=3
[13:23:08.076]  - relaying element #3
[13:23:08.076] result() for MulticoreFuture ...
[13:23:08.077] result() for MulticoreFuture ... done
[13:23:08.077] result() for MulticoreFuture ...
[13:23:08.077] result() for MulticoreFuture ... done
[13:23:08.077] result() for MulticoreFuture ...
[13:23:08.077] result() for MulticoreFuture ... done
[13:23:08.077] result() for MulticoreFuture ...
[13:23:08.077] result() for MulticoreFuture ... done
[13:23:08.077] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:08.078] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:08.078] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:08.078]  length: 1 (resolved future 3)
[13:23:08.078] Future #4
[13:23:08.078] result() for MulticoreFuture ...
[13:23:08.079] result() for MulticoreFuture ...
[13:23:08.079] result() for MulticoreFuture ... done
[13:23:08.080] result() for MulticoreFuture ... done
[13:23:08.080] result() for MulticoreFuture ...
[13:23:08.080] result() for MulticoreFuture ... done
[13:23:08.080] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:08.080] - nx: 4
[13:23:08.081] - relay: TRUE
[13:23:08.081] - stdout: TRUE
[13:23:08.081] - signal: TRUE
[13:23:08.081] - resignal: FALSE
[13:23:08.081] - force: TRUE
[13:23:08.081] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:08.081] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:08.082]  - until=4
[13:23:08.082]  - relaying element #4
[13:23:08.082] result() for MulticoreFuture ...
[13:23:08.082] result() for MulticoreFuture ... done
[13:23:08.082] result() for MulticoreFuture ...
[13:23:08.083] result() for MulticoreFuture ... done
[13:23:08.083] result() for MulticoreFuture ...
[13:23:08.083] result() for MulticoreFuture ... done
[13:23:08.083] result() for MulticoreFuture ...
[13:23:08.083] result() for MulticoreFuture ... done
[13:23:08.083] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:08.084] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:08.084] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:08.084]  length: 0 (resolved future 4)
[13:23:08.084] Relaying remaining futures
[13:23:08.084] signalConditionsASAP(NULL, pos=0) ...
[13:23:08.084] - nx: 4
[13:23:08.084] - relay: TRUE
[13:23:08.084] - stdout: TRUE
[13:23:08.084] - signal: TRUE
[13:23:08.085] - resignal: FALSE
[13:23:08.085] - force: TRUE
[13:23:08.085] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:08.085] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:08.085] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:08.085] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:08.085] signalConditionsASAP(NULL, pos=0) ... done
[13:23:08.085] resolve() on environment ... DONE
[13:23:08.085] result() for MulticoreFuture ...
[13:23:08.086] result() for MulticoreFuture ... done
[13:23:08.086] result() for MulticoreFuture ...
[13:23:08.086] result() for MulticoreFuture ... done
[13:23:08.086] result() for MulticoreFuture ...
[13:23:08.086] result() for MulticoreFuture ... done
[13:23:08.086] result() for MulticoreFuture ...
[13:23:08.086] result() for MulticoreFuture ... done
[13:23:08.086] result() for MulticoreFuture ...
[13:23:08.086] result() for MulticoreFuture ... done
[13:23:08.087] result() for MulticoreFuture ...
[13:23:08.087] result() for MulticoreFuture ... done
<environment: 0x5596d6634b20> 
Type of future: multisession
[13:23:08.087] plan(): Setting new future strategy stack:
[13:23:08.087] List of future strategies:
[13:23:08.087] 1. multisession:
[13:23:08.087]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:08.087]    - tweaked: FALSE
[13:23:08.087]    - call: plan(strategy)
[13:23:08.088] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:23:08.088] multisession:
[13:23:08.088] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:08.088] - tweaked: FALSE
[13:23:08.088] - call: plan(strategy)
[13:23:08.093] getGlobalsAndPackages() ...
[13:23:08.093] Not searching for globals
[13:23:08.093] - globals: [0] <none>
[13:23:08.093] getGlobalsAndPackages() ... DONE
[13:23:08.094] [local output] makeClusterPSOCK() ...
[13:23:08.097] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:23:08.098] [local output] Base port: 11698
[13:23:08.098] [local output] Getting setup options for 2 cluster nodes ...
[13:23:08.098] [local output]  - Node 1 of 2 ...
[13:23:08.099] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:08.100] [local output] Rscript port: 11698

[13:23:08.100] [local output]  - Node 2 of 2 ...
[13:23:08.100] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:08.101] [local output] Rscript port: 11698

[13:23:08.101] [local output] Getting setup options for 2 cluster nodes ... done
[13:23:08.102] [local output]  - Parallel setup requested for some PSOCK nodes
[13:23:08.102] [local output] Setting up PSOCK nodes in parallel
[13:23:08.102] List of 36
[13:23:08.102]  $ worker          : chr "localhost"
[13:23:08.102]   ..- attr(*, "localhost")= logi TRUE
[13:23:08.102]  $ master          : chr "localhost"
[13:23:08.102]  $ port            : int 11698
[13:23:08.102]  $ connectTimeout  : num 120
[13:23:08.102]  $ timeout         : num 2592000
[13:23:08.102]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:23:08.102]  $ homogeneous     : logi TRUE
[13:23:08.102]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:23:08.102]  $ rscript_envs    : NULL
[13:23:08.102]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:08.102]  $ rscript_startup : NULL
[13:23:08.102]  $ rscript_sh      : chr "sh"
[13:23:08.102]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:08.102]  $ methods         : logi TRUE
[13:23:08.102]  $ socketOptions   : chr "no-delay"
[13:23:08.102]  $ useXDR          : logi FALSE
[13:23:08.102]  $ outfile         : chr "/dev/null"
[13:23:08.102]  $ renice          : int NA
[13:23:08.102]  $ rshcmd          : NULL
[13:23:08.102]  $ user            : chr(0) 
[13:23:08.102]  $ revtunnel       : logi FALSE
[13:23:08.102]  $ rshlogfile      : NULL
[13:23:08.102]  $ rshopts         : chr(0) 
[13:23:08.102]  $ rank            : int 1
[13:23:08.102]  $ manual          : logi FALSE
[13:23:08.102]  $ dryrun          : logi FALSE
[13:23:08.102]  $ quiet           : logi FALSE
[13:23:08.102]  $ setup_strategy  : chr "parallel"
[13:23:08.102]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:08.102]  $ pidfile         : chr "/tmp/RtmpMODyD9/worker.rank=1.parallelly.parent=84369.1499165ea6147.pid"
[13:23:08.102]  $ rshcmd_label    : NULL
[13:23:08.102]  $ rsh_call        : NULL
[13:23:08.102]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:08.102]  $ localMachine    : logi TRUE
[13:23:08.102]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:23:08.102]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:23:08.102]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:23:08.102]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:23:08.102]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:23:08.102]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:23:08.102]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:23:08.102]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:23:08.102]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:23:08.102]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:23:08.102]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:23:08.102]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:23:08.102]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:23:08.102]  $ arguments       :List of 28
[13:23:08.102]   ..$ worker          : chr "localhost"
[13:23:08.102]   ..$ master          : NULL
[13:23:08.102]   ..$ port            : int 11698
[13:23:08.102]   ..$ connectTimeout  : num 120
[13:23:08.102]   ..$ timeout         : num 2592000
[13:23:08.102]   ..$ rscript         : NULL
[13:23:08.102]   ..$ homogeneous     : NULL
[13:23:08.102]   ..$ rscript_args    : NULL
[13:23:08.102]   ..$ rscript_envs    : NULL
[13:23:08.102]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:08.102]   ..$ rscript_startup : NULL
[13:23:08.102]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:23:08.102]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:08.102]   ..$ methods         : logi TRUE
[13:23:08.102]   ..$ socketOptions   : chr "no-delay"
[13:23:08.102]   ..$ useXDR          : logi FALSE
[13:23:08.102]   ..$ outfile         : chr "/dev/null"
[13:23:08.102]   ..$ renice          : int NA
[13:23:08.102]   ..$ rshcmd          : NULL
[13:23:08.102]   ..$ user            : NULL
[13:23:08.102]   ..$ revtunnel       : logi NA
[13:23:08.102]   ..$ rshlogfile      : NULL
[13:23:08.102]   ..$ rshopts         : NULL
[13:23:08.102]   ..$ rank            : int 1
[13:23:08.102]   ..$ manual          : logi FALSE
[13:23:08.102]   ..$ dryrun          : logi FALSE
[13:23:08.102]   ..$ quiet           : logi FALSE
[13:23:08.102]   ..$ setup_strategy  : chr "parallel"
[13:23:08.102]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:23:08.127] [local output] System call to launch all workers:
[13:23:08.128] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMODyD9/worker.rank=1.parallelly.parent=84369.1499165ea6147.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11698 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:23:08.128] [local output] Starting PSOCK main server
[13:23:08.129] [local output] Workers launched
[13:23:08.130] [local output] Waiting for workers to connect back
[13:23:08.130]  - [local output] 0 workers out of 2 ready
[13:23:08.383]  - [local output] 0 workers out of 2 ready
[13:23:08.384]  - [local output] 1 workers out of 2 ready
[13:23:08.384]  - [local output] 2 workers out of 2 ready
[13:23:08.384] [local output] Launching of workers completed
[13:23:08.384] [local output] Collecting session information from workers
[13:23:08.385] [local output]  - Worker #1 of 2
[13:23:08.385] [local output]  - Worker #2 of 2
[13:23:08.386] [local output] makeClusterPSOCK() ... done
[13:23:08.398] Packages needed by the future expression (n = 0): <none>
[13:23:08.398] Packages needed by future strategies (n = 0): <none>
[13:23:08.398] {
[13:23:08.398]     {
[13:23:08.398]         {
[13:23:08.398]             ...future.startTime <- base::Sys.time()
[13:23:08.398]             {
[13:23:08.398]                 {
[13:23:08.398]                   {
[13:23:08.398]                     {
[13:23:08.398]                       base::local({
[13:23:08.398]                         has_future <- base::requireNamespace("future", 
[13:23:08.398]                           quietly = TRUE)
[13:23:08.398]                         if (has_future) {
[13:23:08.398]                           ns <- base::getNamespace("future")
[13:23:08.398]                           version <- ns[[".package"]][["version"]]
[13:23:08.398]                           if (is.null(version)) 
[13:23:08.398]                             version <- utils::packageVersion("future")
[13:23:08.398]                         }
[13:23:08.398]                         else {
[13:23:08.398]                           version <- NULL
[13:23:08.398]                         }
[13:23:08.398]                         if (!has_future || version < "1.8.0") {
[13:23:08.398]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.398]                             "", base::R.version$version.string), 
[13:23:08.398]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.398]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.398]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.398]                               "release", "version")], collapse = " "), 
[13:23:08.398]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.398]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.398]                             info)
[13:23:08.398]                           info <- base::paste(info, collapse = "; ")
[13:23:08.398]                           if (!has_future) {
[13:23:08.398]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.398]                               info)
[13:23:08.398]                           }
[13:23:08.398]                           else {
[13:23:08.398]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.398]                               info, version)
[13:23:08.398]                           }
[13:23:08.398]                           base::stop(msg)
[13:23:08.398]                         }
[13:23:08.398]                       })
[13:23:08.398]                     }
[13:23:08.398]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.398]                     base::options(mc.cores = 1L)
[13:23:08.398]                   }
[13:23:08.398]                   options(future.plan = NULL)
[13:23:08.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.398]                 }
[13:23:08.398]                 ...future.workdir <- getwd()
[13:23:08.398]             }
[13:23:08.398]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.398]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.398]         }
[13:23:08.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.398]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.398]             base::names(...future.oldOptions))
[13:23:08.398]     }
[13:23:08.398]     if (FALSE) {
[13:23:08.398]     }
[13:23:08.398]     else {
[13:23:08.398]         if (TRUE) {
[13:23:08.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.398]                 open = "w")
[13:23:08.398]         }
[13:23:08.398]         else {
[13:23:08.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.398]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.398]         }
[13:23:08.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.398]             base::sink(type = "output", split = FALSE)
[13:23:08.398]             base::close(...future.stdout)
[13:23:08.398]         }, add = TRUE)
[13:23:08.398]     }
[13:23:08.398]     ...future.frame <- base::sys.nframe()
[13:23:08.398]     ...future.conditions <- base::list()
[13:23:08.398]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.398]     if (FALSE) {
[13:23:08.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.398]     }
[13:23:08.398]     ...future.result <- base::tryCatch({
[13:23:08.398]         base::withCallingHandlers({
[13:23:08.398]             ...future.value <- base::withVisible(base::local({
[13:23:08.398]                 ...future.makeSendCondition <- base::local({
[13:23:08.398]                   sendCondition <- NULL
[13:23:08.398]                   function(frame = 1L) {
[13:23:08.398]                     if (is.function(sendCondition)) 
[13:23:08.398]                       return(sendCondition)
[13:23:08.398]                     ns <- getNamespace("parallel")
[13:23:08.398]                     if (exists("sendData", mode = "function", 
[13:23:08.398]                       envir = ns)) {
[13:23:08.398]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.398]                         envir = ns)
[13:23:08.398]                       envir <- sys.frame(frame)
[13:23:08.398]                       master <- NULL
[13:23:08.398]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.398]                         !identical(envir, emptyenv())) {
[13:23:08.398]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.398]                           inherits = FALSE)) {
[13:23:08.398]                           master <- get("master", mode = "list", 
[13:23:08.398]                             envir = envir, inherits = FALSE)
[13:23:08.398]                           if (inherits(master, c("SOCKnode", 
[13:23:08.398]                             "SOCK0node"))) {
[13:23:08.398]                             sendCondition <<- function(cond) {
[13:23:08.398]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.398]                                 success = TRUE)
[13:23:08.398]                               parallel_sendData(master, data)
[13:23:08.398]                             }
[13:23:08.398]                             return(sendCondition)
[13:23:08.398]                           }
[13:23:08.398]                         }
[13:23:08.398]                         frame <- frame + 1L
[13:23:08.398]                         envir <- sys.frame(frame)
[13:23:08.398]                       }
[13:23:08.398]                     }
[13:23:08.398]                     sendCondition <<- function(cond) NULL
[13:23:08.398]                   }
[13:23:08.398]                 })
[13:23:08.398]                 withCallingHandlers({
[13:23:08.398]                   NA
[13:23:08.398]                 }, immediateCondition = function(cond) {
[13:23:08.398]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.398]                   sendCondition(cond)
[13:23:08.398]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.398]                   {
[13:23:08.398]                     inherits <- base::inherits
[13:23:08.398]                     invokeRestart <- base::invokeRestart
[13:23:08.398]                     is.null <- base::is.null
[13:23:08.398]                     muffled <- FALSE
[13:23:08.398]                     if (inherits(cond, "message")) {
[13:23:08.398]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.398]                       if (muffled) 
[13:23:08.398]                         invokeRestart("muffleMessage")
[13:23:08.398]                     }
[13:23:08.398]                     else if (inherits(cond, "warning")) {
[13:23:08.398]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.398]                       if (muffled) 
[13:23:08.398]                         invokeRestart("muffleWarning")
[13:23:08.398]                     }
[13:23:08.398]                     else if (inherits(cond, "condition")) {
[13:23:08.398]                       if (!is.null(pattern)) {
[13:23:08.398]                         computeRestarts <- base::computeRestarts
[13:23:08.398]                         grepl <- base::grepl
[13:23:08.398]                         restarts <- computeRestarts(cond)
[13:23:08.398]                         for (restart in restarts) {
[13:23:08.398]                           name <- restart$name
[13:23:08.398]                           if (is.null(name)) 
[13:23:08.398]                             next
[13:23:08.398]                           if (!grepl(pattern, name)) 
[13:23:08.398]                             next
[13:23:08.398]                           invokeRestart(restart)
[13:23:08.398]                           muffled <- TRUE
[13:23:08.398]                           break
[13:23:08.398]                         }
[13:23:08.398]                       }
[13:23:08.398]                     }
[13:23:08.398]                     invisible(muffled)
[13:23:08.398]                   }
[13:23:08.398]                   muffleCondition(cond)
[13:23:08.398]                 })
[13:23:08.398]             }))
[13:23:08.398]             future::FutureResult(value = ...future.value$value, 
[13:23:08.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.398]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.398]                     ...future.globalenv.names))
[13:23:08.398]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.398]         }, condition = base::local({
[13:23:08.398]             c <- base::c
[13:23:08.398]             inherits <- base::inherits
[13:23:08.398]             invokeRestart <- base::invokeRestart
[13:23:08.398]             length <- base::length
[13:23:08.398]             list <- base::list
[13:23:08.398]             seq.int <- base::seq.int
[13:23:08.398]             signalCondition <- base::signalCondition
[13:23:08.398]             sys.calls <- base::sys.calls
[13:23:08.398]             `[[` <- base::`[[`
[13:23:08.398]             `+` <- base::`+`
[13:23:08.398]             `<<-` <- base::`<<-`
[13:23:08.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.398]                   3L)]
[13:23:08.398]             }
[13:23:08.398]             function(cond) {
[13:23:08.398]                 is_error <- inherits(cond, "error")
[13:23:08.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.398]                   NULL)
[13:23:08.398]                 if (is_error) {
[13:23:08.398]                   sessionInformation <- function() {
[13:23:08.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.398]                       search = base::search(), system = base::Sys.info())
[13:23:08.398]                   }
[13:23:08.398]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.398]                     cond$call), session = sessionInformation(), 
[13:23:08.398]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.398]                   signalCondition(cond)
[13:23:08.398]                 }
[13:23:08.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.398]                 "immediateCondition"))) {
[13:23:08.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.398]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.398]                   if (TRUE && !signal) {
[13:23:08.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.398]                     {
[13:23:08.398]                       inherits <- base::inherits
[13:23:08.398]                       invokeRestart <- base::invokeRestart
[13:23:08.398]                       is.null <- base::is.null
[13:23:08.398]                       muffled <- FALSE
[13:23:08.398]                       if (inherits(cond, "message")) {
[13:23:08.398]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.398]                         if (muffled) 
[13:23:08.398]                           invokeRestart("muffleMessage")
[13:23:08.398]                       }
[13:23:08.398]                       else if (inherits(cond, "warning")) {
[13:23:08.398]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.398]                         if (muffled) 
[13:23:08.398]                           invokeRestart("muffleWarning")
[13:23:08.398]                       }
[13:23:08.398]                       else if (inherits(cond, "condition")) {
[13:23:08.398]                         if (!is.null(pattern)) {
[13:23:08.398]                           computeRestarts <- base::computeRestarts
[13:23:08.398]                           grepl <- base::grepl
[13:23:08.398]                           restarts <- computeRestarts(cond)
[13:23:08.398]                           for (restart in restarts) {
[13:23:08.398]                             name <- restart$name
[13:23:08.398]                             if (is.null(name)) 
[13:23:08.398]                               next
[13:23:08.398]                             if (!grepl(pattern, name)) 
[13:23:08.398]                               next
[13:23:08.398]                             invokeRestart(restart)
[13:23:08.398]                             muffled <- TRUE
[13:23:08.398]                             break
[13:23:08.398]                           }
[13:23:08.398]                         }
[13:23:08.398]                       }
[13:23:08.398]                       invisible(muffled)
[13:23:08.398]                     }
[13:23:08.398]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.398]                   }
[13:23:08.398]                 }
[13:23:08.398]                 else {
[13:23:08.398]                   if (TRUE) {
[13:23:08.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.398]                     {
[13:23:08.398]                       inherits <- base::inherits
[13:23:08.398]                       invokeRestart <- base::invokeRestart
[13:23:08.398]                       is.null <- base::is.null
[13:23:08.398]                       muffled <- FALSE
[13:23:08.398]                       if (inherits(cond, "message")) {
[13:23:08.398]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.398]                         if (muffled) 
[13:23:08.398]                           invokeRestart("muffleMessage")
[13:23:08.398]                       }
[13:23:08.398]                       else if (inherits(cond, "warning")) {
[13:23:08.398]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.398]                         if (muffled) 
[13:23:08.398]                           invokeRestart("muffleWarning")
[13:23:08.398]                       }
[13:23:08.398]                       else if (inherits(cond, "condition")) {
[13:23:08.398]                         if (!is.null(pattern)) {
[13:23:08.398]                           computeRestarts <- base::computeRestarts
[13:23:08.398]                           grepl <- base::grepl
[13:23:08.398]                           restarts <- computeRestarts(cond)
[13:23:08.398]                           for (restart in restarts) {
[13:23:08.398]                             name <- restart$name
[13:23:08.398]                             if (is.null(name)) 
[13:23:08.398]                               next
[13:23:08.398]                             if (!grepl(pattern, name)) 
[13:23:08.398]                               next
[13:23:08.398]                             invokeRestart(restart)
[13:23:08.398]                             muffled <- TRUE
[13:23:08.398]                             break
[13:23:08.398]                           }
[13:23:08.398]                         }
[13:23:08.398]                       }
[13:23:08.398]                       invisible(muffled)
[13:23:08.398]                     }
[13:23:08.398]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.398]                   }
[13:23:08.398]                 }
[13:23:08.398]             }
[13:23:08.398]         }))
[13:23:08.398]     }, error = function(ex) {
[13:23:08.398]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.398]                 ...future.rng), started = ...future.startTime, 
[13:23:08.398]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.398]             version = "1.8"), class = "FutureResult")
[13:23:08.398]     }, finally = {
[13:23:08.398]         if (!identical(...future.workdir, getwd())) 
[13:23:08.398]             setwd(...future.workdir)
[13:23:08.398]         {
[13:23:08.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.398]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.398]             }
[13:23:08.398]             base::options(...future.oldOptions)
[13:23:08.398]             if (.Platform$OS.type == "windows") {
[13:23:08.398]                 old_names <- names(...future.oldEnvVars)
[13:23:08.398]                 envs <- base::Sys.getenv()
[13:23:08.398]                 names <- names(envs)
[13:23:08.398]                 common <- intersect(names, old_names)
[13:23:08.398]                 added <- setdiff(names, old_names)
[13:23:08.398]                 removed <- setdiff(old_names, names)
[13:23:08.398]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.398]                   envs[common]]
[13:23:08.398]                 NAMES <- toupper(changed)
[13:23:08.398]                 args <- list()
[13:23:08.398]                 for (kk in seq_along(NAMES)) {
[13:23:08.398]                   name <- changed[[kk]]
[13:23:08.398]                   NAME <- NAMES[[kk]]
[13:23:08.398]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.398]                     next
[13:23:08.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.398]                 }
[13:23:08.398]                 NAMES <- toupper(added)
[13:23:08.398]                 for (kk in seq_along(NAMES)) {
[13:23:08.398]                   name <- added[[kk]]
[13:23:08.398]                   NAME <- NAMES[[kk]]
[13:23:08.398]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.398]                     next
[13:23:08.398]                   args[[name]] <- ""
[13:23:08.398]                 }
[13:23:08.398]                 NAMES <- toupper(removed)
[13:23:08.398]                 for (kk in seq_along(NAMES)) {
[13:23:08.398]                   name <- removed[[kk]]
[13:23:08.398]                   NAME <- NAMES[[kk]]
[13:23:08.398]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.398]                     next
[13:23:08.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.398]                 }
[13:23:08.398]                 if (length(args) > 0) 
[13:23:08.398]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.398]             }
[13:23:08.398]             else {
[13:23:08.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.398]             }
[13:23:08.398]             {
[13:23:08.398]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.398]                   0L) {
[13:23:08.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.398]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.398]                   base::options(opts)
[13:23:08.398]                 }
[13:23:08.398]                 {
[13:23:08.398]                   {
[13:23:08.398]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.398]                     NULL
[13:23:08.398]                   }
[13:23:08.398]                   options(future.plan = NULL)
[13:23:08.398]                   if (is.na(NA_character_)) 
[13:23:08.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.398]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.398]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.398]                     envir = parent.frame()) 
[13:23:08.398]                   {
[13:23:08.398]                     if (is.function(workers)) 
[13:23:08.398]                       workers <- workers()
[13:23:08.398]                     workers <- structure(as.integer(workers), 
[13:23:08.398]                       class = class(workers))
[13:23:08.398]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.398]                       workers >= 1)
[13:23:08.398]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.398]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.398]                     }
[13:23:08.398]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.398]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.398]                       envir = envir)
[13:23:08.398]                     if (!future$lazy) 
[13:23:08.398]                       future <- run(future)
[13:23:08.398]                     invisible(future)
[13:23:08.398]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.398]                 }
[13:23:08.398]             }
[13:23:08.398]         }
[13:23:08.398]     })
[13:23:08.398]     if (TRUE) {
[13:23:08.398]         base::sink(type = "output", split = FALSE)
[13:23:08.398]         if (TRUE) {
[13:23:08.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.398]         }
[13:23:08.398]         else {
[13:23:08.398]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.398]         }
[13:23:08.398]         base::close(...future.stdout)
[13:23:08.398]         ...future.stdout <- NULL
[13:23:08.398]     }
[13:23:08.398]     ...future.result$conditions <- ...future.conditions
[13:23:08.398]     ...future.result$finished <- base::Sys.time()
[13:23:08.398]     ...future.result
[13:23:08.398] }
[13:23:08.467] MultisessionFuture started
[13:23:08.467] result() for ClusterFuture ...
[13:23:08.467] receiveMessageFromWorker() for ClusterFuture ...
[13:23:08.468] - Validating connection of MultisessionFuture
[13:23:08.521] - received message: FutureResult
[13:23:08.521] - Received FutureResult
[13:23:08.522] - Erased future from FutureRegistry
[13:23:08.522] result() for ClusterFuture ...
[13:23:08.522] - result already collected: FutureResult
[13:23:08.522] result() for ClusterFuture ... done
[13:23:08.522] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:08.522] result() for ClusterFuture ... done
[13:23:08.522] result() for ClusterFuture ...
[13:23:08.522] - result already collected: FutureResult
[13:23:08.523] result() for ClusterFuture ... done
[13:23:08.523] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:23:08.526] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:23:08.527] getGlobalsAndPackages() ...
[13:23:08.527] Searching for globals...
[13:23:08.527] 
[13:23:08.527] Searching for globals ... DONE
[13:23:08.528] - globals: [0] <none>
[13:23:08.528] getGlobalsAndPackages() ... DONE
[13:23:08.528] run() for ‘Future’ ...
[13:23:08.528] - state: ‘created’
[13:23:08.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.543] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.543] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:08.544]   - Field: ‘node’
[13:23:08.544]   - Field: ‘label’
[13:23:08.544]   - Field: ‘local’
[13:23:08.544]   - Field: ‘owner’
[13:23:08.544]   - Field: ‘envir’
[13:23:08.544]   - Field: ‘workers’
[13:23:08.544]   - Field: ‘packages’
[13:23:08.545]   - Field: ‘gc’
[13:23:08.545]   - Field: ‘conditions’
[13:23:08.545]   - Field: ‘persistent’
[13:23:08.545]   - Field: ‘expr’
[13:23:08.545]   - Field: ‘uuid’
[13:23:08.545]   - Field: ‘seed’
[13:23:08.545]   - Field: ‘version’
[13:23:08.545]   - Field: ‘result’
[13:23:08.545]   - Field: ‘asynchronous’
[13:23:08.545]   - Field: ‘calls’
[13:23:08.546]   - Field: ‘globals’
[13:23:08.546]   - Field: ‘stdout’
[13:23:08.546]   - Field: ‘earlySignal’
[13:23:08.546]   - Field: ‘lazy’
[13:23:08.546]   - Field: ‘state’
[13:23:08.546] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:08.546] - Launch lazy future ...
[13:23:08.547] Packages needed by the future expression (n = 0): <none>
[13:23:08.547] Packages needed by future strategies (n = 0): <none>
[13:23:08.547] {
[13:23:08.547]     {
[13:23:08.547]         {
[13:23:08.547]             ...future.startTime <- base::Sys.time()
[13:23:08.547]             {
[13:23:08.547]                 {
[13:23:08.547]                   {
[13:23:08.547]                     {
[13:23:08.547]                       base::local({
[13:23:08.547]                         has_future <- base::requireNamespace("future", 
[13:23:08.547]                           quietly = TRUE)
[13:23:08.547]                         if (has_future) {
[13:23:08.547]                           ns <- base::getNamespace("future")
[13:23:08.547]                           version <- ns[[".package"]][["version"]]
[13:23:08.547]                           if (is.null(version)) 
[13:23:08.547]                             version <- utils::packageVersion("future")
[13:23:08.547]                         }
[13:23:08.547]                         else {
[13:23:08.547]                           version <- NULL
[13:23:08.547]                         }
[13:23:08.547]                         if (!has_future || version < "1.8.0") {
[13:23:08.547]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.547]                             "", base::R.version$version.string), 
[13:23:08.547]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.547]                               "release", "version")], collapse = " "), 
[13:23:08.547]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.547]                             info)
[13:23:08.547]                           info <- base::paste(info, collapse = "; ")
[13:23:08.547]                           if (!has_future) {
[13:23:08.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.547]                               info)
[13:23:08.547]                           }
[13:23:08.547]                           else {
[13:23:08.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.547]                               info, version)
[13:23:08.547]                           }
[13:23:08.547]                           base::stop(msg)
[13:23:08.547]                         }
[13:23:08.547]                       })
[13:23:08.547]                     }
[13:23:08.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.547]                     base::options(mc.cores = 1L)
[13:23:08.547]                   }
[13:23:08.547]                   options(future.plan = NULL)
[13:23:08.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.547]                 }
[13:23:08.547]                 ...future.workdir <- getwd()
[13:23:08.547]             }
[13:23:08.547]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.547]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.547]         }
[13:23:08.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.547]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.547]             base::names(...future.oldOptions))
[13:23:08.547]     }
[13:23:08.547]     if (FALSE) {
[13:23:08.547]     }
[13:23:08.547]     else {
[13:23:08.547]         if (TRUE) {
[13:23:08.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.547]                 open = "w")
[13:23:08.547]         }
[13:23:08.547]         else {
[13:23:08.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.547]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.547]         }
[13:23:08.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.547]             base::sink(type = "output", split = FALSE)
[13:23:08.547]             base::close(...future.stdout)
[13:23:08.547]         }, add = TRUE)
[13:23:08.547]     }
[13:23:08.547]     ...future.frame <- base::sys.nframe()
[13:23:08.547]     ...future.conditions <- base::list()
[13:23:08.547]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.547]     if (FALSE) {
[13:23:08.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.547]     }
[13:23:08.547]     ...future.result <- base::tryCatch({
[13:23:08.547]         base::withCallingHandlers({
[13:23:08.547]             ...future.value <- base::withVisible(base::local({
[13:23:08.547]                 ...future.makeSendCondition <- base::local({
[13:23:08.547]                   sendCondition <- NULL
[13:23:08.547]                   function(frame = 1L) {
[13:23:08.547]                     if (is.function(sendCondition)) 
[13:23:08.547]                       return(sendCondition)
[13:23:08.547]                     ns <- getNamespace("parallel")
[13:23:08.547]                     if (exists("sendData", mode = "function", 
[13:23:08.547]                       envir = ns)) {
[13:23:08.547]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.547]                         envir = ns)
[13:23:08.547]                       envir <- sys.frame(frame)
[13:23:08.547]                       master <- NULL
[13:23:08.547]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.547]                         !identical(envir, emptyenv())) {
[13:23:08.547]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.547]                           inherits = FALSE)) {
[13:23:08.547]                           master <- get("master", mode = "list", 
[13:23:08.547]                             envir = envir, inherits = FALSE)
[13:23:08.547]                           if (inherits(master, c("SOCKnode", 
[13:23:08.547]                             "SOCK0node"))) {
[13:23:08.547]                             sendCondition <<- function(cond) {
[13:23:08.547]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.547]                                 success = TRUE)
[13:23:08.547]                               parallel_sendData(master, data)
[13:23:08.547]                             }
[13:23:08.547]                             return(sendCondition)
[13:23:08.547]                           }
[13:23:08.547]                         }
[13:23:08.547]                         frame <- frame + 1L
[13:23:08.547]                         envir <- sys.frame(frame)
[13:23:08.547]                       }
[13:23:08.547]                     }
[13:23:08.547]                     sendCondition <<- function(cond) NULL
[13:23:08.547]                   }
[13:23:08.547]                 })
[13:23:08.547]                 withCallingHandlers({
[13:23:08.547]                   2
[13:23:08.547]                 }, immediateCondition = function(cond) {
[13:23:08.547]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.547]                   sendCondition(cond)
[13:23:08.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.547]                   {
[13:23:08.547]                     inherits <- base::inherits
[13:23:08.547]                     invokeRestart <- base::invokeRestart
[13:23:08.547]                     is.null <- base::is.null
[13:23:08.547]                     muffled <- FALSE
[13:23:08.547]                     if (inherits(cond, "message")) {
[13:23:08.547]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.547]                       if (muffled) 
[13:23:08.547]                         invokeRestart("muffleMessage")
[13:23:08.547]                     }
[13:23:08.547]                     else if (inherits(cond, "warning")) {
[13:23:08.547]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.547]                       if (muffled) 
[13:23:08.547]                         invokeRestart("muffleWarning")
[13:23:08.547]                     }
[13:23:08.547]                     else if (inherits(cond, "condition")) {
[13:23:08.547]                       if (!is.null(pattern)) {
[13:23:08.547]                         computeRestarts <- base::computeRestarts
[13:23:08.547]                         grepl <- base::grepl
[13:23:08.547]                         restarts <- computeRestarts(cond)
[13:23:08.547]                         for (restart in restarts) {
[13:23:08.547]                           name <- restart$name
[13:23:08.547]                           if (is.null(name)) 
[13:23:08.547]                             next
[13:23:08.547]                           if (!grepl(pattern, name)) 
[13:23:08.547]                             next
[13:23:08.547]                           invokeRestart(restart)
[13:23:08.547]                           muffled <- TRUE
[13:23:08.547]                           break
[13:23:08.547]                         }
[13:23:08.547]                       }
[13:23:08.547]                     }
[13:23:08.547]                     invisible(muffled)
[13:23:08.547]                   }
[13:23:08.547]                   muffleCondition(cond)
[13:23:08.547]                 })
[13:23:08.547]             }))
[13:23:08.547]             future::FutureResult(value = ...future.value$value, 
[13:23:08.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.547]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.547]                     ...future.globalenv.names))
[13:23:08.547]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.547]         }, condition = base::local({
[13:23:08.547]             c <- base::c
[13:23:08.547]             inherits <- base::inherits
[13:23:08.547]             invokeRestart <- base::invokeRestart
[13:23:08.547]             length <- base::length
[13:23:08.547]             list <- base::list
[13:23:08.547]             seq.int <- base::seq.int
[13:23:08.547]             signalCondition <- base::signalCondition
[13:23:08.547]             sys.calls <- base::sys.calls
[13:23:08.547]             `[[` <- base::`[[`
[13:23:08.547]             `+` <- base::`+`
[13:23:08.547]             `<<-` <- base::`<<-`
[13:23:08.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.547]                   3L)]
[13:23:08.547]             }
[13:23:08.547]             function(cond) {
[13:23:08.547]                 is_error <- inherits(cond, "error")
[13:23:08.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.547]                   NULL)
[13:23:08.547]                 if (is_error) {
[13:23:08.547]                   sessionInformation <- function() {
[13:23:08.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.547]                       search = base::search(), system = base::Sys.info())
[13:23:08.547]                   }
[13:23:08.547]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.547]                     cond$call), session = sessionInformation(), 
[13:23:08.547]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.547]                   signalCondition(cond)
[13:23:08.547]                 }
[13:23:08.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.547]                 "immediateCondition"))) {
[13:23:08.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.547]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.547]                   if (TRUE && !signal) {
[13:23:08.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.547]                     {
[13:23:08.547]                       inherits <- base::inherits
[13:23:08.547]                       invokeRestart <- base::invokeRestart
[13:23:08.547]                       is.null <- base::is.null
[13:23:08.547]                       muffled <- FALSE
[13:23:08.547]                       if (inherits(cond, "message")) {
[13:23:08.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.547]                         if (muffled) 
[13:23:08.547]                           invokeRestart("muffleMessage")
[13:23:08.547]                       }
[13:23:08.547]                       else if (inherits(cond, "warning")) {
[13:23:08.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.547]                         if (muffled) 
[13:23:08.547]                           invokeRestart("muffleWarning")
[13:23:08.547]                       }
[13:23:08.547]                       else if (inherits(cond, "condition")) {
[13:23:08.547]                         if (!is.null(pattern)) {
[13:23:08.547]                           computeRestarts <- base::computeRestarts
[13:23:08.547]                           grepl <- base::grepl
[13:23:08.547]                           restarts <- computeRestarts(cond)
[13:23:08.547]                           for (restart in restarts) {
[13:23:08.547]                             name <- restart$name
[13:23:08.547]                             if (is.null(name)) 
[13:23:08.547]                               next
[13:23:08.547]                             if (!grepl(pattern, name)) 
[13:23:08.547]                               next
[13:23:08.547]                             invokeRestart(restart)
[13:23:08.547]                             muffled <- TRUE
[13:23:08.547]                             break
[13:23:08.547]                           }
[13:23:08.547]                         }
[13:23:08.547]                       }
[13:23:08.547]                       invisible(muffled)
[13:23:08.547]                     }
[13:23:08.547]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.547]                   }
[13:23:08.547]                 }
[13:23:08.547]                 else {
[13:23:08.547]                   if (TRUE) {
[13:23:08.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.547]                     {
[13:23:08.547]                       inherits <- base::inherits
[13:23:08.547]                       invokeRestart <- base::invokeRestart
[13:23:08.547]                       is.null <- base::is.null
[13:23:08.547]                       muffled <- FALSE
[13:23:08.547]                       if (inherits(cond, "message")) {
[13:23:08.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.547]                         if (muffled) 
[13:23:08.547]                           invokeRestart("muffleMessage")
[13:23:08.547]                       }
[13:23:08.547]                       else if (inherits(cond, "warning")) {
[13:23:08.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.547]                         if (muffled) 
[13:23:08.547]                           invokeRestart("muffleWarning")
[13:23:08.547]                       }
[13:23:08.547]                       else if (inherits(cond, "condition")) {
[13:23:08.547]                         if (!is.null(pattern)) {
[13:23:08.547]                           computeRestarts <- base::computeRestarts
[13:23:08.547]                           grepl <- base::grepl
[13:23:08.547]                           restarts <- computeRestarts(cond)
[13:23:08.547]                           for (restart in restarts) {
[13:23:08.547]                             name <- restart$name
[13:23:08.547]                             if (is.null(name)) 
[13:23:08.547]                               next
[13:23:08.547]                             if (!grepl(pattern, name)) 
[13:23:08.547]                               next
[13:23:08.547]                             invokeRestart(restart)
[13:23:08.547]                             muffled <- TRUE
[13:23:08.547]                             break
[13:23:08.547]                           }
[13:23:08.547]                         }
[13:23:08.547]                       }
[13:23:08.547]                       invisible(muffled)
[13:23:08.547]                     }
[13:23:08.547]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.547]                   }
[13:23:08.547]                 }
[13:23:08.547]             }
[13:23:08.547]         }))
[13:23:08.547]     }, error = function(ex) {
[13:23:08.547]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.547]                 ...future.rng), started = ...future.startTime, 
[13:23:08.547]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.547]             version = "1.8"), class = "FutureResult")
[13:23:08.547]     }, finally = {
[13:23:08.547]         if (!identical(...future.workdir, getwd())) 
[13:23:08.547]             setwd(...future.workdir)
[13:23:08.547]         {
[13:23:08.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.547]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.547]             }
[13:23:08.547]             base::options(...future.oldOptions)
[13:23:08.547]             if (.Platform$OS.type == "windows") {
[13:23:08.547]                 old_names <- names(...future.oldEnvVars)
[13:23:08.547]                 envs <- base::Sys.getenv()
[13:23:08.547]                 names <- names(envs)
[13:23:08.547]                 common <- intersect(names, old_names)
[13:23:08.547]                 added <- setdiff(names, old_names)
[13:23:08.547]                 removed <- setdiff(old_names, names)
[13:23:08.547]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.547]                   envs[common]]
[13:23:08.547]                 NAMES <- toupper(changed)
[13:23:08.547]                 args <- list()
[13:23:08.547]                 for (kk in seq_along(NAMES)) {
[13:23:08.547]                   name <- changed[[kk]]
[13:23:08.547]                   NAME <- NAMES[[kk]]
[13:23:08.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.547]                     next
[13:23:08.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.547]                 }
[13:23:08.547]                 NAMES <- toupper(added)
[13:23:08.547]                 for (kk in seq_along(NAMES)) {
[13:23:08.547]                   name <- added[[kk]]
[13:23:08.547]                   NAME <- NAMES[[kk]]
[13:23:08.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.547]                     next
[13:23:08.547]                   args[[name]] <- ""
[13:23:08.547]                 }
[13:23:08.547]                 NAMES <- toupper(removed)
[13:23:08.547]                 for (kk in seq_along(NAMES)) {
[13:23:08.547]                   name <- removed[[kk]]
[13:23:08.547]                   NAME <- NAMES[[kk]]
[13:23:08.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.547]                     next
[13:23:08.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.547]                 }
[13:23:08.547]                 if (length(args) > 0) 
[13:23:08.547]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.547]             }
[13:23:08.547]             else {
[13:23:08.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.547]             }
[13:23:08.547]             {
[13:23:08.547]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.547]                   0L) {
[13:23:08.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.547]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.547]                   base::options(opts)
[13:23:08.547]                 }
[13:23:08.547]                 {
[13:23:08.547]                   {
[13:23:08.547]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.547]                     NULL
[13:23:08.547]                   }
[13:23:08.547]                   options(future.plan = NULL)
[13:23:08.547]                   if (is.na(NA_character_)) 
[13:23:08.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.547]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.547]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.547]                     envir = parent.frame()) 
[13:23:08.547]                   {
[13:23:08.547]                     if (is.function(workers)) 
[13:23:08.547]                       workers <- workers()
[13:23:08.547]                     workers <- structure(as.integer(workers), 
[13:23:08.547]                       class = class(workers))
[13:23:08.547]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.547]                       workers >= 1)
[13:23:08.547]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.547]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.547]                     }
[13:23:08.547]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.547]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.547]                       envir = envir)
[13:23:08.547]                     if (!future$lazy) 
[13:23:08.547]                       future <- run(future)
[13:23:08.547]                     invisible(future)
[13:23:08.547]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.547]                 }
[13:23:08.547]             }
[13:23:08.547]         }
[13:23:08.547]     })
[13:23:08.547]     if (TRUE) {
[13:23:08.547]         base::sink(type = "output", split = FALSE)
[13:23:08.547]         if (TRUE) {
[13:23:08.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.547]         }
[13:23:08.547]         else {
[13:23:08.547]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.547]         }
[13:23:08.547]         base::close(...future.stdout)
[13:23:08.547]         ...future.stdout <- NULL
[13:23:08.547]     }
[13:23:08.547]     ...future.result$conditions <- ...future.conditions
[13:23:08.547]     ...future.result$finished <- base::Sys.time()
[13:23:08.547]     ...future.result
[13:23:08.547] }
[13:23:08.551] MultisessionFuture started
[13:23:08.551] - Launch lazy future ... done
[13:23:08.551] run() for ‘MultisessionFuture’ ... done
[13:23:08.551] getGlobalsAndPackages() ...
[13:23:08.551] Searching for globals...
[13:23:08.552] 
[13:23:08.552] Searching for globals ... DONE
[13:23:08.552] - globals: [0] <none>
[13:23:08.552] getGlobalsAndPackages() ... DONE
[13:23:08.553] run() for ‘Future’ ...
[13:23:08.553] - state: ‘created’
[13:23:08.553] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.570] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:08.570]   - Field: ‘node’
[13:23:08.570]   - Field: ‘label’
[13:23:08.570]   - Field: ‘local’
[13:23:08.570]   - Field: ‘owner’
[13:23:08.571]   - Field: ‘envir’
[13:23:08.571]   - Field: ‘workers’
[13:23:08.571]   - Field: ‘packages’
[13:23:08.571]   - Field: ‘gc’
[13:23:08.571]   - Field: ‘conditions’
[13:23:08.571]   - Field: ‘persistent’
[13:23:08.571]   - Field: ‘expr’
[13:23:08.571]   - Field: ‘uuid’
[13:23:08.571]   - Field: ‘seed’
[13:23:08.572]   - Field: ‘version’
[13:23:08.572]   - Field: ‘result’
[13:23:08.572]   - Field: ‘asynchronous’
[13:23:08.572]   - Field: ‘calls’
[13:23:08.572]   - Field: ‘globals’
[13:23:08.572]   - Field: ‘stdout’
[13:23:08.572]   - Field: ‘earlySignal’
[13:23:08.572]   - Field: ‘lazy’
[13:23:08.572]   - Field: ‘state’
[13:23:08.573] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:08.573] - Launch lazy future ...
[13:23:08.573] Packages needed by the future expression (n = 0): <none>
[13:23:08.573] Packages needed by future strategies (n = 0): <none>
[13:23:08.574] {
[13:23:08.574]     {
[13:23:08.574]         {
[13:23:08.574]             ...future.startTime <- base::Sys.time()
[13:23:08.574]             {
[13:23:08.574]                 {
[13:23:08.574]                   {
[13:23:08.574]                     {
[13:23:08.574]                       base::local({
[13:23:08.574]                         has_future <- base::requireNamespace("future", 
[13:23:08.574]                           quietly = TRUE)
[13:23:08.574]                         if (has_future) {
[13:23:08.574]                           ns <- base::getNamespace("future")
[13:23:08.574]                           version <- ns[[".package"]][["version"]]
[13:23:08.574]                           if (is.null(version)) 
[13:23:08.574]                             version <- utils::packageVersion("future")
[13:23:08.574]                         }
[13:23:08.574]                         else {
[13:23:08.574]                           version <- NULL
[13:23:08.574]                         }
[13:23:08.574]                         if (!has_future || version < "1.8.0") {
[13:23:08.574]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.574]                             "", base::R.version$version.string), 
[13:23:08.574]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.574]                               "release", "version")], collapse = " "), 
[13:23:08.574]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.574]                             info)
[13:23:08.574]                           info <- base::paste(info, collapse = "; ")
[13:23:08.574]                           if (!has_future) {
[13:23:08.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.574]                               info)
[13:23:08.574]                           }
[13:23:08.574]                           else {
[13:23:08.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.574]                               info, version)
[13:23:08.574]                           }
[13:23:08.574]                           base::stop(msg)
[13:23:08.574]                         }
[13:23:08.574]                       })
[13:23:08.574]                     }
[13:23:08.574]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.574]                     base::options(mc.cores = 1L)
[13:23:08.574]                   }
[13:23:08.574]                   options(future.plan = NULL)
[13:23:08.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.574]                 }
[13:23:08.574]                 ...future.workdir <- getwd()
[13:23:08.574]             }
[13:23:08.574]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.574]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.574]         }
[13:23:08.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.574]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.574]             base::names(...future.oldOptions))
[13:23:08.574]     }
[13:23:08.574]     if (FALSE) {
[13:23:08.574]     }
[13:23:08.574]     else {
[13:23:08.574]         if (TRUE) {
[13:23:08.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.574]                 open = "w")
[13:23:08.574]         }
[13:23:08.574]         else {
[13:23:08.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.574]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.574]         }
[13:23:08.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.574]             base::sink(type = "output", split = FALSE)
[13:23:08.574]             base::close(...future.stdout)
[13:23:08.574]         }, add = TRUE)
[13:23:08.574]     }
[13:23:08.574]     ...future.frame <- base::sys.nframe()
[13:23:08.574]     ...future.conditions <- base::list()
[13:23:08.574]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.574]     if (FALSE) {
[13:23:08.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.574]     }
[13:23:08.574]     ...future.result <- base::tryCatch({
[13:23:08.574]         base::withCallingHandlers({
[13:23:08.574]             ...future.value <- base::withVisible(base::local({
[13:23:08.574]                 ...future.makeSendCondition <- base::local({
[13:23:08.574]                   sendCondition <- NULL
[13:23:08.574]                   function(frame = 1L) {
[13:23:08.574]                     if (is.function(sendCondition)) 
[13:23:08.574]                       return(sendCondition)
[13:23:08.574]                     ns <- getNamespace("parallel")
[13:23:08.574]                     if (exists("sendData", mode = "function", 
[13:23:08.574]                       envir = ns)) {
[13:23:08.574]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.574]                         envir = ns)
[13:23:08.574]                       envir <- sys.frame(frame)
[13:23:08.574]                       master <- NULL
[13:23:08.574]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.574]                         !identical(envir, emptyenv())) {
[13:23:08.574]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.574]                           inherits = FALSE)) {
[13:23:08.574]                           master <- get("master", mode = "list", 
[13:23:08.574]                             envir = envir, inherits = FALSE)
[13:23:08.574]                           if (inherits(master, c("SOCKnode", 
[13:23:08.574]                             "SOCK0node"))) {
[13:23:08.574]                             sendCondition <<- function(cond) {
[13:23:08.574]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.574]                                 success = TRUE)
[13:23:08.574]                               parallel_sendData(master, data)
[13:23:08.574]                             }
[13:23:08.574]                             return(sendCondition)
[13:23:08.574]                           }
[13:23:08.574]                         }
[13:23:08.574]                         frame <- frame + 1L
[13:23:08.574]                         envir <- sys.frame(frame)
[13:23:08.574]                       }
[13:23:08.574]                     }
[13:23:08.574]                     sendCondition <<- function(cond) NULL
[13:23:08.574]                   }
[13:23:08.574]                 })
[13:23:08.574]                 withCallingHandlers({
[13:23:08.574]                   NULL
[13:23:08.574]                 }, immediateCondition = function(cond) {
[13:23:08.574]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.574]                   sendCondition(cond)
[13:23:08.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.574]                   {
[13:23:08.574]                     inherits <- base::inherits
[13:23:08.574]                     invokeRestart <- base::invokeRestart
[13:23:08.574]                     is.null <- base::is.null
[13:23:08.574]                     muffled <- FALSE
[13:23:08.574]                     if (inherits(cond, "message")) {
[13:23:08.574]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.574]                       if (muffled) 
[13:23:08.574]                         invokeRestart("muffleMessage")
[13:23:08.574]                     }
[13:23:08.574]                     else if (inherits(cond, "warning")) {
[13:23:08.574]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.574]                       if (muffled) 
[13:23:08.574]                         invokeRestart("muffleWarning")
[13:23:08.574]                     }
[13:23:08.574]                     else if (inherits(cond, "condition")) {
[13:23:08.574]                       if (!is.null(pattern)) {
[13:23:08.574]                         computeRestarts <- base::computeRestarts
[13:23:08.574]                         grepl <- base::grepl
[13:23:08.574]                         restarts <- computeRestarts(cond)
[13:23:08.574]                         for (restart in restarts) {
[13:23:08.574]                           name <- restart$name
[13:23:08.574]                           if (is.null(name)) 
[13:23:08.574]                             next
[13:23:08.574]                           if (!grepl(pattern, name)) 
[13:23:08.574]                             next
[13:23:08.574]                           invokeRestart(restart)
[13:23:08.574]                           muffled <- TRUE
[13:23:08.574]                           break
[13:23:08.574]                         }
[13:23:08.574]                       }
[13:23:08.574]                     }
[13:23:08.574]                     invisible(muffled)
[13:23:08.574]                   }
[13:23:08.574]                   muffleCondition(cond)
[13:23:08.574]                 })
[13:23:08.574]             }))
[13:23:08.574]             future::FutureResult(value = ...future.value$value, 
[13:23:08.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.574]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.574]                     ...future.globalenv.names))
[13:23:08.574]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.574]         }, condition = base::local({
[13:23:08.574]             c <- base::c
[13:23:08.574]             inherits <- base::inherits
[13:23:08.574]             invokeRestart <- base::invokeRestart
[13:23:08.574]             length <- base::length
[13:23:08.574]             list <- base::list
[13:23:08.574]             seq.int <- base::seq.int
[13:23:08.574]             signalCondition <- base::signalCondition
[13:23:08.574]             sys.calls <- base::sys.calls
[13:23:08.574]             `[[` <- base::`[[`
[13:23:08.574]             `+` <- base::`+`
[13:23:08.574]             `<<-` <- base::`<<-`
[13:23:08.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.574]                   3L)]
[13:23:08.574]             }
[13:23:08.574]             function(cond) {
[13:23:08.574]                 is_error <- inherits(cond, "error")
[13:23:08.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.574]                   NULL)
[13:23:08.574]                 if (is_error) {
[13:23:08.574]                   sessionInformation <- function() {
[13:23:08.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.574]                       search = base::search(), system = base::Sys.info())
[13:23:08.574]                   }
[13:23:08.574]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.574]                     cond$call), session = sessionInformation(), 
[13:23:08.574]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.574]                   signalCondition(cond)
[13:23:08.574]                 }
[13:23:08.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.574]                 "immediateCondition"))) {
[13:23:08.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.574]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.574]                   if (TRUE && !signal) {
[13:23:08.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.574]                     {
[13:23:08.574]                       inherits <- base::inherits
[13:23:08.574]                       invokeRestart <- base::invokeRestart
[13:23:08.574]                       is.null <- base::is.null
[13:23:08.574]                       muffled <- FALSE
[13:23:08.574]                       if (inherits(cond, "message")) {
[13:23:08.574]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.574]                         if (muffled) 
[13:23:08.574]                           invokeRestart("muffleMessage")
[13:23:08.574]                       }
[13:23:08.574]                       else if (inherits(cond, "warning")) {
[13:23:08.574]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.574]                         if (muffled) 
[13:23:08.574]                           invokeRestart("muffleWarning")
[13:23:08.574]                       }
[13:23:08.574]                       else if (inherits(cond, "condition")) {
[13:23:08.574]                         if (!is.null(pattern)) {
[13:23:08.574]                           computeRestarts <- base::computeRestarts
[13:23:08.574]                           grepl <- base::grepl
[13:23:08.574]                           restarts <- computeRestarts(cond)
[13:23:08.574]                           for (restart in restarts) {
[13:23:08.574]                             name <- restart$name
[13:23:08.574]                             if (is.null(name)) 
[13:23:08.574]                               next
[13:23:08.574]                             if (!grepl(pattern, name)) 
[13:23:08.574]                               next
[13:23:08.574]                             invokeRestart(restart)
[13:23:08.574]                             muffled <- TRUE
[13:23:08.574]                             break
[13:23:08.574]                           }
[13:23:08.574]                         }
[13:23:08.574]                       }
[13:23:08.574]                       invisible(muffled)
[13:23:08.574]                     }
[13:23:08.574]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.574]                   }
[13:23:08.574]                 }
[13:23:08.574]                 else {
[13:23:08.574]                   if (TRUE) {
[13:23:08.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.574]                     {
[13:23:08.574]                       inherits <- base::inherits
[13:23:08.574]                       invokeRestart <- base::invokeRestart
[13:23:08.574]                       is.null <- base::is.null
[13:23:08.574]                       muffled <- FALSE
[13:23:08.574]                       if (inherits(cond, "message")) {
[13:23:08.574]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.574]                         if (muffled) 
[13:23:08.574]                           invokeRestart("muffleMessage")
[13:23:08.574]                       }
[13:23:08.574]                       else if (inherits(cond, "warning")) {
[13:23:08.574]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.574]                         if (muffled) 
[13:23:08.574]                           invokeRestart("muffleWarning")
[13:23:08.574]                       }
[13:23:08.574]                       else if (inherits(cond, "condition")) {
[13:23:08.574]                         if (!is.null(pattern)) {
[13:23:08.574]                           computeRestarts <- base::computeRestarts
[13:23:08.574]                           grepl <- base::grepl
[13:23:08.574]                           restarts <- computeRestarts(cond)
[13:23:08.574]                           for (restart in restarts) {
[13:23:08.574]                             name <- restart$name
[13:23:08.574]                             if (is.null(name)) 
[13:23:08.574]                               next
[13:23:08.574]                             if (!grepl(pattern, name)) 
[13:23:08.574]                               next
[13:23:08.574]                             invokeRestart(restart)
[13:23:08.574]                             muffled <- TRUE
[13:23:08.574]                             break
[13:23:08.574]                           }
[13:23:08.574]                         }
[13:23:08.574]                       }
[13:23:08.574]                       invisible(muffled)
[13:23:08.574]                     }
[13:23:08.574]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.574]                   }
[13:23:08.574]                 }
[13:23:08.574]             }
[13:23:08.574]         }))
[13:23:08.574]     }, error = function(ex) {
[13:23:08.574]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.574]                 ...future.rng), started = ...future.startTime, 
[13:23:08.574]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.574]             version = "1.8"), class = "FutureResult")
[13:23:08.574]     }, finally = {
[13:23:08.574]         if (!identical(...future.workdir, getwd())) 
[13:23:08.574]             setwd(...future.workdir)
[13:23:08.574]         {
[13:23:08.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.574]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.574]             }
[13:23:08.574]             base::options(...future.oldOptions)
[13:23:08.574]             if (.Platform$OS.type == "windows") {
[13:23:08.574]                 old_names <- names(...future.oldEnvVars)
[13:23:08.574]                 envs <- base::Sys.getenv()
[13:23:08.574]                 names <- names(envs)
[13:23:08.574]                 common <- intersect(names, old_names)
[13:23:08.574]                 added <- setdiff(names, old_names)
[13:23:08.574]                 removed <- setdiff(old_names, names)
[13:23:08.574]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.574]                   envs[common]]
[13:23:08.574]                 NAMES <- toupper(changed)
[13:23:08.574]                 args <- list()
[13:23:08.574]                 for (kk in seq_along(NAMES)) {
[13:23:08.574]                   name <- changed[[kk]]
[13:23:08.574]                   NAME <- NAMES[[kk]]
[13:23:08.574]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.574]                     next
[13:23:08.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.574]                 }
[13:23:08.574]                 NAMES <- toupper(added)
[13:23:08.574]                 for (kk in seq_along(NAMES)) {
[13:23:08.574]                   name <- added[[kk]]
[13:23:08.574]                   NAME <- NAMES[[kk]]
[13:23:08.574]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.574]                     next
[13:23:08.574]                   args[[name]] <- ""
[13:23:08.574]                 }
[13:23:08.574]                 NAMES <- toupper(removed)
[13:23:08.574]                 for (kk in seq_along(NAMES)) {
[13:23:08.574]                   name <- removed[[kk]]
[13:23:08.574]                   NAME <- NAMES[[kk]]
[13:23:08.574]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.574]                     next
[13:23:08.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.574]                 }
[13:23:08.574]                 if (length(args) > 0) 
[13:23:08.574]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.574]             }
[13:23:08.574]             else {
[13:23:08.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.574]             }
[13:23:08.574]             {
[13:23:08.574]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.574]                   0L) {
[13:23:08.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.574]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.574]                   base::options(opts)
[13:23:08.574]                 }
[13:23:08.574]                 {
[13:23:08.574]                   {
[13:23:08.574]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.574]                     NULL
[13:23:08.574]                   }
[13:23:08.574]                   options(future.plan = NULL)
[13:23:08.574]                   if (is.na(NA_character_)) 
[13:23:08.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.574]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.574]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.574]                     envir = parent.frame()) 
[13:23:08.574]                   {
[13:23:08.574]                     if (is.function(workers)) 
[13:23:08.574]                       workers <- workers()
[13:23:08.574]                     workers <- structure(as.integer(workers), 
[13:23:08.574]                       class = class(workers))
[13:23:08.574]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.574]                       workers >= 1)
[13:23:08.574]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.574]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.574]                     }
[13:23:08.574]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.574]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.574]                       envir = envir)
[13:23:08.574]                     if (!future$lazy) 
[13:23:08.574]                       future <- run(future)
[13:23:08.574]                     invisible(future)
[13:23:08.574]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.574]                 }
[13:23:08.574]             }
[13:23:08.574]         }
[13:23:08.574]     })
[13:23:08.574]     if (TRUE) {
[13:23:08.574]         base::sink(type = "output", split = FALSE)
[13:23:08.574]         if (TRUE) {
[13:23:08.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.574]         }
[13:23:08.574]         else {
[13:23:08.574]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.574]         }
[13:23:08.574]         base::close(...future.stdout)
[13:23:08.574]         ...future.stdout <- NULL
[13:23:08.574]     }
[13:23:08.574]     ...future.result$conditions <- ...future.conditions
[13:23:08.574]     ...future.result$finished <- base::Sys.time()
[13:23:08.574]     ...future.result
[13:23:08.574] }
[13:23:08.632] MultisessionFuture started
[13:23:08.632] - Launch lazy future ... done
[13:23:08.632] run() for ‘MultisessionFuture’ ... done
[13:23:08.632] getGlobalsAndPackages() ...
[13:23:08.633] Searching for globals...
[13:23:08.633] - globals found: [1] ‘{’
[13:23:08.634] Searching for globals ... DONE
[13:23:08.634] Resolving globals: FALSE
[13:23:08.634] 
[13:23:08.634] 
[13:23:08.634] getGlobalsAndPackages() ... DONE
[13:23:08.634] run() for ‘Future’ ...
[13:23:08.635] - state: ‘created’
[13:23:08.635] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.649] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:08.650]   - Field: ‘node’
[13:23:08.650]   - Field: ‘label’
[13:23:08.650]   - Field: ‘local’
[13:23:08.650]   - Field: ‘owner’
[13:23:08.650]   - Field: ‘envir’
[13:23:08.650]   - Field: ‘workers’
[13:23:08.650]   - Field: ‘packages’
[13:23:08.650]   - Field: ‘gc’
[13:23:08.650]   - Field: ‘conditions’
[13:23:08.651]   - Field: ‘persistent’
[13:23:08.651]   - Field: ‘expr’
[13:23:08.651]   - Field: ‘uuid’
[13:23:08.651]   - Field: ‘seed’
[13:23:08.651]   - Field: ‘version’
[13:23:08.651]   - Field: ‘result’
[13:23:08.651]   - Field: ‘asynchronous’
[13:23:08.651]   - Field: ‘calls’
[13:23:08.651]   - Field: ‘globals’
[13:23:08.651]   - Field: ‘stdout’
[13:23:08.652]   - Field: ‘earlySignal’
[13:23:08.652]   - Field: ‘lazy’
[13:23:08.652]   - Field: ‘state’
[13:23:08.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:08.652] - Launch lazy future ...
[13:23:08.652] Packages needed by the future expression (n = 0): <none>
[13:23:08.652] Packages needed by future strategies (n = 0): <none>
[13:23:08.653] {
[13:23:08.653]     {
[13:23:08.653]         {
[13:23:08.653]             ...future.startTime <- base::Sys.time()
[13:23:08.653]             {
[13:23:08.653]                 {
[13:23:08.653]                   {
[13:23:08.653]                     {
[13:23:08.653]                       base::local({
[13:23:08.653]                         has_future <- base::requireNamespace("future", 
[13:23:08.653]                           quietly = TRUE)
[13:23:08.653]                         if (has_future) {
[13:23:08.653]                           ns <- base::getNamespace("future")
[13:23:08.653]                           version <- ns[[".package"]][["version"]]
[13:23:08.653]                           if (is.null(version)) 
[13:23:08.653]                             version <- utils::packageVersion("future")
[13:23:08.653]                         }
[13:23:08.653]                         else {
[13:23:08.653]                           version <- NULL
[13:23:08.653]                         }
[13:23:08.653]                         if (!has_future || version < "1.8.0") {
[13:23:08.653]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.653]                             "", base::R.version$version.string), 
[13:23:08.653]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.653]                               "release", "version")], collapse = " "), 
[13:23:08.653]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.653]                             info)
[13:23:08.653]                           info <- base::paste(info, collapse = "; ")
[13:23:08.653]                           if (!has_future) {
[13:23:08.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.653]                               info)
[13:23:08.653]                           }
[13:23:08.653]                           else {
[13:23:08.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.653]                               info, version)
[13:23:08.653]                           }
[13:23:08.653]                           base::stop(msg)
[13:23:08.653]                         }
[13:23:08.653]                       })
[13:23:08.653]                     }
[13:23:08.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.653]                     base::options(mc.cores = 1L)
[13:23:08.653]                   }
[13:23:08.653]                   options(future.plan = NULL)
[13:23:08.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.653]                 }
[13:23:08.653]                 ...future.workdir <- getwd()
[13:23:08.653]             }
[13:23:08.653]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.653]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.653]         }
[13:23:08.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.653]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.653]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.653]             base::names(...future.oldOptions))
[13:23:08.653]     }
[13:23:08.653]     if (FALSE) {
[13:23:08.653]     }
[13:23:08.653]     else {
[13:23:08.653]         if (TRUE) {
[13:23:08.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.653]                 open = "w")
[13:23:08.653]         }
[13:23:08.653]         else {
[13:23:08.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.653]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.653]         }
[13:23:08.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.653]             base::sink(type = "output", split = FALSE)
[13:23:08.653]             base::close(...future.stdout)
[13:23:08.653]         }, add = TRUE)
[13:23:08.653]     }
[13:23:08.653]     ...future.frame <- base::sys.nframe()
[13:23:08.653]     ...future.conditions <- base::list()
[13:23:08.653]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.653]     if (FALSE) {
[13:23:08.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.653]     }
[13:23:08.653]     ...future.result <- base::tryCatch({
[13:23:08.653]         base::withCallingHandlers({
[13:23:08.653]             ...future.value <- base::withVisible(base::local({
[13:23:08.653]                 ...future.makeSendCondition <- base::local({
[13:23:08.653]                   sendCondition <- NULL
[13:23:08.653]                   function(frame = 1L) {
[13:23:08.653]                     if (is.function(sendCondition)) 
[13:23:08.653]                       return(sendCondition)
[13:23:08.653]                     ns <- getNamespace("parallel")
[13:23:08.653]                     if (exists("sendData", mode = "function", 
[13:23:08.653]                       envir = ns)) {
[13:23:08.653]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.653]                         envir = ns)
[13:23:08.653]                       envir <- sys.frame(frame)
[13:23:08.653]                       master <- NULL
[13:23:08.653]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.653]                         !identical(envir, emptyenv())) {
[13:23:08.653]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.653]                           inherits = FALSE)) {
[13:23:08.653]                           master <- get("master", mode = "list", 
[13:23:08.653]                             envir = envir, inherits = FALSE)
[13:23:08.653]                           if (inherits(master, c("SOCKnode", 
[13:23:08.653]                             "SOCK0node"))) {
[13:23:08.653]                             sendCondition <<- function(cond) {
[13:23:08.653]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.653]                                 success = TRUE)
[13:23:08.653]                               parallel_sendData(master, data)
[13:23:08.653]                             }
[13:23:08.653]                             return(sendCondition)
[13:23:08.653]                           }
[13:23:08.653]                         }
[13:23:08.653]                         frame <- frame + 1L
[13:23:08.653]                         envir <- sys.frame(frame)
[13:23:08.653]                       }
[13:23:08.653]                     }
[13:23:08.653]                     sendCondition <<- function(cond) NULL
[13:23:08.653]                   }
[13:23:08.653]                 })
[13:23:08.653]                 withCallingHandlers({
[13:23:08.653]                   {
[13:23:08.653]                     4
[13:23:08.653]                   }
[13:23:08.653]                 }, immediateCondition = function(cond) {
[13:23:08.653]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.653]                   sendCondition(cond)
[13:23:08.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.653]                   {
[13:23:08.653]                     inherits <- base::inherits
[13:23:08.653]                     invokeRestart <- base::invokeRestart
[13:23:08.653]                     is.null <- base::is.null
[13:23:08.653]                     muffled <- FALSE
[13:23:08.653]                     if (inherits(cond, "message")) {
[13:23:08.653]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.653]                       if (muffled) 
[13:23:08.653]                         invokeRestart("muffleMessage")
[13:23:08.653]                     }
[13:23:08.653]                     else if (inherits(cond, "warning")) {
[13:23:08.653]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.653]                       if (muffled) 
[13:23:08.653]                         invokeRestart("muffleWarning")
[13:23:08.653]                     }
[13:23:08.653]                     else if (inherits(cond, "condition")) {
[13:23:08.653]                       if (!is.null(pattern)) {
[13:23:08.653]                         computeRestarts <- base::computeRestarts
[13:23:08.653]                         grepl <- base::grepl
[13:23:08.653]                         restarts <- computeRestarts(cond)
[13:23:08.653]                         for (restart in restarts) {
[13:23:08.653]                           name <- restart$name
[13:23:08.653]                           if (is.null(name)) 
[13:23:08.653]                             next
[13:23:08.653]                           if (!grepl(pattern, name)) 
[13:23:08.653]                             next
[13:23:08.653]                           invokeRestart(restart)
[13:23:08.653]                           muffled <- TRUE
[13:23:08.653]                           break
[13:23:08.653]                         }
[13:23:08.653]                       }
[13:23:08.653]                     }
[13:23:08.653]                     invisible(muffled)
[13:23:08.653]                   }
[13:23:08.653]                   muffleCondition(cond)
[13:23:08.653]                 })
[13:23:08.653]             }))
[13:23:08.653]             future::FutureResult(value = ...future.value$value, 
[13:23:08.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.653]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.653]                     ...future.globalenv.names))
[13:23:08.653]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.653]         }, condition = base::local({
[13:23:08.653]             c <- base::c
[13:23:08.653]             inherits <- base::inherits
[13:23:08.653]             invokeRestart <- base::invokeRestart
[13:23:08.653]             length <- base::length
[13:23:08.653]             list <- base::list
[13:23:08.653]             seq.int <- base::seq.int
[13:23:08.653]             signalCondition <- base::signalCondition
[13:23:08.653]             sys.calls <- base::sys.calls
[13:23:08.653]             `[[` <- base::`[[`
[13:23:08.653]             `+` <- base::`+`
[13:23:08.653]             `<<-` <- base::`<<-`
[13:23:08.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.653]                   3L)]
[13:23:08.653]             }
[13:23:08.653]             function(cond) {
[13:23:08.653]                 is_error <- inherits(cond, "error")
[13:23:08.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.653]                   NULL)
[13:23:08.653]                 if (is_error) {
[13:23:08.653]                   sessionInformation <- function() {
[13:23:08.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.653]                       search = base::search(), system = base::Sys.info())
[13:23:08.653]                   }
[13:23:08.653]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.653]                     cond$call), session = sessionInformation(), 
[13:23:08.653]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.653]                   signalCondition(cond)
[13:23:08.653]                 }
[13:23:08.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.653]                 "immediateCondition"))) {
[13:23:08.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.653]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.653]                   if (TRUE && !signal) {
[13:23:08.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.653]                     {
[13:23:08.653]                       inherits <- base::inherits
[13:23:08.653]                       invokeRestart <- base::invokeRestart
[13:23:08.653]                       is.null <- base::is.null
[13:23:08.653]                       muffled <- FALSE
[13:23:08.653]                       if (inherits(cond, "message")) {
[13:23:08.653]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.653]                         if (muffled) 
[13:23:08.653]                           invokeRestart("muffleMessage")
[13:23:08.653]                       }
[13:23:08.653]                       else if (inherits(cond, "warning")) {
[13:23:08.653]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.653]                         if (muffled) 
[13:23:08.653]                           invokeRestart("muffleWarning")
[13:23:08.653]                       }
[13:23:08.653]                       else if (inherits(cond, "condition")) {
[13:23:08.653]                         if (!is.null(pattern)) {
[13:23:08.653]                           computeRestarts <- base::computeRestarts
[13:23:08.653]                           grepl <- base::grepl
[13:23:08.653]                           restarts <- computeRestarts(cond)
[13:23:08.653]                           for (restart in restarts) {
[13:23:08.653]                             name <- restart$name
[13:23:08.653]                             if (is.null(name)) 
[13:23:08.653]                               next
[13:23:08.653]                             if (!grepl(pattern, name)) 
[13:23:08.653]                               next
[13:23:08.653]                             invokeRestart(restart)
[13:23:08.653]                             muffled <- TRUE
[13:23:08.653]                             break
[13:23:08.653]                           }
[13:23:08.653]                         }
[13:23:08.653]                       }
[13:23:08.653]                       invisible(muffled)
[13:23:08.653]                     }
[13:23:08.653]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.653]                   }
[13:23:08.653]                 }
[13:23:08.653]                 else {
[13:23:08.653]                   if (TRUE) {
[13:23:08.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.653]                     {
[13:23:08.653]                       inherits <- base::inherits
[13:23:08.653]                       invokeRestart <- base::invokeRestart
[13:23:08.653]                       is.null <- base::is.null
[13:23:08.653]                       muffled <- FALSE
[13:23:08.653]                       if (inherits(cond, "message")) {
[13:23:08.653]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.653]                         if (muffled) 
[13:23:08.653]                           invokeRestart("muffleMessage")
[13:23:08.653]                       }
[13:23:08.653]                       else if (inherits(cond, "warning")) {
[13:23:08.653]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.653]                         if (muffled) 
[13:23:08.653]                           invokeRestart("muffleWarning")
[13:23:08.653]                       }
[13:23:08.653]                       else if (inherits(cond, "condition")) {
[13:23:08.653]                         if (!is.null(pattern)) {
[13:23:08.653]                           computeRestarts <- base::computeRestarts
[13:23:08.653]                           grepl <- base::grepl
[13:23:08.653]                           restarts <- computeRestarts(cond)
[13:23:08.653]                           for (restart in restarts) {
[13:23:08.653]                             name <- restart$name
[13:23:08.653]                             if (is.null(name)) 
[13:23:08.653]                               next
[13:23:08.653]                             if (!grepl(pattern, name)) 
[13:23:08.653]                               next
[13:23:08.653]                             invokeRestart(restart)
[13:23:08.653]                             muffled <- TRUE
[13:23:08.653]                             break
[13:23:08.653]                           }
[13:23:08.653]                         }
[13:23:08.653]                       }
[13:23:08.653]                       invisible(muffled)
[13:23:08.653]                     }
[13:23:08.653]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.653]                   }
[13:23:08.653]                 }
[13:23:08.653]             }
[13:23:08.653]         }))
[13:23:08.653]     }, error = function(ex) {
[13:23:08.653]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.653]                 ...future.rng), started = ...future.startTime, 
[13:23:08.653]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.653]             version = "1.8"), class = "FutureResult")
[13:23:08.653]     }, finally = {
[13:23:08.653]         if (!identical(...future.workdir, getwd())) 
[13:23:08.653]             setwd(...future.workdir)
[13:23:08.653]         {
[13:23:08.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.653]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.653]             }
[13:23:08.653]             base::options(...future.oldOptions)
[13:23:08.653]             if (.Platform$OS.type == "windows") {
[13:23:08.653]                 old_names <- names(...future.oldEnvVars)
[13:23:08.653]                 envs <- base::Sys.getenv()
[13:23:08.653]                 names <- names(envs)
[13:23:08.653]                 common <- intersect(names, old_names)
[13:23:08.653]                 added <- setdiff(names, old_names)
[13:23:08.653]                 removed <- setdiff(old_names, names)
[13:23:08.653]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.653]                   envs[common]]
[13:23:08.653]                 NAMES <- toupper(changed)
[13:23:08.653]                 args <- list()
[13:23:08.653]                 for (kk in seq_along(NAMES)) {
[13:23:08.653]                   name <- changed[[kk]]
[13:23:08.653]                   NAME <- NAMES[[kk]]
[13:23:08.653]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.653]                     next
[13:23:08.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.653]                 }
[13:23:08.653]                 NAMES <- toupper(added)
[13:23:08.653]                 for (kk in seq_along(NAMES)) {
[13:23:08.653]                   name <- added[[kk]]
[13:23:08.653]                   NAME <- NAMES[[kk]]
[13:23:08.653]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.653]                     next
[13:23:08.653]                   args[[name]] <- ""
[13:23:08.653]                 }
[13:23:08.653]                 NAMES <- toupper(removed)
[13:23:08.653]                 for (kk in seq_along(NAMES)) {
[13:23:08.653]                   name <- removed[[kk]]
[13:23:08.653]                   NAME <- NAMES[[kk]]
[13:23:08.653]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.653]                     next
[13:23:08.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.653]                 }
[13:23:08.653]                 if (length(args) > 0) 
[13:23:08.653]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.653]             }
[13:23:08.653]             else {
[13:23:08.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.653]             }
[13:23:08.653]             {
[13:23:08.653]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.653]                   0L) {
[13:23:08.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.653]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.653]                   base::options(opts)
[13:23:08.653]                 }
[13:23:08.653]                 {
[13:23:08.653]                   {
[13:23:08.653]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.653]                     NULL
[13:23:08.653]                   }
[13:23:08.653]                   options(future.plan = NULL)
[13:23:08.653]                   if (is.na(NA_character_)) 
[13:23:08.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.653]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.653]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.653]                     envir = parent.frame()) 
[13:23:08.653]                   {
[13:23:08.653]                     if (is.function(workers)) 
[13:23:08.653]                       workers <- workers()
[13:23:08.653]                     workers <- structure(as.integer(workers), 
[13:23:08.653]                       class = class(workers))
[13:23:08.653]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.653]                       workers >= 1)
[13:23:08.653]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.653]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.653]                     }
[13:23:08.653]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.653]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.653]                       envir = envir)
[13:23:08.653]                     if (!future$lazy) 
[13:23:08.653]                       future <- run(future)
[13:23:08.653]                     invisible(future)
[13:23:08.653]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.653]                 }
[13:23:08.653]             }
[13:23:08.653]         }
[13:23:08.653]     })
[13:23:08.653]     if (TRUE) {
[13:23:08.653]         base::sink(type = "output", split = FALSE)
[13:23:08.653]         if (TRUE) {
[13:23:08.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.653]         }
[13:23:08.653]         else {
[13:23:08.653]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.653]         }
[13:23:08.653]         base::close(...future.stdout)
[13:23:08.653]         ...future.stdout <- NULL
[13:23:08.653]     }
[13:23:08.653]     ...future.result$conditions <- ...future.conditions
[13:23:08.653]     ...future.result$finished <- base::Sys.time()
[13:23:08.653]     ...future.result
[13:23:08.653] }
[13:23:08.655] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:08.666] receiveMessageFromWorker() for ClusterFuture ...
[13:23:08.667] - Validating connection of MultisessionFuture
[13:23:08.667] - received message: FutureResult
[13:23:08.667] - Received FutureResult
[13:23:08.667] - Erased future from FutureRegistry
[13:23:08.667] result() for ClusterFuture ...
[13:23:08.667] - result already collected: FutureResult
[13:23:08.667] result() for ClusterFuture ... done
[13:23:08.667] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:08.668] result() for ClusterFuture ...
[13:23:08.668] - result already collected: FutureResult
[13:23:08.668] result() for ClusterFuture ... done
[13:23:08.668] result() for ClusterFuture ...
[13:23:08.668] - result already collected: FutureResult
[13:23:08.668] result() for ClusterFuture ... done
[13:23:08.670] MultisessionFuture started
[13:23:08.670] - Launch lazy future ... done
[13:23:08.670] run() for ‘MultisessionFuture’ ... done
<environment: 0x5596d55a2360> 
<environment: 0x5596d69cf420> 
[13:23:08.680] receiveMessageFromWorker() for ClusterFuture ...
[13:23:08.680] - Validating connection of MultisessionFuture
[13:23:08.680] - received message: FutureResult
[13:23:08.680] - Received FutureResult
[13:23:08.680] - Erased future from FutureRegistry
[13:23:08.680] result() for ClusterFuture ...
[13:23:08.681] - result already collected: FutureResult
[13:23:08.681] result() for ClusterFuture ... done
[13:23:08.681] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:08.693] resolve() on environment ...
[13:23:08.693]  recursive: 0
[13:23:08.694]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:08.694] signalConditionsASAP(numeric, pos=1) ...
[13:23:08.694] - nx: 4
[13:23:08.694] - relay: TRUE
[13:23:08.694] - stdout: TRUE
[13:23:08.694] - signal: TRUE
[13:23:08.694] - resignal: FALSE
[13:23:08.694] - force: TRUE
[13:23:08.694] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.694] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.694]  - until=2
[13:23:08.695]  - relaying element #2
[13:23:08.695] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:08.695] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.695] signalConditionsASAP(NULL, pos=1) ... done
[13:23:08.695]  length: 3 (resolved future 1)
[13:23:08.695] Future #2
[13:23:08.695] result() for ClusterFuture ...
[13:23:08.695] - result already collected: FutureResult
[13:23:08.695] result() for ClusterFuture ... done
[13:23:08.695] result() for ClusterFuture ...
[13:23:08.696] - result already collected: FutureResult
[13:23:08.696] result() for ClusterFuture ... done
[13:23:08.696] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:08.696] - nx: 4
[13:23:08.696] - relay: TRUE
[13:23:08.696] - stdout: TRUE
[13:23:08.696] - signal: TRUE
[13:23:08.696] - resignal: FALSE
[13:23:08.696] - force: TRUE
[13:23:08.696] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:08.696] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.697]  - until=2
[13:23:08.697]  - relaying element #2
[13:23:08.697] result() for ClusterFuture ...
[13:23:08.697] - result already collected: FutureResult
[13:23:08.697] result() for ClusterFuture ... done
[13:23:08.697] result() for ClusterFuture ...
[13:23:08.697] - result already collected: FutureResult
[13:23:08.697] result() for ClusterFuture ... done
[13:23:08.697] result() for ClusterFuture ...
[13:23:08.697] - result already collected: FutureResult
[13:23:08.697] result() for ClusterFuture ... done
[13:23:08.698] result() for ClusterFuture ...
[13:23:08.698] - result already collected: FutureResult
[13:23:08.698] result() for ClusterFuture ... done
[13:23:08.698] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:08.698] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:08.698] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:08.698]  length: 2 (resolved future 2)
[13:23:08.698] Future #3
[13:23:08.698] result() for ClusterFuture ...
[13:23:08.698] - result already collected: FutureResult
[13:23:08.699] result() for ClusterFuture ... done
[13:23:08.699] result() for ClusterFuture ...
[13:23:08.699] - result already collected: FutureResult
[13:23:08.699] result() for ClusterFuture ... done
[13:23:08.699] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:08.699] - nx: 4
[13:23:08.699] - relay: TRUE
[13:23:08.699] - stdout: TRUE
[13:23:08.699] - signal: TRUE
[13:23:08.699] - resignal: FALSE
[13:23:08.699] - force: TRUE
[13:23:08.699] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:08.700] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:08.700]  - until=3
[13:23:08.700]  - relaying element #3
[13:23:08.700] result() for ClusterFuture ...
[13:23:08.700] - result already collected: FutureResult
[13:23:08.700] result() for ClusterFuture ... done
[13:23:08.700] result() for ClusterFuture ...
[13:23:08.700] - result already collected: FutureResult
[13:23:08.700] result() for ClusterFuture ... done
[13:23:08.700] result() for ClusterFuture ...
[13:23:08.701] - result already collected: FutureResult
[13:23:08.701] result() for ClusterFuture ... done
[13:23:08.701] result() for ClusterFuture ...
[13:23:08.701] - result already collected: FutureResult
[13:23:08.701] result() for ClusterFuture ... done
[13:23:08.701] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:08.701] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:08.701] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:08.701]  length: 1 (resolved future 3)
[13:23:08.723] receiveMessageFromWorker() for ClusterFuture ...
[13:23:08.723] - Validating connection of MultisessionFuture
[13:23:08.723] - received message: FutureResult
[13:23:08.723] - Received FutureResult
[13:23:08.723] - Erased future from FutureRegistry
[13:23:08.724] result() for ClusterFuture ...
[13:23:08.724] - result already collected: FutureResult
[13:23:08.724] result() for ClusterFuture ... done
[13:23:08.724] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:08.724] Future #4
[13:23:08.724] result() for ClusterFuture ...
[13:23:08.724] - result already collected: FutureResult
[13:23:08.724] result() for ClusterFuture ... done
[13:23:08.724] result() for ClusterFuture ...
[13:23:08.724] - result already collected: FutureResult
[13:23:08.725] result() for ClusterFuture ... done
[13:23:08.725] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:08.725] - nx: 4
[13:23:08.725] - relay: TRUE
[13:23:08.725] - stdout: TRUE
[13:23:08.725] - signal: TRUE
[13:23:08.725] - resignal: FALSE
[13:23:08.725] - force: TRUE
[13:23:08.725] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:08.725] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:08.725]  - until=4
[13:23:08.726]  - relaying element #4
[13:23:08.726] result() for ClusterFuture ...
[13:23:08.726] - result already collected: FutureResult
[13:23:08.726] result() for ClusterFuture ... done
[13:23:08.726] result() for ClusterFuture ...
[13:23:08.726] - result already collected: FutureResult
[13:23:08.726] result() for ClusterFuture ... done
[13:23:08.726] result() for ClusterFuture ...
[13:23:08.726] - result already collected: FutureResult
[13:23:08.726] result() for ClusterFuture ... done
[13:23:08.726] result() for ClusterFuture ...
[13:23:08.727] - result already collected: FutureResult
[13:23:08.727] result() for ClusterFuture ... done
[13:23:08.727] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:08.727] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:08.727] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:08.727]  length: 0 (resolved future 4)
[13:23:08.727] Relaying remaining futures
[13:23:08.727] signalConditionsASAP(NULL, pos=0) ...
[13:23:08.727] - nx: 4
[13:23:08.727] - relay: TRUE
[13:23:08.727] - stdout: TRUE
[13:23:08.728] - signal: TRUE
[13:23:08.728] - resignal: FALSE
[13:23:08.728] - force: TRUE
[13:23:08.728] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:08.728] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:08.728] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:08.728] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:08.728] signalConditionsASAP(NULL, pos=0) ... done
[13:23:08.728] resolve() on environment ... DONE
[13:23:08.729] result() for ClusterFuture ...
[13:23:08.729] - result already collected: FutureResult
[13:23:08.729] result() for ClusterFuture ... done
[13:23:08.729] result() for ClusterFuture ...
[13:23:08.729] - result already collected: FutureResult
[13:23:08.729] result() for ClusterFuture ... done
[13:23:08.729] result() for ClusterFuture ...
[13:23:08.729] - result already collected: FutureResult
[13:23:08.729] result() for ClusterFuture ... done
[13:23:08.729] result() for ClusterFuture ...
[13:23:08.729] - result already collected: FutureResult
[13:23:08.730] result() for ClusterFuture ... done
[13:23:08.730] result() for ClusterFuture ...
[13:23:08.730] - result already collected: FutureResult
[13:23:08.730] result() for ClusterFuture ... done
[13:23:08.730] result() for ClusterFuture ...
[13:23:08.730] - result already collected: FutureResult
[13:23:08.730] result() for ClusterFuture ... done
<environment: 0x5596d6bbdb48> 
Dimensions: c(1, 6)
[13:23:08.731] getGlobalsAndPackages() ...
[13:23:08.731] Searching for globals...
[13:23:08.731] 
[13:23:08.731] Searching for globals ... DONE
[13:23:08.731] - globals: [0] <none>
[13:23:08.731] getGlobalsAndPackages() ... DONE
[13:23:08.732] run() for ‘Future’ ...
[13:23:08.732] - state: ‘created’
[13:23:08.732] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.746] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:08.747]   - Field: ‘node’
[13:23:08.747]   - Field: ‘label’
[13:23:08.747]   - Field: ‘local’
[13:23:08.747]   - Field: ‘owner’
[13:23:08.747]   - Field: ‘envir’
[13:23:08.747]   - Field: ‘workers’
[13:23:08.747]   - Field: ‘packages’
[13:23:08.748]   - Field: ‘gc’
[13:23:08.748]   - Field: ‘conditions’
[13:23:08.748]   - Field: ‘persistent’
[13:23:08.748]   - Field: ‘expr’
[13:23:08.748]   - Field: ‘uuid’
[13:23:08.748]   - Field: ‘seed’
[13:23:08.748]   - Field: ‘version’
[13:23:08.748]   - Field: ‘result’
[13:23:08.748]   - Field: ‘asynchronous’
[13:23:08.748]   - Field: ‘calls’
[13:23:08.749]   - Field: ‘globals’
[13:23:08.749]   - Field: ‘stdout’
[13:23:08.749]   - Field: ‘earlySignal’
[13:23:08.749]   - Field: ‘lazy’
[13:23:08.749]   - Field: ‘state’
[13:23:08.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:08.749] - Launch lazy future ...
[13:23:08.749] Packages needed by the future expression (n = 0): <none>
[13:23:08.750] Packages needed by future strategies (n = 0): <none>
[13:23:08.750] {
[13:23:08.750]     {
[13:23:08.750]         {
[13:23:08.750]             ...future.startTime <- base::Sys.time()
[13:23:08.750]             {
[13:23:08.750]                 {
[13:23:08.750]                   {
[13:23:08.750]                     {
[13:23:08.750]                       base::local({
[13:23:08.750]                         has_future <- base::requireNamespace("future", 
[13:23:08.750]                           quietly = TRUE)
[13:23:08.750]                         if (has_future) {
[13:23:08.750]                           ns <- base::getNamespace("future")
[13:23:08.750]                           version <- ns[[".package"]][["version"]]
[13:23:08.750]                           if (is.null(version)) 
[13:23:08.750]                             version <- utils::packageVersion("future")
[13:23:08.750]                         }
[13:23:08.750]                         else {
[13:23:08.750]                           version <- NULL
[13:23:08.750]                         }
[13:23:08.750]                         if (!has_future || version < "1.8.0") {
[13:23:08.750]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.750]                             "", base::R.version$version.string), 
[13:23:08.750]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.750]                               "release", "version")], collapse = " "), 
[13:23:08.750]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.750]                             info)
[13:23:08.750]                           info <- base::paste(info, collapse = "; ")
[13:23:08.750]                           if (!has_future) {
[13:23:08.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.750]                               info)
[13:23:08.750]                           }
[13:23:08.750]                           else {
[13:23:08.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.750]                               info, version)
[13:23:08.750]                           }
[13:23:08.750]                           base::stop(msg)
[13:23:08.750]                         }
[13:23:08.750]                       })
[13:23:08.750]                     }
[13:23:08.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.750]                     base::options(mc.cores = 1L)
[13:23:08.750]                   }
[13:23:08.750]                   options(future.plan = NULL)
[13:23:08.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.750]                 }
[13:23:08.750]                 ...future.workdir <- getwd()
[13:23:08.750]             }
[13:23:08.750]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.750]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.750]         }
[13:23:08.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.750]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.750]             base::names(...future.oldOptions))
[13:23:08.750]     }
[13:23:08.750]     if (FALSE) {
[13:23:08.750]     }
[13:23:08.750]     else {
[13:23:08.750]         if (TRUE) {
[13:23:08.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.750]                 open = "w")
[13:23:08.750]         }
[13:23:08.750]         else {
[13:23:08.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.750]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.750]         }
[13:23:08.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.750]             base::sink(type = "output", split = FALSE)
[13:23:08.750]             base::close(...future.stdout)
[13:23:08.750]         }, add = TRUE)
[13:23:08.750]     }
[13:23:08.750]     ...future.frame <- base::sys.nframe()
[13:23:08.750]     ...future.conditions <- base::list()
[13:23:08.750]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.750]     if (FALSE) {
[13:23:08.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.750]     }
[13:23:08.750]     ...future.result <- base::tryCatch({
[13:23:08.750]         base::withCallingHandlers({
[13:23:08.750]             ...future.value <- base::withVisible(base::local({
[13:23:08.750]                 ...future.makeSendCondition <- base::local({
[13:23:08.750]                   sendCondition <- NULL
[13:23:08.750]                   function(frame = 1L) {
[13:23:08.750]                     if (is.function(sendCondition)) 
[13:23:08.750]                       return(sendCondition)
[13:23:08.750]                     ns <- getNamespace("parallel")
[13:23:08.750]                     if (exists("sendData", mode = "function", 
[13:23:08.750]                       envir = ns)) {
[13:23:08.750]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.750]                         envir = ns)
[13:23:08.750]                       envir <- sys.frame(frame)
[13:23:08.750]                       master <- NULL
[13:23:08.750]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.750]                         !identical(envir, emptyenv())) {
[13:23:08.750]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.750]                           inherits = FALSE)) {
[13:23:08.750]                           master <- get("master", mode = "list", 
[13:23:08.750]                             envir = envir, inherits = FALSE)
[13:23:08.750]                           if (inherits(master, c("SOCKnode", 
[13:23:08.750]                             "SOCK0node"))) {
[13:23:08.750]                             sendCondition <<- function(cond) {
[13:23:08.750]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.750]                                 success = TRUE)
[13:23:08.750]                               parallel_sendData(master, data)
[13:23:08.750]                             }
[13:23:08.750]                             return(sendCondition)
[13:23:08.750]                           }
[13:23:08.750]                         }
[13:23:08.750]                         frame <- frame + 1L
[13:23:08.750]                         envir <- sys.frame(frame)
[13:23:08.750]                       }
[13:23:08.750]                     }
[13:23:08.750]                     sendCondition <<- function(cond) NULL
[13:23:08.750]                   }
[13:23:08.750]                 })
[13:23:08.750]                 withCallingHandlers({
[13:23:08.750]                   2
[13:23:08.750]                 }, immediateCondition = function(cond) {
[13:23:08.750]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.750]                   sendCondition(cond)
[13:23:08.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.750]                   {
[13:23:08.750]                     inherits <- base::inherits
[13:23:08.750]                     invokeRestart <- base::invokeRestart
[13:23:08.750]                     is.null <- base::is.null
[13:23:08.750]                     muffled <- FALSE
[13:23:08.750]                     if (inherits(cond, "message")) {
[13:23:08.750]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.750]                       if (muffled) 
[13:23:08.750]                         invokeRestart("muffleMessage")
[13:23:08.750]                     }
[13:23:08.750]                     else if (inherits(cond, "warning")) {
[13:23:08.750]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.750]                       if (muffled) 
[13:23:08.750]                         invokeRestart("muffleWarning")
[13:23:08.750]                     }
[13:23:08.750]                     else if (inherits(cond, "condition")) {
[13:23:08.750]                       if (!is.null(pattern)) {
[13:23:08.750]                         computeRestarts <- base::computeRestarts
[13:23:08.750]                         grepl <- base::grepl
[13:23:08.750]                         restarts <- computeRestarts(cond)
[13:23:08.750]                         for (restart in restarts) {
[13:23:08.750]                           name <- restart$name
[13:23:08.750]                           if (is.null(name)) 
[13:23:08.750]                             next
[13:23:08.750]                           if (!grepl(pattern, name)) 
[13:23:08.750]                             next
[13:23:08.750]                           invokeRestart(restart)
[13:23:08.750]                           muffled <- TRUE
[13:23:08.750]                           break
[13:23:08.750]                         }
[13:23:08.750]                       }
[13:23:08.750]                     }
[13:23:08.750]                     invisible(muffled)
[13:23:08.750]                   }
[13:23:08.750]                   muffleCondition(cond)
[13:23:08.750]                 })
[13:23:08.750]             }))
[13:23:08.750]             future::FutureResult(value = ...future.value$value, 
[13:23:08.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.750]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.750]                     ...future.globalenv.names))
[13:23:08.750]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.750]         }, condition = base::local({
[13:23:08.750]             c <- base::c
[13:23:08.750]             inherits <- base::inherits
[13:23:08.750]             invokeRestart <- base::invokeRestart
[13:23:08.750]             length <- base::length
[13:23:08.750]             list <- base::list
[13:23:08.750]             seq.int <- base::seq.int
[13:23:08.750]             signalCondition <- base::signalCondition
[13:23:08.750]             sys.calls <- base::sys.calls
[13:23:08.750]             `[[` <- base::`[[`
[13:23:08.750]             `+` <- base::`+`
[13:23:08.750]             `<<-` <- base::`<<-`
[13:23:08.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.750]                   3L)]
[13:23:08.750]             }
[13:23:08.750]             function(cond) {
[13:23:08.750]                 is_error <- inherits(cond, "error")
[13:23:08.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.750]                   NULL)
[13:23:08.750]                 if (is_error) {
[13:23:08.750]                   sessionInformation <- function() {
[13:23:08.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.750]                       search = base::search(), system = base::Sys.info())
[13:23:08.750]                   }
[13:23:08.750]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.750]                     cond$call), session = sessionInformation(), 
[13:23:08.750]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.750]                   signalCondition(cond)
[13:23:08.750]                 }
[13:23:08.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.750]                 "immediateCondition"))) {
[13:23:08.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.750]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.750]                   if (TRUE && !signal) {
[13:23:08.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.750]                     {
[13:23:08.750]                       inherits <- base::inherits
[13:23:08.750]                       invokeRestart <- base::invokeRestart
[13:23:08.750]                       is.null <- base::is.null
[13:23:08.750]                       muffled <- FALSE
[13:23:08.750]                       if (inherits(cond, "message")) {
[13:23:08.750]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.750]                         if (muffled) 
[13:23:08.750]                           invokeRestart("muffleMessage")
[13:23:08.750]                       }
[13:23:08.750]                       else if (inherits(cond, "warning")) {
[13:23:08.750]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.750]                         if (muffled) 
[13:23:08.750]                           invokeRestart("muffleWarning")
[13:23:08.750]                       }
[13:23:08.750]                       else if (inherits(cond, "condition")) {
[13:23:08.750]                         if (!is.null(pattern)) {
[13:23:08.750]                           computeRestarts <- base::computeRestarts
[13:23:08.750]                           grepl <- base::grepl
[13:23:08.750]                           restarts <- computeRestarts(cond)
[13:23:08.750]                           for (restart in restarts) {
[13:23:08.750]                             name <- restart$name
[13:23:08.750]                             if (is.null(name)) 
[13:23:08.750]                               next
[13:23:08.750]                             if (!grepl(pattern, name)) 
[13:23:08.750]                               next
[13:23:08.750]                             invokeRestart(restart)
[13:23:08.750]                             muffled <- TRUE
[13:23:08.750]                             break
[13:23:08.750]                           }
[13:23:08.750]                         }
[13:23:08.750]                       }
[13:23:08.750]                       invisible(muffled)
[13:23:08.750]                     }
[13:23:08.750]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.750]                   }
[13:23:08.750]                 }
[13:23:08.750]                 else {
[13:23:08.750]                   if (TRUE) {
[13:23:08.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.750]                     {
[13:23:08.750]                       inherits <- base::inherits
[13:23:08.750]                       invokeRestart <- base::invokeRestart
[13:23:08.750]                       is.null <- base::is.null
[13:23:08.750]                       muffled <- FALSE
[13:23:08.750]                       if (inherits(cond, "message")) {
[13:23:08.750]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.750]                         if (muffled) 
[13:23:08.750]                           invokeRestart("muffleMessage")
[13:23:08.750]                       }
[13:23:08.750]                       else if (inherits(cond, "warning")) {
[13:23:08.750]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.750]                         if (muffled) 
[13:23:08.750]                           invokeRestart("muffleWarning")
[13:23:08.750]                       }
[13:23:08.750]                       else if (inherits(cond, "condition")) {
[13:23:08.750]                         if (!is.null(pattern)) {
[13:23:08.750]                           computeRestarts <- base::computeRestarts
[13:23:08.750]                           grepl <- base::grepl
[13:23:08.750]                           restarts <- computeRestarts(cond)
[13:23:08.750]                           for (restart in restarts) {
[13:23:08.750]                             name <- restart$name
[13:23:08.750]                             if (is.null(name)) 
[13:23:08.750]                               next
[13:23:08.750]                             if (!grepl(pattern, name)) 
[13:23:08.750]                               next
[13:23:08.750]                             invokeRestart(restart)
[13:23:08.750]                             muffled <- TRUE
[13:23:08.750]                             break
[13:23:08.750]                           }
[13:23:08.750]                         }
[13:23:08.750]                       }
[13:23:08.750]                       invisible(muffled)
[13:23:08.750]                     }
[13:23:08.750]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.750]                   }
[13:23:08.750]                 }
[13:23:08.750]             }
[13:23:08.750]         }))
[13:23:08.750]     }, error = function(ex) {
[13:23:08.750]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.750]                 ...future.rng), started = ...future.startTime, 
[13:23:08.750]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.750]             version = "1.8"), class = "FutureResult")
[13:23:08.750]     }, finally = {
[13:23:08.750]         if (!identical(...future.workdir, getwd())) 
[13:23:08.750]             setwd(...future.workdir)
[13:23:08.750]         {
[13:23:08.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.750]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.750]             }
[13:23:08.750]             base::options(...future.oldOptions)
[13:23:08.750]             if (.Platform$OS.type == "windows") {
[13:23:08.750]                 old_names <- names(...future.oldEnvVars)
[13:23:08.750]                 envs <- base::Sys.getenv()
[13:23:08.750]                 names <- names(envs)
[13:23:08.750]                 common <- intersect(names, old_names)
[13:23:08.750]                 added <- setdiff(names, old_names)
[13:23:08.750]                 removed <- setdiff(old_names, names)
[13:23:08.750]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.750]                   envs[common]]
[13:23:08.750]                 NAMES <- toupper(changed)
[13:23:08.750]                 args <- list()
[13:23:08.750]                 for (kk in seq_along(NAMES)) {
[13:23:08.750]                   name <- changed[[kk]]
[13:23:08.750]                   NAME <- NAMES[[kk]]
[13:23:08.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.750]                     next
[13:23:08.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.750]                 }
[13:23:08.750]                 NAMES <- toupper(added)
[13:23:08.750]                 for (kk in seq_along(NAMES)) {
[13:23:08.750]                   name <- added[[kk]]
[13:23:08.750]                   NAME <- NAMES[[kk]]
[13:23:08.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.750]                     next
[13:23:08.750]                   args[[name]] <- ""
[13:23:08.750]                 }
[13:23:08.750]                 NAMES <- toupper(removed)
[13:23:08.750]                 for (kk in seq_along(NAMES)) {
[13:23:08.750]                   name <- removed[[kk]]
[13:23:08.750]                   NAME <- NAMES[[kk]]
[13:23:08.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.750]                     next
[13:23:08.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.750]                 }
[13:23:08.750]                 if (length(args) > 0) 
[13:23:08.750]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.750]             }
[13:23:08.750]             else {
[13:23:08.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.750]             }
[13:23:08.750]             {
[13:23:08.750]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.750]                   0L) {
[13:23:08.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.750]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.750]                   base::options(opts)
[13:23:08.750]                 }
[13:23:08.750]                 {
[13:23:08.750]                   {
[13:23:08.750]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.750]                     NULL
[13:23:08.750]                   }
[13:23:08.750]                   options(future.plan = NULL)
[13:23:08.750]                   if (is.na(NA_character_)) 
[13:23:08.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.750]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.750]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.750]                     envir = parent.frame()) 
[13:23:08.750]                   {
[13:23:08.750]                     if (is.function(workers)) 
[13:23:08.750]                       workers <- workers()
[13:23:08.750]                     workers <- structure(as.integer(workers), 
[13:23:08.750]                       class = class(workers))
[13:23:08.750]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.750]                       workers >= 1)
[13:23:08.750]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.750]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.750]                     }
[13:23:08.750]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.750]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.750]                       envir = envir)
[13:23:08.750]                     if (!future$lazy) 
[13:23:08.750]                       future <- run(future)
[13:23:08.750]                     invisible(future)
[13:23:08.750]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.750]                 }
[13:23:08.750]             }
[13:23:08.750]         }
[13:23:08.750]     })
[13:23:08.750]     if (TRUE) {
[13:23:08.750]         base::sink(type = "output", split = FALSE)
[13:23:08.750]         if (TRUE) {
[13:23:08.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.750]         }
[13:23:08.750]         else {
[13:23:08.750]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.750]         }
[13:23:08.750]         base::close(...future.stdout)
[13:23:08.750]         ...future.stdout <- NULL
[13:23:08.750]     }
[13:23:08.750]     ...future.result$conditions <- ...future.conditions
[13:23:08.750]     ...future.result$finished <- base::Sys.time()
[13:23:08.750]     ...future.result
[13:23:08.750] }
[13:23:08.756] MultisessionFuture started
[13:23:08.757] - Launch lazy future ... done
[13:23:08.757] run() for ‘MultisessionFuture’ ... done
[13:23:08.757] getGlobalsAndPackages() ...
[13:23:08.757] Searching for globals...
[13:23:08.757] 
[13:23:08.757] Searching for globals ... DONE
[13:23:08.758] - globals: [0] <none>
[13:23:08.758] getGlobalsAndPackages() ... DONE
[13:23:08.758] run() for ‘Future’ ...
[13:23:08.758] - state: ‘created’
[13:23:08.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.773] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:08.773]   - Field: ‘node’
[13:23:08.773]   - Field: ‘label’
[13:23:08.774]   - Field: ‘local’
[13:23:08.774]   - Field: ‘owner’
[13:23:08.774]   - Field: ‘envir’
[13:23:08.774]   - Field: ‘workers’
[13:23:08.774]   - Field: ‘packages’
[13:23:08.774]   - Field: ‘gc’
[13:23:08.774]   - Field: ‘conditions’
[13:23:08.774]   - Field: ‘persistent’
[13:23:08.774]   - Field: ‘expr’
[13:23:08.774]   - Field: ‘uuid’
[13:23:08.775]   - Field: ‘seed’
[13:23:08.775]   - Field: ‘version’
[13:23:08.775]   - Field: ‘result’
[13:23:08.775]   - Field: ‘asynchronous’
[13:23:08.775]   - Field: ‘calls’
[13:23:08.775]   - Field: ‘globals’
[13:23:08.775]   - Field: ‘stdout’
[13:23:08.775]   - Field: ‘earlySignal’
[13:23:08.775]   - Field: ‘lazy’
[13:23:08.775]   - Field: ‘state’
[13:23:08.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:08.776] - Launch lazy future ...
[13:23:08.776] Packages needed by the future expression (n = 0): <none>
[13:23:08.776] Packages needed by future strategies (n = 0): <none>
[13:23:08.777] {
[13:23:08.777]     {
[13:23:08.777]         {
[13:23:08.777]             ...future.startTime <- base::Sys.time()
[13:23:08.777]             {
[13:23:08.777]                 {
[13:23:08.777]                   {
[13:23:08.777]                     {
[13:23:08.777]                       base::local({
[13:23:08.777]                         has_future <- base::requireNamespace("future", 
[13:23:08.777]                           quietly = TRUE)
[13:23:08.777]                         if (has_future) {
[13:23:08.777]                           ns <- base::getNamespace("future")
[13:23:08.777]                           version <- ns[[".package"]][["version"]]
[13:23:08.777]                           if (is.null(version)) 
[13:23:08.777]                             version <- utils::packageVersion("future")
[13:23:08.777]                         }
[13:23:08.777]                         else {
[13:23:08.777]                           version <- NULL
[13:23:08.777]                         }
[13:23:08.777]                         if (!has_future || version < "1.8.0") {
[13:23:08.777]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.777]                             "", base::R.version$version.string), 
[13:23:08.777]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.777]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.777]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.777]                               "release", "version")], collapse = " "), 
[13:23:08.777]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.777]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.777]                             info)
[13:23:08.777]                           info <- base::paste(info, collapse = "; ")
[13:23:08.777]                           if (!has_future) {
[13:23:08.777]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.777]                               info)
[13:23:08.777]                           }
[13:23:08.777]                           else {
[13:23:08.777]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.777]                               info, version)
[13:23:08.777]                           }
[13:23:08.777]                           base::stop(msg)
[13:23:08.777]                         }
[13:23:08.777]                       })
[13:23:08.777]                     }
[13:23:08.777]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.777]                     base::options(mc.cores = 1L)
[13:23:08.777]                   }
[13:23:08.777]                   options(future.plan = NULL)
[13:23:08.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.777]                 }
[13:23:08.777]                 ...future.workdir <- getwd()
[13:23:08.777]             }
[13:23:08.777]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.777]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.777]         }
[13:23:08.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.777]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.777]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.777]             base::names(...future.oldOptions))
[13:23:08.777]     }
[13:23:08.777]     if (FALSE) {
[13:23:08.777]     }
[13:23:08.777]     else {
[13:23:08.777]         if (TRUE) {
[13:23:08.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.777]                 open = "w")
[13:23:08.777]         }
[13:23:08.777]         else {
[13:23:08.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.777]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.777]         }
[13:23:08.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.777]             base::sink(type = "output", split = FALSE)
[13:23:08.777]             base::close(...future.stdout)
[13:23:08.777]         }, add = TRUE)
[13:23:08.777]     }
[13:23:08.777]     ...future.frame <- base::sys.nframe()
[13:23:08.777]     ...future.conditions <- base::list()
[13:23:08.777]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.777]     if (FALSE) {
[13:23:08.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.777]     }
[13:23:08.777]     ...future.result <- base::tryCatch({
[13:23:08.777]         base::withCallingHandlers({
[13:23:08.777]             ...future.value <- base::withVisible(base::local({
[13:23:08.777]                 ...future.makeSendCondition <- base::local({
[13:23:08.777]                   sendCondition <- NULL
[13:23:08.777]                   function(frame = 1L) {
[13:23:08.777]                     if (is.function(sendCondition)) 
[13:23:08.777]                       return(sendCondition)
[13:23:08.777]                     ns <- getNamespace("parallel")
[13:23:08.777]                     if (exists("sendData", mode = "function", 
[13:23:08.777]                       envir = ns)) {
[13:23:08.777]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.777]                         envir = ns)
[13:23:08.777]                       envir <- sys.frame(frame)
[13:23:08.777]                       master <- NULL
[13:23:08.777]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.777]                         !identical(envir, emptyenv())) {
[13:23:08.777]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.777]                           inherits = FALSE)) {
[13:23:08.777]                           master <- get("master", mode = "list", 
[13:23:08.777]                             envir = envir, inherits = FALSE)
[13:23:08.777]                           if (inherits(master, c("SOCKnode", 
[13:23:08.777]                             "SOCK0node"))) {
[13:23:08.777]                             sendCondition <<- function(cond) {
[13:23:08.777]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.777]                                 success = TRUE)
[13:23:08.777]                               parallel_sendData(master, data)
[13:23:08.777]                             }
[13:23:08.777]                             return(sendCondition)
[13:23:08.777]                           }
[13:23:08.777]                         }
[13:23:08.777]                         frame <- frame + 1L
[13:23:08.777]                         envir <- sys.frame(frame)
[13:23:08.777]                       }
[13:23:08.777]                     }
[13:23:08.777]                     sendCondition <<- function(cond) NULL
[13:23:08.777]                   }
[13:23:08.777]                 })
[13:23:08.777]                 withCallingHandlers({
[13:23:08.777]                   NULL
[13:23:08.777]                 }, immediateCondition = function(cond) {
[13:23:08.777]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.777]                   sendCondition(cond)
[13:23:08.777]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.777]                   {
[13:23:08.777]                     inherits <- base::inherits
[13:23:08.777]                     invokeRestart <- base::invokeRestart
[13:23:08.777]                     is.null <- base::is.null
[13:23:08.777]                     muffled <- FALSE
[13:23:08.777]                     if (inherits(cond, "message")) {
[13:23:08.777]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.777]                       if (muffled) 
[13:23:08.777]                         invokeRestart("muffleMessage")
[13:23:08.777]                     }
[13:23:08.777]                     else if (inherits(cond, "warning")) {
[13:23:08.777]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.777]                       if (muffled) 
[13:23:08.777]                         invokeRestart("muffleWarning")
[13:23:08.777]                     }
[13:23:08.777]                     else if (inherits(cond, "condition")) {
[13:23:08.777]                       if (!is.null(pattern)) {
[13:23:08.777]                         computeRestarts <- base::computeRestarts
[13:23:08.777]                         grepl <- base::grepl
[13:23:08.777]                         restarts <- computeRestarts(cond)
[13:23:08.777]                         for (restart in restarts) {
[13:23:08.777]                           name <- restart$name
[13:23:08.777]                           if (is.null(name)) 
[13:23:08.777]                             next
[13:23:08.777]                           if (!grepl(pattern, name)) 
[13:23:08.777]                             next
[13:23:08.777]                           invokeRestart(restart)
[13:23:08.777]                           muffled <- TRUE
[13:23:08.777]                           break
[13:23:08.777]                         }
[13:23:08.777]                       }
[13:23:08.777]                     }
[13:23:08.777]                     invisible(muffled)
[13:23:08.777]                   }
[13:23:08.777]                   muffleCondition(cond)
[13:23:08.777]                 })
[13:23:08.777]             }))
[13:23:08.777]             future::FutureResult(value = ...future.value$value, 
[13:23:08.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.777]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.777]                     ...future.globalenv.names))
[13:23:08.777]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.777]         }, condition = base::local({
[13:23:08.777]             c <- base::c
[13:23:08.777]             inherits <- base::inherits
[13:23:08.777]             invokeRestart <- base::invokeRestart
[13:23:08.777]             length <- base::length
[13:23:08.777]             list <- base::list
[13:23:08.777]             seq.int <- base::seq.int
[13:23:08.777]             signalCondition <- base::signalCondition
[13:23:08.777]             sys.calls <- base::sys.calls
[13:23:08.777]             `[[` <- base::`[[`
[13:23:08.777]             `+` <- base::`+`
[13:23:08.777]             `<<-` <- base::`<<-`
[13:23:08.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.777]                   3L)]
[13:23:08.777]             }
[13:23:08.777]             function(cond) {
[13:23:08.777]                 is_error <- inherits(cond, "error")
[13:23:08.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.777]                   NULL)
[13:23:08.777]                 if (is_error) {
[13:23:08.777]                   sessionInformation <- function() {
[13:23:08.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.777]                       search = base::search(), system = base::Sys.info())
[13:23:08.777]                   }
[13:23:08.777]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.777]                     cond$call), session = sessionInformation(), 
[13:23:08.777]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.777]                   signalCondition(cond)
[13:23:08.777]                 }
[13:23:08.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.777]                 "immediateCondition"))) {
[13:23:08.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.777]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.777]                   if (TRUE && !signal) {
[13:23:08.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.777]                     {
[13:23:08.777]                       inherits <- base::inherits
[13:23:08.777]                       invokeRestart <- base::invokeRestart
[13:23:08.777]                       is.null <- base::is.null
[13:23:08.777]                       muffled <- FALSE
[13:23:08.777]                       if (inherits(cond, "message")) {
[13:23:08.777]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.777]                         if (muffled) 
[13:23:08.777]                           invokeRestart("muffleMessage")
[13:23:08.777]                       }
[13:23:08.777]                       else if (inherits(cond, "warning")) {
[13:23:08.777]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.777]                         if (muffled) 
[13:23:08.777]                           invokeRestart("muffleWarning")
[13:23:08.777]                       }
[13:23:08.777]                       else if (inherits(cond, "condition")) {
[13:23:08.777]                         if (!is.null(pattern)) {
[13:23:08.777]                           computeRestarts <- base::computeRestarts
[13:23:08.777]                           grepl <- base::grepl
[13:23:08.777]                           restarts <- computeRestarts(cond)
[13:23:08.777]                           for (restart in restarts) {
[13:23:08.777]                             name <- restart$name
[13:23:08.777]                             if (is.null(name)) 
[13:23:08.777]                               next
[13:23:08.777]                             if (!grepl(pattern, name)) 
[13:23:08.777]                               next
[13:23:08.777]                             invokeRestart(restart)
[13:23:08.777]                             muffled <- TRUE
[13:23:08.777]                             break
[13:23:08.777]                           }
[13:23:08.777]                         }
[13:23:08.777]                       }
[13:23:08.777]                       invisible(muffled)
[13:23:08.777]                     }
[13:23:08.777]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.777]                   }
[13:23:08.777]                 }
[13:23:08.777]                 else {
[13:23:08.777]                   if (TRUE) {
[13:23:08.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.777]                     {
[13:23:08.777]                       inherits <- base::inherits
[13:23:08.777]                       invokeRestart <- base::invokeRestart
[13:23:08.777]                       is.null <- base::is.null
[13:23:08.777]                       muffled <- FALSE
[13:23:08.777]                       if (inherits(cond, "message")) {
[13:23:08.777]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.777]                         if (muffled) 
[13:23:08.777]                           invokeRestart("muffleMessage")
[13:23:08.777]                       }
[13:23:08.777]                       else if (inherits(cond, "warning")) {
[13:23:08.777]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.777]                         if (muffled) 
[13:23:08.777]                           invokeRestart("muffleWarning")
[13:23:08.777]                       }
[13:23:08.777]                       else if (inherits(cond, "condition")) {
[13:23:08.777]                         if (!is.null(pattern)) {
[13:23:08.777]                           computeRestarts <- base::computeRestarts
[13:23:08.777]                           grepl <- base::grepl
[13:23:08.777]                           restarts <- computeRestarts(cond)
[13:23:08.777]                           for (restart in restarts) {
[13:23:08.777]                             name <- restart$name
[13:23:08.777]                             if (is.null(name)) 
[13:23:08.777]                               next
[13:23:08.777]                             if (!grepl(pattern, name)) 
[13:23:08.777]                               next
[13:23:08.777]                             invokeRestart(restart)
[13:23:08.777]                             muffled <- TRUE
[13:23:08.777]                             break
[13:23:08.777]                           }
[13:23:08.777]                         }
[13:23:08.777]                       }
[13:23:08.777]                       invisible(muffled)
[13:23:08.777]                     }
[13:23:08.777]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.777]                   }
[13:23:08.777]                 }
[13:23:08.777]             }
[13:23:08.777]         }))
[13:23:08.777]     }, error = function(ex) {
[13:23:08.777]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.777]                 ...future.rng), started = ...future.startTime, 
[13:23:08.777]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.777]             version = "1.8"), class = "FutureResult")
[13:23:08.777]     }, finally = {
[13:23:08.777]         if (!identical(...future.workdir, getwd())) 
[13:23:08.777]             setwd(...future.workdir)
[13:23:08.777]         {
[13:23:08.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.777]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.777]             }
[13:23:08.777]             base::options(...future.oldOptions)
[13:23:08.777]             if (.Platform$OS.type == "windows") {
[13:23:08.777]                 old_names <- names(...future.oldEnvVars)
[13:23:08.777]                 envs <- base::Sys.getenv()
[13:23:08.777]                 names <- names(envs)
[13:23:08.777]                 common <- intersect(names, old_names)
[13:23:08.777]                 added <- setdiff(names, old_names)
[13:23:08.777]                 removed <- setdiff(old_names, names)
[13:23:08.777]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.777]                   envs[common]]
[13:23:08.777]                 NAMES <- toupper(changed)
[13:23:08.777]                 args <- list()
[13:23:08.777]                 for (kk in seq_along(NAMES)) {
[13:23:08.777]                   name <- changed[[kk]]
[13:23:08.777]                   NAME <- NAMES[[kk]]
[13:23:08.777]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.777]                     next
[13:23:08.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.777]                 }
[13:23:08.777]                 NAMES <- toupper(added)
[13:23:08.777]                 for (kk in seq_along(NAMES)) {
[13:23:08.777]                   name <- added[[kk]]
[13:23:08.777]                   NAME <- NAMES[[kk]]
[13:23:08.777]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.777]                     next
[13:23:08.777]                   args[[name]] <- ""
[13:23:08.777]                 }
[13:23:08.777]                 NAMES <- toupper(removed)
[13:23:08.777]                 for (kk in seq_along(NAMES)) {
[13:23:08.777]                   name <- removed[[kk]]
[13:23:08.777]                   NAME <- NAMES[[kk]]
[13:23:08.777]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.777]                     next
[13:23:08.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.777]                 }
[13:23:08.777]                 if (length(args) > 0) 
[13:23:08.777]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.777]             }
[13:23:08.777]             else {
[13:23:08.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.777]             }
[13:23:08.777]             {
[13:23:08.777]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.777]                   0L) {
[13:23:08.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.777]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.777]                   base::options(opts)
[13:23:08.777]                 }
[13:23:08.777]                 {
[13:23:08.777]                   {
[13:23:08.777]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.777]                     NULL
[13:23:08.777]                   }
[13:23:08.777]                   options(future.plan = NULL)
[13:23:08.777]                   if (is.na(NA_character_)) 
[13:23:08.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.777]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.777]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.777]                     envir = parent.frame()) 
[13:23:08.777]                   {
[13:23:08.777]                     if (is.function(workers)) 
[13:23:08.777]                       workers <- workers()
[13:23:08.777]                     workers <- structure(as.integer(workers), 
[13:23:08.777]                       class = class(workers))
[13:23:08.777]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.777]                       workers >= 1)
[13:23:08.777]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.777]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.777]                     }
[13:23:08.777]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.777]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.777]                       envir = envir)
[13:23:08.777]                     if (!future$lazy) 
[13:23:08.777]                       future <- run(future)
[13:23:08.777]                     invisible(future)
[13:23:08.777]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.777]                 }
[13:23:08.777]             }
[13:23:08.777]         }
[13:23:08.777]     })
[13:23:08.777]     if (TRUE) {
[13:23:08.777]         base::sink(type = "output", split = FALSE)
[13:23:08.777]         if (TRUE) {
[13:23:08.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.777]         }
[13:23:08.777]         else {
[13:23:08.777]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.777]         }
[13:23:08.777]         base::close(...future.stdout)
[13:23:08.777]         ...future.stdout <- NULL
[13:23:08.777]     }
[13:23:08.777]     ...future.result$conditions <- ...future.conditions
[13:23:08.777]     ...future.result$finished <- base::Sys.time()
[13:23:08.777]     ...future.result
[13:23:08.777] }
[13:23:08.780] MultisessionFuture started
[13:23:08.780] - Launch lazy future ... done
[13:23:08.780] run() for ‘MultisessionFuture’ ... done
[13:23:08.781] getGlobalsAndPackages() ...
[13:23:08.781] Searching for globals...
[13:23:08.781] - globals found: [1] ‘{’
[13:23:08.781] Searching for globals ... DONE
[13:23:08.782] Resolving globals: FALSE
[13:23:08.782] 
[13:23:08.782] 
[13:23:08.782] getGlobalsAndPackages() ... DONE
[13:23:08.782] run() for ‘Future’ ...
[13:23:08.782] - state: ‘created’
[13:23:08.783] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.797] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.797] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:08.797]   - Field: ‘node’
[13:23:08.797]   - Field: ‘label’
[13:23:08.797]   - Field: ‘local’
[13:23:08.797]   - Field: ‘owner’
[13:23:08.797]   - Field: ‘envir’
[13:23:08.798]   - Field: ‘workers’
[13:23:08.798]   - Field: ‘packages’
[13:23:08.798]   - Field: ‘gc’
[13:23:08.798]   - Field: ‘conditions’
[13:23:08.798]   - Field: ‘persistent’
[13:23:08.798]   - Field: ‘expr’
[13:23:08.798]   - Field: ‘uuid’
[13:23:08.798]   - Field: ‘seed’
[13:23:08.798]   - Field: ‘version’
[13:23:08.798]   - Field: ‘result’
[13:23:08.799]   - Field: ‘asynchronous’
[13:23:08.799]   - Field: ‘calls’
[13:23:08.799]   - Field: ‘globals’
[13:23:08.799]   - Field: ‘stdout’
[13:23:08.799]   - Field: ‘earlySignal’
[13:23:08.799]   - Field: ‘lazy’
[13:23:08.799]   - Field: ‘state’
[13:23:08.799] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:08.799] - Launch lazy future ...
[13:23:08.800] Packages needed by the future expression (n = 0): <none>
[13:23:08.800] Packages needed by future strategies (n = 0): <none>
[13:23:08.800] {
[13:23:08.800]     {
[13:23:08.800]         {
[13:23:08.800]             ...future.startTime <- base::Sys.time()
[13:23:08.800]             {
[13:23:08.800]                 {
[13:23:08.800]                   {
[13:23:08.800]                     {
[13:23:08.800]                       base::local({
[13:23:08.800]                         has_future <- base::requireNamespace("future", 
[13:23:08.800]                           quietly = TRUE)
[13:23:08.800]                         if (has_future) {
[13:23:08.800]                           ns <- base::getNamespace("future")
[13:23:08.800]                           version <- ns[[".package"]][["version"]]
[13:23:08.800]                           if (is.null(version)) 
[13:23:08.800]                             version <- utils::packageVersion("future")
[13:23:08.800]                         }
[13:23:08.800]                         else {
[13:23:08.800]                           version <- NULL
[13:23:08.800]                         }
[13:23:08.800]                         if (!has_future || version < "1.8.0") {
[13:23:08.800]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.800]                             "", base::R.version$version.string), 
[13:23:08.800]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.800]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.800]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.800]                               "release", "version")], collapse = " "), 
[13:23:08.800]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.800]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.800]                             info)
[13:23:08.800]                           info <- base::paste(info, collapse = "; ")
[13:23:08.800]                           if (!has_future) {
[13:23:08.800]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.800]                               info)
[13:23:08.800]                           }
[13:23:08.800]                           else {
[13:23:08.800]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.800]                               info, version)
[13:23:08.800]                           }
[13:23:08.800]                           base::stop(msg)
[13:23:08.800]                         }
[13:23:08.800]                       })
[13:23:08.800]                     }
[13:23:08.800]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.800]                     base::options(mc.cores = 1L)
[13:23:08.800]                   }
[13:23:08.800]                   options(future.plan = NULL)
[13:23:08.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.800]                 }
[13:23:08.800]                 ...future.workdir <- getwd()
[13:23:08.800]             }
[13:23:08.800]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.800]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.800]         }
[13:23:08.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.800]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.800]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.800]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.800]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.800]             base::names(...future.oldOptions))
[13:23:08.800]     }
[13:23:08.800]     if (FALSE) {
[13:23:08.800]     }
[13:23:08.800]     else {
[13:23:08.800]         if (TRUE) {
[13:23:08.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.800]                 open = "w")
[13:23:08.800]         }
[13:23:08.800]         else {
[13:23:08.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.800]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.800]         }
[13:23:08.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.800]             base::sink(type = "output", split = FALSE)
[13:23:08.800]             base::close(...future.stdout)
[13:23:08.800]         }, add = TRUE)
[13:23:08.800]     }
[13:23:08.800]     ...future.frame <- base::sys.nframe()
[13:23:08.800]     ...future.conditions <- base::list()
[13:23:08.800]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.800]     if (FALSE) {
[13:23:08.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.800]     }
[13:23:08.800]     ...future.result <- base::tryCatch({
[13:23:08.800]         base::withCallingHandlers({
[13:23:08.800]             ...future.value <- base::withVisible(base::local({
[13:23:08.800]                 ...future.makeSendCondition <- base::local({
[13:23:08.800]                   sendCondition <- NULL
[13:23:08.800]                   function(frame = 1L) {
[13:23:08.800]                     if (is.function(sendCondition)) 
[13:23:08.800]                       return(sendCondition)
[13:23:08.800]                     ns <- getNamespace("parallel")
[13:23:08.800]                     if (exists("sendData", mode = "function", 
[13:23:08.800]                       envir = ns)) {
[13:23:08.800]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.800]                         envir = ns)
[13:23:08.800]                       envir <- sys.frame(frame)
[13:23:08.800]                       master <- NULL
[13:23:08.800]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.800]                         !identical(envir, emptyenv())) {
[13:23:08.800]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.800]                           inherits = FALSE)) {
[13:23:08.800]                           master <- get("master", mode = "list", 
[13:23:08.800]                             envir = envir, inherits = FALSE)
[13:23:08.800]                           if (inherits(master, c("SOCKnode", 
[13:23:08.800]                             "SOCK0node"))) {
[13:23:08.800]                             sendCondition <<- function(cond) {
[13:23:08.800]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.800]                                 success = TRUE)
[13:23:08.800]                               parallel_sendData(master, data)
[13:23:08.800]                             }
[13:23:08.800]                             return(sendCondition)
[13:23:08.800]                           }
[13:23:08.800]                         }
[13:23:08.800]                         frame <- frame + 1L
[13:23:08.800]                         envir <- sys.frame(frame)
[13:23:08.800]                       }
[13:23:08.800]                     }
[13:23:08.800]                     sendCondition <<- function(cond) NULL
[13:23:08.800]                   }
[13:23:08.800]                 })
[13:23:08.800]                 withCallingHandlers({
[13:23:08.800]                   {
[13:23:08.800]                     4
[13:23:08.800]                   }
[13:23:08.800]                 }, immediateCondition = function(cond) {
[13:23:08.800]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.800]                   sendCondition(cond)
[13:23:08.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.800]                   {
[13:23:08.800]                     inherits <- base::inherits
[13:23:08.800]                     invokeRestart <- base::invokeRestart
[13:23:08.800]                     is.null <- base::is.null
[13:23:08.800]                     muffled <- FALSE
[13:23:08.800]                     if (inherits(cond, "message")) {
[13:23:08.800]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.800]                       if (muffled) 
[13:23:08.800]                         invokeRestart("muffleMessage")
[13:23:08.800]                     }
[13:23:08.800]                     else if (inherits(cond, "warning")) {
[13:23:08.800]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.800]                       if (muffled) 
[13:23:08.800]                         invokeRestart("muffleWarning")
[13:23:08.800]                     }
[13:23:08.800]                     else if (inherits(cond, "condition")) {
[13:23:08.800]                       if (!is.null(pattern)) {
[13:23:08.800]                         computeRestarts <- base::computeRestarts
[13:23:08.800]                         grepl <- base::grepl
[13:23:08.800]                         restarts <- computeRestarts(cond)
[13:23:08.800]                         for (restart in restarts) {
[13:23:08.800]                           name <- restart$name
[13:23:08.800]                           if (is.null(name)) 
[13:23:08.800]                             next
[13:23:08.800]                           if (!grepl(pattern, name)) 
[13:23:08.800]                             next
[13:23:08.800]                           invokeRestart(restart)
[13:23:08.800]                           muffled <- TRUE
[13:23:08.800]                           break
[13:23:08.800]                         }
[13:23:08.800]                       }
[13:23:08.800]                     }
[13:23:08.800]                     invisible(muffled)
[13:23:08.800]                   }
[13:23:08.800]                   muffleCondition(cond)
[13:23:08.800]                 })
[13:23:08.800]             }))
[13:23:08.800]             future::FutureResult(value = ...future.value$value, 
[13:23:08.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.800]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.800]                     ...future.globalenv.names))
[13:23:08.800]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.800]         }, condition = base::local({
[13:23:08.800]             c <- base::c
[13:23:08.800]             inherits <- base::inherits
[13:23:08.800]             invokeRestart <- base::invokeRestart
[13:23:08.800]             length <- base::length
[13:23:08.800]             list <- base::list
[13:23:08.800]             seq.int <- base::seq.int
[13:23:08.800]             signalCondition <- base::signalCondition
[13:23:08.800]             sys.calls <- base::sys.calls
[13:23:08.800]             `[[` <- base::`[[`
[13:23:08.800]             `+` <- base::`+`
[13:23:08.800]             `<<-` <- base::`<<-`
[13:23:08.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.800]                   3L)]
[13:23:08.800]             }
[13:23:08.800]             function(cond) {
[13:23:08.800]                 is_error <- inherits(cond, "error")
[13:23:08.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.800]                   NULL)
[13:23:08.800]                 if (is_error) {
[13:23:08.800]                   sessionInformation <- function() {
[13:23:08.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.800]                       search = base::search(), system = base::Sys.info())
[13:23:08.800]                   }
[13:23:08.800]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.800]                     cond$call), session = sessionInformation(), 
[13:23:08.800]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.800]                   signalCondition(cond)
[13:23:08.800]                 }
[13:23:08.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.800]                 "immediateCondition"))) {
[13:23:08.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.800]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.800]                   if (TRUE && !signal) {
[13:23:08.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.800]                     {
[13:23:08.800]                       inherits <- base::inherits
[13:23:08.800]                       invokeRestart <- base::invokeRestart
[13:23:08.800]                       is.null <- base::is.null
[13:23:08.800]                       muffled <- FALSE
[13:23:08.800]                       if (inherits(cond, "message")) {
[13:23:08.800]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.800]                         if (muffled) 
[13:23:08.800]                           invokeRestart("muffleMessage")
[13:23:08.800]                       }
[13:23:08.800]                       else if (inherits(cond, "warning")) {
[13:23:08.800]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.800]                         if (muffled) 
[13:23:08.800]                           invokeRestart("muffleWarning")
[13:23:08.800]                       }
[13:23:08.800]                       else if (inherits(cond, "condition")) {
[13:23:08.800]                         if (!is.null(pattern)) {
[13:23:08.800]                           computeRestarts <- base::computeRestarts
[13:23:08.800]                           grepl <- base::grepl
[13:23:08.800]                           restarts <- computeRestarts(cond)
[13:23:08.800]                           for (restart in restarts) {
[13:23:08.800]                             name <- restart$name
[13:23:08.800]                             if (is.null(name)) 
[13:23:08.800]                               next
[13:23:08.800]                             if (!grepl(pattern, name)) 
[13:23:08.800]                               next
[13:23:08.800]                             invokeRestart(restart)
[13:23:08.800]                             muffled <- TRUE
[13:23:08.800]                             break
[13:23:08.800]                           }
[13:23:08.800]                         }
[13:23:08.800]                       }
[13:23:08.800]                       invisible(muffled)
[13:23:08.800]                     }
[13:23:08.800]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.800]                   }
[13:23:08.800]                 }
[13:23:08.800]                 else {
[13:23:08.800]                   if (TRUE) {
[13:23:08.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.800]                     {
[13:23:08.800]                       inherits <- base::inherits
[13:23:08.800]                       invokeRestart <- base::invokeRestart
[13:23:08.800]                       is.null <- base::is.null
[13:23:08.800]                       muffled <- FALSE
[13:23:08.800]                       if (inherits(cond, "message")) {
[13:23:08.800]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.800]                         if (muffled) 
[13:23:08.800]                           invokeRestart("muffleMessage")
[13:23:08.800]                       }
[13:23:08.800]                       else if (inherits(cond, "warning")) {
[13:23:08.800]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.800]                         if (muffled) 
[13:23:08.800]                           invokeRestart("muffleWarning")
[13:23:08.800]                       }
[13:23:08.800]                       else if (inherits(cond, "condition")) {
[13:23:08.800]                         if (!is.null(pattern)) {
[13:23:08.800]                           computeRestarts <- base::computeRestarts
[13:23:08.800]                           grepl <- base::grepl
[13:23:08.800]                           restarts <- computeRestarts(cond)
[13:23:08.800]                           for (restart in restarts) {
[13:23:08.800]                             name <- restart$name
[13:23:08.800]                             if (is.null(name)) 
[13:23:08.800]                               next
[13:23:08.800]                             if (!grepl(pattern, name)) 
[13:23:08.800]                               next
[13:23:08.800]                             invokeRestart(restart)
[13:23:08.800]                             muffled <- TRUE
[13:23:08.800]                             break
[13:23:08.800]                           }
[13:23:08.800]                         }
[13:23:08.800]                       }
[13:23:08.800]                       invisible(muffled)
[13:23:08.800]                     }
[13:23:08.800]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.800]                   }
[13:23:08.800]                 }
[13:23:08.800]             }
[13:23:08.800]         }))
[13:23:08.800]     }, error = function(ex) {
[13:23:08.800]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.800]                 ...future.rng), started = ...future.startTime, 
[13:23:08.800]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.800]             version = "1.8"), class = "FutureResult")
[13:23:08.800]     }, finally = {
[13:23:08.800]         if (!identical(...future.workdir, getwd())) 
[13:23:08.800]             setwd(...future.workdir)
[13:23:08.800]         {
[13:23:08.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.800]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.800]             }
[13:23:08.800]             base::options(...future.oldOptions)
[13:23:08.800]             if (.Platform$OS.type == "windows") {
[13:23:08.800]                 old_names <- names(...future.oldEnvVars)
[13:23:08.800]                 envs <- base::Sys.getenv()
[13:23:08.800]                 names <- names(envs)
[13:23:08.800]                 common <- intersect(names, old_names)
[13:23:08.800]                 added <- setdiff(names, old_names)
[13:23:08.800]                 removed <- setdiff(old_names, names)
[13:23:08.800]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.800]                   envs[common]]
[13:23:08.800]                 NAMES <- toupper(changed)
[13:23:08.800]                 args <- list()
[13:23:08.800]                 for (kk in seq_along(NAMES)) {
[13:23:08.800]                   name <- changed[[kk]]
[13:23:08.800]                   NAME <- NAMES[[kk]]
[13:23:08.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.800]                     next
[13:23:08.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.800]                 }
[13:23:08.800]                 NAMES <- toupper(added)
[13:23:08.800]                 for (kk in seq_along(NAMES)) {
[13:23:08.800]                   name <- added[[kk]]
[13:23:08.800]                   NAME <- NAMES[[kk]]
[13:23:08.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.800]                     next
[13:23:08.800]                   args[[name]] <- ""
[13:23:08.800]                 }
[13:23:08.800]                 NAMES <- toupper(removed)
[13:23:08.800]                 for (kk in seq_along(NAMES)) {
[13:23:08.800]                   name <- removed[[kk]]
[13:23:08.800]                   NAME <- NAMES[[kk]]
[13:23:08.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.800]                     next
[13:23:08.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.800]                 }
[13:23:08.800]                 if (length(args) > 0) 
[13:23:08.800]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.800]             }
[13:23:08.800]             else {
[13:23:08.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.800]             }
[13:23:08.800]             {
[13:23:08.800]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.800]                   0L) {
[13:23:08.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.800]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.800]                   base::options(opts)
[13:23:08.800]                 }
[13:23:08.800]                 {
[13:23:08.800]                   {
[13:23:08.800]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.800]                     NULL
[13:23:08.800]                   }
[13:23:08.800]                   options(future.plan = NULL)
[13:23:08.800]                   if (is.na(NA_character_)) 
[13:23:08.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.800]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.800]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.800]                     envir = parent.frame()) 
[13:23:08.800]                   {
[13:23:08.800]                     if (is.function(workers)) 
[13:23:08.800]                       workers <- workers()
[13:23:08.800]                     workers <- structure(as.integer(workers), 
[13:23:08.800]                       class = class(workers))
[13:23:08.800]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.800]                       workers >= 1)
[13:23:08.800]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.800]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.800]                     }
[13:23:08.800]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.800]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.800]                       envir = envir)
[13:23:08.800]                     if (!future$lazy) 
[13:23:08.800]                       future <- run(future)
[13:23:08.800]                     invisible(future)
[13:23:08.800]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.800]                 }
[13:23:08.800]             }
[13:23:08.800]         }
[13:23:08.800]     })
[13:23:08.800]     if (TRUE) {
[13:23:08.800]         base::sink(type = "output", split = FALSE)
[13:23:08.800]         if (TRUE) {
[13:23:08.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.800]         }
[13:23:08.800]         else {
[13:23:08.800]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.800]         }
[13:23:08.800]         base::close(...future.stdout)
[13:23:08.800]         ...future.stdout <- NULL
[13:23:08.800]     }
[13:23:08.800]     ...future.result$conditions <- ...future.conditions
[13:23:08.800]     ...future.result$finished <- base::Sys.time()
[13:23:08.800]     ...future.result
[13:23:08.800] }
[13:23:08.803] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:08.813] receiveMessageFromWorker() for ClusterFuture ...
[13:23:08.814] - Validating connection of MultisessionFuture
[13:23:08.814] - received message: FutureResult
[13:23:08.814] - Received FutureResult
[13:23:08.814] - Erased future from FutureRegistry
[13:23:08.814] result() for ClusterFuture ...
[13:23:08.814] - result already collected: FutureResult
[13:23:08.814] result() for ClusterFuture ... done
[13:23:08.814] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:08.815] result() for ClusterFuture ...
[13:23:08.815] - result already collected: FutureResult
[13:23:08.815] result() for ClusterFuture ... done
[13:23:08.815] result() for ClusterFuture ...
[13:23:08.815] - result already collected: FutureResult
[13:23:08.815] result() for ClusterFuture ... done
[13:23:08.816] MultisessionFuture started
[13:23:08.816] - Launch lazy future ... done
[13:23:08.816] run() for ‘MultisessionFuture’ ... done
<environment: 0x5596d7450960> 
<environment: 0x5596d41b3728> 
 Named logi [1:4] TRUE TRUE FALSE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:08.840] resolve() on environment ...
[13:23:08.840]  recursive: 0
[13:23:08.841]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:08.841] signalConditionsASAP(numeric, pos=1) ...
[13:23:08.841] - nx: 4
[13:23:08.841] - relay: TRUE
[13:23:08.841] - stdout: TRUE
[13:23:08.841] - signal: TRUE
[13:23:08.842] - resignal: FALSE
[13:23:08.842] - force: TRUE
[13:23:08.842] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.842] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.842]  - until=2
[13:23:08.842]  - relaying element #2
[13:23:08.842] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:08.842] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.842] signalConditionsASAP(NULL, pos=1) ... done
[13:23:08.842]  length: 3 (resolved future 1)
[13:23:08.843] Future #2
[13:23:08.843] result() for ClusterFuture ...
[13:23:08.843] - result already collected: FutureResult
[13:23:08.843] result() for ClusterFuture ... done
[13:23:08.843] result() for ClusterFuture ...
[13:23:08.843] - result already collected: FutureResult
[13:23:08.843] result() for ClusterFuture ... done
[13:23:08.843] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:08.843] - nx: 4
[13:23:08.843] - relay: TRUE
[13:23:08.843] - stdout: TRUE
[13:23:08.844] - signal: TRUE
[13:23:08.844] - resignal: FALSE
[13:23:08.844] - force: TRUE
[13:23:08.844] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:08.844] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.844]  - until=2
[13:23:08.844]  - relaying element #2
[13:23:08.844] result() for ClusterFuture ...
[13:23:08.844] - result already collected: FutureResult
[13:23:08.844] result() for ClusterFuture ... done
[13:23:08.845] result() for ClusterFuture ...
[13:23:08.845] - result already collected: FutureResult
[13:23:08.845] result() for ClusterFuture ... done
[13:23:08.845] result() for ClusterFuture ...
[13:23:08.845] - result already collected: FutureResult
[13:23:08.845] result() for ClusterFuture ... done
[13:23:08.845] result() for ClusterFuture ...
[13:23:08.845] - result already collected: FutureResult
[13:23:08.845] result() for ClusterFuture ... done
[13:23:08.845] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:08.846] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:08.846] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:08.846]  length: 2 (resolved future 2)
[13:23:08.846] receiveMessageFromWorker() for ClusterFuture ...
[13:23:08.846] - Validating connection of MultisessionFuture
[13:23:08.847] - received message: FutureResult
[13:23:08.847] - Received FutureResult
[13:23:08.847] - Erased future from FutureRegistry
[13:23:08.847] result() for ClusterFuture ...
[13:23:08.847] - result already collected: FutureResult
[13:23:08.847] result() for ClusterFuture ... done
[13:23:08.847] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:08.847] Future #3
[13:23:08.847] result() for ClusterFuture ...
[13:23:08.848] - result already collected: FutureResult
[13:23:08.848] result() for ClusterFuture ... done
[13:23:08.848] result() for ClusterFuture ...
[13:23:08.848] - result already collected: FutureResult
[13:23:08.848] result() for ClusterFuture ... done
[13:23:08.848] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:08.848] - nx: 4
[13:23:08.848] - relay: TRUE
[13:23:08.848] - stdout: TRUE
[13:23:08.848] - signal: TRUE
[13:23:08.849] - resignal: FALSE
[13:23:08.849] - force: TRUE
[13:23:08.849] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:08.849] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:08.849]  - until=3
[13:23:08.849]  - relaying element #3
[13:23:08.849] result() for ClusterFuture ...
[13:23:08.849] - result already collected: FutureResult
[13:23:08.849] result() for ClusterFuture ... done
[13:23:08.849] result() for ClusterFuture ...
[13:23:08.849] - result already collected: FutureResult
[13:23:08.850] result() for ClusterFuture ... done
[13:23:08.850] result() for ClusterFuture ...
[13:23:08.850] - result already collected: FutureResult
[13:23:08.850] result() for ClusterFuture ... done
[13:23:08.850] result() for ClusterFuture ...
[13:23:08.850] - result already collected: FutureResult
[13:23:08.850] result() for ClusterFuture ... done
[13:23:08.850] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:08.850] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:08.850] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:08.850]  length: 1 (resolved future 3)
[13:23:08.872] receiveMessageFromWorker() for ClusterFuture ...
[13:23:08.872] - Validating connection of MultisessionFuture
[13:23:08.872] - received message: FutureResult
[13:23:08.872] - Received FutureResult
[13:23:08.873] - Erased future from FutureRegistry
[13:23:08.873] result() for ClusterFuture ...
[13:23:08.873] - result already collected: FutureResult
[13:23:08.873] result() for ClusterFuture ... done
[13:23:08.873] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:08.873] Future #4
[13:23:08.873] result() for ClusterFuture ...
[13:23:08.873] - result already collected: FutureResult
[13:23:08.873] result() for ClusterFuture ... done
[13:23:08.873] result() for ClusterFuture ...
[13:23:08.873] - result already collected: FutureResult
[13:23:08.874] result() for ClusterFuture ... done
[13:23:08.874] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:08.874] - nx: 4
[13:23:08.874] - relay: TRUE
[13:23:08.874] - stdout: TRUE
[13:23:08.874] - signal: TRUE
[13:23:08.874] - resignal: FALSE
[13:23:08.874] - force: TRUE
[13:23:08.874] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:08.874] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:08.874]  - until=4
[13:23:08.875]  - relaying element #4
[13:23:08.875] result() for ClusterFuture ...
[13:23:08.875] - result already collected: FutureResult
[13:23:08.875] result() for ClusterFuture ... done
[13:23:08.875] result() for ClusterFuture ...
[13:23:08.875] - result already collected: FutureResult
[13:23:08.875] result() for ClusterFuture ... done
[13:23:08.875] result() for ClusterFuture ...
[13:23:08.875] - result already collected: FutureResult
[13:23:08.875] result() for ClusterFuture ... done
[13:23:08.875] result() for ClusterFuture ...
[13:23:08.876] - result already collected: FutureResult
[13:23:08.876] result() for ClusterFuture ... done
[13:23:08.876] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:08.876] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:08.876] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:08.876]  length: 0 (resolved future 4)
[13:23:08.876] Relaying remaining futures
[13:23:08.876] signalConditionsASAP(NULL, pos=0) ...
[13:23:08.876] - nx: 4
[13:23:08.876] - relay: TRUE
[13:23:08.877] - stdout: TRUE
[13:23:08.877] - signal: TRUE
[13:23:08.877] - resignal: FALSE
[13:23:08.877] - force: TRUE
[13:23:08.877] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:08.877] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:08.877] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:08.877] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:08.877] signalConditionsASAP(NULL, pos=0) ... done
[13:23:08.877] resolve() on environment ... DONE
[13:23:08.878] result() for ClusterFuture ...
[13:23:08.878] - result already collected: FutureResult
[13:23:08.878] result() for ClusterFuture ... done
[13:23:08.878] result() for ClusterFuture ...
[13:23:08.878] - result already collected: FutureResult
[13:23:08.878] result() for ClusterFuture ... done
[13:23:08.878] result() for ClusterFuture ...
[13:23:08.878] - result already collected: FutureResult
[13:23:08.878] result() for ClusterFuture ... done
[13:23:08.878] result() for ClusterFuture ...
[13:23:08.879] - result already collected: FutureResult
[13:23:08.879] result() for ClusterFuture ... done
[13:23:08.879] result() for ClusterFuture ...
[13:23:08.879] - result already collected: FutureResult
[13:23:08.879] result() for ClusterFuture ... done
[13:23:08.879] result() for ClusterFuture ...
[13:23:08.879] - result already collected: FutureResult
[13:23:08.879] result() for ClusterFuture ... done
<environment: 0x5596d4b3afc8> 
Dimensions: c(2, 3)
[13:23:08.880] getGlobalsAndPackages() ...
[13:23:08.880] Searching for globals...
[13:23:08.880] 
[13:23:08.880] Searching for globals ... DONE
[13:23:08.880] - globals: [0] <none>
[13:23:08.881] getGlobalsAndPackages() ... DONE
[13:23:08.881] run() for ‘Future’ ...
[13:23:08.881] - state: ‘created’
[13:23:08.881] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.895] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:08.896]   - Field: ‘node’
[13:23:08.896]   - Field: ‘label’
[13:23:08.896]   - Field: ‘local’
[13:23:08.896]   - Field: ‘owner’
[13:23:08.896]   - Field: ‘envir’
[13:23:08.896]   - Field: ‘workers’
[13:23:08.896]   - Field: ‘packages’
[13:23:08.896]   - Field: ‘gc’
[13:23:08.896]   - Field: ‘conditions’
[13:23:08.897]   - Field: ‘persistent’
[13:23:08.897]   - Field: ‘expr’
[13:23:08.897]   - Field: ‘uuid’
[13:23:08.897]   - Field: ‘seed’
[13:23:08.897]   - Field: ‘version’
[13:23:08.897]   - Field: ‘result’
[13:23:08.897]   - Field: ‘asynchronous’
[13:23:08.897]   - Field: ‘calls’
[13:23:08.897]   - Field: ‘globals’
[13:23:08.897]   - Field: ‘stdout’
[13:23:08.898]   - Field: ‘earlySignal’
[13:23:08.898]   - Field: ‘lazy’
[13:23:08.898]   - Field: ‘state’
[13:23:08.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:08.898] - Launch lazy future ...
[13:23:08.898] Packages needed by the future expression (n = 0): <none>
[13:23:08.898] Packages needed by future strategies (n = 0): <none>
[13:23:08.899] {
[13:23:08.899]     {
[13:23:08.899]         {
[13:23:08.899]             ...future.startTime <- base::Sys.time()
[13:23:08.899]             {
[13:23:08.899]                 {
[13:23:08.899]                   {
[13:23:08.899]                     {
[13:23:08.899]                       base::local({
[13:23:08.899]                         has_future <- base::requireNamespace("future", 
[13:23:08.899]                           quietly = TRUE)
[13:23:08.899]                         if (has_future) {
[13:23:08.899]                           ns <- base::getNamespace("future")
[13:23:08.899]                           version <- ns[[".package"]][["version"]]
[13:23:08.899]                           if (is.null(version)) 
[13:23:08.899]                             version <- utils::packageVersion("future")
[13:23:08.899]                         }
[13:23:08.899]                         else {
[13:23:08.899]                           version <- NULL
[13:23:08.899]                         }
[13:23:08.899]                         if (!has_future || version < "1.8.0") {
[13:23:08.899]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.899]                             "", base::R.version$version.string), 
[13:23:08.899]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.899]                               "release", "version")], collapse = " "), 
[13:23:08.899]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.899]                             info)
[13:23:08.899]                           info <- base::paste(info, collapse = "; ")
[13:23:08.899]                           if (!has_future) {
[13:23:08.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.899]                               info)
[13:23:08.899]                           }
[13:23:08.899]                           else {
[13:23:08.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.899]                               info, version)
[13:23:08.899]                           }
[13:23:08.899]                           base::stop(msg)
[13:23:08.899]                         }
[13:23:08.899]                       })
[13:23:08.899]                     }
[13:23:08.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.899]                     base::options(mc.cores = 1L)
[13:23:08.899]                   }
[13:23:08.899]                   options(future.plan = NULL)
[13:23:08.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.899]                 }
[13:23:08.899]                 ...future.workdir <- getwd()
[13:23:08.899]             }
[13:23:08.899]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.899]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.899]         }
[13:23:08.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.899]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.899]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.899]             base::names(...future.oldOptions))
[13:23:08.899]     }
[13:23:08.899]     if (FALSE) {
[13:23:08.899]     }
[13:23:08.899]     else {
[13:23:08.899]         if (TRUE) {
[13:23:08.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.899]                 open = "w")
[13:23:08.899]         }
[13:23:08.899]         else {
[13:23:08.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.899]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.899]         }
[13:23:08.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.899]             base::sink(type = "output", split = FALSE)
[13:23:08.899]             base::close(...future.stdout)
[13:23:08.899]         }, add = TRUE)
[13:23:08.899]     }
[13:23:08.899]     ...future.frame <- base::sys.nframe()
[13:23:08.899]     ...future.conditions <- base::list()
[13:23:08.899]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.899]     if (FALSE) {
[13:23:08.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.899]     }
[13:23:08.899]     ...future.result <- base::tryCatch({
[13:23:08.899]         base::withCallingHandlers({
[13:23:08.899]             ...future.value <- base::withVisible(base::local({
[13:23:08.899]                 ...future.makeSendCondition <- base::local({
[13:23:08.899]                   sendCondition <- NULL
[13:23:08.899]                   function(frame = 1L) {
[13:23:08.899]                     if (is.function(sendCondition)) 
[13:23:08.899]                       return(sendCondition)
[13:23:08.899]                     ns <- getNamespace("parallel")
[13:23:08.899]                     if (exists("sendData", mode = "function", 
[13:23:08.899]                       envir = ns)) {
[13:23:08.899]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.899]                         envir = ns)
[13:23:08.899]                       envir <- sys.frame(frame)
[13:23:08.899]                       master <- NULL
[13:23:08.899]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.899]                         !identical(envir, emptyenv())) {
[13:23:08.899]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.899]                           inherits = FALSE)) {
[13:23:08.899]                           master <- get("master", mode = "list", 
[13:23:08.899]                             envir = envir, inherits = FALSE)
[13:23:08.899]                           if (inherits(master, c("SOCKnode", 
[13:23:08.899]                             "SOCK0node"))) {
[13:23:08.899]                             sendCondition <<- function(cond) {
[13:23:08.899]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.899]                                 success = TRUE)
[13:23:08.899]                               parallel_sendData(master, data)
[13:23:08.899]                             }
[13:23:08.899]                             return(sendCondition)
[13:23:08.899]                           }
[13:23:08.899]                         }
[13:23:08.899]                         frame <- frame + 1L
[13:23:08.899]                         envir <- sys.frame(frame)
[13:23:08.899]                       }
[13:23:08.899]                     }
[13:23:08.899]                     sendCondition <<- function(cond) NULL
[13:23:08.899]                   }
[13:23:08.899]                 })
[13:23:08.899]                 withCallingHandlers({
[13:23:08.899]                   2
[13:23:08.899]                 }, immediateCondition = function(cond) {
[13:23:08.899]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.899]                   sendCondition(cond)
[13:23:08.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.899]                   {
[13:23:08.899]                     inherits <- base::inherits
[13:23:08.899]                     invokeRestart <- base::invokeRestart
[13:23:08.899]                     is.null <- base::is.null
[13:23:08.899]                     muffled <- FALSE
[13:23:08.899]                     if (inherits(cond, "message")) {
[13:23:08.899]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.899]                       if (muffled) 
[13:23:08.899]                         invokeRestart("muffleMessage")
[13:23:08.899]                     }
[13:23:08.899]                     else if (inherits(cond, "warning")) {
[13:23:08.899]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.899]                       if (muffled) 
[13:23:08.899]                         invokeRestart("muffleWarning")
[13:23:08.899]                     }
[13:23:08.899]                     else if (inherits(cond, "condition")) {
[13:23:08.899]                       if (!is.null(pattern)) {
[13:23:08.899]                         computeRestarts <- base::computeRestarts
[13:23:08.899]                         grepl <- base::grepl
[13:23:08.899]                         restarts <- computeRestarts(cond)
[13:23:08.899]                         for (restart in restarts) {
[13:23:08.899]                           name <- restart$name
[13:23:08.899]                           if (is.null(name)) 
[13:23:08.899]                             next
[13:23:08.899]                           if (!grepl(pattern, name)) 
[13:23:08.899]                             next
[13:23:08.899]                           invokeRestart(restart)
[13:23:08.899]                           muffled <- TRUE
[13:23:08.899]                           break
[13:23:08.899]                         }
[13:23:08.899]                       }
[13:23:08.899]                     }
[13:23:08.899]                     invisible(muffled)
[13:23:08.899]                   }
[13:23:08.899]                   muffleCondition(cond)
[13:23:08.899]                 })
[13:23:08.899]             }))
[13:23:08.899]             future::FutureResult(value = ...future.value$value, 
[13:23:08.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.899]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.899]                     ...future.globalenv.names))
[13:23:08.899]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.899]         }, condition = base::local({
[13:23:08.899]             c <- base::c
[13:23:08.899]             inherits <- base::inherits
[13:23:08.899]             invokeRestart <- base::invokeRestart
[13:23:08.899]             length <- base::length
[13:23:08.899]             list <- base::list
[13:23:08.899]             seq.int <- base::seq.int
[13:23:08.899]             signalCondition <- base::signalCondition
[13:23:08.899]             sys.calls <- base::sys.calls
[13:23:08.899]             `[[` <- base::`[[`
[13:23:08.899]             `+` <- base::`+`
[13:23:08.899]             `<<-` <- base::`<<-`
[13:23:08.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.899]                   3L)]
[13:23:08.899]             }
[13:23:08.899]             function(cond) {
[13:23:08.899]                 is_error <- inherits(cond, "error")
[13:23:08.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.899]                   NULL)
[13:23:08.899]                 if (is_error) {
[13:23:08.899]                   sessionInformation <- function() {
[13:23:08.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.899]                       search = base::search(), system = base::Sys.info())
[13:23:08.899]                   }
[13:23:08.899]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.899]                     cond$call), session = sessionInformation(), 
[13:23:08.899]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.899]                   signalCondition(cond)
[13:23:08.899]                 }
[13:23:08.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.899]                 "immediateCondition"))) {
[13:23:08.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.899]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.899]                   if (TRUE && !signal) {
[13:23:08.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.899]                     {
[13:23:08.899]                       inherits <- base::inherits
[13:23:08.899]                       invokeRestart <- base::invokeRestart
[13:23:08.899]                       is.null <- base::is.null
[13:23:08.899]                       muffled <- FALSE
[13:23:08.899]                       if (inherits(cond, "message")) {
[13:23:08.899]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.899]                         if (muffled) 
[13:23:08.899]                           invokeRestart("muffleMessage")
[13:23:08.899]                       }
[13:23:08.899]                       else if (inherits(cond, "warning")) {
[13:23:08.899]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.899]                         if (muffled) 
[13:23:08.899]                           invokeRestart("muffleWarning")
[13:23:08.899]                       }
[13:23:08.899]                       else if (inherits(cond, "condition")) {
[13:23:08.899]                         if (!is.null(pattern)) {
[13:23:08.899]                           computeRestarts <- base::computeRestarts
[13:23:08.899]                           grepl <- base::grepl
[13:23:08.899]                           restarts <- computeRestarts(cond)
[13:23:08.899]                           for (restart in restarts) {
[13:23:08.899]                             name <- restart$name
[13:23:08.899]                             if (is.null(name)) 
[13:23:08.899]                               next
[13:23:08.899]                             if (!grepl(pattern, name)) 
[13:23:08.899]                               next
[13:23:08.899]                             invokeRestart(restart)
[13:23:08.899]                             muffled <- TRUE
[13:23:08.899]                             break
[13:23:08.899]                           }
[13:23:08.899]                         }
[13:23:08.899]                       }
[13:23:08.899]                       invisible(muffled)
[13:23:08.899]                     }
[13:23:08.899]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.899]                   }
[13:23:08.899]                 }
[13:23:08.899]                 else {
[13:23:08.899]                   if (TRUE) {
[13:23:08.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.899]                     {
[13:23:08.899]                       inherits <- base::inherits
[13:23:08.899]                       invokeRestart <- base::invokeRestart
[13:23:08.899]                       is.null <- base::is.null
[13:23:08.899]                       muffled <- FALSE
[13:23:08.899]                       if (inherits(cond, "message")) {
[13:23:08.899]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.899]                         if (muffled) 
[13:23:08.899]                           invokeRestart("muffleMessage")
[13:23:08.899]                       }
[13:23:08.899]                       else if (inherits(cond, "warning")) {
[13:23:08.899]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.899]                         if (muffled) 
[13:23:08.899]                           invokeRestart("muffleWarning")
[13:23:08.899]                       }
[13:23:08.899]                       else if (inherits(cond, "condition")) {
[13:23:08.899]                         if (!is.null(pattern)) {
[13:23:08.899]                           computeRestarts <- base::computeRestarts
[13:23:08.899]                           grepl <- base::grepl
[13:23:08.899]                           restarts <- computeRestarts(cond)
[13:23:08.899]                           for (restart in restarts) {
[13:23:08.899]                             name <- restart$name
[13:23:08.899]                             if (is.null(name)) 
[13:23:08.899]                               next
[13:23:08.899]                             if (!grepl(pattern, name)) 
[13:23:08.899]                               next
[13:23:08.899]                             invokeRestart(restart)
[13:23:08.899]                             muffled <- TRUE
[13:23:08.899]                             break
[13:23:08.899]                           }
[13:23:08.899]                         }
[13:23:08.899]                       }
[13:23:08.899]                       invisible(muffled)
[13:23:08.899]                     }
[13:23:08.899]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.899]                   }
[13:23:08.899]                 }
[13:23:08.899]             }
[13:23:08.899]         }))
[13:23:08.899]     }, error = function(ex) {
[13:23:08.899]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.899]                 ...future.rng), started = ...future.startTime, 
[13:23:08.899]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.899]             version = "1.8"), class = "FutureResult")
[13:23:08.899]     }, finally = {
[13:23:08.899]         if (!identical(...future.workdir, getwd())) 
[13:23:08.899]             setwd(...future.workdir)
[13:23:08.899]         {
[13:23:08.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.899]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.899]             }
[13:23:08.899]             base::options(...future.oldOptions)
[13:23:08.899]             if (.Platform$OS.type == "windows") {
[13:23:08.899]                 old_names <- names(...future.oldEnvVars)
[13:23:08.899]                 envs <- base::Sys.getenv()
[13:23:08.899]                 names <- names(envs)
[13:23:08.899]                 common <- intersect(names, old_names)
[13:23:08.899]                 added <- setdiff(names, old_names)
[13:23:08.899]                 removed <- setdiff(old_names, names)
[13:23:08.899]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.899]                   envs[common]]
[13:23:08.899]                 NAMES <- toupper(changed)
[13:23:08.899]                 args <- list()
[13:23:08.899]                 for (kk in seq_along(NAMES)) {
[13:23:08.899]                   name <- changed[[kk]]
[13:23:08.899]                   NAME <- NAMES[[kk]]
[13:23:08.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.899]                     next
[13:23:08.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.899]                 }
[13:23:08.899]                 NAMES <- toupper(added)
[13:23:08.899]                 for (kk in seq_along(NAMES)) {
[13:23:08.899]                   name <- added[[kk]]
[13:23:08.899]                   NAME <- NAMES[[kk]]
[13:23:08.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.899]                     next
[13:23:08.899]                   args[[name]] <- ""
[13:23:08.899]                 }
[13:23:08.899]                 NAMES <- toupper(removed)
[13:23:08.899]                 for (kk in seq_along(NAMES)) {
[13:23:08.899]                   name <- removed[[kk]]
[13:23:08.899]                   NAME <- NAMES[[kk]]
[13:23:08.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.899]                     next
[13:23:08.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.899]                 }
[13:23:08.899]                 if (length(args) > 0) 
[13:23:08.899]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.899]             }
[13:23:08.899]             else {
[13:23:08.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.899]             }
[13:23:08.899]             {
[13:23:08.899]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.899]                   0L) {
[13:23:08.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.899]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.899]                   base::options(opts)
[13:23:08.899]                 }
[13:23:08.899]                 {
[13:23:08.899]                   {
[13:23:08.899]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.899]                     NULL
[13:23:08.899]                   }
[13:23:08.899]                   options(future.plan = NULL)
[13:23:08.899]                   if (is.na(NA_character_)) 
[13:23:08.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.899]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.899]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.899]                     envir = parent.frame()) 
[13:23:08.899]                   {
[13:23:08.899]                     if (is.function(workers)) 
[13:23:08.899]                       workers <- workers()
[13:23:08.899]                     workers <- structure(as.integer(workers), 
[13:23:08.899]                       class = class(workers))
[13:23:08.899]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.899]                       workers >= 1)
[13:23:08.899]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.899]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.899]                     }
[13:23:08.899]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.899]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.899]                       envir = envir)
[13:23:08.899]                     if (!future$lazy) 
[13:23:08.899]                       future <- run(future)
[13:23:08.899]                     invisible(future)
[13:23:08.899]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.899]                 }
[13:23:08.899]             }
[13:23:08.899]         }
[13:23:08.899]     })
[13:23:08.899]     if (TRUE) {
[13:23:08.899]         base::sink(type = "output", split = FALSE)
[13:23:08.899]         if (TRUE) {
[13:23:08.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.899]         }
[13:23:08.899]         else {
[13:23:08.899]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.899]         }
[13:23:08.899]         base::close(...future.stdout)
[13:23:08.899]         ...future.stdout <- NULL
[13:23:08.899]     }
[13:23:08.899]     ...future.result$conditions <- ...future.conditions
[13:23:08.899]     ...future.result$finished <- base::Sys.time()
[13:23:08.899]     ...future.result
[13:23:08.899] }
[13:23:08.902] MultisessionFuture started
[13:23:08.902] - Launch lazy future ... done
[13:23:08.902] run() for ‘MultisessionFuture’ ... done
[13:23:08.902] getGlobalsAndPackages() ...
[13:23:08.903] Searching for globals...
[13:23:08.903] 
[13:23:08.903] Searching for globals ... DONE
[13:23:08.903] - globals: [0] <none>
[13:23:08.903] getGlobalsAndPackages() ... DONE
[13:23:08.903] run() for ‘Future’ ...
[13:23:08.904] - state: ‘created’
[13:23:08.904] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.918] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.918] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:08.918]   - Field: ‘node’
[13:23:08.918]   - Field: ‘label’
[13:23:08.919]   - Field: ‘local’
[13:23:08.919]   - Field: ‘owner’
[13:23:08.919]   - Field: ‘envir’
[13:23:08.919]   - Field: ‘workers’
[13:23:08.919]   - Field: ‘packages’
[13:23:08.919]   - Field: ‘gc’
[13:23:08.919]   - Field: ‘conditions’
[13:23:08.919]   - Field: ‘persistent’
[13:23:08.919]   - Field: ‘expr’
[13:23:08.919]   - Field: ‘uuid’
[13:23:08.919]   - Field: ‘seed’
[13:23:08.920]   - Field: ‘version’
[13:23:08.920]   - Field: ‘result’
[13:23:08.920]   - Field: ‘asynchronous’
[13:23:08.920]   - Field: ‘calls’
[13:23:08.920]   - Field: ‘globals’
[13:23:08.920]   - Field: ‘stdout’
[13:23:08.920]   - Field: ‘earlySignal’
[13:23:08.920]   - Field: ‘lazy’
[13:23:08.920]   - Field: ‘state’
[13:23:08.920] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:08.921] - Launch lazy future ...
[13:23:08.921] Packages needed by the future expression (n = 0): <none>
[13:23:08.921] Packages needed by future strategies (n = 0): <none>
[13:23:08.921] {
[13:23:08.921]     {
[13:23:08.921]         {
[13:23:08.921]             ...future.startTime <- base::Sys.time()
[13:23:08.921]             {
[13:23:08.921]                 {
[13:23:08.921]                   {
[13:23:08.921]                     {
[13:23:08.921]                       base::local({
[13:23:08.921]                         has_future <- base::requireNamespace("future", 
[13:23:08.921]                           quietly = TRUE)
[13:23:08.921]                         if (has_future) {
[13:23:08.921]                           ns <- base::getNamespace("future")
[13:23:08.921]                           version <- ns[[".package"]][["version"]]
[13:23:08.921]                           if (is.null(version)) 
[13:23:08.921]                             version <- utils::packageVersion("future")
[13:23:08.921]                         }
[13:23:08.921]                         else {
[13:23:08.921]                           version <- NULL
[13:23:08.921]                         }
[13:23:08.921]                         if (!has_future || version < "1.8.0") {
[13:23:08.921]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.921]                             "", base::R.version$version.string), 
[13:23:08.921]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.921]                               "release", "version")], collapse = " "), 
[13:23:08.921]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.921]                             info)
[13:23:08.921]                           info <- base::paste(info, collapse = "; ")
[13:23:08.921]                           if (!has_future) {
[13:23:08.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.921]                               info)
[13:23:08.921]                           }
[13:23:08.921]                           else {
[13:23:08.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.921]                               info, version)
[13:23:08.921]                           }
[13:23:08.921]                           base::stop(msg)
[13:23:08.921]                         }
[13:23:08.921]                       })
[13:23:08.921]                     }
[13:23:08.921]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.921]                     base::options(mc.cores = 1L)
[13:23:08.921]                   }
[13:23:08.921]                   options(future.plan = NULL)
[13:23:08.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.921]                 }
[13:23:08.921]                 ...future.workdir <- getwd()
[13:23:08.921]             }
[13:23:08.921]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.921]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.921]         }
[13:23:08.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.921]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.921]             base::names(...future.oldOptions))
[13:23:08.921]     }
[13:23:08.921]     if (FALSE) {
[13:23:08.921]     }
[13:23:08.921]     else {
[13:23:08.921]         if (TRUE) {
[13:23:08.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.921]                 open = "w")
[13:23:08.921]         }
[13:23:08.921]         else {
[13:23:08.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.921]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.921]         }
[13:23:08.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.921]             base::sink(type = "output", split = FALSE)
[13:23:08.921]             base::close(...future.stdout)
[13:23:08.921]         }, add = TRUE)
[13:23:08.921]     }
[13:23:08.921]     ...future.frame <- base::sys.nframe()
[13:23:08.921]     ...future.conditions <- base::list()
[13:23:08.921]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.921]     if (FALSE) {
[13:23:08.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.921]     }
[13:23:08.921]     ...future.result <- base::tryCatch({
[13:23:08.921]         base::withCallingHandlers({
[13:23:08.921]             ...future.value <- base::withVisible(base::local({
[13:23:08.921]                 ...future.makeSendCondition <- base::local({
[13:23:08.921]                   sendCondition <- NULL
[13:23:08.921]                   function(frame = 1L) {
[13:23:08.921]                     if (is.function(sendCondition)) 
[13:23:08.921]                       return(sendCondition)
[13:23:08.921]                     ns <- getNamespace("parallel")
[13:23:08.921]                     if (exists("sendData", mode = "function", 
[13:23:08.921]                       envir = ns)) {
[13:23:08.921]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.921]                         envir = ns)
[13:23:08.921]                       envir <- sys.frame(frame)
[13:23:08.921]                       master <- NULL
[13:23:08.921]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.921]                         !identical(envir, emptyenv())) {
[13:23:08.921]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.921]                           inherits = FALSE)) {
[13:23:08.921]                           master <- get("master", mode = "list", 
[13:23:08.921]                             envir = envir, inherits = FALSE)
[13:23:08.921]                           if (inherits(master, c("SOCKnode", 
[13:23:08.921]                             "SOCK0node"))) {
[13:23:08.921]                             sendCondition <<- function(cond) {
[13:23:08.921]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.921]                                 success = TRUE)
[13:23:08.921]                               parallel_sendData(master, data)
[13:23:08.921]                             }
[13:23:08.921]                             return(sendCondition)
[13:23:08.921]                           }
[13:23:08.921]                         }
[13:23:08.921]                         frame <- frame + 1L
[13:23:08.921]                         envir <- sys.frame(frame)
[13:23:08.921]                       }
[13:23:08.921]                     }
[13:23:08.921]                     sendCondition <<- function(cond) NULL
[13:23:08.921]                   }
[13:23:08.921]                 })
[13:23:08.921]                 withCallingHandlers({
[13:23:08.921]                   NULL
[13:23:08.921]                 }, immediateCondition = function(cond) {
[13:23:08.921]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.921]                   sendCondition(cond)
[13:23:08.921]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.921]                   {
[13:23:08.921]                     inherits <- base::inherits
[13:23:08.921]                     invokeRestart <- base::invokeRestart
[13:23:08.921]                     is.null <- base::is.null
[13:23:08.921]                     muffled <- FALSE
[13:23:08.921]                     if (inherits(cond, "message")) {
[13:23:08.921]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.921]                       if (muffled) 
[13:23:08.921]                         invokeRestart("muffleMessage")
[13:23:08.921]                     }
[13:23:08.921]                     else if (inherits(cond, "warning")) {
[13:23:08.921]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.921]                       if (muffled) 
[13:23:08.921]                         invokeRestart("muffleWarning")
[13:23:08.921]                     }
[13:23:08.921]                     else if (inherits(cond, "condition")) {
[13:23:08.921]                       if (!is.null(pattern)) {
[13:23:08.921]                         computeRestarts <- base::computeRestarts
[13:23:08.921]                         grepl <- base::grepl
[13:23:08.921]                         restarts <- computeRestarts(cond)
[13:23:08.921]                         for (restart in restarts) {
[13:23:08.921]                           name <- restart$name
[13:23:08.921]                           if (is.null(name)) 
[13:23:08.921]                             next
[13:23:08.921]                           if (!grepl(pattern, name)) 
[13:23:08.921]                             next
[13:23:08.921]                           invokeRestart(restart)
[13:23:08.921]                           muffled <- TRUE
[13:23:08.921]                           break
[13:23:08.921]                         }
[13:23:08.921]                       }
[13:23:08.921]                     }
[13:23:08.921]                     invisible(muffled)
[13:23:08.921]                   }
[13:23:08.921]                   muffleCondition(cond)
[13:23:08.921]                 })
[13:23:08.921]             }))
[13:23:08.921]             future::FutureResult(value = ...future.value$value, 
[13:23:08.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.921]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.921]                     ...future.globalenv.names))
[13:23:08.921]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.921]         }, condition = base::local({
[13:23:08.921]             c <- base::c
[13:23:08.921]             inherits <- base::inherits
[13:23:08.921]             invokeRestart <- base::invokeRestart
[13:23:08.921]             length <- base::length
[13:23:08.921]             list <- base::list
[13:23:08.921]             seq.int <- base::seq.int
[13:23:08.921]             signalCondition <- base::signalCondition
[13:23:08.921]             sys.calls <- base::sys.calls
[13:23:08.921]             `[[` <- base::`[[`
[13:23:08.921]             `+` <- base::`+`
[13:23:08.921]             `<<-` <- base::`<<-`
[13:23:08.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.921]                   3L)]
[13:23:08.921]             }
[13:23:08.921]             function(cond) {
[13:23:08.921]                 is_error <- inherits(cond, "error")
[13:23:08.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.921]                   NULL)
[13:23:08.921]                 if (is_error) {
[13:23:08.921]                   sessionInformation <- function() {
[13:23:08.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.921]                       search = base::search(), system = base::Sys.info())
[13:23:08.921]                   }
[13:23:08.921]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.921]                     cond$call), session = sessionInformation(), 
[13:23:08.921]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.921]                   signalCondition(cond)
[13:23:08.921]                 }
[13:23:08.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.921]                 "immediateCondition"))) {
[13:23:08.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.921]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.921]                   if (TRUE && !signal) {
[13:23:08.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.921]                     {
[13:23:08.921]                       inherits <- base::inherits
[13:23:08.921]                       invokeRestart <- base::invokeRestart
[13:23:08.921]                       is.null <- base::is.null
[13:23:08.921]                       muffled <- FALSE
[13:23:08.921]                       if (inherits(cond, "message")) {
[13:23:08.921]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.921]                         if (muffled) 
[13:23:08.921]                           invokeRestart("muffleMessage")
[13:23:08.921]                       }
[13:23:08.921]                       else if (inherits(cond, "warning")) {
[13:23:08.921]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.921]                         if (muffled) 
[13:23:08.921]                           invokeRestart("muffleWarning")
[13:23:08.921]                       }
[13:23:08.921]                       else if (inherits(cond, "condition")) {
[13:23:08.921]                         if (!is.null(pattern)) {
[13:23:08.921]                           computeRestarts <- base::computeRestarts
[13:23:08.921]                           grepl <- base::grepl
[13:23:08.921]                           restarts <- computeRestarts(cond)
[13:23:08.921]                           for (restart in restarts) {
[13:23:08.921]                             name <- restart$name
[13:23:08.921]                             if (is.null(name)) 
[13:23:08.921]                               next
[13:23:08.921]                             if (!grepl(pattern, name)) 
[13:23:08.921]                               next
[13:23:08.921]                             invokeRestart(restart)
[13:23:08.921]                             muffled <- TRUE
[13:23:08.921]                             break
[13:23:08.921]                           }
[13:23:08.921]                         }
[13:23:08.921]                       }
[13:23:08.921]                       invisible(muffled)
[13:23:08.921]                     }
[13:23:08.921]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.921]                   }
[13:23:08.921]                 }
[13:23:08.921]                 else {
[13:23:08.921]                   if (TRUE) {
[13:23:08.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.921]                     {
[13:23:08.921]                       inherits <- base::inherits
[13:23:08.921]                       invokeRestart <- base::invokeRestart
[13:23:08.921]                       is.null <- base::is.null
[13:23:08.921]                       muffled <- FALSE
[13:23:08.921]                       if (inherits(cond, "message")) {
[13:23:08.921]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.921]                         if (muffled) 
[13:23:08.921]                           invokeRestart("muffleMessage")
[13:23:08.921]                       }
[13:23:08.921]                       else if (inherits(cond, "warning")) {
[13:23:08.921]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.921]                         if (muffled) 
[13:23:08.921]                           invokeRestart("muffleWarning")
[13:23:08.921]                       }
[13:23:08.921]                       else if (inherits(cond, "condition")) {
[13:23:08.921]                         if (!is.null(pattern)) {
[13:23:08.921]                           computeRestarts <- base::computeRestarts
[13:23:08.921]                           grepl <- base::grepl
[13:23:08.921]                           restarts <- computeRestarts(cond)
[13:23:08.921]                           for (restart in restarts) {
[13:23:08.921]                             name <- restart$name
[13:23:08.921]                             if (is.null(name)) 
[13:23:08.921]                               next
[13:23:08.921]                             if (!grepl(pattern, name)) 
[13:23:08.921]                               next
[13:23:08.921]                             invokeRestart(restart)
[13:23:08.921]                             muffled <- TRUE
[13:23:08.921]                             break
[13:23:08.921]                           }
[13:23:08.921]                         }
[13:23:08.921]                       }
[13:23:08.921]                       invisible(muffled)
[13:23:08.921]                     }
[13:23:08.921]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.921]                   }
[13:23:08.921]                 }
[13:23:08.921]             }
[13:23:08.921]         }))
[13:23:08.921]     }, error = function(ex) {
[13:23:08.921]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.921]                 ...future.rng), started = ...future.startTime, 
[13:23:08.921]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.921]             version = "1.8"), class = "FutureResult")
[13:23:08.921]     }, finally = {
[13:23:08.921]         if (!identical(...future.workdir, getwd())) 
[13:23:08.921]             setwd(...future.workdir)
[13:23:08.921]         {
[13:23:08.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.921]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.921]             }
[13:23:08.921]             base::options(...future.oldOptions)
[13:23:08.921]             if (.Platform$OS.type == "windows") {
[13:23:08.921]                 old_names <- names(...future.oldEnvVars)
[13:23:08.921]                 envs <- base::Sys.getenv()
[13:23:08.921]                 names <- names(envs)
[13:23:08.921]                 common <- intersect(names, old_names)
[13:23:08.921]                 added <- setdiff(names, old_names)
[13:23:08.921]                 removed <- setdiff(old_names, names)
[13:23:08.921]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.921]                   envs[common]]
[13:23:08.921]                 NAMES <- toupper(changed)
[13:23:08.921]                 args <- list()
[13:23:08.921]                 for (kk in seq_along(NAMES)) {
[13:23:08.921]                   name <- changed[[kk]]
[13:23:08.921]                   NAME <- NAMES[[kk]]
[13:23:08.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.921]                     next
[13:23:08.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.921]                 }
[13:23:08.921]                 NAMES <- toupper(added)
[13:23:08.921]                 for (kk in seq_along(NAMES)) {
[13:23:08.921]                   name <- added[[kk]]
[13:23:08.921]                   NAME <- NAMES[[kk]]
[13:23:08.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.921]                     next
[13:23:08.921]                   args[[name]] <- ""
[13:23:08.921]                 }
[13:23:08.921]                 NAMES <- toupper(removed)
[13:23:08.921]                 for (kk in seq_along(NAMES)) {
[13:23:08.921]                   name <- removed[[kk]]
[13:23:08.921]                   NAME <- NAMES[[kk]]
[13:23:08.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.921]                     next
[13:23:08.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.921]                 }
[13:23:08.921]                 if (length(args) > 0) 
[13:23:08.921]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.921]             }
[13:23:08.921]             else {
[13:23:08.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.921]             }
[13:23:08.921]             {
[13:23:08.921]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.921]                   0L) {
[13:23:08.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.921]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.921]                   base::options(opts)
[13:23:08.921]                 }
[13:23:08.921]                 {
[13:23:08.921]                   {
[13:23:08.921]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.921]                     NULL
[13:23:08.921]                   }
[13:23:08.921]                   options(future.plan = NULL)
[13:23:08.921]                   if (is.na(NA_character_)) 
[13:23:08.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.921]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.921]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.921]                     envir = parent.frame()) 
[13:23:08.921]                   {
[13:23:08.921]                     if (is.function(workers)) 
[13:23:08.921]                       workers <- workers()
[13:23:08.921]                     workers <- structure(as.integer(workers), 
[13:23:08.921]                       class = class(workers))
[13:23:08.921]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.921]                       workers >= 1)
[13:23:08.921]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.921]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.921]                     }
[13:23:08.921]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.921]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.921]                       envir = envir)
[13:23:08.921]                     if (!future$lazy) 
[13:23:08.921]                       future <- run(future)
[13:23:08.921]                     invisible(future)
[13:23:08.921]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.921]                 }
[13:23:08.921]             }
[13:23:08.921]         }
[13:23:08.921]     })
[13:23:08.921]     if (TRUE) {
[13:23:08.921]         base::sink(type = "output", split = FALSE)
[13:23:08.921]         if (TRUE) {
[13:23:08.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.921]         }
[13:23:08.921]         else {
[13:23:08.921]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.921]         }
[13:23:08.921]         base::close(...future.stdout)
[13:23:08.921]         ...future.stdout <- NULL
[13:23:08.921]     }
[13:23:08.921]     ...future.result$conditions <- ...future.conditions
[13:23:08.921]     ...future.result$finished <- base::Sys.time()
[13:23:08.921]     ...future.result
[13:23:08.921] }
[13:23:08.925] MultisessionFuture started
[13:23:08.925] - Launch lazy future ... done
[13:23:08.925] run() for ‘MultisessionFuture’ ... done
[13:23:08.925] getGlobalsAndPackages() ...
[13:23:08.925] Searching for globals...
[13:23:08.926] - globals found: [1] ‘{’
[13:23:08.926] Searching for globals ... DONE
[13:23:08.926] Resolving globals: FALSE
[13:23:08.927] 
[13:23:08.927] 
[13:23:08.927] getGlobalsAndPackages() ... DONE
[13:23:08.927] run() for ‘Future’ ...
[13:23:08.927] - state: ‘created’
[13:23:08.927] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:08.942] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:08.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:08.942]   - Field: ‘node’
[13:23:08.942]   - Field: ‘label’
[13:23:08.942]   - Field: ‘local’
[13:23:08.942]   - Field: ‘owner’
[13:23:08.943]   - Field: ‘envir’
[13:23:08.943]   - Field: ‘workers’
[13:23:08.943]   - Field: ‘packages’
[13:23:08.943]   - Field: ‘gc’
[13:23:08.943]   - Field: ‘conditions’
[13:23:08.943]   - Field: ‘persistent’
[13:23:08.943]   - Field: ‘expr’
[13:23:08.943]   - Field: ‘uuid’
[13:23:08.943]   - Field: ‘seed’
[13:23:08.943]   - Field: ‘version’
[13:23:08.944]   - Field: ‘result’
[13:23:08.944]   - Field: ‘asynchronous’
[13:23:08.944]   - Field: ‘calls’
[13:23:08.944]   - Field: ‘globals’
[13:23:08.944]   - Field: ‘stdout’
[13:23:08.944]   - Field: ‘earlySignal’
[13:23:08.944]   - Field: ‘lazy’
[13:23:08.944]   - Field: ‘state’
[13:23:08.944] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:08.944] - Launch lazy future ...
[13:23:08.945] Packages needed by the future expression (n = 0): <none>
[13:23:08.945] Packages needed by future strategies (n = 0): <none>
[13:23:08.945] {
[13:23:08.945]     {
[13:23:08.945]         {
[13:23:08.945]             ...future.startTime <- base::Sys.time()
[13:23:08.945]             {
[13:23:08.945]                 {
[13:23:08.945]                   {
[13:23:08.945]                     {
[13:23:08.945]                       base::local({
[13:23:08.945]                         has_future <- base::requireNamespace("future", 
[13:23:08.945]                           quietly = TRUE)
[13:23:08.945]                         if (has_future) {
[13:23:08.945]                           ns <- base::getNamespace("future")
[13:23:08.945]                           version <- ns[[".package"]][["version"]]
[13:23:08.945]                           if (is.null(version)) 
[13:23:08.945]                             version <- utils::packageVersion("future")
[13:23:08.945]                         }
[13:23:08.945]                         else {
[13:23:08.945]                           version <- NULL
[13:23:08.945]                         }
[13:23:08.945]                         if (!has_future || version < "1.8.0") {
[13:23:08.945]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:08.945]                             "", base::R.version$version.string), 
[13:23:08.945]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:08.945]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:08.945]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:08.945]                               "release", "version")], collapse = " "), 
[13:23:08.945]                             hostname = base::Sys.info()[["nodename"]])
[13:23:08.945]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:08.945]                             info)
[13:23:08.945]                           info <- base::paste(info, collapse = "; ")
[13:23:08.945]                           if (!has_future) {
[13:23:08.945]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:08.945]                               info)
[13:23:08.945]                           }
[13:23:08.945]                           else {
[13:23:08.945]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:08.945]                               info, version)
[13:23:08.945]                           }
[13:23:08.945]                           base::stop(msg)
[13:23:08.945]                         }
[13:23:08.945]                       })
[13:23:08.945]                     }
[13:23:08.945]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:08.945]                     base::options(mc.cores = 1L)
[13:23:08.945]                   }
[13:23:08.945]                   options(future.plan = NULL)
[13:23:08.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:08.945]                 }
[13:23:08.945]                 ...future.workdir <- getwd()
[13:23:08.945]             }
[13:23:08.945]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:08.945]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:08.945]         }
[13:23:08.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:08.945]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:08.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:08.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:08.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:08.945]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:08.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:08.945]             base::names(...future.oldOptions))
[13:23:08.945]     }
[13:23:08.945]     if (FALSE) {
[13:23:08.945]     }
[13:23:08.945]     else {
[13:23:08.945]         if (TRUE) {
[13:23:08.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:08.945]                 open = "w")
[13:23:08.945]         }
[13:23:08.945]         else {
[13:23:08.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:08.945]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:08.945]         }
[13:23:08.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:08.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:08.945]             base::sink(type = "output", split = FALSE)
[13:23:08.945]             base::close(...future.stdout)
[13:23:08.945]         }, add = TRUE)
[13:23:08.945]     }
[13:23:08.945]     ...future.frame <- base::sys.nframe()
[13:23:08.945]     ...future.conditions <- base::list()
[13:23:08.945]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:08.945]     if (FALSE) {
[13:23:08.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:08.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:08.945]     }
[13:23:08.945]     ...future.result <- base::tryCatch({
[13:23:08.945]         base::withCallingHandlers({
[13:23:08.945]             ...future.value <- base::withVisible(base::local({
[13:23:08.945]                 ...future.makeSendCondition <- base::local({
[13:23:08.945]                   sendCondition <- NULL
[13:23:08.945]                   function(frame = 1L) {
[13:23:08.945]                     if (is.function(sendCondition)) 
[13:23:08.945]                       return(sendCondition)
[13:23:08.945]                     ns <- getNamespace("parallel")
[13:23:08.945]                     if (exists("sendData", mode = "function", 
[13:23:08.945]                       envir = ns)) {
[13:23:08.945]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:08.945]                         envir = ns)
[13:23:08.945]                       envir <- sys.frame(frame)
[13:23:08.945]                       master <- NULL
[13:23:08.945]                       while (!identical(envir, .GlobalEnv) && 
[13:23:08.945]                         !identical(envir, emptyenv())) {
[13:23:08.945]                         if (exists("master", mode = "list", envir = envir, 
[13:23:08.945]                           inherits = FALSE)) {
[13:23:08.945]                           master <- get("master", mode = "list", 
[13:23:08.945]                             envir = envir, inherits = FALSE)
[13:23:08.945]                           if (inherits(master, c("SOCKnode", 
[13:23:08.945]                             "SOCK0node"))) {
[13:23:08.945]                             sendCondition <<- function(cond) {
[13:23:08.945]                               data <- list(type = "VALUE", value = cond, 
[13:23:08.945]                                 success = TRUE)
[13:23:08.945]                               parallel_sendData(master, data)
[13:23:08.945]                             }
[13:23:08.945]                             return(sendCondition)
[13:23:08.945]                           }
[13:23:08.945]                         }
[13:23:08.945]                         frame <- frame + 1L
[13:23:08.945]                         envir <- sys.frame(frame)
[13:23:08.945]                       }
[13:23:08.945]                     }
[13:23:08.945]                     sendCondition <<- function(cond) NULL
[13:23:08.945]                   }
[13:23:08.945]                 })
[13:23:08.945]                 withCallingHandlers({
[13:23:08.945]                   {
[13:23:08.945]                     4
[13:23:08.945]                   }
[13:23:08.945]                 }, immediateCondition = function(cond) {
[13:23:08.945]                   sendCondition <- ...future.makeSendCondition()
[13:23:08.945]                   sendCondition(cond)
[13:23:08.945]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.945]                   {
[13:23:08.945]                     inherits <- base::inherits
[13:23:08.945]                     invokeRestart <- base::invokeRestart
[13:23:08.945]                     is.null <- base::is.null
[13:23:08.945]                     muffled <- FALSE
[13:23:08.945]                     if (inherits(cond, "message")) {
[13:23:08.945]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:08.945]                       if (muffled) 
[13:23:08.945]                         invokeRestart("muffleMessage")
[13:23:08.945]                     }
[13:23:08.945]                     else if (inherits(cond, "warning")) {
[13:23:08.945]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:08.945]                       if (muffled) 
[13:23:08.945]                         invokeRestart("muffleWarning")
[13:23:08.945]                     }
[13:23:08.945]                     else if (inherits(cond, "condition")) {
[13:23:08.945]                       if (!is.null(pattern)) {
[13:23:08.945]                         computeRestarts <- base::computeRestarts
[13:23:08.945]                         grepl <- base::grepl
[13:23:08.945]                         restarts <- computeRestarts(cond)
[13:23:08.945]                         for (restart in restarts) {
[13:23:08.945]                           name <- restart$name
[13:23:08.945]                           if (is.null(name)) 
[13:23:08.945]                             next
[13:23:08.945]                           if (!grepl(pattern, name)) 
[13:23:08.945]                             next
[13:23:08.945]                           invokeRestart(restart)
[13:23:08.945]                           muffled <- TRUE
[13:23:08.945]                           break
[13:23:08.945]                         }
[13:23:08.945]                       }
[13:23:08.945]                     }
[13:23:08.945]                     invisible(muffled)
[13:23:08.945]                   }
[13:23:08.945]                   muffleCondition(cond)
[13:23:08.945]                 })
[13:23:08.945]             }))
[13:23:08.945]             future::FutureResult(value = ...future.value$value, 
[13:23:08.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.945]                   ...future.rng), globalenv = if (FALSE) 
[13:23:08.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:08.945]                     ...future.globalenv.names))
[13:23:08.945]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:08.945]         }, condition = base::local({
[13:23:08.945]             c <- base::c
[13:23:08.945]             inherits <- base::inherits
[13:23:08.945]             invokeRestart <- base::invokeRestart
[13:23:08.945]             length <- base::length
[13:23:08.945]             list <- base::list
[13:23:08.945]             seq.int <- base::seq.int
[13:23:08.945]             signalCondition <- base::signalCondition
[13:23:08.945]             sys.calls <- base::sys.calls
[13:23:08.945]             `[[` <- base::`[[`
[13:23:08.945]             `+` <- base::`+`
[13:23:08.945]             `<<-` <- base::`<<-`
[13:23:08.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:08.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:08.945]                   3L)]
[13:23:08.945]             }
[13:23:08.945]             function(cond) {
[13:23:08.945]                 is_error <- inherits(cond, "error")
[13:23:08.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:08.945]                   NULL)
[13:23:08.945]                 if (is_error) {
[13:23:08.945]                   sessionInformation <- function() {
[13:23:08.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:08.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:08.945]                       search = base::search(), system = base::Sys.info())
[13:23:08.945]                   }
[13:23:08.945]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:08.945]                     cond$call), session = sessionInformation(), 
[13:23:08.945]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:08.945]                   signalCondition(cond)
[13:23:08.945]                 }
[13:23:08.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:08.945]                 "immediateCondition"))) {
[13:23:08.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:08.945]                   ...future.conditions[[length(...future.conditions) + 
[13:23:08.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:08.945]                   if (TRUE && !signal) {
[13:23:08.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.945]                     {
[13:23:08.945]                       inherits <- base::inherits
[13:23:08.945]                       invokeRestart <- base::invokeRestart
[13:23:08.945]                       is.null <- base::is.null
[13:23:08.945]                       muffled <- FALSE
[13:23:08.945]                       if (inherits(cond, "message")) {
[13:23:08.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.945]                         if (muffled) 
[13:23:08.945]                           invokeRestart("muffleMessage")
[13:23:08.945]                       }
[13:23:08.945]                       else if (inherits(cond, "warning")) {
[13:23:08.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.945]                         if (muffled) 
[13:23:08.945]                           invokeRestart("muffleWarning")
[13:23:08.945]                       }
[13:23:08.945]                       else if (inherits(cond, "condition")) {
[13:23:08.945]                         if (!is.null(pattern)) {
[13:23:08.945]                           computeRestarts <- base::computeRestarts
[13:23:08.945]                           grepl <- base::grepl
[13:23:08.945]                           restarts <- computeRestarts(cond)
[13:23:08.945]                           for (restart in restarts) {
[13:23:08.945]                             name <- restart$name
[13:23:08.945]                             if (is.null(name)) 
[13:23:08.945]                               next
[13:23:08.945]                             if (!grepl(pattern, name)) 
[13:23:08.945]                               next
[13:23:08.945]                             invokeRestart(restart)
[13:23:08.945]                             muffled <- TRUE
[13:23:08.945]                             break
[13:23:08.945]                           }
[13:23:08.945]                         }
[13:23:08.945]                       }
[13:23:08.945]                       invisible(muffled)
[13:23:08.945]                     }
[13:23:08.945]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.945]                   }
[13:23:08.945]                 }
[13:23:08.945]                 else {
[13:23:08.945]                   if (TRUE) {
[13:23:08.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:08.945]                     {
[13:23:08.945]                       inherits <- base::inherits
[13:23:08.945]                       invokeRestart <- base::invokeRestart
[13:23:08.945]                       is.null <- base::is.null
[13:23:08.945]                       muffled <- FALSE
[13:23:08.945]                       if (inherits(cond, "message")) {
[13:23:08.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:08.945]                         if (muffled) 
[13:23:08.945]                           invokeRestart("muffleMessage")
[13:23:08.945]                       }
[13:23:08.945]                       else if (inherits(cond, "warning")) {
[13:23:08.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:08.945]                         if (muffled) 
[13:23:08.945]                           invokeRestart("muffleWarning")
[13:23:08.945]                       }
[13:23:08.945]                       else if (inherits(cond, "condition")) {
[13:23:08.945]                         if (!is.null(pattern)) {
[13:23:08.945]                           computeRestarts <- base::computeRestarts
[13:23:08.945]                           grepl <- base::grepl
[13:23:08.945]                           restarts <- computeRestarts(cond)
[13:23:08.945]                           for (restart in restarts) {
[13:23:08.945]                             name <- restart$name
[13:23:08.945]                             if (is.null(name)) 
[13:23:08.945]                               next
[13:23:08.945]                             if (!grepl(pattern, name)) 
[13:23:08.945]                               next
[13:23:08.945]                             invokeRestart(restart)
[13:23:08.945]                             muffled <- TRUE
[13:23:08.945]                             break
[13:23:08.945]                           }
[13:23:08.945]                         }
[13:23:08.945]                       }
[13:23:08.945]                       invisible(muffled)
[13:23:08.945]                     }
[13:23:08.945]                     muffleCondition(cond, pattern = "^muffle")
[13:23:08.945]                   }
[13:23:08.945]                 }
[13:23:08.945]             }
[13:23:08.945]         }))
[13:23:08.945]     }, error = function(ex) {
[13:23:08.945]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:08.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:08.945]                 ...future.rng), started = ...future.startTime, 
[13:23:08.945]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:08.945]             version = "1.8"), class = "FutureResult")
[13:23:08.945]     }, finally = {
[13:23:08.945]         if (!identical(...future.workdir, getwd())) 
[13:23:08.945]             setwd(...future.workdir)
[13:23:08.945]         {
[13:23:08.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:08.945]                 ...future.oldOptions$nwarnings <- NULL
[13:23:08.945]             }
[13:23:08.945]             base::options(...future.oldOptions)
[13:23:08.945]             if (.Platform$OS.type == "windows") {
[13:23:08.945]                 old_names <- names(...future.oldEnvVars)
[13:23:08.945]                 envs <- base::Sys.getenv()
[13:23:08.945]                 names <- names(envs)
[13:23:08.945]                 common <- intersect(names, old_names)
[13:23:08.945]                 added <- setdiff(names, old_names)
[13:23:08.945]                 removed <- setdiff(old_names, names)
[13:23:08.945]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:08.945]                   envs[common]]
[13:23:08.945]                 NAMES <- toupper(changed)
[13:23:08.945]                 args <- list()
[13:23:08.945]                 for (kk in seq_along(NAMES)) {
[13:23:08.945]                   name <- changed[[kk]]
[13:23:08.945]                   NAME <- NAMES[[kk]]
[13:23:08.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.945]                     next
[13:23:08.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.945]                 }
[13:23:08.945]                 NAMES <- toupper(added)
[13:23:08.945]                 for (kk in seq_along(NAMES)) {
[13:23:08.945]                   name <- added[[kk]]
[13:23:08.945]                   NAME <- NAMES[[kk]]
[13:23:08.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.945]                     next
[13:23:08.945]                   args[[name]] <- ""
[13:23:08.945]                 }
[13:23:08.945]                 NAMES <- toupper(removed)
[13:23:08.945]                 for (kk in seq_along(NAMES)) {
[13:23:08.945]                   name <- removed[[kk]]
[13:23:08.945]                   NAME <- NAMES[[kk]]
[13:23:08.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:08.945]                     next
[13:23:08.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:08.945]                 }
[13:23:08.945]                 if (length(args) > 0) 
[13:23:08.945]                   base::do.call(base::Sys.setenv, args = args)
[13:23:08.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:08.945]             }
[13:23:08.945]             else {
[13:23:08.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:08.945]             }
[13:23:08.945]             {
[13:23:08.945]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:08.945]                   0L) {
[13:23:08.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:08.945]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:08.945]                   base::options(opts)
[13:23:08.945]                 }
[13:23:08.945]                 {
[13:23:08.945]                   {
[13:23:08.945]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:08.945]                     NULL
[13:23:08.945]                   }
[13:23:08.945]                   options(future.plan = NULL)
[13:23:08.945]                   if (is.na(NA_character_)) 
[13:23:08.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:08.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:08.945]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:08.945]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:08.945]                     envir = parent.frame()) 
[13:23:08.945]                   {
[13:23:08.945]                     if (is.function(workers)) 
[13:23:08.945]                       workers <- workers()
[13:23:08.945]                     workers <- structure(as.integer(workers), 
[13:23:08.945]                       class = class(workers))
[13:23:08.945]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:08.945]                       workers >= 1)
[13:23:08.945]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:08.945]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:08.945]                     }
[13:23:08.945]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:08.945]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:08.945]                       envir = envir)
[13:23:08.945]                     if (!future$lazy) 
[13:23:08.945]                       future <- run(future)
[13:23:08.945]                     invisible(future)
[13:23:08.945]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:08.945]                 }
[13:23:08.945]             }
[13:23:08.945]         }
[13:23:08.945]     })
[13:23:08.945]     if (TRUE) {
[13:23:08.945]         base::sink(type = "output", split = FALSE)
[13:23:08.945]         if (TRUE) {
[13:23:08.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:08.945]         }
[13:23:08.945]         else {
[13:23:08.945]             ...future.result["stdout"] <- base::list(NULL)
[13:23:08.945]         }
[13:23:08.945]         base::close(...future.stdout)
[13:23:08.945]         ...future.stdout <- NULL
[13:23:08.945]     }
[13:23:08.945]     ...future.result$conditions <- ...future.conditions
[13:23:08.945]     ...future.result$finished <- base::Sys.time()
[13:23:08.945]     ...future.result
[13:23:08.945] }
[13:23:08.948] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:08.959] receiveMessageFromWorker() for ClusterFuture ...
[13:23:08.959] - Validating connection of MultisessionFuture
[13:23:08.960] - received message: FutureResult
[13:23:08.960] - Received FutureResult
[13:23:08.960] - Erased future from FutureRegistry
[13:23:08.960] result() for ClusterFuture ...
[13:23:08.960] - result already collected: FutureResult
[13:23:08.960] result() for ClusterFuture ... done
[13:23:08.960] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:08.960] result() for ClusterFuture ...
[13:23:08.960] - result already collected: FutureResult
[13:23:08.961] result() for ClusterFuture ... done
[13:23:08.961] result() for ClusterFuture ...
[13:23:08.961] - result already collected: FutureResult
[13:23:08.961] result() for ClusterFuture ... done
[13:23:08.965] MultisessionFuture started
[13:23:08.965] - Launch lazy future ... done
[13:23:08.965] run() for ‘MultisessionFuture’ ... done
<environment: 0x5596d6a14ef0> 
<environment: 0x5596d5f9f1f0> 
 Named logi [1:4] TRUE TRUE FALSE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:08.989] resolve() on environment ...
[13:23:08.989]  recursive: 0
[13:23:08.990]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:08.990] signalConditionsASAP(numeric, pos=1) ...
[13:23:08.990] - nx: 4
[13:23:08.990] - relay: TRUE
[13:23:08.990] - stdout: TRUE
[13:23:08.990] - signal: TRUE
[13:23:08.991] - resignal: FALSE
[13:23:08.991] - force: TRUE
[13:23:08.991] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.991] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.991]  - until=2
[13:23:08.991]  - relaying element #2
[13:23:08.991] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:08.991] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.991] signalConditionsASAP(NULL, pos=1) ... done
[13:23:08.991]  length: 3 (resolved future 1)
[13:23:08.992] Future #2
[13:23:08.992] result() for ClusterFuture ...
[13:23:08.992] - result already collected: FutureResult
[13:23:08.992] result() for ClusterFuture ... done
[13:23:08.992] result() for ClusterFuture ...
[13:23:08.992] - result already collected: FutureResult
[13:23:08.992] result() for ClusterFuture ... done
[13:23:08.992] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:08.992] - nx: 4
[13:23:08.992] - relay: TRUE
[13:23:08.993] - stdout: TRUE
[13:23:08.993] - signal: TRUE
[13:23:08.993] - resignal: FALSE
[13:23:08.993] - force: TRUE
[13:23:08.993] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:08.993] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:08.993]  - until=2
[13:23:08.993]  - relaying element #2
[13:23:08.993] result() for ClusterFuture ...
[13:23:08.993] - result already collected: FutureResult
[13:23:08.993] result() for ClusterFuture ... done
[13:23:08.993] result() for ClusterFuture ...
[13:23:08.994] - result already collected: FutureResult
[13:23:08.994] result() for ClusterFuture ... done
[13:23:08.994] result() for ClusterFuture ...
[13:23:08.994] - result already collected: FutureResult
[13:23:08.994] result() for ClusterFuture ... done
[13:23:08.994] result() for ClusterFuture ...
[13:23:08.994] - result already collected: FutureResult
[13:23:08.994] result() for ClusterFuture ... done
[13:23:08.994] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:08.994] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:08.994] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:08.995]  length: 2 (resolved future 2)
[13:23:08.995] receiveMessageFromWorker() for ClusterFuture ...
[13:23:08.995] - Validating connection of MultisessionFuture
[13:23:08.995] - received message: FutureResult
[13:23:08.996] - Received FutureResult
[13:23:08.996] - Erased future from FutureRegistry
[13:23:08.996] result() for ClusterFuture ...
[13:23:08.996] - result already collected: FutureResult
[13:23:08.996] result() for ClusterFuture ... done
[13:23:08.996] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:08.996] Future #3
[13:23:08.996] result() for ClusterFuture ...
[13:23:08.996] - result already collected: FutureResult
[13:23:08.996] result() for ClusterFuture ... done
[13:23:08.997] result() for ClusterFuture ...
[13:23:08.997] - result already collected: FutureResult
[13:23:08.997] result() for ClusterFuture ... done
[13:23:08.997] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:08.997] - nx: 4
[13:23:08.997] - relay: TRUE
[13:23:08.997] - stdout: TRUE
[13:23:08.997] - signal: TRUE
[13:23:08.997] - resignal: FALSE
[13:23:08.997] - force: TRUE
[13:23:08.997] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:08.998] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:08.998]  - until=3
[13:23:08.998]  - relaying element #3
[13:23:08.998] result() for ClusterFuture ...
[13:23:08.998] - result already collected: FutureResult
[13:23:08.998] result() for ClusterFuture ... done
[13:23:08.998] result() for ClusterFuture ...
[13:23:08.998] - result already collected: FutureResult
[13:23:08.998] result() for ClusterFuture ... done
[13:23:08.998] result() for ClusterFuture ...
[13:23:08.998] - result already collected: FutureResult
[13:23:08.999] result() for ClusterFuture ... done
[13:23:08.999] result() for ClusterFuture ...
[13:23:08.999] - result already collected: FutureResult
[13:23:08.999] result() for ClusterFuture ... done
[13:23:08.999] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:08.999] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:08.999] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:08.999]  length: 1 (resolved future 3)
[13:23:09.020] receiveMessageFromWorker() for ClusterFuture ...
[13:23:09.021] - Validating connection of MultisessionFuture
[13:23:09.021] - received message: FutureResult
[13:23:09.021] - Received FutureResult
[13:23:09.021] - Erased future from FutureRegistry
[13:23:09.021] result() for ClusterFuture ...
[13:23:09.021] - result already collected: FutureResult
[13:23:09.021] result() for ClusterFuture ... done
[13:23:09.022] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:09.022] Future #4
[13:23:09.022] result() for ClusterFuture ...
[13:23:09.022] - result already collected: FutureResult
[13:23:09.022] result() for ClusterFuture ... done
[13:23:09.022] result() for ClusterFuture ...
[13:23:09.022] - result already collected: FutureResult
[13:23:09.022] result() for ClusterFuture ... done
[13:23:09.022] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:09.022] - nx: 4
[13:23:09.022] - relay: TRUE
[13:23:09.023] - stdout: TRUE
[13:23:09.023] - signal: TRUE
[13:23:09.023] - resignal: FALSE
[13:23:09.023] - force: TRUE
[13:23:09.023] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:09.023] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:09.023]  - until=4
[13:23:09.023]  - relaying element #4
[13:23:09.023] result() for ClusterFuture ...
[13:23:09.023] - result already collected: FutureResult
[13:23:09.023] result() for ClusterFuture ... done
[13:23:09.024] result() for ClusterFuture ...
[13:23:09.024] - result already collected: FutureResult
[13:23:09.024] result() for ClusterFuture ... done
[13:23:09.024] result() for ClusterFuture ...
[13:23:09.024] - result already collected: FutureResult
[13:23:09.024] result() for ClusterFuture ... done
[13:23:09.024] result() for ClusterFuture ...
[13:23:09.024] - result already collected: FutureResult
[13:23:09.024] result() for ClusterFuture ... done
[13:23:09.024] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:09.025] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:09.025] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:09.025]  length: 0 (resolved future 4)
[13:23:09.025] Relaying remaining futures
[13:23:09.025] signalConditionsASAP(NULL, pos=0) ...
[13:23:09.025] - nx: 4
[13:23:09.025] - relay: TRUE
[13:23:09.025] - stdout: TRUE
[13:23:09.025] - signal: TRUE
[13:23:09.025] - resignal: FALSE
[13:23:09.025] - force: TRUE
[13:23:09.026] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:09.026] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:09.026] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:09.026] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:09.026] signalConditionsASAP(NULL, pos=0) ... done
[13:23:09.026] resolve() on environment ... DONE
[13:23:09.026] result() for ClusterFuture ...
[13:23:09.026] - result already collected: FutureResult
[13:23:09.026] result() for ClusterFuture ... done
[13:23:09.026] result() for ClusterFuture ...
[13:23:09.027] - result already collected: FutureResult
[13:23:09.027] result() for ClusterFuture ... done
[13:23:09.027] result() for ClusterFuture ...
[13:23:09.027] - result already collected: FutureResult
[13:23:09.027] result() for ClusterFuture ... done
[13:23:09.027] result() for ClusterFuture ...
[13:23:09.027] - result already collected: FutureResult
[13:23:09.027] result() for ClusterFuture ... done
[13:23:09.027] result() for ClusterFuture ...
[13:23:09.027] - result already collected: FutureResult
[13:23:09.027] result() for ClusterFuture ... done
[13:23:09.028] result() for ClusterFuture ...
[13:23:09.028] - result already collected: FutureResult
[13:23:09.028] result() for ClusterFuture ... done
<environment: 0x5596d5d1de10> 
Dimensions: c(2, 3, 1)
[13:23:09.028] getGlobalsAndPackages() ...
[13:23:09.028] Searching for globals...
[13:23:09.029] 
[13:23:09.029] Searching for globals ... DONE
[13:23:09.029] - globals: [0] <none>
[13:23:09.029] getGlobalsAndPackages() ... DONE
[13:23:09.029] run() for ‘Future’ ...
[13:23:09.029] - state: ‘created’
[13:23:09.029] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.047] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:09.048]   - Field: ‘node’
[13:23:09.048]   - Field: ‘label’
[13:23:09.048]   - Field: ‘local’
[13:23:09.048]   - Field: ‘owner’
[13:23:09.048]   - Field: ‘envir’
[13:23:09.048]   - Field: ‘workers’
[13:23:09.048]   - Field: ‘packages’
[13:23:09.049]   - Field: ‘gc’
[13:23:09.049]   - Field: ‘conditions’
[13:23:09.049]   - Field: ‘persistent’
[13:23:09.049]   - Field: ‘expr’
[13:23:09.049]   - Field: ‘uuid’
[13:23:09.049]   - Field: ‘seed’
[13:23:09.049]   - Field: ‘version’
[13:23:09.049]   - Field: ‘result’
[13:23:09.049]   - Field: ‘asynchronous’
[13:23:09.049]   - Field: ‘calls’
[13:23:09.050]   - Field: ‘globals’
[13:23:09.050]   - Field: ‘stdout’
[13:23:09.050]   - Field: ‘earlySignal’
[13:23:09.050]   - Field: ‘lazy’
[13:23:09.050]   - Field: ‘state’
[13:23:09.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:09.050] - Launch lazy future ...
[13:23:09.050] Packages needed by the future expression (n = 0): <none>
[13:23:09.051] Packages needed by future strategies (n = 0): <none>
[13:23:09.051] {
[13:23:09.051]     {
[13:23:09.051]         {
[13:23:09.051]             ...future.startTime <- base::Sys.time()
[13:23:09.051]             {
[13:23:09.051]                 {
[13:23:09.051]                   {
[13:23:09.051]                     {
[13:23:09.051]                       base::local({
[13:23:09.051]                         has_future <- base::requireNamespace("future", 
[13:23:09.051]                           quietly = TRUE)
[13:23:09.051]                         if (has_future) {
[13:23:09.051]                           ns <- base::getNamespace("future")
[13:23:09.051]                           version <- ns[[".package"]][["version"]]
[13:23:09.051]                           if (is.null(version)) 
[13:23:09.051]                             version <- utils::packageVersion("future")
[13:23:09.051]                         }
[13:23:09.051]                         else {
[13:23:09.051]                           version <- NULL
[13:23:09.051]                         }
[13:23:09.051]                         if (!has_future || version < "1.8.0") {
[13:23:09.051]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.051]                             "", base::R.version$version.string), 
[13:23:09.051]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.051]                               "release", "version")], collapse = " "), 
[13:23:09.051]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.051]                             info)
[13:23:09.051]                           info <- base::paste(info, collapse = "; ")
[13:23:09.051]                           if (!has_future) {
[13:23:09.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.051]                               info)
[13:23:09.051]                           }
[13:23:09.051]                           else {
[13:23:09.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.051]                               info, version)
[13:23:09.051]                           }
[13:23:09.051]                           base::stop(msg)
[13:23:09.051]                         }
[13:23:09.051]                       })
[13:23:09.051]                     }
[13:23:09.051]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.051]                     base::options(mc.cores = 1L)
[13:23:09.051]                   }
[13:23:09.051]                   options(future.plan = NULL)
[13:23:09.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.051]                 }
[13:23:09.051]                 ...future.workdir <- getwd()
[13:23:09.051]             }
[13:23:09.051]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.051]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.051]         }
[13:23:09.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.051]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.051]             base::names(...future.oldOptions))
[13:23:09.051]     }
[13:23:09.051]     if (FALSE) {
[13:23:09.051]     }
[13:23:09.051]     else {
[13:23:09.051]         if (TRUE) {
[13:23:09.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.051]                 open = "w")
[13:23:09.051]         }
[13:23:09.051]         else {
[13:23:09.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.051]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.051]         }
[13:23:09.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.051]             base::sink(type = "output", split = FALSE)
[13:23:09.051]             base::close(...future.stdout)
[13:23:09.051]         }, add = TRUE)
[13:23:09.051]     }
[13:23:09.051]     ...future.frame <- base::sys.nframe()
[13:23:09.051]     ...future.conditions <- base::list()
[13:23:09.051]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.051]     if (FALSE) {
[13:23:09.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.051]     }
[13:23:09.051]     ...future.result <- base::tryCatch({
[13:23:09.051]         base::withCallingHandlers({
[13:23:09.051]             ...future.value <- base::withVisible(base::local({
[13:23:09.051]                 ...future.makeSendCondition <- base::local({
[13:23:09.051]                   sendCondition <- NULL
[13:23:09.051]                   function(frame = 1L) {
[13:23:09.051]                     if (is.function(sendCondition)) 
[13:23:09.051]                       return(sendCondition)
[13:23:09.051]                     ns <- getNamespace("parallel")
[13:23:09.051]                     if (exists("sendData", mode = "function", 
[13:23:09.051]                       envir = ns)) {
[13:23:09.051]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:09.051]                         envir = ns)
[13:23:09.051]                       envir <- sys.frame(frame)
[13:23:09.051]                       master <- NULL
[13:23:09.051]                       while (!identical(envir, .GlobalEnv) && 
[13:23:09.051]                         !identical(envir, emptyenv())) {
[13:23:09.051]                         if (exists("master", mode = "list", envir = envir, 
[13:23:09.051]                           inherits = FALSE)) {
[13:23:09.051]                           master <- get("master", mode = "list", 
[13:23:09.051]                             envir = envir, inherits = FALSE)
[13:23:09.051]                           if (inherits(master, c("SOCKnode", 
[13:23:09.051]                             "SOCK0node"))) {
[13:23:09.051]                             sendCondition <<- function(cond) {
[13:23:09.051]                               data <- list(type = "VALUE", value = cond, 
[13:23:09.051]                                 success = TRUE)
[13:23:09.051]                               parallel_sendData(master, data)
[13:23:09.051]                             }
[13:23:09.051]                             return(sendCondition)
[13:23:09.051]                           }
[13:23:09.051]                         }
[13:23:09.051]                         frame <- frame + 1L
[13:23:09.051]                         envir <- sys.frame(frame)
[13:23:09.051]                       }
[13:23:09.051]                     }
[13:23:09.051]                     sendCondition <<- function(cond) NULL
[13:23:09.051]                   }
[13:23:09.051]                 })
[13:23:09.051]                 withCallingHandlers({
[13:23:09.051]                   2
[13:23:09.051]                 }, immediateCondition = function(cond) {
[13:23:09.051]                   sendCondition <- ...future.makeSendCondition()
[13:23:09.051]                   sendCondition(cond)
[13:23:09.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.051]                   {
[13:23:09.051]                     inherits <- base::inherits
[13:23:09.051]                     invokeRestart <- base::invokeRestart
[13:23:09.051]                     is.null <- base::is.null
[13:23:09.051]                     muffled <- FALSE
[13:23:09.051]                     if (inherits(cond, "message")) {
[13:23:09.051]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.051]                       if (muffled) 
[13:23:09.051]                         invokeRestart("muffleMessage")
[13:23:09.051]                     }
[13:23:09.051]                     else if (inherits(cond, "warning")) {
[13:23:09.051]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.051]                       if (muffled) 
[13:23:09.051]                         invokeRestart("muffleWarning")
[13:23:09.051]                     }
[13:23:09.051]                     else if (inherits(cond, "condition")) {
[13:23:09.051]                       if (!is.null(pattern)) {
[13:23:09.051]                         computeRestarts <- base::computeRestarts
[13:23:09.051]                         grepl <- base::grepl
[13:23:09.051]                         restarts <- computeRestarts(cond)
[13:23:09.051]                         for (restart in restarts) {
[13:23:09.051]                           name <- restart$name
[13:23:09.051]                           if (is.null(name)) 
[13:23:09.051]                             next
[13:23:09.051]                           if (!grepl(pattern, name)) 
[13:23:09.051]                             next
[13:23:09.051]                           invokeRestart(restart)
[13:23:09.051]                           muffled <- TRUE
[13:23:09.051]                           break
[13:23:09.051]                         }
[13:23:09.051]                       }
[13:23:09.051]                     }
[13:23:09.051]                     invisible(muffled)
[13:23:09.051]                   }
[13:23:09.051]                   muffleCondition(cond)
[13:23:09.051]                 })
[13:23:09.051]             }))
[13:23:09.051]             future::FutureResult(value = ...future.value$value, 
[13:23:09.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.051]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.051]                     ...future.globalenv.names))
[13:23:09.051]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.051]         }, condition = base::local({
[13:23:09.051]             c <- base::c
[13:23:09.051]             inherits <- base::inherits
[13:23:09.051]             invokeRestart <- base::invokeRestart
[13:23:09.051]             length <- base::length
[13:23:09.051]             list <- base::list
[13:23:09.051]             seq.int <- base::seq.int
[13:23:09.051]             signalCondition <- base::signalCondition
[13:23:09.051]             sys.calls <- base::sys.calls
[13:23:09.051]             `[[` <- base::`[[`
[13:23:09.051]             `+` <- base::`+`
[13:23:09.051]             `<<-` <- base::`<<-`
[13:23:09.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.051]                   3L)]
[13:23:09.051]             }
[13:23:09.051]             function(cond) {
[13:23:09.051]                 is_error <- inherits(cond, "error")
[13:23:09.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.051]                   NULL)
[13:23:09.051]                 if (is_error) {
[13:23:09.051]                   sessionInformation <- function() {
[13:23:09.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.051]                       search = base::search(), system = base::Sys.info())
[13:23:09.051]                   }
[13:23:09.051]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.051]                     cond$call), session = sessionInformation(), 
[13:23:09.051]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.051]                   signalCondition(cond)
[13:23:09.051]                 }
[13:23:09.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.051]                 "immediateCondition"))) {
[13:23:09.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.051]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.051]                   if (TRUE && !signal) {
[13:23:09.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.051]                     {
[13:23:09.051]                       inherits <- base::inherits
[13:23:09.051]                       invokeRestart <- base::invokeRestart
[13:23:09.051]                       is.null <- base::is.null
[13:23:09.051]                       muffled <- FALSE
[13:23:09.051]                       if (inherits(cond, "message")) {
[13:23:09.051]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.051]                         if (muffled) 
[13:23:09.051]                           invokeRestart("muffleMessage")
[13:23:09.051]                       }
[13:23:09.051]                       else if (inherits(cond, "warning")) {
[13:23:09.051]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.051]                         if (muffled) 
[13:23:09.051]                           invokeRestart("muffleWarning")
[13:23:09.051]                       }
[13:23:09.051]                       else if (inherits(cond, "condition")) {
[13:23:09.051]                         if (!is.null(pattern)) {
[13:23:09.051]                           computeRestarts <- base::computeRestarts
[13:23:09.051]                           grepl <- base::grepl
[13:23:09.051]                           restarts <- computeRestarts(cond)
[13:23:09.051]                           for (restart in restarts) {
[13:23:09.051]                             name <- restart$name
[13:23:09.051]                             if (is.null(name)) 
[13:23:09.051]                               next
[13:23:09.051]                             if (!grepl(pattern, name)) 
[13:23:09.051]                               next
[13:23:09.051]                             invokeRestart(restart)
[13:23:09.051]                             muffled <- TRUE
[13:23:09.051]                             break
[13:23:09.051]                           }
[13:23:09.051]                         }
[13:23:09.051]                       }
[13:23:09.051]                       invisible(muffled)
[13:23:09.051]                     }
[13:23:09.051]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.051]                   }
[13:23:09.051]                 }
[13:23:09.051]                 else {
[13:23:09.051]                   if (TRUE) {
[13:23:09.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.051]                     {
[13:23:09.051]                       inherits <- base::inherits
[13:23:09.051]                       invokeRestart <- base::invokeRestart
[13:23:09.051]                       is.null <- base::is.null
[13:23:09.051]                       muffled <- FALSE
[13:23:09.051]                       if (inherits(cond, "message")) {
[13:23:09.051]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.051]                         if (muffled) 
[13:23:09.051]                           invokeRestart("muffleMessage")
[13:23:09.051]                       }
[13:23:09.051]                       else if (inherits(cond, "warning")) {
[13:23:09.051]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.051]                         if (muffled) 
[13:23:09.051]                           invokeRestart("muffleWarning")
[13:23:09.051]                       }
[13:23:09.051]                       else if (inherits(cond, "condition")) {
[13:23:09.051]                         if (!is.null(pattern)) {
[13:23:09.051]                           computeRestarts <- base::computeRestarts
[13:23:09.051]                           grepl <- base::grepl
[13:23:09.051]                           restarts <- computeRestarts(cond)
[13:23:09.051]                           for (restart in restarts) {
[13:23:09.051]                             name <- restart$name
[13:23:09.051]                             if (is.null(name)) 
[13:23:09.051]                               next
[13:23:09.051]                             if (!grepl(pattern, name)) 
[13:23:09.051]                               next
[13:23:09.051]                             invokeRestart(restart)
[13:23:09.051]                             muffled <- TRUE
[13:23:09.051]                             break
[13:23:09.051]                           }
[13:23:09.051]                         }
[13:23:09.051]                       }
[13:23:09.051]                       invisible(muffled)
[13:23:09.051]                     }
[13:23:09.051]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.051]                   }
[13:23:09.051]                 }
[13:23:09.051]             }
[13:23:09.051]         }))
[13:23:09.051]     }, error = function(ex) {
[13:23:09.051]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.051]                 ...future.rng), started = ...future.startTime, 
[13:23:09.051]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.051]             version = "1.8"), class = "FutureResult")
[13:23:09.051]     }, finally = {
[13:23:09.051]         if (!identical(...future.workdir, getwd())) 
[13:23:09.051]             setwd(...future.workdir)
[13:23:09.051]         {
[13:23:09.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.051]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.051]             }
[13:23:09.051]             base::options(...future.oldOptions)
[13:23:09.051]             if (.Platform$OS.type == "windows") {
[13:23:09.051]                 old_names <- names(...future.oldEnvVars)
[13:23:09.051]                 envs <- base::Sys.getenv()
[13:23:09.051]                 names <- names(envs)
[13:23:09.051]                 common <- intersect(names, old_names)
[13:23:09.051]                 added <- setdiff(names, old_names)
[13:23:09.051]                 removed <- setdiff(old_names, names)
[13:23:09.051]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.051]                   envs[common]]
[13:23:09.051]                 NAMES <- toupper(changed)
[13:23:09.051]                 args <- list()
[13:23:09.051]                 for (kk in seq_along(NAMES)) {
[13:23:09.051]                   name <- changed[[kk]]
[13:23:09.051]                   NAME <- NAMES[[kk]]
[13:23:09.051]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.051]                     next
[13:23:09.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.051]                 }
[13:23:09.051]                 NAMES <- toupper(added)
[13:23:09.051]                 for (kk in seq_along(NAMES)) {
[13:23:09.051]                   name <- added[[kk]]
[13:23:09.051]                   NAME <- NAMES[[kk]]
[13:23:09.051]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.051]                     next
[13:23:09.051]                   args[[name]] <- ""
[13:23:09.051]                 }
[13:23:09.051]                 NAMES <- toupper(removed)
[13:23:09.051]                 for (kk in seq_along(NAMES)) {
[13:23:09.051]                   name <- removed[[kk]]
[13:23:09.051]                   NAME <- NAMES[[kk]]
[13:23:09.051]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.051]                     next
[13:23:09.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.051]                 }
[13:23:09.051]                 if (length(args) > 0) 
[13:23:09.051]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.051]             }
[13:23:09.051]             else {
[13:23:09.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.051]             }
[13:23:09.051]             {
[13:23:09.051]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.051]                   0L) {
[13:23:09.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.051]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.051]                   base::options(opts)
[13:23:09.051]                 }
[13:23:09.051]                 {
[13:23:09.051]                   {
[13:23:09.051]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.051]                     NULL
[13:23:09.051]                   }
[13:23:09.051]                   options(future.plan = NULL)
[13:23:09.051]                   if (is.na(NA_character_)) 
[13:23:09.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.051]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:09.051]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:09.051]                     envir = parent.frame()) 
[13:23:09.051]                   {
[13:23:09.051]                     if (is.function(workers)) 
[13:23:09.051]                       workers <- workers()
[13:23:09.051]                     workers <- structure(as.integer(workers), 
[13:23:09.051]                       class = class(workers))
[13:23:09.051]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:09.051]                       workers >= 1)
[13:23:09.051]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:09.051]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:09.051]                     }
[13:23:09.051]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:09.051]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:09.051]                       envir = envir)
[13:23:09.051]                     if (!future$lazy) 
[13:23:09.051]                       future <- run(future)
[13:23:09.051]                     invisible(future)
[13:23:09.051]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.051]                 }
[13:23:09.051]             }
[13:23:09.051]         }
[13:23:09.051]     })
[13:23:09.051]     if (TRUE) {
[13:23:09.051]         base::sink(type = "output", split = FALSE)
[13:23:09.051]         if (TRUE) {
[13:23:09.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.051]         }
[13:23:09.051]         else {
[13:23:09.051]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.051]         }
[13:23:09.051]         base::close(...future.stdout)
[13:23:09.051]         ...future.stdout <- NULL
[13:23:09.051]     }
[13:23:09.051]     ...future.result$conditions <- ...future.conditions
[13:23:09.051]     ...future.result$finished <- base::Sys.time()
[13:23:09.051]     ...future.result
[13:23:09.051] }
[13:23:09.054] MultisessionFuture started
[13:23:09.054] - Launch lazy future ... done
[13:23:09.055] run() for ‘MultisessionFuture’ ... done
[13:23:09.055] getGlobalsAndPackages() ...
[13:23:09.055] Searching for globals...
[13:23:09.055] 
[13:23:09.055] Searching for globals ... DONE
[13:23:09.055] - globals: [0] <none>
[13:23:09.055] getGlobalsAndPackages() ... DONE
[13:23:09.056] run() for ‘Future’ ...
[13:23:09.056] - state: ‘created’
[13:23:09.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.070] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:09.070]   - Field: ‘node’
[13:23:09.070]   - Field: ‘label’
[13:23:09.071]   - Field: ‘local’
[13:23:09.071]   - Field: ‘owner’
[13:23:09.071]   - Field: ‘envir’
[13:23:09.071]   - Field: ‘workers’
[13:23:09.071]   - Field: ‘packages’
[13:23:09.071]   - Field: ‘gc’
[13:23:09.071]   - Field: ‘conditions’
[13:23:09.071]   - Field: ‘persistent’
[13:23:09.071]   - Field: ‘expr’
[13:23:09.071]   - Field: ‘uuid’
[13:23:09.072]   - Field: ‘seed’
[13:23:09.072]   - Field: ‘version’
[13:23:09.072]   - Field: ‘result’
[13:23:09.072]   - Field: ‘asynchronous’
[13:23:09.072]   - Field: ‘calls’
[13:23:09.072]   - Field: ‘globals’
[13:23:09.072]   - Field: ‘stdout’
[13:23:09.072]   - Field: ‘earlySignal’
[13:23:09.072]   - Field: ‘lazy’
[13:23:09.072]   - Field: ‘state’
[13:23:09.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:09.073] - Launch lazy future ...
[13:23:09.073] Packages needed by the future expression (n = 0): <none>
[13:23:09.073] Packages needed by future strategies (n = 0): <none>
[13:23:09.074] {
[13:23:09.074]     {
[13:23:09.074]         {
[13:23:09.074]             ...future.startTime <- base::Sys.time()
[13:23:09.074]             {
[13:23:09.074]                 {
[13:23:09.074]                   {
[13:23:09.074]                     {
[13:23:09.074]                       base::local({
[13:23:09.074]                         has_future <- base::requireNamespace("future", 
[13:23:09.074]                           quietly = TRUE)
[13:23:09.074]                         if (has_future) {
[13:23:09.074]                           ns <- base::getNamespace("future")
[13:23:09.074]                           version <- ns[[".package"]][["version"]]
[13:23:09.074]                           if (is.null(version)) 
[13:23:09.074]                             version <- utils::packageVersion("future")
[13:23:09.074]                         }
[13:23:09.074]                         else {
[13:23:09.074]                           version <- NULL
[13:23:09.074]                         }
[13:23:09.074]                         if (!has_future || version < "1.8.0") {
[13:23:09.074]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.074]                             "", base::R.version$version.string), 
[13:23:09.074]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.074]                               "release", "version")], collapse = " "), 
[13:23:09.074]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.074]                             info)
[13:23:09.074]                           info <- base::paste(info, collapse = "; ")
[13:23:09.074]                           if (!has_future) {
[13:23:09.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.074]                               info)
[13:23:09.074]                           }
[13:23:09.074]                           else {
[13:23:09.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.074]                               info, version)
[13:23:09.074]                           }
[13:23:09.074]                           base::stop(msg)
[13:23:09.074]                         }
[13:23:09.074]                       })
[13:23:09.074]                     }
[13:23:09.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.074]                     base::options(mc.cores = 1L)
[13:23:09.074]                   }
[13:23:09.074]                   options(future.plan = NULL)
[13:23:09.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.074]                 }
[13:23:09.074]                 ...future.workdir <- getwd()
[13:23:09.074]             }
[13:23:09.074]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.074]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.074]         }
[13:23:09.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.074]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.074]             base::names(...future.oldOptions))
[13:23:09.074]     }
[13:23:09.074]     if (FALSE) {
[13:23:09.074]     }
[13:23:09.074]     else {
[13:23:09.074]         if (TRUE) {
[13:23:09.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.074]                 open = "w")
[13:23:09.074]         }
[13:23:09.074]         else {
[13:23:09.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.074]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.074]         }
[13:23:09.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.074]             base::sink(type = "output", split = FALSE)
[13:23:09.074]             base::close(...future.stdout)
[13:23:09.074]         }, add = TRUE)
[13:23:09.074]     }
[13:23:09.074]     ...future.frame <- base::sys.nframe()
[13:23:09.074]     ...future.conditions <- base::list()
[13:23:09.074]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.074]     if (FALSE) {
[13:23:09.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.074]     }
[13:23:09.074]     ...future.result <- base::tryCatch({
[13:23:09.074]         base::withCallingHandlers({
[13:23:09.074]             ...future.value <- base::withVisible(base::local({
[13:23:09.074]                 ...future.makeSendCondition <- base::local({
[13:23:09.074]                   sendCondition <- NULL
[13:23:09.074]                   function(frame = 1L) {
[13:23:09.074]                     if (is.function(sendCondition)) 
[13:23:09.074]                       return(sendCondition)
[13:23:09.074]                     ns <- getNamespace("parallel")
[13:23:09.074]                     if (exists("sendData", mode = "function", 
[13:23:09.074]                       envir = ns)) {
[13:23:09.074]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:09.074]                         envir = ns)
[13:23:09.074]                       envir <- sys.frame(frame)
[13:23:09.074]                       master <- NULL
[13:23:09.074]                       while (!identical(envir, .GlobalEnv) && 
[13:23:09.074]                         !identical(envir, emptyenv())) {
[13:23:09.074]                         if (exists("master", mode = "list", envir = envir, 
[13:23:09.074]                           inherits = FALSE)) {
[13:23:09.074]                           master <- get("master", mode = "list", 
[13:23:09.074]                             envir = envir, inherits = FALSE)
[13:23:09.074]                           if (inherits(master, c("SOCKnode", 
[13:23:09.074]                             "SOCK0node"))) {
[13:23:09.074]                             sendCondition <<- function(cond) {
[13:23:09.074]                               data <- list(type = "VALUE", value = cond, 
[13:23:09.074]                                 success = TRUE)
[13:23:09.074]                               parallel_sendData(master, data)
[13:23:09.074]                             }
[13:23:09.074]                             return(sendCondition)
[13:23:09.074]                           }
[13:23:09.074]                         }
[13:23:09.074]                         frame <- frame + 1L
[13:23:09.074]                         envir <- sys.frame(frame)
[13:23:09.074]                       }
[13:23:09.074]                     }
[13:23:09.074]                     sendCondition <<- function(cond) NULL
[13:23:09.074]                   }
[13:23:09.074]                 })
[13:23:09.074]                 withCallingHandlers({
[13:23:09.074]                   NULL
[13:23:09.074]                 }, immediateCondition = function(cond) {
[13:23:09.074]                   sendCondition <- ...future.makeSendCondition()
[13:23:09.074]                   sendCondition(cond)
[13:23:09.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.074]                   {
[13:23:09.074]                     inherits <- base::inherits
[13:23:09.074]                     invokeRestart <- base::invokeRestart
[13:23:09.074]                     is.null <- base::is.null
[13:23:09.074]                     muffled <- FALSE
[13:23:09.074]                     if (inherits(cond, "message")) {
[13:23:09.074]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.074]                       if (muffled) 
[13:23:09.074]                         invokeRestart("muffleMessage")
[13:23:09.074]                     }
[13:23:09.074]                     else if (inherits(cond, "warning")) {
[13:23:09.074]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.074]                       if (muffled) 
[13:23:09.074]                         invokeRestart("muffleWarning")
[13:23:09.074]                     }
[13:23:09.074]                     else if (inherits(cond, "condition")) {
[13:23:09.074]                       if (!is.null(pattern)) {
[13:23:09.074]                         computeRestarts <- base::computeRestarts
[13:23:09.074]                         grepl <- base::grepl
[13:23:09.074]                         restarts <- computeRestarts(cond)
[13:23:09.074]                         for (restart in restarts) {
[13:23:09.074]                           name <- restart$name
[13:23:09.074]                           if (is.null(name)) 
[13:23:09.074]                             next
[13:23:09.074]                           if (!grepl(pattern, name)) 
[13:23:09.074]                             next
[13:23:09.074]                           invokeRestart(restart)
[13:23:09.074]                           muffled <- TRUE
[13:23:09.074]                           break
[13:23:09.074]                         }
[13:23:09.074]                       }
[13:23:09.074]                     }
[13:23:09.074]                     invisible(muffled)
[13:23:09.074]                   }
[13:23:09.074]                   muffleCondition(cond)
[13:23:09.074]                 })
[13:23:09.074]             }))
[13:23:09.074]             future::FutureResult(value = ...future.value$value, 
[13:23:09.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.074]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.074]                     ...future.globalenv.names))
[13:23:09.074]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.074]         }, condition = base::local({
[13:23:09.074]             c <- base::c
[13:23:09.074]             inherits <- base::inherits
[13:23:09.074]             invokeRestart <- base::invokeRestart
[13:23:09.074]             length <- base::length
[13:23:09.074]             list <- base::list
[13:23:09.074]             seq.int <- base::seq.int
[13:23:09.074]             signalCondition <- base::signalCondition
[13:23:09.074]             sys.calls <- base::sys.calls
[13:23:09.074]             `[[` <- base::`[[`
[13:23:09.074]             `+` <- base::`+`
[13:23:09.074]             `<<-` <- base::`<<-`
[13:23:09.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.074]                   3L)]
[13:23:09.074]             }
[13:23:09.074]             function(cond) {
[13:23:09.074]                 is_error <- inherits(cond, "error")
[13:23:09.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.074]                   NULL)
[13:23:09.074]                 if (is_error) {
[13:23:09.074]                   sessionInformation <- function() {
[13:23:09.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.074]                       search = base::search(), system = base::Sys.info())
[13:23:09.074]                   }
[13:23:09.074]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.074]                     cond$call), session = sessionInformation(), 
[13:23:09.074]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.074]                   signalCondition(cond)
[13:23:09.074]                 }
[13:23:09.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.074]                 "immediateCondition"))) {
[13:23:09.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.074]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.074]                   if (TRUE && !signal) {
[13:23:09.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.074]                     {
[13:23:09.074]                       inherits <- base::inherits
[13:23:09.074]                       invokeRestart <- base::invokeRestart
[13:23:09.074]                       is.null <- base::is.null
[13:23:09.074]                       muffled <- FALSE
[13:23:09.074]                       if (inherits(cond, "message")) {
[13:23:09.074]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.074]                         if (muffled) 
[13:23:09.074]                           invokeRestart("muffleMessage")
[13:23:09.074]                       }
[13:23:09.074]                       else if (inherits(cond, "warning")) {
[13:23:09.074]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.074]                         if (muffled) 
[13:23:09.074]                           invokeRestart("muffleWarning")
[13:23:09.074]                       }
[13:23:09.074]                       else if (inherits(cond, "condition")) {
[13:23:09.074]                         if (!is.null(pattern)) {
[13:23:09.074]                           computeRestarts <- base::computeRestarts
[13:23:09.074]                           grepl <- base::grepl
[13:23:09.074]                           restarts <- computeRestarts(cond)
[13:23:09.074]                           for (restart in restarts) {
[13:23:09.074]                             name <- restart$name
[13:23:09.074]                             if (is.null(name)) 
[13:23:09.074]                               next
[13:23:09.074]                             if (!grepl(pattern, name)) 
[13:23:09.074]                               next
[13:23:09.074]                             invokeRestart(restart)
[13:23:09.074]                             muffled <- TRUE
[13:23:09.074]                             break
[13:23:09.074]                           }
[13:23:09.074]                         }
[13:23:09.074]                       }
[13:23:09.074]                       invisible(muffled)
[13:23:09.074]                     }
[13:23:09.074]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.074]                   }
[13:23:09.074]                 }
[13:23:09.074]                 else {
[13:23:09.074]                   if (TRUE) {
[13:23:09.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.074]                     {
[13:23:09.074]                       inherits <- base::inherits
[13:23:09.074]                       invokeRestart <- base::invokeRestart
[13:23:09.074]                       is.null <- base::is.null
[13:23:09.074]                       muffled <- FALSE
[13:23:09.074]                       if (inherits(cond, "message")) {
[13:23:09.074]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.074]                         if (muffled) 
[13:23:09.074]                           invokeRestart("muffleMessage")
[13:23:09.074]                       }
[13:23:09.074]                       else if (inherits(cond, "warning")) {
[13:23:09.074]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.074]                         if (muffled) 
[13:23:09.074]                           invokeRestart("muffleWarning")
[13:23:09.074]                       }
[13:23:09.074]                       else if (inherits(cond, "condition")) {
[13:23:09.074]                         if (!is.null(pattern)) {
[13:23:09.074]                           computeRestarts <- base::computeRestarts
[13:23:09.074]                           grepl <- base::grepl
[13:23:09.074]                           restarts <- computeRestarts(cond)
[13:23:09.074]                           for (restart in restarts) {
[13:23:09.074]                             name <- restart$name
[13:23:09.074]                             if (is.null(name)) 
[13:23:09.074]                               next
[13:23:09.074]                             if (!grepl(pattern, name)) 
[13:23:09.074]                               next
[13:23:09.074]                             invokeRestart(restart)
[13:23:09.074]                             muffled <- TRUE
[13:23:09.074]                             break
[13:23:09.074]                           }
[13:23:09.074]                         }
[13:23:09.074]                       }
[13:23:09.074]                       invisible(muffled)
[13:23:09.074]                     }
[13:23:09.074]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.074]                   }
[13:23:09.074]                 }
[13:23:09.074]             }
[13:23:09.074]         }))
[13:23:09.074]     }, error = function(ex) {
[13:23:09.074]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.074]                 ...future.rng), started = ...future.startTime, 
[13:23:09.074]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.074]             version = "1.8"), class = "FutureResult")
[13:23:09.074]     }, finally = {
[13:23:09.074]         if (!identical(...future.workdir, getwd())) 
[13:23:09.074]             setwd(...future.workdir)
[13:23:09.074]         {
[13:23:09.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.074]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.074]             }
[13:23:09.074]             base::options(...future.oldOptions)
[13:23:09.074]             if (.Platform$OS.type == "windows") {
[13:23:09.074]                 old_names <- names(...future.oldEnvVars)
[13:23:09.074]                 envs <- base::Sys.getenv()
[13:23:09.074]                 names <- names(envs)
[13:23:09.074]                 common <- intersect(names, old_names)
[13:23:09.074]                 added <- setdiff(names, old_names)
[13:23:09.074]                 removed <- setdiff(old_names, names)
[13:23:09.074]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.074]                   envs[common]]
[13:23:09.074]                 NAMES <- toupper(changed)
[13:23:09.074]                 args <- list()
[13:23:09.074]                 for (kk in seq_along(NAMES)) {
[13:23:09.074]                   name <- changed[[kk]]
[13:23:09.074]                   NAME <- NAMES[[kk]]
[13:23:09.074]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.074]                     next
[13:23:09.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.074]                 }
[13:23:09.074]                 NAMES <- toupper(added)
[13:23:09.074]                 for (kk in seq_along(NAMES)) {
[13:23:09.074]                   name <- added[[kk]]
[13:23:09.074]                   NAME <- NAMES[[kk]]
[13:23:09.074]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.074]                     next
[13:23:09.074]                   args[[name]] <- ""
[13:23:09.074]                 }
[13:23:09.074]                 NAMES <- toupper(removed)
[13:23:09.074]                 for (kk in seq_along(NAMES)) {
[13:23:09.074]                   name <- removed[[kk]]
[13:23:09.074]                   NAME <- NAMES[[kk]]
[13:23:09.074]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.074]                     next
[13:23:09.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.074]                 }
[13:23:09.074]                 if (length(args) > 0) 
[13:23:09.074]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.074]             }
[13:23:09.074]             else {
[13:23:09.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.074]             }
[13:23:09.074]             {
[13:23:09.074]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.074]                   0L) {
[13:23:09.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.074]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.074]                   base::options(opts)
[13:23:09.074]                 }
[13:23:09.074]                 {
[13:23:09.074]                   {
[13:23:09.074]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.074]                     NULL
[13:23:09.074]                   }
[13:23:09.074]                   options(future.plan = NULL)
[13:23:09.074]                   if (is.na(NA_character_)) 
[13:23:09.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.074]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:09.074]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:09.074]                     envir = parent.frame()) 
[13:23:09.074]                   {
[13:23:09.074]                     if (is.function(workers)) 
[13:23:09.074]                       workers <- workers()
[13:23:09.074]                     workers <- structure(as.integer(workers), 
[13:23:09.074]                       class = class(workers))
[13:23:09.074]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:09.074]                       workers >= 1)
[13:23:09.074]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:09.074]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:09.074]                     }
[13:23:09.074]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:09.074]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:09.074]                       envir = envir)
[13:23:09.074]                     if (!future$lazy) 
[13:23:09.074]                       future <- run(future)
[13:23:09.074]                     invisible(future)
[13:23:09.074]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.074]                 }
[13:23:09.074]             }
[13:23:09.074]         }
[13:23:09.074]     })
[13:23:09.074]     if (TRUE) {
[13:23:09.074]         base::sink(type = "output", split = FALSE)
[13:23:09.074]         if (TRUE) {
[13:23:09.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.074]         }
[13:23:09.074]         else {
[13:23:09.074]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.074]         }
[13:23:09.074]         base::close(...future.stdout)
[13:23:09.074]         ...future.stdout <- NULL
[13:23:09.074]     }
[13:23:09.074]     ...future.result$conditions <- ...future.conditions
[13:23:09.074]     ...future.result$finished <- base::Sys.time()
[13:23:09.074]     ...future.result
[13:23:09.074] }
[13:23:09.077] MultisessionFuture started
[13:23:09.077] - Launch lazy future ... done
[13:23:09.077] run() for ‘MultisessionFuture’ ... done
[13:23:09.078] getGlobalsAndPackages() ...
[13:23:09.078] Searching for globals...
[13:23:09.078] - globals found: [1] ‘{’
[13:23:09.079] Searching for globals ... DONE
[13:23:09.079] Resolving globals: FALSE
[13:23:09.079] 
[13:23:09.079] 
[13:23:09.079] getGlobalsAndPackages() ... DONE
[13:23:09.079] run() for ‘Future’ ...
[13:23:09.080] - state: ‘created’
[13:23:09.080] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.094] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.094] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:09.094]   - Field: ‘node’
[13:23:09.094]   - Field: ‘label’
[13:23:09.094]   - Field: ‘local’
[13:23:09.095]   - Field: ‘owner’
[13:23:09.095]   - Field: ‘envir’
[13:23:09.095]   - Field: ‘workers’
[13:23:09.095]   - Field: ‘packages’
[13:23:09.095]   - Field: ‘gc’
[13:23:09.095]   - Field: ‘conditions’
[13:23:09.095]   - Field: ‘persistent’
[13:23:09.095]   - Field: ‘expr’
[13:23:09.095]   - Field: ‘uuid’
[13:23:09.095]   - Field: ‘seed’
[13:23:09.095]   - Field: ‘version’
[13:23:09.096]   - Field: ‘result’
[13:23:09.096]   - Field: ‘asynchronous’
[13:23:09.096]   - Field: ‘calls’
[13:23:09.096]   - Field: ‘globals’
[13:23:09.096]   - Field: ‘stdout’
[13:23:09.096]   - Field: ‘earlySignal’
[13:23:09.096]   - Field: ‘lazy’
[13:23:09.096]   - Field: ‘state’
[13:23:09.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:09.096] - Launch lazy future ...
[13:23:09.097] Packages needed by the future expression (n = 0): <none>
[13:23:09.097] Packages needed by future strategies (n = 0): <none>
[13:23:09.097] {
[13:23:09.097]     {
[13:23:09.097]         {
[13:23:09.097]             ...future.startTime <- base::Sys.time()
[13:23:09.097]             {
[13:23:09.097]                 {
[13:23:09.097]                   {
[13:23:09.097]                     {
[13:23:09.097]                       base::local({
[13:23:09.097]                         has_future <- base::requireNamespace("future", 
[13:23:09.097]                           quietly = TRUE)
[13:23:09.097]                         if (has_future) {
[13:23:09.097]                           ns <- base::getNamespace("future")
[13:23:09.097]                           version <- ns[[".package"]][["version"]]
[13:23:09.097]                           if (is.null(version)) 
[13:23:09.097]                             version <- utils::packageVersion("future")
[13:23:09.097]                         }
[13:23:09.097]                         else {
[13:23:09.097]                           version <- NULL
[13:23:09.097]                         }
[13:23:09.097]                         if (!has_future || version < "1.8.0") {
[13:23:09.097]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.097]                             "", base::R.version$version.string), 
[13:23:09.097]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.097]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.097]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.097]                               "release", "version")], collapse = " "), 
[13:23:09.097]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.097]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.097]                             info)
[13:23:09.097]                           info <- base::paste(info, collapse = "; ")
[13:23:09.097]                           if (!has_future) {
[13:23:09.097]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.097]                               info)
[13:23:09.097]                           }
[13:23:09.097]                           else {
[13:23:09.097]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.097]                               info, version)
[13:23:09.097]                           }
[13:23:09.097]                           base::stop(msg)
[13:23:09.097]                         }
[13:23:09.097]                       })
[13:23:09.097]                     }
[13:23:09.097]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.097]                     base::options(mc.cores = 1L)
[13:23:09.097]                   }
[13:23:09.097]                   options(future.plan = NULL)
[13:23:09.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.097]                 }
[13:23:09.097]                 ...future.workdir <- getwd()
[13:23:09.097]             }
[13:23:09.097]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.097]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.097]         }
[13:23:09.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.097]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.097]             base::names(...future.oldOptions))
[13:23:09.097]     }
[13:23:09.097]     if (FALSE) {
[13:23:09.097]     }
[13:23:09.097]     else {
[13:23:09.097]         if (TRUE) {
[13:23:09.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.097]                 open = "w")
[13:23:09.097]         }
[13:23:09.097]         else {
[13:23:09.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.097]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.097]         }
[13:23:09.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.097]             base::sink(type = "output", split = FALSE)
[13:23:09.097]             base::close(...future.stdout)
[13:23:09.097]         }, add = TRUE)
[13:23:09.097]     }
[13:23:09.097]     ...future.frame <- base::sys.nframe()
[13:23:09.097]     ...future.conditions <- base::list()
[13:23:09.097]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.097]     if (FALSE) {
[13:23:09.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.097]     }
[13:23:09.097]     ...future.result <- base::tryCatch({
[13:23:09.097]         base::withCallingHandlers({
[13:23:09.097]             ...future.value <- base::withVisible(base::local({
[13:23:09.097]                 ...future.makeSendCondition <- base::local({
[13:23:09.097]                   sendCondition <- NULL
[13:23:09.097]                   function(frame = 1L) {
[13:23:09.097]                     if (is.function(sendCondition)) 
[13:23:09.097]                       return(sendCondition)
[13:23:09.097]                     ns <- getNamespace("parallel")
[13:23:09.097]                     if (exists("sendData", mode = "function", 
[13:23:09.097]                       envir = ns)) {
[13:23:09.097]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:09.097]                         envir = ns)
[13:23:09.097]                       envir <- sys.frame(frame)
[13:23:09.097]                       master <- NULL
[13:23:09.097]                       while (!identical(envir, .GlobalEnv) && 
[13:23:09.097]                         !identical(envir, emptyenv())) {
[13:23:09.097]                         if (exists("master", mode = "list", envir = envir, 
[13:23:09.097]                           inherits = FALSE)) {
[13:23:09.097]                           master <- get("master", mode = "list", 
[13:23:09.097]                             envir = envir, inherits = FALSE)
[13:23:09.097]                           if (inherits(master, c("SOCKnode", 
[13:23:09.097]                             "SOCK0node"))) {
[13:23:09.097]                             sendCondition <<- function(cond) {
[13:23:09.097]                               data <- list(type = "VALUE", value = cond, 
[13:23:09.097]                                 success = TRUE)
[13:23:09.097]                               parallel_sendData(master, data)
[13:23:09.097]                             }
[13:23:09.097]                             return(sendCondition)
[13:23:09.097]                           }
[13:23:09.097]                         }
[13:23:09.097]                         frame <- frame + 1L
[13:23:09.097]                         envir <- sys.frame(frame)
[13:23:09.097]                       }
[13:23:09.097]                     }
[13:23:09.097]                     sendCondition <<- function(cond) NULL
[13:23:09.097]                   }
[13:23:09.097]                 })
[13:23:09.097]                 withCallingHandlers({
[13:23:09.097]                   {
[13:23:09.097]                     4
[13:23:09.097]                   }
[13:23:09.097]                 }, immediateCondition = function(cond) {
[13:23:09.097]                   sendCondition <- ...future.makeSendCondition()
[13:23:09.097]                   sendCondition(cond)
[13:23:09.097]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.097]                   {
[13:23:09.097]                     inherits <- base::inherits
[13:23:09.097]                     invokeRestart <- base::invokeRestart
[13:23:09.097]                     is.null <- base::is.null
[13:23:09.097]                     muffled <- FALSE
[13:23:09.097]                     if (inherits(cond, "message")) {
[13:23:09.097]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.097]                       if (muffled) 
[13:23:09.097]                         invokeRestart("muffleMessage")
[13:23:09.097]                     }
[13:23:09.097]                     else if (inherits(cond, "warning")) {
[13:23:09.097]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.097]                       if (muffled) 
[13:23:09.097]                         invokeRestart("muffleWarning")
[13:23:09.097]                     }
[13:23:09.097]                     else if (inherits(cond, "condition")) {
[13:23:09.097]                       if (!is.null(pattern)) {
[13:23:09.097]                         computeRestarts <- base::computeRestarts
[13:23:09.097]                         grepl <- base::grepl
[13:23:09.097]                         restarts <- computeRestarts(cond)
[13:23:09.097]                         for (restart in restarts) {
[13:23:09.097]                           name <- restart$name
[13:23:09.097]                           if (is.null(name)) 
[13:23:09.097]                             next
[13:23:09.097]                           if (!grepl(pattern, name)) 
[13:23:09.097]                             next
[13:23:09.097]                           invokeRestart(restart)
[13:23:09.097]                           muffled <- TRUE
[13:23:09.097]                           break
[13:23:09.097]                         }
[13:23:09.097]                       }
[13:23:09.097]                     }
[13:23:09.097]                     invisible(muffled)
[13:23:09.097]                   }
[13:23:09.097]                   muffleCondition(cond)
[13:23:09.097]                 })
[13:23:09.097]             }))
[13:23:09.097]             future::FutureResult(value = ...future.value$value, 
[13:23:09.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.097]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.097]                     ...future.globalenv.names))
[13:23:09.097]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.097]         }, condition = base::local({
[13:23:09.097]             c <- base::c
[13:23:09.097]             inherits <- base::inherits
[13:23:09.097]             invokeRestart <- base::invokeRestart
[13:23:09.097]             length <- base::length
[13:23:09.097]             list <- base::list
[13:23:09.097]             seq.int <- base::seq.int
[13:23:09.097]             signalCondition <- base::signalCondition
[13:23:09.097]             sys.calls <- base::sys.calls
[13:23:09.097]             `[[` <- base::`[[`
[13:23:09.097]             `+` <- base::`+`
[13:23:09.097]             `<<-` <- base::`<<-`
[13:23:09.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.097]                   3L)]
[13:23:09.097]             }
[13:23:09.097]             function(cond) {
[13:23:09.097]                 is_error <- inherits(cond, "error")
[13:23:09.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.097]                   NULL)
[13:23:09.097]                 if (is_error) {
[13:23:09.097]                   sessionInformation <- function() {
[13:23:09.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.097]                       search = base::search(), system = base::Sys.info())
[13:23:09.097]                   }
[13:23:09.097]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.097]                     cond$call), session = sessionInformation(), 
[13:23:09.097]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.097]                   signalCondition(cond)
[13:23:09.097]                 }
[13:23:09.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.097]                 "immediateCondition"))) {
[13:23:09.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.097]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.097]                   if (TRUE && !signal) {
[13:23:09.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.097]                     {
[13:23:09.097]                       inherits <- base::inherits
[13:23:09.097]                       invokeRestart <- base::invokeRestart
[13:23:09.097]                       is.null <- base::is.null
[13:23:09.097]                       muffled <- FALSE
[13:23:09.097]                       if (inherits(cond, "message")) {
[13:23:09.097]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.097]                         if (muffled) 
[13:23:09.097]                           invokeRestart("muffleMessage")
[13:23:09.097]                       }
[13:23:09.097]                       else if (inherits(cond, "warning")) {
[13:23:09.097]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.097]                         if (muffled) 
[13:23:09.097]                           invokeRestart("muffleWarning")
[13:23:09.097]                       }
[13:23:09.097]                       else if (inherits(cond, "condition")) {
[13:23:09.097]                         if (!is.null(pattern)) {
[13:23:09.097]                           computeRestarts <- base::computeRestarts
[13:23:09.097]                           grepl <- base::grepl
[13:23:09.097]                           restarts <- computeRestarts(cond)
[13:23:09.097]                           for (restart in restarts) {
[13:23:09.097]                             name <- restart$name
[13:23:09.097]                             if (is.null(name)) 
[13:23:09.097]                               next
[13:23:09.097]                             if (!grepl(pattern, name)) 
[13:23:09.097]                               next
[13:23:09.097]                             invokeRestart(restart)
[13:23:09.097]                             muffled <- TRUE
[13:23:09.097]                             break
[13:23:09.097]                           }
[13:23:09.097]                         }
[13:23:09.097]                       }
[13:23:09.097]                       invisible(muffled)
[13:23:09.097]                     }
[13:23:09.097]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.097]                   }
[13:23:09.097]                 }
[13:23:09.097]                 else {
[13:23:09.097]                   if (TRUE) {
[13:23:09.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.097]                     {
[13:23:09.097]                       inherits <- base::inherits
[13:23:09.097]                       invokeRestart <- base::invokeRestart
[13:23:09.097]                       is.null <- base::is.null
[13:23:09.097]                       muffled <- FALSE
[13:23:09.097]                       if (inherits(cond, "message")) {
[13:23:09.097]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.097]                         if (muffled) 
[13:23:09.097]                           invokeRestart("muffleMessage")
[13:23:09.097]                       }
[13:23:09.097]                       else if (inherits(cond, "warning")) {
[13:23:09.097]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.097]                         if (muffled) 
[13:23:09.097]                           invokeRestart("muffleWarning")
[13:23:09.097]                       }
[13:23:09.097]                       else if (inherits(cond, "condition")) {
[13:23:09.097]                         if (!is.null(pattern)) {
[13:23:09.097]                           computeRestarts <- base::computeRestarts
[13:23:09.097]                           grepl <- base::grepl
[13:23:09.097]                           restarts <- computeRestarts(cond)
[13:23:09.097]                           for (restart in restarts) {
[13:23:09.097]                             name <- restart$name
[13:23:09.097]                             if (is.null(name)) 
[13:23:09.097]                               next
[13:23:09.097]                             if (!grepl(pattern, name)) 
[13:23:09.097]                               next
[13:23:09.097]                             invokeRestart(restart)
[13:23:09.097]                             muffled <- TRUE
[13:23:09.097]                             break
[13:23:09.097]                           }
[13:23:09.097]                         }
[13:23:09.097]                       }
[13:23:09.097]                       invisible(muffled)
[13:23:09.097]                     }
[13:23:09.097]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.097]                   }
[13:23:09.097]                 }
[13:23:09.097]             }
[13:23:09.097]         }))
[13:23:09.097]     }, error = function(ex) {
[13:23:09.097]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.097]                 ...future.rng), started = ...future.startTime, 
[13:23:09.097]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.097]             version = "1.8"), class = "FutureResult")
[13:23:09.097]     }, finally = {
[13:23:09.097]         if (!identical(...future.workdir, getwd())) 
[13:23:09.097]             setwd(...future.workdir)
[13:23:09.097]         {
[13:23:09.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.097]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.097]             }
[13:23:09.097]             base::options(...future.oldOptions)
[13:23:09.097]             if (.Platform$OS.type == "windows") {
[13:23:09.097]                 old_names <- names(...future.oldEnvVars)
[13:23:09.097]                 envs <- base::Sys.getenv()
[13:23:09.097]                 names <- names(envs)
[13:23:09.097]                 common <- intersect(names, old_names)
[13:23:09.097]                 added <- setdiff(names, old_names)
[13:23:09.097]                 removed <- setdiff(old_names, names)
[13:23:09.097]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.097]                   envs[common]]
[13:23:09.097]                 NAMES <- toupper(changed)
[13:23:09.097]                 args <- list()
[13:23:09.097]                 for (kk in seq_along(NAMES)) {
[13:23:09.097]                   name <- changed[[kk]]
[13:23:09.097]                   NAME <- NAMES[[kk]]
[13:23:09.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.097]                     next
[13:23:09.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.097]                 }
[13:23:09.097]                 NAMES <- toupper(added)
[13:23:09.097]                 for (kk in seq_along(NAMES)) {
[13:23:09.097]                   name <- added[[kk]]
[13:23:09.097]                   NAME <- NAMES[[kk]]
[13:23:09.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.097]                     next
[13:23:09.097]                   args[[name]] <- ""
[13:23:09.097]                 }
[13:23:09.097]                 NAMES <- toupper(removed)
[13:23:09.097]                 for (kk in seq_along(NAMES)) {
[13:23:09.097]                   name <- removed[[kk]]
[13:23:09.097]                   NAME <- NAMES[[kk]]
[13:23:09.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.097]                     next
[13:23:09.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.097]                 }
[13:23:09.097]                 if (length(args) > 0) 
[13:23:09.097]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.097]             }
[13:23:09.097]             else {
[13:23:09.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.097]             }
[13:23:09.097]             {
[13:23:09.097]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.097]                   0L) {
[13:23:09.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.097]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.097]                   base::options(opts)
[13:23:09.097]                 }
[13:23:09.097]                 {
[13:23:09.097]                   {
[13:23:09.097]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.097]                     NULL
[13:23:09.097]                   }
[13:23:09.097]                   options(future.plan = NULL)
[13:23:09.097]                   if (is.na(NA_character_)) 
[13:23:09.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.097]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:09.097]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:09.097]                     envir = parent.frame()) 
[13:23:09.097]                   {
[13:23:09.097]                     if (is.function(workers)) 
[13:23:09.097]                       workers <- workers()
[13:23:09.097]                     workers <- structure(as.integer(workers), 
[13:23:09.097]                       class = class(workers))
[13:23:09.097]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:09.097]                       workers >= 1)
[13:23:09.097]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:09.097]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:09.097]                     }
[13:23:09.097]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:09.097]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:09.097]                       envir = envir)
[13:23:09.097]                     if (!future$lazy) 
[13:23:09.097]                       future <- run(future)
[13:23:09.097]                     invisible(future)
[13:23:09.097]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.097]                 }
[13:23:09.097]             }
[13:23:09.097]         }
[13:23:09.097]     })
[13:23:09.097]     if (TRUE) {
[13:23:09.097]         base::sink(type = "output", split = FALSE)
[13:23:09.097]         if (TRUE) {
[13:23:09.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.097]         }
[13:23:09.097]         else {
[13:23:09.097]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.097]         }
[13:23:09.097]         base::close(...future.stdout)
[13:23:09.097]         ...future.stdout <- NULL
[13:23:09.097]     }
[13:23:09.097]     ...future.result$conditions <- ...future.conditions
[13:23:09.097]     ...future.result$finished <- base::Sys.time()
[13:23:09.097]     ...future.result
[13:23:09.097] }
[13:23:09.100] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:09.111] receiveMessageFromWorker() for ClusterFuture ...
[13:23:09.111] - Validating connection of MultisessionFuture
[13:23:09.111] - received message: FutureResult
[13:23:09.111] - Received FutureResult
[13:23:09.111] - Erased future from FutureRegistry
[13:23:09.112] result() for ClusterFuture ...
[13:23:09.112] - result already collected: FutureResult
[13:23:09.112] result() for ClusterFuture ... done
[13:23:09.112] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:09.112] result() for ClusterFuture ...
[13:23:09.112] - result already collected: FutureResult
[13:23:09.112] result() for ClusterFuture ... done
[13:23:09.112] result() for ClusterFuture ...
[13:23:09.112] - result already collected: FutureResult
[13:23:09.112] result() for ClusterFuture ... done
[13:23:09.114] MultisessionFuture started
[13:23:09.114] - Launch lazy future ... done
[13:23:09.114] run() for ‘MultisessionFuture’ ... done
<environment: 0x5596d382b6d8> 
<environment: 0x5596d6eceb90> 
[13:23:09.125] receiveMessageFromWorker() for ClusterFuture ...
[13:23:09.126] - Validating connection of MultisessionFuture
[13:23:09.126] - received message: FutureResult
[13:23:09.126] - Received FutureResult
[13:23:09.126] - Erased future from FutureRegistry
[13:23:09.126] result() for ClusterFuture ...
[13:23:09.126] - result already collected: FutureResult
[13:23:09.126] result() for ClusterFuture ... done
[13:23:09.126] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:09.138] resolve() on environment ...
[13:23:09.139]  recursive: 0
[13:23:09.139]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:09.139] signalConditionsASAP(numeric, pos=1) ...
[13:23:09.139] - nx: 4
[13:23:09.139] - relay: TRUE
[13:23:09.139] - stdout: TRUE
[13:23:09.140] - signal: TRUE
[13:23:09.140] - resignal: FALSE
[13:23:09.140] - force: TRUE
[13:23:09.140] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:09.140] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:09.140]  - until=2
[13:23:09.140]  - relaying element #2
[13:23:09.140] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:09.140] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:09.140] signalConditionsASAP(NULL, pos=1) ... done
[13:23:09.140]  length: 3 (resolved future 1)
[13:23:09.141] Future #2
[13:23:09.141] result() for ClusterFuture ...
[13:23:09.141] - result already collected: FutureResult
[13:23:09.141] result() for ClusterFuture ... done
[13:23:09.141] result() for ClusterFuture ...
[13:23:09.141] - result already collected: FutureResult
[13:23:09.141] result() for ClusterFuture ... done
[13:23:09.141] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:09.141] - nx: 4
[13:23:09.141] - relay: TRUE
[13:23:09.142] - stdout: TRUE
[13:23:09.142] - signal: TRUE
[13:23:09.142] - resignal: FALSE
[13:23:09.142] - force: TRUE
[13:23:09.142] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:09.142] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:09.142]  - until=2
[13:23:09.142]  - relaying element #2
[13:23:09.142] result() for ClusterFuture ...
[13:23:09.142] - result already collected: FutureResult
[13:23:09.142] result() for ClusterFuture ... done
[13:23:09.142] result() for ClusterFuture ...
[13:23:09.143] - result already collected: FutureResult
[13:23:09.143] result() for ClusterFuture ... done
[13:23:09.143] result() for ClusterFuture ...
[13:23:09.143] - result already collected: FutureResult
[13:23:09.143] result() for ClusterFuture ... done
[13:23:09.143] result() for ClusterFuture ...
[13:23:09.143] - result already collected: FutureResult
[13:23:09.143] result() for ClusterFuture ... done
[13:23:09.143] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:09.143] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:09.143] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:09.144]  length: 2 (resolved future 2)
[13:23:09.144] Future #3
[13:23:09.144] result() for ClusterFuture ...
[13:23:09.144] - result already collected: FutureResult
[13:23:09.144] result() for ClusterFuture ... done
[13:23:09.144] result() for ClusterFuture ...
[13:23:09.144] - result already collected: FutureResult
[13:23:09.144] result() for ClusterFuture ... done
[13:23:09.144] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:09.144] - nx: 4
[13:23:09.145] - relay: TRUE
[13:23:09.145] - stdout: TRUE
[13:23:09.145] - signal: TRUE
[13:23:09.145] - resignal: FALSE
[13:23:09.145] - force: TRUE
[13:23:09.145] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:09.145] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:09.145]  - until=3
[13:23:09.145]  - relaying element #3
[13:23:09.145] result() for ClusterFuture ...
[13:23:09.145] - result already collected: FutureResult
[13:23:09.146] result() for ClusterFuture ... done
[13:23:09.146] result() for ClusterFuture ...
[13:23:09.146] - result already collected: FutureResult
[13:23:09.146] result() for ClusterFuture ... done
[13:23:09.146] result() for ClusterFuture ...
[13:23:09.146] - result already collected: FutureResult
[13:23:09.146] result() for ClusterFuture ... done
[13:23:09.146] result() for ClusterFuture ...
[13:23:09.146] - result already collected: FutureResult
[13:23:09.146] result() for ClusterFuture ... done
[13:23:09.146] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:09.147] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:09.147] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:09.147]  length: 1 (resolved future 3)
[13:23:09.168] receiveMessageFromWorker() for ClusterFuture ...
[13:23:09.168] - Validating connection of MultisessionFuture
[13:23:09.169] - received message: FutureResult
[13:23:09.169] - Received FutureResult
[13:23:09.169] - Erased future from FutureRegistry
[13:23:09.169] result() for ClusterFuture ...
[13:23:09.169] - result already collected: FutureResult
[13:23:09.169] result() for ClusterFuture ... done
[13:23:09.169] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:09.169] Future #4
[13:23:09.169] result() for ClusterFuture ...
[13:23:09.170] - result already collected: FutureResult
[13:23:09.170] result() for ClusterFuture ... done
[13:23:09.170] result() for ClusterFuture ...
[13:23:09.170] - result already collected: FutureResult
[13:23:09.170] result() for ClusterFuture ... done
[13:23:09.170] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:09.170] - nx: 4
[13:23:09.170] - relay: TRUE
[13:23:09.170] - stdout: TRUE
[13:23:09.170] - signal: TRUE
[13:23:09.170] - resignal: FALSE
[13:23:09.170] - force: TRUE
[13:23:09.171] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:09.171] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:09.171]  - until=4
[13:23:09.171]  - relaying element #4
[13:23:09.171] result() for ClusterFuture ...
[13:23:09.171] - result already collected: FutureResult
[13:23:09.171] result() for ClusterFuture ... done
[13:23:09.171] result() for ClusterFuture ...
[13:23:09.171] - result already collected: FutureResult
[13:23:09.171] result() for ClusterFuture ... done
[13:23:09.172] result() for ClusterFuture ...
[13:23:09.172] - result already collected: FutureResult
[13:23:09.172] result() for ClusterFuture ... done
[13:23:09.172] result() for ClusterFuture ...
[13:23:09.172] - result already collected: FutureResult
[13:23:09.172] result() for ClusterFuture ... done
[13:23:09.172] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:09.172] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:09.172] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:09.172]  length: 0 (resolved future 4)
[13:23:09.172] Relaying remaining futures
[13:23:09.173] signalConditionsASAP(NULL, pos=0) ...
[13:23:09.173] - nx: 4
[13:23:09.173] - relay: TRUE
[13:23:09.173] - stdout: TRUE
[13:23:09.173] - signal: TRUE
[13:23:09.173] - resignal: FALSE
[13:23:09.173] - force: TRUE
[13:23:09.173] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:09.176] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:09.176] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:09.176] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:09.176] signalConditionsASAP(NULL, pos=0) ... done
[13:23:09.176] resolve() on environment ... DONE
[13:23:09.177] result() for ClusterFuture ...
[13:23:09.177] - result already collected: FutureResult
[13:23:09.177] result() for ClusterFuture ... done
[13:23:09.177] result() for ClusterFuture ...
[13:23:09.177] - result already collected: FutureResult
[13:23:09.177] result() for ClusterFuture ... done
[13:23:09.177] result() for ClusterFuture ...
[13:23:09.177] - result already collected: FutureResult
[13:23:09.177] result() for ClusterFuture ... done
[13:23:09.177] result() for ClusterFuture ...
[13:23:09.178] - result already collected: FutureResult
[13:23:09.178] result() for ClusterFuture ... done
[13:23:09.178] result() for ClusterFuture ...
[13:23:09.178] - result already collected: FutureResult
[13:23:09.178] result() for ClusterFuture ... done
[13:23:09.178] result() for ClusterFuture ...
[13:23:09.178] - result already collected: FutureResult
[13:23:09.178] result() for ClusterFuture ... done
<environment: 0x5596d70d0f78> 
Dimensions: c(2, 1, 3, 1)
[13:23:09.179] getGlobalsAndPackages() ...
[13:23:09.179] Searching for globals...
[13:23:09.179] 
[13:23:09.179] Searching for globals ... DONE
[13:23:09.179] - globals: [0] <none>
[13:23:09.179] getGlobalsAndPackages() ... DONE
[13:23:09.180] run() for ‘Future’ ...
[13:23:09.180] - state: ‘created’
[13:23:09.180] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.195] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.195] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:09.195]   - Field: ‘node’
[13:23:09.195]   - Field: ‘label’
[13:23:09.195]   - Field: ‘local’
[13:23:09.195]   - Field: ‘owner’
[13:23:09.195]   - Field: ‘envir’
[13:23:09.195]   - Field: ‘workers’
[13:23:09.195]   - Field: ‘packages’
[13:23:09.196]   - Field: ‘gc’
[13:23:09.196]   - Field: ‘conditions’
[13:23:09.196]   - Field: ‘persistent’
[13:23:09.196]   - Field: ‘expr’
[13:23:09.196]   - Field: ‘uuid’
[13:23:09.196]   - Field: ‘seed’
[13:23:09.196]   - Field: ‘version’
[13:23:09.196]   - Field: ‘result’
[13:23:09.196]   - Field: ‘asynchronous’
[13:23:09.196]   - Field: ‘calls’
[13:23:09.197]   - Field: ‘globals’
[13:23:09.197]   - Field: ‘stdout’
[13:23:09.197]   - Field: ‘earlySignal’
[13:23:09.197]   - Field: ‘lazy’
[13:23:09.197]   - Field: ‘state’
[13:23:09.197] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:09.197] - Launch lazy future ...
[13:23:09.197] Packages needed by the future expression (n = 0): <none>
[13:23:09.198] Packages needed by future strategies (n = 0): <none>
[13:23:09.198] {
[13:23:09.198]     {
[13:23:09.198]         {
[13:23:09.198]             ...future.startTime <- base::Sys.time()
[13:23:09.198]             {
[13:23:09.198]                 {
[13:23:09.198]                   {
[13:23:09.198]                     {
[13:23:09.198]                       base::local({
[13:23:09.198]                         has_future <- base::requireNamespace("future", 
[13:23:09.198]                           quietly = TRUE)
[13:23:09.198]                         if (has_future) {
[13:23:09.198]                           ns <- base::getNamespace("future")
[13:23:09.198]                           version <- ns[[".package"]][["version"]]
[13:23:09.198]                           if (is.null(version)) 
[13:23:09.198]                             version <- utils::packageVersion("future")
[13:23:09.198]                         }
[13:23:09.198]                         else {
[13:23:09.198]                           version <- NULL
[13:23:09.198]                         }
[13:23:09.198]                         if (!has_future || version < "1.8.0") {
[13:23:09.198]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.198]                             "", base::R.version$version.string), 
[13:23:09.198]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.198]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.198]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.198]                               "release", "version")], collapse = " "), 
[13:23:09.198]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.198]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.198]                             info)
[13:23:09.198]                           info <- base::paste(info, collapse = "; ")
[13:23:09.198]                           if (!has_future) {
[13:23:09.198]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.198]                               info)
[13:23:09.198]                           }
[13:23:09.198]                           else {
[13:23:09.198]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.198]                               info, version)
[13:23:09.198]                           }
[13:23:09.198]                           base::stop(msg)
[13:23:09.198]                         }
[13:23:09.198]                       })
[13:23:09.198]                     }
[13:23:09.198]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.198]                     base::options(mc.cores = 1L)
[13:23:09.198]                   }
[13:23:09.198]                   options(future.plan = NULL)
[13:23:09.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.198]                 }
[13:23:09.198]                 ...future.workdir <- getwd()
[13:23:09.198]             }
[13:23:09.198]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.198]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.198]         }
[13:23:09.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.198]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.198]             base::names(...future.oldOptions))
[13:23:09.198]     }
[13:23:09.198]     if (FALSE) {
[13:23:09.198]     }
[13:23:09.198]     else {
[13:23:09.198]         if (TRUE) {
[13:23:09.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.198]                 open = "w")
[13:23:09.198]         }
[13:23:09.198]         else {
[13:23:09.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.198]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.198]         }
[13:23:09.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.198]             base::sink(type = "output", split = FALSE)
[13:23:09.198]             base::close(...future.stdout)
[13:23:09.198]         }, add = TRUE)
[13:23:09.198]     }
[13:23:09.198]     ...future.frame <- base::sys.nframe()
[13:23:09.198]     ...future.conditions <- base::list()
[13:23:09.198]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.198]     if (FALSE) {
[13:23:09.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.198]     }
[13:23:09.198]     ...future.result <- base::tryCatch({
[13:23:09.198]         base::withCallingHandlers({
[13:23:09.198]             ...future.value <- base::withVisible(base::local({
[13:23:09.198]                 ...future.makeSendCondition <- base::local({
[13:23:09.198]                   sendCondition <- NULL
[13:23:09.198]                   function(frame = 1L) {
[13:23:09.198]                     if (is.function(sendCondition)) 
[13:23:09.198]                       return(sendCondition)
[13:23:09.198]                     ns <- getNamespace("parallel")
[13:23:09.198]                     if (exists("sendData", mode = "function", 
[13:23:09.198]                       envir = ns)) {
[13:23:09.198]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:09.198]                         envir = ns)
[13:23:09.198]                       envir <- sys.frame(frame)
[13:23:09.198]                       master <- NULL
[13:23:09.198]                       while (!identical(envir, .GlobalEnv) && 
[13:23:09.198]                         !identical(envir, emptyenv())) {
[13:23:09.198]                         if (exists("master", mode = "list", envir = envir, 
[13:23:09.198]                           inherits = FALSE)) {
[13:23:09.198]                           master <- get("master", mode = "list", 
[13:23:09.198]                             envir = envir, inherits = FALSE)
[13:23:09.198]                           if (inherits(master, c("SOCKnode", 
[13:23:09.198]                             "SOCK0node"))) {
[13:23:09.198]                             sendCondition <<- function(cond) {
[13:23:09.198]                               data <- list(type = "VALUE", value = cond, 
[13:23:09.198]                                 success = TRUE)
[13:23:09.198]                               parallel_sendData(master, data)
[13:23:09.198]                             }
[13:23:09.198]                             return(sendCondition)
[13:23:09.198]                           }
[13:23:09.198]                         }
[13:23:09.198]                         frame <- frame + 1L
[13:23:09.198]                         envir <- sys.frame(frame)
[13:23:09.198]                       }
[13:23:09.198]                     }
[13:23:09.198]                     sendCondition <<- function(cond) NULL
[13:23:09.198]                   }
[13:23:09.198]                 })
[13:23:09.198]                 withCallingHandlers({
[13:23:09.198]                   2
[13:23:09.198]                 }, immediateCondition = function(cond) {
[13:23:09.198]                   sendCondition <- ...future.makeSendCondition()
[13:23:09.198]                   sendCondition(cond)
[13:23:09.198]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.198]                   {
[13:23:09.198]                     inherits <- base::inherits
[13:23:09.198]                     invokeRestart <- base::invokeRestart
[13:23:09.198]                     is.null <- base::is.null
[13:23:09.198]                     muffled <- FALSE
[13:23:09.198]                     if (inherits(cond, "message")) {
[13:23:09.198]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.198]                       if (muffled) 
[13:23:09.198]                         invokeRestart("muffleMessage")
[13:23:09.198]                     }
[13:23:09.198]                     else if (inherits(cond, "warning")) {
[13:23:09.198]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.198]                       if (muffled) 
[13:23:09.198]                         invokeRestart("muffleWarning")
[13:23:09.198]                     }
[13:23:09.198]                     else if (inherits(cond, "condition")) {
[13:23:09.198]                       if (!is.null(pattern)) {
[13:23:09.198]                         computeRestarts <- base::computeRestarts
[13:23:09.198]                         grepl <- base::grepl
[13:23:09.198]                         restarts <- computeRestarts(cond)
[13:23:09.198]                         for (restart in restarts) {
[13:23:09.198]                           name <- restart$name
[13:23:09.198]                           if (is.null(name)) 
[13:23:09.198]                             next
[13:23:09.198]                           if (!grepl(pattern, name)) 
[13:23:09.198]                             next
[13:23:09.198]                           invokeRestart(restart)
[13:23:09.198]                           muffled <- TRUE
[13:23:09.198]                           break
[13:23:09.198]                         }
[13:23:09.198]                       }
[13:23:09.198]                     }
[13:23:09.198]                     invisible(muffled)
[13:23:09.198]                   }
[13:23:09.198]                   muffleCondition(cond)
[13:23:09.198]                 })
[13:23:09.198]             }))
[13:23:09.198]             future::FutureResult(value = ...future.value$value, 
[13:23:09.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.198]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.198]                     ...future.globalenv.names))
[13:23:09.198]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.198]         }, condition = base::local({
[13:23:09.198]             c <- base::c
[13:23:09.198]             inherits <- base::inherits
[13:23:09.198]             invokeRestart <- base::invokeRestart
[13:23:09.198]             length <- base::length
[13:23:09.198]             list <- base::list
[13:23:09.198]             seq.int <- base::seq.int
[13:23:09.198]             signalCondition <- base::signalCondition
[13:23:09.198]             sys.calls <- base::sys.calls
[13:23:09.198]             `[[` <- base::`[[`
[13:23:09.198]             `+` <- base::`+`
[13:23:09.198]             `<<-` <- base::`<<-`
[13:23:09.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.198]                   3L)]
[13:23:09.198]             }
[13:23:09.198]             function(cond) {
[13:23:09.198]                 is_error <- inherits(cond, "error")
[13:23:09.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.198]                   NULL)
[13:23:09.198]                 if (is_error) {
[13:23:09.198]                   sessionInformation <- function() {
[13:23:09.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.198]                       search = base::search(), system = base::Sys.info())
[13:23:09.198]                   }
[13:23:09.198]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.198]                     cond$call), session = sessionInformation(), 
[13:23:09.198]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.198]                   signalCondition(cond)
[13:23:09.198]                 }
[13:23:09.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.198]                 "immediateCondition"))) {
[13:23:09.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.198]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.198]                   if (TRUE && !signal) {
[13:23:09.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.198]                     {
[13:23:09.198]                       inherits <- base::inherits
[13:23:09.198]                       invokeRestart <- base::invokeRestart
[13:23:09.198]                       is.null <- base::is.null
[13:23:09.198]                       muffled <- FALSE
[13:23:09.198]                       if (inherits(cond, "message")) {
[13:23:09.198]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.198]                         if (muffled) 
[13:23:09.198]                           invokeRestart("muffleMessage")
[13:23:09.198]                       }
[13:23:09.198]                       else if (inherits(cond, "warning")) {
[13:23:09.198]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.198]                         if (muffled) 
[13:23:09.198]                           invokeRestart("muffleWarning")
[13:23:09.198]                       }
[13:23:09.198]                       else if (inherits(cond, "condition")) {
[13:23:09.198]                         if (!is.null(pattern)) {
[13:23:09.198]                           computeRestarts <- base::computeRestarts
[13:23:09.198]                           grepl <- base::grepl
[13:23:09.198]                           restarts <- computeRestarts(cond)
[13:23:09.198]                           for (restart in restarts) {
[13:23:09.198]                             name <- restart$name
[13:23:09.198]                             if (is.null(name)) 
[13:23:09.198]                               next
[13:23:09.198]                             if (!grepl(pattern, name)) 
[13:23:09.198]                               next
[13:23:09.198]                             invokeRestart(restart)
[13:23:09.198]                             muffled <- TRUE
[13:23:09.198]                             break
[13:23:09.198]                           }
[13:23:09.198]                         }
[13:23:09.198]                       }
[13:23:09.198]                       invisible(muffled)
[13:23:09.198]                     }
[13:23:09.198]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.198]                   }
[13:23:09.198]                 }
[13:23:09.198]                 else {
[13:23:09.198]                   if (TRUE) {
[13:23:09.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.198]                     {
[13:23:09.198]                       inherits <- base::inherits
[13:23:09.198]                       invokeRestart <- base::invokeRestart
[13:23:09.198]                       is.null <- base::is.null
[13:23:09.198]                       muffled <- FALSE
[13:23:09.198]                       if (inherits(cond, "message")) {
[13:23:09.198]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.198]                         if (muffled) 
[13:23:09.198]                           invokeRestart("muffleMessage")
[13:23:09.198]                       }
[13:23:09.198]                       else if (inherits(cond, "warning")) {
[13:23:09.198]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.198]                         if (muffled) 
[13:23:09.198]                           invokeRestart("muffleWarning")
[13:23:09.198]                       }
[13:23:09.198]                       else if (inherits(cond, "condition")) {
[13:23:09.198]                         if (!is.null(pattern)) {
[13:23:09.198]                           computeRestarts <- base::computeRestarts
[13:23:09.198]                           grepl <- base::grepl
[13:23:09.198]                           restarts <- computeRestarts(cond)
[13:23:09.198]                           for (restart in restarts) {
[13:23:09.198]                             name <- restart$name
[13:23:09.198]                             if (is.null(name)) 
[13:23:09.198]                               next
[13:23:09.198]                             if (!grepl(pattern, name)) 
[13:23:09.198]                               next
[13:23:09.198]                             invokeRestart(restart)
[13:23:09.198]                             muffled <- TRUE
[13:23:09.198]                             break
[13:23:09.198]                           }
[13:23:09.198]                         }
[13:23:09.198]                       }
[13:23:09.198]                       invisible(muffled)
[13:23:09.198]                     }
[13:23:09.198]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.198]                   }
[13:23:09.198]                 }
[13:23:09.198]             }
[13:23:09.198]         }))
[13:23:09.198]     }, error = function(ex) {
[13:23:09.198]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.198]                 ...future.rng), started = ...future.startTime, 
[13:23:09.198]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.198]             version = "1.8"), class = "FutureResult")
[13:23:09.198]     }, finally = {
[13:23:09.198]         if (!identical(...future.workdir, getwd())) 
[13:23:09.198]             setwd(...future.workdir)
[13:23:09.198]         {
[13:23:09.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.198]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.198]             }
[13:23:09.198]             base::options(...future.oldOptions)
[13:23:09.198]             if (.Platform$OS.type == "windows") {
[13:23:09.198]                 old_names <- names(...future.oldEnvVars)
[13:23:09.198]                 envs <- base::Sys.getenv()
[13:23:09.198]                 names <- names(envs)
[13:23:09.198]                 common <- intersect(names, old_names)
[13:23:09.198]                 added <- setdiff(names, old_names)
[13:23:09.198]                 removed <- setdiff(old_names, names)
[13:23:09.198]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.198]                   envs[common]]
[13:23:09.198]                 NAMES <- toupper(changed)
[13:23:09.198]                 args <- list()
[13:23:09.198]                 for (kk in seq_along(NAMES)) {
[13:23:09.198]                   name <- changed[[kk]]
[13:23:09.198]                   NAME <- NAMES[[kk]]
[13:23:09.198]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.198]                     next
[13:23:09.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.198]                 }
[13:23:09.198]                 NAMES <- toupper(added)
[13:23:09.198]                 for (kk in seq_along(NAMES)) {
[13:23:09.198]                   name <- added[[kk]]
[13:23:09.198]                   NAME <- NAMES[[kk]]
[13:23:09.198]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.198]                     next
[13:23:09.198]                   args[[name]] <- ""
[13:23:09.198]                 }
[13:23:09.198]                 NAMES <- toupper(removed)
[13:23:09.198]                 for (kk in seq_along(NAMES)) {
[13:23:09.198]                   name <- removed[[kk]]
[13:23:09.198]                   NAME <- NAMES[[kk]]
[13:23:09.198]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.198]                     next
[13:23:09.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.198]                 }
[13:23:09.198]                 if (length(args) > 0) 
[13:23:09.198]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.198]             }
[13:23:09.198]             else {
[13:23:09.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.198]             }
[13:23:09.198]             {
[13:23:09.198]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.198]                   0L) {
[13:23:09.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.198]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.198]                   base::options(opts)
[13:23:09.198]                 }
[13:23:09.198]                 {
[13:23:09.198]                   {
[13:23:09.198]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.198]                     NULL
[13:23:09.198]                   }
[13:23:09.198]                   options(future.plan = NULL)
[13:23:09.198]                   if (is.na(NA_character_)) 
[13:23:09.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.198]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:09.198]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:09.198]                     envir = parent.frame()) 
[13:23:09.198]                   {
[13:23:09.198]                     if (is.function(workers)) 
[13:23:09.198]                       workers <- workers()
[13:23:09.198]                     workers <- structure(as.integer(workers), 
[13:23:09.198]                       class = class(workers))
[13:23:09.198]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:09.198]                       workers >= 1)
[13:23:09.198]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:09.198]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:09.198]                     }
[13:23:09.198]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:09.198]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:09.198]                       envir = envir)
[13:23:09.198]                     if (!future$lazy) 
[13:23:09.198]                       future <- run(future)
[13:23:09.198]                     invisible(future)
[13:23:09.198]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.198]                 }
[13:23:09.198]             }
[13:23:09.198]         }
[13:23:09.198]     })
[13:23:09.198]     if (TRUE) {
[13:23:09.198]         base::sink(type = "output", split = FALSE)
[13:23:09.198]         if (TRUE) {
[13:23:09.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.198]         }
[13:23:09.198]         else {
[13:23:09.198]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.198]         }
[13:23:09.198]         base::close(...future.stdout)
[13:23:09.198]         ...future.stdout <- NULL
[13:23:09.198]     }
[13:23:09.198]     ...future.result$conditions <- ...future.conditions
[13:23:09.198]     ...future.result$finished <- base::Sys.time()
[13:23:09.198]     ...future.result
[13:23:09.198] }
[13:23:09.201] MultisessionFuture started
[13:23:09.201] - Launch lazy future ... done
[13:23:09.202] run() for ‘MultisessionFuture’ ... done
[13:23:09.202] getGlobalsAndPackages() ...
[13:23:09.202] Searching for globals...
[13:23:09.202] 
[13:23:09.202] Searching for globals ... DONE
[13:23:09.202] - globals: [0] <none>
[13:23:09.202] getGlobalsAndPackages() ... DONE
[13:23:09.203] run() for ‘Future’ ...
[13:23:09.203] - state: ‘created’
[13:23:09.203] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.218] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.218] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:09.218]   - Field: ‘node’
[13:23:09.218]   - Field: ‘label’
[13:23:09.218]   - Field: ‘local’
[13:23:09.218]   - Field: ‘owner’
[13:23:09.218]   - Field: ‘envir’
[13:23:09.218]   - Field: ‘workers’
[13:23:09.219]   - Field: ‘packages’
[13:23:09.219]   - Field: ‘gc’
[13:23:09.219]   - Field: ‘conditions’
[13:23:09.219]   - Field: ‘persistent’
[13:23:09.219]   - Field: ‘expr’
[13:23:09.219]   - Field: ‘uuid’
[13:23:09.219]   - Field: ‘seed’
[13:23:09.219]   - Field: ‘version’
[13:23:09.219]   - Field: ‘result’
[13:23:09.219]   - Field: ‘asynchronous’
[13:23:09.219]   - Field: ‘calls’
[13:23:09.220]   - Field: ‘globals’
[13:23:09.220]   - Field: ‘stdout’
[13:23:09.220]   - Field: ‘earlySignal’
[13:23:09.220]   - Field: ‘lazy’
[13:23:09.220]   - Field: ‘state’
[13:23:09.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:09.220] - Launch lazy future ...
[13:23:09.221] Packages needed by the future expression (n = 0): <none>
[13:23:09.221] Packages needed by future strategies (n = 0): <none>
[13:23:09.221] {
[13:23:09.221]     {
[13:23:09.221]         {
[13:23:09.221]             ...future.startTime <- base::Sys.time()
[13:23:09.221]             {
[13:23:09.221]                 {
[13:23:09.221]                   {
[13:23:09.221]                     {
[13:23:09.221]                       base::local({
[13:23:09.221]                         has_future <- base::requireNamespace("future", 
[13:23:09.221]                           quietly = TRUE)
[13:23:09.221]                         if (has_future) {
[13:23:09.221]                           ns <- base::getNamespace("future")
[13:23:09.221]                           version <- ns[[".package"]][["version"]]
[13:23:09.221]                           if (is.null(version)) 
[13:23:09.221]                             version <- utils::packageVersion("future")
[13:23:09.221]                         }
[13:23:09.221]                         else {
[13:23:09.221]                           version <- NULL
[13:23:09.221]                         }
[13:23:09.221]                         if (!has_future || version < "1.8.0") {
[13:23:09.221]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.221]                             "", base::R.version$version.string), 
[13:23:09.221]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.221]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.221]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.221]                               "release", "version")], collapse = " "), 
[13:23:09.221]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.221]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.221]                             info)
[13:23:09.221]                           info <- base::paste(info, collapse = "; ")
[13:23:09.221]                           if (!has_future) {
[13:23:09.221]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.221]                               info)
[13:23:09.221]                           }
[13:23:09.221]                           else {
[13:23:09.221]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.221]                               info, version)
[13:23:09.221]                           }
[13:23:09.221]                           base::stop(msg)
[13:23:09.221]                         }
[13:23:09.221]                       })
[13:23:09.221]                     }
[13:23:09.221]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.221]                     base::options(mc.cores = 1L)
[13:23:09.221]                   }
[13:23:09.221]                   options(future.plan = NULL)
[13:23:09.221]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.221]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.221]                 }
[13:23:09.221]                 ...future.workdir <- getwd()
[13:23:09.221]             }
[13:23:09.221]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.221]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.221]         }
[13:23:09.221]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.221]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.221]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.221]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.221]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.221]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.221]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.221]             base::names(...future.oldOptions))
[13:23:09.221]     }
[13:23:09.221]     if (FALSE) {
[13:23:09.221]     }
[13:23:09.221]     else {
[13:23:09.221]         if (TRUE) {
[13:23:09.221]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.221]                 open = "w")
[13:23:09.221]         }
[13:23:09.221]         else {
[13:23:09.221]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.221]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.221]         }
[13:23:09.221]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.221]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.221]             base::sink(type = "output", split = FALSE)
[13:23:09.221]             base::close(...future.stdout)
[13:23:09.221]         }, add = TRUE)
[13:23:09.221]     }
[13:23:09.221]     ...future.frame <- base::sys.nframe()
[13:23:09.221]     ...future.conditions <- base::list()
[13:23:09.221]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.221]     if (FALSE) {
[13:23:09.221]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.221]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.221]     }
[13:23:09.221]     ...future.result <- base::tryCatch({
[13:23:09.221]         base::withCallingHandlers({
[13:23:09.221]             ...future.value <- base::withVisible(base::local({
[13:23:09.221]                 ...future.makeSendCondition <- base::local({
[13:23:09.221]                   sendCondition <- NULL
[13:23:09.221]                   function(frame = 1L) {
[13:23:09.221]                     if (is.function(sendCondition)) 
[13:23:09.221]                       return(sendCondition)
[13:23:09.221]                     ns <- getNamespace("parallel")
[13:23:09.221]                     if (exists("sendData", mode = "function", 
[13:23:09.221]                       envir = ns)) {
[13:23:09.221]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:09.221]                         envir = ns)
[13:23:09.221]                       envir <- sys.frame(frame)
[13:23:09.221]                       master <- NULL
[13:23:09.221]                       while (!identical(envir, .GlobalEnv) && 
[13:23:09.221]                         !identical(envir, emptyenv())) {
[13:23:09.221]                         if (exists("master", mode = "list", envir = envir, 
[13:23:09.221]                           inherits = FALSE)) {
[13:23:09.221]                           master <- get("master", mode = "list", 
[13:23:09.221]                             envir = envir, inherits = FALSE)
[13:23:09.221]                           if (inherits(master, c("SOCKnode", 
[13:23:09.221]                             "SOCK0node"))) {
[13:23:09.221]                             sendCondition <<- function(cond) {
[13:23:09.221]                               data <- list(type = "VALUE", value = cond, 
[13:23:09.221]                                 success = TRUE)
[13:23:09.221]                               parallel_sendData(master, data)
[13:23:09.221]                             }
[13:23:09.221]                             return(sendCondition)
[13:23:09.221]                           }
[13:23:09.221]                         }
[13:23:09.221]                         frame <- frame + 1L
[13:23:09.221]                         envir <- sys.frame(frame)
[13:23:09.221]                       }
[13:23:09.221]                     }
[13:23:09.221]                     sendCondition <<- function(cond) NULL
[13:23:09.221]                   }
[13:23:09.221]                 })
[13:23:09.221]                 withCallingHandlers({
[13:23:09.221]                   NULL
[13:23:09.221]                 }, immediateCondition = function(cond) {
[13:23:09.221]                   sendCondition <- ...future.makeSendCondition()
[13:23:09.221]                   sendCondition(cond)
[13:23:09.221]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.221]                   {
[13:23:09.221]                     inherits <- base::inherits
[13:23:09.221]                     invokeRestart <- base::invokeRestart
[13:23:09.221]                     is.null <- base::is.null
[13:23:09.221]                     muffled <- FALSE
[13:23:09.221]                     if (inherits(cond, "message")) {
[13:23:09.221]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.221]                       if (muffled) 
[13:23:09.221]                         invokeRestart("muffleMessage")
[13:23:09.221]                     }
[13:23:09.221]                     else if (inherits(cond, "warning")) {
[13:23:09.221]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.221]                       if (muffled) 
[13:23:09.221]                         invokeRestart("muffleWarning")
[13:23:09.221]                     }
[13:23:09.221]                     else if (inherits(cond, "condition")) {
[13:23:09.221]                       if (!is.null(pattern)) {
[13:23:09.221]                         computeRestarts <- base::computeRestarts
[13:23:09.221]                         grepl <- base::grepl
[13:23:09.221]                         restarts <- computeRestarts(cond)
[13:23:09.221]                         for (restart in restarts) {
[13:23:09.221]                           name <- restart$name
[13:23:09.221]                           if (is.null(name)) 
[13:23:09.221]                             next
[13:23:09.221]                           if (!grepl(pattern, name)) 
[13:23:09.221]                             next
[13:23:09.221]                           invokeRestart(restart)
[13:23:09.221]                           muffled <- TRUE
[13:23:09.221]                           break
[13:23:09.221]                         }
[13:23:09.221]                       }
[13:23:09.221]                     }
[13:23:09.221]                     invisible(muffled)
[13:23:09.221]                   }
[13:23:09.221]                   muffleCondition(cond)
[13:23:09.221]                 })
[13:23:09.221]             }))
[13:23:09.221]             future::FutureResult(value = ...future.value$value, 
[13:23:09.221]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.221]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.221]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.221]                     ...future.globalenv.names))
[13:23:09.221]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.221]         }, condition = base::local({
[13:23:09.221]             c <- base::c
[13:23:09.221]             inherits <- base::inherits
[13:23:09.221]             invokeRestart <- base::invokeRestart
[13:23:09.221]             length <- base::length
[13:23:09.221]             list <- base::list
[13:23:09.221]             seq.int <- base::seq.int
[13:23:09.221]             signalCondition <- base::signalCondition
[13:23:09.221]             sys.calls <- base::sys.calls
[13:23:09.221]             `[[` <- base::`[[`
[13:23:09.221]             `+` <- base::`+`
[13:23:09.221]             `<<-` <- base::`<<-`
[13:23:09.221]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.221]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.221]                   3L)]
[13:23:09.221]             }
[13:23:09.221]             function(cond) {
[13:23:09.221]                 is_error <- inherits(cond, "error")
[13:23:09.221]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.221]                   NULL)
[13:23:09.221]                 if (is_error) {
[13:23:09.221]                   sessionInformation <- function() {
[13:23:09.221]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.221]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.221]                       search = base::search(), system = base::Sys.info())
[13:23:09.221]                   }
[13:23:09.221]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.221]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.221]                     cond$call), session = sessionInformation(), 
[13:23:09.221]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.221]                   signalCondition(cond)
[13:23:09.221]                 }
[13:23:09.221]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.221]                 "immediateCondition"))) {
[13:23:09.221]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.221]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.221]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.221]                   if (TRUE && !signal) {
[13:23:09.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.221]                     {
[13:23:09.221]                       inherits <- base::inherits
[13:23:09.221]                       invokeRestart <- base::invokeRestart
[13:23:09.221]                       is.null <- base::is.null
[13:23:09.221]                       muffled <- FALSE
[13:23:09.221]                       if (inherits(cond, "message")) {
[13:23:09.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.221]                         if (muffled) 
[13:23:09.221]                           invokeRestart("muffleMessage")
[13:23:09.221]                       }
[13:23:09.221]                       else if (inherits(cond, "warning")) {
[13:23:09.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.221]                         if (muffled) 
[13:23:09.221]                           invokeRestart("muffleWarning")
[13:23:09.221]                       }
[13:23:09.221]                       else if (inherits(cond, "condition")) {
[13:23:09.221]                         if (!is.null(pattern)) {
[13:23:09.221]                           computeRestarts <- base::computeRestarts
[13:23:09.221]                           grepl <- base::grepl
[13:23:09.221]                           restarts <- computeRestarts(cond)
[13:23:09.221]                           for (restart in restarts) {
[13:23:09.221]                             name <- restart$name
[13:23:09.221]                             if (is.null(name)) 
[13:23:09.221]                               next
[13:23:09.221]                             if (!grepl(pattern, name)) 
[13:23:09.221]                               next
[13:23:09.221]                             invokeRestart(restart)
[13:23:09.221]                             muffled <- TRUE
[13:23:09.221]                             break
[13:23:09.221]                           }
[13:23:09.221]                         }
[13:23:09.221]                       }
[13:23:09.221]                       invisible(muffled)
[13:23:09.221]                     }
[13:23:09.221]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.221]                   }
[13:23:09.221]                 }
[13:23:09.221]                 else {
[13:23:09.221]                   if (TRUE) {
[13:23:09.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.221]                     {
[13:23:09.221]                       inherits <- base::inherits
[13:23:09.221]                       invokeRestart <- base::invokeRestart
[13:23:09.221]                       is.null <- base::is.null
[13:23:09.221]                       muffled <- FALSE
[13:23:09.221]                       if (inherits(cond, "message")) {
[13:23:09.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.221]                         if (muffled) 
[13:23:09.221]                           invokeRestart("muffleMessage")
[13:23:09.221]                       }
[13:23:09.221]                       else if (inherits(cond, "warning")) {
[13:23:09.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.221]                         if (muffled) 
[13:23:09.221]                           invokeRestart("muffleWarning")
[13:23:09.221]                       }
[13:23:09.221]                       else if (inherits(cond, "condition")) {
[13:23:09.221]                         if (!is.null(pattern)) {
[13:23:09.221]                           computeRestarts <- base::computeRestarts
[13:23:09.221]                           grepl <- base::grepl
[13:23:09.221]                           restarts <- computeRestarts(cond)
[13:23:09.221]                           for (restart in restarts) {
[13:23:09.221]                             name <- restart$name
[13:23:09.221]                             if (is.null(name)) 
[13:23:09.221]                               next
[13:23:09.221]                             if (!grepl(pattern, name)) 
[13:23:09.221]                               next
[13:23:09.221]                             invokeRestart(restart)
[13:23:09.221]                             muffled <- TRUE
[13:23:09.221]                             break
[13:23:09.221]                           }
[13:23:09.221]                         }
[13:23:09.221]                       }
[13:23:09.221]                       invisible(muffled)
[13:23:09.221]                     }
[13:23:09.221]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.221]                   }
[13:23:09.221]                 }
[13:23:09.221]             }
[13:23:09.221]         }))
[13:23:09.221]     }, error = function(ex) {
[13:23:09.221]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.221]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.221]                 ...future.rng), started = ...future.startTime, 
[13:23:09.221]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.221]             version = "1.8"), class = "FutureResult")
[13:23:09.221]     }, finally = {
[13:23:09.221]         if (!identical(...future.workdir, getwd())) 
[13:23:09.221]             setwd(...future.workdir)
[13:23:09.221]         {
[13:23:09.221]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.221]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.221]             }
[13:23:09.221]             base::options(...future.oldOptions)
[13:23:09.221]             if (.Platform$OS.type == "windows") {
[13:23:09.221]                 old_names <- names(...future.oldEnvVars)
[13:23:09.221]                 envs <- base::Sys.getenv()
[13:23:09.221]                 names <- names(envs)
[13:23:09.221]                 common <- intersect(names, old_names)
[13:23:09.221]                 added <- setdiff(names, old_names)
[13:23:09.221]                 removed <- setdiff(old_names, names)
[13:23:09.221]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.221]                   envs[common]]
[13:23:09.221]                 NAMES <- toupper(changed)
[13:23:09.221]                 args <- list()
[13:23:09.221]                 for (kk in seq_along(NAMES)) {
[13:23:09.221]                   name <- changed[[kk]]
[13:23:09.221]                   NAME <- NAMES[[kk]]
[13:23:09.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.221]                     next
[13:23:09.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.221]                 }
[13:23:09.221]                 NAMES <- toupper(added)
[13:23:09.221]                 for (kk in seq_along(NAMES)) {
[13:23:09.221]                   name <- added[[kk]]
[13:23:09.221]                   NAME <- NAMES[[kk]]
[13:23:09.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.221]                     next
[13:23:09.221]                   args[[name]] <- ""
[13:23:09.221]                 }
[13:23:09.221]                 NAMES <- toupper(removed)
[13:23:09.221]                 for (kk in seq_along(NAMES)) {
[13:23:09.221]                   name <- removed[[kk]]
[13:23:09.221]                   NAME <- NAMES[[kk]]
[13:23:09.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.221]                     next
[13:23:09.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.221]                 }
[13:23:09.221]                 if (length(args) > 0) 
[13:23:09.221]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.221]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.221]             }
[13:23:09.221]             else {
[13:23:09.221]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.221]             }
[13:23:09.221]             {
[13:23:09.221]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.221]                   0L) {
[13:23:09.221]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.221]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.221]                   base::options(opts)
[13:23:09.221]                 }
[13:23:09.221]                 {
[13:23:09.221]                   {
[13:23:09.221]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.221]                     NULL
[13:23:09.221]                   }
[13:23:09.221]                   options(future.plan = NULL)
[13:23:09.221]                   if (is.na(NA_character_)) 
[13:23:09.221]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.221]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.221]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:09.221]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:09.221]                     envir = parent.frame()) 
[13:23:09.221]                   {
[13:23:09.221]                     if (is.function(workers)) 
[13:23:09.221]                       workers <- workers()
[13:23:09.221]                     workers <- structure(as.integer(workers), 
[13:23:09.221]                       class = class(workers))
[13:23:09.221]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:09.221]                       workers >= 1)
[13:23:09.221]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:09.221]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:09.221]                     }
[13:23:09.221]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:09.221]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:09.221]                       envir = envir)
[13:23:09.221]                     if (!future$lazy) 
[13:23:09.221]                       future <- run(future)
[13:23:09.221]                     invisible(future)
[13:23:09.221]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.221]                 }
[13:23:09.221]             }
[13:23:09.221]         }
[13:23:09.221]     })
[13:23:09.221]     if (TRUE) {
[13:23:09.221]         base::sink(type = "output", split = FALSE)
[13:23:09.221]         if (TRUE) {
[13:23:09.221]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.221]         }
[13:23:09.221]         else {
[13:23:09.221]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.221]         }
[13:23:09.221]         base::close(...future.stdout)
[13:23:09.221]         ...future.stdout <- NULL
[13:23:09.221]     }
[13:23:09.221]     ...future.result$conditions <- ...future.conditions
[13:23:09.221]     ...future.result$finished <- base::Sys.time()
[13:23:09.221]     ...future.result
[13:23:09.221] }
[13:23:09.225] MultisessionFuture started
[13:23:09.225] - Launch lazy future ... done
[13:23:09.225] run() for ‘MultisessionFuture’ ... done
[13:23:09.225] getGlobalsAndPackages() ...
[13:23:09.225] Searching for globals...
[13:23:09.226] - globals found: [1] ‘{’
[13:23:09.226] Searching for globals ... DONE
[13:23:09.226] Resolving globals: FALSE
[13:23:09.226] 
[13:23:09.227] 
[13:23:09.227] getGlobalsAndPackages() ... DONE
[13:23:09.227] run() for ‘Future’ ...
[13:23:09.227] - state: ‘created’
[13:23:09.227] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.242] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:09.243]   - Field: ‘node’
[13:23:09.243]   - Field: ‘label’
[13:23:09.243]   - Field: ‘local’
[13:23:09.243]   - Field: ‘owner’
[13:23:09.243]   - Field: ‘envir’
[13:23:09.243]   - Field: ‘workers’
[13:23:09.243]   - Field: ‘packages’
[13:23:09.243]   - Field: ‘gc’
[13:23:09.243]   - Field: ‘conditions’
[13:23:09.243]   - Field: ‘persistent’
[13:23:09.244]   - Field: ‘expr’
[13:23:09.244]   - Field: ‘uuid’
[13:23:09.244]   - Field: ‘seed’
[13:23:09.244]   - Field: ‘version’
[13:23:09.244]   - Field: ‘result’
[13:23:09.244]   - Field: ‘asynchronous’
[13:23:09.244]   - Field: ‘calls’
[13:23:09.244]   - Field: ‘globals’
[13:23:09.244]   - Field: ‘stdout’
[13:23:09.245]   - Field: ‘earlySignal’
[13:23:09.245]   - Field: ‘lazy’
[13:23:09.245]   - Field: ‘state’
[13:23:09.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:09.245] - Launch lazy future ...
[13:23:09.245] Packages needed by the future expression (n = 0): <none>
[13:23:09.245] Packages needed by future strategies (n = 0): <none>
[13:23:09.246] {
[13:23:09.246]     {
[13:23:09.246]         {
[13:23:09.246]             ...future.startTime <- base::Sys.time()
[13:23:09.246]             {
[13:23:09.246]                 {
[13:23:09.246]                   {
[13:23:09.246]                     {
[13:23:09.246]                       base::local({
[13:23:09.246]                         has_future <- base::requireNamespace("future", 
[13:23:09.246]                           quietly = TRUE)
[13:23:09.246]                         if (has_future) {
[13:23:09.246]                           ns <- base::getNamespace("future")
[13:23:09.246]                           version <- ns[[".package"]][["version"]]
[13:23:09.246]                           if (is.null(version)) 
[13:23:09.246]                             version <- utils::packageVersion("future")
[13:23:09.246]                         }
[13:23:09.246]                         else {
[13:23:09.246]                           version <- NULL
[13:23:09.246]                         }
[13:23:09.246]                         if (!has_future || version < "1.8.0") {
[13:23:09.246]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.246]                             "", base::R.version$version.string), 
[13:23:09.246]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.246]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.246]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.246]                               "release", "version")], collapse = " "), 
[13:23:09.246]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.246]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.246]                             info)
[13:23:09.246]                           info <- base::paste(info, collapse = "; ")
[13:23:09.246]                           if (!has_future) {
[13:23:09.246]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.246]                               info)
[13:23:09.246]                           }
[13:23:09.246]                           else {
[13:23:09.246]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.246]                               info, version)
[13:23:09.246]                           }
[13:23:09.246]                           base::stop(msg)
[13:23:09.246]                         }
[13:23:09.246]                       })
[13:23:09.246]                     }
[13:23:09.246]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.246]                     base::options(mc.cores = 1L)
[13:23:09.246]                   }
[13:23:09.246]                   options(future.plan = NULL)
[13:23:09.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.246]                 }
[13:23:09.246]                 ...future.workdir <- getwd()
[13:23:09.246]             }
[13:23:09.246]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.246]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.246]         }
[13:23:09.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.246]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.246]             base::names(...future.oldOptions))
[13:23:09.246]     }
[13:23:09.246]     if (FALSE) {
[13:23:09.246]     }
[13:23:09.246]     else {
[13:23:09.246]         if (TRUE) {
[13:23:09.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.246]                 open = "w")
[13:23:09.246]         }
[13:23:09.246]         else {
[13:23:09.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.246]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.246]         }
[13:23:09.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.246]             base::sink(type = "output", split = FALSE)
[13:23:09.246]             base::close(...future.stdout)
[13:23:09.246]         }, add = TRUE)
[13:23:09.246]     }
[13:23:09.246]     ...future.frame <- base::sys.nframe()
[13:23:09.246]     ...future.conditions <- base::list()
[13:23:09.246]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.246]     if (FALSE) {
[13:23:09.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.246]     }
[13:23:09.246]     ...future.result <- base::tryCatch({
[13:23:09.246]         base::withCallingHandlers({
[13:23:09.246]             ...future.value <- base::withVisible(base::local({
[13:23:09.246]                 ...future.makeSendCondition <- base::local({
[13:23:09.246]                   sendCondition <- NULL
[13:23:09.246]                   function(frame = 1L) {
[13:23:09.246]                     if (is.function(sendCondition)) 
[13:23:09.246]                       return(sendCondition)
[13:23:09.246]                     ns <- getNamespace("parallel")
[13:23:09.246]                     if (exists("sendData", mode = "function", 
[13:23:09.246]                       envir = ns)) {
[13:23:09.246]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:09.246]                         envir = ns)
[13:23:09.246]                       envir <- sys.frame(frame)
[13:23:09.246]                       master <- NULL
[13:23:09.246]                       while (!identical(envir, .GlobalEnv) && 
[13:23:09.246]                         !identical(envir, emptyenv())) {
[13:23:09.246]                         if (exists("master", mode = "list", envir = envir, 
[13:23:09.246]                           inherits = FALSE)) {
[13:23:09.246]                           master <- get("master", mode = "list", 
[13:23:09.246]                             envir = envir, inherits = FALSE)
[13:23:09.246]                           if (inherits(master, c("SOCKnode", 
[13:23:09.246]                             "SOCK0node"))) {
[13:23:09.246]                             sendCondition <<- function(cond) {
[13:23:09.246]                               data <- list(type = "VALUE", value = cond, 
[13:23:09.246]                                 success = TRUE)
[13:23:09.246]                               parallel_sendData(master, data)
[13:23:09.246]                             }
[13:23:09.246]                             return(sendCondition)
[13:23:09.246]                           }
[13:23:09.246]                         }
[13:23:09.246]                         frame <- frame + 1L
[13:23:09.246]                         envir <- sys.frame(frame)
[13:23:09.246]                       }
[13:23:09.246]                     }
[13:23:09.246]                     sendCondition <<- function(cond) NULL
[13:23:09.246]                   }
[13:23:09.246]                 })
[13:23:09.246]                 withCallingHandlers({
[13:23:09.246]                   {
[13:23:09.246]                     4
[13:23:09.246]                   }
[13:23:09.246]                 }, immediateCondition = function(cond) {
[13:23:09.246]                   sendCondition <- ...future.makeSendCondition()
[13:23:09.246]                   sendCondition(cond)
[13:23:09.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.246]                   {
[13:23:09.246]                     inherits <- base::inherits
[13:23:09.246]                     invokeRestart <- base::invokeRestart
[13:23:09.246]                     is.null <- base::is.null
[13:23:09.246]                     muffled <- FALSE
[13:23:09.246]                     if (inherits(cond, "message")) {
[13:23:09.246]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.246]                       if (muffled) 
[13:23:09.246]                         invokeRestart("muffleMessage")
[13:23:09.246]                     }
[13:23:09.246]                     else if (inherits(cond, "warning")) {
[13:23:09.246]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.246]                       if (muffled) 
[13:23:09.246]                         invokeRestart("muffleWarning")
[13:23:09.246]                     }
[13:23:09.246]                     else if (inherits(cond, "condition")) {
[13:23:09.246]                       if (!is.null(pattern)) {
[13:23:09.246]                         computeRestarts <- base::computeRestarts
[13:23:09.246]                         grepl <- base::grepl
[13:23:09.246]                         restarts <- computeRestarts(cond)
[13:23:09.246]                         for (restart in restarts) {
[13:23:09.246]                           name <- restart$name
[13:23:09.246]                           if (is.null(name)) 
[13:23:09.246]                             next
[13:23:09.246]                           if (!grepl(pattern, name)) 
[13:23:09.246]                             next
[13:23:09.246]                           invokeRestart(restart)
[13:23:09.246]                           muffled <- TRUE
[13:23:09.246]                           break
[13:23:09.246]                         }
[13:23:09.246]                       }
[13:23:09.246]                     }
[13:23:09.246]                     invisible(muffled)
[13:23:09.246]                   }
[13:23:09.246]                   muffleCondition(cond)
[13:23:09.246]                 })
[13:23:09.246]             }))
[13:23:09.246]             future::FutureResult(value = ...future.value$value, 
[13:23:09.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.246]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.246]                     ...future.globalenv.names))
[13:23:09.246]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.246]         }, condition = base::local({
[13:23:09.246]             c <- base::c
[13:23:09.246]             inherits <- base::inherits
[13:23:09.246]             invokeRestart <- base::invokeRestart
[13:23:09.246]             length <- base::length
[13:23:09.246]             list <- base::list
[13:23:09.246]             seq.int <- base::seq.int
[13:23:09.246]             signalCondition <- base::signalCondition
[13:23:09.246]             sys.calls <- base::sys.calls
[13:23:09.246]             `[[` <- base::`[[`
[13:23:09.246]             `+` <- base::`+`
[13:23:09.246]             `<<-` <- base::`<<-`
[13:23:09.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.246]                   3L)]
[13:23:09.246]             }
[13:23:09.246]             function(cond) {
[13:23:09.246]                 is_error <- inherits(cond, "error")
[13:23:09.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.246]                   NULL)
[13:23:09.246]                 if (is_error) {
[13:23:09.246]                   sessionInformation <- function() {
[13:23:09.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.246]                       search = base::search(), system = base::Sys.info())
[13:23:09.246]                   }
[13:23:09.246]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.246]                     cond$call), session = sessionInformation(), 
[13:23:09.246]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.246]                   signalCondition(cond)
[13:23:09.246]                 }
[13:23:09.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.246]                 "immediateCondition"))) {
[13:23:09.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.246]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.246]                   if (TRUE && !signal) {
[13:23:09.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.246]                     {
[13:23:09.246]                       inherits <- base::inherits
[13:23:09.246]                       invokeRestart <- base::invokeRestart
[13:23:09.246]                       is.null <- base::is.null
[13:23:09.246]                       muffled <- FALSE
[13:23:09.246]                       if (inherits(cond, "message")) {
[13:23:09.246]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.246]                         if (muffled) 
[13:23:09.246]                           invokeRestart("muffleMessage")
[13:23:09.246]                       }
[13:23:09.246]                       else if (inherits(cond, "warning")) {
[13:23:09.246]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.246]                         if (muffled) 
[13:23:09.246]                           invokeRestart("muffleWarning")
[13:23:09.246]                       }
[13:23:09.246]                       else if (inherits(cond, "condition")) {
[13:23:09.246]                         if (!is.null(pattern)) {
[13:23:09.246]                           computeRestarts <- base::computeRestarts
[13:23:09.246]                           grepl <- base::grepl
[13:23:09.246]                           restarts <- computeRestarts(cond)
[13:23:09.246]                           for (restart in restarts) {
[13:23:09.246]                             name <- restart$name
[13:23:09.246]                             if (is.null(name)) 
[13:23:09.246]                               next
[13:23:09.246]                             if (!grepl(pattern, name)) 
[13:23:09.246]                               next
[13:23:09.246]                             invokeRestart(restart)
[13:23:09.246]                             muffled <- TRUE
[13:23:09.246]                             break
[13:23:09.246]                           }
[13:23:09.246]                         }
[13:23:09.246]                       }
[13:23:09.246]                       invisible(muffled)
[13:23:09.246]                     }
[13:23:09.246]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.246]                   }
[13:23:09.246]                 }
[13:23:09.246]                 else {
[13:23:09.246]                   if (TRUE) {
[13:23:09.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.246]                     {
[13:23:09.246]                       inherits <- base::inherits
[13:23:09.246]                       invokeRestart <- base::invokeRestart
[13:23:09.246]                       is.null <- base::is.null
[13:23:09.246]                       muffled <- FALSE
[13:23:09.246]                       if (inherits(cond, "message")) {
[13:23:09.246]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.246]                         if (muffled) 
[13:23:09.246]                           invokeRestart("muffleMessage")
[13:23:09.246]                       }
[13:23:09.246]                       else if (inherits(cond, "warning")) {
[13:23:09.246]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.246]                         if (muffled) 
[13:23:09.246]                           invokeRestart("muffleWarning")
[13:23:09.246]                       }
[13:23:09.246]                       else if (inherits(cond, "condition")) {
[13:23:09.246]                         if (!is.null(pattern)) {
[13:23:09.246]                           computeRestarts <- base::computeRestarts
[13:23:09.246]                           grepl <- base::grepl
[13:23:09.246]                           restarts <- computeRestarts(cond)
[13:23:09.246]                           for (restart in restarts) {
[13:23:09.246]                             name <- restart$name
[13:23:09.246]                             if (is.null(name)) 
[13:23:09.246]                               next
[13:23:09.246]                             if (!grepl(pattern, name)) 
[13:23:09.246]                               next
[13:23:09.246]                             invokeRestart(restart)
[13:23:09.246]                             muffled <- TRUE
[13:23:09.246]                             break
[13:23:09.246]                           }
[13:23:09.246]                         }
[13:23:09.246]                       }
[13:23:09.246]                       invisible(muffled)
[13:23:09.246]                     }
[13:23:09.246]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.246]                   }
[13:23:09.246]                 }
[13:23:09.246]             }
[13:23:09.246]         }))
[13:23:09.246]     }, error = function(ex) {
[13:23:09.246]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.246]                 ...future.rng), started = ...future.startTime, 
[13:23:09.246]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.246]             version = "1.8"), class = "FutureResult")
[13:23:09.246]     }, finally = {
[13:23:09.246]         if (!identical(...future.workdir, getwd())) 
[13:23:09.246]             setwd(...future.workdir)
[13:23:09.246]         {
[13:23:09.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.246]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.246]             }
[13:23:09.246]             base::options(...future.oldOptions)
[13:23:09.246]             if (.Platform$OS.type == "windows") {
[13:23:09.246]                 old_names <- names(...future.oldEnvVars)
[13:23:09.246]                 envs <- base::Sys.getenv()
[13:23:09.246]                 names <- names(envs)
[13:23:09.246]                 common <- intersect(names, old_names)
[13:23:09.246]                 added <- setdiff(names, old_names)
[13:23:09.246]                 removed <- setdiff(old_names, names)
[13:23:09.246]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.246]                   envs[common]]
[13:23:09.246]                 NAMES <- toupper(changed)
[13:23:09.246]                 args <- list()
[13:23:09.246]                 for (kk in seq_along(NAMES)) {
[13:23:09.246]                   name <- changed[[kk]]
[13:23:09.246]                   NAME <- NAMES[[kk]]
[13:23:09.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.246]                     next
[13:23:09.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.246]                 }
[13:23:09.246]                 NAMES <- toupper(added)
[13:23:09.246]                 for (kk in seq_along(NAMES)) {
[13:23:09.246]                   name <- added[[kk]]
[13:23:09.246]                   NAME <- NAMES[[kk]]
[13:23:09.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.246]                     next
[13:23:09.246]                   args[[name]] <- ""
[13:23:09.246]                 }
[13:23:09.246]                 NAMES <- toupper(removed)
[13:23:09.246]                 for (kk in seq_along(NAMES)) {
[13:23:09.246]                   name <- removed[[kk]]
[13:23:09.246]                   NAME <- NAMES[[kk]]
[13:23:09.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.246]                     next
[13:23:09.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.246]                 }
[13:23:09.246]                 if (length(args) > 0) 
[13:23:09.246]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.246]             }
[13:23:09.246]             else {
[13:23:09.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.246]             }
[13:23:09.246]             {
[13:23:09.246]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.246]                   0L) {
[13:23:09.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.246]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.246]                   base::options(opts)
[13:23:09.246]                 }
[13:23:09.246]                 {
[13:23:09.246]                   {
[13:23:09.246]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.246]                     NULL
[13:23:09.246]                   }
[13:23:09.246]                   options(future.plan = NULL)
[13:23:09.246]                   if (is.na(NA_character_)) 
[13:23:09.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.246]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:09.246]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:09.246]                     envir = parent.frame()) 
[13:23:09.246]                   {
[13:23:09.246]                     if (is.function(workers)) 
[13:23:09.246]                       workers <- workers()
[13:23:09.246]                     workers <- structure(as.integer(workers), 
[13:23:09.246]                       class = class(workers))
[13:23:09.246]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:09.246]                       workers >= 1)
[13:23:09.246]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:09.246]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:09.246]                     }
[13:23:09.246]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:09.246]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:09.246]                       envir = envir)
[13:23:09.246]                     if (!future$lazy) 
[13:23:09.246]                       future <- run(future)
[13:23:09.246]                     invisible(future)
[13:23:09.246]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.246]                 }
[13:23:09.246]             }
[13:23:09.246]         }
[13:23:09.246]     })
[13:23:09.246]     if (TRUE) {
[13:23:09.246]         base::sink(type = "output", split = FALSE)
[13:23:09.246]         if (TRUE) {
[13:23:09.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.246]         }
[13:23:09.246]         else {
[13:23:09.246]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.246]         }
[13:23:09.246]         base::close(...future.stdout)
[13:23:09.246]         ...future.stdout <- NULL
[13:23:09.246]     }
[13:23:09.246]     ...future.result$conditions <- ...future.conditions
[13:23:09.246]     ...future.result$finished <- base::Sys.time()
[13:23:09.246]     ...future.result
[13:23:09.246] }
[13:23:09.248] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:09.259] receiveMessageFromWorker() for ClusterFuture ...
[13:23:09.260] - Validating connection of MultisessionFuture
[13:23:09.260] - received message: FutureResult
[13:23:09.260] - Received FutureResult
[13:23:09.260] - Erased future from FutureRegistry
[13:23:09.260] result() for ClusterFuture ...
[13:23:09.260] - result already collected: FutureResult
[13:23:09.260] result() for ClusterFuture ... done
[13:23:09.260] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:09.261] result() for ClusterFuture ...
[13:23:09.261] - result already collected: FutureResult
[13:23:09.261] result() for ClusterFuture ... done
[13:23:09.261] result() for ClusterFuture ...
[13:23:09.261] - result already collected: FutureResult
[13:23:09.261] result() for ClusterFuture ... done
[13:23:09.262] MultisessionFuture started
[13:23:09.262] - Launch lazy future ... done
[13:23:09.262] run() for ‘MultisessionFuture’ ... done
<environment: 0x5596d5d9e0b8> 
<environment: 0x5596d62c6270> 
[13:23:09.273] receiveMessageFromWorker() for ClusterFuture ...
[13:23:09.273] - Validating connection of MultisessionFuture
[13:23:09.274] - received message: FutureResult
[13:23:09.274] - Received FutureResult
[13:23:09.274] - Erased future from FutureRegistry
[13:23:09.274] result() for ClusterFuture ...
[13:23:09.274] - result already collected: FutureResult
[13:23:09.274] result() for ClusterFuture ... done
[13:23:09.274] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[13:23:09.286] resolve() on environment ...
[13:23:09.287]  recursive: 0
[13:23:09.287]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[13:23:09.287] signalConditionsASAP(numeric, pos=1) ...
[13:23:09.287] - nx: 4
[13:23:09.287] - relay: TRUE
[13:23:09.288] - stdout: TRUE
[13:23:09.288] - signal: TRUE
[13:23:09.288] - resignal: FALSE
[13:23:09.288] - force: TRUE
[13:23:09.288] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:09.288] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:09.288]  - until=2
[13:23:09.288]  - relaying element #2
[13:23:09.288] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:09.288] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:09.289] signalConditionsASAP(NULL, pos=1) ... done
[13:23:09.289]  length: 3 (resolved future 1)
[13:23:09.289] Future #2
[13:23:09.289] result() for ClusterFuture ...
[13:23:09.289] - result already collected: FutureResult
[13:23:09.289] result() for ClusterFuture ... done
[13:23:09.289] result() for ClusterFuture ...
[13:23:09.289] - result already collected: FutureResult
[13:23:09.289] result() for ClusterFuture ... done
[13:23:09.289] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:09.290] - nx: 4
[13:23:09.290] - relay: TRUE
[13:23:09.290] - stdout: TRUE
[13:23:09.290] - signal: TRUE
[13:23:09.290] - resignal: FALSE
[13:23:09.290] - force: TRUE
[13:23:09.290] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[13:23:09.290] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[13:23:09.290]  - until=2
[13:23:09.290]  - relaying element #2
[13:23:09.290] result() for ClusterFuture ...
[13:23:09.290] - result already collected: FutureResult
[13:23:09.291] result() for ClusterFuture ... done
[13:23:09.291] result() for ClusterFuture ...
[13:23:09.291] - result already collected: FutureResult
[13:23:09.291] result() for ClusterFuture ... done
[13:23:09.291] result() for ClusterFuture ...
[13:23:09.291] - result already collected: FutureResult
[13:23:09.291] result() for ClusterFuture ... done
[13:23:09.291] result() for ClusterFuture ...
[13:23:09.291] - result already collected: FutureResult
[13:23:09.291] result() for ClusterFuture ... done
[13:23:09.291] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:09.292] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:09.292] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:09.292]  length: 2 (resolved future 2)
[13:23:09.292] Future #3
[13:23:09.292] result() for ClusterFuture ...
[13:23:09.292] - result already collected: FutureResult
[13:23:09.292] result() for ClusterFuture ... done
[13:23:09.292] result() for ClusterFuture ...
[13:23:09.292] - result already collected: FutureResult
[13:23:09.292] result() for ClusterFuture ... done
[13:23:09.293] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:09.293] - nx: 4
[13:23:09.293] - relay: TRUE
[13:23:09.293] - stdout: TRUE
[13:23:09.293] - signal: TRUE
[13:23:09.293] - resignal: FALSE
[13:23:09.293] - force: TRUE
[13:23:09.293] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[13:23:09.293] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[13:23:09.293]  - until=3
[13:23:09.293]  - relaying element #3
[13:23:09.294] result() for ClusterFuture ...
[13:23:09.294] - result already collected: FutureResult
[13:23:09.294] result() for ClusterFuture ... done
[13:23:09.294] result() for ClusterFuture ...
[13:23:09.294] - result already collected: FutureResult
[13:23:09.294] result() for ClusterFuture ... done
[13:23:09.294] result() for ClusterFuture ...
[13:23:09.294] - result already collected: FutureResult
[13:23:09.294] result() for ClusterFuture ... done
[13:23:09.294] result() for ClusterFuture ...
[13:23:09.294] - result already collected: FutureResult
[13:23:09.294] result() for ClusterFuture ... done
[13:23:09.295] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:09.295] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:09.295] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:09.295]  length: 1 (resolved future 3)
[13:23:09.316] receiveMessageFromWorker() for ClusterFuture ...
[13:23:09.316] - Validating connection of MultisessionFuture
[13:23:09.317] - received message: FutureResult
[13:23:09.317] - Received FutureResult
[13:23:09.317] - Erased future from FutureRegistry
[13:23:09.317] result() for ClusterFuture ...
[13:23:09.317] - result already collected: FutureResult
[13:23:09.317] result() for ClusterFuture ... done
[13:23:09.317] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:09.317] Future #4
[13:23:09.318] result() for ClusterFuture ...
[13:23:09.318] - result already collected: FutureResult
[13:23:09.318] result() for ClusterFuture ... done
[13:23:09.318] result() for ClusterFuture ...
[13:23:09.318] - result already collected: FutureResult
[13:23:09.318] result() for ClusterFuture ... done
[13:23:09.318] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:09.318] - nx: 4
[13:23:09.318] - relay: TRUE
[13:23:09.318] - stdout: TRUE
[13:23:09.318] - signal: TRUE
[13:23:09.319] - resignal: FALSE
[13:23:09.319] - force: TRUE
[13:23:09.319] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[13:23:09.319] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[13:23:09.319]  - until=4
[13:23:09.319]  - relaying element #4
[13:23:09.319] result() for ClusterFuture ...
[13:23:09.319] - result already collected: FutureResult
[13:23:09.319] result() for ClusterFuture ... done
[13:23:09.319] result() for ClusterFuture ...
[13:23:09.319] - result already collected: FutureResult
[13:23:09.320] result() for ClusterFuture ... done
[13:23:09.320] result() for ClusterFuture ...
[13:23:09.320] - result already collected: FutureResult
[13:23:09.320] result() for ClusterFuture ... done
[13:23:09.320] result() for ClusterFuture ...
[13:23:09.320] - result already collected: FutureResult
[13:23:09.320] result() for ClusterFuture ... done
[13:23:09.320] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:09.320] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:09.320] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:09.321]  length: 0 (resolved future 4)
[13:23:09.321] Relaying remaining futures
[13:23:09.321] signalConditionsASAP(NULL, pos=0) ...
[13:23:09.321] - nx: 4
[13:23:09.321] - relay: TRUE
[13:23:09.321] - stdout: TRUE
[13:23:09.321] - signal: TRUE
[13:23:09.321] - resignal: FALSE
[13:23:09.321] - force: TRUE
[13:23:09.321] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:09.321] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[13:23:09.322] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[13:23:09.322] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[13:23:09.322] signalConditionsASAP(NULL, pos=0) ... done
[13:23:09.322] resolve() on environment ... DONE
[13:23:09.322] result() for ClusterFuture ...
[13:23:09.322] - result already collected: FutureResult
[13:23:09.322] result() for ClusterFuture ... done
[13:23:09.322] result() for ClusterFuture ...
[13:23:09.322] - result already collected: FutureResult
[13:23:09.322] result() for ClusterFuture ... done
[13:23:09.322] result() for ClusterFuture ...
[13:23:09.323] - result already collected: FutureResult
[13:23:09.323] result() for ClusterFuture ... done
[13:23:09.323] result() for ClusterFuture ...
[13:23:09.323] - result already collected: FutureResult
[13:23:09.323] result() for ClusterFuture ... done
[13:23:09.323] result() for ClusterFuture ...
[13:23:09.323] - result already collected: FutureResult
[13:23:09.323] result() for ClusterFuture ... done
[13:23:09.323] result() for ClusterFuture ...
[13:23:09.323] - result already collected: FutureResult
[13:23:09.323] result() for ClusterFuture ... done
<environment: 0x5596d666e308> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[13:23:09.324] plan(): Setting new future strategy stack:
[13:23:09.324] List of future strategies:
[13:23:09.324] 1. multicore:
[13:23:09.324]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.324]    - tweaked: FALSE
[13:23:09.324]    - call: plan(strategy)
[13:23:09.329] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:23:09.330] getGlobalsAndPackages() ...
[13:23:09.330] Searching for globals...
[13:23:09.331] 
[13:23:09.331] Searching for globals ... DONE
[13:23:09.331] - globals: [0] <none>
[13:23:09.331] getGlobalsAndPackages() ... DONE
[13:23:09.331] run() for ‘Future’ ...
[13:23:09.331] - state: ‘created’
[13:23:09.332] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.336] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.337]   - Field: ‘label’
[13:23:09.337]   - Field: ‘local’
[13:23:09.337]   - Field: ‘owner’
[13:23:09.337]   - Field: ‘envir’
[13:23:09.337]   - Field: ‘workers’
[13:23:09.337]   - Field: ‘packages’
[13:23:09.337]   - Field: ‘gc’
[13:23:09.337]   - Field: ‘job’
[13:23:09.337]   - Field: ‘conditions’
[13:23:09.337]   - Field: ‘expr’
[13:23:09.338]   - Field: ‘uuid’
[13:23:09.338]   - Field: ‘seed’
[13:23:09.338]   - Field: ‘version’
[13:23:09.338]   - Field: ‘result’
[13:23:09.338]   - Field: ‘asynchronous’
[13:23:09.338]   - Field: ‘calls’
[13:23:09.338]   - Field: ‘globals’
[13:23:09.338]   - Field: ‘stdout’
[13:23:09.338]   - Field: ‘earlySignal’
[13:23:09.338]   - Field: ‘lazy’
[13:23:09.338]   - Field: ‘state’
[13:23:09.339] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.339] - Launch lazy future ...
[13:23:09.339] Packages needed by the future expression (n = 0): <none>
[13:23:09.339] Packages needed by future strategies (n = 0): <none>
[13:23:09.340] {
[13:23:09.340]     {
[13:23:09.340]         {
[13:23:09.340]             ...future.startTime <- base::Sys.time()
[13:23:09.340]             {
[13:23:09.340]                 {
[13:23:09.340]                   {
[13:23:09.340]                     {
[13:23:09.340]                       base::local({
[13:23:09.340]                         has_future <- base::requireNamespace("future", 
[13:23:09.340]                           quietly = TRUE)
[13:23:09.340]                         if (has_future) {
[13:23:09.340]                           ns <- base::getNamespace("future")
[13:23:09.340]                           version <- ns[[".package"]][["version"]]
[13:23:09.340]                           if (is.null(version)) 
[13:23:09.340]                             version <- utils::packageVersion("future")
[13:23:09.340]                         }
[13:23:09.340]                         else {
[13:23:09.340]                           version <- NULL
[13:23:09.340]                         }
[13:23:09.340]                         if (!has_future || version < "1.8.0") {
[13:23:09.340]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.340]                             "", base::R.version$version.string), 
[13:23:09.340]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.340]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.340]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.340]                               "release", "version")], collapse = " "), 
[13:23:09.340]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.340]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.340]                             info)
[13:23:09.340]                           info <- base::paste(info, collapse = "; ")
[13:23:09.340]                           if (!has_future) {
[13:23:09.340]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.340]                               info)
[13:23:09.340]                           }
[13:23:09.340]                           else {
[13:23:09.340]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.340]                               info, version)
[13:23:09.340]                           }
[13:23:09.340]                           base::stop(msg)
[13:23:09.340]                         }
[13:23:09.340]                       })
[13:23:09.340]                     }
[13:23:09.340]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.340]                     base::options(mc.cores = 1L)
[13:23:09.340]                   }
[13:23:09.340]                   options(future.plan = NULL)
[13:23:09.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.340]                 }
[13:23:09.340]                 ...future.workdir <- getwd()
[13:23:09.340]             }
[13:23:09.340]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.340]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.340]         }
[13:23:09.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.340]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.340]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.340]             base::names(...future.oldOptions))
[13:23:09.340]     }
[13:23:09.340]     if (FALSE) {
[13:23:09.340]     }
[13:23:09.340]     else {
[13:23:09.340]         if (TRUE) {
[13:23:09.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.340]                 open = "w")
[13:23:09.340]         }
[13:23:09.340]         else {
[13:23:09.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.340]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.340]         }
[13:23:09.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.340]             base::sink(type = "output", split = FALSE)
[13:23:09.340]             base::close(...future.stdout)
[13:23:09.340]         }, add = TRUE)
[13:23:09.340]     }
[13:23:09.340]     ...future.frame <- base::sys.nframe()
[13:23:09.340]     ...future.conditions <- base::list()
[13:23:09.340]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.340]     if (FALSE) {
[13:23:09.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.340]     }
[13:23:09.340]     ...future.result <- base::tryCatch({
[13:23:09.340]         base::withCallingHandlers({
[13:23:09.340]             ...future.value <- base::withVisible(base::local({
[13:23:09.340]                 withCallingHandlers({
[13:23:09.340]                   2
[13:23:09.340]                 }, immediateCondition = function(cond) {
[13:23:09.340]                   save_rds <- function (object, pathname, ...) 
[13:23:09.340]                   {
[13:23:09.340]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.340]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.340]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.340]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.340]                         fi_tmp[["mtime"]])
[13:23:09.340]                     }
[13:23:09.340]                     tryCatch({
[13:23:09.340]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.340]                     }, error = function(ex) {
[13:23:09.340]                       msg <- conditionMessage(ex)
[13:23:09.340]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.340]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.340]                         fi_tmp[["mtime"]], msg)
[13:23:09.340]                       ex$message <- msg
[13:23:09.340]                       stop(ex)
[13:23:09.340]                     })
[13:23:09.340]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.340]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.340]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.340]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.340]                       fi <- file.info(pathname)
[13:23:09.340]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.340]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.340]                         fi[["size"]], fi[["mtime"]])
[13:23:09.340]                       stop(msg)
[13:23:09.340]                     }
[13:23:09.340]                     invisible(pathname)
[13:23:09.340]                   }
[13:23:09.340]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.340]                     rootPath = tempdir()) 
[13:23:09.340]                   {
[13:23:09.340]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.340]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.340]                       tmpdir = path, fileext = ".rds")
[13:23:09.340]                     save_rds(obj, file)
[13:23:09.340]                   }
[13:23:09.340]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.340]                   {
[13:23:09.340]                     inherits <- base::inherits
[13:23:09.340]                     invokeRestart <- base::invokeRestart
[13:23:09.340]                     is.null <- base::is.null
[13:23:09.340]                     muffled <- FALSE
[13:23:09.340]                     if (inherits(cond, "message")) {
[13:23:09.340]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.340]                       if (muffled) 
[13:23:09.340]                         invokeRestart("muffleMessage")
[13:23:09.340]                     }
[13:23:09.340]                     else if (inherits(cond, "warning")) {
[13:23:09.340]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.340]                       if (muffled) 
[13:23:09.340]                         invokeRestart("muffleWarning")
[13:23:09.340]                     }
[13:23:09.340]                     else if (inherits(cond, "condition")) {
[13:23:09.340]                       if (!is.null(pattern)) {
[13:23:09.340]                         computeRestarts <- base::computeRestarts
[13:23:09.340]                         grepl <- base::grepl
[13:23:09.340]                         restarts <- computeRestarts(cond)
[13:23:09.340]                         for (restart in restarts) {
[13:23:09.340]                           name <- restart$name
[13:23:09.340]                           if (is.null(name)) 
[13:23:09.340]                             next
[13:23:09.340]                           if (!grepl(pattern, name)) 
[13:23:09.340]                             next
[13:23:09.340]                           invokeRestart(restart)
[13:23:09.340]                           muffled <- TRUE
[13:23:09.340]                           break
[13:23:09.340]                         }
[13:23:09.340]                       }
[13:23:09.340]                     }
[13:23:09.340]                     invisible(muffled)
[13:23:09.340]                   }
[13:23:09.340]                   muffleCondition(cond)
[13:23:09.340]                 })
[13:23:09.340]             }))
[13:23:09.340]             future::FutureResult(value = ...future.value$value, 
[13:23:09.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.340]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.340]                     ...future.globalenv.names))
[13:23:09.340]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.340]         }, condition = base::local({
[13:23:09.340]             c <- base::c
[13:23:09.340]             inherits <- base::inherits
[13:23:09.340]             invokeRestart <- base::invokeRestart
[13:23:09.340]             length <- base::length
[13:23:09.340]             list <- base::list
[13:23:09.340]             seq.int <- base::seq.int
[13:23:09.340]             signalCondition <- base::signalCondition
[13:23:09.340]             sys.calls <- base::sys.calls
[13:23:09.340]             `[[` <- base::`[[`
[13:23:09.340]             `+` <- base::`+`
[13:23:09.340]             `<<-` <- base::`<<-`
[13:23:09.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.340]                   3L)]
[13:23:09.340]             }
[13:23:09.340]             function(cond) {
[13:23:09.340]                 is_error <- inherits(cond, "error")
[13:23:09.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.340]                   NULL)
[13:23:09.340]                 if (is_error) {
[13:23:09.340]                   sessionInformation <- function() {
[13:23:09.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.340]                       search = base::search(), system = base::Sys.info())
[13:23:09.340]                   }
[13:23:09.340]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.340]                     cond$call), session = sessionInformation(), 
[13:23:09.340]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.340]                   signalCondition(cond)
[13:23:09.340]                 }
[13:23:09.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.340]                 "immediateCondition"))) {
[13:23:09.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.340]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.340]                   if (TRUE && !signal) {
[13:23:09.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.340]                     {
[13:23:09.340]                       inherits <- base::inherits
[13:23:09.340]                       invokeRestart <- base::invokeRestart
[13:23:09.340]                       is.null <- base::is.null
[13:23:09.340]                       muffled <- FALSE
[13:23:09.340]                       if (inherits(cond, "message")) {
[13:23:09.340]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.340]                         if (muffled) 
[13:23:09.340]                           invokeRestart("muffleMessage")
[13:23:09.340]                       }
[13:23:09.340]                       else if (inherits(cond, "warning")) {
[13:23:09.340]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.340]                         if (muffled) 
[13:23:09.340]                           invokeRestart("muffleWarning")
[13:23:09.340]                       }
[13:23:09.340]                       else if (inherits(cond, "condition")) {
[13:23:09.340]                         if (!is.null(pattern)) {
[13:23:09.340]                           computeRestarts <- base::computeRestarts
[13:23:09.340]                           grepl <- base::grepl
[13:23:09.340]                           restarts <- computeRestarts(cond)
[13:23:09.340]                           for (restart in restarts) {
[13:23:09.340]                             name <- restart$name
[13:23:09.340]                             if (is.null(name)) 
[13:23:09.340]                               next
[13:23:09.340]                             if (!grepl(pattern, name)) 
[13:23:09.340]                               next
[13:23:09.340]                             invokeRestart(restart)
[13:23:09.340]                             muffled <- TRUE
[13:23:09.340]                             break
[13:23:09.340]                           }
[13:23:09.340]                         }
[13:23:09.340]                       }
[13:23:09.340]                       invisible(muffled)
[13:23:09.340]                     }
[13:23:09.340]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.340]                   }
[13:23:09.340]                 }
[13:23:09.340]                 else {
[13:23:09.340]                   if (TRUE) {
[13:23:09.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.340]                     {
[13:23:09.340]                       inherits <- base::inherits
[13:23:09.340]                       invokeRestart <- base::invokeRestart
[13:23:09.340]                       is.null <- base::is.null
[13:23:09.340]                       muffled <- FALSE
[13:23:09.340]                       if (inherits(cond, "message")) {
[13:23:09.340]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.340]                         if (muffled) 
[13:23:09.340]                           invokeRestart("muffleMessage")
[13:23:09.340]                       }
[13:23:09.340]                       else if (inherits(cond, "warning")) {
[13:23:09.340]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.340]                         if (muffled) 
[13:23:09.340]                           invokeRestart("muffleWarning")
[13:23:09.340]                       }
[13:23:09.340]                       else if (inherits(cond, "condition")) {
[13:23:09.340]                         if (!is.null(pattern)) {
[13:23:09.340]                           computeRestarts <- base::computeRestarts
[13:23:09.340]                           grepl <- base::grepl
[13:23:09.340]                           restarts <- computeRestarts(cond)
[13:23:09.340]                           for (restart in restarts) {
[13:23:09.340]                             name <- restart$name
[13:23:09.340]                             if (is.null(name)) 
[13:23:09.340]                               next
[13:23:09.340]                             if (!grepl(pattern, name)) 
[13:23:09.340]                               next
[13:23:09.340]                             invokeRestart(restart)
[13:23:09.340]                             muffled <- TRUE
[13:23:09.340]                             break
[13:23:09.340]                           }
[13:23:09.340]                         }
[13:23:09.340]                       }
[13:23:09.340]                       invisible(muffled)
[13:23:09.340]                     }
[13:23:09.340]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.340]                   }
[13:23:09.340]                 }
[13:23:09.340]             }
[13:23:09.340]         }))
[13:23:09.340]     }, error = function(ex) {
[13:23:09.340]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.340]                 ...future.rng), started = ...future.startTime, 
[13:23:09.340]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.340]             version = "1.8"), class = "FutureResult")
[13:23:09.340]     }, finally = {
[13:23:09.340]         if (!identical(...future.workdir, getwd())) 
[13:23:09.340]             setwd(...future.workdir)
[13:23:09.340]         {
[13:23:09.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.340]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.340]             }
[13:23:09.340]             base::options(...future.oldOptions)
[13:23:09.340]             if (.Platform$OS.type == "windows") {
[13:23:09.340]                 old_names <- names(...future.oldEnvVars)
[13:23:09.340]                 envs <- base::Sys.getenv()
[13:23:09.340]                 names <- names(envs)
[13:23:09.340]                 common <- intersect(names, old_names)
[13:23:09.340]                 added <- setdiff(names, old_names)
[13:23:09.340]                 removed <- setdiff(old_names, names)
[13:23:09.340]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.340]                   envs[common]]
[13:23:09.340]                 NAMES <- toupper(changed)
[13:23:09.340]                 args <- list()
[13:23:09.340]                 for (kk in seq_along(NAMES)) {
[13:23:09.340]                   name <- changed[[kk]]
[13:23:09.340]                   NAME <- NAMES[[kk]]
[13:23:09.340]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.340]                     next
[13:23:09.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.340]                 }
[13:23:09.340]                 NAMES <- toupper(added)
[13:23:09.340]                 for (kk in seq_along(NAMES)) {
[13:23:09.340]                   name <- added[[kk]]
[13:23:09.340]                   NAME <- NAMES[[kk]]
[13:23:09.340]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.340]                     next
[13:23:09.340]                   args[[name]] <- ""
[13:23:09.340]                 }
[13:23:09.340]                 NAMES <- toupper(removed)
[13:23:09.340]                 for (kk in seq_along(NAMES)) {
[13:23:09.340]                   name <- removed[[kk]]
[13:23:09.340]                   NAME <- NAMES[[kk]]
[13:23:09.340]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.340]                     next
[13:23:09.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.340]                 }
[13:23:09.340]                 if (length(args) > 0) 
[13:23:09.340]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.340]             }
[13:23:09.340]             else {
[13:23:09.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.340]             }
[13:23:09.340]             {
[13:23:09.340]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.340]                   0L) {
[13:23:09.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.340]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.340]                   base::options(opts)
[13:23:09.340]                 }
[13:23:09.340]                 {
[13:23:09.340]                   {
[13:23:09.340]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.340]                     NULL
[13:23:09.340]                   }
[13:23:09.340]                   options(future.plan = NULL)
[13:23:09.340]                   if (is.na(NA_character_)) 
[13:23:09.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.340]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.340]                     envir = parent.frame()) 
[13:23:09.340]                   {
[13:23:09.340]                     default_workers <- missing(workers)
[13:23:09.340]                     if (is.function(workers)) 
[13:23:09.340]                       workers <- workers()
[13:23:09.340]                     workers <- structure(as.integer(workers), 
[13:23:09.340]                       class = class(workers))
[13:23:09.340]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.340]                       1L)
[13:23:09.340]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.340]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.340]                       if (default_workers) 
[13:23:09.340]                         supportsMulticore(warn = TRUE)
[13:23:09.340]                       return(sequential(..., envir = envir))
[13:23:09.340]                     }
[13:23:09.340]                     oopts <- options(mc.cores = workers)
[13:23:09.340]                     on.exit(options(oopts))
[13:23:09.340]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.340]                       envir = envir)
[13:23:09.340]                     if (!future$lazy) 
[13:23:09.340]                       future <- run(future)
[13:23:09.340]                     invisible(future)
[13:23:09.340]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.340]                 }
[13:23:09.340]             }
[13:23:09.340]         }
[13:23:09.340]     })
[13:23:09.340]     if (TRUE) {
[13:23:09.340]         base::sink(type = "output", split = FALSE)
[13:23:09.340]         if (TRUE) {
[13:23:09.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.340]         }
[13:23:09.340]         else {
[13:23:09.340]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.340]         }
[13:23:09.340]         base::close(...future.stdout)
[13:23:09.340]         ...future.stdout <- NULL
[13:23:09.340]     }
[13:23:09.340]     ...future.result$conditions <- ...future.conditions
[13:23:09.340]     ...future.result$finished <- base::Sys.time()
[13:23:09.340]     ...future.result
[13:23:09.340] }
[13:23:09.342] requestCore(): workers = 2
[13:23:09.345] MulticoreFuture started
[13:23:09.345] - Launch lazy future ... done
[13:23:09.346] run() for ‘MulticoreFuture’ ... done
[13:23:09.346] getGlobalsAndPackages() ...
[13:23:09.346] Searching for globals...
[13:23:09.346] plan(): Setting new future strategy stack:
[13:23:09.346] List of future strategies:
[13:23:09.346] 1. sequential:
[13:23:09.346]    - args: function (..., envir = parent.frame())
[13:23:09.346]    - tweaked: FALSE
[13:23:09.346]    - call: NULL
[13:23:09.347] 
[13:23:09.347] Searching for globals ... DONE
[13:23:09.347] plan(): nbrOfWorkers() = 1
[13:23:09.347] - globals: [0] <none>
[13:23:09.347] getGlobalsAndPackages() ... DONE
[13:23:09.348] run() for ‘Future’ ...
[13:23:09.348] - state: ‘created’
[13:23:09.348] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.349] plan(): Setting new future strategy stack:
[13:23:09.349] List of future strategies:
[13:23:09.349] 1. multicore:
[13:23:09.349]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.349]    - tweaked: FALSE
[13:23:09.349]    - call: plan(strategy)
[13:23:09.354] plan(): nbrOfWorkers() = 2
[13:23:09.355] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.355] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.355]   - Field: ‘label’
[13:23:09.355]   - Field: ‘local’
[13:23:09.355]   - Field: ‘owner’
[13:23:09.356]   - Field: ‘envir’
[13:23:09.356]   - Field: ‘workers’
[13:23:09.356]   - Field: ‘packages’
[13:23:09.356]   - Field: ‘gc’
[13:23:09.356]   - Field: ‘job’
[13:23:09.356]   - Field: ‘conditions’
[13:23:09.356]   - Field: ‘expr’
[13:23:09.357]   - Field: ‘uuid’
[13:23:09.357]   - Field: ‘seed’
[13:23:09.357]   - Field: ‘version’
[13:23:09.357]   - Field: ‘result’
[13:23:09.357]   - Field: ‘asynchronous’
[13:23:09.357]   - Field: ‘calls’
[13:23:09.357]   - Field: ‘globals’
[13:23:09.358]   - Field: ‘stdout’
[13:23:09.358]   - Field: ‘earlySignal’
[13:23:09.358]   - Field: ‘lazy’
[13:23:09.358]   - Field: ‘state’
[13:23:09.358] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.358] - Launch lazy future ...
[13:23:09.359] Packages needed by the future expression (n = 0): <none>
[13:23:09.359] Packages needed by future strategies (n = 0): <none>
[13:23:09.360] {
[13:23:09.360]     {
[13:23:09.360]         {
[13:23:09.360]             ...future.startTime <- base::Sys.time()
[13:23:09.360]             {
[13:23:09.360]                 {
[13:23:09.360]                   {
[13:23:09.360]                     {
[13:23:09.360]                       base::local({
[13:23:09.360]                         has_future <- base::requireNamespace("future", 
[13:23:09.360]                           quietly = TRUE)
[13:23:09.360]                         if (has_future) {
[13:23:09.360]                           ns <- base::getNamespace("future")
[13:23:09.360]                           version <- ns[[".package"]][["version"]]
[13:23:09.360]                           if (is.null(version)) 
[13:23:09.360]                             version <- utils::packageVersion("future")
[13:23:09.360]                         }
[13:23:09.360]                         else {
[13:23:09.360]                           version <- NULL
[13:23:09.360]                         }
[13:23:09.360]                         if (!has_future || version < "1.8.0") {
[13:23:09.360]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.360]                             "", base::R.version$version.string), 
[13:23:09.360]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.360]                               "release", "version")], collapse = " "), 
[13:23:09.360]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.360]                             info)
[13:23:09.360]                           info <- base::paste(info, collapse = "; ")
[13:23:09.360]                           if (!has_future) {
[13:23:09.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.360]                               info)
[13:23:09.360]                           }
[13:23:09.360]                           else {
[13:23:09.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.360]                               info, version)
[13:23:09.360]                           }
[13:23:09.360]                           base::stop(msg)
[13:23:09.360]                         }
[13:23:09.360]                       })
[13:23:09.360]                     }
[13:23:09.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.360]                     base::options(mc.cores = 1L)
[13:23:09.360]                   }
[13:23:09.360]                   options(future.plan = NULL)
[13:23:09.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.360]                 }
[13:23:09.360]                 ...future.workdir <- getwd()
[13:23:09.360]             }
[13:23:09.360]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.360]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.360]         }
[13:23:09.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.360]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.360]             base::names(...future.oldOptions))
[13:23:09.360]     }
[13:23:09.360]     if (FALSE) {
[13:23:09.360]     }
[13:23:09.360]     else {
[13:23:09.360]         if (TRUE) {
[13:23:09.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.360]                 open = "w")
[13:23:09.360]         }
[13:23:09.360]         else {
[13:23:09.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.360]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.360]         }
[13:23:09.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.360]             base::sink(type = "output", split = FALSE)
[13:23:09.360]             base::close(...future.stdout)
[13:23:09.360]         }, add = TRUE)
[13:23:09.360]     }
[13:23:09.360]     ...future.frame <- base::sys.nframe()
[13:23:09.360]     ...future.conditions <- base::list()
[13:23:09.360]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.360]     if (FALSE) {
[13:23:09.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.360]     }
[13:23:09.360]     ...future.result <- base::tryCatch({
[13:23:09.360]         base::withCallingHandlers({
[13:23:09.360]             ...future.value <- base::withVisible(base::local({
[13:23:09.360]                 withCallingHandlers({
[13:23:09.360]                   NULL
[13:23:09.360]                 }, immediateCondition = function(cond) {
[13:23:09.360]                   save_rds <- function (object, pathname, ...) 
[13:23:09.360]                   {
[13:23:09.360]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.360]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.360]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.360]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.360]                         fi_tmp[["mtime"]])
[13:23:09.360]                     }
[13:23:09.360]                     tryCatch({
[13:23:09.360]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.360]                     }, error = function(ex) {
[13:23:09.360]                       msg <- conditionMessage(ex)
[13:23:09.360]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.360]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.360]                         fi_tmp[["mtime"]], msg)
[13:23:09.360]                       ex$message <- msg
[13:23:09.360]                       stop(ex)
[13:23:09.360]                     })
[13:23:09.360]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.360]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.360]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.360]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.360]                       fi <- file.info(pathname)
[13:23:09.360]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.360]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.360]                         fi[["size"]], fi[["mtime"]])
[13:23:09.360]                       stop(msg)
[13:23:09.360]                     }
[13:23:09.360]                     invisible(pathname)
[13:23:09.360]                   }
[13:23:09.360]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.360]                     rootPath = tempdir()) 
[13:23:09.360]                   {
[13:23:09.360]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.360]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.360]                       tmpdir = path, fileext = ".rds")
[13:23:09.360]                     save_rds(obj, file)
[13:23:09.360]                   }
[13:23:09.360]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.360]                   {
[13:23:09.360]                     inherits <- base::inherits
[13:23:09.360]                     invokeRestart <- base::invokeRestart
[13:23:09.360]                     is.null <- base::is.null
[13:23:09.360]                     muffled <- FALSE
[13:23:09.360]                     if (inherits(cond, "message")) {
[13:23:09.360]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.360]                       if (muffled) 
[13:23:09.360]                         invokeRestart("muffleMessage")
[13:23:09.360]                     }
[13:23:09.360]                     else if (inherits(cond, "warning")) {
[13:23:09.360]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.360]                       if (muffled) 
[13:23:09.360]                         invokeRestart("muffleWarning")
[13:23:09.360]                     }
[13:23:09.360]                     else if (inherits(cond, "condition")) {
[13:23:09.360]                       if (!is.null(pattern)) {
[13:23:09.360]                         computeRestarts <- base::computeRestarts
[13:23:09.360]                         grepl <- base::grepl
[13:23:09.360]                         restarts <- computeRestarts(cond)
[13:23:09.360]                         for (restart in restarts) {
[13:23:09.360]                           name <- restart$name
[13:23:09.360]                           if (is.null(name)) 
[13:23:09.360]                             next
[13:23:09.360]                           if (!grepl(pattern, name)) 
[13:23:09.360]                             next
[13:23:09.360]                           invokeRestart(restart)
[13:23:09.360]                           muffled <- TRUE
[13:23:09.360]                           break
[13:23:09.360]                         }
[13:23:09.360]                       }
[13:23:09.360]                     }
[13:23:09.360]                     invisible(muffled)
[13:23:09.360]                   }
[13:23:09.360]                   muffleCondition(cond)
[13:23:09.360]                 })
[13:23:09.360]             }))
[13:23:09.360]             future::FutureResult(value = ...future.value$value, 
[13:23:09.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.360]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.360]                     ...future.globalenv.names))
[13:23:09.360]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.360]         }, condition = base::local({
[13:23:09.360]             c <- base::c
[13:23:09.360]             inherits <- base::inherits
[13:23:09.360]             invokeRestart <- base::invokeRestart
[13:23:09.360]             length <- base::length
[13:23:09.360]             list <- base::list
[13:23:09.360]             seq.int <- base::seq.int
[13:23:09.360]             signalCondition <- base::signalCondition
[13:23:09.360]             sys.calls <- base::sys.calls
[13:23:09.360]             `[[` <- base::`[[`
[13:23:09.360]             `+` <- base::`+`
[13:23:09.360]             `<<-` <- base::`<<-`
[13:23:09.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.360]                   3L)]
[13:23:09.360]             }
[13:23:09.360]             function(cond) {
[13:23:09.360]                 is_error <- inherits(cond, "error")
[13:23:09.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.360]                   NULL)
[13:23:09.360]                 if (is_error) {
[13:23:09.360]                   sessionInformation <- function() {
[13:23:09.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.360]                       search = base::search(), system = base::Sys.info())
[13:23:09.360]                   }
[13:23:09.360]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.360]                     cond$call), session = sessionInformation(), 
[13:23:09.360]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.360]                   signalCondition(cond)
[13:23:09.360]                 }
[13:23:09.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.360]                 "immediateCondition"))) {
[13:23:09.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.360]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.360]                   if (TRUE && !signal) {
[13:23:09.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.360]                     {
[13:23:09.360]                       inherits <- base::inherits
[13:23:09.360]                       invokeRestart <- base::invokeRestart
[13:23:09.360]                       is.null <- base::is.null
[13:23:09.360]                       muffled <- FALSE
[13:23:09.360]                       if (inherits(cond, "message")) {
[13:23:09.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.360]                         if (muffled) 
[13:23:09.360]                           invokeRestart("muffleMessage")
[13:23:09.360]                       }
[13:23:09.360]                       else if (inherits(cond, "warning")) {
[13:23:09.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.360]                         if (muffled) 
[13:23:09.360]                           invokeRestart("muffleWarning")
[13:23:09.360]                       }
[13:23:09.360]                       else if (inherits(cond, "condition")) {
[13:23:09.360]                         if (!is.null(pattern)) {
[13:23:09.360]                           computeRestarts <- base::computeRestarts
[13:23:09.360]                           grepl <- base::grepl
[13:23:09.360]                           restarts <- computeRestarts(cond)
[13:23:09.360]                           for (restart in restarts) {
[13:23:09.360]                             name <- restart$name
[13:23:09.360]                             if (is.null(name)) 
[13:23:09.360]                               next
[13:23:09.360]                             if (!grepl(pattern, name)) 
[13:23:09.360]                               next
[13:23:09.360]                             invokeRestart(restart)
[13:23:09.360]                             muffled <- TRUE
[13:23:09.360]                             break
[13:23:09.360]                           }
[13:23:09.360]                         }
[13:23:09.360]                       }
[13:23:09.360]                       invisible(muffled)
[13:23:09.360]                     }
[13:23:09.360]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.360]                   }
[13:23:09.360]                 }
[13:23:09.360]                 else {
[13:23:09.360]                   if (TRUE) {
[13:23:09.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.360]                     {
[13:23:09.360]                       inherits <- base::inherits
[13:23:09.360]                       invokeRestart <- base::invokeRestart
[13:23:09.360]                       is.null <- base::is.null
[13:23:09.360]                       muffled <- FALSE
[13:23:09.360]                       if (inherits(cond, "message")) {
[13:23:09.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.360]                         if (muffled) 
[13:23:09.360]                           invokeRestart("muffleMessage")
[13:23:09.360]                       }
[13:23:09.360]                       else if (inherits(cond, "warning")) {
[13:23:09.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.360]                         if (muffled) 
[13:23:09.360]                           invokeRestart("muffleWarning")
[13:23:09.360]                       }
[13:23:09.360]                       else if (inherits(cond, "condition")) {
[13:23:09.360]                         if (!is.null(pattern)) {
[13:23:09.360]                           computeRestarts <- base::computeRestarts
[13:23:09.360]                           grepl <- base::grepl
[13:23:09.360]                           restarts <- computeRestarts(cond)
[13:23:09.360]                           for (restart in restarts) {
[13:23:09.360]                             name <- restart$name
[13:23:09.360]                             if (is.null(name)) 
[13:23:09.360]                               next
[13:23:09.360]                             if (!grepl(pattern, name)) 
[13:23:09.360]                               next
[13:23:09.360]                             invokeRestart(restart)
[13:23:09.360]                             muffled <- TRUE
[13:23:09.360]                             break
[13:23:09.360]                           }
[13:23:09.360]                         }
[13:23:09.360]                       }
[13:23:09.360]                       invisible(muffled)
[13:23:09.360]                     }
[13:23:09.360]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.360]                   }
[13:23:09.360]                 }
[13:23:09.360]             }
[13:23:09.360]         }))
[13:23:09.360]     }, error = function(ex) {
[13:23:09.360]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.360]                 ...future.rng), started = ...future.startTime, 
[13:23:09.360]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.360]             version = "1.8"), class = "FutureResult")
[13:23:09.360]     }, finally = {
[13:23:09.360]         if (!identical(...future.workdir, getwd())) 
[13:23:09.360]             setwd(...future.workdir)
[13:23:09.360]         {
[13:23:09.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.360]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.360]             }
[13:23:09.360]             base::options(...future.oldOptions)
[13:23:09.360]             if (.Platform$OS.type == "windows") {
[13:23:09.360]                 old_names <- names(...future.oldEnvVars)
[13:23:09.360]                 envs <- base::Sys.getenv()
[13:23:09.360]                 names <- names(envs)
[13:23:09.360]                 common <- intersect(names, old_names)
[13:23:09.360]                 added <- setdiff(names, old_names)
[13:23:09.360]                 removed <- setdiff(old_names, names)
[13:23:09.360]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.360]                   envs[common]]
[13:23:09.360]                 NAMES <- toupper(changed)
[13:23:09.360]                 args <- list()
[13:23:09.360]                 for (kk in seq_along(NAMES)) {
[13:23:09.360]                   name <- changed[[kk]]
[13:23:09.360]                   NAME <- NAMES[[kk]]
[13:23:09.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.360]                     next
[13:23:09.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.360]                 }
[13:23:09.360]                 NAMES <- toupper(added)
[13:23:09.360]                 for (kk in seq_along(NAMES)) {
[13:23:09.360]                   name <- added[[kk]]
[13:23:09.360]                   NAME <- NAMES[[kk]]
[13:23:09.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.360]                     next
[13:23:09.360]                   args[[name]] <- ""
[13:23:09.360]                 }
[13:23:09.360]                 NAMES <- toupper(removed)
[13:23:09.360]                 for (kk in seq_along(NAMES)) {
[13:23:09.360]                   name <- removed[[kk]]
[13:23:09.360]                   NAME <- NAMES[[kk]]
[13:23:09.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.360]                     next
[13:23:09.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.360]                 }
[13:23:09.360]                 if (length(args) > 0) 
[13:23:09.360]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.360]             }
[13:23:09.360]             else {
[13:23:09.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.360]             }
[13:23:09.360]             {
[13:23:09.360]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.360]                   0L) {
[13:23:09.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.360]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.360]                   base::options(opts)
[13:23:09.360]                 }
[13:23:09.360]                 {
[13:23:09.360]                   {
[13:23:09.360]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.360]                     NULL
[13:23:09.360]                   }
[13:23:09.360]                   options(future.plan = NULL)
[13:23:09.360]                   if (is.na(NA_character_)) 
[13:23:09.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.360]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.360]                     envir = parent.frame()) 
[13:23:09.360]                   {
[13:23:09.360]                     default_workers <- missing(workers)
[13:23:09.360]                     if (is.function(workers)) 
[13:23:09.360]                       workers <- workers()
[13:23:09.360]                     workers <- structure(as.integer(workers), 
[13:23:09.360]                       class = class(workers))
[13:23:09.360]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.360]                       1L)
[13:23:09.360]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.360]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.360]                       if (default_workers) 
[13:23:09.360]                         supportsMulticore(warn = TRUE)
[13:23:09.360]                       return(sequential(..., envir = envir))
[13:23:09.360]                     }
[13:23:09.360]                     oopts <- options(mc.cores = workers)
[13:23:09.360]                     on.exit(options(oopts))
[13:23:09.360]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.360]                       envir = envir)
[13:23:09.360]                     if (!future$lazy) 
[13:23:09.360]                       future <- run(future)
[13:23:09.360]                     invisible(future)
[13:23:09.360]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.360]                 }
[13:23:09.360]             }
[13:23:09.360]         }
[13:23:09.360]     })
[13:23:09.360]     if (TRUE) {
[13:23:09.360]         base::sink(type = "output", split = FALSE)
[13:23:09.360]         if (TRUE) {
[13:23:09.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.360]         }
[13:23:09.360]         else {
[13:23:09.360]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.360]         }
[13:23:09.360]         base::close(...future.stdout)
[13:23:09.360]         ...future.stdout <- NULL
[13:23:09.360]     }
[13:23:09.360]     ...future.result$conditions <- ...future.conditions
[13:23:09.360]     ...future.result$finished <- base::Sys.time()
[13:23:09.360]     ...future.result
[13:23:09.360] }
[13:23:09.363] requestCore(): workers = 2
[13:23:09.366] MulticoreFuture started
[13:23:09.367] - Launch lazy future ... done
[13:23:09.367] run() for ‘MulticoreFuture’ ... done
[13:23:09.368] plan(): Setting new future strategy stack:
[13:23:09.368] getGlobalsAndPackages() ...
[13:23:09.368] Searching for globals...
[13:23:09.368] List of future strategies:
[13:23:09.368] 1. sequential:
[13:23:09.368]    - args: function (..., envir = parent.frame())
[13:23:09.368]    - tweaked: FALSE
[13:23:09.368]    - call: NULL
[13:23:09.369] plan(): nbrOfWorkers() = 1
[13:23:09.371] plan(): Setting new future strategy stack:
[13:23:09.378] - globals found: [1] ‘{’
[13:23:09.371] List of future strategies:
[13:23:09.371] 1. multicore:
[13:23:09.371]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.371]    - tweaked: FALSE
[13:23:09.371]    - call: plan(strategy)
[13:23:09.379] Searching for globals ... DONE
[13:23:09.379] Resolving globals: FALSE
[13:23:09.381] 
[13:23:09.381] 
[13:23:09.381] getGlobalsAndPackages() ... DONE
[13:23:09.382] run() for ‘Future’ ...
[13:23:09.382] - state: ‘created’
[13:23:09.383] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.385] plan(): nbrOfWorkers() = 2
[13:23:09.388] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.388] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.388]   - Field: ‘label’
[13:23:09.388]   - Field: ‘local’
[13:23:09.388]   - Field: ‘owner’
[13:23:09.389]   - Field: ‘envir’
[13:23:09.389]   - Field: ‘workers’
[13:23:09.389]   - Field: ‘packages’
[13:23:09.389]   - Field: ‘gc’
[13:23:09.389]   - Field: ‘job’
[13:23:09.389]   - Field: ‘conditions’
[13:23:09.389]   - Field: ‘expr’
[13:23:09.390]   - Field: ‘uuid’
[13:23:09.390]   - Field: ‘seed’
[13:23:09.390]   - Field: ‘version’
[13:23:09.390]   - Field: ‘result’
[13:23:09.390]   - Field: ‘asynchronous’
[13:23:09.390]   - Field: ‘calls’
[13:23:09.390]   - Field: ‘globals’
[13:23:09.391]   - Field: ‘stdout’
[13:23:09.391]   - Field: ‘earlySignal’
[13:23:09.391]   - Field: ‘lazy’
[13:23:09.391]   - Field: ‘state’
[13:23:09.391] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.391] - Launch lazy future ...
[13:23:09.392] Packages needed by the future expression (n = 0): <none>
[13:23:09.392] Packages needed by future strategies (n = 0): <none>
[13:23:09.393] {
[13:23:09.393]     {
[13:23:09.393]         {
[13:23:09.393]             ...future.startTime <- base::Sys.time()
[13:23:09.393]             {
[13:23:09.393]                 {
[13:23:09.393]                   {
[13:23:09.393]                     {
[13:23:09.393]                       base::local({
[13:23:09.393]                         has_future <- base::requireNamespace("future", 
[13:23:09.393]                           quietly = TRUE)
[13:23:09.393]                         if (has_future) {
[13:23:09.393]                           ns <- base::getNamespace("future")
[13:23:09.393]                           version <- ns[[".package"]][["version"]]
[13:23:09.393]                           if (is.null(version)) 
[13:23:09.393]                             version <- utils::packageVersion("future")
[13:23:09.393]                         }
[13:23:09.393]                         else {
[13:23:09.393]                           version <- NULL
[13:23:09.393]                         }
[13:23:09.393]                         if (!has_future || version < "1.8.0") {
[13:23:09.393]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.393]                             "", base::R.version$version.string), 
[13:23:09.393]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.393]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.393]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.393]                               "release", "version")], collapse = " "), 
[13:23:09.393]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.393]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.393]                             info)
[13:23:09.393]                           info <- base::paste(info, collapse = "; ")
[13:23:09.393]                           if (!has_future) {
[13:23:09.393]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.393]                               info)
[13:23:09.393]                           }
[13:23:09.393]                           else {
[13:23:09.393]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.393]                               info, version)
[13:23:09.393]                           }
[13:23:09.393]                           base::stop(msg)
[13:23:09.393]                         }
[13:23:09.393]                       })
[13:23:09.393]                     }
[13:23:09.393]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.393]                     base::options(mc.cores = 1L)
[13:23:09.393]                   }
[13:23:09.393]                   options(future.plan = NULL)
[13:23:09.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.393]                 }
[13:23:09.393]                 ...future.workdir <- getwd()
[13:23:09.393]             }
[13:23:09.393]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.393]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.393]         }
[13:23:09.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.393]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.393]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.393]             base::names(...future.oldOptions))
[13:23:09.393]     }
[13:23:09.393]     if (FALSE) {
[13:23:09.393]     }
[13:23:09.393]     else {
[13:23:09.393]         if (TRUE) {
[13:23:09.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.393]                 open = "w")
[13:23:09.393]         }
[13:23:09.393]         else {
[13:23:09.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.393]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.393]         }
[13:23:09.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.393]             base::sink(type = "output", split = FALSE)
[13:23:09.393]             base::close(...future.stdout)
[13:23:09.393]         }, add = TRUE)
[13:23:09.393]     }
[13:23:09.393]     ...future.frame <- base::sys.nframe()
[13:23:09.393]     ...future.conditions <- base::list()
[13:23:09.393]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.393]     if (FALSE) {
[13:23:09.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.393]     }
[13:23:09.393]     ...future.result <- base::tryCatch({
[13:23:09.393]         base::withCallingHandlers({
[13:23:09.393]             ...future.value <- base::withVisible(base::local({
[13:23:09.393]                 withCallingHandlers({
[13:23:09.393]                   {
[13:23:09.393]                     4
[13:23:09.393]                   }
[13:23:09.393]                 }, immediateCondition = function(cond) {
[13:23:09.393]                   save_rds <- function (object, pathname, ...) 
[13:23:09.393]                   {
[13:23:09.393]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.393]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.393]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.393]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.393]                         fi_tmp[["mtime"]])
[13:23:09.393]                     }
[13:23:09.393]                     tryCatch({
[13:23:09.393]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.393]                     }, error = function(ex) {
[13:23:09.393]                       msg <- conditionMessage(ex)
[13:23:09.393]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.393]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.393]                         fi_tmp[["mtime"]], msg)
[13:23:09.393]                       ex$message <- msg
[13:23:09.393]                       stop(ex)
[13:23:09.393]                     })
[13:23:09.393]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.393]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.393]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.393]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.393]                       fi <- file.info(pathname)
[13:23:09.393]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.393]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.393]                         fi[["size"]], fi[["mtime"]])
[13:23:09.393]                       stop(msg)
[13:23:09.393]                     }
[13:23:09.393]                     invisible(pathname)
[13:23:09.393]                   }
[13:23:09.393]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.393]                     rootPath = tempdir()) 
[13:23:09.393]                   {
[13:23:09.393]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.393]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.393]                       tmpdir = path, fileext = ".rds")
[13:23:09.393]                     save_rds(obj, file)
[13:23:09.393]                   }
[13:23:09.393]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.393]                   {
[13:23:09.393]                     inherits <- base::inherits
[13:23:09.393]                     invokeRestart <- base::invokeRestart
[13:23:09.393]                     is.null <- base::is.null
[13:23:09.393]                     muffled <- FALSE
[13:23:09.393]                     if (inherits(cond, "message")) {
[13:23:09.393]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.393]                       if (muffled) 
[13:23:09.393]                         invokeRestart("muffleMessage")
[13:23:09.393]                     }
[13:23:09.393]                     else if (inherits(cond, "warning")) {
[13:23:09.393]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.393]                       if (muffled) 
[13:23:09.393]                         invokeRestart("muffleWarning")
[13:23:09.393]                     }
[13:23:09.393]                     else if (inherits(cond, "condition")) {
[13:23:09.393]                       if (!is.null(pattern)) {
[13:23:09.393]                         computeRestarts <- base::computeRestarts
[13:23:09.393]                         grepl <- base::grepl
[13:23:09.393]                         restarts <- computeRestarts(cond)
[13:23:09.393]                         for (restart in restarts) {
[13:23:09.393]                           name <- restart$name
[13:23:09.393]                           if (is.null(name)) 
[13:23:09.393]                             next
[13:23:09.393]                           if (!grepl(pattern, name)) 
[13:23:09.393]                             next
[13:23:09.393]                           invokeRestart(restart)
[13:23:09.393]                           muffled <- TRUE
[13:23:09.393]                           break
[13:23:09.393]                         }
[13:23:09.393]                       }
[13:23:09.393]                     }
[13:23:09.393]                     invisible(muffled)
[13:23:09.393]                   }
[13:23:09.393]                   muffleCondition(cond)
[13:23:09.393]                 })
[13:23:09.393]             }))
[13:23:09.393]             future::FutureResult(value = ...future.value$value, 
[13:23:09.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.393]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.393]                     ...future.globalenv.names))
[13:23:09.393]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.393]         }, condition = base::local({
[13:23:09.393]             c <- base::c
[13:23:09.393]             inherits <- base::inherits
[13:23:09.393]             invokeRestart <- base::invokeRestart
[13:23:09.393]             length <- base::length
[13:23:09.393]             list <- base::list
[13:23:09.393]             seq.int <- base::seq.int
[13:23:09.393]             signalCondition <- base::signalCondition
[13:23:09.393]             sys.calls <- base::sys.calls
[13:23:09.393]             `[[` <- base::`[[`
[13:23:09.393]             `+` <- base::`+`
[13:23:09.393]             `<<-` <- base::`<<-`
[13:23:09.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.393]                   3L)]
[13:23:09.393]             }
[13:23:09.393]             function(cond) {
[13:23:09.393]                 is_error <- inherits(cond, "error")
[13:23:09.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.393]                   NULL)
[13:23:09.393]                 if (is_error) {
[13:23:09.393]                   sessionInformation <- function() {
[13:23:09.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.393]                       search = base::search(), system = base::Sys.info())
[13:23:09.393]                   }
[13:23:09.393]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.393]                     cond$call), session = sessionInformation(), 
[13:23:09.393]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.393]                   signalCondition(cond)
[13:23:09.393]                 }
[13:23:09.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.393]                 "immediateCondition"))) {
[13:23:09.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.393]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.393]                   if (TRUE && !signal) {
[13:23:09.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.393]                     {
[13:23:09.393]                       inherits <- base::inherits
[13:23:09.393]                       invokeRestart <- base::invokeRestart
[13:23:09.393]                       is.null <- base::is.null
[13:23:09.393]                       muffled <- FALSE
[13:23:09.393]                       if (inherits(cond, "message")) {
[13:23:09.393]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.393]                         if (muffled) 
[13:23:09.393]                           invokeRestart("muffleMessage")
[13:23:09.393]                       }
[13:23:09.393]                       else if (inherits(cond, "warning")) {
[13:23:09.393]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.393]                         if (muffled) 
[13:23:09.393]                           invokeRestart("muffleWarning")
[13:23:09.393]                       }
[13:23:09.393]                       else if (inherits(cond, "condition")) {
[13:23:09.393]                         if (!is.null(pattern)) {
[13:23:09.393]                           computeRestarts <- base::computeRestarts
[13:23:09.393]                           grepl <- base::grepl
[13:23:09.393]                           restarts <- computeRestarts(cond)
[13:23:09.393]                           for (restart in restarts) {
[13:23:09.393]                             name <- restart$name
[13:23:09.393]                             if (is.null(name)) 
[13:23:09.393]                               next
[13:23:09.393]                             if (!grepl(pattern, name)) 
[13:23:09.393]                               next
[13:23:09.393]                             invokeRestart(restart)
[13:23:09.393]                             muffled <- TRUE
[13:23:09.393]                             break
[13:23:09.393]                           }
[13:23:09.393]                         }
[13:23:09.393]                       }
[13:23:09.393]                       invisible(muffled)
[13:23:09.393]                     }
[13:23:09.393]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.393]                   }
[13:23:09.393]                 }
[13:23:09.393]                 else {
[13:23:09.393]                   if (TRUE) {
[13:23:09.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.393]                     {
[13:23:09.393]                       inherits <- base::inherits
[13:23:09.393]                       invokeRestart <- base::invokeRestart
[13:23:09.393]                       is.null <- base::is.null
[13:23:09.393]                       muffled <- FALSE
[13:23:09.393]                       if (inherits(cond, "message")) {
[13:23:09.393]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.393]                         if (muffled) 
[13:23:09.393]                           invokeRestart("muffleMessage")
[13:23:09.393]                       }
[13:23:09.393]                       else if (inherits(cond, "warning")) {
[13:23:09.393]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.393]                         if (muffled) 
[13:23:09.393]                           invokeRestart("muffleWarning")
[13:23:09.393]                       }
[13:23:09.393]                       else if (inherits(cond, "condition")) {
[13:23:09.393]                         if (!is.null(pattern)) {
[13:23:09.393]                           computeRestarts <- base::computeRestarts
[13:23:09.393]                           grepl <- base::grepl
[13:23:09.393]                           restarts <- computeRestarts(cond)
[13:23:09.393]                           for (restart in restarts) {
[13:23:09.393]                             name <- restart$name
[13:23:09.393]                             if (is.null(name)) 
[13:23:09.393]                               next
[13:23:09.393]                             if (!grepl(pattern, name)) 
[13:23:09.393]                               next
[13:23:09.393]                             invokeRestart(restart)
[13:23:09.393]                             muffled <- TRUE
[13:23:09.393]                             break
[13:23:09.393]                           }
[13:23:09.393]                         }
[13:23:09.393]                       }
[13:23:09.393]                       invisible(muffled)
[13:23:09.393]                     }
[13:23:09.393]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.393]                   }
[13:23:09.393]                 }
[13:23:09.393]             }
[13:23:09.393]         }))
[13:23:09.393]     }, error = function(ex) {
[13:23:09.393]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.393]                 ...future.rng), started = ...future.startTime, 
[13:23:09.393]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.393]             version = "1.8"), class = "FutureResult")
[13:23:09.393]     }, finally = {
[13:23:09.393]         if (!identical(...future.workdir, getwd())) 
[13:23:09.393]             setwd(...future.workdir)
[13:23:09.393]         {
[13:23:09.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.393]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.393]             }
[13:23:09.393]             base::options(...future.oldOptions)
[13:23:09.393]             if (.Platform$OS.type == "windows") {
[13:23:09.393]                 old_names <- names(...future.oldEnvVars)
[13:23:09.393]                 envs <- base::Sys.getenv()
[13:23:09.393]                 names <- names(envs)
[13:23:09.393]                 common <- intersect(names, old_names)
[13:23:09.393]                 added <- setdiff(names, old_names)
[13:23:09.393]                 removed <- setdiff(old_names, names)
[13:23:09.393]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.393]                   envs[common]]
[13:23:09.393]                 NAMES <- toupper(changed)
[13:23:09.393]                 args <- list()
[13:23:09.393]                 for (kk in seq_along(NAMES)) {
[13:23:09.393]                   name <- changed[[kk]]
[13:23:09.393]                   NAME <- NAMES[[kk]]
[13:23:09.393]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.393]                     next
[13:23:09.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.393]                 }
[13:23:09.393]                 NAMES <- toupper(added)
[13:23:09.393]                 for (kk in seq_along(NAMES)) {
[13:23:09.393]                   name <- added[[kk]]
[13:23:09.393]                   NAME <- NAMES[[kk]]
[13:23:09.393]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.393]                     next
[13:23:09.393]                   args[[name]] <- ""
[13:23:09.393]                 }
[13:23:09.393]                 NAMES <- toupper(removed)
[13:23:09.393]                 for (kk in seq_along(NAMES)) {
[13:23:09.393]                   name <- removed[[kk]]
[13:23:09.393]                   NAME <- NAMES[[kk]]
[13:23:09.393]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.393]                     next
[13:23:09.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.393]                 }
[13:23:09.393]                 if (length(args) > 0) 
[13:23:09.393]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.393]             }
[13:23:09.393]             else {
[13:23:09.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.393]             }
[13:23:09.393]             {
[13:23:09.393]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.393]                   0L) {
[13:23:09.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.393]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.393]                   base::options(opts)
[13:23:09.393]                 }
[13:23:09.393]                 {
[13:23:09.393]                   {
[13:23:09.393]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.393]                     NULL
[13:23:09.393]                   }
[13:23:09.393]                   options(future.plan = NULL)
[13:23:09.393]                   if (is.na(NA_character_)) 
[13:23:09.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.393]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.393]                     envir = parent.frame()) 
[13:23:09.393]                   {
[13:23:09.393]                     default_workers <- missing(workers)
[13:23:09.393]                     if (is.function(workers)) 
[13:23:09.393]                       workers <- workers()
[13:23:09.393]                     workers <- structure(as.integer(workers), 
[13:23:09.393]                       class = class(workers))
[13:23:09.393]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.393]                       1L)
[13:23:09.393]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.393]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.393]                       if (default_workers) 
[13:23:09.393]                         supportsMulticore(warn = TRUE)
[13:23:09.393]                       return(sequential(..., envir = envir))
[13:23:09.393]                     }
[13:23:09.393]                     oopts <- options(mc.cores = workers)
[13:23:09.393]                     on.exit(options(oopts))
[13:23:09.393]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.393]                       envir = envir)
[13:23:09.393]                     if (!future$lazy) 
[13:23:09.393]                       future <- run(future)
[13:23:09.393]                     invisible(future)
[13:23:09.393]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.393]                 }
[13:23:09.393]             }
[13:23:09.393]         }
[13:23:09.393]     })
[13:23:09.393]     if (TRUE) {
[13:23:09.393]         base::sink(type = "output", split = FALSE)
[13:23:09.393]         if (TRUE) {
[13:23:09.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.393]         }
[13:23:09.393]         else {
[13:23:09.393]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.393]         }
[13:23:09.393]         base::close(...future.stdout)
[13:23:09.393]         ...future.stdout <- NULL
[13:23:09.393]     }
[13:23:09.393]     ...future.result$conditions <- ...future.conditions
[13:23:09.393]     ...future.result$finished <- base::Sys.time()
[13:23:09.393]     ...future.result
[13:23:09.393] }
[13:23:09.396] requestCore(): workers = 2
[13:23:09.396] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:09.407] result() for MulticoreFuture ...
[13:23:09.408] result() for MulticoreFuture ...
[13:23:09.409] result() for MulticoreFuture ... done
[13:23:09.409] result() for MulticoreFuture ... done
[13:23:09.409] result() for MulticoreFuture ...
[13:23:09.409] result() for MulticoreFuture ... done
[13:23:09.413] MulticoreFuture started
[13:23:09.414] - Launch lazy future ... done
[13:23:09.414] run() for ‘MulticoreFuture’ ... done
[13:23:09.414] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5596d70df0c8> 
[13:23:09.414] List of future strategies:
[13:23:09.414] 1. sequential:
[13:23:09.414]    - args: function (..., envir = parent.frame())
[13:23:09.414]    - tweaked: FALSE
[13:23:09.414]    - call: NULL
[13:23:09.415] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5596d58984f0> 
[13:23:09.417] plan(): Setting new future strategy stack:
[13:23:09.418] List of future strategies:
[13:23:09.418] 1. multicore:
[13:23:09.418]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.418]    - tweaked: FALSE
[13:23:09.418]    - call: plan(strategy)
[13:23:09.423] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:09.426] resolve() on list environment ...
[13:23:09.426]  recursive: 0
[13:23:09.428]  length: 6
[13:23:09.428]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:09.428] signalConditionsASAP(numeric, pos=1) ...
[13:23:09.428] - nx: 6
[13:23:09.429] - relay: TRUE
[13:23:09.429] - stdout: TRUE
[13:23:09.429] - signal: TRUE
[13:23:09.429] - resignal: FALSE
[13:23:09.429] - force: TRUE
[13:23:09.429] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.429] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.430]  - until=2
[13:23:09.430]  - relaying element #2
[13:23:09.430] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.430] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.430] signalConditionsASAP(NULL, pos=1) ... done
[13:23:09.430]  length: 5 (resolved future 1)
[13:23:09.430] Future #2
[13:23:09.431] result() for MulticoreFuture ...
[13:23:09.431] result() for MulticoreFuture ... done
[13:23:09.431] result() for MulticoreFuture ...
[13:23:09.431] result() for MulticoreFuture ... done
[13:23:09.431] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:09.431] - nx: 6
[13:23:09.431] - relay: TRUE
[13:23:09.432] - stdout: TRUE
[13:23:09.432] - signal: TRUE
[13:23:09.432] - resignal: FALSE
[13:23:09.432] - force: TRUE
[13:23:09.432] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.432] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.432]  - until=2
[13:23:09.433]  - relaying element #2
[13:23:09.433] result() for MulticoreFuture ...
[13:23:09.433] result() for MulticoreFuture ... done
[13:23:09.433] result() for MulticoreFuture ...
[13:23:09.433] result() for MulticoreFuture ... done
[13:23:09.433] result() for MulticoreFuture ...
[13:23:09.433] result() for MulticoreFuture ... done
[13:23:09.434] result() for MulticoreFuture ...
[13:23:09.434] result() for MulticoreFuture ... done
[13:23:09.434] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.434] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.434] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:09.434]  length: 4 (resolved future 2)
[13:23:09.435] Future #3
[13:23:09.435] result() for MulticoreFuture ...
[13:23:09.436] result() for MulticoreFuture ...
[13:23:09.436] result() for MulticoreFuture ... done
[13:23:09.436] result() for MulticoreFuture ... done
[13:23:09.437] result() for MulticoreFuture ...
[13:23:09.437] result() for MulticoreFuture ... done
[13:23:09.437] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:09.437] - nx: 6
[13:23:09.437] - relay: TRUE
[13:23:09.437] - stdout: TRUE
[13:23:09.438] - signal: TRUE
[13:23:09.438] - resignal: FALSE
[13:23:09.438] - force: TRUE
[13:23:09.438] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.438] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.438]  - until=3
[13:23:09.438]  - relaying element #3
[13:23:09.439] result() for MulticoreFuture ...
[13:23:09.439] result() for MulticoreFuture ... done
[13:23:09.439] result() for MulticoreFuture ...
[13:23:09.439] result() for MulticoreFuture ... done
[13:23:09.439] result() for MulticoreFuture ...
[13:23:09.439] result() for MulticoreFuture ... done
[13:23:09.440] result() for MulticoreFuture ...
[13:23:09.440] result() for MulticoreFuture ... done
[13:23:09.440] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.440] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.440] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:09.441]  length: 3 (resolved future 3)
[13:23:09.441] Future #4
[13:23:09.441] result() for MulticoreFuture ...
[13:23:09.442] result() for MulticoreFuture ...
[13:23:09.442] result() for MulticoreFuture ... done
[13:23:09.442] result() for MulticoreFuture ... done
[13:23:09.443] result() for MulticoreFuture ...
[13:23:09.443] result() for MulticoreFuture ... done
[13:23:09.443] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:09.443] - nx: 6
[13:23:09.443] - relay: TRUE
[13:23:09.444] - stdout: TRUE
[13:23:09.444] - signal: TRUE
[13:23:09.444] - resignal: FALSE
[13:23:09.444] - force: TRUE
[13:23:09.444] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.444] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.445]  - until=4
[13:23:09.445]  - relaying element #4
[13:23:09.445] result() for MulticoreFuture ...
[13:23:09.445] result() for MulticoreFuture ... done
[13:23:09.445] result() for MulticoreFuture ...
[13:23:09.446] result() for MulticoreFuture ... done
[13:23:09.446] result() for MulticoreFuture ...
[13:23:09.446] result() for MulticoreFuture ... done
[13:23:09.446] result() for MulticoreFuture ...
[13:23:09.446] result() for MulticoreFuture ... done
[13:23:09.446] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.447] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.447] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:09.447]  length: 2 (resolved future 4)
[13:23:09.447] signalConditionsASAP(NULL, pos=5) ...
[13:23:09.447] - nx: 6
[13:23:09.447] - relay: TRUE
[13:23:09.447] - stdout: TRUE
[13:23:09.447] - signal: TRUE
[13:23:09.448] - resignal: FALSE
[13:23:09.448] - force: TRUE
[13:23:09.448] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.448] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.448]  - until=6
[13:23:09.448]  - relaying element #6
[13:23:09.448] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.448] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.449] signalConditionsASAP(NULL, pos=5) ... done
[13:23:09.449]  length: 1 (resolved future 5)
[13:23:09.449] signalConditionsASAP(numeric, pos=6) ...
[13:23:09.449] - nx: 6
[13:23:09.449] - relay: TRUE
[13:23:09.449] - stdout: TRUE
[13:23:09.449] - signal: TRUE
[13:23:09.449] - resignal: FALSE
[13:23:09.449] - force: TRUE
[13:23:09.450] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.450] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.450]  - until=6
[13:23:09.450] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.450] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.450] signalConditionsASAP(numeric, pos=6) ... done
[13:23:09.450]  length: 0 (resolved future 6)
[13:23:09.450] Relaying remaining futures
[13:23:09.450] signalConditionsASAP(NULL, pos=0) ...
[13:23:09.451] - nx: 6
[13:23:09.451] - relay: TRUE
[13:23:09.451] - stdout: TRUE
[13:23:09.451] - signal: TRUE
[13:23:09.451] - resignal: FALSE
[13:23:09.451] - force: TRUE
[13:23:09.451] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.451] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:09.452] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.452] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.452] signalConditionsASAP(NULL, pos=0) ... done
[13:23:09.452] resolve() on list environment ... DONE
[13:23:09.452] result() for MulticoreFuture ...
[13:23:09.452] result() for MulticoreFuture ... done
[13:23:09.452] result() for MulticoreFuture ...
[13:23:09.452] result() for MulticoreFuture ... done
[13:23:09.453] result() for MulticoreFuture ...
[13:23:09.453] result() for MulticoreFuture ... done
[13:23:09.453] result() for MulticoreFuture ...
[13:23:09.453] result() for MulticoreFuture ... done
[13:23:09.453] result() for MulticoreFuture ...
[13:23:09.453] result() for MulticoreFuture ... done
[13:23:09.453] result() for MulticoreFuture ...
[13:23:09.454] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d5612f38> 
Dimensions: c(1, 6)
[13:23:09.454] getGlobalsAndPackages() ...
[13:23:09.454] Searching for globals...
[13:23:09.455] 
[13:23:09.455] Searching for globals ... DONE
[13:23:09.455] - globals: [0] <none>
[13:23:09.455] getGlobalsAndPackages() ... DONE
[13:23:09.456] run() for ‘Future’ ...
[13:23:09.456] - state: ‘created’
[13:23:09.456] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.461] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.461] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.461]   - Field: ‘label’
[13:23:09.461]   - Field: ‘local’
[13:23:09.461]   - Field: ‘owner’
[13:23:09.461]   - Field: ‘envir’
[13:23:09.462]   - Field: ‘workers’
[13:23:09.462]   - Field: ‘packages’
[13:23:09.462]   - Field: ‘gc’
[13:23:09.462]   - Field: ‘job’
[13:23:09.462]   - Field: ‘conditions’
[13:23:09.462]   - Field: ‘expr’
[13:23:09.462]   - Field: ‘uuid’
[13:23:09.462]   - Field: ‘seed’
[13:23:09.462]   - Field: ‘version’
[13:23:09.463]   - Field: ‘result’
[13:23:09.463]   - Field: ‘asynchronous’
[13:23:09.463]   - Field: ‘calls’
[13:23:09.463]   - Field: ‘globals’
[13:23:09.463]   - Field: ‘stdout’
[13:23:09.463]   - Field: ‘earlySignal’
[13:23:09.463]   - Field: ‘lazy’
[13:23:09.463]   - Field: ‘state’
[13:23:09.463] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.464] - Launch lazy future ...
[13:23:09.464] Packages needed by the future expression (n = 0): <none>
[13:23:09.464] Packages needed by future strategies (n = 0): <none>
[13:23:09.465] {
[13:23:09.465]     {
[13:23:09.465]         {
[13:23:09.465]             ...future.startTime <- base::Sys.time()
[13:23:09.465]             {
[13:23:09.465]                 {
[13:23:09.465]                   {
[13:23:09.465]                     {
[13:23:09.465]                       base::local({
[13:23:09.465]                         has_future <- base::requireNamespace("future", 
[13:23:09.465]                           quietly = TRUE)
[13:23:09.465]                         if (has_future) {
[13:23:09.465]                           ns <- base::getNamespace("future")
[13:23:09.465]                           version <- ns[[".package"]][["version"]]
[13:23:09.465]                           if (is.null(version)) 
[13:23:09.465]                             version <- utils::packageVersion("future")
[13:23:09.465]                         }
[13:23:09.465]                         else {
[13:23:09.465]                           version <- NULL
[13:23:09.465]                         }
[13:23:09.465]                         if (!has_future || version < "1.8.0") {
[13:23:09.465]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.465]                             "", base::R.version$version.string), 
[13:23:09.465]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.465]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.465]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.465]                               "release", "version")], collapse = " "), 
[13:23:09.465]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.465]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.465]                             info)
[13:23:09.465]                           info <- base::paste(info, collapse = "; ")
[13:23:09.465]                           if (!has_future) {
[13:23:09.465]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.465]                               info)
[13:23:09.465]                           }
[13:23:09.465]                           else {
[13:23:09.465]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.465]                               info, version)
[13:23:09.465]                           }
[13:23:09.465]                           base::stop(msg)
[13:23:09.465]                         }
[13:23:09.465]                       })
[13:23:09.465]                     }
[13:23:09.465]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.465]                     base::options(mc.cores = 1L)
[13:23:09.465]                   }
[13:23:09.465]                   options(future.plan = NULL)
[13:23:09.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.465]                 }
[13:23:09.465]                 ...future.workdir <- getwd()
[13:23:09.465]             }
[13:23:09.465]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.465]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.465]         }
[13:23:09.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.465]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.465]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.465]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.465]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.465]             base::names(...future.oldOptions))
[13:23:09.465]     }
[13:23:09.465]     if (FALSE) {
[13:23:09.465]     }
[13:23:09.465]     else {
[13:23:09.465]         if (TRUE) {
[13:23:09.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.465]                 open = "w")
[13:23:09.465]         }
[13:23:09.465]         else {
[13:23:09.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.465]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.465]         }
[13:23:09.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.465]             base::sink(type = "output", split = FALSE)
[13:23:09.465]             base::close(...future.stdout)
[13:23:09.465]         }, add = TRUE)
[13:23:09.465]     }
[13:23:09.465]     ...future.frame <- base::sys.nframe()
[13:23:09.465]     ...future.conditions <- base::list()
[13:23:09.465]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.465]     if (FALSE) {
[13:23:09.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.465]     }
[13:23:09.465]     ...future.result <- base::tryCatch({
[13:23:09.465]         base::withCallingHandlers({
[13:23:09.465]             ...future.value <- base::withVisible(base::local({
[13:23:09.465]                 withCallingHandlers({
[13:23:09.465]                   2
[13:23:09.465]                 }, immediateCondition = function(cond) {
[13:23:09.465]                   save_rds <- function (object, pathname, ...) 
[13:23:09.465]                   {
[13:23:09.465]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.465]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.465]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.465]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.465]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.465]                         fi_tmp[["mtime"]])
[13:23:09.465]                     }
[13:23:09.465]                     tryCatch({
[13:23:09.465]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.465]                     }, error = function(ex) {
[13:23:09.465]                       msg <- conditionMessage(ex)
[13:23:09.465]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.465]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.465]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.465]                         fi_tmp[["mtime"]], msg)
[13:23:09.465]                       ex$message <- msg
[13:23:09.465]                       stop(ex)
[13:23:09.465]                     })
[13:23:09.465]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.465]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.465]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.465]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.465]                       fi <- file.info(pathname)
[13:23:09.465]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.465]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.465]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.465]                         fi[["size"]], fi[["mtime"]])
[13:23:09.465]                       stop(msg)
[13:23:09.465]                     }
[13:23:09.465]                     invisible(pathname)
[13:23:09.465]                   }
[13:23:09.465]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.465]                     rootPath = tempdir()) 
[13:23:09.465]                   {
[13:23:09.465]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.465]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.465]                       tmpdir = path, fileext = ".rds")
[13:23:09.465]                     save_rds(obj, file)
[13:23:09.465]                   }
[13:23:09.465]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.465]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.465]                   {
[13:23:09.465]                     inherits <- base::inherits
[13:23:09.465]                     invokeRestart <- base::invokeRestart
[13:23:09.465]                     is.null <- base::is.null
[13:23:09.465]                     muffled <- FALSE
[13:23:09.465]                     if (inherits(cond, "message")) {
[13:23:09.465]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.465]                       if (muffled) 
[13:23:09.465]                         invokeRestart("muffleMessage")
[13:23:09.465]                     }
[13:23:09.465]                     else if (inherits(cond, "warning")) {
[13:23:09.465]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.465]                       if (muffled) 
[13:23:09.465]                         invokeRestart("muffleWarning")
[13:23:09.465]                     }
[13:23:09.465]                     else if (inherits(cond, "condition")) {
[13:23:09.465]                       if (!is.null(pattern)) {
[13:23:09.465]                         computeRestarts <- base::computeRestarts
[13:23:09.465]                         grepl <- base::grepl
[13:23:09.465]                         restarts <- computeRestarts(cond)
[13:23:09.465]                         for (restart in restarts) {
[13:23:09.465]                           name <- restart$name
[13:23:09.465]                           if (is.null(name)) 
[13:23:09.465]                             next
[13:23:09.465]                           if (!grepl(pattern, name)) 
[13:23:09.465]                             next
[13:23:09.465]                           invokeRestart(restart)
[13:23:09.465]                           muffled <- TRUE
[13:23:09.465]                           break
[13:23:09.465]                         }
[13:23:09.465]                       }
[13:23:09.465]                     }
[13:23:09.465]                     invisible(muffled)
[13:23:09.465]                   }
[13:23:09.465]                   muffleCondition(cond)
[13:23:09.465]                 })
[13:23:09.465]             }))
[13:23:09.465]             future::FutureResult(value = ...future.value$value, 
[13:23:09.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.465]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.465]                     ...future.globalenv.names))
[13:23:09.465]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.465]         }, condition = base::local({
[13:23:09.465]             c <- base::c
[13:23:09.465]             inherits <- base::inherits
[13:23:09.465]             invokeRestart <- base::invokeRestart
[13:23:09.465]             length <- base::length
[13:23:09.465]             list <- base::list
[13:23:09.465]             seq.int <- base::seq.int
[13:23:09.465]             signalCondition <- base::signalCondition
[13:23:09.465]             sys.calls <- base::sys.calls
[13:23:09.465]             `[[` <- base::`[[`
[13:23:09.465]             `+` <- base::`+`
[13:23:09.465]             `<<-` <- base::`<<-`
[13:23:09.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.465]                   3L)]
[13:23:09.465]             }
[13:23:09.465]             function(cond) {
[13:23:09.465]                 is_error <- inherits(cond, "error")
[13:23:09.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.465]                   NULL)
[13:23:09.465]                 if (is_error) {
[13:23:09.465]                   sessionInformation <- function() {
[13:23:09.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.465]                       search = base::search(), system = base::Sys.info())
[13:23:09.465]                   }
[13:23:09.465]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.465]                     cond$call), session = sessionInformation(), 
[13:23:09.465]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.465]                   signalCondition(cond)
[13:23:09.465]                 }
[13:23:09.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.465]                 "immediateCondition"))) {
[13:23:09.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.465]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.465]                   if (TRUE && !signal) {
[13:23:09.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.465]                     {
[13:23:09.465]                       inherits <- base::inherits
[13:23:09.465]                       invokeRestart <- base::invokeRestart
[13:23:09.465]                       is.null <- base::is.null
[13:23:09.465]                       muffled <- FALSE
[13:23:09.465]                       if (inherits(cond, "message")) {
[13:23:09.465]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.465]                         if (muffled) 
[13:23:09.465]                           invokeRestart("muffleMessage")
[13:23:09.465]                       }
[13:23:09.465]                       else if (inherits(cond, "warning")) {
[13:23:09.465]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.465]                         if (muffled) 
[13:23:09.465]                           invokeRestart("muffleWarning")
[13:23:09.465]                       }
[13:23:09.465]                       else if (inherits(cond, "condition")) {
[13:23:09.465]                         if (!is.null(pattern)) {
[13:23:09.465]                           computeRestarts <- base::computeRestarts
[13:23:09.465]                           grepl <- base::grepl
[13:23:09.465]                           restarts <- computeRestarts(cond)
[13:23:09.465]                           for (restart in restarts) {
[13:23:09.465]                             name <- restart$name
[13:23:09.465]                             if (is.null(name)) 
[13:23:09.465]                               next
[13:23:09.465]                             if (!grepl(pattern, name)) 
[13:23:09.465]                               next
[13:23:09.465]                             invokeRestart(restart)
[13:23:09.465]                             muffled <- TRUE
[13:23:09.465]                             break
[13:23:09.465]                           }
[13:23:09.465]                         }
[13:23:09.465]                       }
[13:23:09.465]                       invisible(muffled)
[13:23:09.465]                     }
[13:23:09.465]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.465]                   }
[13:23:09.465]                 }
[13:23:09.465]                 else {
[13:23:09.465]                   if (TRUE) {
[13:23:09.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.465]                     {
[13:23:09.465]                       inherits <- base::inherits
[13:23:09.465]                       invokeRestart <- base::invokeRestart
[13:23:09.465]                       is.null <- base::is.null
[13:23:09.465]                       muffled <- FALSE
[13:23:09.465]                       if (inherits(cond, "message")) {
[13:23:09.465]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.465]                         if (muffled) 
[13:23:09.465]                           invokeRestart("muffleMessage")
[13:23:09.465]                       }
[13:23:09.465]                       else if (inherits(cond, "warning")) {
[13:23:09.465]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.465]                         if (muffled) 
[13:23:09.465]                           invokeRestart("muffleWarning")
[13:23:09.465]                       }
[13:23:09.465]                       else if (inherits(cond, "condition")) {
[13:23:09.465]                         if (!is.null(pattern)) {
[13:23:09.465]                           computeRestarts <- base::computeRestarts
[13:23:09.465]                           grepl <- base::grepl
[13:23:09.465]                           restarts <- computeRestarts(cond)
[13:23:09.465]                           for (restart in restarts) {
[13:23:09.465]                             name <- restart$name
[13:23:09.465]                             if (is.null(name)) 
[13:23:09.465]                               next
[13:23:09.465]                             if (!grepl(pattern, name)) 
[13:23:09.465]                               next
[13:23:09.465]                             invokeRestart(restart)
[13:23:09.465]                             muffled <- TRUE
[13:23:09.465]                             break
[13:23:09.465]                           }
[13:23:09.465]                         }
[13:23:09.465]                       }
[13:23:09.465]                       invisible(muffled)
[13:23:09.465]                     }
[13:23:09.465]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.465]                   }
[13:23:09.465]                 }
[13:23:09.465]             }
[13:23:09.465]         }))
[13:23:09.465]     }, error = function(ex) {
[13:23:09.465]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.465]                 ...future.rng), started = ...future.startTime, 
[13:23:09.465]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.465]             version = "1.8"), class = "FutureResult")
[13:23:09.465]     }, finally = {
[13:23:09.465]         if (!identical(...future.workdir, getwd())) 
[13:23:09.465]             setwd(...future.workdir)
[13:23:09.465]         {
[13:23:09.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.465]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.465]             }
[13:23:09.465]             base::options(...future.oldOptions)
[13:23:09.465]             if (.Platform$OS.type == "windows") {
[13:23:09.465]                 old_names <- names(...future.oldEnvVars)
[13:23:09.465]                 envs <- base::Sys.getenv()
[13:23:09.465]                 names <- names(envs)
[13:23:09.465]                 common <- intersect(names, old_names)
[13:23:09.465]                 added <- setdiff(names, old_names)
[13:23:09.465]                 removed <- setdiff(old_names, names)
[13:23:09.465]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.465]                   envs[common]]
[13:23:09.465]                 NAMES <- toupper(changed)
[13:23:09.465]                 args <- list()
[13:23:09.465]                 for (kk in seq_along(NAMES)) {
[13:23:09.465]                   name <- changed[[kk]]
[13:23:09.465]                   NAME <- NAMES[[kk]]
[13:23:09.465]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.465]                     next
[13:23:09.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.465]                 }
[13:23:09.465]                 NAMES <- toupper(added)
[13:23:09.465]                 for (kk in seq_along(NAMES)) {
[13:23:09.465]                   name <- added[[kk]]
[13:23:09.465]                   NAME <- NAMES[[kk]]
[13:23:09.465]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.465]                     next
[13:23:09.465]                   args[[name]] <- ""
[13:23:09.465]                 }
[13:23:09.465]                 NAMES <- toupper(removed)
[13:23:09.465]                 for (kk in seq_along(NAMES)) {
[13:23:09.465]                   name <- removed[[kk]]
[13:23:09.465]                   NAME <- NAMES[[kk]]
[13:23:09.465]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.465]                     next
[13:23:09.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.465]                 }
[13:23:09.465]                 if (length(args) > 0) 
[13:23:09.465]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.465]             }
[13:23:09.465]             else {
[13:23:09.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.465]             }
[13:23:09.465]             {
[13:23:09.465]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.465]                   0L) {
[13:23:09.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.465]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.465]                   base::options(opts)
[13:23:09.465]                 }
[13:23:09.465]                 {
[13:23:09.465]                   {
[13:23:09.465]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.465]                     NULL
[13:23:09.465]                   }
[13:23:09.465]                   options(future.plan = NULL)
[13:23:09.465]                   if (is.na(NA_character_)) 
[13:23:09.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.465]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.465]                     envir = parent.frame()) 
[13:23:09.465]                   {
[13:23:09.465]                     default_workers <- missing(workers)
[13:23:09.465]                     if (is.function(workers)) 
[13:23:09.465]                       workers <- workers()
[13:23:09.465]                     workers <- structure(as.integer(workers), 
[13:23:09.465]                       class = class(workers))
[13:23:09.465]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.465]                       1L)
[13:23:09.465]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.465]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.465]                       if (default_workers) 
[13:23:09.465]                         supportsMulticore(warn = TRUE)
[13:23:09.465]                       return(sequential(..., envir = envir))
[13:23:09.465]                     }
[13:23:09.465]                     oopts <- options(mc.cores = workers)
[13:23:09.465]                     on.exit(options(oopts))
[13:23:09.465]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.465]                       envir = envir)
[13:23:09.465]                     if (!future$lazy) 
[13:23:09.465]                       future <- run(future)
[13:23:09.465]                     invisible(future)
[13:23:09.465]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.465]                 }
[13:23:09.465]             }
[13:23:09.465]         }
[13:23:09.465]     })
[13:23:09.465]     if (TRUE) {
[13:23:09.465]         base::sink(type = "output", split = FALSE)
[13:23:09.465]         if (TRUE) {
[13:23:09.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.465]         }
[13:23:09.465]         else {
[13:23:09.465]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.465]         }
[13:23:09.465]         base::close(...future.stdout)
[13:23:09.465]         ...future.stdout <- NULL
[13:23:09.465]     }
[13:23:09.465]     ...future.result$conditions <- ...future.conditions
[13:23:09.465]     ...future.result$finished <- base::Sys.time()
[13:23:09.465]     ...future.result
[13:23:09.465] }
[13:23:09.468] requestCore(): workers = 2
[13:23:09.471] MulticoreFuture started
[13:23:09.471] - Launch lazy future ... done
[13:23:09.471] run() for ‘MulticoreFuture’ ... done
[13:23:09.472] getGlobalsAndPackages() ...
[13:23:09.472] Searching for globals...
[13:23:09.472] plan(): Setting new future strategy stack:
[13:23:09.473] 
[13:23:09.472] List of future strategies:
[13:23:09.472] 1. sequential:
[13:23:09.472]    - args: function (..., envir = parent.frame())
[13:23:09.472]    - tweaked: FALSE
[13:23:09.472]    - call: NULL
[13:23:09.473] Searching for globals ... DONE
[13:23:09.473] - globals: [0] <none>
[13:23:09.473] plan(): nbrOfWorkers() = 1
[13:23:09.473] getGlobalsAndPackages() ... DONE
[13:23:09.474] run() for ‘Future’ ...
[13:23:09.474] - state: ‘created’
[13:23:09.474] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.475] plan(): Setting new future strategy stack:
[13:23:09.475] List of future strategies:
[13:23:09.475] 1. multicore:
[13:23:09.475]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.475]    - tweaked: FALSE
[13:23:09.475]    - call: plan(strategy)
[13:23:09.480] plan(): nbrOfWorkers() = 2
[13:23:09.480] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.481]   - Field: ‘label’
[13:23:09.481]   - Field: ‘local’
[13:23:09.481]   - Field: ‘owner’
[13:23:09.481]   - Field: ‘envir’
[13:23:09.481]   - Field: ‘workers’
[13:23:09.481]   - Field: ‘packages’
[13:23:09.481]   - Field: ‘gc’
[13:23:09.482]   - Field: ‘job’
[13:23:09.482]   - Field: ‘conditions’
[13:23:09.482]   - Field: ‘expr’
[13:23:09.482]   - Field: ‘uuid’
[13:23:09.482]   - Field: ‘seed’
[13:23:09.482]   - Field: ‘version’
[13:23:09.482]   - Field: ‘result’
[13:23:09.483]   - Field: ‘asynchronous’
[13:23:09.483]   - Field: ‘calls’
[13:23:09.483]   - Field: ‘globals’
[13:23:09.483]   - Field: ‘stdout’
[13:23:09.483]   - Field: ‘earlySignal’
[13:23:09.483]   - Field: ‘lazy’
[13:23:09.483]   - Field: ‘state’
[13:23:09.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.484] - Launch lazy future ...
[13:23:09.484] Packages needed by the future expression (n = 0): <none>
[13:23:09.485] Packages needed by future strategies (n = 0): <none>
[13:23:09.485] {
[13:23:09.485]     {
[13:23:09.485]         {
[13:23:09.485]             ...future.startTime <- base::Sys.time()
[13:23:09.485]             {
[13:23:09.485]                 {
[13:23:09.485]                   {
[13:23:09.485]                     {
[13:23:09.485]                       base::local({
[13:23:09.485]                         has_future <- base::requireNamespace("future", 
[13:23:09.485]                           quietly = TRUE)
[13:23:09.485]                         if (has_future) {
[13:23:09.485]                           ns <- base::getNamespace("future")
[13:23:09.485]                           version <- ns[[".package"]][["version"]]
[13:23:09.485]                           if (is.null(version)) 
[13:23:09.485]                             version <- utils::packageVersion("future")
[13:23:09.485]                         }
[13:23:09.485]                         else {
[13:23:09.485]                           version <- NULL
[13:23:09.485]                         }
[13:23:09.485]                         if (!has_future || version < "1.8.0") {
[13:23:09.485]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.485]                             "", base::R.version$version.string), 
[13:23:09.485]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.485]                               "release", "version")], collapse = " "), 
[13:23:09.485]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.485]                             info)
[13:23:09.485]                           info <- base::paste(info, collapse = "; ")
[13:23:09.485]                           if (!has_future) {
[13:23:09.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.485]                               info)
[13:23:09.485]                           }
[13:23:09.485]                           else {
[13:23:09.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.485]                               info, version)
[13:23:09.485]                           }
[13:23:09.485]                           base::stop(msg)
[13:23:09.485]                         }
[13:23:09.485]                       })
[13:23:09.485]                     }
[13:23:09.485]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.485]                     base::options(mc.cores = 1L)
[13:23:09.485]                   }
[13:23:09.485]                   options(future.plan = NULL)
[13:23:09.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.485]                 }
[13:23:09.485]                 ...future.workdir <- getwd()
[13:23:09.485]             }
[13:23:09.485]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.485]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.485]         }
[13:23:09.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.485]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.485]             base::names(...future.oldOptions))
[13:23:09.485]     }
[13:23:09.485]     if (FALSE) {
[13:23:09.485]     }
[13:23:09.485]     else {
[13:23:09.485]         if (TRUE) {
[13:23:09.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.485]                 open = "w")
[13:23:09.485]         }
[13:23:09.485]         else {
[13:23:09.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.485]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.485]         }
[13:23:09.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.485]             base::sink(type = "output", split = FALSE)
[13:23:09.485]             base::close(...future.stdout)
[13:23:09.485]         }, add = TRUE)
[13:23:09.485]     }
[13:23:09.485]     ...future.frame <- base::sys.nframe()
[13:23:09.485]     ...future.conditions <- base::list()
[13:23:09.485]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.485]     if (FALSE) {
[13:23:09.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.485]     }
[13:23:09.485]     ...future.result <- base::tryCatch({
[13:23:09.485]         base::withCallingHandlers({
[13:23:09.485]             ...future.value <- base::withVisible(base::local({
[13:23:09.485]                 withCallingHandlers({
[13:23:09.485]                   NULL
[13:23:09.485]                 }, immediateCondition = function(cond) {
[13:23:09.485]                   save_rds <- function (object, pathname, ...) 
[13:23:09.485]                   {
[13:23:09.485]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.485]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.485]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.485]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.485]                         fi_tmp[["mtime"]])
[13:23:09.485]                     }
[13:23:09.485]                     tryCatch({
[13:23:09.485]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.485]                     }, error = function(ex) {
[13:23:09.485]                       msg <- conditionMessage(ex)
[13:23:09.485]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.485]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.485]                         fi_tmp[["mtime"]], msg)
[13:23:09.485]                       ex$message <- msg
[13:23:09.485]                       stop(ex)
[13:23:09.485]                     })
[13:23:09.485]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.485]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.485]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.485]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.485]                       fi <- file.info(pathname)
[13:23:09.485]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.485]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.485]                         fi[["size"]], fi[["mtime"]])
[13:23:09.485]                       stop(msg)
[13:23:09.485]                     }
[13:23:09.485]                     invisible(pathname)
[13:23:09.485]                   }
[13:23:09.485]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.485]                     rootPath = tempdir()) 
[13:23:09.485]                   {
[13:23:09.485]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.485]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.485]                       tmpdir = path, fileext = ".rds")
[13:23:09.485]                     save_rds(obj, file)
[13:23:09.485]                   }
[13:23:09.485]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.485]                   {
[13:23:09.485]                     inherits <- base::inherits
[13:23:09.485]                     invokeRestart <- base::invokeRestart
[13:23:09.485]                     is.null <- base::is.null
[13:23:09.485]                     muffled <- FALSE
[13:23:09.485]                     if (inherits(cond, "message")) {
[13:23:09.485]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.485]                       if (muffled) 
[13:23:09.485]                         invokeRestart("muffleMessage")
[13:23:09.485]                     }
[13:23:09.485]                     else if (inherits(cond, "warning")) {
[13:23:09.485]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.485]                       if (muffled) 
[13:23:09.485]                         invokeRestart("muffleWarning")
[13:23:09.485]                     }
[13:23:09.485]                     else if (inherits(cond, "condition")) {
[13:23:09.485]                       if (!is.null(pattern)) {
[13:23:09.485]                         computeRestarts <- base::computeRestarts
[13:23:09.485]                         grepl <- base::grepl
[13:23:09.485]                         restarts <- computeRestarts(cond)
[13:23:09.485]                         for (restart in restarts) {
[13:23:09.485]                           name <- restart$name
[13:23:09.485]                           if (is.null(name)) 
[13:23:09.485]                             next
[13:23:09.485]                           if (!grepl(pattern, name)) 
[13:23:09.485]                             next
[13:23:09.485]                           invokeRestart(restart)
[13:23:09.485]                           muffled <- TRUE
[13:23:09.485]                           break
[13:23:09.485]                         }
[13:23:09.485]                       }
[13:23:09.485]                     }
[13:23:09.485]                     invisible(muffled)
[13:23:09.485]                   }
[13:23:09.485]                   muffleCondition(cond)
[13:23:09.485]                 })
[13:23:09.485]             }))
[13:23:09.485]             future::FutureResult(value = ...future.value$value, 
[13:23:09.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.485]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.485]                     ...future.globalenv.names))
[13:23:09.485]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.485]         }, condition = base::local({
[13:23:09.485]             c <- base::c
[13:23:09.485]             inherits <- base::inherits
[13:23:09.485]             invokeRestart <- base::invokeRestart
[13:23:09.485]             length <- base::length
[13:23:09.485]             list <- base::list
[13:23:09.485]             seq.int <- base::seq.int
[13:23:09.485]             signalCondition <- base::signalCondition
[13:23:09.485]             sys.calls <- base::sys.calls
[13:23:09.485]             `[[` <- base::`[[`
[13:23:09.485]             `+` <- base::`+`
[13:23:09.485]             `<<-` <- base::`<<-`
[13:23:09.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.485]                   3L)]
[13:23:09.485]             }
[13:23:09.485]             function(cond) {
[13:23:09.485]                 is_error <- inherits(cond, "error")
[13:23:09.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.485]                   NULL)
[13:23:09.485]                 if (is_error) {
[13:23:09.485]                   sessionInformation <- function() {
[13:23:09.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.485]                       search = base::search(), system = base::Sys.info())
[13:23:09.485]                   }
[13:23:09.485]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.485]                     cond$call), session = sessionInformation(), 
[13:23:09.485]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.485]                   signalCondition(cond)
[13:23:09.485]                 }
[13:23:09.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.485]                 "immediateCondition"))) {
[13:23:09.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.485]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.485]                   if (TRUE && !signal) {
[13:23:09.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.485]                     {
[13:23:09.485]                       inherits <- base::inherits
[13:23:09.485]                       invokeRestart <- base::invokeRestart
[13:23:09.485]                       is.null <- base::is.null
[13:23:09.485]                       muffled <- FALSE
[13:23:09.485]                       if (inherits(cond, "message")) {
[13:23:09.485]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.485]                         if (muffled) 
[13:23:09.485]                           invokeRestart("muffleMessage")
[13:23:09.485]                       }
[13:23:09.485]                       else if (inherits(cond, "warning")) {
[13:23:09.485]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.485]                         if (muffled) 
[13:23:09.485]                           invokeRestart("muffleWarning")
[13:23:09.485]                       }
[13:23:09.485]                       else if (inherits(cond, "condition")) {
[13:23:09.485]                         if (!is.null(pattern)) {
[13:23:09.485]                           computeRestarts <- base::computeRestarts
[13:23:09.485]                           grepl <- base::grepl
[13:23:09.485]                           restarts <- computeRestarts(cond)
[13:23:09.485]                           for (restart in restarts) {
[13:23:09.485]                             name <- restart$name
[13:23:09.485]                             if (is.null(name)) 
[13:23:09.485]                               next
[13:23:09.485]                             if (!grepl(pattern, name)) 
[13:23:09.485]                               next
[13:23:09.485]                             invokeRestart(restart)
[13:23:09.485]                             muffled <- TRUE
[13:23:09.485]                             break
[13:23:09.485]                           }
[13:23:09.485]                         }
[13:23:09.485]                       }
[13:23:09.485]                       invisible(muffled)
[13:23:09.485]                     }
[13:23:09.485]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.485]                   }
[13:23:09.485]                 }
[13:23:09.485]                 else {
[13:23:09.485]                   if (TRUE) {
[13:23:09.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.485]                     {
[13:23:09.485]                       inherits <- base::inherits
[13:23:09.485]                       invokeRestart <- base::invokeRestart
[13:23:09.485]                       is.null <- base::is.null
[13:23:09.485]                       muffled <- FALSE
[13:23:09.485]                       if (inherits(cond, "message")) {
[13:23:09.485]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.485]                         if (muffled) 
[13:23:09.485]                           invokeRestart("muffleMessage")
[13:23:09.485]                       }
[13:23:09.485]                       else if (inherits(cond, "warning")) {
[13:23:09.485]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.485]                         if (muffled) 
[13:23:09.485]                           invokeRestart("muffleWarning")
[13:23:09.485]                       }
[13:23:09.485]                       else if (inherits(cond, "condition")) {
[13:23:09.485]                         if (!is.null(pattern)) {
[13:23:09.485]                           computeRestarts <- base::computeRestarts
[13:23:09.485]                           grepl <- base::grepl
[13:23:09.485]                           restarts <- computeRestarts(cond)
[13:23:09.485]                           for (restart in restarts) {
[13:23:09.485]                             name <- restart$name
[13:23:09.485]                             if (is.null(name)) 
[13:23:09.485]                               next
[13:23:09.485]                             if (!grepl(pattern, name)) 
[13:23:09.485]                               next
[13:23:09.485]                             invokeRestart(restart)
[13:23:09.485]                             muffled <- TRUE
[13:23:09.485]                             break
[13:23:09.485]                           }
[13:23:09.485]                         }
[13:23:09.485]                       }
[13:23:09.485]                       invisible(muffled)
[13:23:09.485]                     }
[13:23:09.485]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.485]                   }
[13:23:09.485]                 }
[13:23:09.485]             }
[13:23:09.485]         }))
[13:23:09.485]     }, error = function(ex) {
[13:23:09.485]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.485]                 ...future.rng), started = ...future.startTime, 
[13:23:09.485]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.485]             version = "1.8"), class = "FutureResult")
[13:23:09.485]     }, finally = {
[13:23:09.485]         if (!identical(...future.workdir, getwd())) 
[13:23:09.485]             setwd(...future.workdir)
[13:23:09.485]         {
[13:23:09.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.485]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.485]             }
[13:23:09.485]             base::options(...future.oldOptions)
[13:23:09.485]             if (.Platform$OS.type == "windows") {
[13:23:09.485]                 old_names <- names(...future.oldEnvVars)
[13:23:09.485]                 envs <- base::Sys.getenv()
[13:23:09.485]                 names <- names(envs)
[13:23:09.485]                 common <- intersect(names, old_names)
[13:23:09.485]                 added <- setdiff(names, old_names)
[13:23:09.485]                 removed <- setdiff(old_names, names)
[13:23:09.485]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.485]                   envs[common]]
[13:23:09.485]                 NAMES <- toupper(changed)
[13:23:09.485]                 args <- list()
[13:23:09.485]                 for (kk in seq_along(NAMES)) {
[13:23:09.485]                   name <- changed[[kk]]
[13:23:09.485]                   NAME <- NAMES[[kk]]
[13:23:09.485]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.485]                     next
[13:23:09.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.485]                 }
[13:23:09.485]                 NAMES <- toupper(added)
[13:23:09.485]                 for (kk in seq_along(NAMES)) {
[13:23:09.485]                   name <- added[[kk]]
[13:23:09.485]                   NAME <- NAMES[[kk]]
[13:23:09.485]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.485]                     next
[13:23:09.485]                   args[[name]] <- ""
[13:23:09.485]                 }
[13:23:09.485]                 NAMES <- toupper(removed)
[13:23:09.485]                 for (kk in seq_along(NAMES)) {
[13:23:09.485]                   name <- removed[[kk]]
[13:23:09.485]                   NAME <- NAMES[[kk]]
[13:23:09.485]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.485]                     next
[13:23:09.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.485]                 }
[13:23:09.485]                 if (length(args) > 0) 
[13:23:09.485]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.485]             }
[13:23:09.485]             else {
[13:23:09.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.485]             }
[13:23:09.485]             {
[13:23:09.485]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.485]                   0L) {
[13:23:09.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.485]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.485]                   base::options(opts)
[13:23:09.485]                 }
[13:23:09.485]                 {
[13:23:09.485]                   {
[13:23:09.485]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.485]                     NULL
[13:23:09.485]                   }
[13:23:09.485]                   options(future.plan = NULL)
[13:23:09.485]                   if (is.na(NA_character_)) 
[13:23:09.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.485]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.485]                     envir = parent.frame()) 
[13:23:09.485]                   {
[13:23:09.485]                     default_workers <- missing(workers)
[13:23:09.485]                     if (is.function(workers)) 
[13:23:09.485]                       workers <- workers()
[13:23:09.485]                     workers <- structure(as.integer(workers), 
[13:23:09.485]                       class = class(workers))
[13:23:09.485]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.485]                       1L)
[13:23:09.485]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.485]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.485]                       if (default_workers) 
[13:23:09.485]                         supportsMulticore(warn = TRUE)
[13:23:09.485]                       return(sequential(..., envir = envir))
[13:23:09.485]                     }
[13:23:09.485]                     oopts <- options(mc.cores = workers)
[13:23:09.485]                     on.exit(options(oopts))
[13:23:09.485]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.485]                       envir = envir)
[13:23:09.485]                     if (!future$lazy) 
[13:23:09.485]                       future <- run(future)
[13:23:09.485]                     invisible(future)
[13:23:09.485]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.485]                 }
[13:23:09.485]             }
[13:23:09.485]         }
[13:23:09.485]     })
[13:23:09.485]     if (TRUE) {
[13:23:09.485]         base::sink(type = "output", split = FALSE)
[13:23:09.485]         if (TRUE) {
[13:23:09.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.485]         }
[13:23:09.485]         else {
[13:23:09.485]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.485]         }
[13:23:09.485]         base::close(...future.stdout)
[13:23:09.485]         ...future.stdout <- NULL
[13:23:09.485]     }
[13:23:09.485]     ...future.result$conditions <- ...future.conditions
[13:23:09.485]     ...future.result$finished <- base::Sys.time()
[13:23:09.485]     ...future.result
[13:23:09.485] }
[13:23:09.489] requestCore(): workers = 2
[13:23:09.492] MulticoreFuture started
[13:23:09.493] - Launch lazy future ... done
[13:23:09.493] run() for ‘MulticoreFuture’ ... done
[13:23:09.494] plan(): Setting new future strategy stack:
[13:23:09.494] getGlobalsAndPackages() ...
[13:23:09.494] Searching for globals...
[13:23:09.494] List of future strategies:
[13:23:09.494] 1. sequential:
[13:23:09.494]    - args: function (..., envir = parent.frame())
[13:23:09.494]    - tweaked: FALSE
[13:23:09.494]    - call: NULL
[13:23:09.495] plan(): nbrOfWorkers() = 1
[13:23:09.496] - globals found: [1] ‘{’
[13:23:09.496] Searching for globals ... DONE
[13:23:09.496] Resolving globals: FALSE
[13:23:09.497] 
[13:23:09.497] 
[13:23:09.497] getGlobalsAndPackages() ... DONE
[13:23:09.497] plan(): Setting new future strategy stack:
[13:23:09.497] run() for ‘Future’ ...
[13:23:09.498] - state: ‘created’
[13:23:09.497] List of future strategies:
[13:23:09.497] 1. multicore:
[13:23:09.497]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.497]    - tweaked: FALSE
[13:23:09.497]    - call: plan(strategy)
[13:23:09.498] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.503] plan(): nbrOfWorkers() = 2
[13:23:09.503] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.503] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.504]   - Field: ‘label’
[13:23:09.504]   - Field: ‘local’
[13:23:09.504]   - Field: ‘owner’
[13:23:09.504]   - Field: ‘envir’
[13:23:09.504]   - Field: ‘workers’
[13:23:09.504]   - Field: ‘packages’
[13:23:09.504]   - Field: ‘gc’
[13:23:09.505]   - Field: ‘job’
[13:23:09.505]   - Field: ‘conditions’
[13:23:09.505]   - Field: ‘expr’
[13:23:09.505]   - Field: ‘uuid’
[13:23:09.505]   - Field: ‘seed’
[13:23:09.505]   - Field: ‘version’
[13:23:09.505]   - Field: ‘result’
[13:23:09.506]   - Field: ‘asynchronous’
[13:23:09.506]   - Field: ‘calls’
[13:23:09.506]   - Field: ‘globals’
[13:23:09.506]   - Field: ‘stdout’
[13:23:09.506]   - Field: ‘earlySignal’
[13:23:09.506]   - Field: ‘lazy’
[13:23:09.506]   - Field: ‘state’
[13:23:09.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.507] - Launch lazy future ...
[13:23:09.507] Packages needed by the future expression (n = 0): <none>
[13:23:09.507] Packages needed by future strategies (n = 0): <none>
[13:23:09.508] {
[13:23:09.508]     {
[13:23:09.508]         {
[13:23:09.508]             ...future.startTime <- base::Sys.time()
[13:23:09.508]             {
[13:23:09.508]                 {
[13:23:09.508]                   {
[13:23:09.508]                     {
[13:23:09.508]                       base::local({
[13:23:09.508]                         has_future <- base::requireNamespace("future", 
[13:23:09.508]                           quietly = TRUE)
[13:23:09.508]                         if (has_future) {
[13:23:09.508]                           ns <- base::getNamespace("future")
[13:23:09.508]                           version <- ns[[".package"]][["version"]]
[13:23:09.508]                           if (is.null(version)) 
[13:23:09.508]                             version <- utils::packageVersion("future")
[13:23:09.508]                         }
[13:23:09.508]                         else {
[13:23:09.508]                           version <- NULL
[13:23:09.508]                         }
[13:23:09.508]                         if (!has_future || version < "1.8.0") {
[13:23:09.508]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.508]                             "", base::R.version$version.string), 
[13:23:09.508]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.508]                               "release", "version")], collapse = " "), 
[13:23:09.508]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.508]                             info)
[13:23:09.508]                           info <- base::paste(info, collapse = "; ")
[13:23:09.508]                           if (!has_future) {
[13:23:09.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.508]                               info)
[13:23:09.508]                           }
[13:23:09.508]                           else {
[13:23:09.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.508]                               info, version)
[13:23:09.508]                           }
[13:23:09.508]                           base::stop(msg)
[13:23:09.508]                         }
[13:23:09.508]                       })
[13:23:09.508]                     }
[13:23:09.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.508]                     base::options(mc.cores = 1L)
[13:23:09.508]                   }
[13:23:09.508]                   options(future.plan = NULL)
[13:23:09.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.508]                 }
[13:23:09.508]                 ...future.workdir <- getwd()
[13:23:09.508]             }
[13:23:09.508]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.508]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.508]         }
[13:23:09.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.508]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.508]             base::names(...future.oldOptions))
[13:23:09.508]     }
[13:23:09.508]     if (FALSE) {
[13:23:09.508]     }
[13:23:09.508]     else {
[13:23:09.508]         if (TRUE) {
[13:23:09.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.508]                 open = "w")
[13:23:09.508]         }
[13:23:09.508]         else {
[13:23:09.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.508]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.508]         }
[13:23:09.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.508]             base::sink(type = "output", split = FALSE)
[13:23:09.508]             base::close(...future.stdout)
[13:23:09.508]         }, add = TRUE)
[13:23:09.508]     }
[13:23:09.508]     ...future.frame <- base::sys.nframe()
[13:23:09.508]     ...future.conditions <- base::list()
[13:23:09.508]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.508]     if (FALSE) {
[13:23:09.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.508]     }
[13:23:09.508]     ...future.result <- base::tryCatch({
[13:23:09.508]         base::withCallingHandlers({
[13:23:09.508]             ...future.value <- base::withVisible(base::local({
[13:23:09.508]                 withCallingHandlers({
[13:23:09.508]                   {
[13:23:09.508]                     4
[13:23:09.508]                   }
[13:23:09.508]                 }, immediateCondition = function(cond) {
[13:23:09.508]                   save_rds <- function (object, pathname, ...) 
[13:23:09.508]                   {
[13:23:09.508]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.508]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.508]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.508]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.508]                         fi_tmp[["mtime"]])
[13:23:09.508]                     }
[13:23:09.508]                     tryCatch({
[13:23:09.508]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.508]                     }, error = function(ex) {
[13:23:09.508]                       msg <- conditionMessage(ex)
[13:23:09.508]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.508]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.508]                         fi_tmp[["mtime"]], msg)
[13:23:09.508]                       ex$message <- msg
[13:23:09.508]                       stop(ex)
[13:23:09.508]                     })
[13:23:09.508]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.508]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.508]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.508]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.508]                       fi <- file.info(pathname)
[13:23:09.508]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.508]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.508]                         fi[["size"]], fi[["mtime"]])
[13:23:09.508]                       stop(msg)
[13:23:09.508]                     }
[13:23:09.508]                     invisible(pathname)
[13:23:09.508]                   }
[13:23:09.508]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.508]                     rootPath = tempdir()) 
[13:23:09.508]                   {
[13:23:09.508]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.508]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.508]                       tmpdir = path, fileext = ".rds")
[13:23:09.508]                     save_rds(obj, file)
[13:23:09.508]                   }
[13:23:09.508]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.508]                   {
[13:23:09.508]                     inherits <- base::inherits
[13:23:09.508]                     invokeRestart <- base::invokeRestart
[13:23:09.508]                     is.null <- base::is.null
[13:23:09.508]                     muffled <- FALSE
[13:23:09.508]                     if (inherits(cond, "message")) {
[13:23:09.508]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.508]                       if (muffled) 
[13:23:09.508]                         invokeRestart("muffleMessage")
[13:23:09.508]                     }
[13:23:09.508]                     else if (inherits(cond, "warning")) {
[13:23:09.508]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.508]                       if (muffled) 
[13:23:09.508]                         invokeRestart("muffleWarning")
[13:23:09.508]                     }
[13:23:09.508]                     else if (inherits(cond, "condition")) {
[13:23:09.508]                       if (!is.null(pattern)) {
[13:23:09.508]                         computeRestarts <- base::computeRestarts
[13:23:09.508]                         grepl <- base::grepl
[13:23:09.508]                         restarts <- computeRestarts(cond)
[13:23:09.508]                         for (restart in restarts) {
[13:23:09.508]                           name <- restart$name
[13:23:09.508]                           if (is.null(name)) 
[13:23:09.508]                             next
[13:23:09.508]                           if (!grepl(pattern, name)) 
[13:23:09.508]                             next
[13:23:09.508]                           invokeRestart(restart)
[13:23:09.508]                           muffled <- TRUE
[13:23:09.508]                           break
[13:23:09.508]                         }
[13:23:09.508]                       }
[13:23:09.508]                     }
[13:23:09.508]                     invisible(muffled)
[13:23:09.508]                   }
[13:23:09.508]                   muffleCondition(cond)
[13:23:09.508]                 })
[13:23:09.508]             }))
[13:23:09.508]             future::FutureResult(value = ...future.value$value, 
[13:23:09.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.508]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.508]                     ...future.globalenv.names))
[13:23:09.508]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.508]         }, condition = base::local({
[13:23:09.508]             c <- base::c
[13:23:09.508]             inherits <- base::inherits
[13:23:09.508]             invokeRestart <- base::invokeRestart
[13:23:09.508]             length <- base::length
[13:23:09.508]             list <- base::list
[13:23:09.508]             seq.int <- base::seq.int
[13:23:09.508]             signalCondition <- base::signalCondition
[13:23:09.508]             sys.calls <- base::sys.calls
[13:23:09.508]             `[[` <- base::`[[`
[13:23:09.508]             `+` <- base::`+`
[13:23:09.508]             `<<-` <- base::`<<-`
[13:23:09.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.508]                   3L)]
[13:23:09.508]             }
[13:23:09.508]             function(cond) {
[13:23:09.508]                 is_error <- inherits(cond, "error")
[13:23:09.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.508]                   NULL)
[13:23:09.508]                 if (is_error) {
[13:23:09.508]                   sessionInformation <- function() {
[13:23:09.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.508]                       search = base::search(), system = base::Sys.info())
[13:23:09.508]                   }
[13:23:09.508]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.508]                     cond$call), session = sessionInformation(), 
[13:23:09.508]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.508]                   signalCondition(cond)
[13:23:09.508]                 }
[13:23:09.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.508]                 "immediateCondition"))) {
[13:23:09.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.508]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.508]                   if (TRUE && !signal) {
[13:23:09.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.508]                     {
[13:23:09.508]                       inherits <- base::inherits
[13:23:09.508]                       invokeRestart <- base::invokeRestart
[13:23:09.508]                       is.null <- base::is.null
[13:23:09.508]                       muffled <- FALSE
[13:23:09.508]                       if (inherits(cond, "message")) {
[13:23:09.508]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.508]                         if (muffled) 
[13:23:09.508]                           invokeRestart("muffleMessage")
[13:23:09.508]                       }
[13:23:09.508]                       else if (inherits(cond, "warning")) {
[13:23:09.508]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.508]                         if (muffled) 
[13:23:09.508]                           invokeRestart("muffleWarning")
[13:23:09.508]                       }
[13:23:09.508]                       else if (inherits(cond, "condition")) {
[13:23:09.508]                         if (!is.null(pattern)) {
[13:23:09.508]                           computeRestarts <- base::computeRestarts
[13:23:09.508]                           grepl <- base::grepl
[13:23:09.508]                           restarts <- computeRestarts(cond)
[13:23:09.508]                           for (restart in restarts) {
[13:23:09.508]                             name <- restart$name
[13:23:09.508]                             if (is.null(name)) 
[13:23:09.508]                               next
[13:23:09.508]                             if (!grepl(pattern, name)) 
[13:23:09.508]                               next
[13:23:09.508]                             invokeRestart(restart)
[13:23:09.508]                             muffled <- TRUE
[13:23:09.508]                             break
[13:23:09.508]                           }
[13:23:09.508]                         }
[13:23:09.508]                       }
[13:23:09.508]                       invisible(muffled)
[13:23:09.508]                     }
[13:23:09.508]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.508]                   }
[13:23:09.508]                 }
[13:23:09.508]                 else {
[13:23:09.508]                   if (TRUE) {
[13:23:09.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.508]                     {
[13:23:09.508]                       inherits <- base::inherits
[13:23:09.508]                       invokeRestart <- base::invokeRestart
[13:23:09.508]                       is.null <- base::is.null
[13:23:09.508]                       muffled <- FALSE
[13:23:09.508]                       if (inherits(cond, "message")) {
[13:23:09.508]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.508]                         if (muffled) 
[13:23:09.508]                           invokeRestart("muffleMessage")
[13:23:09.508]                       }
[13:23:09.508]                       else if (inherits(cond, "warning")) {
[13:23:09.508]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.508]                         if (muffled) 
[13:23:09.508]                           invokeRestart("muffleWarning")
[13:23:09.508]                       }
[13:23:09.508]                       else if (inherits(cond, "condition")) {
[13:23:09.508]                         if (!is.null(pattern)) {
[13:23:09.508]                           computeRestarts <- base::computeRestarts
[13:23:09.508]                           grepl <- base::grepl
[13:23:09.508]                           restarts <- computeRestarts(cond)
[13:23:09.508]                           for (restart in restarts) {
[13:23:09.508]                             name <- restart$name
[13:23:09.508]                             if (is.null(name)) 
[13:23:09.508]                               next
[13:23:09.508]                             if (!grepl(pattern, name)) 
[13:23:09.508]                               next
[13:23:09.508]                             invokeRestart(restart)
[13:23:09.508]                             muffled <- TRUE
[13:23:09.508]                             break
[13:23:09.508]                           }
[13:23:09.508]                         }
[13:23:09.508]                       }
[13:23:09.508]                       invisible(muffled)
[13:23:09.508]                     }
[13:23:09.508]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.508]                   }
[13:23:09.508]                 }
[13:23:09.508]             }
[13:23:09.508]         }))
[13:23:09.508]     }, error = function(ex) {
[13:23:09.508]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.508]                 ...future.rng), started = ...future.startTime, 
[13:23:09.508]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.508]             version = "1.8"), class = "FutureResult")
[13:23:09.508]     }, finally = {
[13:23:09.508]         if (!identical(...future.workdir, getwd())) 
[13:23:09.508]             setwd(...future.workdir)
[13:23:09.508]         {
[13:23:09.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.508]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.508]             }
[13:23:09.508]             base::options(...future.oldOptions)
[13:23:09.508]             if (.Platform$OS.type == "windows") {
[13:23:09.508]                 old_names <- names(...future.oldEnvVars)
[13:23:09.508]                 envs <- base::Sys.getenv()
[13:23:09.508]                 names <- names(envs)
[13:23:09.508]                 common <- intersect(names, old_names)
[13:23:09.508]                 added <- setdiff(names, old_names)
[13:23:09.508]                 removed <- setdiff(old_names, names)
[13:23:09.508]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.508]                   envs[common]]
[13:23:09.508]                 NAMES <- toupper(changed)
[13:23:09.508]                 args <- list()
[13:23:09.508]                 for (kk in seq_along(NAMES)) {
[13:23:09.508]                   name <- changed[[kk]]
[13:23:09.508]                   NAME <- NAMES[[kk]]
[13:23:09.508]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.508]                     next
[13:23:09.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.508]                 }
[13:23:09.508]                 NAMES <- toupper(added)
[13:23:09.508]                 for (kk in seq_along(NAMES)) {
[13:23:09.508]                   name <- added[[kk]]
[13:23:09.508]                   NAME <- NAMES[[kk]]
[13:23:09.508]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.508]                     next
[13:23:09.508]                   args[[name]] <- ""
[13:23:09.508]                 }
[13:23:09.508]                 NAMES <- toupper(removed)
[13:23:09.508]                 for (kk in seq_along(NAMES)) {
[13:23:09.508]                   name <- removed[[kk]]
[13:23:09.508]                   NAME <- NAMES[[kk]]
[13:23:09.508]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.508]                     next
[13:23:09.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.508]                 }
[13:23:09.508]                 if (length(args) > 0) 
[13:23:09.508]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.508]             }
[13:23:09.508]             else {
[13:23:09.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.508]             }
[13:23:09.508]             {
[13:23:09.508]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.508]                   0L) {
[13:23:09.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.508]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.508]                   base::options(opts)
[13:23:09.508]                 }
[13:23:09.508]                 {
[13:23:09.508]                   {
[13:23:09.508]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.508]                     NULL
[13:23:09.508]                   }
[13:23:09.508]                   options(future.plan = NULL)
[13:23:09.508]                   if (is.na(NA_character_)) 
[13:23:09.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.508]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.508]                     envir = parent.frame()) 
[13:23:09.508]                   {
[13:23:09.508]                     default_workers <- missing(workers)
[13:23:09.508]                     if (is.function(workers)) 
[13:23:09.508]                       workers <- workers()
[13:23:09.508]                     workers <- structure(as.integer(workers), 
[13:23:09.508]                       class = class(workers))
[13:23:09.508]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.508]                       1L)
[13:23:09.508]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.508]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.508]                       if (default_workers) 
[13:23:09.508]                         supportsMulticore(warn = TRUE)
[13:23:09.508]                       return(sequential(..., envir = envir))
[13:23:09.508]                     }
[13:23:09.508]                     oopts <- options(mc.cores = workers)
[13:23:09.508]                     on.exit(options(oopts))
[13:23:09.508]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.508]                       envir = envir)
[13:23:09.508]                     if (!future$lazy) 
[13:23:09.508]                       future <- run(future)
[13:23:09.508]                     invisible(future)
[13:23:09.508]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.508]                 }
[13:23:09.508]             }
[13:23:09.508]         }
[13:23:09.508]     })
[13:23:09.508]     if (TRUE) {
[13:23:09.508]         base::sink(type = "output", split = FALSE)
[13:23:09.508]         if (TRUE) {
[13:23:09.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.508]         }
[13:23:09.508]         else {
[13:23:09.508]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.508]         }
[13:23:09.508]         base::close(...future.stdout)
[13:23:09.508]         ...future.stdout <- NULL
[13:23:09.508]     }
[13:23:09.508]     ...future.result$conditions <- ...future.conditions
[13:23:09.508]     ...future.result$finished <- base::Sys.time()
[13:23:09.508]     ...future.result
[13:23:09.508] }
[13:23:09.512] requestCore(): workers = 2
[13:23:09.513] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:09.523] result() for MulticoreFuture ...
[13:23:09.525] result() for MulticoreFuture ...
[13:23:09.525] result() for MulticoreFuture ... done
[13:23:09.525] result() for MulticoreFuture ... done
[13:23:09.525] result() for MulticoreFuture ...
[13:23:09.525] result() for MulticoreFuture ... done
[13:23:09.528] MulticoreFuture started
[13:23:09.529] - Launch lazy future ... done
[13:23:09.529] run() for ‘MulticoreFuture’ ... done
[13:23:09.530] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5596d64caab8> 
[13:23:09.530] List of future strategies:
[13:23:09.530] 1. sequential:
[13:23:09.530]    - args: function (..., envir = parent.frame())
[13:23:09.530]    - tweaked: FALSE
[13:23:09.530]    - call: NULL
[13:23:09.531] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5596d717e928> 
 - attr(*, "dim.")=[13:23:09.534] plan(): Setting new future strategy stack:
 int [1:2] 1 6
 - attr(*, "dimnames.")=[13:23:09.534] List of future strategies:
[13:23:09.534] 1. multicore:
[13:23:09.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.534]    - tweaked: FALSE
[13:23:09.534]    - call: plan(strategy)
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:23:09.541] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:09.545] resolve() on list environment ...
[13:23:09.545]  recursive: 0
[13:23:09.546]  length: 6
[13:23:09.546]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:09.547] signalConditionsASAP(numeric, pos=1) ...
[13:23:09.547] - nx: 6
[13:23:09.547] - relay: TRUE
[13:23:09.547] - stdout: TRUE
[13:23:09.547] - signal: TRUE
[13:23:09.547] - resignal: FALSE
[13:23:09.547] - force: TRUE
[13:23:09.547] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.548] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.548]  - until=2
[13:23:09.548]  - relaying element #2
[13:23:09.548] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.548] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.548] signalConditionsASAP(NULL, pos=1) ... done
[13:23:09.548]  length: 5 (resolved future 1)
[13:23:09.549] Future #2
[13:23:09.549] result() for MulticoreFuture ...
[13:23:09.549] result() for MulticoreFuture ... done
[13:23:09.549] result() for MulticoreFuture ...
[13:23:09.549] result() for MulticoreFuture ... done
[13:23:09.549] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:09.550] - nx: 6
[13:23:09.550] - relay: TRUE
[13:23:09.550] - stdout: TRUE
[13:23:09.550] - signal: TRUE
[13:23:09.550] - resignal: FALSE
[13:23:09.550] - force: TRUE
[13:23:09.550] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.550] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.550]  - until=2
[13:23:09.551]  - relaying element #2
[13:23:09.551] result() for MulticoreFuture ...
[13:23:09.551] result() for MulticoreFuture ... done
[13:23:09.551] result() for MulticoreFuture ...
[13:23:09.551] result() for MulticoreFuture ... done
[13:23:09.551] result() for MulticoreFuture ...
[13:23:09.551] result() for MulticoreFuture ... done
[13:23:09.552] result() for MulticoreFuture ...
[13:23:09.552] result() for MulticoreFuture ... done
[13:23:09.552] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.552] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.552] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:09.552]  length: 4 (resolved future 2)
[13:23:09.553] Future #3
[13:23:09.553] result() for MulticoreFuture ...
[13:23:09.554] result() for MulticoreFuture ...
[13:23:09.554] result() for MulticoreFuture ... done
[13:23:09.554] result() for MulticoreFuture ... done
[13:23:09.554] result() for MulticoreFuture ...
[13:23:09.554] result() for MulticoreFuture ... done
[13:23:09.554] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:09.555] - nx: 6
[13:23:09.555] - relay: TRUE
[13:23:09.562] - stdout: TRUE
[13:23:09.563] - signal: TRUE
[13:23:09.563] - resignal: FALSE
[13:23:09.563] - force: TRUE
[13:23:09.564] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.564] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.564]  - until=3
[13:23:09.565]  - relaying element #3
[13:23:09.565] result() for MulticoreFuture ...
[13:23:09.565] result() for MulticoreFuture ... done
[13:23:09.565] result() for MulticoreFuture ...
[13:23:09.565] result() for MulticoreFuture ... done
[13:23:09.565] result() for MulticoreFuture ...
[13:23:09.566] result() for MulticoreFuture ... done
[13:23:09.566] result() for MulticoreFuture ...
[13:23:09.566] result() for MulticoreFuture ... done
[13:23:09.566] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.566] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.566] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:09.566]  length: 3 (resolved future 3)
[13:23:09.567] Future #4
[13:23:09.567] result() for MulticoreFuture ...
[13:23:09.568] result() for MulticoreFuture ...
[13:23:09.568] result() for MulticoreFuture ... done
[13:23:09.568] result() for MulticoreFuture ... done
[13:23:09.569] result() for MulticoreFuture ...
[13:23:09.569] result() for MulticoreFuture ... done
[13:23:09.569] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:09.569] - nx: 6
[13:23:09.569] - relay: TRUE
[13:23:09.569] - stdout: TRUE
[13:23:09.570] - signal: TRUE
[13:23:09.570] - resignal: FALSE
[13:23:09.570] - force: TRUE
[13:23:09.570] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.570] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.571]  - until=4
[13:23:09.571]  - relaying element #4
[13:23:09.571] result() for MulticoreFuture ...
[13:23:09.571] result() for MulticoreFuture ... done
[13:23:09.571] result() for MulticoreFuture ...
[13:23:09.571] result() for MulticoreFuture ... done
[13:23:09.572] result() for MulticoreFuture ...
[13:23:09.572] result() for MulticoreFuture ... done
[13:23:09.572] result() for MulticoreFuture ...
[13:23:09.572] result() for MulticoreFuture ... done
[13:23:09.572] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.572] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.573] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:09.573]  length: 2 (resolved future 4)
[13:23:09.573] signalConditionsASAP(NULL, pos=5) ...
[13:23:09.573] - nx: 6
[13:23:09.573] - relay: TRUE
[13:23:09.573] - stdout: TRUE
[13:23:09.574] - signal: TRUE
[13:23:09.574] - resignal: FALSE
[13:23:09.574] - force: TRUE
[13:23:09.574] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.574] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.574]  - until=6
[13:23:09.574]  - relaying element #6
[13:23:09.574] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.575] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.575] signalConditionsASAP(NULL, pos=5) ... done
[13:23:09.575]  length: 1 (resolved future 5)
[13:23:09.575] signalConditionsASAP(numeric, pos=6) ...
[13:23:09.575] - nx: 6
[13:23:09.575] - relay: TRUE
[13:23:09.575] - stdout: TRUE
[13:23:09.575] - signal: TRUE
[13:23:09.575] - resignal: FALSE
[13:23:09.576] - force: TRUE
[13:23:09.576] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.576] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.576]  - until=6
[13:23:09.576] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.576] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.577] signalConditionsASAP(numeric, pos=6) ... done
[13:23:09.577]  length: 0 (resolved future 6)
[13:23:09.577] Relaying remaining futures
[13:23:09.577] signalConditionsASAP(NULL, pos=0) ...
[13:23:09.577] - nx: 6
[13:23:09.577] - relay: TRUE
[13:23:09.577] - stdout: TRUE
[13:23:09.577] - signal: TRUE
[13:23:09.577] - resignal: FALSE
[13:23:09.578] - force: TRUE
[13:23:09.578] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.578] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:09.578] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.578] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.578] signalConditionsASAP(NULL, pos=0) ... done
[13:23:09.578] resolve() on list environment ... DONE
[13:23:09.578] result() for MulticoreFuture ...
[13:23:09.578] result() for MulticoreFuture ... done
[13:23:09.579] result() for MulticoreFuture ...
[13:23:09.579] result() for MulticoreFuture ... done
[13:23:09.579] result() for MulticoreFuture ...
[13:23:09.579] result() for MulticoreFuture ... done
[13:23:09.579] result() for MulticoreFuture ...
[13:23:09.579] result() for MulticoreFuture ... done
[13:23:09.579] result() for MulticoreFuture ...
[13:23:09.580] result() for MulticoreFuture ... done
[13:23:09.580] result() for MulticoreFuture ...
[13:23:09.580] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d73dc358> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:23:09.582] getGlobalsAndPackages() ...
[13:23:09.582] Searching for globals...
[13:23:09.583] 
[13:23:09.583] Searching for globals ... DONE
[13:23:09.583] - globals: [0] <none>
[13:23:09.583] getGlobalsAndPackages() ... DONE
[13:23:09.583] run() for ‘Future’ ...
[13:23:09.583] - state: ‘created’
[13:23:09.584] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.588]   - Field: ‘label’
[13:23:09.588]   - Field: ‘local’
[13:23:09.588]   - Field: ‘owner’
[13:23:09.589]   - Field: ‘envir’
[13:23:09.589]   - Field: ‘workers’
[13:23:09.589]   - Field: ‘packages’
[13:23:09.589]   - Field: ‘gc’
[13:23:09.589]   - Field: ‘job’
[13:23:09.589]   - Field: ‘conditions’
[13:23:09.589]   - Field: ‘expr’
[13:23:09.589]   - Field: ‘uuid’
[13:23:09.589]   - Field: ‘seed’
[13:23:09.590]   - Field: ‘version’
[13:23:09.590]   - Field: ‘result’
[13:23:09.590]   - Field: ‘asynchronous’
[13:23:09.590]   - Field: ‘calls’
[13:23:09.590]   - Field: ‘globals’
[13:23:09.590]   - Field: ‘stdout’
[13:23:09.590]   - Field: ‘earlySignal’
[13:23:09.590]   - Field: ‘lazy’
[13:23:09.590]   - Field: ‘state’
[13:23:09.591] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.591] - Launch lazy future ...
[13:23:09.591] Packages needed by the future expression (n = 0): <none>
[13:23:09.591] Packages needed by future strategies (n = 0): <none>
[13:23:09.592] {
[13:23:09.592]     {
[13:23:09.592]         {
[13:23:09.592]             ...future.startTime <- base::Sys.time()
[13:23:09.592]             {
[13:23:09.592]                 {
[13:23:09.592]                   {
[13:23:09.592]                     {
[13:23:09.592]                       base::local({
[13:23:09.592]                         has_future <- base::requireNamespace("future", 
[13:23:09.592]                           quietly = TRUE)
[13:23:09.592]                         if (has_future) {
[13:23:09.592]                           ns <- base::getNamespace("future")
[13:23:09.592]                           version <- ns[[".package"]][["version"]]
[13:23:09.592]                           if (is.null(version)) 
[13:23:09.592]                             version <- utils::packageVersion("future")
[13:23:09.592]                         }
[13:23:09.592]                         else {
[13:23:09.592]                           version <- NULL
[13:23:09.592]                         }
[13:23:09.592]                         if (!has_future || version < "1.8.0") {
[13:23:09.592]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.592]                             "", base::R.version$version.string), 
[13:23:09.592]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.592]                               "release", "version")], collapse = " "), 
[13:23:09.592]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.592]                             info)
[13:23:09.592]                           info <- base::paste(info, collapse = "; ")
[13:23:09.592]                           if (!has_future) {
[13:23:09.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.592]                               info)
[13:23:09.592]                           }
[13:23:09.592]                           else {
[13:23:09.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.592]                               info, version)
[13:23:09.592]                           }
[13:23:09.592]                           base::stop(msg)
[13:23:09.592]                         }
[13:23:09.592]                       })
[13:23:09.592]                     }
[13:23:09.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.592]                     base::options(mc.cores = 1L)
[13:23:09.592]                   }
[13:23:09.592]                   options(future.plan = NULL)
[13:23:09.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.592]                 }
[13:23:09.592]                 ...future.workdir <- getwd()
[13:23:09.592]             }
[13:23:09.592]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.592]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.592]         }
[13:23:09.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.592]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.592]             base::names(...future.oldOptions))
[13:23:09.592]     }
[13:23:09.592]     if (FALSE) {
[13:23:09.592]     }
[13:23:09.592]     else {
[13:23:09.592]         if (TRUE) {
[13:23:09.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.592]                 open = "w")
[13:23:09.592]         }
[13:23:09.592]         else {
[13:23:09.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.592]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.592]         }
[13:23:09.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.592]             base::sink(type = "output", split = FALSE)
[13:23:09.592]             base::close(...future.stdout)
[13:23:09.592]         }, add = TRUE)
[13:23:09.592]     }
[13:23:09.592]     ...future.frame <- base::sys.nframe()
[13:23:09.592]     ...future.conditions <- base::list()
[13:23:09.592]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.592]     if (FALSE) {
[13:23:09.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.592]     }
[13:23:09.592]     ...future.result <- base::tryCatch({
[13:23:09.592]         base::withCallingHandlers({
[13:23:09.592]             ...future.value <- base::withVisible(base::local({
[13:23:09.592]                 withCallingHandlers({
[13:23:09.592]                   2
[13:23:09.592]                 }, immediateCondition = function(cond) {
[13:23:09.592]                   save_rds <- function (object, pathname, ...) 
[13:23:09.592]                   {
[13:23:09.592]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.592]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.592]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.592]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.592]                         fi_tmp[["mtime"]])
[13:23:09.592]                     }
[13:23:09.592]                     tryCatch({
[13:23:09.592]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.592]                     }, error = function(ex) {
[13:23:09.592]                       msg <- conditionMessage(ex)
[13:23:09.592]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.592]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.592]                         fi_tmp[["mtime"]], msg)
[13:23:09.592]                       ex$message <- msg
[13:23:09.592]                       stop(ex)
[13:23:09.592]                     })
[13:23:09.592]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.592]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.592]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.592]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.592]                       fi <- file.info(pathname)
[13:23:09.592]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.592]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.592]                         fi[["size"]], fi[["mtime"]])
[13:23:09.592]                       stop(msg)
[13:23:09.592]                     }
[13:23:09.592]                     invisible(pathname)
[13:23:09.592]                   }
[13:23:09.592]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.592]                     rootPath = tempdir()) 
[13:23:09.592]                   {
[13:23:09.592]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.592]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.592]                       tmpdir = path, fileext = ".rds")
[13:23:09.592]                     save_rds(obj, file)
[13:23:09.592]                   }
[13:23:09.592]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.592]                   {
[13:23:09.592]                     inherits <- base::inherits
[13:23:09.592]                     invokeRestart <- base::invokeRestart
[13:23:09.592]                     is.null <- base::is.null
[13:23:09.592]                     muffled <- FALSE
[13:23:09.592]                     if (inherits(cond, "message")) {
[13:23:09.592]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.592]                       if (muffled) 
[13:23:09.592]                         invokeRestart("muffleMessage")
[13:23:09.592]                     }
[13:23:09.592]                     else if (inherits(cond, "warning")) {
[13:23:09.592]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.592]                       if (muffled) 
[13:23:09.592]                         invokeRestart("muffleWarning")
[13:23:09.592]                     }
[13:23:09.592]                     else if (inherits(cond, "condition")) {
[13:23:09.592]                       if (!is.null(pattern)) {
[13:23:09.592]                         computeRestarts <- base::computeRestarts
[13:23:09.592]                         grepl <- base::grepl
[13:23:09.592]                         restarts <- computeRestarts(cond)
[13:23:09.592]                         for (restart in restarts) {
[13:23:09.592]                           name <- restart$name
[13:23:09.592]                           if (is.null(name)) 
[13:23:09.592]                             next
[13:23:09.592]                           if (!grepl(pattern, name)) 
[13:23:09.592]                             next
[13:23:09.592]                           invokeRestart(restart)
[13:23:09.592]                           muffled <- TRUE
[13:23:09.592]                           break
[13:23:09.592]                         }
[13:23:09.592]                       }
[13:23:09.592]                     }
[13:23:09.592]                     invisible(muffled)
[13:23:09.592]                   }
[13:23:09.592]                   muffleCondition(cond)
[13:23:09.592]                 })
[13:23:09.592]             }))
[13:23:09.592]             future::FutureResult(value = ...future.value$value, 
[13:23:09.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.592]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.592]                     ...future.globalenv.names))
[13:23:09.592]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.592]         }, condition = base::local({
[13:23:09.592]             c <- base::c
[13:23:09.592]             inherits <- base::inherits
[13:23:09.592]             invokeRestart <- base::invokeRestart
[13:23:09.592]             length <- base::length
[13:23:09.592]             list <- base::list
[13:23:09.592]             seq.int <- base::seq.int
[13:23:09.592]             signalCondition <- base::signalCondition
[13:23:09.592]             sys.calls <- base::sys.calls
[13:23:09.592]             `[[` <- base::`[[`
[13:23:09.592]             `+` <- base::`+`
[13:23:09.592]             `<<-` <- base::`<<-`
[13:23:09.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.592]                   3L)]
[13:23:09.592]             }
[13:23:09.592]             function(cond) {
[13:23:09.592]                 is_error <- inherits(cond, "error")
[13:23:09.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.592]                   NULL)
[13:23:09.592]                 if (is_error) {
[13:23:09.592]                   sessionInformation <- function() {
[13:23:09.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.592]                       search = base::search(), system = base::Sys.info())
[13:23:09.592]                   }
[13:23:09.592]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.592]                     cond$call), session = sessionInformation(), 
[13:23:09.592]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.592]                   signalCondition(cond)
[13:23:09.592]                 }
[13:23:09.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.592]                 "immediateCondition"))) {
[13:23:09.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.592]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.592]                   if (TRUE && !signal) {
[13:23:09.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.592]                     {
[13:23:09.592]                       inherits <- base::inherits
[13:23:09.592]                       invokeRestart <- base::invokeRestart
[13:23:09.592]                       is.null <- base::is.null
[13:23:09.592]                       muffled <- FALSE
[13:23:09.592]                       if (inherits(cond, "message")) {
[13:23:09.592]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.592]                         if (muffled) 
[13:23:09.592]                           invokeRestart("muffleMessage")
[13:23:09.592]                       }
[13:23:09.592]                       else if (inherits(cond, "warning")) {
[13:23:09.592]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.592]                         if (muffled) 
[13:23:09.592]                           invokeRestart("muffleWarning")
[13:23:09.592]                       }
[13:23:09.592]                       else if (inherits(cond, "condition")) {
[13:23:09.592]                         if (!is.null(pattern)) {
[13:23:09.592]                           computeRestarts <- base::computeRestarts
[13:23:09.592]                           grepl <- base::grepl
[13:23:09.592]                           restarts <- computeRestarts(cond)
[13:23:09.592]                           for (restart in restarts) {
[13:23:09.592]                             name <- restart$name
[13:23:09.592]                             if (is.null(name)) 
[13:23:09.592]                               next
[13:23:09.592]                             if (!grepl(pattern, name)) 
[13:23:09.592]                               next
[13:23:09.592]                             invokeRestart(restart)
[13:23:09.592]                             muffled <- TRUE
[13:23:09.592]                             break
[13:23:09.592]                           }
[13:23:09.592]                         }
[13:23:09.592]                       }
[13:23:09.592]                       invisible(muffled)
[13:23:09.592]                     }
[13:23:09.592]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.592]                   }
[13:23:09.592]                 }
[13:23:09.592]                 else {
[13:23:09.592]                   if (TRUE) {
[13:23:09.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.592]                     {
[13:23:09.592]                       inherits <- base::inherits
[13:23:09.592]                       invokeRestart <- base::invokeRestart
[13:23:09.592]                       is.null <- base::is.null
[13:23:09.592]                       muffled <- FALSE
[13:23:09.592]                       if (inherits(cond, "message")) {
[13:23:09.592]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.592]                         if (muffled) 
[13:23:09.592]                           invokeRestart("muffleMessage")
[13:23:09.592]                       }
[13:23:09.592]                       else if (inherits(cond, "warning")) {
[13:23:09.592]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.592]                         if (muffled) 
[13:23:09.592]                           invokeRestart("muffleWarning")
[13:23:09.592]                       }
[13:23:09.592]                       else if (inherits(cond, "condition")) {
[13:23:09.592]                         if (!is.null(pattern)) {
[13:23:09.592]                           computeRestarts <- base::computeRestarts
[13:23:09.592]                           grepl <- base::grepl
[13:23:09.592]                           restarts <- computeRestarts(cond)
[13:23:09.592]                           for (restart in restarts) {
[13:23:09.592]                             name <- restart$name
[13:23:09.592]                             if (is.null(name)) 
[13:23:09.592]                               next
[13:23:09.592]                             if (!grepl(pattern, name)) 
[13:23:09.592]                               next
[13:23:09.592]                             invokeRestart(restart)
[13:23:09.592]                             muffled <- TRUE
[13:23:09.592]                             break
[13:23:09.592]                           }
[13:23:09.592]                         }
[13:23:09.592]                       }
[13:23:09.592]                       invisible(muffled)
[13:23:09.592]                     }
[13:23:09.592]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.592]                   }
[13:23:09.592]                 }
[13:23:09.592]             }
[13:23:09.592]         }))
[13:23:09.592]     }, error = function(ex) {
[13:23:09.592]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.592]                 ...future.rng), started = ...future.startTime, 
[13:23:09.592]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.592]             version = "1.8"), class = "FutureResult")
[13:23:09.592]     }, finally = {
[13:23:09.592]         if (!identical(...future.workdir, getwd())) 
[13:23:09.592]             setwd(...future.workdir)
[13:23:09.592]         {
[13:23:09.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.592]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.592]             }
[13:23:09.592]             base::options(...future.oldOptions)
[13:23:09.592]             if (.Platform$OS.type == "windows") {
[13:23:09.592]                 old_names <- names(...future.oldEnvVars)
[13:23:09.592]                 envs <- base::Sys.getenv()
[13:23:09.592]                 names <- names(envs)
[13:23:09.592]                 common <- intersect(names, old_names)
[13:23:09.592]                 added <- setdiff(names, old_names)
[13:23:09.592]                 removed <- setdiff(old_names, names)
[13:23:09.592]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.592]                   envs[common]]
[13:23:09.592]                 NAMES <- toupper(changed)
[13:23:09.592]                 args <- list()
[13:23:09.592]                 for (kk in seq_along(NAMES)) {
[13:23:09.592]                   name <- changed[[kk]]
[13:23:09.592]                   NAME <- NAMES[[kk]]
[13:23:09.592]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.592]                     next
[13:23:09.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.592]                 }
[13:23:09.592]                 NAMES <- toupper(added)
[13:23:09.592]                 for (kk in seq_along(NAMES)) {
[13:23:09.592]                   name <- added[[kk]]
[13:23:09.592]                   NAME <- NAMES[[kk]]
[13:23:09.592]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.592]                     next
[13:23:09.592]                   args[[name]] <- ""
[13:23:09.592]                 }
[13:23:09.592]                 NAMES <- toupper(removed)
[13:23:09.592]                 for (kk in seq_along(NAMES)) {
[13:23:09.592]                   name <- removed[[kk]]
[13:23:09.592]                   NAME <- NAMES[[kk]]
[13:23:09.592]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.592]                     next
[13:23:09.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.592]                 }
[13:23:09.592]                 if (length(args) > 0) 
[13:23:09.592]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.592]             }
[13:23:09.592]             else {
[13:23:09.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.592]             }
[13:23:09.592]             {
[13:23:09.592]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.592]                   0L) {
[13:23:09.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.592]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.592]                   base::options(opts)
[13:23:09.592]                 }
[13:23:09.592]                 {
[13:23:09.592]                   {
[13:23:09.592]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.592]                     NULL
[13:23:09.592]                   }
[13:23:09.592]                   options(future.plan = NULL)
[13:23:09.592]                   if (is.na(NA_character_)) 
[13:23:09.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.592]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.592]                     envir = parent.frame()) 
[13:23:09.592]                   {
[13:23:09.592]                     default_workers <- missing(workers)
[13:23:09.592]                     if (is.function(workers)) 
[13:23:09.592]                       workers <- workers()
[13:23:09.592]                     workers <- structure(as.integer(workers), 
[13:23:09.592]                       class = class(workers))
[13:23:09.592]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.592]                       1L)
[13:23:09.592]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.592]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.592]                       if (default_workers) 
[13:23:09.592]                         supportsMulticore(warn = TRUE)
[13:23:09.592]                       return(sequential(..., envir = envir))
[13:23:09.592]                     }
[13:23:09.592]                     oopts <- options(mc.cores = workers)
[13:23:09.592]                     on.exit(options(oopts))
[13:23:09.592]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.592]                       envir = envir)
[13:23:09.592]                     if (!future$lazy) 
[13:23:09.592]                       future <- run(future)
[13:23:09.592]                     invisible(future)
[13:23:09.592]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.592]                 }
[13:23:09.592]             }
[13:23:09.592]         }
[13:23:09.592]     })
[13:23:09.592]     if (TRUE) {
[13:23:09.592]         base::sink(type = "output", split = FALSE)
[13:23:09.592]         if (TRUE) {
[13:23:09.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.592]         }
[13:23:09.592]         else {
[13:23:09.592]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.592]         }
[13:23:09.592]         base::close(...future.stdout)
[13:23:09.592]         ...future.stdout <- NULL
[13:23:09.592]     }
[13:23:09.592]     ...future.result$conditions <- ...future.conditions
[13:23:09.592]     ...future.result$finished <- base::Sys.time()
[13:23:09.592]     ...future.result
[13:23:09.592] }
[13:23:09.594] requestCore(): workers = 2
[13:23:09.598] MulticoreFuture started
[13:23:09.598] - Launch lazy future ... done
[13:23:09.598] run() for ‘MulticoreFuture’ ... done
[13:23:09.599] getGlobalsAndPackages() ...
[13:23:09.599] plan(): Setting new future strategy stack:
[13:23:09.599] Searching for globals...
[13:23:09.599] List of future strategies:
[13:23:09.599] 1. sequential:
[13:23:09.599]    - args: function (..., envir = parent.frame())
[13:23:09.599]    - tweaked: FALSE
[13:23:09.599]    - call: NULL
[13:23:09.600] 
[13:23:09.600] Searching for globals ... DONE
[13:23:09.600] plan(): nbrOfWorkers() = 1
[13:23:09.600] - globals: [0] <none>
[13:23:09.600] getGlobalsAndPackages() ... DONE
[13:23:09.601] run() for ‘Future’ ...
[13:23:09.601] - state: ‘created’
[13:23:09.601] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.602] plan(): Setting new future strategy stack:
[13:23:09.602] List of future strategies:
[13:23:09.602] 1. multicore:
[13:23:09.602]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.602]    - tweaked: FALSE
[13:23:09.602]    - call: plan(strategy)
[13:23:09.607] plan(): nbrOfWorkers() = 2
[13:23:09.607] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.607]   - Field: ‘label’
[13:23:09.608]   - Field: ‘local’
[13:23:09.608]   - Field: ‘owner’
[13:23:09.608]   - Field: ‘envir’
[13:23:09.608]   - Field: ‘workers’
[13:23:09.608]   - Field: ‘packages’
[13:23:09.609]   - Field: ‘gc’
[13:23:09.609]   - Field: ‘job’
[13:23:09.609]   - Field: ‘conditions’
[13:23:09.609]   - Field: ‘expr’
[13:23:09.609]   - Field: ‘uuid’
[13:23:09.609]   - Field: ‘seed’
[13:23:09.610]   - Field: ‘version’
[13:23:09.610]   - Field: ‘result’
[13:23:09.610]   - Field: ‘asynchronous’
[13:23:09.610]   - Field: ‘calls’
[13:23:09.610]   - Field: ‘globals’
[13:23:09.611]   - Field: ‘stdout’
[13:23:09.611]   - Field: ‘earlySignal’
[13:23:09.611]   - Field: ‘lazy’
[13:23:09.611]   - Field: ‘state’
[13:23:09.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.612] - Launch lazy future ...
[13:23:09.612] Packages needed by the future expression (n = 0): <none>
[13:23:09.612] Packages needed by future strategies (n = 0): <none>
[13:23:09.613] {
[13:23:09.613]     {
[13:23:09.613]         {
[13:23:09.613]             ...future.startTime <- base::Sys.time()
[13:23:09.613]             {
[13:23:09.613]                 {
[13:23:09.613]                   {
[13:23:09.613]                     {
[13:23:09.613]                       base::local({
[13:23:09.613]                         has_future <- base::requireNamespace("future", 
[13:23:09.613]                           quietly = TRUE)
[13:23:09.613]                         if (has_future) {
[13:23:09.613]                           ns <- base::getNamespace("future")
[13:23:09.613]                           version <- ns[[".package"]][["version"]]
[13:23:09.613]                           if (is.null(version)) 
[13:23:09.613]                             version <- utils::packageVersion("future")
[13:23:09.613]                         }
[13:23:09.613]                         else {
[13:23:09.613]                           version <- NULL
[13:23:09.613]                         }
[13:23:09.613]                         if (!has_future || version < "1.8.0") {
[13:23:09.613]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.613]                             "", base::R.version$version.string), 
[13:23:09.613]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.613]                               "release", "version")], collapse = " "), 
[13:23:09.613]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.613]                             info)
[13:23:09.613]                           info <- base::paste(info, collapse = "; ")
[13:23:09.613]                           if (!has_future) {
[13:23:09.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.613]                               info)
[13:23:09.613]                           }
[13:23:09.613]                           else {
[13:23:09.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.613]                               info, version)
[13:23:09.613]                           }
[13:23:09.613]                           base::stop(msg)
[13:23:09.613]                         }
[13:23:09.613]                       })
[13:23:09.613]                     }
[13:23:09.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.613]                     base::options(mc.cores = 1L)
[13:23:09.613]                   }
[13:23:09.613]                   options(future.plan = NULL)
[13:23:09.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.613]                 }
[13:23:09.613]                 ...future.workdir <- getwd()
[13:23:09.613]             }
[13:23:09.613]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.613]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.613]         }
[13:23:09.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.613]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.613]             base::names(...future.oldOptions))
[13:23:09.613]     }
[13:23:09.613]     if (FALSE) {
[13:23:09.613]     }
[13:23:09.613]     else {
[13:23:09.613]         if (TRUE) {
[13:23:09.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.613]                 open = "w")
[13:23:09.613]         }
[13:23:09.613]         else {
[13:23:09.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.613]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.613]         }
[13:23:09.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.613]             base::sink(type = "output", split = FALSE)
[13:23:09.613]             base::close(...future.stdout)
[13:23:09.613]         }, add = TRUE)
[13:23:09.613]     }
[13:23:09.613]     ...future.frame <- base::sys.nframe()
[13:23:09.613]     ...future.conditions <- base::list()
[13:23:09.613]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.613]     if (FALSE) {
[13:23:09.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.613]     }
[13:23:09.613]     ...future.result <- base::tryCatch({
[13:23:09.613]         base::withCallingHandlers({
[13:23:09.613]             ...future.value <- base::withVisible(base::local({
[13:23:09.613]                 withCallingHandlers({
[13:23:09.613]                   NULL
[13:23:09.613]                 }, immediateCondition = function(cond) {
[13:23:09.613]                   save_rds <- function (object, pathname, ...) 
[13:23:09.613]                   {
[13:23:09.613]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.613]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.613]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.613]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.613]                         fi_tmp[["mtime"]])
[13:23:09.613]                     }
[13:23:09.613]                     tryCatch({
[13:23:09.613]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.613]                     }, error = function(ex) {
[13:23:09.613]                       msg <- conditionMessage(ex)
[13:23:09.613]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.613]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.613]                         fi_tmp[["mtime"]], msg)
[13:23:09.613]                       ex$message <- msg
[13:23:09.613]                       stop(ex)
[13:23:09.613]                     })
[13:23:09.613]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.613]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.613]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.613]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.613]                       fi <- file.info(pathname)
[13:23:09.613]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.613]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.613]                         fi[["size"]], fi[["mtime"]])
[13:23:09.613]                       stop(msg)
[13:23:09.613]                     }
[13:23:09.613]                     invisible(pathname)
[13:23:09.613]                   }
[13:23:09.613]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.613]                     rootPath = tempdir()) 
[13:23:09.613]                   {
[13:23:09.613]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.613]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.613]                       tmpdir = path, fileext = ".rds")
[13:23:09.613]                     save_rds(obj, file)
[13:23:09.613]                   }
[13:23:09.613]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.613]                   {
[13:23:09.613]                     inherits <- base::inherits
[13:23:09.613]                     invokeRestart <- base::invokeRestart
[13:23:09.613]                     is.null <- base::is.null
[13:23:09.613]                     muffled <- FALSE
[13:23:09.613]                     if (inherits(cond, "message")) {
[13:23:09.613]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.613]                       if (muffled) 
[13:23:09.613]                         invokeRestart("muffleMessage")
[13:23:09.613]                     }
[13:23:09.613]                     else if (inherits(cond, "warning")) {
[13:23:09.613]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.613]                       if (muffled) 
[13:23:09.613]                         invokeRestart("muffleWarning")
[13:23:09.613]                     }
[13:23:09.613]                     else if (inherits(cond, "condition")) {
[13:23:09.613]                       if (!is.null(pattern)) {
[13:23:09.613]                         computeRestarts <- base::computeRestarts
[13:23:09.613]                         grepl <- base::grepl
[13:23:09.613]                         restarts <- computeRestarts(cond)
[13:23:09.613]                         for (restart in restarts) {
[13:23:09.613]                           name <- restart$name
[13:23:09.613]                           if (is.null(name)) 
[13:23:09.613]                             next
[13:23:09.613]                           if (!grepl(pattern, name)) 
[13:23:09.613]                             next
[13:23:09.613]                           invokeRestart(restart)
[13:23:09.613]                           muffled <- TRUE
[13:23:09.613]                           break
[13:23:09.613]                         }
[13:23:09.613]                       }
[13:23:09.613]                     }
[13:23:09.613]                     invisible(muffled)
[13:23:09.613]                   }
[13:23:09.613]                   muffleCondition(cond)
[13:23:09.613]                 })
[13:23:09.613]             }))
[13:23:09.613]             future::FutureResult(value = ...future.value$value, 
[13:23:09.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.613]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.613]                     ...future.globalenv.names))
[13:23:09.613]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.613]         }, condition = base::local({
[13:23:09.613]             c <- base::c
[13:23:09.613]             inherits <- base::inherits
[13:23:09.613]             invokeRestart <- base::invokeRestart
[13:23:09.613]             length <- base::length
[13:23:09.613]             list <- base::list
[13:23:09.613]             seq.int <- base::seq.int
[13:23:09.613]             signalCondition <- base::signalCondition
[13:23:09.613]             sys.calls <- base::sys.calls
[13:23:09.613]             `[[` <- base::`[[`
[13:23:09.613]             `+` <- base::`+`
[13:23:09.613]             `<<-` <- base::`<<-`
[13:23:09.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.613]                   3L)]
[13:23:09.613]             }
[13:23:09.613]             function(cond) {
[13:23:09.613]                 is_error <- inherits(cond, "error")
[13:23:09.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.613]                   NULL)
[13:23:09.613]                 if (is_error) {
[13:23:09.613]                   sessionInformation <- function() {
[13:23:09.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.613]                       search = base::search(), system = base::Sys.info())
[13:23:09.613]                   }
[13:23:09.613]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.613]                     cond$call), session = sessionInformation(), 
[13:23:09.613]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.613]                   signalCondition(cond)
[13:23:09.613]                 }
[13:23:09.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.613]                 "immediateCondition"))) {
[13:23:09.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.613]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.613]                   if (TRUE && !signal) {
[13:23:09.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.613]                     {
[13:23:09.613]                       inherits <- base::inherits
[13:23:09.613]                       invokeRestart <- base::invokeRestart
[13:23:09.613]                       is.null <- base::is.null
[13:23:09.613]                       muffled <- FALSE
[13:23:09.613]                       if (inherits(cond, "message")) {
[13:23:09.613]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.613]                         if (muffled) 
[13:23:09.613]                           invokeRestart("muffleMessage")
[13:23:09.613]                       }
[13:23:09.613]                       else if (inherits(cond, "warning")) {
[13:23:09.613]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.613]                         if (muffled) 
[13:23:09.613]                           invokeRestart("muffleWarning")
[13:23:09.613]                       }
[13:23:09.613]                       else if (inherits(cond, "condition")) {
[13:23:09.613]                         if (!is.null(pattern)) {
[13:23:09.613]                           computeRestarts <- base::computeRestarts
[13:23:09.613]                           grepl <- base::grepl
[13:23:09.613]                           restarts <- computeRestarts(cond)
[13:23:09.613]                           for (restart in restarts) {
[13:23:09.613]                             name <- restart$name
[13:23:09.613]                             if (is.null(name)) 
[13:23:09.613]                               next
[13:23:09.613]                             if (!grepl(pattern, name)) 
[13:23:09.613]                               next
[13:23:09.613]                             invokeRestart(restart)
[13:23:09.613]                             muffled <- TRUE
[13:23:09.613]                             break
[13:23:09.613]                           }
[13:23:09.613]                         }
[13:23:09.613]                       }
[13:23:09.613]                       invisible(muffled)
[13:23:09.613]                     }
[13:23:09.613]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.613]                   }
[13:23:09.613]                 }
[13:23:09.613]                 else {
[13:23:09.613]                   if (TRUE) {
[13:23:09.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.613]                     {
[13:23:09.613]                       inherits <- base::inherits
[13:23:09.613]                       invokeRestart <- base::invokeRestart
[13:23:09.613]                       is.null <- base::is.null
[13:23:09.613]                       muffled <- FALSE
[13:23:09.613]                       if (inherits(cond, "message")) {
[13:23:09.613]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.613]                         if (muffled) 
[13:23:09.613]                           invokeRestart("muffleMessage")
[13:23:09.613]                       }
[13:23:09.613]                       else if (inherits(cond, "warning")) {
[13:23:09.613]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.613]                         if (muffled) 
[13:23:09.613]                           invokeRestart("muffleWarning")
[13:23:09.613]                       }
[13:23:09.613]                       else if (inherits(cond, "condition")) {
[13:23:09.613]                         if (!is.null(pattern)) {
[13:23:09.613]                           computeRestarts <- base::computeRestarts
[13:23:09.613]                           grepl <- base::grepl
[13:23:09.613]                           restarts <- computeRestarts(cond)
[13:23:09.613]                           for (restart in restarts) {
[13:23:09.613]                             name <- restart$name
[13:23:09.613]                             if (is.null(name)) 
[13:23:09.613]                               next
[13:23:09.613]                             if (!grepl(pattern, name)) 
[13:23:09.613]                               next
[13:23:09.613]                             invokeRestart(restart)
[13:23:09.613]                             muffled <- TRUE
[13:23:09.613]                             break
[13:23:09.613]                           }
[13:23:09.613]                         }
[13:23:09.613]                       }
[13:23:09.613]                       invisible(muffled)
[13:23:09.613]                     }
[13:23:09.613]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.613]                   }
[13:23:09.613]                 }
[13:23:09.613]             }
[13:23:09.613]         }))
[13:23:09.613]     }, error = function(ex) {
[13:23:09.613]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.613]                 ...future.rng), started = ...future.startTime, 
[13:23:09.613]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.613]             version = "1.8"), class = "FutureResult")
[13:23:09.613]     }, finally = {
[13:23:09.613]         if (!identical(...future.workdir, getwd())) 
[13:23:09.613]             setwd(...future.workdir)
[13:23:09.613]         {
[13:23:09.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.613]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.613]             }
[13:23:09.613]             base::options(...future.oldOptions)
[13:23:09.613]             if (.Platform$OS.type == "windows") {
[13:23:09.613]                 old_names <- names(...future.oldEnvVars)
[13:23:09.613]                 envs <- base::Sys.getenv()
[13:23:09.613]                 names <- names(envs)
[13:23:09.613]                 common <- intersect(names, old_names)
[13:23:09.613]                 added <- setdiff(names, old_names)
[13:23:09.613]                 removed <- setdiff(old_names, names)
[13:23:09.613]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.613]                   envs[common]]
[13:23:09.613]                 NAMES <- toupper(changed)
[13:23:09.613]                 args <- list()
[13:23:09.613]                 for (kk in seq_along(NAMES)) {
[13:23:09.613]                   name <- changed[[kk]]
[13:23:09.613]                   NAME <- NAMES[[kk]]
[13:23:09.613]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.613]                     next
[13:23:09.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.613]                 }
[13:23:09.613]                 NAMES <- toupper(added)
[13:23:09.613]                 for (kk in seq_along(NAMES)) {
[13:23:09.613]                   name <- added[[kk]]
[13:23:09.613]                   NAME <- NAMES[[kk]]
[13:23:09.613]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.613]                     next
[13:23:09.613]                   args[[name]] <- ""
[13:23:09.613]                 }
[13:23:09.613]                 NAMES <- toupper(removed)
[13:23:09.613]                 for (kk in seq_along(NAMES)) {
[13:23:09.613]                   name <- removed[[kk]]
[13:23:09.613]                   NAME <- NAMES[[kk]]
[13:23:09.613]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.613]                     next
[13:23:09.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.613]                 }
[13:23:09.613]                 if (length(args) > 0) 
[13:23:09.613]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.613]             }
[13:23:09.613]             else {
[13:23:09.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.613]             }
[13:23:09.613]             {
[13:23:09.613]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.613]                   0L) {
[13:23:09.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.613]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.613]                   base::options(opts)
[13:23:09.613]                 }
[13:23:09.613]                 {
[13:23:09.613]                   {
[13:23:09.613]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.613]                     NULL
[13:23:09.613]                   }
[13:23:09.613]                   options(future.plan = NULL)
[13:23:09.613]                   if (is.na(NA_character_)) 
[13:23:09.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.613]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.613]                     envir = parent.frame()) 
[13:23:09.613]                   {
[13:23:09.613]                     default_workers <- missing(workers)
[13:23:09.613]                     if (is.function(workers)) 
[13:23:09.613]                       workers <- workers()
[13:23:09.613]                     workers <- structure(as.integer(workers), 
[13:23:09.613]                       class = class(workers))
[13:23:09.613]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.613]                       1L)
[13:23:09.613]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.613]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.613]                       if (default_workers) 
[13:23:09.613]                         supportsMulticore(warn = TRUE)
[13:23:09.613]                       return(sequential(..., envir = envir))
[13:23:09.613]                     }
[13:23:09.613]                     oopts <- options(mc.cores = workers)
[13:23:09.613]                     on.exit(options(oopts))
[13:23:09.613]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.613]                       envir = envir)
[13:23:09.613]                     if (!future$lazy) 
[13:23:09.613]                       future <- run(future)
[13:23:09.613]                     invisible(future)
[13:23:09.613]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.613]                 }
[13:23:09.613]             }
[13:23:09.613]         }
[13:23:09.613]     })
[13:23:09.613]     if (TRUE) {
[13:23:09.613]         base::sink(type = "output", split = FALSE)
[13:23:09.613]         if (TRUE) {
[13:23:09.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.613]         }
[13:23:09.613]         else {
[13:23:09.613]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.613]         }
[13:23:09.613]         base::close(...future.stdout)
[13:23:09.613]         ...future.stdout <- NULL
[13:23:09.613]     }
[13:23:09.613]     ...future.result$conditions <- ...future.conditions
[13:23:09.613]     ...future.result$finished <- base::Sys.time()
[13:23:09.613]     ...future.result
[13:23:09.613] }
[13:23:09.618] requestCore(): workers = 2
[13:23:09.621] MulticoreFuture started
[13:23:09.622] - Launch lazy future ... done
[13:23:09.622] run() for ‘MulticoreFuture’ ... done
[13:23:09.622] plan(): Setting new future strategy stack:
[13:23:09.623] getGlobalsAndPackages() ...
[13:23:09.623] Searching for globals...
[13:23:09.623] List of future strategies:
[13:23:09.623] 1. sequential:
[13:23:09.623]    - args: function (..., envir = parent.frame())
[13:23:09.623]    - tweaked: FALSE
[13:23:09.623]    - call: NULL
[13:23:09.624] plan(): nbrOfWorkers() = 1
[13:23:09.625] - globals found: [1] ‘{’
[13:23:09.625] Searching for globals ... DONE
[13:23:09.625] Resolving globals: FALSE
[13:23:09.626] 
[13:23:09.626] plan(): Setting new future strategy stack:
[13:23:09.626] 
[13:23:09.626] getGlobalsAndPackages() ... DONE
[13:23:09.626] List of future strategies:
[13:23:09.626] 1. multicore:
[13:23:09.626]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.626]    - tweaked: FALSE
[13:23:09.626]    - call: plan(strategy)
[13:23:09.627] run() for ‘Future’ ...
[13:23:09.627] - state: ‘created’
[13:23:09.627] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.632] plan(): nbrOfWorkers() = 2
[13:23:09.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.633]   - Field: ‘label’
[13:23:09.634]   - Field: ‘local’
[13:23:09.634]   - Field: ‘owner’
[13:23:09.634]   - Field: ‘envir’
[13:23:09.634]   - Field: ‘workers’
[13:23:09.634]   - Field: ‘packages’
[13:23:09.634]   - Field: ‘gc’
[13:23:09.635]   - Field: ‘job’
[13:23:09.635]   - Field: ‘conditions’
[13:23:09.635]   - Field: ‘expr’
[13:23:09.635]   - Field: ‘uuid’
[13:23:09.635]   - Field: ‘seed’
[13:23:09.635]   - Field: ‘version’
[13:23:09.635]   - Field: ‘result’
[13:23:09.636]   - Field: ‘asynchronous’
[13:23:09.636]   - Field: ‘calls’
[13:23:09.636]   - Field: ‘globals’
[13:23:09.636]   - Field: ‘stdout’
[13:23:09.636]   - Field: ‘earlySignal’
[13:23:09.636]   - Field: ‘lazy’
[13:23:09.636]   - Field: ‘state’
[13:23:09.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.637] - Launch lazy future ...
[13:23:09.637] Packages needed by the future expression (n = 0): <none>
[13:23:09.637] Packages needed by future strategies (n = 0): <none>
[13:23:09.638] {
[13:23:09.638]     {
[13:23:09.638]         {
[13:23:09.638]             ...future.startTime <- base::Sys.time()
[13:23:09.638]             {
[13:23:09.638]                 {
[13:23:09.638]                   {
[13:23:09.638]                     {
[13:23:09.638]                       base::local({
[13:23:09.638]                         has_future <- base::requireNamespace("future", 
[13:23:09.638]                           quietly = TRUE)
[13:23:09.638]                         if (has_future) {
[13:23:09.638]                           ns <- base::getNamespace("future")
[13:23:09.638]                           version <- ns[[".package"]][["version"]]
[13:23:09.638]                           if (is.null(version)) 
[13:23:09.638]                             version <- utils::packageVersion("future")
[13:23:09.638]                         }
[13:23:09.638]                         else {
[13:23:09.638]                           version <- NULL
[13:23:09.638]                         }
[13:23:09.638]                         if (!has_future || version < "1.8.0") {
[13:23:09.638]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.638]                             "", base::R.version$version.string), 
[13:23:09.638]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.638]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.638]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.638]                               "release", "version")], collapse = " "), 
[13:23:09.638]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.638]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.638]                             info)
[13:23:09.638]                           info <- base::paste(info, collapse = "; ")
[13:23:09.638]                           if (!has_future) {
[13:23:09.638]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.638]                               info)
[13:23:09.638]                           }
[13:23:09.638]                           else {
[13:23:09.638]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.638]                               info, version)
[13:23:09.638]                           }
[13:23:09.638]                           base::stop(msg)
[13:23:09.638]                         }
[13:23:09.638]                       })
[13:23:09.638]                     }
[13:23:09.638]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.638]                     base::options(mc.cores = 1L)
[13:23:09.638]                   }
[13:23:09.638]                   options(future.plan = NULL)
[13:23:09.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.638]                 }
[13:23:09.638]                 ...future.workdir <- getwd()
[13:23:09.638]             }
[13:23:09.638]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.638]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.638]         }
[13:23:09.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.638]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.638]             base::names(...future.oldOptions))
[13:23:09.638]     }
[13:23:09.638]     if (FALSE) {
[13:23:09.638]     }
[13:23:09.638]     else {
[13:23:09.638]         if (TRUE) {
[13:23:09.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.638]                 open = "w")
[13:23:09.638]         }
[13:23:09.638]         else {
[13:23:09.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.638]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.638]         }
[13:23:09.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.638]             base::sink(type = "output", split = FALSE)
[13:23:09.638]             base::close(...future.stdout)
[13:23:09.638]         }, add = TRUE)
[13:23:09.638]     }
[13:23:09.638]     ...future.frame <- base::sys.nframe()
[13:23:09.638]     ...future.conditions <- base::list()
[13:23:09.638]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.638]     if (FALSE) {
[13:23:09.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.638]     }
[13:23:09.638]     ...future.result <- base::tryCatch({
[13:23:09.638]         base::withCallingHandlers({
[13:23:09.638]             ...future.value <- base::withVisible(base::local({
[13:23:09.638]                 withCallingHandlers({
[13:23:09.638]                   {
[13:23:09.638]                     4
[13:23:09.638]                   }
[13:23:09.638]                 }, immediateCondition = function(cond) {
[13:23:09.638]                   save_rds <- function (object, pathname, ...) 
[13:23:09.638]                   {
[13:23:09.638]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.638]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.638]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.638]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.638]                         fi_tmp[["mtime"]])
[13:23:09.638]                     }
[13:23:09.638]                     tryCatch({
[13:23:09.638]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.638]                     }, error = function(ex) {
[13:23:09.638]                       msg <- conditionMessage(ex)
[13:23:09.638]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.638]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.638]                         fi_tmp[["mtime"]], msg)
[13:23:09.638]                       ex$message <- msg
[13:23:09.638]                       stop(ex)
[13:23:09.638]                     })
[13:23:09.638]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.638]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.638]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.638]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.638]                       fi <- file.info(pathname)
[13:23:09.638]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.638]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.638]                         fi[["size"]], fi[["mtime"]])
[13:23:09.638]                       stop(msg)
[13:23:09.638]                     }
[13:23:09.638]                     invisible(pathname)
[13:23:09.638]                   }
[13:23:09.638]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.638]                     rootPath = tempdir()) 
[13:23:09.638]                   {
[13:23:09.638]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.638]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.638]                       tmpdir = path, fileext = ".rds")
[13:23:09.638]                     save_rds(obj, file)
[13:23:09.638]                   }
[13:23:09.638]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.638]                   {
[13:23:09.638]                     inherits <- base::inherits
[13:23:09.638]                     invokeRestart <- base::invokeRestart
[13:23:09.638]                     is.null <- base::is.null
[13:23:09.638]                     muffled <- FALSE
[13:23:09.638]                     if (inherits(cond, "message")) {
[13:23:09.638]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.638]                       if (muffled) 
[13:23:09.638]                         invokeRestart("muffleMessage")
[13:23:09.638]                     }
[13:23:09.638]                     else if (inherits(cond, "warning")) {
[13:23:09.638]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.638]                       if (muffled) 
[13:23:09.638]                         invokeRestart("muffleWarning")
[13:23:09.638]                     }
[13:23:09.638]                     else if (inherits(cond, "condition")) {
[13:23:09.638]                       if (!is.null(pattern)) {
[13:23:09.638]                         computeRestarts <- base::computeRestarts
[13:23:09.638]                         grepl <- base::grepl
[13:23:09.638]                         restarts <- computeRestarts(cond)
[13:23:09.638]                         for (restart in restarts) {
[13:23:09.638]                           name <- restart$name
[13:23:09.638]                           if (is.null(name)) 
[13:23:09.638]                             next
[13:23:09.638]                           if (!grepl(pattern, name)) 
[13:23:09.638]                             next
[13:23:09.638]                           invokeRestart(restart)
[13:23:09.638]                           muffled <- TRUE
[13:23:09.638]                           break
[13:23:09.638]                         }
[13:23:09.638]                       }
[13:23:09.638]                     }
[13:23:09.638]                     invisible(muffled)
[13:23:09.638]                   }
[13:23:09.638]                   muffleCondition(cond)
[13:23:09.638]                 })
[13:23:09.638]             }))
[13:23:09.638]             future::FutureResult(value = ...future.value$value, 
[13:23:09.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.638]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.638]                     ...future.globalenv.names))
[13:23:09.638]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.638]         }, condition = base::local({
[13:23:09.638]             c <- base::c
[13:23:09.638]             inherits <- base::inherits
[13:23:09.638]             invokeRestart <- base::invokeRestart
[13:23:09.638]             length <- base::length
[13:23:09.638]             list <- base::list
[13:23:09.638]             seq.int <- base::seq.int
[13:23:09.638]             signalCondition <- base::signalCondition
[13:23:09.638]             sys.calls <- base::sys.calls
[13:23:09.638]             `[[` <- base::`[[`
[13:23:09.638]             `+` <- base::`+`
[13:23:09.638]             `<<-` <- base::`<<-`
[13:23:09.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.638]                   3L)]
[13:23:09.638]             }
[13:23:09.638]             function(cond) {
[13:23:09.638]                 is_error <- inherits(cond, "error")
[13:23:09.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.638]                   NULL)
[13:23:09.638]                 if (is_error) {
[13:23:09.638]                   sessionInformation <- function() {
[13:23:09.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.638]                       search = base::search(), system = base::Sys.info())
[13:23:09.638]                   }
[13:23:09.638]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.638]                     cond$call), session = sessionInformation(), 
[13:23:09.638]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.638]                   signalCondition(cond)
[13:23:09.638]                 }
[13:23:09.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.638]                 "immediateCondition"))) {
[13:23:09.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.638]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.638]                   if (TRUE && !signal) {
[13:23:09.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.638]                     {
[13:23:09.638]                       inherits <- base::inherits
[13:23:09.638]                       invokeRestart <- base::invokeRestart
[13:23:09.638]                       is.null <- base::is.null
[13:23:09.638]                       muffled <- FALSE
[13:23:09.638]                       if (inherits(cond, "message")) {
[13:23:09.638]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.638]                         if (muffled) 
[13:23:09.638]                           invokeRestart("muffleMessage")
[13:23:09.638]                       }
[13:23:09.638]                       else if (inherits(cond, "warning")) {
[13:23:09.638]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.638]                         if (muffled) 
[13:23:09.638]                           invokeRestart("muffleWarning")
[13:23:09.638]                       }
[13:23:09.638]                       else if (inherits(cond, "condition")) {
[13:23:09.638]                         if (!is.null(pattern)) {
[13:23:09.638]                           computeRestarts <- base::computeRestarts
[13:23:09.638]                           grepl <- base::grepl
[13:23:09.638]                           restarts <- computeRestarts(cond)
[13:23:09.638]                           for (restart in restarts) {
[13:23:09.638]                             name <- restart$name
[13:23:09.638]                             if (is.null(name)) 
[13:23:09.638]                               next
[13:23:09.638]                             if (!grepl(pattern, name)) 
[13:23:09.638]                               next
[13:23:09.638]                             invokeRestart(restart)
[13:23:09.638]                             muffled <- TRUE
[13:23:09.638]                             break
[13:23:09.638]                           }
[13:23:09.638]                         }
[13:23:09.638]                       }
[13:23:09.638]                       invisible(muffled)
[13:23:09.638]                     }
[13:23:09.638]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.638]                   }
[13:23:09.638]                 }
[13:23:09.638]                 else {
[13:23:09.638]                   if (TRUE) {
[13:23:09.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.638]                     {
[13:23:09.638]                       inherits <- base::inherits
[13:23:09.638]                       invokeRestart <- base::invokeRestart
[13:23:09.638]                       is.null <- base::is.null
[13:23:09.638]                       muffled <- FALSE
[13:23:09.638]                       if (inherits(cond, "message")) {
[13:23:09.638]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.638]                         if (muffled) 
[13:23:09.638]                           invokeRestart("muffleMessage")
[13:23:09.638]                       }
[13:23:09.638]                       else if (inherits(cond, "warning")) {
[13:23:09.638]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.638]                         if (muffled) 
[13:23:09.638]                           invokeRestart("muffleWarning")
[13:23:09.638]                       }
[13:23:09.638]                       else if (inherits(cond, "condition")) {
[13:23:09.638]                         if (!is.null(pattern)) {
[13:23:09.638]                           computeRestarts <- base::computeRestarts
[13:23:09.638]                           grepl <- base::grepl
[13:23:09.638]                           restarts <- computeRestarts(cond)
[13:23:09.638]                           for (restart in restarts) {
[13:23:09.638]                             name <- restart$name
[13:23:09.638]                             if (is.null(name)) 
[13:23:09.638]                               next
[13:23:09.638]                             if (!grepl(pattern, name)) 
[13:23:09.638]                               next
[13:23:09.638]                             invokeRestart(restart)
[13:23:09.638]                             muffled <- TRUE
[13:23:09.638]                             break
[13:23:09.638]                           }
[13:23:09.638]                         }
[13:23:09.638]                       }
[13:23:09.638]                       invisible(muffled)
[13:23:09.638]                     }
[13:23:09.638]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.638]                   }
[13:23:09.638]                 }
[13:23:09.638]             }
[13:23:09.638]         }))
[13:23:09.638]     }, error = function(ex) {
[13:23:09.638]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.638]                 ...future.rng), started = ...future.startTime, 
[13:23:09.638]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.638]             version = "1.8"), class = "FutureResult")
[13:23:09.638]     }, finally = {
[13:23:09.638]         if (!identical(...future.workdir, getwd())) 
[13:23:09.638]             setwd(...future.workdir)
[13:23:09.638]         {
[13:23:09.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.638]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.638]             }
[13:23:09.638]             base::options(...future.oldOptions)
[13:23:09.638]             if (.Platform$OS.type == "windows") {
[13:23:09.638]                 old_names <- names(...future.oldEnvVars)
[13:23:09.638]                 envs <- base::Sys.getenv()
[13:23:09.638]                 names <- names(envs)
[13:23:09.638]                 common <- intersect(names, old_names)
[13:23:09.638]                 added <- setdiff(names, old_names)
[13:23:09.638]                 removed <- setdiff(old_names, names)
[13:23:09.638]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.638]                   envs[common]]
[13:23:09.638]                 NAMES <- toupper(changed)
[13:23:09.638]                 args <- list()
[13:23:09.638]                 for (kk in seq_along(NAMES)) {
[13:23:09.638]                   name <- changed[[kk]]
[13:23:09.638]                   NAME <- NAMES[[kk]]
[13:23:09.638]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.638]                     next
[13:23:09.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.638]                 }
[13:23:09.638]                 NAMES <- toupper(added)
[13:23:09.638]                 for (kk in seq_along(NAMES)) {
[13:23:09.638]                   name <- added[[kk]]
[13:23:09.638]                   NAME <- NAMES[[kk]]
[13:23:09.638]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.638]                     next
[13:23:09.638]                   args[[name]] <- ""
[13:23:09.638]                 }
[13:23:09.638]                 NAMES <- toupper(removed)
[13:23:09.638]                 for (kk in seq_along(NAMES)) {
[13:23:09.638]                   name <- removed[[kk]]
[13:23:09.638]                   NAME <- NAMES[[kk]]
[13:23:09.638]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.638]                     next
[13:23:09.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.638]                 }
[13:23:09.638]                 if (length(args) > 0) 
[13:23:09.638]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.638]             }
[13:23:09.638]             else {
[13:23:09.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.638]             }
[13:23:09.638]             {
[13:23:09.638]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.638]                   0L) {
[13:23:09.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.638]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.638]                   base::options(opts)
[13:23:09.638]                 }
[13:23:09.638]                 {
[13:23:09.638]                   {
[13:23:09.638]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.638]                     NULL
[13:23:09.638]                   }
[13:23:09.638]                   options(future.plan = NULL)
[13:23:09.638]                   if (is.na(NA_character_)) 
[13:23:09.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.638]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.638]                     envir = parent.frame()) 
[13:23:09.638]                   {
[13:23:09.638]                     default_workers <- missing(workers)
[13:23:09.638]                     if (is.function(workers)) 
[13:23:09.638]                       workers <- workers()
[13:23:09.638]                     workers <- structure(as.integer(workers), 
[13:23:09.638]                       class = class(workers))
[13:23:09.638]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.638]                       1L)
[13:23:09.638]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.638]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.638]                       if (default_workers) 
[13:23:09.638]                         supportsMulticore(warn = TRUE)
[13:23:09.638]                       return(sequential(..., envir = envir))
[13:23:09.638]                     }
[13:23:09.638]                     oopts <- options(mc.cores = workers)
[13:23:09.638]                     on.exit(options(oopts))
[13:23:09.638]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.638]                       envir = envir)
[13:23:09.638]                     if (!future$lazy) 
[13:23:09.638]                       future <- run(future)
[13:23:09.638]                     invisible(future)
[13:23:09.638]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.638]                 }
[13:23:09.638]             }
[13:23:09.638]         }
[13:23:09.638]     })
[13:23:09.638]     if (TRUE) {
[13:23:09.638]         base::sink(type = "output", split = FALSE)
[13:23:09.638]         if (TRUE) {
[13:23:09.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.638]         }
[13:23:09.638]         else {
[13:23:09.638]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.638]         }
[13:23:09.638]         base::close(...future.stdout)
[13:23:09.638]         ...future.stdout <- NULL
[13:23:09.638]     }
[13:23:09.638]     ...future.result$conditions <- ...future.conditions
[13:23:09.638]     ...future.result$finished <- base::Sys.time()
[13:23:09.638]     ...future.result
[13:23:09.638] }
[13:23:09.642] requestCore(): workers = 2
[13:23:09.643] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:09.654] result() for MulticoreFuture ...
[13:23:09.655] result() for MulticoreFuture ...
[13:23:09.655] result() for MulticoreFuture ... done
[13:23:09.655] result() for MulticoreFuture ... done
[13:23:09.655] result() for MulticoreFuture ...
[13:23:09.655] result() for MulticoreFuture ... done
[13:23:09.659] MulticoreFuture started
[13:23:09.659] - Launch lazy future ... done
[13:23:09.659] run() for ‘MulticoreFuture’ ... done
[13:23:09.660] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5596d5597528> 
[13:23:09.660] List of future strategies:
[13:23:09.660] 1. sequential:
[13:23:09.660]    - args: function (..., envir = parent.frame())
[13:23:09.660]    - tweaked: FALSE
[13:23:09.660]    - call: NULL
[13:23:09.662] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5596d6788c20> 
 - attr(*, "dim.")=[13:23:09.665] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ :[13:23:09.665] List of future strategies:
[13:23:09.665] 1. multicore:
[13:23:09.665]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.665]    - tweaked: FALSE
[13:23:09.665]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:23:09.672] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:09.677] resolve() on list environment ...
[13:23:09.677]  recursive: 0
[13:23:09.678]  length: 6
[13:23:09.678]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:09.679] signalConditionsASAP(numeric, pos=1) ...
[13:23:09.679] - nx: 6
[13:23:09.679] - relay: TRUE
[13:23:09.679] - stdout: TRUE
[13:23:09.679] - signal: TRUE
[13:23:09.679] - resignal: FALSE
[13:23:09.679] - force: TRUE
[13:23:09.680] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.680] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.680]  - until=2
[13:23:09.680]  - relaying element #2
[13:23:09.680] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.680] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.680] signalConditionsASAP(NULL, pos=1) ... done
[13:23:09.681]  length: 5 (resolved future 1)
[13:23:09.681] Future #2
[13:23:09.681] result() for MulticoreFuture ...
[13:23:09.681] result() for MulticoreFuture ... done
[13:23:09.681] result() for MulticoreFuture ...
[13:23:09.681] result() for MulticoreFuture ... done
[13:23:09.682] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:09.682] - nx: 6
[13:23:09.682] - relay: TRUE
[13:23:09.682] - stdout: TRUE
[13:23:09.682] - signal: TRUE
[13:23:09.682] - resignal: FALSE
[13:23:09.682] - force: TRUE
[13:23:09.683] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.683] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.683]  - until=2
[13:23:09.683]  - relaying element #2
[13:23:09.683] result() for MulticoreFuture ...
[13:23:09.683] result() for MulticoreFuture ... done
[13:23:09.683] result() for MulticoreFuture ...
[13:23:09.684] result() for MulticoreFuture ... done
[13:23:09.684] result() for MulticoreFuture ...
[13:23:09.684] result() for MulticoreFuture ... done
[13:23:09.684] result() for MulticoreFuture ...
[13:23:09.684] result() for MulticoreFuture ... done
[13:23:09.684] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.684] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.685] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:09.685]  length: 4 (resolved future 2)
[13:23:09.685] Future #3
[13:23:09.685] result() for MulticoreFuture ...
[13:23:09.686] result() for MulticoreFuture ...
[13:23:09.687] result() for MulticoreFuture ... done
[13:23:09.687] result() for MulticoreFuture ... done
[13:23:09.687] result() for MulticoreFuture ...
[13:23:09.687] result() for MulticoreFuture ... done
[13:23:09.687] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:09.688] - nx: 6
[13:23:09.688] - relay: TRUE
[13:23:09.688] - stdout: TRUE
[13:23:09.688] - signal: TRUE
[13:23:09.688] - resignal: FALSE
[13:23:09.688] - force: TRUE
[13:23:09.689] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.689] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.689]  - until=3
[13:23:09.689]  - relaying element #3
[13:23:09.689] result() for MulticoreFuture ...
[13:23:09.689] result() for MulticoreFuture ... done
[13:23:09.690] result() for MulticoreFuture ...
[13:23:09.690] result() for MulticoreFuture ... done
[13:23:09.690] result() for MulticoreFuture ...
[13:23:09.690] result() for MulticoreFuture ... done
[13:23:09.690] result() for MulticoreFuture ...
[13:23:09.691] result() for MulticoreFuture ... done
[13:23:09.691] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.691] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.691] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:09.691]  length: 3 (resolved future 3)
[13:23:09.692] Future #4
[13:23:09.692] result() for MulticoreFuture ...
[13:23:09.693] result() for MulticoreFuture ...
[13:23:09.693] result() for MulticoreFuture ... done
[13:23:09.693] result() for MulticoreFuture ... done
[13:23:09.694] result() for MulticoreFuture ...
[13:23:09.694] result() for MulticoreFuture ... done
[13:23:09.694] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:09.694] - nx: 6
[13:23:09.694] - relay: TRUE
[13:23:09.695] - stdout: TRUE
[13:23:09.695] - signal: TRUE
[13:23:09.695] - resignal: FALSE
[13:23:09.695] - force: TRUE
[13:23:09.695] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.695] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.696]  - until=4
[13:23:09.696]  - relaying element #4
[13:23:09.696] result() for MulticoreFuture ...
[13:23:09.696] result() for MulticoreFuture ... done
[13:23:09.696] result() for MulticoreFuture ...
[13:23:09.696] result() for MulticoreFuture ... done
[13:23:09.697] result() for MulticoreFuture ...
[13:23:09.697] result() for MulticoreFuture ... done
[13:23:09.697] result() for MulticoreFuture ...
[13:23:09.697] result() for MulticoreFuture ... done
[13:23:09.697] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.698] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.698] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:09.698]  length: 2 (resolved future 4)
[13:23:09.698] signalConditionsASAP(NULL, pos=5) ...
[13:23:09.698] - nx: 6
[13:23:09.698] - relay: TRUE
[13:23:09.699] - stdout: TRUE
[13:23:09.699] - signal: TRUE
[13:23:09.699] - resignal: FALSE
[13:23:09.699] - force: TRUE
[13:23:09.699] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.699] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.699]  - until=6
[13:23:09.700]  - relaying element #6
[13:23:09.700] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.700] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.700] signalConditionsASAP(NULL, pos=5) ... done
[13:23:09.700]  length: 1 (resolved future 5)
[13:23:09.700] signalConditionsASAP(numeric, pos=6) ...
[13:23:09.700] - nx: 6
[13:23:09.700] - relay: TRUE
[13:23:09.700] - stdout: TRUE
[13:23:09.701] - signal: TRUE
[13:23:09.701] - resignal: FALSE
[13:23:09.701] - force: TRUE
[13:23:09.701] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.701] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.701]  - until=6
[13:23:09.701] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.701] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.701] signalConditionsASAP(numeric, pos=6) ... done
[13:23:09.701]  length: 0 (resolved future 6)
[13:23:09.702] Relaying remaining futures
[13:23:09.702] signalConditionsASAP(NULL, pos=0) ...
[13:23:09.702] - nx: 6
[13:23:09.702] - relay: TRUE
[13:23:09.702] - stdout: TRUE
[13:23:09.702] - signal: TRUE
[13:23:09.702] - resignal: FALSE
[13:23:09.702] - force: TRUE
[13:23:09.702] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.703] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:09.703] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.703] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.703] signalConditionsASAP(NULL, pos=0) ... done
[13:23:09.703] resolve() on list environment ... DONE
[13:23:09.703] result() for MulticoreFuture ...
[13:23:09.703] result() for MulticoreFuture ... done
[13:23:09.703] result() for MulticoreFuture ...
[13:23:09.704] result() for MulticoreFuture ... done
[13:23:09.704] result() for MulticoreFuture ...
[13:23:09.704] result() for MulticoreFuture ... done
[13:23:09.704] result() for MulticoreFuture ...
[13:23:09.704] result() for MulticoreFuture ... done
[13:23:09.704] result() for MulticoreFuture ...
[13:23:09.705] result() for MulticoreFuture ... done
[13:23:09.705] result() for MulticoreFuture ...
[13:23:09.705] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d6a42518> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:23:09.707] getGlobalsAndPackages() ...
[13:23:09.707] Searching for globals...
[13:23:09.708] 
[13:23:09.708] Searching for globals ... DONE
[13:23:09.708] - globals: [0] <none>
[13:23:09.708] getGlobalsAndPackages() ... DONE
[13:23:09.709] run() for ‘Future’ ...
[13:23:09.709] - state: ‘created’
[13:23:09.709] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.714] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.714]   - Field: ‘label’
[13:23:09.714]   - Field: ‘local’
[13:23:09.715]   - Field: ‘owner’
[13:23:09.715]   - Field: ‘envir’
[13:23:09.715]   - Field: ‘workers’
[13:23:09.715]   - Field: ‘packages’
[13:23:09.715]   - Field: ‘gc’
[13:23:09.715]   - Field: ‘job’
[13:23:09.715]   - Field: ‘conditions’
[13:23:09.715]   - Field: ‘expr’
[13:23:09.716]   - Field: ‘uuid’
[13:23:09.716]   - Field: ‘seed’
[13:23:09.716]   - Field: ‘version’
[13:23:09.716]   - Field: ‘result’
[13:23:09.716]   - Field: ‘asynchronous’
[13:23:09.716]   - Field: ‘calls’
[13:23:09.716]   - Field: ‘globals’
[13:23:09.716]   - Field: ‘stdout’
[13:23:09.716]   - Field: ‘earlySignal’
[13:23:09.717]   - Field: ‘lazy’
[13:23:09.717]   - Field: ‘state’
[13:23:09.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.717] - Launch lazy future ...
[13:23:09.722] Packages needed by the future expression (n = 0): <none>
[13:23:09.722] Packages needed by future strategies (n = 0): <none>
[13:23:09.723] {
[13:23:09.723]     {
[13:23:09.723]         {
[13:23:09.723]             ...future.startTime <- base::Sys.time()
[13:23:09.723]             {
[13:23:09.723]                 {
[13:23:09.723]                   {
[13:23:09.723]                     {
[13:23:09.723]                       base::local({
[13:23:09.723]                         has_future <- base::requireNamespace("future", 
[13:23:09.723]                           quietly = TRUE)
[13:23:09.723]                         if (has_future) {
[13:23:09.723]                           ns <- base::getNamespace("future")
[13:23:09.723]                           version <- ns[[".package"]][["version"]]
[13:23:09.723]                           if (is.null(version)) 
[13:23:09.723]                             version <- utils::packageVersion("future")
[13:23:09.723]                         }
[13:23:09.723]                         else {
[13:23:09.723]                           version <- NULL
[13:23:09.723]                         }
[13:23:09.723]                         if (!has_future || version < "1.8.0") {
[13:23:09.723]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.723]                             "", base::R.version$version.string), 
[13:23:09.723]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.723]                               "release", "version")], collapse = " "), 
[13:23:09.723]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.723]                             info)
[13:23:09.723]                           info <- base::paste(info, collapse = "; ")
[13:23:09.723]                           if (!has_future) {
[13:23:09.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.723]                               info)
[13:23:09.723]                           }
[13:23:09.723]                           else {
[13:23:09.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.723]                               info, version)
[13:23:09.723]                           }
[13:23:09.723]                           base::stop(msg)
[13:23:09.723]                         }
[13:23:09.723]                       })
[13:23:09.723]                     }
[13:23:09.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.723]                     base::options(mc.cores = 1L)
[13:23:09.723]                   }
[13:23:09.723]                   options(future.plan = NULL)
[13:23:09.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.723]                 }
[13:23:09.723]                 ...future.workdir <- getwd()
[13:23:09.723]             }
[13:23:09.723]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.723]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.723]         }
[13:23:09.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.723]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.723]             base::names(...future.oldOptions))
[13:23:09.723]     }
[13:23:09.723]     if (FALSE) {
[13:23:09.723]     }
[13:23:09.723]     else {
[13:23:09.723]         if (TRUE) {
[13:23:09.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.723]                 open = "w")
[13:23:09.723]         }
[13:23:09.723]         else {
[13:23:09.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.723]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.723]         }
[13:23:09.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.723]             base::sink(type = "output", split = FALSE)
[13:23:09.723]             base::close(...future.stdout)
[13:23:09.723]         }, add = TRUE)
[13:23:09.723]     }
[13:23:09.723]     ...future.frame <- base::sys.nframe()
[13:23:09.723]     ...future.conditions <- base::list()
[13:23:09.723]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.723]     if (FALSE) {
[13:23:09.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.723]     }
[13:23:09.723]     ...future.result <- base::tryCatch({
[13:23:09.723]         base::withCallingHandlers({
[13:23:09.723]             ...future.value <- base::withVisible(base::local({
[13:23:09.723]                 withCallingHandlers({
[13:23:09.723]                   2
[13:23:09.723]                 }, immediateCondition = function(cond) {
[13:23:09.723]                   save_rds <- function (object, pathname, ...) 
[13:23:09.723]                   {
[13:23:09.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.723]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.723]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.723]                         fi_tmp[["mtime"]])
[13:23:09.723]                     }
[13:23:09.723]                     tryCatch({
[13:23:09.723]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.723]                     }, error = function(ex) {
[13:23:09.723]                       msg <- conditionMessage(ex)
[13:23:09.723]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.723]                         fi_tmp[["mtime"]], msg)
[13:23:09.723]                       ex$message <- msg
[13:23:09.723]                       stop(ex)
[13:23:09.723]                     })
[13:23:09.723]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.723]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.723]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.723]                       fi <- file.info(pathname)
[13:23:09.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.723]                         fi[["size"]], fi[["mtime"]])
[13:23:09.723]                       stop(msg)
[13:23:09.723]                     }
[13:23:09.723]                     invisible(pathname)
[13:23:09.723]                   }
[13:23:09.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.723]                     rootPath = tempdir()) 
[13:23:09.723]                   {
[13:23:09.723]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.723]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.723]                       tmpdir = path, fileext = ".rds")
[13:23:09.723]                     save_rds(obj, file)
[13:23:09.723]                   }
[13:23:09.723]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.723]                   {
[13:23:09.723]                     inherits <- base::inherits
[13:23:09.723]                     invokeRestart <- base::invokeRestart
[13:23:09.723]                     is.null <- base::is.null
[13:23:09.723]                     muffled <- FALSE
[13:23:09.723]                     if (inherits(cond, "message")) {
[13:23:09.723]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.723]                       if (muffled) 
[13:23:09.723]                         invokeRestart("muffleMessage")
[13:23:09.723]                     }
[13:23:09.723]                     else if (inherits(cond, "warning")) {
[13:23:09.723]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.723]                       if (muffled) 
[13:23:09.723]                         invokeRestart("muffleWarning")
[13:23:09.723]                     }
[13:23:09.723]                     else if (inherits(cond, "condition")) {
[13:23:09.723]                       if (!is.null(pattern)) {
[13:23:09.723]                         computeRestarts <- base::computeRestarts
[13:23:09.723]                         grepl <- base::grepl
[13:23:09.723]                         restarts <- computeRestarts(cond)
[13:23:09.723]                         for (restart in restarts) {
[13:23:09.723]                           name <- restart$name
[13:23:09.723]                           if (is.null(name)) 
[13:23:09.723]                             next
[13:23:09.723]                           if (!grepl(pattern, name)) 
[13:23:09.723]                             next
[13:23:09.723]                           invokeRestart(restart)
[13:23:09.723]                           muffled <- TRUE
[13:23:09.723]                           break
[13:23:09.723]                         }
[13:23:09.723]                       }
[13:23:09.723]                     }
[13:23:09.723]                     invisible(muffled)
[13:23:09.723]                   }
[13:23:09.723]                   muffleCondition(cond)
[13:23:09.723]                 })
[13:23:09.723]             }))
[13:23:09.723]             future::FutureResult(value = ...future.value$value, 
[13:23:09.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.723]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.723]                     ...future.globalenv.names))
[13:23:09.723]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.723]         }, condition = base::local({
[13:23:09.723]             c <- base::c
[13:23:09.723]             inherits <- base::inherits
[13:23:09.723]             invokeRestart <- base::invokeRestart
[13:23:09.723]             length <- base::length
[13:23:09.723]             list <- base::list
[13:23:09.723]             seq.int <- base::seq.int
[13:23:09.723]             signalCondition <- base::signalCondition
[13:23:09.723]             sys.calls <- base::sys.calls
[13:23:09.723]             `[[` <- base::`[[`
[13:23:09.723]             `+` <- base::`+`
[13:23:09.723]             `<<-` <- base::`<<-`
[13:23:09.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.723]                   3L)]
[13:23:09.723]             }
[13:23:09.723]             function(cond) {
[13:23:09.723]                 is_error <- inherits(cond, "error")
[13:23:09.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.723]                   NULL)
[13:23:09.723]                 if (is_error) {
[13:23:09.723]                   sessionInformation <- function() {
[13:23:09.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.723]                       search = base::search(), system = base::Sys.info())
[13:23:09.723]                   }
[13:23:09.723]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.723]                     cond$call), session = sessionInformation(), 
[13:23:09.723]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.723]                   signalCondition(cond)
[13:23:09.723]                 }
[13:23:09.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.723]                 "immediateCondition"))) {
[13:23:09.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.723]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.723]                   if (TRUE && !signal) {
[13:23:09.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.723]                     {
[13:23:09.723]                       inherits <- base::inherits
[13:23:09.723]                       invokeRestart <- base::invokeRestart
[13:23:09.723]                       is.null <- base::is.null
[13:23:09.723]                       muffled <- FALSE
[13:23:09.723]                       if (inherits(cond, "message")) {
[13:23:09.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.723]                         if (muffled) 
[13:23:09.723]                           invokeRestart("muffleMessage")
[13:23:09.723]                       }
[13:23:09.723]                       else if (inherits(cond, "warning")) {
[13:23:09.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.723]                         if (muffled) 
[13:23:09.723]                           invokeRestart("muffleWarning")
[13:23:09.723]                       }
[13:23:09.723]                       else if (inherits(cond, "condition")) {
[13:23:09.723]                         if (!is.null(pattern)) {
[13:23:09.723]                           computeRestarts <- base::computeRestarts
[13:23:09.723]                           grepl <- base::grepl
[13:23:09.723]                           restarts <- computeRestarts(cond)
[13:23:09.723]                           for (restart in restarts) {
[13:23:09.723]                             name <- restart$name
[13:23:09.723]                             if (is.null(name)) 
[13:23:09.723]                               next
[13:23:09.723]                             if (!grepl(pattern, name)) 
[13:23:09.723]                               next
[13:23:09.723]                             invokeRestart(restart)
[13:23:09.723]                             muffled <- TRUE
[13:23:09.723]                             break
[13:23:09.723]                           }
[13:23:09.723]                         }
[13:23:09.723]                       }
[13:23:09.723]                       invisible(muffled)
[13:23:09.723]                     }
[13:23:09.723]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.723]                   }
[13:23:09.723]                 }
[13:23:09.723]                 else {
[13:23:09.723]                   if (TRUE) {
[13:23:09.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.723]                     {
[13:23:09.723]                       inherits <- base::inherits
[13:23:09.723]                       invokeRestart <- base::invokeRestart
[13:23:09.723]                       is.null <- base::is.null
[13:23:09.723]                       muffled <- FALSE
[13:23:09.723]                       if (inherits(cond, "message")) {
[13:23:09.723]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.723]                         if (muffled) 
[13:23:09.723]                           invokeRestart("muffleMessage")
[13:23:09.723]                       }
[13:23:09.723]                       else if (inherits(cond, "warning")) {
[13:23:09.723]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.723]                         if (muffled) 
[13:23:09.723]                           invokeRestart("muffleWarning")
[13:23:09.723]                       }
[13:23:09.723]                       else if (inherits(cond, "condition")) {
[13:23:09.723]                         if (!is.null(pattern)) {
[13:23:09.723]                           computeRestarts <- base::computeRestarts
[13:23:09.723]                           grepl <- base::grepl
[13:23:09.723]                           restarts <- computeRestarts(cond)
[13:23:09.723]                           for (restart in restarts) {
[13:23:09.723]                             name <- restart$name
[13:23:09.723]                             if (is.null(name)) 
[13:23:09.723]                               next
[13:23:09.723]                             if (!grepl(pattern, name)) 
[13:23:09.723]                               next
[13:23:09.723]                             invokeRestart(restart)
[13:23:09.723]                             muffled <- TRUE
[13:23:09.723]                             break
[13:23:09.723]                           }
[13:23:09.723]                         }
[13:23:09.723]                       }
[13:23:09.723]                       invisible(muffled)
[13:23:09.723]                     }
[13:23:09.723]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.723]                   }
[13:23:09.723]                 }
[13:23:09.723]             }
[13:23:09.723]         }))
[13:23:09.723]     }, error = function(ex) {
[13:23:09.723]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.723]                 ...future.rng), started = ...future.startTime, 
[13:23:09.723]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.723]             version = "1.8"), class = "FutureResult")
[13:23:09.723]     }, finally = {
[13:23:09.723]         if (!identical(...future.workdir, getwd())) 
[13:23:09.723]             setwd(...future.workdir)
[13:23:09.723]         {
[13:23:09.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.723]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.723]             }
[13:23:09.723]             base::options(...future.oldOptions)
[13:23:09.723]             if (.Platform$OS.type == "windows") {
[13:23:09.723]                 old_names <- names(...future.oldEnvVars)
[13:23:09.723]                 envs <- base::Sys.getenv()
[13:23:09.723]                 names <- names(envs)
[13:23:09.723]                 common <- intersect(names, old_names)
[13:23:09.723]                 added <- setdiff(names, old_names)
[13:23:09.723]                 removed <- setdiff(old_names, names)
[13:23:09.723]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.723]                   envs[common]]
[13:23:09.723]                 NAMES <- toupper(changed)
[13:23:09.723]                 args <- list()
[13:23:09.723]                 for (kk in seq_along(NAMES)) {
[13:23:09.723]                   name <- changed[[kk]]
[13:23:09.723]                   NAME <- NAMES[[kk]]
[13:23:09.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.723]                     next
[13:23:09.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.723]                 }
[13:23:09.723]                 NAMES <- toupper(added)
[13:23:09.723]                 for (kk in seq_along(NAMES)) {
[13:23:09.723]                   name <- added[[kk]]
[13:23:09.723]                   NAME <- NAMES[[kk]]
[13:23:09.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.723]                     next
[13:23:09.723]                   args[[name]] <- ""
[13:23:09.723]                 }
[13:23:09.723]                 NAMES <- toupper(removed)
[13:23:09.723]                 for (kk in seq_along(NAMES)) {
[13:23:09.723]                   name <- removed[[kk]]
[13:23:09.723]                   NAME <- NAMES[[kk]]
[13:23:09.723]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.723]                     next
[13:23:09.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.723]                 }
[13:23:09.723]                 if (length(args) > 0) 
[13:23:09.723]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.723]             }
[13:23:09.723]             else {
[13:23:09.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.723]             }
[13:23:09.723]             {
[13:23:09.723]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.723]                   0L) {
[13:23:09.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.723]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.723]                   base::options(opts)
[13:23:09.723]                 }
[13:23:09.723]                 {
[13:23:09.723]                   {
[13:23:09.723]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.723]                     NULL
[13:23:09.723]                   }
[13:23:09.723]                   options(future.plan = NULL)
[13:23:09.723]                   if (is.na(NA_character_)) 
[13:23:09.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.723]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.723]                     envir = parent.frame()) 
[13:23:09.723]                   {
[13:23:09.723]                     default_workers <- missing(workers)
[13:23:09.723]                     if (is.function(workers)) 
[13:23:09.723]                       workers <- workers()
[13:23:09.723]                     workers <- structure(as.integer(workers), 
[13:23:09.723]                       class = class(workers))
[13:23:09.723]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.723]                       1L)
[13:23:09.723]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.723]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.723]                       if (default_workers) 
[13:23:09.723]                         supportsMulticore(warn = TRUE)
[13:23:09.723]                       return(sequential(..., envir = envir))
[13:23:09.723]                     }
[13:23:09.723]                     oopts <- options(mc.cores = workers)
[13:23:09.723]                     on.exit(options(oopts))
[13:23:09.723]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.723]                       envir = envir)
[13:23:09.723]                     if (!future$lazy) 
[13:23:09.723]                       future <- run(future)
[13:23:09.723]                     invisible(future)
[13:23:09.723]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.723]                 }
[13:23:09.723]             }
[13:23:09.723]         }
[13:23:09.723]     })
[13:23:09.723]     if (TRUE) {
[13:23:09.723]         base::sink(type = "output", split = FALSE)
[13:23:09.723]         if (TRUE) {
[13:23:09.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.723]         }
[13:23:09.723]         else {
[13:23:09.723]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.723]         }
[13:23:09.723]         base::close(...future.stdout)
[13:23:09.723]         ...future.stdout <- NULL
[13:23:09.723]     }
[13:23:09.723]     ...future.result$conditions <- ...future.conditions
[13:23:09.723]     ...future.result$finished <- base::Sys.time()
[13:23:09.723]     ...future.result
[13:23:09.723] }
[13:23:09.726] requestCore(): workers = 2
[13:23:09.729] MulticoreFuture started
[13:23:09.730] - Launch lazy future ... done
[13:23:09.730] run() for ‘MulticoreFuture’ ... done
[13:23:09.730] getGlobalsAndPackages() ...
[13:23:09.731] plan(): Setting new future strategy stack:
[13:23:09.731] Searching for globals...
[13:23:09.731] List of future strategies:
[13:23:09.731] 1. sequential:
[13:23:09.731]    - args: function (..., envir = parent.frame())
[13:23:09.731]    - tweaked: FALSE
[13:23:09.731]    - call: NULL
[13:23:09.732] 
[13:23:09.732] plan(): nbrOfWorkers() = 1
[13:23:09.732] Searching for globals ... DONE
[13:23:09.732] - globals: [0] <none>
[13:23:09.732] getGlobalsAndPackages() ... DONE
[13:23:09.733] run() for ‘Future’ ...
[13:23:09.733] - state: ‘created’
[13:23:09.733] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.734] plan(): Setting new future strategy stack:
[13:23:09.734] List of future strategies:
[13:23:09.734] 1. multicore:
[13:23:09.734]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.734]    - tweaked: FALSE
[13:23:09.734]    - call: plan(strategy)
[13:23:09.739] plan(): nbrOfWorkers() = 2
[13:23:09.739] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.740]   - Field: ‘label’
[13:23:09.740]   - Field: ‘local’
[13:23:09.740]   - Field: ‘owner’
[13:23:09.740]   - Field: ‘envir’
[13:23:09.740]   - Field: ‘workers’
[13:23:09.741]   - Field: ‘packages’
[13:23:09.741]   - Field: ‘gc’
[13:23:09.741]   - Field: ‘job’
[13:23:09.741]   - Field: ‘conditions’
[13:23:09.741]   - Field: ‘expr’
[13:23:09.741]   - Field: ‘uuid’
[13:23:09.742]   - Field: ‘seed’
[13:23:09.742]   - Field: ‘version’
[13:23:09.742]   - Field: ‘result’
[13:23:09.742]   - Field: ‘asynchronous’
[13:23:09.742]   - Field: ‘calls’
[13:23:09.742]   - Field: ‘globals’
[13:23:09.742]   - Field: ‘stdout’
[13:23:09.743]   - Field: ‘earlySignal’
[13:23:09.743]   - Field: ‘lazy’
[13:23:09.743]   - Field: ‘state’
[13:23:09.743] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.743] - Launch lazy future ...
[13:23:09.744] Packages needed by the future expression (n = 0): <none>
[13:23:09.744] Packages needed by future strategies (n = 0): <none>
[13:23:09.745] {
[13:23:09.745]     {
[13:23:09.745]         {
[13:23:09.745]             ...future.startTime <- base::Sys.time()
[13:23:09.745]             {
[13:23:09.745]                 {
[13:23:09.745]                   {
[13:23:09.745]                     {
[13:23:09.745]                       base::local({
[13:23:09.745]                         has_future <- base::requireNamespace("future", 
[13:23:09.745]                           quietly = TRUE)
[13:23:09.745]                         if (has_future) {
[13:23:09.745]                           ns <- base::getNamespace("future")
[13:23:09.745]                           version <- ns[[".package"]][["version"]]
[13:23:09.745]                           if (is.null(version)) 
[13:23:09.745]                             version <- utils::packageVersion("future")
[13:23:09.745]                         }
[13:23:09.745]                         else {
[13:23:09.745]                           version <- NULL
[13:23:09.745]                         }
[13:23:09.745]                         if (!has_future || version < "1.8.0") {
[13:23:09.745]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.745]                             "", base::R.version$version.string), 
[13:23:09.745]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.745]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.745]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.745]                               "release", "version")], collapse = " "), 
[13:23:09.745]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.745]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.745]                             info)
[13:23:09.745]                           info <- base::paste(info, collapse = "; ")
[13:23:09.745]                           if (!has_future) {
[13:23:09.745]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.745]                               info)
[13:23:09.745]                           }
[13:23:09.745]                           else {
[13:23:09.745]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.745]                               info, version)
[13:23:09.745]                           }
[13:23:09.745]                           base::stop(msg)
[13:23:09.745]                         }
[13:23:09.745]                       })
[13:23:09.745]                     }
[13:23:09.745]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.745]                     base::options(mc.cores = 1L)
[13:23:09.745]                   }
[13:23:09.745]                   options(future.plan = NULL)
[13:23:09.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.745]                 }
[13:23:09.745]                 ...future.workdir <- getwd()
[13:23:09.745]             }
[13:23:09.745]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.745]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.745]         }
[13:23:09.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.745]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.745]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.745]             base::names(...future.oldOptions))
[13:23:09.745]     }
[13:23:09.745]     if (FALSE) {
[13:23:09.745]     }
[13:23:09.745]     else {
[13:23:09.745]         if (TRUE) {
[13:23:09.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.745]                 open = "w")
[13:23:09.745]         }
[13:23:09.745]         else {
[13:23:09.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.745]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.745]         }
[13:23:09.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.745]             base::sink(type = "output", split = FALSE)
[13:23:09.745]             base::close(...future.stdout)
[13:23:09.745]         }, add = TRUE)
[13:23:09.745]     }
[13:23:09.745]     ...future.frame <- base::sys.nframe()
[13:23:09.745]     ...future.conditions <- base::list()
[13:23:09.745]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.745]     if (FALSE) {
[13:23:09.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.745]     }
[13:23:09.745]     ...future.result <- base::tryCatch({
[13:23:09.745]         base::withCallingHandlers({
[13:23:09.745]             ...future.value <- base::withVisible(base::local({
[13:23:09.745]                 withCallingHandlers({
[13:23:09.745]                   NULL
[13:23:09.745]                 }, immediateCondition = function(cond) {
[13:23:09.745]                   save_rds <- function (object, pathname, ...) 
[13:23:09.745]                   {
[13:23:09.745]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.745]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.745]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.745]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.745]                         fi_tmp[["mtime"]])
[13:23:09.745]                     }
[13:23:09.745]                     tryCatch({
[13:23:09.745]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.745]                     }, error = function(ex) {
[13:23:09.745]                       msg <- conditionMessage(ex)
[13:23:09.745]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.745]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.745]                         fi_tmp[["mtime"]], msg)
[13:23:09.745]                       ex$message <- msg
[13:23:09.745]                       stop(ex)
[13:23:09.745]                     })
[13:23:09.745]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.745]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.745]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.745]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.745]                       fi <- file.info(pathname)
[13:23:09.745]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.745]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.745]                         fi[["size"]], fi[["mtime"]])
[13:23:09.745]                       stop(msg)
[13:23:09.745]                     }
[13:23:09.745]                     invisible(pathname)
[13:23:09.745]                   }
[13:23:09.745]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.745]                     rootPath = tempdir()) 
[13:23:09.745]                   {
[13:23:09.745]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.745]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.745]                       tmpdir = path, fileext = ".rds")
[13:23:09.745]                     save_rds(obj, file)
[13:23:09.745]                   }
[13:23:09.745]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.745]                   {
[13:23:09.745]                     inherits <- base::inherits
[13:23:09.745]                     invokeRestart <- base::invokeRestart
[13:23:09.745]                     is.null <- base::is.null
[13:23:09.745]                     muffled <- FALSE
[13:23:09.745]                     if (inherits(cond, "message")) {
[13:23:09.745]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.745]                       if (muffled) 
[13:23:09.745]                         invokeRestart("muffleMessage")
[13:23:09.745]                     }
[13:23:09.745]                     else if (inherits(cond, "warning")) {
[13:23:09.745]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.745]                       if (muffled) 
[13:23:09.745]                         invokeRestart("muffleWarning")
[13:23:09.745]                     }
[13:23:09.745]                     else if (inherits(cond, "condition")) {
[13:23:09.745]                       if (!is.null(pattern)) {
[13:23:09.745]                         computeRestarts <- base::computeRestarts
[13:23:09.745]                         grepl <- base::grepl
[13:23:09.745]                         restarts <- computeRestarts(cond)
[13:23:09.745]                         for (restart in restarts) {
[13:23:09.745]                           name <- restart$name
[13:23:09.745]                           if (is.null(name)) 
[13:23:09.745]                             next
[13:23:09.745]                           if (!grepl(pattern, name)) 
[13:23:09.745]                             next
[13:23:09.745]                           invokeRestart(restart)
[13:23:09.745]                           muffled <- TRUE
[13:23:09.745]                           break
[13:23:09.745]                         }
[13:23:09.745]                       }
[13:23:09.745]                     }
[13:23:09.745]                     invisible(muffled)
[13:23:09.745]                   }
[13:23:09.745]                   muffleCondition(cond)
[13:23:09.745]                 })
[13:23:09.745]             }))
[13:23:09.745]             future::FutureResult(value = ...future.value$value, 
[13:23:09.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.745]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.745]                     ...future.globalenv.names))
[13:23:09.745]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.745]         }, condition = base::local({
[13:23:09.745]             c <- base::c
[13:23:09.745]             inherits <- base::inherits
[13:23:09.745]             invokeRestart <- base::invokeRestart
[13:23:09.745]             length <- base::length
[13:23:09.745]             list <- base::list
[13:23:09.745]             seq.int <- base::seq.int
[13:23:09.745]             signalCondition <- base::signalCondition
[13:23:09.745]             sys.calls <- base::sys.calls
[13:23:09.745]             `[[` <- base::`[[`
[13:23:09.745]             `+` <- base::`+`
[13:23:09.745]             `<<-` <- base::`<<-`
[13:23:09.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.745]                   3L)]
[13:23:09.745]             }
[13:23:09.745]             function(cond) {
[13:23:09.745]                 is_error <- inherits(cond, "error")
[13:23:09.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.745]                   NULL)
[13:23:09.745]                 if (is_error) {
[13:23:09.745]                   sessionInformation <- function() {
[13:23:09.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.745]                       search = base::search(), system = base::Sys.info())
[13:23:09.745]                   }
[13:23:09.745]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.745]                     cond$call), session = sessionInformation(), 
[13:23:09.745]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.745]                   signalCondition(cond)
[13:23:09.745]                 }
[13:23:09.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.745]                 "immediateCondition"))) {
[13:23:09.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.745]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.745]                   if (TRUE && !signal) {
[13:23:09.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.745]                     {
[13:23:09.745]                       inherits <- base::inherits
[13:23:09.745]                       invokeRestart <- base::invokeRestart
[13:23:09.745]                       is.null <- base::is.null
[13:23:09.745]                       muffled <- FALSE
[13:23:09.745]                       if (inherits(cond, "message")) {
[13:23:09.745]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.745]                         if (muffled) 
[13:23:09.745]                           invokeRestart("muffleMessage")
[13:23:09.745]                       }
[13:23:09.745]                       else if (inherits(cond, "warning")) {
[13:23:09.745]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.745]                         if (muffled) 
[13:23:09.745]                           invokeRestart("muffleWarning")
[13:23:09.745]                       }
[13:23:09.745]                       else if (inherits(cond, "condition")) {
[13:23:09.745]                         if (!is.null(pattern)) {
[13:23:09.745]                           computeRestarts <- base::computeRestarts
[13:23:09.745]                           grepl <- base::grepl
[13:23:09.745]                           restarts <- computeRestarts(cond)
[13:23:09.745]                           for (restart in restarts) {
[13:23:09.745]                             name <- restart$name
[13:23:09.745]                             if (is.null(name)) 
[13:23:09.745]                               next
[13:23:09.745]                             if (!grepl(pattern, name)) 
[13:23:09.745]                               next
[13:23:09.745]                             invokeRestart(restart)
[13:23:09.745]                             muffled <- TRUE
[13:23:09.745]                             break
[13:23:09.745]                           }
[13:23:09.745]                         }
[13:23:09.745]                       }
[13:23:09.745]                       invisible(muffled)
[13:23:09.745]                     }
[13:23:09.745]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.745]                   }
[13:23:09.745]                 }
[13:23:09.745]                 else {
[13:23:09.745]                   if (TRUE) {
[13:23:09.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.745]                     {
[13:23:09.745]                       inherits <- base::inherits
[13:23:09.745]                       invokeRestart <- base::invokeRestart
[13:23:09.745]                       is.null <- base::is.null
[13:23:09.745]                       muffled <- FALSE
[13:23:09.745]                       if (inherits(cond, "message")) {
[13:23:09.745]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.745]                         if (muffled) 
[13:23:09.745]                           invokeRestart("muffleMessage")
[13:23:09.745]                       }
[13:23:09.745]                       else if (inherits(cond, "warning")) {
[13:23:09.745]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.745]                         if (muffled) 
[13:23:09.745]                           invokeRestart("muffleWarning")
[13:23:09.745]                       }
[13:23:09.745]                       else if (inherits(cond, "condition")) {
[13:23:09.745]                         if (!is.null(pattern)) {
[13:23:09.745]                           computeRestarts <- base::computeRestarts
[13:23:09.745]                           grepl <- base::grepl
[13:23:09.745]                           restarts <- computeRestarts(cond)
[13:23:09.745]                           for (restart in restarts) {
[13:23:09.745]                             name <- restart$name
[13:23:09.745]                             if (is.null(name)) 
[13:23:09.745]                               next
[13:23:09.745]                             if (!grepl(pattern, name)) 
[13:23:09.745]                               next
[13:23:09.745]                             invokeRestart(restart)
[13:23:09.745]                             muffled <- TRUE
[13:23:09.745]                             break
[13:23:09.745]                           }
[13:23:09.745]                         }
[13:23:09.745]                       }
[13:23:09.745]                       invisible(muffled)
[13:23:09.745]                     }
[13:23:09.745]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.745]                   }
[13:23:09.745]                 }
[13:23:09.745]             }
[13:23:09.745]         }))
[13:23:09.745]     }, error = function(ex) {
[13:23:09.745]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.745]                 ...future.rng), started = ...future.startTime, 
[13:23:09.745]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.745]             version = "1.8"), class = "FutureResult")
[13:23:09.745]     }, finally = {
[13:23:09.745]         if (!identical(...future.workdir, getwd())) 
[13:23:09.745]             setwd(...future.workdir)
[13:23:09.745]         {
[13:23:09.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.745]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.745]             }
[13:23:09.745]             base::options(...future.oldOptions)
[13:23:09.745]             if (.Platform$OS.type == "windows") {
[13:23:09.745]                 old_names <- names(...future.oldEnvVars)
[13:23:09.745]                 envs <- base::Sys.getenv()
[13:23:09.745]                 names <- names(envs)
[13:23:09.745]                 common <- intersect(names, old_names)
[13:23:09.745]                 added <- setdiff(names, old_names)
[13:23:09.745]                 removed <- setdiff(old_names, names)
[13:23:09.745]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.745]                   envs[common]]
[13:23:09.745]                 NAMES <- toupper(changed)
[13:23:09.745]                 args <- list()
[13:23:09.745]                 for (kk in seq_along(NAMES)) {
[13:23:09.745]                   name <- changed[[kk]]
[13:23:09.745]                   NAME <- NAMES[[kk]]
[13:23:09.745]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.745]                     next
[13:23:09.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.745]                 }
[13:23:09.745]                 NAMES <- toupper(added)
[13:23:09.745]                 for (kk in seq_along(NAMES)) {
[13:23:09.745]                   name <- added[[kk]]
[13:23:09.745]                   NAME <- NAMES[[kk]]
[13:23:09.745]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.745]                     next
[13:23:09.745]                   args[[name]] <- ""
[13:23:09.745]                 }
[13:23:09.745]                 NAMES <- toupper(removed)
[13:23:09.745]                 for (kk in seq_along(NAMES)) {
[13:23:09.745]                   name <- removed[[kk]]
[13:23:09.745]                   NAME <- NAMES[[kk]]
[13:23:09.745]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.745]                     next
[13:23:09.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.745]                 }
[13:23:09.745]                 if (length(args) > 0) 
[13:23:09.745]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.745]             }
[13:23:09.745]             else {
[13:23:09.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.745]             }
[13:23:09.745]             {
[13:23:09.745]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.745]                   0L) {
[13:23:09.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.745]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.745]                   base::options(opts)
[13:23:09.745]                 }
[13:23:09.745]                 {
[13:23:09.745]                   {
[13:23:09.745]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.745]                     NULL
[13:23:09.745]                   }
[13:23:09.745]                   options(future.plan = NULL)
[13:23:09.745]                   if (is.na(NA_character_)) 
[13:23:09.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.745]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.745]                     envir = parent.frame()) 
[13:23:09.745]                   {
[13:23:09.745]                     default_workers <- missing(workers)
[13:23:09.745]                     if (is.function(workers)) 
[13:23:09.745]                       workers <- workers()
[13:23:09.745]                     workers <- structure(as.integer(workers), 
[13:23:09.745]                       class = class(workers))
[13:23:09.745]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.745]                       1L)
[13:23:09.745]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.745]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.745]                       if (default_workers) 
[13:23:09.745]                         supportsMulticore(warn = TRUE)
[13:23:09.745]                       return(sequential(..., envir = envir))
[13:23:09.745]                     }
[13:23:09.745]                     oopts <- options(mc.cores = workers)
[13:23:09.745]                     on.exit(options(oopts))
[13:23:09.745]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.745]                       envir = envir)
[13:23:09.745]                     if (!future$lazy) 
[13:23:09.745]                       future <- run(future)
[13:23:09.745]                     invisible(future)
[13:23:09.745]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.745]                 }
[13:23:09.745]             }
[13:23:09.745]         }
[13:23:09.745]     })
[13:23:09.745]     if (TRUE) {
[13:23:09.745]         base::sink(type = "output", split = FALSE)
[13:23:09.745]         if (TRUE) {
[13:23:09.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.745]         }
[13:23:09.745]         else {
[13:23:09.745]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.745]         }
[13:23:09.745]         base::close(...future.stdout)
[13:23:09.745]         ...future.stdout <- NULL
[13:23:09.745]     }
[13:23:09.745]     ...future.result$conditions <- ...future.conditions
[13:23:09.745]     ...future.result$finished <- base::Sys.time()
[13:23:09.745]     ...future.result
[13:23:09.745] }
[13:23:09.749] requestCore(): workers = 2
[13:23:09.752] MulticoreFuture started
[13:23:09.753] - Launch lazy future ... done
[13:23:09.753] run() for ‘MulticoreFuture’ ... done
[13:23:09.754] plan(): Setting new future strategy stack:
[13:23:09.754] getGlobalsAndPackages() ...
[13:23:09.754] Searching for globals...
[13:23:09.754] List of future strategies:
[13:23:09.754] 1. sequential:
[13:23:09.754]    - args: function (..., envir = parent.frame())
[13:23:09.754]    - tweaked: FALSE
[13:23:09.754]    - call: NULL
[13:23:09.755] plan(): nbrOfWorkers() = 1
[13:23:09.756] - globals found: [1] ‘{’
[13:23:09.756] Searching for globals ... DONE
[13:23:09.756] Resolving globals: FALSE
[13:23:09.757] 
[13:23:09.757] 
[13:23:09.757] getGlobalsAndPackages() ... DONE
[13:23:09.757] plan(): Setting new future strategy stack:
[13:23:09.757] run() for ‘Future’ ...
[13:23:09.758] - state: ‘created’
[13:23:09.758] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.757] List of future strategies:
[13:23:09.757] 1. multicore:
[13:23:09.757]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.757]    - tweaked: FALSE
[13:23:09.757]    - call: plan(strategy)
[13:23:09.764] plan(): nbrOfWorkers() = 2
[13:23:09.764] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.764] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.765]   - Field: ‘label’
[13:23:09.765]   - Field: ‘local’
[13:23:09.765]   - Field: ‘owner’
[13:23:09.765]   - Field: ‘envir’
[13:23:09.765]   - Field: ‘workers’
[13:23:09.765]   - Field: ‘packages’
[13:23:09.765]   - Field: ‘gc’
[13:23:09.766]   - Field: ‘job’
[13:23:09.766]   - Field: ‘conditions’
[13:23:09.766]   - Field: ‘expr’
[13:23:09.766]   - Field: ‘uuid’
[13:23:09.766]   - Field: ‘seed’
[13:23:09.766]   - Field: ‘version’
[13:23:09.767]   - Field: ‘result’
[13:23:09.767]   - Field: ‘asynchronous’
[13:23:09.767]   - Field: ‘calls’
[13:23:09.767]   - Field: ‘globals’
[13:23:09.767]   - Field: ‘stdout’
[13:23:09.767]   - Field: ‘earlySignal’
[13:23:09.767]   - Field: ‘lazy’
[13:23:09.768]   - Field: ‘state’
[13:23:09.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.768] - Launch lazy future ...
[13:23:09.769] Packages needed by the future expression (n = 0): <none>
[13:23:09.769] Packages needed by future strategies (n = 0): <none>
[13:23:09.770] {
[13:23:09.770]     {
[13:23:09.770]         {
[13:23:09.770]             ...future.startTime <- base::Sys.time()
[13:23:09.770]             {
[13:23:09.770]                 {
[13:23:09.770]                   {
[13:23:09.770]                     {
[13:23:09.770]                       base::local({
[13:23:09.770]                         has_future <- base::requireNamespace("future", 
[13:23:09.770]                           quietly = TRUE)
[13:23:09.770]                         if (has_future) {
[13:23:09.770]                           ns <- base::getNamespace("future")
[13:23:09.770]                           version <- ns[[".package"]][["version"]]
[13:23:09.770]                           if (is.null(version)) 
[13:23:09.770]                             version <- utils::packageVersion("future")
[13:23:09.770]                         }
[13:23:09.770]                         else {
[13:23:09.770]                           version <- NULL
[13:23:09.770]                         }
[13:23:09.770]                         if (!has_future || version < "1.8.0") {
[13:23:09.770]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.770]                             "", base::R.version$version.string), 
[13:23:09.770]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.770]                               "release", "version")], collapse = " "), 
[13:23:09.770]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.770]                             info)
[13:23:09.770]                           info <- base::paste(info, collapse = "; ")
[13:23:09.770]                           if (!has_future) {
[13:23:09.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.770]                               info)
[13:23:09.770]                           }
[13:23:09.770]                           else {
[13:23:09.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.770]                               info, version)
[13:23:09.770]                           }
[13:23:09.770]                           base::stop(msg)
[13:23:09.770]                         }
[13:23:09.770]                       })
[13:23:09.770]                     }
[13:23:09.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.770]                     base::options(mc.cores = 1L)
[13:23:09.770]                   }
[13:23:09.770]                   options(future.plan = NULL)
[13:23:09.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.770]                 }
[13:23:09.770]                 ...future.workdir <- getwd()
[13:23:09.770]             }
[13:23:09.770]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.770]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.770]         }
[13:23:09.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.770]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.770]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.770]             base::names(...future.oldOptions))
[13:23:09.770]     }
[13:23:09.770]     if (FALSE) {
[13:23:09.770]     }
[13:23:09.770]     else {
[13:23:09.770]         if (TRUE) {
[13:23:09.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.770]                 open = "w")
[13:23:09.770]         }
[13:23:09.770]         else {
[13:23:09.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.770]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.770]         }
[13:23:09.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.770]             base::sink(type = "output", split = FALSE)
[13:23:09.770]             base::close(...future.stdout)
[13:23:09.770]         }, add = TRUE)
[13:23:09.770]     }
[13:23:09.770]     ...future.frame <- base::sys.nframe()
[13:23:09.770]     ...future.conditions <- base::list()
[13:23:09.770]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.770]     if (FALSE) {
[13:23:09.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.770]     }
[13:23:09.770]     ...future.result <- base::tryCatch({
[13:23:09.770]         base::withCallingHandlers({
[13:23:09.770]             ...future.value <- base::withVisible(base::local({
[13:23:09.770]                 withCallingHandlers({
[13:23:09.770]                   {
[13:23:09.770]                     4
[13:23:09.770]                   }
[13:23:09.770]                 }, immediateCondition = function(cond) {
[13:23:09.770]                   save_rds <- function (object, pathname, ...) 
[13:23:09.770]                   {
[13:23:09.770]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.770]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.770]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.770]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.770]                         fi_tmp[["mtime"]])
[13:23:09.770]                     }
[13:23:09.770]                     tryCatch({
[13:23:09.770]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.770]                     }, error = function(ex) {
[13:23:09.770]                       msg <- conditionMessage(ex)
[13:23:09.770]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.770]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.770]                         fi_tmp[["mtime"]], msg)
[13:23:09.770]                       ex$message <- msg
[13:23:09.770]                       stop(ex)
[13:23:09.770]                     })
[13:23:09.770]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.770]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.770]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.770]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.770]                       fi <- file.info(pathname)
[13:23:09.770]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.770]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.770]                         fi[["size"]], fi[["mtime"]])
[13:23:09.770]                       stop(msg)
[13:23:09.770]                     }
[13:23:09.770]                     invisible(pathname)
[13:23:09.770]                   }
[13:23:09.770]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.770]                     rootPath = tempdir()) 
[13:23:09.770]                   {
[13:23:09.770]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.770]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.770]                       tmpdir = path, fileext = ".rds")
[13:23:09.770]                     save_rds(obj, file)
[13:23:09.770]                   }
[13:23:09.770]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.770]                   {
[13:23:09.770]                     inherits <- base::inherits
[13:23:09.770]                     invokeRestart <- base::invokeRestart
[13:23:09.770]                     is.null <- base::is.null
[13:23:09.770]                     muffled <- FALSE
[13:23:09.770]                     if (inherits(cond, "message")) {
[13:23:09.770]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.770]                       if (muffled) 
[13:23:09.770]                         invokeRestart("muffleMessage")
[13:23:09.770]                     }
[13:23:09.770]                     else if (inherits(cond, "warning")) {
[13:23:09.770]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.770]                       if (muffled) 
[13:23:09.770]                         invokeRestart("muffleWarning")
[13:23:09.770]                     }
[13:23:09.770]                     else if (inherits(cond, "condition")) {
[13:23:09.770]                       if (!is.null(pattern)) {
[13:23:09.770]                         computeRestarts <- base::computeRestarts
[13:23:09.770]                         grepl <- base::grepl
[13:23:09.770]                         restarts <- computeRestarts(cond)
[13:23:09.770]                         for (restart in restarts) {
[13:23:09.770]                           name <- restart$name
[13:23:09.770]                           if (is.null(name)) 
[13:23:09.770]                             next
[13:23:09.770]                           if (!grepl(pattern, name)) 
[13:23:09.770]                             next
[13:23:09.770]                           invokeRestart(restart)
[13:23:09.770]                           muffled <- TRUE
[13:23:09.770]                           break
[13:23:09.770]                         }
[13:23:09.770]                       }
[13:23:09.770]                     }
[13:23:09.770]                     invisible(muffled)
[13:23:09.770]                   }
[13:23:09.770]                   muffleCondition(cond)
[13:23:09.770]                 })
[13:23:09.770]             }))
[13:23:09.770]             future::FutureResult(value = ...future.value$value, 
[13:23:09.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.770]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.770]                     ...future.globalenv.names))
[13:23:09.770]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.770]         }, condition = base::local({
[13:23:09.770]             c <- base::c
[13:23:09.770]             inherits <- base::inherits
[13:23:09.770]             invokeRestart <- base::invokeRestart
[13:23:09.770]             length <- base::length
[13:23:09.770]             list <- base::list
[13:23:09.770]             seq.int <- base::seq.int
[13:23:09.770]             signalCondition <- base::signalCondition
[13:23:09.770]             sys.calls <- base::sys.calls
[13:23:09.770]             `[[` <- base::`[[`
[13:23:09.770]             `+` <- base::`+`
[13:23:09.770]             `<<-` <- base::`<<-`
[13:23:09.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.770]                   3L)]
[13:23:09.770]             }
[13:23:09.770]             function(cond) {
[13:23:09.770]                 is_error <- inherits(cond, "error")
[13:23:09.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.770]                   NULL)
[13:23:09.770]                 if (is_error) {
[13:23:09.770]                   sessionInformation <- function() {
[13:23:09.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.770]                       search = base::search(), system = base::Sys.info())
[13:23:09.770]                   }
[13:23:09.770]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.770]                     cond$call), session = sessionInformation(), 
[13:23:09.770]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.770]                   signalCondition(cond)
[13:23:09.770]                 }
[13:23:09.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.770]                 "immediateCondition"))) {
[13:23:09.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.770]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.770]                   if (TRUE && !signal) {
[13:23:09.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.770]                     {
[13:23:09.770]                       inherits <- base::inherits
[13:23:09.770]                       invokeRestart <- base::invokeRestart
[13:23:09.770]                       is.null <- base::is.null
[13:23:09.770]                       muffled <- FALSE
[13:23:09.770]                       if (inherits(cond, "message")) {
[13:23:09.770]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.770]                         if (muffled) 
[13:23:09.770]                           invokeRestart("muffleMessage")
[13:23:09.770]                       }
[13:23:09.770]                       else if (inherits(cond, "warning")) {
[13:23:09.770]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.770]                         if (muffled) 
[13:23:09.770]                           invokeRestart("muffleWarning")
[13:23:09.770]                       }
[13:23:09.770]                       else if (inherits(cond, "condition")) {
[13:23:09.770]                         if (!is.null(pattern)) {
[13:23:09.770]                           computeRestarts <- base::computeRestarts
[13:23:09.770]                           grepl <- base::grepl
[13:23:09.770]                           restarts <- computeRestarts(cond)
[13:23:09.770]                           for (restart in restarts) {
[13:23:09.770]                             name <- restart$name
[13:23:09.770]                             if (is.null(name)) 
[13:23:09.770]                               next
[13:23:09.770]                             if (!grepl(pattern, name)) 
[13:23:09.770]                               next
[13:23:09.770]                             invokeRestart(restart)
[13:23:09.770]                             muffled <- TRUE
[13:23:09.770]                             break
[13:23:09.770]                           }
[13:23:09.770]                         }
[13:23:09.770]                       }
[13:23:09.770]                       invisible(muffled)
[13:23:09.770]                     }
[13:23:09.770]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.770]                   }
[13:23:09.770]                 }
[13:23:09.770]                 else {
[13:23:09.770]                   if (TRUE) {
[13:23:09.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.770]                     {
[13:23:09.770]                       inherits <- base::inherits
[13:23:09.770]                       invokeRestart <- base::invokeRestart
[13:23:09.770]                       is.null <- base::is.null
[13:23:09.770]                       muffled <- FALSE
[13:23:09.770]                       if (inherits(cond, "message")) {
[13:23:09.770]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.770]                         if (muffled) 
[13:23:09.770]                           invokeRestart("muffleMessage")
[13:23:09.770]                       }
[13:23:09.770]                       else if (inherits(cond, "warning")) {
[13:23:09.770]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.770]                         if (muffled) 
[13:23:09.770]                           invokeRestart("muffleWarning")
[13:23:09.770]                       }
[13:23:09.770]                       else if (inherits(cond, "condition")) {
[13:23:09.770]                         if (!is.null(pattern)) {
[13:23:09.770]                           computeRestarts <- base::computeRestarts
[13:23:09.770]                           grepl <- base::grepl
[13:23:09.770]                           restarts <- computeRestarts(cond)
[13:23:09.770]                           for (restart in restarts) {
[13:23:09.770]                             name <- restart$name
[13:23:09.770]                             if (is.null(name)) 
[13:23:09.770]                               next
[13:23:09.770]                             if (!grepl(pattern, name)) 
[13:23:09.770]                               next
[13:23:09.770]                             invokeRestart(restart)
[13:23:09.770]                             muffled <- TRUE
[13:23:09.770]                             break
[13:23:09.770]                           }
[13:23:09.770]                         }
[13:23:09.770]                       }
[13:23:09.770]                       invisible(muffled)
[13:23:09.770]                     }
[13:23:09.770]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.770]                   }
[13:23:09.770]                 }
[13:23:09.770]             }
[13:23:09.770]         }))
[13:23:09.770]     }, error = function(ex) {
[13:23:09.770]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.770]                 ...future.rng), started = ...future.startTime, 
[13:23:09.770]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.770]             version = "1.8"), class = "FutureResult")
[13:23:09.770]     }, finally = {
[13:23:09.770]         if (!identical(...future.workdir, getwd())) 
[13:23:09.770]             setwd(...future.workdir)
[13:23:09.770]         {
[13:23:09.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.770]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.770]             }
[13:23:09.770]             base::options(...future.oldOptions)
[13:23:09.770]             if (.Platform$OS.type == "windows") {
[13:23:09.770]                 old_names <- names(...future.oldEnvVars)
[13:23:09.770]                 envs <- base::Sys.getenv()
[13:23:09.770]                 names <- names(envs)
[13:23:09.770]                 common <- intersect(names, old_names)
[13:23:09.770]                 added <- setdiff(names, old_names)
[13:23:09.770]                 removed <- setdiff(old_names, names)
[13:23:09.770]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.770]                   envs[common]]
[13:23:09.770]                 NAMES <- toupper(changed)
[13:23:09.770]                 args <- list()
[13:23:09.770]                 for (kk in seq_along(NAMES)) {
[13:23:09.770]                   name <- changed[[kk]]
[13:23:09.770]                   NAME <- NAMES[[kk]]
[13:23:09.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.770]                     next
[13:23:09.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.770]                 }
[13:23:09.770]                 NAMES <- toupper(added)
[13:23:09.770]                 for (kk in seq_along(NAMES)) {
[13:23:09.770]                   name <- added[[kk]]
[13:23:09.770]                   NAME <- NAMES[[kk]]
[13:23:09.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.770]                     next
[13:23:09.770]                   args[[name]] <- ""
[13:23:09.770]                 }
[13:23:09.770]                 NAMES <- toupper(removed)
[13:23:09.770]                 for (kk in seq_along(NAMES)) {
[13:23:09.770]                   name <- removed[[kk]]
[13:23:09.770]                   NAME <- NAMES[[kk]]
[13:23:09.770]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.770]                     next
[13:23:09.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.770]                 }
[13:23:09.770]                 if (length(args) > 0) 
[13:23:09.770]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.770]             }
[13:23:09.770]             else {
[13:23:09.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.770]             }
[13:23:09.770]             {
[13:23:09.770]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.770]                   0L) {
[13:23:09.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.770]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.770]                   base::options(opts)
[13:23:09.770]                 }
[13:23:09.770]                 {
[13:23:09.770]                   {
[13:23:09.770]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.770]                     NULL
[13:23:09.770]                   }
[13:23:09.770]                   options(future.plan = NULL)
[13:23:09.770]                   if (is.na(NA_character_)) 
[13:23:09.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.770]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.770]                     envir = parent.frame()) 
[13:23:09.770]                   {
[13:23:09.770]                     default_workers <- missing(workers)
[13:23:09.770]                     if (is.function(workers)) 
[13:23:09.770]                       workers <- workers()
[13:23:09.770]                     workers <- structure(as.integer(workers), 
[13:23:09.770]                       class = class(workers))
[13:23:09.770]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.770]                       1L)
[13:23:09.770]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.770]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.770]                       if (default_workers) 
[13:23:09.770]                         supportsMulticore(warn = TRUE)
[13:23:09.770]                       return(sequential(..., envir = envir))
[13:23:09.770]                     }
[13:23:09.770]                     oopts <- options(mc.cores = workers)
[13:23:09.770]                     on.exit(options(oopts))
[13:23:09.770]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.770]                       envir = envir)
[13:23:09.770]                     if (!future$lazy) 
[13:23:09.770]                       future <- run(future)
[13:23:09.770]                     invisible(future)
[13:23:09.770]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.770]                 }
[13:23:09.770]             }
[13:23:09.770]         }
[13:23:09.770]     })
[13:23:09.770]     if (TRUE) {
[13:23:09.770]         base::sink(type = "output", split = FALSE)
[13:23:09.770]         if (TRUE) {
[13:23:09.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.770]         }
[13:23:09.770]         else {
[13:23:09.770]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.770]         }
[13:23:09.770]         base::close(...future.stdout)
[13:23:09.770]         ...future.stdout <- NULL
[13:23:09.770]     }
[13:23:09.770]     ...future.result$conditions <- ...future.conditions
[13:23:09.770]     ...future.result$finished <- base::Sys.time()
[13:23:09.770]     ...future.result
[13:23:09.770] }
[13:23:09.774] requestCore(): workers = 2
[13:23:09.774] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:09.785] result() for MulticoreFuture ...
[13:23:09.786] result() for MulticoreFuture ...
[13:23:09.786] result() for MulticoreFuture ... done
[13:23:09.786] result() for MulticoreFuture ... done
[13:23:09.786] result() for MulticoreFuture ...
[13:23:09.787] result() for MulticoreFuture ... done
[13:23:09.790] MulticoreFuture started
[13:23:09.790] - Launch lazy future ... done
[13:23:09.790] run() for ‘MulticoreFuture’ ... done
[13:23:09.791] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5596d74dfc28> 
[13:23:09.791] List of future strategies:
[13:23:09.791] 1. sequential:
[13:23:09.791]    - args: function (..., envir = parent.frame())
[13:23:09.791]    - tweaked: FALSE
[13:23:09.791]    - call: NULL
[13:23:09.793] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5596d514b668> 
 - attr(*, "dim.")=[13:23:09.796] plan(): Setting new future strategy stack:
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=[13:23:09.796] List of future strategies:
[13:23:09.796] 1. multicore:
[13:23:09.796]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.796]    - tweaked: FALSE
[13:23:09.796]    - call: plan(strategy)
List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:23:09.803] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:09.808] resolve() on list environment ...
[13:23:09.808]  recursive: 0
[13:23:09.810]  length: 6
[13:23:09.810]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:09.811] signalConditionsASAP(numeric, pos=1) ...
[13:23:09.811] - nx: 6
[13:23:09.811] - relay: TRUE
[13:23:09.811] - stdout: TRUE
[13:23:09.811] - signal: TRUE
[13:23:09.811] - resignal: FALSE
[13:23:09.812] - force: TRUE
[13:23:09.812] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.812] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.812]  - until=2
[13:23:09.812]  - relaying element #2
[13:23:09.812] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.812] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.813] signalConditionsASAP(NULL, pos=1) ... done
[13:23:09.813]  length: 5 (resolved future 1)
[13:23:09.813] Future #2
[13:23:09.813] result() for MulticoreFuture ...
[13:23:09.813] result() for MulticoreFuture ... done
[13:23:09.813] result() for MulticoreFuture ...
[13:23:09.814] result() for MulticoreFuture ... done
[13:23:09.814] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:09.814] - nx: 6
[13:23:09.814] - relay: TRUE
[13:23:09.814] - stdout: TRUE
[13:23:09.814] - signal: TRUE
[13:23:09.814] - resignal: FALSE
[13:23:09.815] - force: TRUE
[13:23:09.815] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.815] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.815]  - until=2
[13:23:09.815]  - relaying element #2
[13:23:09.815] result() for MulticoreFuture ...
[13:23:09.815] result() for MulticoreFuture ... done
[13:23:09.816] result() for MulticoreFuture ...
[13:23:09.816] result() for MulticoreFuture ... done
[13:23:09.816] result() for MulticoreFuture ...
[13:23:09.816] result() for MulticoreFuture ... done
[13:23:09.816] result() for MulticoreFuture ...
[13:23:09.816] result() for MulticoreFuture ... done
[13:23:09.817] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.817] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.817] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:09.817]  length: 4 (resolved future 2)
[13:23:09.817] Future #3
[13:23:09.818] result() for MulticoreFuture ...
[13:23:09.818] result() for MulticoreFuture ...
[13:23:09.819] result() for MulticoreFuture ... done
[13:23:09.819] result() for MulticoreFuture ... done
[13:23:09.819] result() for MulticoreFuture ...
[13:23:09.819] result() for MulticoreFuture ... done
[13:23:09.819] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:09.820] - nx: 6
[13:23:09.820] - relay: TRUE
[13:23:09.820] - stdout: TRUE
[13:23:09.820] - signal: TRUE
[13:23:09.820] - resignal: FALSE
[13:23:09.821] - force: TRUE
[13:23:09.821] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.821] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.821]  - until=3
[13:23:09.821]  - relaying element #3
[13:23:09.821] result() for MulticoreFuture ...
[13:23:09.822] result() for MulticoreFuture ... done
[13:23:09.822] result() for MulticoreFuture ...
[13:23:09.822] result() for MulticoreFuture ... done
[13:23:09.822] result() for MulticoreFuture ...
[13:23:09.822] result() for MulticoreFuture ... done
[13:23:09.823] result() for MulticoreFuture ...
[13:23:09.823] result() for MulticoreFuture ... done
[13:23:09.823] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.823] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.823] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:09.824]  length: 3 (resolved future 3)
[13:23:09.824] Future #4
[13:23:09.824] result() for MulticoreFuture ...
[13:23:09.825] result() for MulticoreFuture ...
[13:23:09.825] result() for MulticoreFuture ... done
[13:23:09.825] result() for MulticoreFuture ... done
[13:23:09.826] result() for MulticoreFuture ...
[13:23:09.826] result() for MulticoreFuture ... done
[13:23:09.826] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:09.826] - nx: 6
[13:23:09.826] - relay: TRUE
[13:23:09.826] - stdout: TRUE
[13:23:09.827] - signal: TRUE
[13:23:09.827] - resignal: FALSE
[13:23:09.827] - force: TRUE
[13:23:09.827] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.827] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.827]  - until=4
[13:23:09.828]  - relaying element #4
[13:23:09.828] result() for MulticoreFuture ...
[13:23:09.828] result() for MulticoreFuture ... done
[13:23:09.828] result() for MulticoreFuture ...
[13:23:09.828] result() for MulticoreFuture ... done
[13:23:09.829] result() for MulticoreFuture ...
[13:23:09.829] result() for MulticoreFuture ... done
[13:23:09.829] result() for MulticoreFuture ...
[13:23:09.829] result() for MulticoreFuture ... done
[13:23:09.829] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.829] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.830] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:09.830]  length: 2 (resolved future 4)
[13:23:09.830] signalConditionsASAP(NULL, pos=5) ...
[13:23:09.830] - nx: 6
[13:23:09.830] - relay: TRUE
[13:23:09.830] - stdout: TRUE
[13:23:09.831] - signal: TRUE
[13:23:09.831] - resignal: FALSE
[13:23:09.831] - force: TRUE
[13:23:09.831] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.831] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.831]  - until=6
[13:23:09.831]  - relaying element #6
[13:23:09.831] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.831] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.832] signalConditionsASAP(NULL, pos=5) ... done
[13:23:09.832]  length: 1 (resolved future 5)
[13:23:09.832] signalConditionsASAP(numeric, pos=6) ...
[13:23:09.832] - nx: 6
[13:23:09.832] - relay: TRUE
[13:23:09.832] - stdout: TRUE
[13:23:09.832] - signal: TRUE
[13:23:09.832] - resignal: FALSE
[13:23:09.832] - force: TRUE
[13:23:09.833] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.833] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.833]  - until=6
[13:23:09.833] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.833] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.833] signalConditionsASAP(numeric, pos=6) ... done
[13:23:09.833]  length: 0 (resolved future 6)
[13:23:09.833] Relaying remaining futures
[13:23:09.833] signalConditionsASAP(NULL, pos=0) ...
[13:23:09.834] - nx: 6
[13:23:09.834] - relay: TRUE
[13:23:09.834] - stdout: TRUE
[13:23:09.834] - signal: TRUE
[13:23:09.834] - resignal: FALSE
[13:23:09.834] - force: TRUE
[13:23:09.834] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.834] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:09.834] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.834] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.835] signalConditionsASAP(NULL, pos=0) ... done
[13:23:09.835] resolve() on list environment ... DONE
[13:23:09.835] result() for MulticoreFuture ...
[13:23:09.835] result() for MulticoreFuture ... done
[13:23:09.835] result() for MulticoreFuture ...
[13:23:09.835] result() for MulticoreFuture ... done
[13:23:09.836] result() for MulticoreFuture ...
[13:23:09.836] result() for MulticoreFuture ... done
[13:23:09.836] result() for MulticoreFuture ...
[13:23:09.836] result() for MulticoreFuture ... done
[13:23:09.836] result() for MulticoreFuture ...
[13:23:09.836] result() for MulticoreFuture ... done
[13:23:09.837] result() for MulticoreFuture ...
[13:23:09.837] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d3f23dc0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:23:09.839] getGlobalsAndPackages() ...
[13:23:09.839] Searching for globals...
[13:23:09.840] 
[13:23:09.840] Searching for globals ... DONE
[13:23:09.840] - globals: [0] <none>
[13:23:09.840] getGlobalsAndPackages() ... DONE
[13:23:09.841] run() for ‘Future’ ...
[13:23:09.841] - state: ‘created’
[13:23:09.841] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.846] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.846] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.846]   - Field: ‘label’
[13:23:09.846]   - Field: ‘local’
[13:23:09.846]   - Field: ‘owner’
[13:23:09.847]   - Field: ‘envir’
[13:23:09.847]   - Field: ‘workers’
[13:23:09.847]   - Field: ‘packages’
[13:23:09.847]   - Field: ‘gc’
[13:23:09.847]   - Field: ‘job’
[13:23:09.847]   - Field: ‘conditions’
[13:23:09.847]   - Field: ‘expr’
[13:23:09.847]   - Field: ‘uuid’
[13:23:09.848]   - Field: ‘seed’
[13:23:09.848]   - Field: ‘version’
[13:23:09.848]   - Field: ‘result’
[13:23:09.848]   - Field: ‘asynchronous’
[13:23:09.848]   - Field: ‘calls’
[13:23:09.848]   - Field: ‘globals’
[13:23:09.848]   - Field: ‘stdout’
[13:23:09.848]   - Field: ‘earlySignal’
[13:23:09.849]   - Field: ‘lazy’
[13:23:09.849]   - Field: ‘state’
[13:23:09.849] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.849] - Launch lazy future ...
[13:23:09.849] Packages needed by the future expression (n = 0): <none>
[13:23:09.849] Packages needed by future strategies (n = 0): <none>
[13:23:09.850] {
[13:23:09.850]     {
[13:23:09.850]         {
[13:23:09.850]             ...future.startTime <- base::Sys.time()
[13:23:09.850]             {
[13:23:09.850]                 {
[13:23:09.850]                   {
[13:23:09.850]                     {
[13:23:09.850]                       base::local({
[13:23:09.850]                         has_future <- base::requireNamespace("future", 
[13:23:09.850]                           quietly = TRUE)
[13:23:09.850]                         if (has_future) {
[13:23:09.850]                           ns <- base::getNamespace("future")
[13:23:09.850]                           version <- ns[[".package"]][["version"]]
[13:23:09.850]                           if (is.null(version)) 
[13:23:09.850]                             version <- utils::packageVersion("future")
[13:23:09.850]                         }
[13:23:09.850]                         else {
[13:23:09.850]                           version <- NULL
[13:23:09.850]                         }
[13:23:09.850]                         if (!has_future || version < "1.8.0") {
[13:23:09.850]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.850]                             "", base::R.version$version.string), 
[13:23:09.850]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.850]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.850]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.850]                               "release", "version")], collapse = " "), 
[13:23:09.850]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.850]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.850]                             info)
[13:23:09.850]                           info <- base::paste(info, collapse = "; ")
[13:23:09.850]                           if (!has_future) {
[13:23:09.850]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.850]                               info)
[13:23:09.850]                           }
[13:23:09.850]                           else {
[13:23:09.850]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.850]                               info, version)
[13:23:09.850]                           }
[13:23:09.850]                           base::stop(msg)
[13:23:09.850]                         }
[13:23:09.850]                       })
[13:23:09.850]                     }
[13:23:09.850]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.850]                     base::options(mc.cores = 1L)
[13:23:09.850]                   }
[13:23:09.850]                   options(future.plan = NULL)
[13:23:09.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.850]                 }
[13:23:09.850]                 ...future.workdir <- getwd()
[13:23:09.850]             }
[13:23:09.850]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.850]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.850]         }
[13:23:09.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.850]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.850]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.850]             base::names(...future.oldOptions))
[13:23:09.850]     }
[13:23:09.850]     if (FALSE) {
[13:23:09.850]     }
[13:23:09.850]     else {
[13:23:09.850]         if (TRUE) {
[13:23:09.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.850]                 open = "w")
[13:23:09.850]         }
[13:23:09.850]         else {
[13:23:09.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.850]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.850]         }
[13:23:09.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.850]             base::sink(type = "output", split = FALSE)
[13:23:09.850]             base::close(...future.stdout)
[13:23:09.850]         }, add = TRUE)
[13:23:09.850]     }
[13:23:09.850]     ...future.frame <- base::sys.nframe()
[13:23:09.850]     ...future.conditions <- base::list()
[13:23:09.850]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.850]     if (FALSE) {
[13:23:09.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.850]     }
[13:23:09.850]     ...future.result <- base::tryCatch({
[13:23:09.850]         base::withCallingHandlers({
[13:23:09.850]             ...future.value <- base::withVisible(base::local({
[13:23:09.850]                 withCallingHandlers({
[13:23:09.850]                   2
[13:23:09.850]                 }, immediateCondition = function(cond) {
[13:23:09.850]                   save_rds <- function (object, pathname, ...) 
[13:23:09.850]                   {
[13:23:09.850]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.850]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.850]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.850]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.850]                         fi_tmp[["mtime"]])
[13:23:09.850]                     }
[13:23:09.850]                     tryCatch({
[13:23:09.850]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.850]                     }, error = function(ex) {
[13:23:09.850]                       msg <- conditionMessage(ex)
[13:23:09.850]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.850]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.850]                         fi_tmp[["mtime"]], msg)
[13:23:09.850]                       ex$message <- msg
[13:23:09.850]                       stop(ex)
[13:23:09.850]                     })
[13:23:09.850]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.850]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.850]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.850]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.850]                       fi <- file.info(pathname)
[13:23:09.850]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.850]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.850]                         fi[["size"]], fi[["mtime"]])
[13:23:09.850]                       stop(msg)
[13:23:09.850]                     }
[13:23:09.850]                     invisible(pathname)
[13:23:09.850]                   }
[13:23:09.850]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.850]                     rootPath = tempdir()) 
[13:23:09.850]                   {
[13:23:09.850]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.850]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.850]                       tmpdir = path, fileext = ".rds")
[13:23:09.850]                     save_rds(obj, file)
[13:23:09.850]                   }
[13:23:09.850]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.850]                   {
[13:23:09.850]                     inherits <- base::inherits
[13:23:09.850]                     invokeRestart <- base::invokeRestart
[13:23:09.850]                     is.null <- base::is.null
[13:23:09.850]                     muffled <- FALSE
[13:23:09.850]                     if (inherits(cond, "message")) {
[13:23:09.850]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.850]                       if (muffled) 
[13:23:09.850]                         invokeRestart("muffleMessage")
[13:23:09.850]                     }
[13:23:09.850]                     else if (inherits(cond, "warning")) {
[13:23:09.850]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.850]                       if (muffled) 
[13:23:09.850]                         invokeRestart("muffleWarning")
[13:23:09.850]                     }
[13:23:09.850]                     else if (inherits(cond, "condition")) {
[13:23:09.850]                       if (!is.null(pattern)) {
[13:23:09.850]                         computeRestarts <- base::computeRestarts
[13:23:09.850]                         grepl <- base::grepl
[13:23:09.850]                         restarts <- computeRestarts(cond)
[13:23:09.850]                         for (restart in restarts) {
[13:23:09.850]                           name <- restart$name
[13:23:09.850]                           if (is.null(name)) 
[13:23:09.850]                             next
[13:23:09.850]                           if (!grepl(pattern, name)) 
[13:23:09.850]                             next
[13:23:09.850]                           invokeRestart(restart)
[13:23:09.850]                           muffled <- TRUE
[13:23:09.850]                           break
[13:23:09.850]                         }
[13:23:09.850]                       }
[13:23:09.850]                     }
[13:23:09.850]                     invisible(muffled)
[13:23:09.850]                   }
[13:23:09.850]                   muffleCondition(cond)
[13:23:09.850]                 })
[13:23:09.850]             }))
[13:23:09.850]             future::FutureResult(value = ...future.value$value, 
[13:23:09.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.850]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.850]                     ...future.globalenv.names))
[13:23:09.850]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.850]         }, condition = base::local({
[13:23:09.850]             c <- base::c
[13:23:09.850]             inherits <- base::inherits
[13:23:09.850]             invokeRestart <- base::invokeRestart
[13:23:09.850]             length <- base::length
[13:23:09.850]             list <- base::list
[13:23:09.850]             seq.int <- base::seq.int
[13:23:09.850]             signalCondition <- base::signalCondition
[13:23:09.850]             sys.calls <- base::sys.calls
[13:23:09.850]             `[[` <- base::`[[`
[13:23:09.850]             `+` <- base::`+`
[13:23:09.850]             `<<-` <- base::`<<-`
[13:23:09.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.850]                   3L)]
[13:23:09.850]             }
[13:23:09.850]             function(cond) {
[13:23:09.850]                 is_error <- inherits(cond, "error")
[13:23:09.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.850]                   NULL)
[13:23:09.850]                 if (is_error) {
[13:23:09.850]                   sessionInformation <- function() {
[13:23:09.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.850]                       search = base::search(), system = base::Sys.info())
[13:23:09.850]                   }
[13:23:09.850]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.850]                     cond$call), session = sessionInformation(), 
[13:23:09.850]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.850]                   signalCondition(cond)
[13:23:09.850]                 }
[13:23:09.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.850]                 "immediateCondition"))) {
[13:23:09.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.850]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.850]                   if (TRUE && !signal) {
[13:23:09.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.850]                     {
[13:23:09.850]                       inherits <- base::inherits
[13:23:09.850]                       invokeRestart <- base::invokeRestart
[13:23:09.850]                       is.null <- base::is.null
[13:23:09.850]                       muffled <- FALSE
[13:23:09.850]                       if (inherits(cond, "message")) {
[13:23:09.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.850]                         if (muffled) 
[13:23:09.850]                           invokeRestart("muffleMessage")
[13:23:09.850]                       }
[13:23:09.850]                       else if (inherits(cond, "warning")) {
[13:23:09.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.850]                         if (muffled) 
[13:23:09.850]                           invokeRestart("muffleWarning")
[13:23:09.850]                       }
[13:23:09.850]                       else if (inherits(cond, "condition")) {
[13:23:09.850]                         if (!is.null(pattern)) {
[13:23:09.850]                           computeRestarts <- base::computeRestarts
[13:23:09.850]                           grepl <- base::grepl
[13:23:09.850]                           restarts <- computeRestarts(cond)
[13:23:09.850]                           for (restart in restarts) {
[13:23:09.850]                             name <- restart$name
[13:23:09.850]                             if (is.null(name)) 
[13:23:09.850]                               next
[13:23:09.850]                             if (!grepl(pattern, name)) 
[13:23:09.850]                               next
[13:23:09.850]                             invokeRestart(restart)
[13:23:09.850]                             muffled <- TRUE
[13:23:09.850]                             break
[13:23:09.850]                           }
[13:23:09.850]                         }
[13:23:09.850]                       }
[13:23:09.850]                       invisible(muffled)
[13:23:09.850]                     }
[13:23:09.850]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.850]                   }
[13:23:09.850]                 }
[13:23:09.850]                 else {
[13:23:09.850]                   if (TRUE) {
[13:23:09.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.850]                     {
[13:23:09.850]                       inherits <- base::inherits
[13:23:09.850]                       invokeRestart <- base::invokeRestart
[13:23:09.850]                       is.null <- base::is.null
[13:23:09.850]                       muffled <- FALSE
[13:23:09.850]                       if (inherits(cond, "message")) {
[13:23:09.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.850]                         if (muffled) 
[13:23:09.850]                           invokeRestart("muffleMessage")
[13:23:09.850]                       }
[13:23:09.850]                       else if (inherits(cond, "warning")) {
[13:23:09.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.850]                         if (muffled) 
[13:23:09.850]                           invokeRestart("muffleWarning")
[13:23:09.850]                       }
[13:23:09.850]                       else if (inherits(cond, "condition")) {
[13:23:09.850]                         if (!is.null(pattern)) {
[13:23:09.850]                           computeRestarts <- base::computeRestarts
[13:23:09.850]                           grepl <- base::grepl
[13:23:09.850]                           restarts <- computeRestarts(cond)
[13:23:09.850]                           for (restart in restarts) {
[13:23:09.850]                             name <- restart$name
[13:23:09.850]                             if (is.null(name)) 
[13:23:09.850]                               next
[13:23:09.850]                             if (!grepl(pattern, name)) 
[13:23:09.850]                               next
[13:23:09.850]                             invokeRestart(restart)
[13:23:09.850]                             muffled <- TRUE
[13:23:09.850]                             break
[13:23:09.850]                           }
[13:23:09.850]                         }
[13:23:09.850]                       }
[13:23:09.850]                       invisible(muffled)
[13:23:09.850]                     }
[13:23:09.850]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.850]                   }
[13:23:09.850]                 }
[13:23:09.850]             }
[13:23:09.850]         }))
[13:23:09.850]     }, error = function(ex) {
[13:23:09.850]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.850]                 ...future.rng), started = ...future.startTime, 
[13:23:09.850]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.850]             version = "1.8"), class = "FutureResult")
[13:23:09.850]     }, finally = {
[13:23:09.850]         if (!identical(...future.workdir, getwd())) 
[13:23:09.850]             setwd(...future.workdir)
[13:23:09.850]         {
[13:23:09.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.850]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.850]             }
[13:23:09.850]             base::options(...future.oldOptions)
[13:23:09.850]             if (.Platform$OS.type == "windows") {
[13:23:09.850]                 old_names <- names(...future.oldEnvVars)
[13:23:09.850]                 envs <- base::Sys.getenv()
[13:23:09.850]                 names <- names(envs)
[13:23:09.850]                 common <- intersect(names, old_names)
[13:23:09.850]                 added <- setdiff(names, old_names)
[13:23:09.850]                 removed <- setdiff(old_names, names)
[13:23:09.850]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.850]                   envs[common]]
[13:23:09.850]                 NAMES <- toupper(changed)
[13:23:09.850]                 args <- list()
[13:23:09.850]                 for (kk in seq_along(NAMES)) {
[13:23:09.850]                   name <- changed[[kk]]
[13:23:09.850]                   NAME <- NAMES[[kk]]
[13:23:09.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.850]                     next
[13:23:09.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.850]                 }
[13:23:09.850]                 NAMES <- toupper(added)
[13:23:09.850]                 for (kk in seq_along(NAMES)) {
[13:23:09.850]                   name <- added[[kk]]
[13:23:09.850]                   NAME <- NAMES[[kk]]
[13:23:09.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.850]                     next
[13:23:09.850]                   args[[name]] <- ""
[13:23:09.850]                 }
[13:23:09.850]                 NAMES <- toupper(removed)
[13:23:09.850]                 for (kk in seq_along(NAMES)) {
[13:23:09.850]                   name <- removed[[kk]]
[13:23:09.850]                   NAME <- NAMES[[kk]]
[13:23:09.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.850]                     next
[13:23:09.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.850]                 }
[13:23:09.850]                 if (length(args) > 0) 
[13:23:09.850]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.850]             }
[13:23:09.850]             else {
[13:23:09.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.850]             }
[13:23:09.850]             {
[13:23:09.850]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.850]                   0L) {
[13:23:09.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.850]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.850]                   base::options(opts)
[13:23:09.850]                 }
[13:23:09.850]                 {
[13:23:09.850]                   {
[13:23:09.850]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.850]                     NULL
[13:23:09.850]                   }
[13:23:09.850]                   options(future.plan = NULL)
[13:23:09.850]                   if (is.na(NA_character_)) 
[13:23:09.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.850]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.850]                     envir = parent.frame()) 
[13:23:09.850]                   {
[13:23:09.850]                     default_workers <- missing(workers)
[13:23:09.850]                     if (is.function(workers)) 
[13:23:09.850]                       workers <- workers()
[13:23:09.850]                     workers <- structure(as.integer(workers), 
[13:23:09.850]                       class = class(workers))
[13:23:09.850]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.850]                       1L)
[13:23:09.850]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.850]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.850]                       if (default_workers) 
[13:23:09.850]                         supportsMulticore(warn = TRUE)
[13:23:09.850]                       return(sequential(..., envir = envir))
[13:23:09.850]                     }
[13:23:09.850]                     oopts <- options(mc.cores = workers)
[13:23:09.850]                     on.exit(options(oopts))
[13:23:09.850]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.850]                       envir = envir)
[13:23:09.850]                     if (!future$lazy) 
[13:23:09.850]                       future <- run(future)
[13:23:09.850]                     invisible(future)
[13:23:09.850]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.850]                 }
[13:23:09.850]             }
[13:23:09.850]         }
[13:23:09.850]     })
[13:23:09.850]     if (TRUE) {
[13:23:09.850]         base::sink(type = "output", split = FALSE)
[13:23:09.850]         if (TRUE) {
[13:23:09.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.850]         }
[13:23:09.850]         else {
[13:23:09.850]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.850]         }
[13:23:09.850]         base::close(...future.stdout)
[13:23:09.850]         ...future.stdout <- NULL
[13:23:09.850]     }
[13:23:09.850]     ...future.result$conditions <- ...future.conditions
[13:23:09.850]     ...future.result$finished <- base::Sys.time()
[13:23:09.850]     ...future.result
[13:23:09.850] }
[13:23:09.853] requestCore(): workers = 2
[13:23:09.856] MulticoreFuture started
[13:23:09.856] - Launch lazy future ... done
[13:23:09.857] run() for ‘MulticoreFuture’ ... done
[13:23:09.857] getGlobalsAndPackages() ...
[13:23:09.857] Searching for globals...
[13:23:09.857] plan(): Setting new future strategy stack:
[13:23:09.858] 
[13:23:09.858] List of future strategies:
[13:23:09.858] 1. sequential:
[13:23:09.858]    - args: function (..., envir = parent.frame())
[13:23:09.858]    - tweaked: FALSE
[13:23:09.858]    - call: NULL
[13:23:09.858] Searching for globals ... DONE
[13:23:09.858] - globals: [0] <none>
[13:23:09.858] plan(): nbrOfWorkers() = 1
[13:23:09.859] getGlobalsAndPackages() ... DONE
[13:23:09.859] run() for ‘Future’ ...
[13:23:09.859] - state: ‘created’
[13:23:09.859] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.860] plan(): Setting new future strategy stack:
[13:23:09.861] List of future strategies:
[13:23:09.861] 1. multicore:
[13:23:09.861]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.861]    - tweaked: FALSE
[13:23:09.861]    - call: plan(strategy)
[13:23:09.866] plan(): nbrOfWorkers() = 2
[13:23:09.866] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.866]   - Field: ‘label’
[13:23:09.866]   - Field: ‘local’
[13:23:09.867]   - Field: ‘owner’
[13:23:09.867]   - Field: ‘envir’
[13:23:09.867]   - Field: ‘workers’
[13:23:09.867]   - Field: ‘packages’
[13:23:09.867]   - Field: ‘gc’
[13:23:09.867]   - Field: ‘job’
[13:23:09.867]   - Field: ‘conditions’
[13:23:09.868]   - Field: ‘expr’
[13:23:09.868]   - Field: ‘uuid’
[13:23:09.868]   - Field: ‘seed’
[13:23:09.868]   - Field: ‘version’
[13:23:09.868]   - Field: ‘result’
[13:23:09.868]   - Field: ‘asynchronous’
[13:23:09.868]   - Field: ‘calls’
[13:23:09.869]   - Field: ‘globals’
[13:23:09.869]   - Field: ‘stdout’
[13:23:09.869]   - Field: ‘earlySignal’
[13:23:09.869]   - Field: ‘lazy’
[13:23:09.869]   - Field: ‘state’
[13:23:09.869] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.869] - Launch lazy future ...
[13:23:09.870] Packages needed by the future expression (n = 0): <none>
[13:23:09.870] Packages needed by future strategies (n = 0): <none>
[13:23:09.871] {
[13:23:09.871]     {
[13:23:09.871]         {
[13:23:09.871]             ...future.startTime <- base::Sys.time()
[13:23:09.871]             {
[13:23:09.871]                 {
[13:23:09.871]                   {
[13:23:09.871]                     {
[13:23:09.871]                       base::local({
[13:23:09.871]                         has_future <- base::requireNamespace("future", 
[13:23:09.871]                           quietly = TRUE)
[13:23:09.871]                         if (has_future) {
[13:23:09.871]                           ns <- base::getNamespace("future")
[13:23:09.871]                           version <- ns[[".package"]][["version"]]
[13:23:09.871]                           if (is.null(version)) 
[13:23:09.871]                             version <- utils::packageVersion("future")
[13:23:09.871]                         }
[13:23:09.871]                         else {
[13:23:09.871]                           version <- NULL
[13:23:09.871]                         }
[13:23:09.871]                         if (!has_future || version < "1.8.0") {
[13:23:09.871]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.871]                             "", base::R.version$version.string), 
[13:23:09.871]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.871]                               "release", "version")], collapse = " "), 
[13:23:09.871]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.871]                             info)
[13:23:09.871]                           info <- base::paste(info, collapse = "; ")
[13:23:09.871]                           if (!has_future) {
[13:23:09.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.871]                               info)
[13:23:09.871]                           }
[13:23:09.871]                           else {
[13:23:09.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.871]                               info, version)
[13:23:09.871]                           }
[13:23:09.871]                           base::stop(msg)
[13:23:09.871]                         }
[13:23:09.871]                       })
[13:23:09.871]                     }
[13:23:09.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.871]                     base::options(mc.cores = 1L)
[13:23:09.871]                   }
[13:23:09.871]                   options(future.plan = NULL)
[13:23:09.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.871]                 }
[13:23:09.871]                 ...future.workdir <- getwd()
[13:23:09.871]             }
[13:23:09.871]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.871]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.871]         }
[13:23:09.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.871]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.871]             base::names(...future.oldOptions))
[13:23:09.871]     }
[13:23:09.871]     if (FALSE) {
[13:23:09.871]     }
[13:23:09.871]     else {
[13:23:09.871]         if (TRUE) {
[13:23:09.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.871]                 open = "w")
[13:23:09.871]         }
[13:23:09.871]         else {
[13:23:09.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.871]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.871]         }
[13:23:09.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.871]             base::sink(type = "output", split = FALSE)
[13:23:09.871]             base::close(...future.stdout)
[13:23:09.871]         }, add = TRUE)
[13:23:09.871]     }
[13:23:09.871]     ...future.frame <- base::sys.nframe()
[13:23:09.871]     ...future.conditions <- base::list()
[13:23:09.871]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.871]     if (FALSE) {
[13:23:09.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.871]     }
[13:23:09.871]     ...future.result <- base::tryCatch({
[13:23:09.871]         base::withCallingHandlers({
[13:23:09.871]             ...future.value <- base::withVisible(base::local({
[13:23:09.871]                 withCallingHandlers({
[13:23:09.871]                   NULL
[13:23:09.871]                 }, immediateCondition = function(cond) {
[13:23:09.871]                   save_rds <- function (object, pathname, ...) 
[13:23:09.871]                   {
[13:23:09.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.871]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.871]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.871]                         fi_tmp[["mtime"]])
[13:23:09.871]                     }
[13:23:09.871]                     tryCatch({
[13:23:09.871]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.871]                     }, error = function(ex) {
[13:23:09.871]                       msg <- conditionMessage(ex)
[13:23:09.871]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.871]                         fi_tmp[["mtime"]], msg)
[13:23:09.871]                       ex$message <- msg
[13:23:09.871]                       stop(ex)
[13:23:09.871]                     })
[13:23:09.871]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.871]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.871]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.871]                       fi <- file.info(pathname)
[13:23:09.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.871]                         fi[["size"]], fi[["mtime"]])
[13:23:09.871]                       stop(msg)
[13:23:09.871]                     }
[13:23:09.871]                     invisible(pathname)
[13:23:09.871]                   }
[13:23:09.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.871]                     rootPath = tempdir()) 
[13:23:09.871]                   {
[13:23:09.871]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.871]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.871]                       tmpdir = path, fileext = ".rds")
[13:23:09.871]                     save_rds(obj, file)
[13:23:09.871]                   }
[13:23:09.871]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.871]                   {
[13:23:09.871]                     inherits <- base::inherits
[13:23:09.871]                     invokeRestart <- base::invokeRestart
[13:23:09.871]                     is.null <- base::is.null
[13:23:09.871]                     muffled <- FALSE
[13:23:09.871]                     if (inherits(cond, "message")) {
[13:23:09.871]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.871]                       if (muffled) 
[13:23:09.871]                         invokeRestart("muffleMessage")
[13:23:09.871]                     }
[13:23:09.871]                     else if (inherits(cond, "warning")) {
[13:23:09.871]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.871]                       if (muffled) 
[13:23:09.871]                         invokeRestart("muffleWarning")
[13:23:09.871]                     }
[13:23:09.871]                     else if (inherits(cond, "condition")) {
[13:23:09.871]                       if (!is.null(pattern)) {
[13:23:09.871]                         computeRestarts <- base::computeRestarts
[13:23:09.871]                         grepl <- base::grepl
[13:23:09.871]                         restarts <- computeRestarts(cond)
[13:23:09.871]                         for (restart in restarts) {
[13:23:09.871]                           name <- restart$name
[13:23:09.871]                           if (is.null(name)) 
[13:23:09.871]                             next
[13:23:09.871]                           if (!grepl(pattern, name)) 
[13:23:09.871]                             next
[13:23:09.871]                           invokeRestart(restart)
[13:23:09.871]                           muffled <- TRUE
[13:23:09.871]                           break
[13:23:09.871]                         }
[13:23:09.871]                       }
[13:23:09.871]                     }
[13:23:09.871]                     invisible(muffled)
[13:23:09.871]                   }
[13:23:09.871]                   muffleCondition(cond)
[13:23:09.871]                 })
[13:23:09.871]             }))
[13:23:09.871]             future::FutureResult(value = ...future.value$value, 
[13:23:09.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.871]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.871]                     ...future.globalenv.names))
[13:23:09.871]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.871]         }, condition = base::local({
[13:23:09.871]             c <- base::c
[13:23:09.871]             inherits <- base::inherits
[13:23:09.871]             invokeRestart <- base::invokeRestart
[13:23:09.871]             length <- base::length
[13:23:09.871]             list <- base::list
[13:23:09.871]             seq.int <- base::seq.int
[13:23:09.871]             signalCondition <- base::signalCondition
[13:23:09.871]             sys.calls <- base::sys.calls
[13:23:09.871]             `[[` <- base::`[[`
[13:23:09.871]             `+` <- base::`+`
[13:23:09.871]             `<<-` <- base::`<<-`
[13:23:09.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.871]                   3L)]
[13:23:09.871]             }
[13:23:09.871]             function(cond) {
[13:23:09.871]                 is_error <- inherits(cond, "error")
[13:23:09.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.871]                   NULL)
[13:23:09.871]                 if (is_error) {
[13:23:09.871]                   sessionInformation <- function() {
[13:23:09.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.871]                       search = base::search(), system = base::Sys.info())
[13:23:09.871]                   }
[13:23:09.871]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.871]                     cond$call), session = sessionInformation(), 
[13:23:09.871]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.871]                   signalCondition(cond)
[13:23:09.871]                 }
[13:23:09.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.871]                 "immediateCondition"))) {
[13:23:09.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.871]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.871]                   if (TRUE && !signal) {
[13:23:09.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.871]                     {
[13:23:09.871]                       inherits <- base::inherits
[13:23:09.871]                       invokeRestart <- base::invokeRestart
[13:23:09.871]                       is.null <- base::is.null
[13:23:09.871]                       muffled <- FALSE
[13:23:09.871]                       if (inherits(cond, "message")) {
[13:23:09.871]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.871]                         if (muffled) 
[13:23:09.871]                           invokeRestart("muffleMessage")
[13:23:09.871]                       }
[13:23:09.871]                       else if (inherits(cond, "warning")) {
[13:23:09.871]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.871]                         if (muffled) 
[13:23:09.871]                           invokeRestart("muffleWarning")
[13:23:09.871]                       }
[13:23:09.871]                       else if (inherits(cond, "condition")) {
[13:23:09.871]                         if (!is.null(pattern)) {
[13:23:09.871]                           computeRestarts <- base::computeRestarts
[13:23:09.871]                           grepl <- base::grepl
[13:23:09.871]                           restarts <- computeRestarts(cond)
[13:23:09.871]                           for (restart in restarts) {
[13:23:09.871]                             name <- restart$name
[13:23:09.871]                             if (is.null(name)) 
[13:23:09.871]                               next
[13:23:09.871]                             if (!grepl(pattern, name)) 
[13:23:09.871]                               next
[13:23:09.871]                             invokeRestart(restart)
[13:23:09.871]                             muffled <- TRUE
[13:23:09.871]                             break
[13:23:09.871]                           }
[13:23:09.871]                         }
[13:23:09.871]                       }
[13:23:09.871]                       invisible(muffled)
[13:23:09.871]                     }
[13:23:09.871]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.871]                   }
[13:23:09.871]                 }
[13:23:09.871]                 else {
[13:23:09.871]                   if (TRUE) {
[13:23:09.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.871]                     {
[13:23:09.871]                       inherits <- base::inherits
[13:23:09.871]                       invokeRestart <- base::invokeRestart
[13:23:09.871]                       is.null <- base::is.null
[13:23:09.871]                       muffled <- FALSE
[13:23:09.871]                       if (inherits(cond, "message")) {
[13:23:09.871]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.871]                         if (muffled) 
[13:23:09.871]                           invokeRestart("muffleMessage")
[13:23:09.871]                       }
[13:23:09.871]                       else if (inherits(cond, "warning")) {
[13:23:09.871]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.871]                         if (muffled) 
[13:23:09.871]                           invokeRestart("muffleWarning")
[13:23:09.871]                       }
[13:23:09.871]                       else if (inherits(cond, "condition")) {
[13:23:09.871]                         if (!is.null(pattern)) {
[13:23:09.871]                           computeRestarts <- base::computeRestarts
[13:23:09.871]                           grepl <- base::grepl
[13:23:09.871]                           restarts <- computeRestarts(cond)
[13:23:09.871]                           for (restart in restarts) {
[13:23:09.871]                             name <- restart$name
[13:23:09.871]                             if (is.null(name)) 
[13:23:09.871]                               next
[13:23:09.871]                             if (!grepl(pattern, name)) 
[13:23:09.871]                               next
[13:23:09.871]                             invokeRestart(restart)
[13:23:09.871]                             muffled <- TRUE
[13:23:09.871]                             break
[13:23:09.871]                           }
[13:23:09.871]                         }
[13:23:09.871]                       }
[13:23:09.871]                       invisible(muffled)
[13:23:09.871]                     }
[13:23:09.871]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.871]                   }
[13:23:09.871]                 }
[13:23:09.871]             }
[13:23:09.871]         }))
[13:23:09.871]     }, error = function(ex) {
[13:23:09.871]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.871]                 ...future.rng), started = ...future.startTime, 
[13:23:09.871]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.871]             version = "1.8"), class = "FutureResult")
[13:23:09.871]     }, finally = {
[13:23:09.871]         if (!identical(...future.workdir, getwd())) 
[13:23:09.871]             setwd(...future.workdir)
[13:23:09.871]         {
[13:23:09.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.871]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.871]             }
[13:23:09.871]             base::options(...future.oldOptions)
[13:23:09.871]             if (.Platform$OS.type == "windows") {
[13:23:09.871]                 old_names <- names(...future.oldEnvVars)
[13:23:09.871]                 envs <- base::Sys.getenv()
[13:23:09.871]                 names <- names(envs)
[13:23:09.871]                 common <- intersect(names, old_names)
[13:23:09.871]                 added <- setdiff(names, old_names)
[13:23:09.871]                 removed <- setdiff(old_names, names)
[13:23:09.871]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.871]                   envs[common]]
[13:23:09.871]                 NAMES <- toupper(changed)
[13:23:09.871]                 args <- list()
[13:23:09.871]                 for (kk in seq_along(NAMES)) {
[13:23:09.871]                   name <- changed[[kk]]
[13:23:09.871]                   NAME <- NAMES[[kk]]
[13:23:09.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.871]                     next
[13:23:09.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.871]                 }
[13:23:09.871]                 NAMES <- toupper(added)
[13:23:09.871]                 for (kk in seq_along(NAMES)) {
[13:23:09.871]                   name <- added[[kk]]
[13:23:09.871]                   NAME <- NAMES[[kk]]
[13:23:09.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.871]                     next
[13:23:09.871]                   args[[name]] <- ""
[13:23:09.871]                 }
[13:23:09.871]                 NAMES <- toupper(removed)
[13:23:09.871]                 for (kk in seq_along(NAMES)) {
[13:23:09.871]                   name <- removed[[kk]]
[13:23:09.871]                   NAME <- NAMES[[kk]]
[13:23:09.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.871]                     next
[13:23:09.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.871]                 }
[13:23:09.871]                 if (length(args) > 0) 
[13:23:09.871]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.871]             }
[13:23:09.871]             else {
[13:23:09.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.871]             }
[13:23:09.871]             {
[13:23:09.871]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.871]                   0L) {
[13:23:09.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.871]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.871]                   base::options(opts)
[13:23:09.871]                 }
[13:23:09.871]                 {
[13:23:09.871]                   {
[13:23:09.871]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.871]                     NULL
[13:23:09.871]                   }
[13:23:09.871]                   options(future.plan = NULL)
[13:23:09.871]                   if (is.na(NA_character_)) 
[13:23:09.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.871]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.871]                     envir = parent.frame()) 
[13:23:09.871]                   {
[13:23:09.871]                     default_workers <- missing(workers)
[13:23:09.871]                     if (is.function(workers)) 
[13:23:09.871]                       workers <- workers()
[13:23:09.871]                     workers <- structure(as.integer(workers), 
[13:23:09.871]                       class = class(workers))
[13:23:09.871]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.871]                       1L)
[13:23:09.871]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.871]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.871]                       if (default_workers) 
[13:23:09.871]                         supportsMulticore(warn = TRUE)
[13:23:09.871]                       return(sequential(..., envir = envir))
[13:23:09.871]                     }
[13:23:09.871]                     oopts <- options(mc.cores = workers)
[13:23:09.871]                     on.exit(options(oopts))
[13:23:09.871]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.871]                       envir = envir)
[13:23:09.871]                     if (!future$lazy) 
[13:23:09.871]                       future <- run(future)
[13:23:09.871]                     invisible(future)
[13:23:09.871]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.871]                 }
[13:23:09.871]             }
[13:23:09.871]         }
[13:23:09.871]     })
[13:23:09.871]     if (TRUE) {
[13:23:09.871]         base::sink(type = "output", split = FALSE)
[13:23:09.871]         if (TRUE) {
[13:23:09.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.871]         }
[13:23:09.871]         else {
[13:23:09.871]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.871]         }
[13:23:09.871]         base::close(...future.stdout)
[13:23:09.871]         ...future.stdout <- NULL
[13:23:09.871]     }
[13:23:09.871]     ...future.result$conditions <- ...future.conditions
[13:23:09.871]     ...future.result$finished <- base::Sys.time()
[13:23:09.871]     ...future.result
[13:23:09.871] }
[13:23:09.875] requestCore(): workers = 2
[13:23:09.878] MulticoreFuture started
[13:23:09.878] - Launch lazy future ... done
[13:23:09.878] run() for ‘MulticoreFuture’ ... done
[13:23:09.879] plan(): Setting new future strategy stack:
[13:23:09.879] getGlobalsAndPackages() ...
[13:23:09.880] Searching for globals...
[13:23:09.879] List of future strategies:
[13:23:09.879] 1. sequential:
[13:23:09.879]    - args: function (..., envir = parent.frame())
[13:23:09.879]    - tweaked: FALSE
[13:23:09.879]    - call: NULL
[13:23:09.880] plan(): nbrOfWorkers() = 1
[13:23:09.881] - globals found: [1] ‘{’
[13:23:09.881] Searching for globals ... DONE
[13:23:09.881] Resolving globals: FALSE
[13:23:09.882] 
[13:23:09.882] 
[13:23:09.882] getGlobalsAndPackages() ... DONE
[13:23:09.882] plan(): Setting new future strategy stack:
[13:23:09.883] run() for ‘Future’ ...
[13:23:09.883] - state: ‘created’
[13:23:09.882] List of future strategies:
[13:23:09.882] 1. multicore:
[13:23:09.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.882]    - tweaked: FALSE
[13:23:09.882]    - call: plan(strategy)
[13:23:09.883] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:09.888] plan(): nbrOfWorkers() = 2
[13:23:09.889] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:09.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:09.889]   - Field: ‘label’
[13:23:09.889]   - Field: ‘local’
[13:23:09.890]   - Field: ‘owner’
[13:23:09.890]   - Field: ‘envir’
[13:23:09.890]   - Field: ‘workers’
[13:23:09.890]   - Field: ‘packages’
[13:23:09.890]   - Field: ‘gc’
[13:23:09.890]   - Field: ‘job’
[13:23:09.890]   - Field: ‘conditions’
[13:23:09.891]   - Field: ‘expr’
[13:23:09.891]   - Field: ‘uuid’
[13:23:09.891]   - Field: ‘seed’
[13:23:09.891]   - Field: ‘version’
[13:23:09.891]   - Field: ‘result’
[13:23:09.891]   - Field: ‘asynchronous’
[13:23:09.891]   - Field: ‘calls’
[13:23:09.892]   - Field: ‘globals’
[13:23:09.892]   - Field: ‘stdout’
[13:23:09.892]   - Field: ‘earlySignal’
[13:23:09.892]   - Field: ‘lazy’
[13:23:09.892]   - Field: ‘state’
[13:23:09.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:09.893] - Launch lazy future ...
[13:23:09.893] Packages needed by the future expression (n = 0): <none>
[13:23:09.893] Packages needed by future strategies (n = 0): <none>
[13:23:09.894] {
[13:23:09.894]     {
[13:23:09.894]         {
[13:23:09.894]             ...future.startTime <- base::Sys.time()
[13:23:09.894]             {
[13:23:09.894]                 {
[13:23:09.894]                   {
[13:23:09.894]                     {
[13:23:09.894]                       base::local({
[13:23:09.894]                         has_future <- base::requireNamespace("future", 
[13:23:09.894]                           quietly = TRUE)
[13:23:09.894]                         if (has_future) {
[13:23:09.894]                           ns <- base::getNamespace("future")
[13:23:09.894]                           version <- ns[[".package"]][["version"]]
[13:23:09.894]                           if (is.null(version)) 
[13:23:09.894]                             version <- utils::packageVersion("future")
[13:23:09.894]                         }
[13:23:09.894]                         else {
[13:23:09.894]                           version <- NULL
[13:23:09.894]                         }
[13:23:09.894]                         if (!has_future || version < "1.8.0") {
[13:23:09.894]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:09.894]                             "", base::R.version$version.string), 
[13:23:09.894]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:09.894]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:09.894]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:09.894]                               "release", "version")], collapse = " "), 
[13:23:09.894]                             hostname = base::Sys.info()[["nodename"]])
[13:23:09.894]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:09.894]                             info)
[13:23:09.894]                           info <- base::paste(info, collapse = "; ")
[13:23:09.894]                           if (!has_future) {
[13:23:09.894]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:09.894]                               info)
[13:23:09.894]                           }
[13:23:09.894]                           else {
[13:23:09.894]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:09.894]                               info, version)
[13:23:09.894]                           }
[13:23:09.894]                           base::stop(msg)
[13:23:09.894]                         }
[13:23:09.894]                       })
[13:23:09.894]                     }
[13:23:09.894]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:09.894]                     base::options(mc.cores = 1L)
[13:23:09.894]                   }
[13:23:09.894]                   options(future.plan = NULL)
[13:23:09.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:09.894]                 }
[13:23:09.894]                 ...future.workdir <- getwd()
[13:23:09.894]             }
[13:23:09.894]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:09.894]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:09.894]         }
[13:23:09.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:09.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:09.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:09.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:09.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:09.894]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:09.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:09.894]             base::names(...future.oldOptions))
[13:23:09.894]     }
[13:23:09.894]     if (FALSE) {
[13:23:09.894]     }
[13:23:09.894]     else {
[13:23:09.894]         if (TRUE) {
[13:23:09.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:09.894]                 open = "w")
[13:23:09.894]         }
[13:23:09.894]         else {
[13:23:09.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:09.894]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:09.894]         }
[13:23:09.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:09.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:09.894]             base::sink(type = "output", split = FALSE)
[13:23:09.894]             base::close(...future.stdout)
[13:23:09.894]         }, add = TRUE)
[13:23:09.894]     }
[13:23:09.894]     ...future.frame <- base::sys.nframe()
[13:23:09.894]     ...future.conditions <- base::list()
[13:23:09.894]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:09.894]     if (FALSE) {
[13:23:09.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:09.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:09.894]     }
[13:23:09.894]     ...future.result <- base::tryCatch({
[13:23:09.894]         base::withCallingHandlers({
[13:23:09.894]             ...future.value <- base::withVisible(base::local({
[13:23:09.894]                 withCallingHandlers({
[13:23:09.894]                   {
[13:23:09.894]                     4
[13:23:09.894]                   }
[13:23:09.894]                 }, immediateCondition = function(cond) {
[13:23:09.894]                   save_rds <- function (object, pathname, ...) 
[13:23:09.894]                   {
[13:23:09.894]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:09.894]                     if (file_test("-f", pathname_tmp)) {
[13:23:09.894]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.894]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:09.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.894]                         fi_tmp[["mtime"]])
[13:23:09.894]                     }
[13:23:09.894]                     tryCatch({
[13:23:09.894]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:09.894]                     }, error = function(ex) {
[13:23:09.894]                       msg <- conditionMessage(ex)
[13:23:09.894]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.894]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:09.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.894]                         fi_tmp[["mtime"]], msg)
[13:23:09.894]                       ex$message <- msg
[13:23:09.894]                       stop(ex)
[13:23:09.894]                     })
[13:23:09.894]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:09.894]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:09.894]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:09.894]                       fi_tmp <- file.info(pathname_tmp)
[13:23:09.894]                       fi <- file.info(pathname)
[13:23:09.894]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:09.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:09.894]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:09.894]                         fi[["size"]], fi[["mtime"]])
[13:23:09.894]                       stop(msg)
[13:23:09.894]                     }
[13:23:09.894]                     invisible(pathname)
[13:23:09.894]                   }
[13:23:09.894]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:09.894]                     rootPath = tempdir()) 
[13:23:09.894]                   {
[13:23:09.894]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:09.894]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:09.894]                       tmpdir = path, fileext = ".rds")
[13:23:09.894]                     save_rds(obj, file)
[13:23:09.894]                   }
[13:23:09.894]                   saveImmediateCondition(cond, path = "/tmp/RtmpMODyD9/.future/immediateConditions")
[13:23:09.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.894]                   {
[13:23:09.894]                     inherits <- base::inherits
[13:23:09.894]                     invokeRestart <- base::invokeRestart
[13:23:09.894]                     is.null <- base::is.null
[13:23:09.894]                     muffled <- FALSE
[13:23:09.894]                     if (inherits(cond, "message")) {
[13:23:09.894]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:09.894]                       if (muffled) 
[13:23:09.894]                         invokeRestart("muffleMessage")
[13:23:09.894]                     }
[13:23:09.894]                     else if (inherits(cond, "warning")) {
[13:23:09.894]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:09.894]                       if (muffled) 
[13:23:09.894]                         invokeRestart("muffleWarning")
[13:23:09.894]                     }
[13:23:09.894]                     else if (inherits(cond, "condition")) {
[13:23:09.894]                       if (!is.null(pattern)) {
[13:23:09.894]                         computeRestarts <- base::computeRestarts
[13:23:09.894]                         grepl <- base::grepl
[13:23:09.894]                         restarts <- computeRestarts(cond)
[13:23:09.894]                         for (restart in restarts) {
[13:23:09.894]                           name <- restart$name
[13:23:09.894]                           if (is.null(name)) 
[13:23:09.894]                             next
[13:23:09.894]                           if (!grepl(pattern, name)) 
[13:23:09.894]                             next
[13:23:09.894]                           invokeRestart(restart)
[13:23:09.894]                           muffled <- TRUE
[13:23:09.894]                           break
[13:23:09.894]                         }
[13:23:09.894]                       }
[13:23:09.894]                     }
[13:23:09.894]                     invisible(muffled)
[13:23:09.894]                   }
[13:23:09.894]                   muffleCondition(cond)
[13:23:09.894]                 })
[13:23:09.894]             }))
[13:23:09.894]             future::FutureResult(value = ...future.value$value, 
[13:23:09.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.894]                   ...future.rng), globalenv = if (FALSE) 
[13:23:09.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:09.894]                     ...future.globalenv.names))
[13:23:09.894]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:09.894]         }, condition = base::local({
[13:23:09.894]             c <- base::c
[13:23:09.894]             inherits <- base::inherits
[13:23:09.894]             invokeRestart <- base::invokeRestart
[13:23:09.894]             length <- base::length
[13:23:09.894]             list <- base::list
[13:23:09.894]             seq.int <- base::seq.int
[13:23:09.894]             signalCondition <- base::signalCondition
[13:23:09.894]             sys.calls <- base::sys.calls
[13:23:09.894]             `[[` <- base::`[[`
[13:23:09.894]             `+` <- base::`+`
[13:23:09.894]             `<<-` <- base::`<<-`
[13:23:09.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:09.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:09.894]                   3L)]
[13:23:09.894]             }
[13:23:09.894]             function(cond) {
[13:23:09.894]                 is_error <- inherits(cond, "error")
[13:23:09.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:09.894]                   NULL)
[13:23:09.894]                 if (is_error) {
[13:23:09.894]                   sessionInformation <- function() {
[13:23:09.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:09.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:09.894]                       search = base::search(), system = base::Sys.info())
[13:23:09.894]                   }
[13:23:09.894]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:09.894]                     cond$call), session = sessionInformation(), 
[13:23:09.894]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:09.894]                   signalCondition(cond)
[13:23:09.894]                 }
[13:23:09.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:09.894]                 "immediateCondition"))) {
[13:23:09.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:09.894]                   ...future.conditions[[length(...future.conditions) + 
[13:23:09.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:09.894]                   if (TRUE && !signal) {
[13:23:09.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.894]                     {
[13:23:09.894]                       inherits <- base::inherits
[13:23:09.894]                       invokeRestart <- base::invokeRestart
[13:23:09.894]                       is.null <- base::is.null
[13:23:09.894]                       muffled <- FALSE
[13:23:09.894]                       if (inherits(cond, "message")) {
[13:23:09.894]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.894]                         if (muffled) 
[13:23:09.894]                           invokeRestart("muffleMessage")
[13:23:09.894]                       }
[13:23:09.894]                       else if (inherits(cond, "warning")) {
[13:23:09.894]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.894]                         if (muffled) 
[13:23:09.894]                           invokeRestart("muffleWarning")
[13:23:09.894]                       }
[13:23:09.894]                       else if (inherits(cond, "condition")) {
[13:23:09.894]                         if (!is.null(pattern)) {
[13:23:09.894]                           computeRestarts <- base::computeRestarts
[13:23:09.894]                           grepl <- base::grepl
[13:23:09.894]                           restarts <- computeRestarts(cond)
[13:23:09.894]                           for (restart in restarts) {
[13:23:09.894]                             name <- restart$name
[13:23:09.894]                             if (is.null(name)) 
[13:23:09.894]                               next
[13:23:09.894]                             if (!grepl(pattern, name)) 
[13:23:09.894]                               next
[13:23:09.894]                             invokeRestart(restart)
[13:23:09.894]                             muffled <- TRUE
[13:23:09.894]                             break
[13:23:09.894]                           }
[13:23:09.894]                         }
[13:23:09.894]                       }
[13:23:09.894]                       invisible(muffled)
[13:23:09.894]                     }
[13:23:09.894]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.894]                   }
[13:23:09.894]                 }
[13:23:09.894]                 else {
[13:23:09.894]                   if (TRUE) {
[13:23:09.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:09.894]                     {
[13:23:09.894]                       inherits <- base::inherits
[13:23:09.894]                       invokeRestart <- base::invokeRestart
[13:23:09.894]                       is.null <- base::is.null
[13:23:09.894]                       muffled <- FALSE
[13:23:09.894]                       if (inherits(cond, "message")) {
[13:23:09.894]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:09.894]                         if (muffled) 
[13:23:09.894]                           invokeRestart("muffleMessage")
[13:23:09.894]                       }
[13:23:09.894]                       else if (inherits(cond, "warning")) {
[13:23:09.894]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:09.894]                         if (muffled) 
[13:23:09.894]                           invokeRestart("muffleWarning")
[13:23:09.894]                       }
[13:23:09.894]                       else if (inherits(cond, "condition")) {
[13:23:09.894]                         if (!is.null(pattern)) {
[13:23:09.894]                           computeRestarts <- base::computeRestarts
[13:23:09.894]                           grepl <- base::grepl
[13:23:09.894]                           restarts <- computeRestarts(cond)
[13:23:09.894]                           for (restart in restarts) {
[13:23:09.894]                             name <- restart$name
[13:23:09.894]                             if (is.null(name)) 
[13:23:09.894]                               next
[13:23:09.894]                             if (!grepl(pattern, name)) 
[13:23:09.894]                               next
[13:23:09.894]                             invokeRestart(restart)
[13:23:09.894]                             muffled <- TRUE
[13:23:09.894]                             break
[13:23:09.894]                           }
[13:23:09.894]                         }
[13:23:09.894]                       }
[13:23:09.894]                       invisible(muffled)
[13:23:09.894]                     }
[13:23:09.894]                     muffleCondition(cond, pattern = "^muffle")
[13:23:09.894]                   }
[13:23:09.894]                 }
[13:23:09.894]             }
[13:23:09.894]         }))
[13:23:09.894]     }, error = function(ex) {
[13:23:09.894]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:09.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:09.894]                 ...future.rng), started = ...future.startTime, 
[13:23:09.894]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:09.894]             version = "1.8"), class = "FutureResult")
[13:23:09.894]     }, finally = {
[13:23:09.894]         if (!identical(...future.workdir, getwd())) 
[13:23:09.894]             setwd(...future.workdir)
[13:23:09.894]         {
[13:23:09.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:09.894]                 ...future.oldOptions$nwarnings <- NULL
[13:23:09.894]             }
[13:23:09.894]             base::options(...future.oldOptions)
[13:23:09.894]             if (.Platform$OS.type == "windows") {
[13:23:09.894]                 old_names <- names(...future.oldEnvVars)
[13:23:09.894]                 envs <- base::Sys.getenv()
[13:23:09.894]                 names <- names(envs)
[13:23:09.894]                 common <- intersect(names, old_names)
[13:23:09.894]                 added <- setdiff(names, old_names)
[13:23:09.894]                 removed <- setdiff(old_names, names)
[13:23:09.894]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:09.894]                   envs[common]]
[13:23:09.894]                 NAMES <- toupper(changed)
[13:23:09.894]                 args <- list()
[13:23:09.894]                 for (kk in seq_along(NAMES)) {
[13:23:09.894]                   name <- changed[[kk]]
[13:23:09.894]                   NAME <- NAMES[[kk]]
[13:23:09.894]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.894]                     next
[13:23:09.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.894]                 }
[13:23:09.894]                 NAMES <- toupper(added)
[13:23:09.894]                 for (kk in seq_along(NAMES)) {
[13:23:09.894]                   name <- added[[kk]]
[13:23:09.894]                   NAME <- NAMES[[kk]]
[13:23:09.894]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.894]                     next
[13:23:09.894]                   args[[name]] <- ""
[13:23:09.894]                 }
[13:23:09.894]                 NAMES <- toupper(removed)
[13:23:09.894]                 for (kk in seq_along(NAMES)) {
[13:23:09.894]                   name <- removed[[kk]]
[13:23:09.894]                   NAME <- NAMES[[kk]]
[13:23:09.894]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:09.894]                     next
[13:23:09.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:09.894]                 }
[13:23:09.894]                 if (length(args) > 0) 
[13:23:09.894]                   base::do.call(base::Sys.setenv, args = args)
[13:23:09.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:09.894]             }
[13:23:09.894]             else {
[13:23:09.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:09.894]             }
[13:23:09.894]             {
[13:23:09.894]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:09.894]                   0L) {
[13:23:09.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:09.894]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:09.894]                   base::options(opts)
[13:23:09.894]                 }
[13:23:09.894]                 {
[13:23:09.894]                   {
[13:23:09.894]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:09.894]                     NULL
[13:23:09.894]                   }
[13:23:09.894]                   options(future.plan = NULL)
[13:23:09.894]                   if (is.na(NA_character_)) 
[13:23:09.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:09.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:09.894]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:09.894]                     envir = parent.frame()) 
[13:23:09.894]                   {
[13:23:09.894]                     default_workers <- missing(workers)
[13:23:09.894]                     if (is.function(workers)) 
[13:23:09.894]                       workers <- workers()
[13:23:09.894]                     workers <- structure(as.integer(workers), 
[13:23:09.894]                       class = class(workers))
[13:23:09.894]                     stop_if_not(is.finite(workers), workers >= 
[13:23:09.894]                       1L)
[13:23:09.894]                     if ((workers == 1L && !inherits(workers, 
[13:23:09.894]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:09.894]                       if (default_workers) 
[13:23:09.894]                         supportsMulticore(warn = TRUE)
[13:23:09.894]                       return(sequential(..., envir = envir))
[13:23:09.894]                     }
[13:23:09.894]                     oopts <- options(mc.cores = workers)
[13:23:09.894]                     on.exit(options(oopts))
[13:23:09.894]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:09.894]                       envir = envir)
[13:23:09.894]                     if (!future$lazy) 
[13:23:09.894]                       future <- run(future)
[13:23:09.894]                     invisible(future)
[13:23:09.894]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:09.894]                 }
[13:23:09.894]             }
[13:23:09.894]         }
[13:23:09.894]     })
[13:23:09.894]     if (TRUE) {
[13:23:09.894]         base::sink(type = "output", split = FALSE)
[13:23:09.894]         if (TRUE) {
[13:23:09.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:09.894]         }
[13:23:09.894]         else {
[13:23:09.894]             ...future.result["stdout"] <- base::list(NULL)
[13:23:09.894]         }
[13:23:09.894]         base::close(...future.stdout)
[13:23:09.894]         ...future.stdout <- NULL
[13:23:09.894]     }
[13:23:09.894]     ...future.result$conditions <- ...future.conditions
[13:23:09.894]     ...future.result$finished <- base::Sys.time()
[13:23:09.894]     ...future.result
[13:23:09.894] }
[13:23:09.898] requestCore(): workers = 2
[13:23:09.898] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:09.909] result() for MulticoreFuture ...
[13:23:09.910] result() for MulticoreFuture ...
[13:23:09.910] result() for MulticoreFuture ... done
[13:23:09.910] result() for MulticoreFuture ... done
[13:23:09.910] result() for MulticoreFuture ...
[13:23:09.911] result() for MulticoreFuture ... done
[13:23:09.923] MulticoreFuture started
[13:23:09.924] - Launch lazy future ... done
[13:23:09.924] run() for ‘MulticoreFuture’ ... done
[13:23:09.925] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x5596d6c73928> 
[13:23:09.925] List of future strategies:
[13:23:09.925] 1. sequential:
[13:23:09.925]    - args: function (..., envir = parent.frame())
[13:23:09.925]    - tweaked: FALSE
[13:23:09.925]    - call: NULL
[13:23:09.927] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x5596d5ef2e68> 
 - attr(*, "dim.")=[13:23:09.929] plan(): Setting new future strategy stack:
 int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ :[13:23:09.929] List of future strategies:
[13:23:09.929] 1. multicore:
[13:23:09.929]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:09.929]    - tweaked: FALSE
[13:23:09.929]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:23:09.935] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:09.940] resolve() on list environment ...
[13:23:09.940]  recursive: 0
[13:23:09.941]  length: 6
[13:23:09.942]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:09.942] signalConditionsASAP(numeric, pos=1) ...
[13:23:09.942] - nx: 6
[13:23:09.942] - relay: TRUE
[13:23:09.942] - stdout: TRUE
[13:23:09.942] - signal: TRUE
[13:23:09.942] - resignal: FALSE
[13:23:09.943] - force: TRUE
[13:23:09.943] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.943] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.943]  - until=2
[13:23:09.943]  - relaying element #2
[13:23:09.943] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.943] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.944] signalConditionsASAP(NULL, pos=1) ... done
[13:23:09.944]  length: 5 (resolved future 1)
[13:23:09.944] Future #2
[13:23:09.944] result() for MulticoreFuture ...
[13:23:09.944] result() for MulticoreFuture ... done
[13:23:09.944] result() for MulticoreFuture ...
[13:23:09.945] result() for MulticoreFuture ... done
[13:23:09.945] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:23:09.945] - nx: 6
[13:23:09.945] - relay: TRUE
[13:23:09.945] - stdout: TRUE
[13:23:09.945] - signal: TRUE
[13:23:09.945] - resignal: FALSE
[13:23:09.946] - force: TRUE
[13:23:09.946] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.946] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:09.946]  - until=2
[13:23:09.946]  - relaying element #2
[13:23:09.946] result() for MulticoreFuture ...
[13:23:09.946] result() for MulticoreFuture ... done
[13:23:09.946] result() for MulticoreFuture ...
[13:23:09.947] result() for MulticoreFuture ... done
[13:23:09.947] result() for MulticoreFuture ...
[13:23:09.947] result() for MulticoreFuture ... done
[13:23:09.947] result() for MulticoreFuture ...
[13:23:09.947] result() for MulticoreFuture ... done
[13:23:09.947] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.947] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.948] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:23:09.948]  length: 4 (resolved future 2)
[13:23:09.948] Future #3
[13:23:09.948] result() for MulticoreFuture ...
[13:23:09.949] result() for MulticoreFuture ...
[13:23:09.950] result() for MulticoreFuture ... done
[13:23:09.950] result() for MulticoreFuture ... done
[13:23:09.950] result() for MulticoreFuture ...
[13:23:09.950] result() for MulticoreFuture ... done
[13:23:09.950] signalConditionsASAP(MulticoreFuture, pos=3) ...
[13:23:09.950] - nx: 6
[13:23:09.951] - relay: TRUE
[13:23:09.951] - stdout: TRUE
[13:23:09.951] - signal: TRUE
[13:23:09.951] - resignal: FALSE
[13:23:09.951] - force: TRUE
[13:23:09.951] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.952] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:09.952]  - until=3
[13:23:09.952]  - relaying element #3
[13:23:09.952] result() for MulticoreFuture ...
[13:23:09.952] result() for MulticoreFuture ... done
[13:23:09.952] result() for MulticoreFuture ...
[13:23:09.953] result() for MulticoreFuture ... done
[13:23:09.953] result() for MulticoreFuture ...
[13:23:09.953] result() for MulticoreFuture ... done
[13:23:09.953] result() for MulticoreFuture ...
[13:23:09.953] result() for MulticoreFuture ... done
[13:23:09.954] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.954] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.954] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[13:23:09.954]  length: 3 (resolved future 3)
[13:23:09.955] Future #4
[13:23:09.955] result() for MulticoreFuture ...
[13:23:09.956] result() for MulticoreFuture ...
[13:23:09.956] result() for MulticoreFuture ... done
[13:23:09.956] result() for MulticoreFuture ... done
[13:23:09.956] result() for MulticoreFuture ...
[13:23:09.956] result() for MulticoreFuture ... done
[13:23:09.957] signalConditionsASAP(MulticoreFuture, pos=4) ...
[13:23:09.957] - nx: 6
[13:23:09.957] - relay: TRUE
[13:23:09.957] - stdout: TRUE
[13:23:09.957] - signal: TRUE
[13:23:09.957] - resignal: FALSE
[13:23:09.957] - force: TRUE
[13:23:09.957] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.958] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:09.958]  - until=4
[13:23:09.958]  - relaying element #4
[13:23:09.958] result() for MulticoreFuture ...
[13:23:09.958] result() for MulticoreFuture ... done
[13:23:09.958] result() for MulticoreFuture ...
[13:23:09.958] result() for MulticoreFuture ... done
[13:23:09.958] result() for MulticoreFuture ...
[13:23:09.959] result() for MulticoreFuture ... done
[13:23:09.959] result() for MulticoreFuture ...
[13:23:09.959] result() for MulticoreFuture ... done
[13:23:09.959] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.959] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.959] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[13:23:09.959]  length: 2 (resolved future 4)
[13:23:09.960] signalConditionsASAP(NULL, pos=5) ...
[13:23:09.960] - nx: 6
[13:23:09.960] - relay: TRUE
[13:23:09.960] - stdout: TRUE
[13:23:09.960] - signal: TRUE
[13:23:09.960] - resignal: FALSE
[13:23:09.960] - force: TRUE
[13:23:09.960] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.960] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.961]  - until=6
[13:23:09.961]  - relaying element #6
[13:23:09.961] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.961] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.961] signalConditionsASAP(NULL, pos=5) ... done
[13:23:09.961]  length: 1 (resolved future 5)
[13:23:09.961] signalConditionsASAP(numeric, pos=6) ...
[13:23:09.961] - nx: 6
[13:23:09.962] - relay: TRUE
[13:23:09.962] - stdout: TRUE
[13:23:09.962] - signal: TRUE
[13:23:09.962] - resignal: FALSE
[13:23:09.962] - force: TRUE
[13:23:09.962] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[13:23:09.962] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.962]  - until=6
[13:23:09.963] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.963] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.963] signalConditionsASAP(numeric, pos=6) ... done
[13:23:09.963]  length: 0 (resolved future 6)
[13:23:09.963] Relaying remaining futures
[13:23:09.963] signalConditionsASAP(NULL, pos=0) ...
[13:23:09.963] - nx: 6
[13:23:09.963] - relay: TRUE
[13:23:09.963] - stdout: TRUE
[13:23:09.964] - signal: TRUE
[13:23:09.964] - resignal: FALSE
[13:23:09.964] - force: TRUE
[13:23:09.964] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.964] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:09.964] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:09.964] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:09.965] signalConditionsASAP(NULL, pos=0) ... done
[13:23:09.965] resolve() on list environment ... DONE
[13:23:09.965] result() for MulticoreFuture ...
[13:23:09.965] result() for MulticoreFuture ... done
[13:23:09.965] result() for MulticoreFuture ...
[13:23:09.965] result() for MulticoreFuture ... done
[13:23:09.965] result() for MulticoreFuture ...
[13:23:09.965] result() for MulticoreFuture ... done
[13:23:09.966] result() for MulticoreFuture ...
[13:23:09.966] result() for MulticoreFuture ... done
[13:23:09.966] result() for MulticoreFuture ...
[13:23:09.966] result() for MulticoreFuture ... done
[13:23:09.966] result() for MulticoreFuture ...
[13:23:09.966] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d58c43d8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[13:23:09.969] plan(): Setting new future strategy stack:
[13:23:09.969] List of future strategies:
[13:23:09.969] 1. multisession:
[13:23:09.969]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:09.969]    - tweaked: FALSE
[13:23:09.969]    - call: plan(strategy)
[13:23:09.970] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:23:09.970] multisession:
[13:23:09.970] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:09.970] - tweaked: FALSE
[13:23:09.970] - call: plan(strategy)
[13:23:09.975] getGlobalsAndPackages() ...
[13:23:09.975] Not searching for globals
[13:23:09.975] - globals: [0] <none>
[13:23:09.975] getGlobalsAndPackages() ... DONE
[13:23:09.976] [local output] makeClusterPSOCK() ...
[13:23:09.980] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:23:09.980] [local output] Base port: 11937
[13:23:09.981] [local output] Getting setup options for 2 cluster nodes ...
[13:23:09.981] [local output]  - Node 1 of 2 ...
[13:23:09.981] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:09.982] [local output] Rscript port: 11937

[13:23:09.982] [local output]  - Node 2 of 2 ...
[13:23:09.983] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:09.983] [local output] Rscript port: 11937

[13:23:09.984] [local output] Getting setup options for 2 cluster nodes ... done
[13:23:09.984] [local output]  - Parallel setup requested for some PSOCK nodes
[13:23:09.984] [local output] Setting up PSOCK nodes in parallel
[13:23:09.984] List of 36
[13:23:09.984]  $ worker          : chr "localhost"
[13:23:09.984]   ..- attr(*, "localhost")= logi TRUE
[13:23:09.984]  $ master          : chr "localhost"
[13:23:09.984]  $ port            : int 11937
[13:23:09.984]  $ connectTimeout  : num 120
[13:23:09.984]  $ timeout         : num 2592000
[13:23:09.984]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:23:09.984]  $ homogeneous     : logi TRUE
[13:23:09.984]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:23:09.984]  $ rscript_envs    : NULL
[13:23:09.984]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:09.984]  $ rscript_startup : NULL
[13:23:09.984]  $ rscript_sh      : chr "sh"
[13:23:09.984]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:09.984]  $ methods         : logi TRUE
[13:23:09.984]  $ socketOptions   : chr "no-delay"
[13:23:09.984]  $ useXDR          : logi FALSE
[13:23:09.984]  $ outfile         : chr "/dev/null"
[13:23:09.984]  $ renice          : int NA
[13:23:09.984]  $ rshcmd          : NULL
[13:23:09.984]  $ user            : chr(0) 
[13:23:09.984]  $ revtunnel       : logi FALSE
[13:23:09.984]  $ rshlogfile      : NULL
[13:23:09.984]  $ rshopts         : chr(0) 
[13:23:09.984]  $ rank            : int 1
[13:23:09.984]  $ manual          : logi FALSE
[13:23:09.984]  $ dryrun          : logi FALSE
[13:23:09.984]  $ quiet           : logi FALSE
[13:23:09.984]  $ setup_strategy  : chr "parallel"
[13:23:09.984]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:09.984]  $ pidfile         : chr "/tmp/RtmpMODyD9/worker.rank=1.parallelly.parent=84369.1499171458bbd.pid"
[13:23:09.984]  $ rshcmd_label    : NULL
[13:23:09.984]  $ rsh_call        : NULL
[13:23:09.984]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:09.984]  $ localMachine    : logi TRUE
[13:23:09.984]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:23:09.984]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:23:09.984]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:23:09.984]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:23:09.984]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:23:09.984]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:23:09.984]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:23:09.984]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:23:09.984]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:23:09.984]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:23:09.984]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:23:09.984]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:23:09.984]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:23:09.984]  $ arguments       :List of 28
[13:23:09.984]   ..$ worker          : chr "localhost"
[13:23:09.984]   ..$ master          : NULL
[13:23:09.984]   ..$ port            : int 11937
[13:23:09.984]   ..$ connectTimeout  : num 120
[13:23:09.984]   ..$ timeout         : num 2592000
[13:23:09.984]   ..$ rscript         : NULL
[13:23:09.984]   ..$ homogeneous     : NULL
[13:23:09.984]   ..$ rscript_args    : NULL
[13:23:09.984]   ..$ rscript_envs    : NULL
[13:23:09.984]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:09.984]   ..$ rscript_startup : NULL
[13:23:09.984]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:23:09.984]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:09.984]   ..$ methods         : logi TRUE
[13:23:09.984]   ..$ socketOptions   : chr "no-delay"
[13:23:09.984]   ..$ useXDR          : logi FALSE
[13:23:09.984]   ..$ outfile         : chr "/dev/null"
[13:23:09.984]   ..$ renice          : int NA
[13:23:09.984]   ..$ rshcmd          : NULL
[13:23:09.984]   ..$ user            : NULL
[13:23:09.984]   ..$ revtunnel       : logi NA
[13:23:09.984]   ..$ rshlogfile      : NULL
[13:23:09.984]   ..$ rshopts         : NULL
[13:23:09.984]   ..$ rank            : int 1
[13:23:09.984]   ..$ manual          : logi FALSE
[13:23:09.984]   ..$ dryrun          : logi FALSE
[13:23:09.984]   ..$ quiet           : logi FALSE
[13:23:09.984]   ..$ setup_strategy  : chr "parallel"
[13:23:09.984]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:23:10.004] [local output] System call to launch all workers:
[13:23:10.005] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMODyD9/worker.rank=1.parallelly.parent=84369.1499171458bbd.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11937 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:23:10.005] [local output] Starting PSOCK main server
[13:23:10.006] [local output] Workers launched
[13:23:10.006] [local output] Waiting for workers to connect back
[13:23:10.007]  - [local output] 0 workers out of 2 ready
[13:23:10.261]  - [local output] 0 workers out of 2 ready
[13:23:10.261]  - [local output] 1 workers out of 2 ready
[13:23:10.263]  - [local output] 1 workers out of 2 ready
[13:23:10.263]  - [local output] 2 workers out of 2 ready
[13:23:10.263] [local output] Launching of workers completed
[13:23:10.263] [local output] Collecting session information from workers
[13:23:10.264] [local output]  - Worker #1 of 2
[13:23:10.265] [local output]  - Worker #2 of 2
[13:23:10.265] [local output] makeClusterPSOCK() ... done
[13:23:10.277] Packages needed by the future expression (n = 0): <none>
[13:23:10.277] Packages needed by future strategies (n = 0): <none>
[13:23:10.277] {
[13:23:10.277]     {
[13:23:10.277]         {
[13:23:10.277]             ...future.startTime <- base::Sys.time()
[13:23:10.277]             {
[13:23:10.277]                 {
[13:23:10.277]                   {
[13:23:10.277]                     {
[13:23:10.277]                       base::local({
[13:23:10.277]                         has_future <- base::requireNamespace("future", 
[13:23:10.277]                           quietly = TRUE)
[13:23:10.277]                         if (has_future) {
[13:23:10.277]                           ns <- base::getNamespace("future")
[13:23:10.277]                           version <- ns[[".package"]][["version"]]
[13:23:10.277]                           if (is.null(version)) 
[13:23:10.277]                             version <- utils::packageVersion("future")
[13:23:10.277]                         }
[13:23:10.277]                         else {
[13:23:10.277]                           version <- NULL
[13:23:10.277]                         }
[13:23:10.277]                         if (!has_future || version < "1.8.0") {
[13:23:10.277]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.277]                             "", base::R.version$version.string), 
[13:23:10.277]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.277]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.277]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.277]                               "release", "version")], collapse = " "), 
[13:23:10.277]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.277]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.277]                             info)
[13:23:10.277]                           info <- base::paste(info, collapse = "; ")
[13:23:10.277]                           if (!has_future) {
[13:23:10.277]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.277]                               info)
[13:23:10.277]                           }
[13:23:10.277]                           else {
[13:23:10.277]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.277]                               info, version)
[13:23:10.277]                           }
[13:23:10.277]                           base::stop(msg)
[13:23:10.277]                         }
[13:23:10.277]                       })
[13:23:10.277]                     }
[13:23:10.277]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.277]                     base::options(mc.cores = 1L)
[13:23:10.277]                   }
[13:23:10.277]                   options(future.plan = NULL)
[13:23:10.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.277]                 }
[13:23:10.277]                 ...future.workdir <- getwd()
[13:23:10.277]             }
[13:23:10.277]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.277]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.277]         }
[13:23:10.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.277]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.277]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.277]             base::names(...future.oldOptions))
[13:23:10.277]     }
[13:23:10.277]     if (FALSE) {
[13:23:10.277]     }
[13:23:10.277]     else {
[13:23:10.277]         if (TRUE) {
[13:23:10.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.277]                 open = "w")
[13:23:10.277]         }
[13:23:10.277]         else {
[13:23:10.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.277]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.277]         }
[13:23:10.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.277]             base::sink(type = "output", split = FALSE)
[13:23:10.277]             base::close(...future.stdout)
[13:23:10.277]         }, add = TRUE)
[13:23:10.277]     }
[13:23:10.277]     ...future.frame <- base::sys.nframe()
[13:23:10.277]     ...future.conditions <- base::list()
[13:23:10.277]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.277]     if (FALSE) {
[13:23:10.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.277]     }
[13:23:10.277]     ...future.result <- base::tryCatch({
[13:23:10.277]         base::withCallingHandlers({
[13:23:10.277]             ...future.value <- base::withVisible(base::local({
[13:23:10.277]                 ...future.makeSendCondition <- base::local({
[13:23:10.277]                   sendCondition <- NULL
[13:23:10.277]                   function(frame = 1L) {
[13:23:10.277]                     if (is.function(sendCondition)) 
[13:23:10.277]                       return(sendCondition)
[13:23:10.277]                     ns <- getNamespace("parallel")
[13:23:10.277]                     if (exists("sendData", mode = "function", 
[13:23:10.277]                       envir = ns)) {
[13:23:10.277]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.277]                         envir = ns)
[13:23:10.277]                       envir <- sys.frame(frame)
[13:23:10.277]                       master <- NULL
[13:23:10.277]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.277]                         !identical(envir, emptyenv())) {
[13:23:10.277]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.277]                           inherits = FALSE)) {
[13:23:10.277]                           master <- get("master", mode = "list", 
[13:23:10.277]                             envir = envir, inherits = FALSE)
[13:23:10.277]                           if (inherits(master, c("SOCKnode", 
[13:23:10.277]                             "SOCK0node"))) {
[13:23:10.277]                             sendCondition <<- function(cond) {
[13:23:10.277]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.277]                                 success = TRUE)
[13:23:10.277]                               parallel_sendData(master, data)
[13:23:10.277]                             }
[13:23:10.277]                             return(sendCondition)
[13:23:10.277]                           }
[13:23:10.277]                         }
[13:23:10.277]                         frame <- frame + 1L
[13:23:10.277]                         envir <- sys.frame(frame)
[13:23:10.277]                       }
[13:23:10.277]                     }
[13:23:10.277]                     sendCondition <<- function(cond) NULL
[13:23:10.277]                   }
[13:23:10.277]                 })
[13:23:10.277]                 withCallingHandlers({
[13:23:10.277]                   NA
[13:23:10.277]                 }, immediateCondition = function(cond) {
[13:23:10.277]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.277]                   sendCondition(cond)
[13:23:10.277]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.277]                   {
[13:23:10.277]                     inherits <- base::inherits
[13:23:10.277]                     invokeRestart <- base::invokeRestart
[13:23:10.277]                     is.null <- base::is.null
[13:23:10.277]                     muffled <- FALSE
[13:23:10.277]                     if (inherits(cond, "message")) {
[13:23:10.277]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.277]                       if (muffled) 
[13:23:10.277]                         invokeRestart("muffleMessage")
[13:23:10.277]                     }
[13:23:10.277]                     else if (inherits(cond, "warning")) {
[13:23:10.277]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.277]                       if (muffled) 
[13:23:10.277]                         invokeRestart("muffleWarning")
[13:23:10.277]                     }
[13:23:10.277]                     else if (inherits(cond, "condition")) {
[13:23:10.277]                       if (!is.null(pattern)) {
[13:23:10.277]                         computeRestarts <- base::computeRestarts
[13:23:10.277]                         grepl <- base::grepl
[13:23:10.277]                         restarts <- computeRestarts(cond)
[13:23:10.277]                         for (restart in restarts) {
[13:23:10.277]                           name <- restart$name
[13:23:10.277]                           if (is.null(name)) 
[13:23:10.277]                             next
[13:23:10.277]                           if (!grepl(pattern, name)) 
[13:23:10.277]                             next
[13:23:10.277]                           invokeRestart(restart)
[13:23:10.277]                           muffled <- TRUE
[13:23:10.277]                           break
[13:23:10.277]                         }
[13:23:10.277]                       }
[13:23:10.277]                     }
[13:23:10.277]                     invisible(muffled)
[13:23:10.277]                   }
[13:23:10.277]                   muffleCondition(cond)
[13:23:10.277]                 })
[13:23:10.277]             }))
[13:23:10.277]             future::FutureResult(value = ...future.value$value, 
[13:23:10.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.277]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.277]                     ...future.globalenv.names))
[13:23:10.277]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.277]         }, condition = base::local({
[13:23:10.277]             c <- base::c
[13:23:10.277]             inherits <- base::inherits
[13:23:10.277]             invokeRestart <- base::invokeRestart
[13:23:10.277]             length <- base::length
[13:23:10.277]             list <- base::list
[13:23:10.277]             seq.int <- base::seq.int
[13:23:10.277]             signalCondition <- base::signalCondition
[13:23:10.277]             sys.calls <- base::sys.calls
[13:23:10.277]             `[[` <- base::`[[`
[13:23:10.277]             `+` <- base::`+`
[13:23:10.277]             `<<-` <- base::`<<-`
[13:23:10.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.277]                   3L)]
[13:23:10.277]             }
[13:23:10.277]             function(cond) {
[13:23:10.277]                 is_error <- inherits(cond, "error")
[13:23:10.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.277]                   NULL)
[13:23:10.277]                 if (is_error) {
[13:23:10.277]                   sessionInformation <- function() {
[13:23:10.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.277]                       search = base::search(), system = base::Sys.info())
[13:23:10.277]                   }
[13:23:10.277]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.277]                     cond$call), session = sessionInformation(), 
[13:23:10.277]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.277]                   signalCondition(cond)
[13:23:10.277]                 }
[13:23:10.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.277]                 "immediateCondition"))) {
[13:23:10.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.277]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.277]                   if (TRUE && !signal) {
[13:23:10.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.277]                     {
[13:23:10.277]                       inherits <- base::inherits
[13:23:10.277]                       invokeRestart <- base::invokeRestart
[13:23:10.277]                       is.null <- base::is.null
[13:23:10.277]                       muffled <- FALSE
[13:23:10.277]                       if (inherits(cond, "message")) {
[13:23:10.277]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.277]                         if (muffled) 
[13:23:10.277]                           invokeRestart("muffleMessage")
[13:23:10.277]                       }
[13:23:10.277]                       else if (inherits(cond, "warning")) {
[13:23:10.277]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.277]                         if (muffled) 
[13:23:10.277]                           invokeRestart("muffleWarning")
[13:23:10.277]                       }
[13:23:10.277]                       else if (inherits(cond, "condition")) {
[13:23:10.277]                         if (!is.null(pattern)) {
[13:23:10.277]                           computeRestarts <- base::computeRestarts
[13:23:10.277]                           grepl <- base::grepl
[13:23:10.277]                           restarts <- computeRestarts(cond)
[13:23:10.277]                           for (restart in restarts) {
[13:23:10.277]                             name <- restart$name
[13:23:10.277]                             if (is.null(name)) 
[13:23:10.277]                               next
[13:23:10.277]                             if (!grepl(pattern, name)) 
[13:23:10.277]                               next
[13:23:10.277]                             invokeRestart(restart)
[13:23:10.277]                             muffled <- TRUE
[13:23:10.277]                             break
[13:23:10.277]                           }
[13:23:10.277]                         }
[13:23:10.277]                       }
[13:23:10.277]                       invisible(muffled)
[13:23:10.277]                     }
[13:23:10.277]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.277]                   }
[13:23:10.277]                 }
[13:23:10.277]                 else {
[13:23:10.277]                   if (TRUE) {
[13:23:10.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.277]                     {
[13:23:10.277]                       inherits <- base::inherits
[13:23:10.277]                       invokeRestart <- base::invokeRestart
[13:23:10.277]                       is.null <- base::is.null
[13:23:10.277]                       muffled <- FALSE
[13:23:10.277]                       if (inherits(cond, "message")) {
[13:23:10.277]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.277]                         if (muffled) 
[13:23:10.277]                           invokeRestart("muffleMessage")
[13:23:10.277]                       }
[13:23:10.277]                       else if (inherits(cond, "warning")) {
[13:23:10.277]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.277]                         if (muffled) 
[13:23:10.277]                           invokeRestart("muffleWarning")
[13:23:10.277]                       }
[13:23:10.277]                       else if (inherits(cond, "condition")) {
[13:23:10.277]                         if (!is.null(pattern)) {
[13:23:10.277]                           computeRestarts <- base::computeRestarts
[13:23:10.277]                           grepl <- base::grepl
[13:23:10.277]                           restarts <- computeRestarts(cond)
[13:23:10.277]                           for (restart in restarts) {
[13:23:10.277]                             name <- restart$name
[13:23:10.277]                             if (is.null(name)) 
[13:23:10.277]                               next
[13:23:10.277]                             if (!grepl(pattern, name)) 
[13:23:10.277]                               next
[13:23:10.277]                             invokeRestart(restart)
[13:23:10.277]                             muffled <- TRUE
[13:23:10.277]                             break
[13:23:10.277]                           }
[13:23:10.277]                         }
[13:23:10.277]                       }
[13:23:10.277]                       invisible(muffled)
[13:23:10.277]                     }
[13:23:10.277]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.277]                   }
[13:23:10.277]                 }
[13:23:10.277]             }
[13:23:10.277]         }))
[13:23:10.277]     }, error = function(ex) {
[13:23:10.277]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.277]                 ...future.rng), started = ...future.startTime, 
[13:23:10.277]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.277]             version = "1.8"), class = "FutureResult")
[13:23:10.277]     }, finally = {
[13:23:10.277]         if (!identical(...future.workdir, getwd())) 
[13:23:10.277]             setwd(...future.workdir)
[13:23:10.277]         {
[13:23:10.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.277]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.277]             }
[13:23:10.277]             base::options(...future.oldOptions)
[13:23:10.277]             if (.Platform$OS.type == "windows") {
[13:23:10.277]                 old_names <- names(...future.oldEnvVars)
[13:23:10.277]                 envs <- base::Sys.getenv()
[13:23:10.277]                 names <- names(envs)
[13:23:10.277]                 common <- intersect(names, old_names)
[13:23:10.277]                 added <- setdiff(names, old_names)
[13:23:10.277]                 removed <- setdiff(old_names, names)
[13:23:10.277]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.277]                   envs[common]]
[13:23:10.277]                 NAMES <- toupper(changed)
[13:23:10.277]                 args <- list()
[13:23:10.277]                 for (kk in seq_along(NAMES)) {
[13:23:10.277]                   name <- changed[[kk]]
[13:23:10.277]                   NAME <- NAMES[[kk]]
[13:23:10.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.277]                     next
[13:23:10.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.277]                 }
[13:23:10.277]                 NAMES <- toupper(added)
[13:23:10.277]                 for (kk in seq_along(NAMES)) {
[13:23:10.277]                   name <- added[[kk]]
[13:23:10.277]                   NAME <- NAMES[[kk]]
[13:23:10.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.277]                     next
[13:23:10.277]                   args[[name]] <- ""
[13:23:10.277]                 }
[13:23:10.277]                 NAMES <- toupper(removed)
[13:23:10.277]                 for (kk in seq_along(NAMES)) {
[13:23:10.277]                   name <- removed[[kk]]
[13:23:10.277]                   NAME <- NAMES[[kk]]
[13:23:10.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.277]                     next
[13:23:10.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.277]                 }
[13:23:10.277]                 if (length(args) > 0) 
[13:23:10.277]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.277]             }
[13:23:10.277]             else {
[13:23:10.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.277]             }
[13:23:10.277]             {
[13:23:10.277]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.277]                   0L) {
[13:23:10.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.277]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.277]                   base::options(opts)
[13:23:10.277]                 }
[13:23:10.277]                 {
[13:23:10.277]                   {
[13:23:10.277]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.277]                     NULL
[13:23:10.277]                   }
[13:23:10.277]                   options(future.plan = NULL)
[13:23:10.277]                   if (is.na(NA_character_)) 
[13:23:10.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.277]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.277]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.277]                     envir = parent.frame()) 
[13:23:10.277]                   {
[13:23:10.277]                     if (is.function(workers)) 
[13:23:10.277]                       workers <- workers()
[13:23:10.277]                     workers <- structure(as.integer(workers), 
[13:23:10.277]                       class = class(workers))
[13:23:10.277]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.277]                       workers >= 1)
[13:23:10.277]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.277]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.277]                     }
[13:23:10.277]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.277]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.277]                       envir = envir)
[13:23:10.277]                     if (!future$lazy) 
[13:23:10.277]                       future <- run(future)
[13:23:10.277]                     invisible(future)
[13:23:10.277]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.277]                 }
[13:23:10.277]             }
[13:23:10.277]         }
[13:23:10.277]     })
[13:23:10.277]     if (TRUE) {
[13:23:10.277]         base::sink(type = "output", split = FALSE)
[13:23:10.277]         if (TRUE) {
[13:23:10.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.277]         }
[13:23:10.277]         else {
[13:23:10.277]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.277]         }
[13:23:10.277]         base::close(...future.stdout)
[13:23:10.277]         ...future.stdout <- NULL
[13:23:10.277]     }
[13:23:10.277]     ...future.result$conditions <- ...future.conditions
[13:23:10.277]     ...future.result$finished <- base::Sys.time()
[13:23:10.277]     ...future.result
[13:23:10.277] }
[13:23:10.336] MultisessionFuture started
[13:23:10.336] result() for ClusterFuture ...
[13:23:10.336] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.336] - Validating connection of MultisessionFuture
[13:23:10.383] - received message: FutureResult
[13:23:10.384] - Received FutureResult
[13:23:10.384] - Erased future from FutureRegistry
[13:23:10.384] result() for ClusterFuture ...
[13:23:10.384] - result already collected: FutureResult
[13:23:10.384] result() for ClusterFuture ... done
[13:23:10.384] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:10.384] result() for ClusterFuture ... done
[13:23:10.384] result() for ClusterFuture ...
[13:23:10.385] - result already collected: FutureResult
[13:23:10.385] result() for ClusterFuture ... done
[13:23:10.385] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:23:10.388] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[13:23:10.389] getGlobalsAndPackages() ...
[13:23:10.389] Searching for globals...
[13:23:10.389] 
[13:23:10.389] Searching for globals ... DONE
[13:23:10.390] - globals: [0] <none>
[13:23:10.390] getGlobalsAndPackages() ... DONE
[13:23:10.390] run() for ‘Future’ ...
[13:23:10.390] - state: ‘created’
[13:23:10.390] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.412] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.413]   - Field: ‘node’
[13:23:10.413]   - Field: ‘label’
[13:23:10.413]   - Field: ‘local’
[13:23:10.413]   - Field: ‘owner’
[13:23:10.413]   - Field: ‘envir’
[13:23:10.413]   - Field: ‘workers’
[13:23:10.413]   - Field: ‘packages’
[13:23:10.413]   - Field: ‘gc’
[13:23:10.414]   - Field: ‘conditions’
[13:23:10.414]   - Field: ‘persistent’
[13:23:10.414]   - Field: ‘expr’
[13:23:10.414]   - Field: ‘uuid’
[13:23:10.414]   - Field: ‘seed’
[13:23:10.414]   - Field: ‘version’
[13:23:10.414]   - Field: ‘result’
[13:23:10.414]   - Field: ‘asynchronous’
[13:23:10.414]   - Field: ‘calls’
[13:23:10.414]   - Field: ‘globals’
[13:23:10.414]   - Field: ‘stdout’
[13:23:10.415]   - Field: ‘earlySignal’
[13:23:10.415]   - Field: ‘lazy’
[13:23:10.415]   - Field: ‘state’
[13:23:10.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.415] - Launch lazy future ...
[13:23:10.415] Packages needed by the future expression (n = 0): <none>
[13:23:10.415] Packages needed by future strategies (n = 0): <none>
[13:23:10.416] {
[13:23:10.416]     {
[13:23:10.416]         {
[13:23:10.416]             ...future.startTime <- base::Sys.time()
[13:23:10.416]             {
[13:23:10.416]                 {
[13:23:10.416]                   {
[13:23:10.416]                     {
[13:23:10.416]                       base::local({
[13:23:10.416]                         has_future <- base::requireNamespace("future", 
[13:23:10.416]                           quietly = TRUE)
[13:23:10.416]                         if (has_future) {
[13:23:10.416]                           ns <- base::getNamespace("future")
[13:23:10.416]                           version <- ns[[".package"]][["version"]]
[13:23:10.416]                           if (is.null(version)) 
[13:23:10.416]                             version <- utils::packageVersion("future")
[13:23:10.416]                         }
[13:23:10.416]                         else {
[13:23:10.416]                           version <- NULL
[13:23:10.416]                         }
[13:23:10.416]                         if (!has_future || version < "1.8.0") {
[13:23:10.416]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.416]                             "", base::R.version$version.string), 
[13:23:10.416]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.416]                               "release", "version")], collapse = " "), 
[13:23:10.416]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.416]                             info)
[13:23:10.416]                           info <- base::paste(info, collapse = "; ")
[13:23:10.416]                           if (!has_future) {
[13:23:10.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.416]                               info)
[13:23:10.416]                           }
[13:23:10.416]                           else {
[13:23:10.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.416]                               info, version)
[13:23:10.416]                           }
[13:23:10.416]                           base::stop(msg)
[13:23:10.416]                         }
[13:23:10.416]                       })
[13:23:10.416]                     }
[13:23:10.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.416]                     base::options(mc.cores = 1L)
[13:23:10.416]                   }
[13:23:10.416]                   options(future.plan = NULL)
[13:23:10.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.416]                 }
[13:23:10.416]                 ...future.workdir <- getwd()
[13:23:10.416]             }
[13:23:10.416]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.416]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.416]         }
[13:23:10.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.416]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.416]             base::names(...future.oldOptions))
[13:23:10.416]     }
[13:23:10.416]     if (FALSE) {
[13:23:10.416]     }
[13:23:10.416]     else {
[13:23:10.416]         if (TRUE) {
[13:23:10.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.416]                 open = "w")
[13:23:10.416]         }
[13:23:10.416]         else {
[13:23:10.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.416]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.416]         }
[13:23:10.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.416]             base::sink(type = "output", split = FALSE)
[13:23:10.416]             base::close(...future.stdout)
[13:23:10.416]         }, add = TRUE)
[13:23:10.416]     }
[13:23:10.416]     ...future.frame <- base::sys.nframe()
[13:23:10.416]     ...future.conditions <- base::list()
[13:23:10.416]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.416]     if (FALSE) {
[13:23:10.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.416]     }
[13:23:10.416]     ...future.result <- base::tryCatch({
[13:23:10.416]         base::withCallingHandlers({
[13:23:10.416]             ...future.value <- base::withVisible(base::local({
[13:23:10.416]                 ...future.makeSendCondition <- base::local({
[13:23:10.416]                   sendCondition <- NULL
[13:23:10.416]                   function(frame = 1L) {
[13:23:10.416]                     if (is.function(sendCondition)) 
[13:23:10.416]                       return(sendCondition)
[13:23:10.416]                     ns <- getNamespace("parallel")
[13:23:10.416]                     if (exists("sendData", mode = "function", 
[13:23:10.416]                       envir = ns)) {
[13:23:10.416]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.416]                         envir = ns)
[13:23:10.416]                       envir <- sys.frame(frame)
[13:23:10.416]                       master <- NULL
[13:23:10.416]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.416]                         !identical(envir, emptyenv())) {
[13:23:10.416]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.416]                           inherits = FALSE)) {
[13:23:10.416]                           master <- get("master", mode = "list", 
[13:23:10.416]                             envir = envir, inherits = FALSE)
[13:23:10.416]                           if (inherits(master, c("SOCKnode", 
[13:23:10.416]                             "SOCK0node"))) {
[13:23:10.416]                             sendCondition <<- function(cond) {
[13:23:10.416]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.416]                                 success = TRUE)
[13:23:10.416]                               parallel_sendData(master, data)
[13:23:10.416]                             }
[13:23:10.416]                             return(sendCondition)
[13:23:10.416]                           }
[13:23:10.416]                         }
[13:23:10.416]                         frame <- frame + 1L
[13:23:10.416]                         envir <- sys.frame(frame)
[13:23:10.416]                       }
[13:23:10.416]                     }
[13:23:10.416]                     sendCondition <<- function(cond) NULL
[13:23:10.416]                   }
[13:23:10.416]                 })
[13:23:10.416]                 withCallingHandlers({
[13:23:10.416]                   2
[13:23:10.416]                 }, immediateCondition = function(cond) {
[13:23:10.416]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.416]                   sendCondition(cond)
[13:23:10.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.416]                   {
[13:23:10.416]                     inherits <- base::inherits
[13:23:10.416]                     invokeRestart <- base::invokeRestart
[13:23:10.416]                     is.null <- base::is.null
[13:23:10.416]                     muffled <- FALSE
[13:23:10.416]                     if (inherits(cond, "message")) {
[13:23:10.416]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.416]                       if (muffled) 
[13:23:10.416]                         invokeRestart("muffleMessage")
[13:23:10.416]                     }
[13:23:10.416]                     else if (inherits(cond, "warning")) {
[13:23:10.416]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.416]                       if (muffled) 
[13:23:10.416]                         invokeRestart("muffleWarning")
[13:23:10.416]                     }
[13:23:10.416]                     else if (inherits(cond, "condition")) {
[13:23:10.416]                       if (!is.null(pattern)) {
[13:23:10.416]                         computeRestarts <- base::computeRestarts
[13:23:10.416]                         grepl <- base::grepl
[13:23:10.416]                         restarts <- computeRestarts(cond)
[13:23:10.416]                         for (restart in restarts) {
[13:23:10.416]                           name <- restart$name
[13:23:10.416]                           if (is.null(name)) 
[13:23:10.416]                             next
[13:23:10.416]                           if (!grepl(pattern, name)) 
[13:23:10.416]                             next
[13:23:10.416]                           invokeRestart(restart)
[13:23:10.416]                           muffled <- TRUE
[13:23:10.416]                           break
[13:23:10.416]                         }
[13:23:10.416]                       }
[13:23:10.416]                     }
[13:23:10.416]                     invisible(muffled)
[13:23:10.416]                   }
[13:23:10.416]                   muffleCondition(cond)
[13:23:10.416]                 })
[13:23:10.416]             }))
[13:23:10.416]             future::FutureResult(value = ...future.value$value, 
[13:23:10.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.416]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.416]                     ...future.globalenv.names))
[13:23:10.416]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.416]         }, condition = base::local({
[13:23:10.416]             c <- base::c
[13:23:10.416]             inherits <- base::inherits
[13:23:10.416]             invokeRestart <- base::invokeRestart
[13:23:10.416]             length <- base::length
[13:23:10.416]             list <- base::list
[13:23:10.416]             seq.int <- base::seq.int
[13:23:10.416]             signalCondition <- base::signalCondition
[13:23:10.416]             sys.calls <- base::sys.calls
[13:23:10.416]             `[[` <- base::`[[`
[13:23:10.416]             `+` <- base::`+`
[13:23:10.416]             `<<-` <- base::`<<-`
[13:23:10.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.416]                   3L)]
[13:23:10.416]             }
[13:23:10.416]             function(cond) {
[13:23:10.416]                 is_error <- inherits(cond, "error")
[13:23:10.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.416]                   NULL)
[13:23:10.416]                 if (is_error) {
[13:23:10.416]                   sessionInformation <- function() {
[13:23:10.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.416]                       search = base::search(), system = base::Sys.info())
[13:23:10.416]                   }
[13:23:10.416]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.416]                     cond$call), session = sessionInformation(), 
[13:23:10.416]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.416]                   signalCondition(cond)
[13:23:10.416]                 }
[13:23:10.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.416]                 "immediateCondition"))) {
[13:23:10.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.416]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.416]                   if (TRUE && !signal) {
[13:23:10.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.416]                     {
[13:23:10.416]                       inherits <- base::inherits
[13:23:10.416]                       invokeRestart <- base::invokeRestart
[13:23:10.416]                       is.null <- base::is.null
[13:23:10.416]                       muffled <- FALSE
[13:23:10.416]                       if (inherits(cond, "message")) {
[13:23:10.416]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.416]                         if (muffled) 
[13:23:10.416]                           invokeRestart("muffleMessage")
[13:23:10.416]                       }
[13:23:10.416]                       else if (inherits(cond, "warning")) {
[13:23:10.416]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.416]                         if (muffled) 
[13:23:10.416]                           invokeRestart("muffleWarning")
[13:23:10.416]                       }
[13:23:10.416]                       else if (inherits(cond, "condition")) {
[13:23:10.416]                         if (!is.null(pattern)) {
[13:23:10.416]                           computeRestarts <- base::computeRestarts
[13:23:10.416]                           grepl <- base::grepl
[13:23:10.416]                           restarts <- computeRestarts(cond)
[13:23:10.416]                           for (restart in restarts) {
[13:23:10.416]                             name <- restart$name
[13:23:10.416]                             if (is.null(name)) 
[13:23:10.416]                               next
[13:23:10.416]                             if (!grepl(pattern, name)) 
[13:23:10.416]                               next
[13:23:10.416]                             invokeRestart(restart)
[13:23:10.416]                             muffled <- TRUE
[13:23:10.416]                             break
[13:23:10.416]                           }
[13:23:10.416]                         }
[13:23:10.416]                       }
[13:23:10.416]                       invisible(muffled)
[13:23:10.416]                     }
[13:23:10.416]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.416]                   }
[13:23:10.416]                 }
[13:23:10.416]                 else {
[13:23:10.416]                   if (TRUE) {
[13:23:10.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.416]                     {
[13:23:10.416]                       inherits <- base::inherits
[13:23:10.416]                       invokeRestart <- base::invokeRestart
[13:23:10.416]                       is.null <- base::is.null
[13:23:10.416]                       muffled <- FALSE
[13:23:10.416]                       if (inherits(cond, "message")) {
[13:23:10.416]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.416]                         if (muffled) 
[13:23:10.416]                           invokeRestart("muffleMessage")
[13:23:10.416]                       }
[13:23:10.416]                       else if (inherits(cond, "warning")) {
[13:23:10.416]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.416]                         if (muffled) 
[13:23:10.416]                           invokeRestart("muffleWarning")
[13:23:10.416]                       }
[13:23:10.416]                       else if (inherits(cond, "condition")) {
[13:23:10.416]                         if (!is.null(pattern)) {
[13:23:10.416]                           computeRestarts <- base::computeRestarts
[13:23:10.416]                           grepl <- base::grepl
[13:23:10.416]                           restarts <- computeRestarts(cond)
[13:23:10.416]                           for (restart in restarts) {
[13:23:10.416]                             name <- restart$name
[13:23:10.416]                             if (is.null(name)) 
[13:23:10.416]                               next
[13:23:10.416]                             if (!grepl(pattern, name)) 
[13:23:10.416]                               next
[13:23:10.416]                             invokeRestart(restart)
[13:23:10.416]                             muffled <- TRUE
[13:23:10.416]                             break
[13:23:10.416]                           }
[13:23:10.416]                         }
[13:23:10.416]                       }
[13:23:10.416]                       invisible(muffled)
[13:23:10.416]                     }
[13:23:10.416]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.416]                   }
[13:23:10.416]                 }
[13:23:10.416]             }
[13:23:10.416]         }))
[13:23:10.416]     }, error = function(ex) {
[13:23:10.416]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.416]                 ...future.rng), started = ...future.startTime, 
[13:23:10.416]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.416]             version = "1.8"), class = "FutureResult")
[13:23:10.416]     }, finally = {
[13:23:10.416]         if (!identical(...future.workdir, getwd())) 
[13:23:10.416]             setwd(...future.workdir)
[13:23:10.416]         {
[13:23:10.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.416]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.416]             }
[13:23:10.416]             base::options(...future.oldOptions)
[13:23:10.416]             if (.Platform$OS.type == "windows") {
[13:23:10.416]                 old_names <- names(...future.oldEnvVars)
[13:23:10.416]                 envs <- base::Sys.getenv()
[13:23:10.416]                 names <- names(envs)
[13:23:10.416]                 common <- intersect(names, old_names)
[13:23:10.416]                 added <- setdiff(names, old_names)
[13:23:10.416]                 removed <- setdiff(old_names, names)
[13:23:10.416]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.416]                   envs[common]]
[13:23:10.416]                 NAMES <- toupper(changed)
[13:23:10.416]                 args <- list()
[13:23:10.416]                 for (kk in seq_along(NAMES)) {
[13:23:10.416]                   name <- changed[[kk]]
[13:23:10.416]                   NAME <- NAMES[[kk]]
[13:23:10.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.416]                     next
[13:23:10.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.416]                 }
[13:23:10.416]                 NAMES <- toupper(added)
[13:23:10.416]                 for (kk in seq_along(NAMES)) {
[13:23:10.416]                   name <- added[[kk]]
[13:23:10.416]                   NAME <- NAMES[[kk]]
[13:23:10.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.416]                     next
[13:23:10.416]                   args[[name]] <- ""
[13:23:10.416]                 }
[13:23:10.416]                 NAMES <- toupper(removed)
[13:23:10.416]                 for (kk in seq_along(NAMES)) {
[13:23:10.416]                   name <- removed[[kk]]
[13:23:10.416]                   NAME <- NAMES[[kk]]
[13:23:10.416]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.416]                     next
[13:23:10.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.416]                 }
[13:23:10.416]                 if (length(args) > 0) 
[13:23:10.416]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.416]             }
[13:23:10.416]             else {
[13:23:10.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.416]             }
[13:23:10.416]             {
[13:23:10.416]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.416]                   0L) {
[13:23:10.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.416]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.416]                   base::options(opts)
[13:23:10.416]                 }
[13:23:10.416]                 {
[13:23:10.416]                   {
[13:23:10.416]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.416]                     NULL
[13:23:10.416]                   }
[13:23:10.416]                   options(future.plan = NULL)
[13:23:10.416]                   if (is.na(NA_character_)) 
[13:23:10.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.416]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.416]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.416]                     envir = parent.frame()) 
[13:23:10.416]                   {
[13:23:10.416]                     if (is.function(workers)) 
[13:23:10.416]                       workers <- workers()
[13:23:10.416]                     workers <- structure(as.integer(workers), 
[13:23:10.416]                       class = class(workers))
[13:23:10.416]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.416]                       workers >= 1)
[13:23:10.416]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.416]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.416]                     }
[13:23:10.416]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.416]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.416]                       envir = envir)
[13:23:10.416]                     if (!future$lazy) 
[13:23:10.416]                       future <- run(future)
[13:23:10.416]                     invisible(future)
[13:23:10.416]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.416]                 }
[13:23:10.416]             }
[13:23:10.416]         }
[13:23:10.416]     })
[13:23:10.416]     if (TRUE) {
[13:23:10.416]         base::sink(type = "output", split = FALSE)
[13:23:10.416]         if (TRUE) {
[13:23:10.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.416]         }
[13:23:10.416]         else {
[13:23:10.416]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.416]         }
[13:23:10.416]         base::close(...future.stdout)
[13:23:10.416]         ...future.stdout <- NULL
[13:23:10.416]     }
[13:23:10.416]     ...future.result$conditions <- ...future.conditions
[13:23:10.416]     ...future.result$finished <- base::Sys.time()
[13:23:10.416]     ...future.result
[13:23:10.416] }
[13:23:10.419] MultisessionFuture started
[13:23:10.420] - Launch lazy future ... done
[13:23:10.420] run() for ‘MultisessionFuture’ ... done
[13:23:10.420] getGlobalsAndPackages() ...
[13:23:10.420] Searching for globals...
[13:23:10.421] 
[13:23:10.421] Searching for globals ... DONE
[13:23:10.421] - globals: [0] <none>
[13:23:10.421] getGlobalsAndPackages() ... DONE
[13:23:10.421] run() for ‘Future’ ...
[13:23:10.421] - state: ‘created’
[13:23:10.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.436]   - Field: ‘node’
[13:23:10.437]   - Field: ‘label’
[13:23:10.437]   - Field: ‘local’
[13:23:10.437]   - Field: ‘owner’
[13:23:10.437]   - Field: ‘envir’
[13:23:10.437]   - Field: ‘workers’
[13:23:10.437]   - Field: ‘packages’
[13:23:10.437]   - Field: ‘gc’
[13:23:10.437]   - Field: ‘conditions’
[13:23:10.437]   - Field: ‘persistent’
[13:23:10.438]   - Field: ‘expr’
[13:23:10.438]   - Field: ‘uuid’
[13:23:10.438]   - Field: ‘seed’
[13:23:10.438]   - Field: ‘version’
[13:23:10.438]   - Field: ‘result’
[13:23:10.438]   - Field: ‘asynchronous’
[13:23:10.438]   - Field: ‘calls’
[13:23:10.438]   - Field: ‘globals’
[13:23:10.438]   - Field: ‘stdout’
[13:23:10.438]   - Field: ‘earlySignal’
[13:23:10.438]   - Field: ‘lazy’
[13:23:10.439]   - Field: ‘state’
[13:23:10.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.439] - Launch lazy future ...
[13:23:10.439] Packages needed by the future expression (n = 0): <none>
[13:23:10.439] Packages needed by future strategies (n = 0): <none>
[13:23:10.440] {
[13:23:10.440]     {
[13:23:10.440]         {
[13:23:10.440]             ...future.startTime <- base::Sys.time()
[13:23:10.440]             {
[13:23:10.440]                 {
[13:23:10.440]                   {
[13:23:10.440]                     {
[13:23:10.440]                       base::local({
[13:23:10.440]                         has_future <- base::requireNamespace("future", 
[13:23:10.440]                           quietly = TRUE)
[13:23:10.440]                         if (has_future) {
[13:23:10.440]                           ns <- base::getNamespace("future")
[13:23:10.440]                           version <- ns[[".package"]][["version"]]
[13:23:10.440]                           if (is.null(version)) 
[13:23:10.440]                             version <- utils::packageVersion("future")
[13:23:10.440]                         }
[13:23:10.440]                         else {
[13:23:10.440]                           version <- NULL
[13:23:10.440]                         }
[13:23:10.440]                         if (!has_future || version < "1.8.0") {
[13:23:10.440]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.440]                             "", base::R.version$version.string), 
[13:23:10.440]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.440]                               "release", "version")], collapse = " "), 
[13:23:10.440]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.440]                             info)
[13:23:10.440]                           info <- base::paste(info, collapse = "; ")
[13:23:10.440]                           if (!has_future) {
[13:23:10.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.440]                               info)
[13:23:10.440]                           }
[13:23:10.440]                           else {
[13:23:10.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.440]                               info, version)
[13:23:10.440]                           }
[13:23:10.440]                           base::stop(msg)
[13:23:10.440]                         }
[13:23:10.440]                       })
[13:23:10.440]                     }
[13:23:10.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.440]                     base::options(mc.cores = 1L)
[13:23:10.440]                   }
[13:23:10.440]                   options(future.plan = NULL)
[13:23:10.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.440]                 }
[13:23:10.440]                 ...future.workdir <- getwd()
[13:23:10.440]             }
[13:23:10.440]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.440]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.440]         }
[13:23:10.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.440]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.440]             base::names(...future.oldOptions))
[13:23:10.440]     }
[13:23:10.440]     if (FALSE) {
[13:23:10.440]     }
[13:23:10.440]     else {
[13:23:10.440]         if (TRUE) {
[13:23:10.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.440]                 open = "w")
[13:23:10.440]         }
[13:23:10.440]         else {
[13:23:10.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.440]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.440]         }
[13:23:10.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.440]             base::sink(type = "output", split = FALSE)
[13:23:10.440]             base::close(...future.stdout)
[13:23:10.440]         }, add = TRUE)
[13:23:10.440]     }
[13:23:10.440]     ...future.frame <- base::sys.nframe()
[13:23:10.440]     ...future.conditions <- base::list()
[13:23:10.440]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.440]     if (FALSE) {
[13:23:10.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.440]     }
[13:23:10.440]     ...future.result <- base::tryCatch({
[13:23:10.440]         base::withCallingHandlers({
[13:23:10.440]             ...future.value <- base::withVisible(base::local({
[13:23:10.440]                 ...future.makeSendCondition <- base::local({
[13:23:10.440]                   sendCondition <- NULL
[13:23:10.440]                   function(frame = 1L) {
[13:23:10.440]                     if (is.function(sendCondition)) 
[13:23:10.440]                       return(sendCondition)
[13:23:10.440]                     ns <- getNamespace("parallel")
[13:23:10.440]                     if (exists("sendData", mode = "function", 
[13:23:10.440]                       envir = ns)) {
[13:23:10.440]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.440]                         envir = ns)
[13:23:10.440]                       envir <- sys.frame(frame)
[13:23:10.440]                       master <- NULL
[13:23:10.440]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.440]                         !identical(envir, emptyenv())) {
[13:23:10.440]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.440]                           inherits = FALSE)) {
[13:23:10.440]                           master <- get("master", mode = "list", 
[13:23:10.440]                             envir = envir, inherits = FALSE)
[13:23:10.440]                           if (inherits(master, c("SOCKnode", 
[13:23:10.440]                             "SOCK0node"))) {
[13:23:10.440]                             sendCondition <<- function(cond) {
[13:23:10.440]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.440]                                 success = TRUE)
[13:23:10.440]                               parallel_sendData(master, data)
[13:23:10.440]                             }
[13:23:10.440]                             return(sendCondition)
[13:23:10.440]                           }
[13:23:10.440]                         }
[13:23:10.440]                         frame <- frame + 1L
[13:23:10.440]                         envir <- sys.frame(frame)
[13:23:10.440]                       }
[13:23:10.440]                     }
[13:23:10.440]                     sendCondition <<- function(cond) NULL
[13:23:10.440]                   }
[13:23:10.440]                 })
[13:23:10.440]                 withCallingHandlers({
[13:23:10.440]                   NULL
[13:23:10.440]                 }, immediateCondition = function(cond) {
[13:23:10.440]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.440]                   sendCondition(cond)
[13:23:10.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.440]                   {
[13:23:10.440]                     inherits <- base::inherits
[13:23:10.440]                     invokeRestart <- base::invokeRestart
[13:23:10.440]                     is.null <- base::is.null
[13:23:10.440]                     muffled <- FALSE
[13:23:10.440]                     if (inherits(cond, "message")) {
[13:23:10.440]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.440]                       if (muffled) 
[13:23:10.440]                         invokeRestart("muffleMessage")
[13:23:10.440]                     }
[13:23:10.440]                     else if (inherits(cond, "warning")) {
[13:23:10.440]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.440]                       if (muffled) 
[13:23:10.440]                         invokeRestart("muffleWarning")
[13:23:10.440]                     }
[13:23:10.440]                     else if (inherits(cond, "condition")) {
[13:23:10.440]                       if (!is.null(pattern)) {
[13:23:10.440]                         computeRestarts <- base::computeRestarts
[13:23:10.440]                         grepl <- base::grepl
[13:23:10.440]                         restarts <- computeRestarts(cond)
[13:23:10.440]                         for (restart in restarts) {
[13:23:10.440]                           name <- restart$name
[13:23:10.440]                           if (is.null(name)) 
[13:23:10.440]                             next
[13:23:10.440]                           if (!grepl(pattern, name)) 
[13:23:10.440]                             next
[13:23:10.440]                           invokeRestart(restart)
[13:23:10.440]                           muffled <- TRUE
[13:23:10.440]                           break
[13:23:10.440]                         }
[13:23:10.440]                       }
[13:23:10.440]                     }
[13:23:10.440]                     invisible(muffled)
[13:23:10.440]                   }
[13:23:10.440]                   muffleCondition(cond)
[13:23:10.440]                 })
[13:23:10.440]             }))
[13:23:10.440]             future::FutureResult(value = ...future.value$value, 
[13:23:10.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.440]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.440]                     ...future.globalenv.names))
[13:23:10.440]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.440]         }, condition = base::local({
[13:23:10.440]             c <- base::c
[13:23:10.440]             inherits <- base::inherits
[13:23:10.440]             invokeRestart <- base::invokeRestart
[13:23:10.440]             length <- base::length
[13:23:10.440]             list <- base::list
[13:23:10.440]             seq.int <- base::seq.int
[13:23:10.440]             signalCondition <- base::signalCondition
[13:23:10.440]             sys.calls <- base::sys.calls
[13:23:10.440]             `[[` <- base::`[[`
[13:23:10.440]             `+` <- base::`+`
[13:23:10.440]             `<<-` <- base::`<<-`
[13:23:10.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.440]                   3L)]
[13:23:10.440]             }
[13:23:10.440]             function(cond) {
[13:23:10.440]                 is_error <- inherits(cond, "error")
[13:23:10.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.440]                   NULL)
[13:23:10.440]                 if (is_error) {
[13:23:10.440]                   sessionInformation <- function() {
[13:23:10.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.440]                       search = base::search(), system = base::Sys.info())
[13:23:10.440]                   }
[13:23:10.440]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.440]                     cond$call), session = sessionInformation(), 
[13:23:10.440]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.440]                   signalCondition(cond)
[13:23:10.440]                 }
[13:23:10.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.440]                 "immediateCondition"))) {
[13:23:10.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.440]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.440]                   if (TRUE && !signal) {
[13:23:10.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.440]                     {
[13:23:10.440]                       inherits <- base::inherits
[13:23:10.440]                       invokeRestart <- base::invokeRestart
[13:23:10.440]                       is.null <- base::is.null
[13:23:10.440]                       muffled <- FALSE
[13:23:10.440]                       if (inherits(cond, "message")) {
[13:23:10.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.440]                         if (muffled) 
[13:23:10.440]                           invokeRestart("muffleMessage")
[13:23:10.440]                       }
[13:23:10.440]                       else if (inherits(cond, "warning")) {
[13:23:10.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.440]                         if (muffled) 
[13:23:10.440]                           invokeRestart("muffleWarning")
[13:23:10.440]                       }
[13:23:10.440]                       else if (inherits(cond, "condition")) {
[13:23:10.440]                         if (!is.null(pattern)) {
[13:23:10.440]                           computeRestarts <- base::computeRestarts
[13:23:10.440]                           grepl <- base::grepl
[13:23:10.440]                           restarts <- computeRestarts(cond)
[13:23:10.440]                           for (restart in restarts) {
[13:23:10.440]                             name <- restart$name
[13:23:10.440]                             if (is.null(name)) 
[13:23:10.440]                               next
[13:23:10.440]                             if (!grepl(pattern, name)) 
[13:23:10.440]                               next
[13:23:10.440]                             invokeRestart(restart)
[13:23:10.440]                             muffled <- TRUE
[13:23:10.440]                             break
[13:23:10.440]                           }
[13:23:10.440]                         }
[13:23:10.440]                       }
[13:23:10.440]                       invisible(muffled)
[13:23:10.440]                     }
[13:23:10.440]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.440]                   }
[13:23:10.440]                 }
[13:23:10.440]                 else {
[13:23:10.440]                   if (TRUE) {
[13:23:10.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.440]                     {
[13:23:10.440]                       inherits <- base::inherits
[13:23:10.440]                       invokeRestart <- base::invokeRestart
[13:23:10.440]                       is.null <- base::is.null
[13:23:10.440]                       muffled <- FALSE
[13:23:10.440]                       if (inherits(cond, "message")) {
[13:23:10.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.440]                         if (muffled) 
[13:23:10.440]                           invokeRestart("muffleMessage")
[13:23:10.440]                       }
[13:23:10.440]                       else if (inherits(cond, "warning")) {
[13:23:10.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.440]                         if (muffled) 
[13:23:10.440]                           invokeRestart("muffleWarning")
[13:23:10.440]                       }
[13:23:10.440]                       else if (inherits(cond, "condition")) {
[13:23:10.440]                         if (!is.null(pattern)) {
[13:23:10.440]                           computeRestarts <- base::computeRestarts
[13:23:10.440]                           grepl <- base::grepl
[13:23:10.440]                           restarts <- computeRestarts(cond)
[13:23:10.440]                           for (restart in restarts) {
[13:23:10.440]                             name <- restart$name
[13:23:10.440]                             if (is.null(name)) 
[13:23:10.440]                               next
[13:23:10.440]                             if (!grepl(pattern, name)) 
[13:23:10.440]                               next
[13:23:10.440]                             invokeRestart(restart)
[13:23:10.440]                             muffled <- TRUE
[13:23:10.440]                             break
[13:23:10.440]                           }
[13:23:10.440]                         }
[13:23:10.440]                       }
[13:23:10.440]                       invisible(muffled)
[13:23:10.440]                     }
[13:23:10.440]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.440]                   }
[13:23:10.440]                 }
[13:23:10.440]             }
[13:23:10.440]         }))
[13:23:10.440]     }, error = function(ex) {
[13:23:10.440]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.440]                 ...future.rng), started = ...future.startTime, 
[13:23:10.440]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.440]             version = "1.8"), class = "FutureResult")
[13:23:10.440]     }, finally = {
[13:23:10.440]         if (!identical(...future.workdir, getwd())) 
[13:23:10.440]             setwd(...future.workdir)
[13:23:10.440]         {
[13:23:10.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.440]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.440]             }
[13:23:10.440]             base::options(...future.oldOptions)
[13:23:10.440]             if (.Platform$OS.type == "windows") {
[13:23:10.440]                 old_names <- names(...future.oldEnvVars)
[13:23:10.440]                 envs <- base::Sys.getenv()
[13:23:10.440]                 names <- names(envs)
[13:23:10.440]                 common <- intersect(names, old_names)
[13:23:10.440]                 added <- setdiff(names, old_names)
[13:23:10.440]                 removed <- setdiff(old_names, names)
[13:23:10.440]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.440]                   envs[common]]
[13:23:10.440]                 NAMES <- toupper(changed)
[13:23:10.440]                 args <- list()
[13:23:10.440]                 for (kk in seq_along(NAMES)) {
[13:23:10.440]                   name <- changed[[kk]]
[13:23:10.440]                   NAME <- NAMES[[kk]]
[13:23:10.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.440]                     next
[13:23:10.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.440]                 }
[13:23:10.440]                 NAMES <- toupper(added)
[13:23:10.440]                 for (kk in seq_along(NAMES)) {
[13:23:10.440]                   name <- added[[kk]]
[13:23:10.440]                   NAME <- NAMES[[kk]]
[13:23:10.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.440]                     next
[13:23:10.440]                   args[[name]] <- ""
[13:23:10.440]                 }
[13:23:10.440]                 NAMES <- toupper(removed)
[13:23:10.440]                 for (kk in seq_along(NAMES)) {
[13:23:10.440]                   name <- removed[[kk]]
[13:23:10.440]                   NAME <- NAMES[[kk]]
[13:23:10.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.440]                     next
[13:23:10.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.440]                 }
[13:23:10.440]                 if (length(args) > 0) 
[13:23:10.440]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.440]             }
[13:23:10.440]             else {
[13:23:10.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.440]             }
[13:23:10.440]             {
[13:23:10.440]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.440]                   0L) {
[13:23:10.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.440]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.440]                   base::options(opts)
[13:23:10.440]                 }
[13:23:10.440]                 {
[13:23:10.440]                   {
[13:23:10.440]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.440]                     NULL
[13:23:10.440]                   }
[13:23:10.440]                   options(future.plan = NULL)
[13:23:10.440]                   if (is.na(NA_character_)) 
[13:23:10.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.440]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.440]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.440]                     envir = parent.frame()) 
[13:23:10.440]                   {
[13:23:10.440]                     if (is.function(workers)) 
[13:23:10.440]                       workers <- workers()
[13:23:10.440]                     workers <- structure(as.integer(workers), 
[13:23:10.440]                       class = class(workers))
[13:23:10.440]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.440]                       workers >= 1)
[13:23:10.440]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.440]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.440]                     }
[13:23:10.440]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.440]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.440]                       envir = envir)
[13:23:10.440]                     if (!future$lazy) 
[13:23:10.440]                       future <- run(future)
[13:23:10.440]                     invisible(future)
[13:23:10.440]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.440]                 }
[13:23:10.440]             }
[13:23:10.440]         }
[13:23:10.440]     })
[13:23:10.440]     if (TRUE) {
[13:23:10.440]         base::sink(type = "output", split = FALSE)
[13:23:10.440]         if (TRUE) {
[13:23:10.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.440]         }
[13:23:10.440]         else {
[13:23:10.440]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.440]         }
[13:23:10.440]         base::close(...future.stdout)
[13:23:10.440]         ...future.stdout <- NULL
[13:23:10.440]     }
[13:23:10.440]     ...future.result$conditions <- ...future.conditions
[13:23:10.440]     ...future.result$finished <- base::Sys.time()
[13:23:10.440]     ...future.result
[13:23:10.440] }
[13:23:10.498] MultisessionFuture started
[13:23:10.498] - Launch lazy future ... done
[13:23:10.498] run() for ‘MultisessionFuture’ ... done
[13:23:10.498] getGlobalsAndPackages() ...
[13:23:10.498] Searching for globals...
[13:23:10.499] - globals found: [1] ‘{’
[13:23:10.499] Searching for globals ... DONE
[13:23:10.499] Resolving globals: FALSE
[13:23:10.500] 
[13:23:10.500] 
[13:23:10.500] getGlobalsAndPackages() ... DONE
[13:23:10.500] run() for ‘Future’ ...
[13:23:10.500] - state: ‘created’
[13:23:10.501] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.515] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.516]   - Field: ‘node’
[13:23:10.516]   - Field: ‘label’
[13:23:10.516]   - Field: ‘local’
[13:23:10.516]   - Field: ‘owner’
[13:23:10.516]   - Field: ‘envir’
[13:23:10.516]   - Field: ‘workers’
[13:23:10.516]   - Field: ‘packages’
[13:23:10.516]   - Field: ‘gc’
[13:23:10.516]   - Field: ‘conditions’
[13:23:10.517]   - Field: ‘persistent’
[13:23:10.517]   - Field: ‘expr’
[13:23:10.517]   - Field: ‘uuid’
[13:23:10.517]   - Field: ‘seed’
[13:23:10.517]   - Field: ‘version’
[13:23:10.517]   - Field: ‘result’
[13:23:10.517]   - Field: ‘asynchronous’
[13:23:10.517]   - Field: ‘calls’
[13:23:10.517]   - Field: ‘globals’
[13:23:10.517]   - Field: ‘stdout’
[13:23:10.518]   - Field: ‘earlySignal’
[13:23:10.518]   - Field: ‘lazy’
[13:23:10.518]   - Field: ‘state’
[13:23:10.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.518] - Launch lazy future ...
[13:23:10.518] Packages needed by the future expression (n = 0): <none>
[13:23:10.518] Packages needed by future strategies (n = 0): <none>
[13:23:10.519] {
[13:23:10.519]     {
[13:23:10.519]         {
[13:23:10.519]             ...future.startTime <- base::Sys.time()
[13:23:10.519]             {
[13:23:10.519]                 {
[13:23:10.519]                   {
[13:23:10.519]                     {
[13:23:10.519]                       base::local({
[13:23:10.519]                         has_future <- base::requireNamespace("future", 
[13:23:10.519]                           quietly = TRUE)
[13:23:10.519]                         if (has_future) {
[13:23:10.519]                           ns <- base::getNamespace("future")
[13:23:10.519]                           version <- ns[[".package"]][["version"]]
[13:23:10.519]                           if (is.null(version)) 
[13:23:10.519]                             version <- utils::packageVersion("future")
[13:23:10.519]                         }
[13:23:10.519]                         else {
[13:23:10.519]                           version <- NULL
[13:23:10.519]                         }
[13:23:10.519]                         if (!has_future || version < "1.8.0") {
[13:23:10.519]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.519]                             "", base::R.version$version.string), 
[13:23:10.519]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.519]                               "release", "version")], collapse = " "), 
[13:23:10.519]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.519]                             info)
[13:23:10.519]                           info <- base::paste(info, collapse = "; ")
[13:23:10.519]                           if (!has_future) {
[13:23:10.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.519]                               info)
[13:23:10.519]                           }
[13:23:10.519]                           else {
[13:23:10.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.519]                               info, version)
[13:23:10.519]                           }
[13:23:10.519]                           base::stop(msg)
[13:23:10.519]                         }
[13:23:10.519]                       })
[13:23:10.519]                     }
[13:23:10.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.519]                     base::options(mc.cores = 1L)
[13:23:10.519]                   }
[13:23:10.519]                   options(future.plan = NULL)
[13:23:10.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.519]                 }
[13:23:10.519]                 ...future.workdir <- getwd()
[13:23:10.519]             }
[13:23:10.519]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.519]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.519]         }
[13:23:10.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.519]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.519]             base::names(...future.oldOptions))
[13:23:10.519]     }
[13:23:10.519]     if (FALSE) {
[13:23:10.519]     }
[13:23:10.519]     else {
[13:23:10.519]         if (TRUE) {
[13:23:10.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.519]                 open = "w")
[13:23:10.519]         }
[13:23:10.519]         else {
[13:23:10.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.519]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.519]         }
[13:23:10.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.519]             base::sink(type = "output", split = FALSE)
[13:23:10.519]             base::close(...future.stdout)
[13:23:10.519]         }, add = TRUE)
[13:23:10.519]     }
[13:23:10.519]     ...future.frame <- base::sys.nframe()
[13:23:10.519]     ...future.conditions <- base::list()
[13:23:10.519]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.519]     if (FALSE) {
[13:23:10.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.519]     }
[13:23:10.519]     ...future.result <- base::tryCatch({
[13:23:10.519]         base::withCallingHandlers({
[13:23:10.519]             ...future.value <- base::withVisible(base::local({
[13:23:10.519]                 ...future.makeSendCondition <- base::local({
[13:23:10.519]                   sendCondition <- NULL
[13:23:10.519]                   function(frame = 1L) {
[13:23:10.519]                     if (is.function(sendCondition)) 
[13:23:10.519]                       return(sendCondition)
[13:23:10.519]                     ns <- getNamespace("parallel")
[13:23:10.519]                     if (exists("sendData", mode = "function", 
[13:23:10.519]                       envir = ns)) {
[13:23:10.519]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.519]                         envir = ns)
[13:23:10.519]                       envir <- sys.frame(frame)
[13:23:10.519]                       master <- NULL
[13:23:10.519]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.519]                         !identical(envir, emptyenv())) {
[13:23:10.519]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.519]                           inherits = FALSE)) {
[13:23:10.519]                           master <- get("master", mode = "list", 
[13:23:10.519]                             envir = envir, inherits = FALSE)
[13:23:10.519]                           if (inherits(master, c("SOCKnode", 
[13:23:10.519]                             "SOCK0node"))) {
[13:23:10.519]                             sendCondition <<- function(cond) {
[13:23:10.519]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.519]                                 success = TRUE)
[13:23:10.519]                               parallel_sendData(master, data)
[13:23:10.519]                             }
[13:23:10.519]                             return(sendCondition)
[13:23:10.519]                           }
[13:23:10.519]                         }
[13:23:10.519]                         frame <- frame + 1L
[13:23:10.519]                         envir <- sys.frame(frame)
[13:23:10.519]                       }
[13:23:10.519]                     }
[13:23:10.519]                     sendCondition <<- function(cond) NULL
[13:23:10.519]                   }
[13:23:10.519]                 })
[13:23:10.519]                 withCallingHandlers({
[13:23:10.519]                   {
[13:23:10.519]                     4
[13:23:10.519]                   }
[13:23:10.519]                 }, immediateCondition = function(cond) {
[13:23:10.519]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.519]                   sendCondition(cond)
[13:23:10.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.519]                   {
[13:23:10.519]                     inherits <- base::inherits
[13:23:10.519]                     invokeRestart <- base::invokeRestart
[13:23:10.519]                     is.null <- base::is.null
[13:23:10.519]                     muffled <- FALSE
[13:23:10.519]                     if (inherits(cond, "message")) {
[13:23:10.519]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.519]                       if (muffled) 
[13:23:10.519]                         invokeRestart("muffleMessage")
[13:23:10.519]                     }
[13:23:10.519]                     else if (inherits(cond, "warning")) {
[13:23:10.519]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.519]                       if (muffled) 
[13:23:10.519]                         invokeRestart("muffleWarning")
[13:23:10.519]                     }
[13:23:10.519]                     else if (inherits(cond, "condition")) {
[13:23:10.519]                       if (!is.null(pattern)) {
[13:23:10.519]                         computeRestarts <- base::computeRestarts
[13:23:10.519]                         grepl <- base::grepl
[13:23:10.519]                         restarts <- computeRestarts(cond)
[13:23:10.519]                         for (restart in restarts) {
[13:23:10.519]                           name <- restart$name
[13:23:10.519]                           if (is.null(name)) 
[13:23:10.519]                             next
[13:23:10.519]                           if (!grepl(pattern, name)) 
[13:23:10.519]                             next
[13:23:10.519]                           invokeRestart(restart)
[13:23:10.519]                           muffled <- TRUE
[13:23:10.519]                           break
[13:23:10.519]                         }
[13:23:10.519]                       }
[13:23:10.519]                     }
[13:23:10.519]                     invisible(muffled)
[13:23:10.519]                   }
[13:23:10.519]                   muffleCondition(cond)
[13:23:10.519]                 })
[13:23:10.519]             }))
[13:23:10.519]             future::FutureResult(value = ...future.value$value, 
[13:23:10.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.519]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.519]                     ...future.globalenv.names))
[13:23:10.519]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.519]         }, condition = base::local({
[13:23:10.519]             c <- base::c
[13:23:10.519]             inherits <- base::inherits
[13:23:10.519]             invokeRestart <- base::invokeRestart
[13:23:10.519]             length <- base::length
[13:23:10.519]             list <- base::list
[13:23:10.519]             seq.int <- base::seq.int
[13:23:10.519]             signalCondition <- base::signalCondition
[13:23:10.519]             sys.calls <- base::sys.calls
[13:23:10.519]             `[[` <- base::`[[`
[13:23:10.519]             `+` <- base::`+`
[13:23:10.519]             `<<-` <- base::`<<-`
[13:23:10.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.519]                   3L)]
[13:23:10.519]             }
[13:23:10.519]             function(cond) {
[13:23:10.519]                 is_error <- inherits(cond, "error")
[13:23:10.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.519]                   NULL)
[13:23:10.519]                 if (is_error) {
[13:23:10.519]                   sessionInformation <- function() {
[13:23:10.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.519]                       search = base::search(), system = base::Sys.info())
[13:23:10.519]                   }
[13:23:10.519]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.519]                     cond$call), session = sessionInformation(), 
[13:23:10.519]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.519]                   signalCondition(cond)
[13:23:10.519]                 }
[13:23:10.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.519]                 "immediateCondition"))) {
[13:23:10.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.519]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.519]                   if (TRUE && !signal) {
[13:23:10.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.519]                     {
[13:23:10.519]                       inherits <- base::inherits
[13:23:10.519]                       invokeRestart <- base::invokeRestart
[13:23:10.519]                       is.null <- base::is.null
[13:23:10.519]                       muffled <- FALSE
[13:23:10.519]                       if (inherits(cond, "message")) {
[13:23:10.519]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.519]                         if (muffled) 
[13:23:10.519]                           invokeRestart("muffleMessage")
[13:23:10.519]                       }
[13:23:10.519]                       else if (inherits(cond, "warning")) {
[13:23:10.519]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.519]                         if (muffled) 
[13:23:10.519]                           invokeRestart("muffleWarning")
[13:23:10.519]                       }
[13:23:10.519]                       else if (inherits(cond, "condition")) {
[13:23:10.519]                         if (!is.null(pattern)) {
[13:23:10.519]                           computeRestarts <- base::computeRestarts
[13:23:10.519]                           grepl <- base::grepl
[13:23:10.519]                           restarts <- computeRestarts(cond)
[13:23:10.519]                           for (restart in restarts) {
[13:23:10.519]                             name <- restart$name
[13:23:10.519]                             if (is.null(name)) 
[13:23:10.519]                               next
[13:23:10.519]                             if (!grepl(pattern, name)) 
[13:23:10.519]                               next
[13:23:10.519]                             invokeRestart(restart)
[13:23:10.519]                             muffled <- TRUE
[13:23:10.519]                             break
[13:23:10.519]                           }
[13:23:10.519]                         }
[13:23:10.519]                       }
[13:23:10.519]                       invisible(muffled)
[13:23:10.519]                     }
[13:23:10.519]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.519]                   }
[13:23:10.519]                 }
[13:23:10.519]                 else {
[13:23:10.519]                   if (TRUE) {
[13:23:10.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.519]                     {
[13:23:10.519]                       inherits <- base::inherits
[13:23:10.519]                       invokeRestart <- base::invokeRestart
[13:23:10.519]                       is.null <- base::is.null
[13:23:10.519]                       muffled <- FALSE
[13:23:10.519]                       if (inherits(cond, "message")) {
[13:23:10.519]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.519]                         if (muffled) 
[13:23:10.519]                           invokeRestart("muffleMessage")
[13:23:10.519]                       }
[13:23:10.519]                       else if (inherits(cond, "warning")) {
[13:23:10.519]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.519]                         if (muffled) 
[13:23:10.519]                           invokeRestart("muffleWarning")
[13:23:10.519]                       }
[13:23:10.519]                       else if (inherits(cond, "condition")) {
[13:23:10.519]                         if (!is.null(pattern)) {
[13:23:10.519]                           computeRestarts <- base::computeRestarts
[13:23:10.519]                           grepl <- base::grepl
[13:23:10.519]                           restarts <- computeRestarts(cond)
[13:23:10.519]                           for (restart in restarts) {
[13:23:10.519]                             name <- restart$name
[13:23:10.519]                             if (is.null(name)) 
[13:23:10.519]                               next
[13:23:10.519]                             if (!grepl(pattern, name)) 
[13:23:10.519]                               next
[13:23:10.519]                             invokeRestart(restart)
[13:23:10.519]                             muffled <- TRUE
[13:23:10.519]                             break
[13:23:10.519]                           }
[13:23:10.519]                         }
[13:23:10.519]                       }
[13:23:10.519]                       invisible(muffled)
[13:23:10.519]                     }
[13:23:10.519]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.519]                   }
[13:23:10.519]                 }
[13:23:10.519]             }
[13:23:10.519]         }))
[13:23:10.519]     }, error = function(ex) {
[13:23:10.519]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.519]                 ...future.rng), started = ...future.startTime, 
[13:23:10.519]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.519]             version = "1.8"), class = "FutureResult")
[13:23:10.519]     }, finally = {
[13:23:10.519]         if (!identical(...future.workdir, getwd())) 
[13:23:10.519]             setwd(...future.workdir)
[13:23:10.519]         {
[13:23:10.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.519]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.519]             }
[13:23:10.519]             base::options(...future.oldOptions)
[13:23:10.519]             if (.Platform$OS.type == "windows") {
[13:23:10.519]                 old_names <- names(...future.oldEnvVars)
[13:23:10.519]                 envs <- base::Sys.getenv()
[13:23:10.519]                 names <- names(envs)
[13:23:10.519]                 common <- intersect(names, old_names)
[13:23:10.519]                 added <- setdiff(names, old_names)
[13:23:10.519]                 removed <- setdiff(old_names, names)
[13:23:10.519]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.519]                   envs[common]]
[13:23:10.519]                 NAMES <- toupper(changed)
[13:23:10.519]                 args <- list()
[13:23:10.519]                 for (kk in seq_along(NAMES)) {
[13:23:10.519]                   name <- changed[[kk]]
[13:23:10.519]                   NAME <- NAMES[[kk]]
[13:23:10.519]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.519]                     next
[13:23:10.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.519]                 }
[13:23:10.519]                 NAMES <- toupper(added)
[13:23:10.519]                 for (kk in seq_along(NAMES)) {
[13:23:10.519]                   name <- added[[kk]]
[13:23:10.519]                   NAME <- NAMES[[kk]]
[13:23:10.519]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.519]                     next
[13:23:10.519]                   args[[name]] <- ""
[13:23:10.519]                 }
[13:23:10.519]                 NAMES <- toupper(removed)
[13:23:10.519]                 for (kk in seq_along(NAMES)) {
[13:23:10.519]                   name <- removed[[kk]]
[13:23:10.519]                   NAME <- NAMES[[kk]]
[13:23:10.519]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.519]                     next
[13:23:10.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.519]                 }
[13:23:10.519]                 if (length(args) > 0) 
[13:23:10.519]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.519]             }
[13:23:10.519]             else {
[13:23:10.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.519]             }
[13:23:10.519]             {
[13:23:10.519]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.519]                   0L) {
[13:23:10.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.519]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.519]                   base::options(opts)
[13:23:10.519]                 }
[13:23:10.519]                 {
[13:23:10.519]                   {
[13:23:10.519]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.519]                     NULL
[13:23:10.519]                   }
[13:23:10.519]                   options(future.plan = NULL)
[13:23:10.519]                   if (is.na(NA_character_)) 
[13:23:10.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.519]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.519]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.519]                     envir = parent.frame()) 
[13:23:10.519]                   {
[13:23:10.519]                     if (is.function(workers)) 
[13:23:10.519]                       workers <- workers()
[13:23:10.519]                     workers <- structure(as.integer(workers), 
[13:23:10.519]                       class = class(workers))
[13:23:10.519]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.519]                       workers >= 1)
[13:23:10.519]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.519]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.519]                     }
[13:23:10.519]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.519]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.519]                       envir = envir)
[13:23:10.519]                     if (!future$lazy) 
[13:23:10.519]                       future <- run(future)
[13:23:10.519]                     invisible(future)
[13:23:10.519]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.519]                 }
[13:23:10.519]             }
[13:23:10.519]         }
[13:23:10.519]     })
[13:23:10.519]     if (TRUE) {
[13:23:10.519]         base::sink(type = "output", split = FALSE)
[13:23:10.519]         if (TRUE) {
[13:23:10.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.519]         }
[13:23:10.519]         else {
[13:23:10.519]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.519]         }
[13:23:10.519]         base::close(...future.stdout)
[13:23:10.519]         ...future.stdout <- NULL
[13:23:10.519]     }
[13:23:10.519]     ...future.result$conditions <- ...future.conditions
[13:23:10.519]     ...future.result$finished <- base::Sys.time()
[13:23:10.519]     ...future.result
[13:23:10.519] }
[13:23:10.521] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:10.532] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.533] - Validating connection of MultisessionFuture
[13:23:10.533] - received message: FutureResult
[13:23:10.533] - Received FutureResult
[13:23:10.533] - Erased future from FutureRegistry
[13:23:10.533] result() for ClusterFuture ...
[13:23:10.533] - result already collected: FutureResult
[13:23:10.533] result() for ClusterFuture ... done
[13:23:10.534] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:10.534] result() for ClusterFuture ...
[13:23:10.534] - result already collected: FutureResult
[13:23:10.534] result() for ClusterFuture ... done
[13:23:10.534] result() for ClusterFuture ...
[13:23:10.534] - result already collected: FutureResult
[13:23:10.534] result() for ClusterFuture ... done
[13:23:10.536] MultisessionFuture started
[13:23:10.536] - Launch lazy future ... done
[13:23:10.536] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d761c3e8> 
Classes 'listenv', 'environment' <environment: 0x5596d34df968> 
[13:23:10.546] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.546] - Validating connection of MultisessionFuture
[13:23:10.547] - received message: FutureResult
[13:23:10.547] - Received FutureResult
[13:23:10.547] - Erased future from FutureRegistry
[13:23:10.547] result() for ClusterFuture ...
[13:23:10.547] - result already collected: FutureResult
[13:23:10.547] result() for ClusterFuture ... done
[13:23:10.547] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:10.560] resolve() on list environment ...
[13:23:10.560]  recursive: 0
[13:23:10.561]  length: 6
[13:23:10.561]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:10.561] signalConditionsASAP(numeric, pos=1) ...
[13:23:10.561] - nx: 6
[13:23:10.561] - relay: TRUE
[13:23:10.562] - stdout: TRUE
[13:23:10.562] - signal: TRUE
[13:23:10.562] - resignal: FALSE
[13:23:10.562] - force: TRUE
[13:23:10.562] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.562] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.562]  - until=2
[13:23:10.562]  - relaying element #2
[13:23:10.562] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.562] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.562] signalConditionsASAP(NULL, pos=1) ... done
[13:23:10.563]  length: 5 (resolved future 1)
[13:23:10.563] Future #2
[13:23:10.563] result() for ClusterFuture ...
[13:23:10.563] - result already collected: FutureResult
[13:23:10.563] result() for ClusterFuture ... done
[13:23:10.563] result() for ClusterFuture ...
[13:23:10.563] - result already collected: FutureResult
[13:23:10.563] result() for ClusterFuture ... done
[13:23:10.563] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:10.563] - nx: 6
[13:23:10.564] - relay: TRUE
[13:23:10.564] - stdout: TRUE
[13:23:10.564] - signal: TRUE
[13:23:10.564] - resignal: FALSE
[13:23:10.564] - force: TRUE
[13:23:10.564] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.564] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.564]  - until=2
[13:23:10.564]  - relaying element #2
[13:23:10.564] result() for ClusterFuture ...
[13:23:10.565] - result already collected: FutureResult
[13:23:10.565] result() for ClusterFuture ... done
[13:23:10.565] result() for ClusterFuture ...
[13:23:10.565] - result already collected: FutureResult
[13:23:10.565] result() for ClusterFuture ... done
[13:23:10.565] result() for ClusterFuture ...
[13:23:10.565] - result already collected: FutureResult
[13:23:10.565] result() for ClusterFuture ... done
[13:23:10.565] result() for ClusterFuture ...
[13:23:10.565] - result already collected: FutureResult
[13:23:10.565] result() for ClusterFuture ... done
[13:23:10.566] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.566] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.566] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:10.566]  length: 4 (resolved future 2)
[13:23:10.566] Future #3
[13:23:10.566] result() for ClusterFuture ...
[13:23:10.566] - result already collected: FutureResult
[13:23:10.566] result() for ClusterFuture ... done
[13:23:10.566] result() for ClusterFuture ...
[13:23:10.566] - result already collected: FutureResult
[13:23:10.566] result() for ClusterFuture ... done
[13:23:10.567] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:10.567] - nx: 6
[13:23:10.567] - relay: TRUE
[13:23:10.567] - stdout: TRUE
[13:23:10.567] - signal: TRUE
[13:23:10.567] - resignal: FALSE
[13:23:10.567] - force: TRUE
[13:23:10.567] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.567] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.567]  - until=3
[13:23:10.567]  - relaying element #3
[13:23:10.568] result() for ClusterFuture ...
[13:23:10.568] - result already collected: FutureResult
[13:23:10.568] result() for ClusterFuture ... done
[13:23:10.568] result() for ClusterFuture ...
[13:23:10.568] - result already collected: FutureResult
[13:23:10.568] result() for ClusterFuture ... done
[13:23:10.568] result() for ClusterFuture ...
[13:23:10.568] - result already collected: FutureResult
[13:23:10.568] result() for ClusterFuture ... done
[13:23:10.569] result() for ClusterFuture ...
[13:23:10.569] - result already collected: FutureResult
[13:23:10.569] result() for ClusterFuture ... done
[13:23:10.569] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.569] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.569] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:10.569]  length: 3 (resolved future 3)
[13:23:10.580] signalConditionsASAP(NULL, pos=5) ...
[13:23:10.580] - nx: 6
[13:23:10.580] - relay: TRUE
[13:23:10.580] - stdout: TRUE
[13:23:10.581] - signal: TRUE
[13:23:10.581] - resignal: FALSE
[13:23:10.581] - force: TRUE
[13:23:10.581] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.581] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.581]  - until=6
[13:23:10.582]  - relaying element #4
[13:23:10.582]  - relaying element #6
[13:23:10.582] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:10.582] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.582] signalConditionsASAP(NULL, pos=5) ... done
[13:23:10.582]  length: 2 (resolved future 5)
[13:23:10.582] signalConditionsASAP(numeric, pos=6) ...
[13:23:10.582] - nx: 6
[13:23:10.583] - relay: TRUE
[13:23:10.583] - stdout: TRUE
[13:23:10.583] - signal: TRUE
[13:23:10.583] - resignal: FALSE
[13:23:10.583] - force: TRUE
[13:23:10.583] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:10.583] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.583]  - until=6
[13:23:10.583]  - relaying element #4
[13:23:10.583] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:10.583] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.584] signalConditionsASAP(NULL, pos=6) ... done
[13:23:10.584]  length: 1 (resolved future 6)
[13:23:10.595] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.595] - Validating connection of MultisessionFuture
[13:23:10.595] - received message: FutureResult
[13:23:10.595] - Received FutureResult
[13:23:10.595] - Erased future from FutureRegistry
[13:23:10.595] result() for ClusterFuture ...
[13:23:10.596] - result already collected: FutureResult
[13:23:10.596] result() for ClusterFuture ... done
[13:23:10.596] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:10.596] Future #4
[13:23:10.596] result() for ClusterFuture ...
[13:23:10.596] - result already collected: FutureResult
[13:23:10.596] result() for ClusterFuture ... done
[13:23:10.596] result() for ClusterFuture ...
[13:23:10.596] - result already collected: FutureResult
[13:23:10.596] result() for ClusterFuture ... done
[13:23:10.597] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:10.597] - nx: 6
[13:23:10.597] - relay: TRUE
[13:23:10.597] - stdout: TRUE
[13:23:10.597] - signal: TRUE
[13:23:10.597] - resignal: FALSE
[13:23:10.597] - force: TRUE
[13:23:10.597] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:10.597] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.597]  - until=6
[13:23:10.597]  - relaying element #4
[13:23:10.598] result() for ClusterFuture ...
[13:23:10.598] - result already collected: FutureResult
[13:23:10.598] result() for ClusterFuture ... done
[13:23:10.598] result() for ClusterFuture ...
[13:23:10.598] - result already collected: FutureResult
[13:23:10.598] result() for ClusterFuture ... done
[13:23:10.598] result() for ClusterFuture ...
[13:23:10.598] - result already collected: FutureResult
[13:23:10.598] result() for ClusterFuture ... done
[13:23:10.598] result() for ClusterFuture ...
[13:23:10.598] - result already collected: FutureResult
[13:23:10.599] result() for ClusterFuture ... done
[13:23:10.599] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:10.599] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:10.599] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:10.599]  length: 0 (resolved future 4)
[13:23:10.599] Relaying remaining futures
[13:23:10.599] signalConditionsASAP(NULL, pos=0) ...
[13:23:10.599] - nx: 6
[13:23:10.599] - relay: TRUE
[13:23:10.599] - stdout: TRUE
[13:23:10.599] - signal: TRUE
[13:23:10.600] - resignal: FALSE
[13:23:10.600] - force: TRUE
[13:23:10.600] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:10.600] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:10.600] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:10.600] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:10.600] signalConditionsASAP(NULL, pos=0) ... done
[13:23:10.600] resolve() on list environment ... DONE
[13:23:10.600] result() for ClusterFuture ...
[13:23:10.600] - result already collected: FutureResult
[13:23:10.601] result() for ClusterFuture ... done
[13:23:10.601] result() for ClusterFuture ...
[13:23:10.601] - result already collected: FutureResult
[13:23:10.601] result() for ClusterFuture ... done
[13:23:10.601] result() for ClusterFuture ...
[13:23:10.601] - result already collected: FutureResult
[13:23:10.601] result() for ClusterFuture ... done
[13:23:10.601] result() for ClusterFuture ...
[13:23:10.601] - result already collected: FutureResult
[13:23:10.601] result() for ClusterFuture ... done
[13:23:10.602] result() for ClusterFuture ...
[13:23:10.602] - result already collected: FutureResult
[13:23:10.602] result() for ClusterFuture ... done
[13:23:10.602] result() for ClusterFuture ...
[13:23:10.602] - result already collected: FutureResult
[13:23:10.602] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d6482a78> 
Dimensions: c(1, 6)
[13:23:10.603] getGlobalsAndPackages() ...
[13:23:10.603] Searching for globals...
[13:23:10.603] 
[13:23:10.603] Searching for globals ... DONE
[13:23:10.603] - globals: [0] <none>
[13:23:10.603] getGlobalsAndPackages() ... DONE
[13:23:10.604] run() for ‘Future’ ...
[13:23:10.604] - state: ‘created’
[13:23:10.604] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.618] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.619]   - Field: ‘node’
[13:23:10.619]   - Field: ‘label’
[13:23:10.619]   - Field: ‘local’
[13:23:10.619]   - Field: ‘owner’
[13:23:10.619]   - Field: ‘envir’
[13:23:10.619]   - Field: ‘workers’
[13:23:10.619]   - Field: ‘packages’
[13:23:10.619]   - Field: ‘gc’
[13:23:10.620]   - Field: ‘conditions’
[13:23:10.620]   - Field: ‘persistent’
[13:23:10.620]   - Field: ‘expr’
[13:23:10.620]   - Field: ‘uuid’
[13:23:10.620]   - Field: ‘seed’
[13:23:10.620]   - Field: ‘version’
[13:23:10.620]   - Field: ‘result’
[13:23:10.620]   - Field: ‘asynchronous’
[13:23:10.620]   - Field: ‘calls’
[13:23:10.621]   - Field: ‘globals’
[13:23:10.621]   - Field: ‘stdout’
[13:23:10.621]   - Field: ‘earlySignal’
[13:23:10.621]   - Field: ‘lazy’
[13:23:10.621]   - Field: ‘state’
[13:23:10.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.621] - Launch lazy future ...
[13:23:10.621] Packages needed by the future expression (n = 0): <none>
[13:23:10.622] Packages needed by future strategies (n = 0): <none>
[13:23:10.622] {
[13:23:10.622]     {
[13:23:10.622]         {
[13:23:10.622]             ...future.startTime <- base::Sys.time()
[13:23:10.622]             {
[13:23:10.622]                 {
[13:23:10.622]                   {
[13:23:10.622]                     {
[13:23:10.622]                       base::local({
[13:23:10.622]                         has_future <- base::requireNamespace("future", 
[13:23:10.622]                           quietly = TRUE)
[13:23:10.622]                         if (has_future) {
[13:23:10.622]                           ns <- base::getNamespace("future")
[13:23:10.622]                           version <- ns[[".package"]][["version"]]
[13:23:10.622]                           if (is.null(version)) 
[13:23:10.622]                             version <- utils::packageVersion("future")
[13:23:10.622]                         }
[13:23:10.622]                         else {
[13:23:10.622]                           version <- NULL
[13:23:10.622]                         }
[13:23:10.622]                         if (!has_future || version < "1.8.0") {
[13:23:10.622]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.622]                             "", base::R.version$version.string), 
[13:23:10.622]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.622]                               "release", "version")], collapse = " "), 
[13:23:10.622]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.622]                             info)
[13:23:10.622]                           info <- base::paste(info, collapse = "; ")
[13:23:10.622]                           if (!has_future) {
[13:23:10.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.622]                               info)
[13:23:10.622]                           }
[13:23:10.622]                           else {
[13:23:10.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.622]                               info, version)
[13:23:10.622]                           }
[13:23:10.622]                           base::stop(msg)
[13:23:10.622]                         }
[13:23:10.622]                       })
[13:23:10.622]                     }
[13:23:10.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.622]                     base::options(mc.cores = 1L)
[13:23:10.622]                   }
[13:23:10.622]                   options(future.plan = NULL)
[13:23:10.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.622]                 }
[13:23:10.622]                 ...future.workdir <- getwd()
[13:23:10.622]             }
[13:23:10.622]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.622]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.622]         }
[13:23:10.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.622]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.622]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.622]             base::names(...future.oldOptions))
[13:23:10.622]     }
[13:23:10.622]     if (FALSE) {
[13:23:10.622]     }
[13:23:10.622]     else {
[13:23:10.622]         if (TRUE) {
[13:23:10.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.622]                 open = "w")
[13:23:10.622]         }
[13:23:10.622]         else {
[13:23:10.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.622]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.622]         }
[13:23:10.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.622]             base::sink(type = "output", split = FALSE)
[13:23:10.622]             base::close(...future.stdout)
[13:23:10.622]         }, add = TRUE)
[13:23:10.622]     }
[13:23:10.622]     ...future.frame <- base::sys.nframe()
[13:23:10.622]     ...future.conditions <- base::list()
[13:23:10.622]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.622]     if (FALSE) {
[13:23:10.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.622]     }
[13:23:10.622]     ...future.result <- base::tryCatch({
[13:23:10.622]         base::withCallingHandlers({
[13:23:10.622]             ...future.value <- base::withVisible(base::local({
[13:23:10.622]                 ...future.makeSendCondition <- base::local({
[13:23:10.622]                   sendCondition <- NULL
[13:23:10.622]                   function(frame = 1L) {
[13:23:10.622]                     if (is.function(sendCondition)) 
[13:23:10.622]                       return(sendCondition)
[13:23:10.622]                     ns <- getNamespace("parallel")
[13:23:10.622]                     if (exists("sendData", mode = "function", 
[13:23:10.622]                       envir = ns)) {
[13:23:10.622]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.622]                         envir = ns)
[13:23:10.622]                       envir <- sys.frame(frame)
[13:23:10.622]                       master <- NULL
[13:23:10.622]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.622]                         !identical(envir, emptyenv())) {
[13:23:10.622]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.622]                           inherits = FALSE)) {
[13:23:10.622]                           master <- get("master", mode = "list", 
[13:23:10.622]                             envir = envir, inherits = FALSE)
[13:23:10.622]                           if (inherits(master, c("SOCKnode", 
[13:23:10.622]                             "SOCK0node"))) {
[13:23:10.622]                             sendCondition <<- function(cond) {
[13:23:10.622]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.622]                                 success = TRUE)
[13:23:10.622]                               parallel_sendData(master, data)
[13:23:10.622]                             }
[13:23:10.622]                             return(sendCondition)
[13:23:10.622]                           }
[13:23:10.622]                         }
[13:23:10.622]                         frame <- frame + 1L
[13:23:10.622]                         envir <- sys.frame(frame)
[13:23:10.622]                       }
[13:23:10.622]                     }
[13:23:10.622]                     sendCondition <<- function(cond) NULL
[13:23:10.622]                   }
[13:23:10.622]                 })
[13:23:10.622]                 withCallingHandlers({
[13:23:10.622]                   2
[13:23:10.622]                 }, immediateCondition = function(cond) {
[13:23:10.622]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.622]                   sendCondition(cond)
[13:23:10.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.622]                   {
[13:23:10.622]                     inherits <- base::inherits
[13:23:10.622]                     invokeRestart <- base::invokeRestart
[13:23:10.622]                     is.null <- base::is.null
[13:23:10.622]                     muffled <- FALSE
[13:23:10.622]                     if (inherits(cond, "message")) {
[13:23:10.622]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.622]                       if (muffled) 
[13:23:10.622]                         invokeRestart("muffleMessage")
[13:23:10.622]                     }
[13:23:10.622]                     else if (inherits(cond, "warning")) {
[13:23:10.622]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.622]                       if (muffled) 
[13:23:10.622]                         invokeRestart("muffleWarning")
[13:23:10.622]                     }
[13:23:10.622]                     else if (inherits(cond, "condition")) {
[13:23:10.622]                       if (!is.null(pattern)) {
[13:23:10.622]                         computeRestarts <- base::computeRestarts
[13:23:10.622]                         grepl <- base::grepl
[13:23:10.622]                         restarts <- computeRestarts(cond)
[13:23:10.622]                         for (restart in restarts) {
[13:23:10.622]                           name <- restart$name
[13:23:10.622]                           if (is.null(name)) 
[13:23:10.622]                             next
[13:23:10.622]                           if (!grepl(pattern, name)) 
[13:23:10.622]                             next
[13:23:10.622]                           invokeRestart(restart)
[13:23:10.622]                           muffled <- TRUE
[13:23:10.622]                           break
[13:23:10.622]                         }
[13:23:10.622]                       }
[13:23:10.622]                     }
[13:23:10.622]                     invisible(muffled)
[13:23:10.622]                   }
[13:23:10.622]                   muffleCondition(cond)
[13:23:10.622]                 })
[13:23:10.622]             }))
[13:23:10.622]             future::FutureResult(value = ...future.value$value, 
[13:23:10.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.622]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.622]                     ...future.globalenv.names))
[13:23:10.622]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.622]         }, condition = base::local({
[13:23:10.622]             c <- base::c
[13:23:10.622]             inherits <- base::inherits
[13:23:10.622]             invokeRestart <- base::invokeRestart
[13:23:10.622]             length <- base::length
[13:23:10.622]             list <- base::list
[13:23:10.622]             seq.int <- base::seq.int
[13:23:10.622]             signalCondition <- base::signalCondition
[13:23:10.622]             sys.calls <- base::sys.calls
[13:23:10.622]             `[[` <- base::`[[`
[13:23:10.622]             `+` <- base::`+`
[13:23:10.622]             `<<-` <- base::`<<-`
[13:23:10.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.622]                   3L)]
[13:23:10.622]             }
[13:23:10.622]             function(cond) {
[13:23:10.622]                 is_error <- inherits(cond, "error")
[13:23:10.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.622]                   NULL)
[13:23:10.622]                 if (is_error) {
[13:23:10.622]                   sessionInformation <- function() {
[13:23:10.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.622]                       search = base::search(), system = base::Sys.info())
[13:23:10.622]                   }
[13:23:10.622]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.622]                     cond$call), session = sessionInformation(), 
[13:23:10.622]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.622]                   signalCondition(cond)
[13:23:10.622]                 }
[13:23:10.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.622]                 "immediateCondition"))) {
[13:23:10.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.622]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.622]                   if (TRUE && !signal) {
[13:23:10.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.622]                     {
[13:23:10.622]                       inherits <- base::inherits
[13:23:10.622]                       invokeRestart <- base::invokeRestart
[13:23:10.622]                       is.null <- base::is.null
[13:23:10.622]                       muffled <- FALSE
[13:23:10.622]                       if (inherits(cond, "message")) {
[13:23:10.622]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.622]                         if (muffled) 
[13:23:10.622]                           invokeRestart("muffleMessage")
[13:23:10.622]                       }
[13:23:10.622]                       else if (inherits(cond, "warning")) {
[13:23:10.622]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.622]                         if (muffled) 
[13:23:10.622]                           invokeRestart("muffleWarning")
[13:23:10.622]                       }
[13:23:10.622]                       else if (inherits(cond, "condition")) {
[13:23:10.622]                         if (!is.null(pattern)) {
[13:23:10.622]                           computeRestarts <- base::computeRestarts
[13:23:10.622]                           grepl <- base::grepl
[13:23:10.622]                           restarts <- computeRestarts(cond)
[13:23:10.622]                           for (restart in restarts) {
[13:23:10.622]                             name <- restart$name
[13:23:10.622]                             if (is.null(name)) 
[13:23:10.622]                               next
[13:23:10.622]                             if (!grepl(pattern, name)) 
[13:23:10.622]                               next
[13:23:10.622]                             invokeRestart(restart)
[13:23:10.622]                             muffled <- TRUE
[13:23:10.622]                             break
[13:23:10.622]                           }
[13:23:10.622]                         }
[13:23:10.622]                       }
[13:23:10.622]                       invisible(muffled)
[13:23:10.622]                     }
[13:23:10.622]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.622]                   }
[13:23:10.622]                 }
[13:23:10.622]                 else {
[13:23:10.622]                   if (TRUE) {
[13:23:10.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.622]                     {
[13:23:10.622]                       inherits <- base::inherits
[13:23:10.622]                       invokeRestart <- base::invokeRestart
[13:23:10.622]                       is.null <- base::is.null
[13:23:10.622]                       muffled <- FALSE
[13:23:10.622]                       if (inherits(cond, "message")) {
[13:23:10.622]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.622]                         if (muffled) 
[13:23:10.622]                           invokeRestart("muffleMessage")
[13:23:10.622]                       }
[13:23:10.622]                       else if (inherits(cond, "warning")) {
[13:23:10.622]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.622]                         if (muffled) 
[13:23:10.622]                           invokeRestart("muffleWarning")
[13:23:10.622]                       }
[13:23:10.622]                       else if (inherits(cond, "condition")) {
[13:23:10.622]                         if (!is.null(pattern)) {
[13:23:10.622]                           computeRestarts <- base::computeRestarts
[13:23:10.622]                           grepl <- base::grepl
[13:23:10.622]                           restarts <- computeRestarts(cond)
[13:23:10.622]                           for (restart in restarts) {
[13:23:10.622]                             name <- restart$name
[13:23:10.622]                             if (is.null(name)) 
[13:23:10.622]                               next
[13:23:10.622]                             if (!grepl(pattern, name)) 
[13:23:10.622]                               next
[13:23:10.622]                             invokeRestart(restart)
[13:23:10.622]                             muffled <- TRUE
[13:23:10.622]                             break
[13:23:10.622]                           }
[13:23:10.622]                         }
[13:23:10.622]                       }
[13:23:10.622]                       invisible(muffled)
[13:23:10.622]                     }
[13:23:10.622]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.622]                   }
[13:23:10.622]                 }
[13:23:10.622]             }
[13:23:10.622]         }))
[13:23:10.622]     }, error = function(ex) {
[13:23:10.622]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.622]                 ...future.rng), started = ...future.startTime, 
[13:23:10.622]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.622]             version = "1.8"), class = "FutureResult")
[13:23:10.622]     }, finally = {
[13:23:10.622]         if (!identical(...future.workdir, getwd())) 
[13:23:10.622]             setwd(...future.workdir)
[13:23:10.622]         {
[13:23:10.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.622]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.622]             }
[13:23:10.622]             base::options(...future.oldOptions)
[13:23:10.622]             if (.Platform$OS.type == "windows") {
[13:23:10.622]                 old_names <- names(...future.oldEnvVars)
[13:23:10.622]                 envs <- base::Sys.getenv()
[13:23:10.622]                 names <- names(envs)
[13:23:10.622]                 common <- intersect(names, old_names)
[13:23:10.622]                 added <- setdiff(names, old_names)
[13:23:10.622]                 removed <- setdiff(old_names, names)
[13:23:10.622]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.622]                   envs[common]]
[13:23:10.622]                 NAMES <- toupper(changed)
[13:23:10.622]                 args <- list()
[13:23:10.622]                 for (kk in seq_along(NAMES)) {
[13:23:10.622]                   name <- changed[[kk]]
[13:23:10.622]                   NAME <- NAMES[[kk]]
[13:23:10.622]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.622]                     next
[13:23:10.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.622]                 }
[13:23:10.622]                 NAMES <- toupper(added)
[13:23:10.622]                 for (kk in seq_along(NAMES)) {
[13:23:10.622]                   name <- added[[kk]]
[13:23:10.622]                   NAME <- NAMES[[kk]]
[13:23:10.622]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.622]                     next
[13:23:10.622]                   args[[name]] <- ""
[13:23:10.622]                 }
[13:23:10.622]                 NAMES <- toupper(removed)
[13:23:10.622]                 for (kk in seq_along(NAMES)) {
[13:23:10.622]                   name <- removed[[kk]]
[13:23:10.622]                   NAME <- NAMES[[kk]]
[13:23:10.622]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.622]                     next
[13:23:10.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.622]                 }
[13:23:10.622]                 if (length(args) > 0) 
[13:23:10.622]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.622]             }
[13:23:10.622]             else {
[13:23:10.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.622]             }
[13:23:10.622]             {
[13:23:10.622]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.622]                   0L) {
[13:23:10.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.622]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.622]                   base::options(opts)
[13:23:10.622]                 }
[13:23:10.622]                 {
[13:23:10.622]                   {
[13:23:10.622]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.622]                     NULL
[13:23:10.622]                   }
[13:23:10.622]                   options(future.plan = NULL)
[13:23:10.622]                   if (is.na(NA_character_)) 
[13:23:10.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.622]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.622]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.622]                     envir = parent.frame()) 
[13:23:10.622]                   {
[13:23:10.622]                     if (is.function(workers)) 
[13:23:10.622]                       workers <- workers()
[13:23:10.622]                     workers <- structure(as.integer(workers), 
[13:23:10.622]                       class = class(workers))
[13:23:10.622]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.622]                       workers >= 1)
[13:23:10.622]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.622]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.622]                     }
[13:23:10.622]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.622]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.622]                       envir = envir)
[13:23:10.622]                     if (!future$lazy) 
[13:23:10.622]                       future <- run(future)
[13:23:10.622]                     invisible(future)
[13:23:10.622]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.622]                 }
[13:23:10.622]             }
[13:23:10.622]         }
[13:23:10.622]     })
[13:23:10.622]     if (TRUE) {
[13:23:10.622]         base::sink(type = "output", split = FALSE)
[13:23:10.622]         if (TRUE) {
[13:23:10.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.622]         }
[13:23:10.622]         else {
[13:23:10.622]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.622]         }
[13:23:10.622]         base::close(...future.stdout)
[13:23:10.622]         ...future.stdout <- NULL
[13:23:10.622]     }
[13:23:10.622]     ...future.result$conditions <- ...future.conditions
[13:23:10.622]     ...future.result$finished <- base::Sys.time()
[13:23:10.622]     ...future.result
[13:23:10.622] }
[13:23:10.626] MultisessionFuture started
[13:23:10.626] - Launch lazy future ... done
[13:23:10.626] run() for ‘MultisessionFuture’ ... done
[13:23:10.626] getGlobalsAndPackages() ...
[13:23:10.626] Searching for globals...
[13:23:10.626] 
[13:23:10.627] Searching for globals ... DONE
[13:23:10.627] - globals: [0] <none>
[13:23:10.627] getGlobalsAndPackages() ... DONE
[13:23:10.627] run() for ‘Future’ ...
[13:23:10.627] - state: ‘created’
[13:23:10.627] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.642] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.642]   - Field: ‘node’
[13:23:10.643]   - Field: ‘label’
[13:23:10.643]   - Field: ‘local’
[13:23:10.643]   - Field: ‘owner’
[13:23:10.643]   - Field: ‘envir’
[13:23:10.643]   - Field: ‘workers’
[13:23:10.643]   - Field: ‘packages’
[13:23:10.643]   - Field: ‘gc’
[13:23:10.643]   - Field: ‘conditions’
[13:23:10.647]   - Field: ‘persistent’
[13:23:10.647]   - Field: ‘expr’
[13:23:10.647]   - Field: ‘uuid’
[13:23:10.647]   - Field: ‘seed’
[13:23:10.647]   - Field: ‘version’
[13:23:10.647]   - Field: ‘result’
[13:23:10.648]   - Field: ‘asynchronous’
[13:23:10.648]   - Field: ‘calls’
[13:23:10.648]   - Field: ‘globals’
[13:23:10.648]   - Field: ‘stdout’
[13:23:10.648]   - Field: ‘earlySignal’
[13:23:10.648]   - Field: ‘lazy’
[13:23:10.648]   - Field: ‘state’
[13:23:10.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.648] - Launch lazy future ...
[13:23:10.649] Packages needed by the future expression (n = 0): <none>
[13:23:10.649] Packages needed by future strategies (n = 0): <none>
[13:23:10.649] {
[13:23:10.649]     {
[13:23:10.649]         {
[13:23:10.649]             ...future.startTime <- base::Sys.time()
[13:23:10.649]             {
[13:23:10.649]                 {
[13:23:10.649]                   {
[13:23:10.649]                     {
[13:23:10.649]                       base::local({
[13:23:10.649]                         has_future <- base::requireNamespace("future", 
[13:23:10.649]                           quietly = TRUE)
[13:23:10.649]                         if (has_future) {
[13:23:10.649]                           ns <- base::getNamespace("future")
[13:23:10.649]                           version <- ns[[".package"]][["version"]]
[13:23:10.649]                           if (is.null(version)) 
[13:23:10.649]                             version <- utils::packageVersion("future")
[13:23:10.649]                         }
[13:23:10.649]                         else {
[13:23:10.649]                           version <- NULL
[13:23:10.649]                         }
[13:23:10.649]                         if (!has_future || version < "1.8.0") {
[13:23:10.649]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.649]                             "", base::R.version$version.string), 
[13:23:10.649]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.649]                               "release", "version")], collapse = " "), 
[13:23:10.649]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.649]                             info)
[13:23:10.649]                           info <- base::paste(info, collapse = "; ")
[13:23:10.649]                           if (!has_future) {
[13:23:10.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.649]                               info)
[13:23:10.649]                           }
[13:23:10.649]                           else {
[13:23:10.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.649]                               info, version)
[13:23:10.649]                           }
[13:23:10.649]                           base::stop(msg)
[13:23:10.649]                         }
[13:23:10.649]                       })
[13:23:10.649]                     }
[13:23:10.649]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.649]                     base::options(mc.cores = 1L)
[13:23:10.649]                   }
[13:23:10.649]                   options(future.plan = NULL)
[13:23:10.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.649]                 }
[13:23:10.649]                 ...future.workdir <- getwd()
[13:23:10.649]             }
[13:23:10.649]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.649]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.649]         }
[13:23:10.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.649]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.649]             base::names(...future.oldOptions))
[13:23:10.649]     }
[13:23:10.649]     if (FALSE) {
[13:23:10.649]     }
[13:23:10.649]     else {
[13:23:10.649]         if (TRUE) {
[13:23:10.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.649]                 open = "w")
[13:23:10.649]         }
[13:23:10.649]         else {
[13:23:10.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.649]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.649]         }
[13:23:10.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.649]             base::sink(type = "output", split = FALSE)
[13:23:10.649]             base::close(...future.stdout)
[13:23:10.649]         }, add = TRUE)
[13:23:10.649]     }
[13:23:10.649]     ...future.frame <- base::sys.nframe()
[13:23:10.649]     ...future.conditions <- base::list()
[13:23:10.649]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.649]     if (FALSE) {
[13:23:10.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.649]     }
[13:23:10.649]     ...future.result <- base::tryCatch({
[13:23:10.649]         base::withCallingHandlers({
[13:23:10.649]             ...future.value <- base::withVisible(base::local({
[13:23:10.649]                 ...future.makeSendCondition <- base::local({
[13:23:10.649]                   sendCondition <- NULL
[13:23:10.649]                   function(frame = 1L) {
[13:23:10.649]                     if (is.function(sendCondition)) 
[13:23:10.649]                       return(sendCondition)
[13:23:10.649]                     ns <- getNamespace("parallel")
[13:23:10.649]                     if (exists("sendData", mode = "function", 
[13:23:10.649]                       envir = ns)) {
[13:23:10.649]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.649]                         envir = ns)
[13:23:10.649]                       envir <- sys.frame(frame)
[13:23:10.649]                       master <- NULL
[13:23:10.649]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.649]                         !identical(envir, emptyenv())) {
[13:23:10.649]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.649]                           inherits = FALSE)) {
[13:23:10.649]                           master <- get("master", mode = "list", 
[13:23:10.649]                             envir = envir, inherits = FALSE)
[13:23:10.649]                           if (inherits(master, c("SOCKnode", 
[13:23:10.649]                             "SOCK0node"))) {
[13:23:10.649]                             sendCondition <<- function(cond) {
[13:23:10.649]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.649]                                 success = TRUE)
[13:23:10.649]                               parallel_sendData(master, data)
[13:23:10.649]                             }
[13:23:10.649]                             return(sendCondition)
[13:23:10.649]                           }
[13:23:10.649]                         }
[13:23:10.649]                         frame <- frame + 1L
[13:23:10.649]                         envir <- sys.frame(frame)
[13:23:10.649]                       }
[13:23:10.649]                     }
[13:23:10.649]                     sendCondition <<- function(cond) NULL
[13:23:10.649]                   }
[13:23:10.649]                 })
[13:23:10.649]                 withCallingHandlers({
[13:23:10.649]                   NULL
[13:23:10.649]                 }, immediateCondition = function(cond) {
[13:23:10.649]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.649]                   sendCondition(cond)
[13:23:10.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.649]                   {
[13:23:10.649]                     inherits <- base::inherits
[13:23:10.649]                     invokeRestart <- base::invokeRestart
[13:23:10.649]                     is.null <- base::is.null
[13:23:10.649]                     muffled <- FALSE
[13:23:10.649]                     if (inherits(cond, "message")) {
[13:23:10.649]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.649]                       if (muffled) 
[13:23:10.649]                         invokeRestart("muffleMessage")
[13:23:10.649]                     }
[13:23:10.649]                     else if (inherits(cond, "warning")) {
[13:23:10.649]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.649]                       if (muffled) 
[13:23:10.649]                         invokeRestart("muffleWarning")
[13:23:10.649]                     }
[13:23:10.649]                     else if (inherits(cond, "condition")) {
[13:23:10.649]                       if (!is.null(pattern)) {
[13:23:10.649]                         computeRestarts <- base::computeRestarts
[13:23:10.649]                         grepl <- base::grepl
[13:23:10.649]                         restarts <- computeRestarts(cond)
[13:23:10.649]                         for (restart in restarts) {
[13:23:10.649]                           name <- restart$name
[13:23:10.649]                           if (is.null(name)) 
[13:23:10.649]                             next
[13:23:10.649]                           if (!grepl(pattern, name)) 
[13:23:10.649]                             next
[13:23:10.649]                           invokeRestart(restart)
[13:23:10.649]                           muffled <- TRUE
[13:23:10.649]                           break
[13:23:10.649]                         }
[13:23:10.649]                       }
[13:23:10.649]                     }
[13:23:10.649]                     invisible(muffled)
[13:23:10.649]                   }
[13:23:10.649]                   muffleCondition(cond)
[13:23:10.649]                 })
[13:23:10.649]             }))
[13:23:10.649]             future::FutureResult(value = ...future.value$value, 
[13:23:10.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.649]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.649]                     ...future.globalenv.names))
[13:23:10.649]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.649]         }, condition = base::local({
[13:23:10.649]             c <- base::c
[13:23:10.649]             inherits <- base::inherits
[13:23:10.649]             invokeRestart <- base::invokeRestart
[13:23:10.649]             length <- base::length
[13:23:10.649]             list <- base::list
[13:23:10.649]             seq.int <- base::seq.int
[13:23:10.649]             signalCondition <- base::signalCondition
[13:23:10.649]             sys.calls <- base::sys.calls
[13:23:10.649]             `[[` <- base::`[[`
[13:23:10.649]             `+` <- base::`+`
[13:23:10.649]             `<<-` <- base::`<<-`
[13:23:10.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.649]                   3L)]
[13:23:10.649]             }
[13:23:10.649]             function(cond) {
[13:23:10.649]                 is_error <- inherits(cond, "error")
[13:23:10.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.649]                   NULL)
[13:23:10.649]                 if (is_error) {
[13:23:10.649]                   sessionInformation <- function() {
[13:23:10.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.649]                       search = base::search(), system = base::Sys.info())
[13:23:10.649]                   }
[13:23:10.649]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.649]                     cond$call), session = sessionInformation(), 
[13:23:10.649]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.649]                   signalCondition(cond)
[13:23:10.649]                 }
[13:23:10.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.649]                 "immediateCondition"))) {
[13:23:10.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.649]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.649]                   if (TRUE && !signal) {
[13:23:10.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.649]                     {
[13:23:10.649]                       inherits <- base::inherits
[13:23:10.649]                       invokeRestart <- base::invokeRestart
[13:23:10.649]                       is.null <- base::is.null
[13:23:10.649]                       muffled <- FALSE
[13:23:10.649]                       if (inherits(cond, "message")) {
[13:23:10.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.649]                         if (muffled) 
[13:23:10.649]                           invokeRestart("muffleMessage")
[13:23:10.649]                       }
[13:23:10.649]                       else if (inherits(cond, "warning")) {
[13:23:10.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.649]                         if (muffled) 
[13:23:10.649]                           invokeRestart("muffleWarning")
[13:23:10.649]                       }
[13:23:10.649]                       else if (inherits(cond, "condition")) {
[13:23:10.649]                         if (!is.null(pattern)) {
[13:23:10.649]                           computeRestarts <- base::computeRestarts
[13:23:10.649]                           grepl <- base::grepl
[13:23:10.649]                           restarts <- computeRestarts(cond)
[13:23:10.649]                           for (restart in restarts) {
[13:23:10.649]                             name <- restart$name
[13:23:10.649]                             if (is.null(name)) 
[13:23:10.649]                               next
[13:23:10.649]                             if (!grepl(pattern, name)) 
[13:23:10.649]                               next
[13:23:10.649]                             invokeRestart(restart)
[13:23:10.649]                             muffled <- TRUE
[13:23:10.649]                             break
[13:23:10.649]                           }
[13:23:10.649]                         }
[13:23:10.649]                       }
[13:23:10.649]                       invisible(muffled)
[13:23:10.649]                     }
[13:23:10.649]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.649]                   }
[13:23:10.649]                 }
[13:23:10.649]                 else {
[13:23:10.649]                   if (TRUE) {
[13:23:10.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.649]                     {
[13:23:10.649]                       inherits <- base::inherits
[13:23:10.649]                       invokeRestart <- base::invokeRestart
[13:23:10.649]                       is.null <- base::is.null
[13:23:10.649]                       muffled <- FALSE
[13:23:10.649]                       if (inherits(cond, "message")) {
[13:23:10.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.649]                         if (muffled) 
[13:23:10.649]                           invokeRestart("muffleMessage")
[13:23:10.649]                       }
[13:23:10.649]                       else if (inherits(cond, "warning")) {
[13:23:10.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.649]                         if (muffled) 
[13:23:10.649]                           invokeRestart("muffleWarning")
[13:23:10.649]                       }
[13:23:10.649]                       else if (inherits(cond, "condition")) {
[13:23:10.649]                         if (!is.null(pattern)) {
[13:23:10.649]                           computeRestarts <- base::computeRestarts
[13:23:10.649]                           grepl <- base::grepl
[13:23:10.649]                           restarts <- computeRestarts(cond)
[13:23:10.649]                           for (restart in restarts) {
[13:23:10.649]                             name <- restart$name
[13:23:10.649]                             if (is.null(name)) 
[13:23:10.649]                               next
[13:23:10.649]                             if (!grepl(pattern, name)) 
[13:23:10.649]                               next
[13:23:10.649]                             invokeRestart(restart)
[13:23:10.649]                             muffled <- TRUE
[13:23:10.649]                             break
[13:23:10.649]                           }
[13:23:10.649]                         }
[13:23:10.649]                       }
[13:23:10.649]                       invisible(muffled)
[13:23:10.649]                     }
[13:23:10.649]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.649]                   }
[13:23:10.649]                 }
[13:23:10.649]             }
[13:23:10.649]         }))
[13:23:10.649]     }, error = function(ex) {
[13:23:10.649]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.649]                 ...future.rng), started = ...future.startTime, 
[13:23:10.649]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.649]             version = "1.8"), class = "FutureResult")
[13:23:10.649]     }, finally = {
[13:23:10.649]         if (!identical(...future.workdir, getwd())) 
[13:23:10.649]             setwd(...future.workdir)
[13:23:10.649]         {
[13:23:10.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.649]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.649]             }
[13:23:10.649]             base::options(...future.oldOptions)
[13:23:10.649]             if (.Platform$OS.type == "windows") {
[13:23:10.649]                 old_names <- names(...future.oldEnvVars)
[13:23:10.649]                 envs <- base::Sys.getenv()
[13:23:10.649]                 names <- names(envs)
[13:23:10.649]                 common <- intersect(names, old_names)
[13:23:10.649]                 added <- setdiff(names, old_names)
[13:23:10.649]                 removed <- setdiff(old_names, names)
[13:23:10.649]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.649]                   envs[common]]
[13:23:10.649]                 NAMES <- toupper(changed)
[13:23:10.649]                 args <- list()
[13:23:10.649]                 for (kk in seq_along(NAMES)) {
[13:23:10.649]                   name <- changed[[kk]]
[13:23:10.649]                   NAME <- NAMES[[kk]]
[13:23:10.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.649]                     next
[13:23:10.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.649]                 }
[13:23:10.649]                 NAMES <- toupper(added)
[13:23:10.649]                 for (kk in seq_along(NAMES)) {
[13:23:10.649]                   name <- added[[kk]]
[13:23:10.649]                   NAME <- NAMES[[kk]]
[13:23:10.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.649]                     next
[13:23:10.649]                   args[[name]] <- ""
[13:23:10.649]                 }
[13:23:10.649]                 NAMES <- toupper(removed)
[13:23:10.649]                 for (kk in seq_along(NAMES)) {
[13:23:10.649]                   name <- removed[[kk]]
[13:23:10.649]                   NAME <- NAMES[[kk]]
[13:23:10.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.649]                     next
[13:23:10.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.649]                 }
[13:23:10.649]                 if (length(args) > 0) 
[13:23:10.649]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.649]             }
[13:23:10.649]             else {
[13:23:10.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.649]             }
[13:23:10.649]             {
[13:23:10.649]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.649]                   0L) {
[13:23:10.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.649]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.649]                   base::options(opts)
[13:23:10.649]                 }
[13:23:10.649]                 {
[13:23:10.649]                   {
[13:23:10.649]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.649]                     NULL
[13:23:10.649]                   }
[13:23:10.649]                   options(future.plan = NULL)
[13:23:10.649]                   if (is.na(NA_character_)) 
[13:23:10.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.649]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.649]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.649]                     envir = parent.frame()) 
[13:23:10.649]                   {
[13:23:10.649]                     if (is.function(workers)) 
[13:23:10.649]                       workers <- workers()
[13:23:10.649]                     workers <- structure(as.integer(workers), 
[13:23:10.649]                       class = class(workers))
[13:23:10.649]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.649]                       workers >= 1)
[13:23:10.649]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.649]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.649]                     }
[13:23:10.649]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.649]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.649]                       envir = envir)
[13:23:10.649]                     if (!future$lazy) 
[13:23:10.649]                       future <- run(future)
[13:23:10.649]                     invisible(future)
[13:23:10.649]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.649]                 }
[13:23:10.649]             }
[13:23:10.649]         }
[13:23:10.649]     })
[13:23:10.649]     if (TRUE) {
[13:23:10.649]         base::sink(type = "output", split = FALSE)
[13:23:10.649]         if (TRUE) {
[13:23:10.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.649]         }
[13:23:10.649]         else {
[13:23:10.649]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.649]         }
[13:23:10.649]         base::close(...future.stdout)
[13:23:10.649]         ...future.stdout <- NULL
[13:23:10.649]     }
[13:23:10.649]     ...future.result$conditions <- ...future.conditions
[13:23:10.649]     ...future.result$finished <- base::Sys.time()
[13:23:10.649]     ...future.result
[13:23:10.649] }
[13:23:10.653] MultisessionFuture started
[13:23:10.653] - Launch lazy future ... done
[13:23:10.653] run() for ‘MultisessionFuture’ ... done
[13:23:10.653] getGlobalsAndPackages() ...
[13:23:10.654] Searching for globals...
[13:23:10.654] - globals found: [1] ‘{’
[13:23:10.654] Searching for globals ... DONE
[13:23:10.654] Resolving globals: FALSE
[13:23:10.655] 
[13:23:10.655] 
[13:23:10.655] getGlobalsAndPackages() ... DONE
[13:23:10.655] run() for ‘Future’ ...
[13:23:10.655] - state: ‘created’
[13:23:10.655] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.671] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.671]   - Field: ‘node’
[13:23:10.672]   - Field: ‘label’
[13:23:10.672]   - Field: ‘local’
[13:23:10.672]   - Field: ‘owner’
[13:23:10.672]   - Field: ‘envir’
[13:23:10.672]   - Field: ‘workers’
[13:23:10.672]   - Field: ‘packages’
[13:23:10.672]   - Field: ‘gc’
[13:23:10.672]   - Field: ‘conditions’
[13:23:10.672]   - Field: ‘persistent’
[13:23:10.672]   - Field: ‘expr’
[13:23:10.673]   - Field: ‘uuid’
[13:23:10.673]   - Field: ‘seed’
[13:23:10.673]   - Field: ‘version’
[13:23:10.673]   - Field: ‘result’
[13:23:10.673]   - Field: ‘asynchronous’
[13:23:10.673]   - Field: ‘calls’
[13:23:10.674]   - Field: ‘globals’
[13:23:10.674]   - Field: ‘stdout’
[13:23:10.674]   - Field: ‘earlySignal’
[13:23:10.674]   - Field: ‘lazy’
[13:23:10.674]   - Field: ‘state’
[13:23:10.674] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.675] - Launch lazy future ...
[13:23:10.675] Packages needed by the future expression (n = 0): <none>
[13:23:10.675] Packages needed by future strategies (n = 0): <none>
[13:23:10.675] {
[13:23:10.675]     {
[13:23:10.675]         {
[13:23:10.675]             ...future.startTime <- base::Sys.time()
[13:23:10.675]             {
[13:23:10.675]                 {
[13:23:10.675]                   {
[13:23:10.675]                     {
[13:23:10.675]                       base::local({
[13:23:10.675]                         has_future <- base::requireNamespace("future", 
[13:23:10.675]                           quietly = TRUE)
[13:23:10.675]                         if (has_future) {
[13:23:10.675]                           ns <- base::getNamespace("future")
[13:23:10.675]                           version <- ns[[".package"]][["version"]]
[13:23:10.675]                           if (is.null(version)) 
[13:23:10.675]                             version <- utils::packageVersion("future")
[13:23:10.675]                         }
[13:23:10.675]                         else {
[13:23:10.675]                           version <- NULL
[13:23:10.675]                         }
[13:23:10.675]                         if (!has_future || version < "1.8.0") {
[13:23:10.675]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.675]                             "", base::R.version$version.string), 
[13:23:10.675]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.675]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.675]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.675]                               "release", "version")], collapse = " "), 
[13:23:10.675]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.675]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.675]                             info)
[13:23:10.675]                           info <- base::paste(info, collapse = "; ")
[13:23:10.675]                           if (!has_future) {
[13:23:10.675]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.675]                               info)
[13:23:10.675]                           }
[13:23:10.675]                           else {
[13:23:10.675]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.675]                               info, version)
[13:23:10.675]                           }
[13:23:10.675]                           base::stop(msg)
[13:23:10.675]                         }
[13:23:10.675]                       })
[13:23:10.675]                     }
[13:23:10.675]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.675]                     base::options(mc.cores = 1L)
[13:23:10.675]                   }
[13:23:10.675]                   options(future.plan = NULL)
[13:23:10.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.675]                 }
[13:23:10.675]                 ...future.workdir <- getwd()
[13:23:10.675]             }
[13:23:10.675]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.675]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.675]         }
[13:23:10.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.675]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.675]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.675]             base::names(...future.oldOptions))
[13:23:10.675]     }
[13:23:10.675]     if (FALSE) {
[13:23:10.675]     }
[13:23:10.675]     else {
[13:23:10.675]         if (TRUE) {
[13:23:10.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.675]                 open = "w")
[13:23:10.675]         }
[13:23:10.675]         else {
[13:23:10.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.675]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.675]         }
[13:23:10.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.675]             base::sink(type = "output", split = FALSE)
[13:23:10.675]             base::close(...future.stdout)
[13:23:10.675]         }, add = TRUE)
[13:23:10.675]     }
[13:23:10.675]     ...future.frame <- base::sys.nframe()
[13:23:10.675]     ...future.conditions <- base::list()
[13:23:10.675]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.675]     if (FALSE) {
[13:23:10.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.675]     }
[13:23:10.675]     ...future.result <- base::tryCatch({
[13:23:10.675]         base::withCallingHandlers({
[13:23:10.675]             ...future.value <- base::withVisible(base::local({
[13:23:10.675]                 ...future.makeSendCondition <- base::local({
[13:23:10.675]                   sendCondition <- NULL
[13:23:10.675]                   function(frame = 1L) {
[13:23:10.675]                     if (is.function(sendCondition)) 
[13:23:10.675]                       return(sendCondition)
[13:23:10.675]                     ns <- getNamespace("parallel")
[13:23:10.675]                     if (exists("sendData", mode = "function", 
[13:23:10.675]                       envir = ns)) {
[13:23:10.675]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.675]                         envir = ns)
[13:23:10.675]                       envir <- sys.frame(frame)
[13:23:10.675]                       master <- NULL
[13:23:10.675]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.675]                         !identical(envir, emptyenv())) {
[13:23:10.675]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.675]                           inherits = FALSE)) {
[13:23:10.675]                           master <- get("master", mode = "list", 
[13:23:10.675]                             envir = envir, inherits = FALSE)
[13:23:10.675]                           if (inherits(master, c("SOCKnode", 
[13:23:10.675]                             "SOCK0node"))) {
[13:23:10.675]                             sendCondition <<- function(cond) {
[13:23:10.675]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.675]                                 success = TRUE)
[13:23:10.675]                               parallel_sendData(master, data)
[13:23:10.675]                             }
[13:23:10.675]                             return(sendCondition)
[13:23:10.675]                           }
[13:23:10.675]                         }
[13:23:10.675]                         frame <- frame + 1L
[13:23:10.675]                         envir <- sys.frame(frame)
[13:23:10.675]                       }
[13:23:10.675]                     }
[13:23:10.675]                     sendCondition <<- function(cond) NULL
[13:23:10.675]                   }
[13:23:10.675]                 })
[13:23:10.675]                 withCallingHandlers({
[13:23:10.675]                   {
[13:23:10.675]                     4
[13:23:10.675]                   }
[13:23:10.675]                 }, immediateCondition = function(cond) {
[13:23:10.675]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.675]                   sendCondition(cond)
[13:23:10.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.675]                   {
[13:23:10.675]                     inherits <- base::inherits
[13:23:10.675]                     invokeRestart <- base::invokeRestart
[13:23:10.675]                     is.null <- base::is.null
[13:23:10.675]                     muffled <- FALSE
[13:23:10.675]                     if (inherits(cond, "message")) {
[13:23:10.675]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.675]                       if (muffled) 
[13:23:10.675]                         invokeRestart("muffleMessage")
[13:23:10.675]                     }
[13:23:10.675]                     else if (inherits(cond, "warning")) {
[13:23:10.675]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.675]                       if (muffled) 
[13:23:10.675]                         invokeRestart("muffleWarning")
[13:23:10.675]                     }
[13:23:10.675]                     else if (inherits(cond, "condition")) {
[13:23:10.675]                       if (!is.null(pattern)) {
[13:23:10.675]                         computeRestarts <- base::computeRestarts
[13:23:10.675]                         grepl <- base::grepl
[13:23:10.675]                         restarts <- computeRestarts(cond)
[13:23:10.675]                         for (restart in restarts) {
[13:23:10.675]                           name <- restart$name
[13:23:10.675]                           if (is.null(name)) 
[13:23:10.675]                             next
[13:23:10.675]                           if (!grepl(pattern, name)) 
[13:23:10.675]                             next
[13:23:10.675]                           invokeRestart(restart)
[13:23:10.675]                           muffled <- TRUE
[13:23:10.675]                           break
[13:23:10.675]                         }
[13:23:10.675]                       }
[13:23:10.675]                     }
[13:23:10.675]                     invisible(muffled)
[13:23:10.675]                   }
[13:23:10.675]                   muffleCondition(cond)
[13:23:10.675]                 })
[13:23:10.675]             }))
[13:23:10.675]             future::FutureResult(value = ...future.value$value, 
[13:23:10.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.675]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.675]                     ...future.globalenv.names))
[13:23:10.675]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.675]         }, condition = base::local({
[13:23:10.675]             c <- base::c
[13:23:10.675]             inherits <- base::inherits
[13:23:10.675]             invokeRestart <- base::invokeRestart
[13:23:10.675]             length <- base::length
[13:23:10.675]             list <- base::list
[13:23:10.675]             seq.int <- base::seq.int
[13:23:10.675]             signalCondition <- base::signalCondition
[13:23:10.675]             sys.calls <- base::sys.calls
[13:23:10.675]             `[[` <- base::`[[`
[13:23:10.675]             `+` <- base::`+`
[13:23:10.675]             `<<-` <- base::`<<-`
[13:23:10.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.675]                   3L)]
[13:23:10.675]             }
[13:23:10.675]             function(cond) {
[13:23:10.675]                 is_error <- inherits(cond, "error")
[13:23:10.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.675]                   NULL)
[13:23:10.675]                 if (is_error) {
[13:23:10.675]                   sessionInformation <- function() {
[13:23:10.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.675]                       search = base::search(), system = base::Sys.info())
[13:23:10.675]                   }
[13:23:10.675]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.675]                     cond$call), session = sessionInformation(), 
[13:23:10.675]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.675]                   signalCondition(cond)
[13:23:10.675]                 }
[13:23:10.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.675]                 "immediateCondition"))) {
[13:23:10.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.675]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.675]                   if (TRUE && !signal) {
[13:23:10.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.675]                     {
[13:23:10.675]                       inherits <- base::inherits
[13:23:10.675]                       invokeRestart <- base::invokeRestart
[13:23:10.675]                       is.null <- base::is.null
[13:23:10.675]                       muffled <- FALSE
[13:23:10.675]                       if (inherits(cond, "message")) {
[13:23:10.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.675]                         if (muffled) 
[13:23:10.675]                           invokeRestart("muffleMessage")
[13:23:10.675]                       }
[13:23:10.675]                       else if (inherits(cond, "warning")) {
[13:23:10.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.675]                         if (muffled) 
[13:23:10.675]                           invokeRestart("muffleWarning")
[13:23:10.675]                       }
[13:23:10.675]                       else if (inherits(cond, "condition")) {
[13:23:10.675]                         if (!is.null(pattern)) {
[13:23:10.675]                           computeRestarts <- base::computeRestarts
[13:23:10.675]                           grepl <- base::grepl
[13:23:10.675]                           restarts <- computeRestarts(cond)
[13:23:10.675]                           for (restart in restarts) {
[13:23:10.675]                             name <- restart$name
[13:23:10.675]                             if (is.null(name)) 
[13:23:10.675]                               next
[13:23:10.675]                             if (!grepl(pattern, name)) 
[13:23:10.675]                               next
[13:23:10.675]                             invokeRestart(restart)
[13:23:10.675]                             muffled <- TRUE
[13:23:10.675]                             break
[13:23:10.675]                           }
[13:23:10.675]                         }
[13:23:10.675]                       }
[13:23:10.675]                       invisible(muffled)
[13:23:10.675]                     }
[13:23:10.675]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.675]                   }
[13:23:10.675]                 }
[13:23:10.675]                 else {
[13:23:10.675]                   if (TRUE) {
[13:23:10.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.675]                     {
[13:23:10.675]                       inherits <- base::inherits
[13:23:10.675]                       invokeRestart <- base::invokeRestart
[13:23:10.675]                       is.null <- base::is.null
[13:23:10.675]                       muffled <- FALSE
[13:23:10.675]                       if (inherits(cond, "message")) {
[13:23:10.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.675]                         if (muffled) 
[13:23:10.675]                           invokeRestart("muffleMessage")
[13:23:10.675]                       }
[13:23:10.675]                       else if (inherits(cond, "warning")) {
[13:23:10.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.675]                         if (muffled) 
[13:23:10.675]                           invokeRestart("muffleWarning")
[13:23:10.675]                       }
[13:23:10.675]                       else if (inherits(cond, "condition")) {
[13:23:10.675]                         if (!is.null(pattern)) {
[13:23:10.675]                           computeRestarts <- base::computeRestarts
[13:23:10.675]                           grepl <- base::grepl
[13:23:10.675]                           restarts <- computeRestarts(cond)
[13:23:10.675]                           for (restart in restarts) {
[13:23:10.675]                             name <- restart$name
[13:23:10.675]                             if (is.null(name)) 
[13:23:10.675]                               next
[13:23:10.675]                             if (!grepl(pattern, name)) 
[13:23:10.675]                               next
[13:23:10.675]                             invokeRestart(restart)
[13:23:10.675]                             muffled <- TRUE
[13:23:10.675]                             break
[13:23:10.675]                           }
[13:23:10.675]                         }
[13:23:10.675]                       }
[13:23:10.675]                       invisible(muffled)
[13:23:10.675]                     }
[13:23:10.675]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.675]                   }
[13:23:10.675]                 }
[13:23:10.675]             }
[13:23:10.675]         }))
[13:23:10.675]     }, error = function(ex) {
[13:23:10.675]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.675]                 ...future.rng), started = ...future.startTime, 
[13:23:10.675]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.675]             version = "1.8"), class = "FutureResult")
[13:23:10.675]     }, finally = {
[13:23:10.675]         if (!identical(...future.workdir, getwd())) 
[13:23:10.675]             setwd(...future.workdir)
[13:23:10.675]         {
[13:23:10.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.675]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.675]             }
[13:23:10.675]             base::options(...future.oldOptions)
[13:23:10.675]             if (.Platform$OS.type == "windows") {
[13:23:10.675]                 old_names <- names(...future.oldEnvVars)
[13:23:10.675]                 envs <- base::Sys.getenv()
[13:23:10.675]                 names <- names(envs)
[13:23:10.675]                 common <- intersect(names, old_names)
[13:23:10.675]                 added <- setdiff(names, old_names)
[13:23:10.675]                 removed <- setdiff(old_names, names)
[13:23:10.675]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.675]                   envs[common]]
[13:23:10.675]                 NAMES <- toupper(changed)
[13:23:10.675]                 args <- list()
[13:23:10.675]                 for (kk in seq_along(NAMES)) {
[13:23:10.675]                   name <- changed[[kk]]
[13:23:10.675]                   NAME <- NAMES[[kk]]
[13:23:10.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.675]                     next
[13:23:10.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.675]                 }
[13:23:10.675]                 NAMES <- toupper(added)
[13:23:10.675]                 for (kk in seq_along(NAMES)) {
[13:23:10.675]                   name <- added[[kk]]
[13:23:10.675]                   NAME <- NAMES[[kk]]
[13:23:10.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.675]                     next
[13:23:10.675]                   args[[name]] <- ""
[13:23:10.675]                 }
[13:23:10.675]                 NAMES <- toupper(removed)
[13:23:10.675]                 for (kk in seq_along(NAMES)) {
[13:23:10.675]                   name <- removed[[kk]]
[13:23:10.675]                   NAME <- NAMES[[kk]]
[13:23:10.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.675]                     next
[13:23:10.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.675]                 }
[13:23:10.675]                 if (length(args) > 0) 
[13:23:10.675]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.675]             }
[13:23:10.675]             else {
[13:23:10.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.675]             }
[13:23:10.675]             {
[13:23:10.675]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.675]                   0L) {
[13:23:10.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.675]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.675]                   base::options(opts)
[13:23:10.675]                 }
[13:23:10.675]                 {
[13:23:10.675]                   {
[13:23:10.675]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.675]                     NULL
[13:23:10.675]                   }
[13:23:10.675]                   options(future.plan = NULL)
[13:23:10.675]                   if (is.na(NA_character_)) 
[13:23:10.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.675]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.675]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.675]                     envir = parent.frame()) 
[13:23:10.675]                   {
[13:23:10.675]                     if (is.function(workers)) 
[13:23:10.675]                       workers <- workers()
[13:23:10.675]                     workers <- structure(as.integer(workers), 
[13:23:10.675]                       class = class(workers))
[13:23:10.675]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.675]                       workers >= 1)
[13:23:10.675]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.675]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.675]                     }
[13:23:10.675]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.675]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.675]                       envir = envir)
[13:23:10.675]                     if (!future$lazy) 
[13:23:10.675]                       future <- run(future)
[13:23:10.675]                     invisible(future)
[13:23:10.675]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.675]                 }
[13:23:10.675]             }
[13:23:10.675]         }
[13:23:10.675]     })
[13:23:10.675]     if (TRUE) {
[13:23:10.675]         base::sink(type = "output", split = FALSE)
[13:23:10.675]         if (TRUE) {
[13:23:10.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.675]         }
[13:23:10.675]         else {
[13:23:10.675]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.675]         }
[13:23:10.675]         base::close(...future.stdout)
[13:23:10.675]         ...future.stdout <- NULL
[13:23:10.675]     }
[13:23:10.675]     ...future.result$conditions <- ...future.conditions
[13:23:10.675]     ...future.result$finished <- base::Sys.time()
[13:23:10.675]     ...future.result
[13:23:10.675] }
[13:23:10.678] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:10.689] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.689] - Validating connection of MultisessionFuture
[13:23:10.689] - received message: FutureResult
[13:23:10.689] - Received FutureResult
[13:23:10.690] - Erased future from FutureRegistry
[13:23:10.690] result() for ClusterFuture ...
[13:23:10.690] - result already collected: FutureResult
[13:23:10.690] result() for ClusterFuture ... done
[13:23:10.690] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:10.690] result() for ClusterFuture ...
[13:23:10.690] - result already collected: FutureResult
[13:23:10.690] result() for ClusterFuture ... done
[13:23:10.690] result() for ClusterFuture ...
[13:23:10.690] - result already collected: FutureResult
[13:23:10.691] result() for ClusterFuture ... done
[13:23:10.692] MultisessionFuture started
[13:23:10.692] - Launch lazy future ... done
[13:23:10.692] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d70b44c0> 
Classes 'listenv', 'environment' <environment: 0x5596d53d4880> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[13:23:10.701] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.701] - Validating connection of MultisessionFuture
[13:23:10.702] - received message: FutureResult
[13:23:10.702] - Received FutureResult
[13:23:10.702] - Erased future from FutureRegistry
[13:23:10.702] result() for ClusterFuture ...
[13:23:10.702] - result already collected: FutureResult
[13:23:10.702] result() for ClusterFuture ... done
[13:23:10.702] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:10.716] resolve() on list environment ...
[13:23:10.716]  recursive: 0
[13:23:10.717]  length: 6
[13:23:10.717]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:10.717] signalConditionsASAP(numeric, pos=1) ...
[13:23:10.717] - nx: 6
[13:23:10.717] - relay: TRUE
[13:23:10.718] - stdout: TRUE
[13:23:10.718] - signal: TRUE
[13:23:10.718] - resignal: FALSE
[13:23:10.718] - force: TRUE
[13:23:10.718] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.718] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.718]  - until=2
[13:23:10.718]  - relaying element #2
[13:23:10.718] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.718] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.718] signalConditionsASAP(NULL, pos=1) ... done
[13:23:10.719]  length: 5 (resolved future 1)
[13:23:10.719] Future #2
[13:23:10.719] result() for ClusterFuture ...
[13:23:10.719] - result already collected: FutureResult
[13:23:10.719] result() for ClusterFuture ... done
[13:23:10.719] result() for ClusterFuture ...
[13:23:10.719] - result already collected: FutureResult
[13:23:10.719] result() for ClusterFuture ... done
[13:23:10.719] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:10.719] - nx: 6
[13:23:10.720] - relay: TRUE
[13:23:10.720] - stdout: TRUE
[13:23:10.720] - signal: TRUE
[13:23:10.720] - resignal: FALSE
[13:23:10.720] - force: TRUE
[13:23:10.720] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.720] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.720]  - until=2
[13:23:10.720]  - relaying element #2
[13:23:10.720] result() for ClusterFuture ...
[13:23:10.721] - result already collected: FutureResult
[13:23:10.721] result() for ClusterFuture ... done
[13:23:10.721] result() for ClusterFuture ...
[13:23:10.721] - result already collected: FutureResult
[13:23:10.721] result() for ClusterFuture ... done
[13:23:10.721] result() for ClusterFuture ...
[13:23:10.721] - result already collected: FutureResult
[13:23:10.721] result() for ClusterFuture ... done
[13:23:10.721] result() for ClusterFuture ...
[13:23:10.721] - result already collected: FutureResult
[13:23:10.721] result() for ClusterFuture ... done
[13:23:10.722] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.722] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.722] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:10.722]  length: 4 (resolved future 2)
[13:23:10.722] Future #3
[13:23:10.722] result() for ClusterFuture ...
[13:23:10.722] - result already collected: FutureResult
[13:23:10.722] result() for ClusterFuture ... done
[13:23:10.722] result() for ClusterFuture ...
[13:23:10.722] - result already collected: FutureResult
[13:23:10.722] result() for ClusterFuture ... done
[13:23:10.723] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:10.723] - nx: 6
[13:23:10.723] - relay: TRUE
[13:23:10.723] - stdout: TRUE
[13:23:10.723] - signal: TRUE
[13:23:10.723] - resignal: FALSE
[13:23:10.723] - force: TRUE
[13:23:10.723] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.723] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.723]  - until=3
[13:23:10.723]  - relaying element #3
[13:23:10.724] result() for ClusterFuture ...
[13:23:10.724] - result already collected: FutureResult
[13:23:10.724] result() for ClusterFuture ... done
[13:23:10.724] result() for ClusterFuture ...
[13:23:10.724] - result already collected: FutureResult
[13:23:10.724] result() for ClusterFuture ... done
[13:23:10.724] result() for ClusterFuture ...
[13:23:10.724] - result already collected: FutureResult
[13:23:10.724] result() for ClusterFuture ... done
[13:23:10.724] result() for ClusterFuture ...
[13:23:10.725] - result already collected: FutureResult
[13:23:10.725] result() for ClusterFuture ... done
[13:23:10.725] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.725] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.725] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:10.725]  length: 3 (resolved future 3)
[13:23:10.736] signalConditionsASAP(NULL, pos=5) ...
[13:23:10.736] - nx: 6
[13:23:10.736] - relay: TRUE
[13:23:10.736] - stdout: TRUE
[13:23:10.737] - signal: TRUE
[13:23:10.737] - resignal: FALSE
[13:23:10.737] - force: TRUE
[13:23:10.737] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.737] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.737]  - until=6
[13:23:10.738]  - relaying element #4
[13:23:10.738]  - relaying element #6
[13:23:10.738] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:10.738] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.738] signalConditionsASAP(NULL, pos=5) ... done
[13:23:10.738]  length: 2 (resolved future 5)
[13:23:10.738] signalConditionsASAP(numeric, pos=6) ...
[13:23:10.738] - nx: 6
[13:23:10.739] - relay: TRUE
[13:23:10.739] - stdout: TRUE
[13:23:10.739] - signal: TRUE
[13:23:10.739] - resignal: FALSE
[13:23:10.739] - force: TRUE
[13:23:10.739] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:10.739] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.739]  - until=6
[13:23:10.739]  - relaying element #4
[13:23:10.739] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:10.739] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.740] signalConditionsASAP(NULL, pos=6) ... done
[13:23:10.740]  length: 1 (resolved future 6)
[13:23:10.751] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.751] - Validating connection of MultisessionFuture
[13:23:10.751] - received message: FutureResult
[13:23:10.751] - Received FutureResult
[13:23:10.751] - Erased future from FutureRegistry
[13:23:10.752] result() for ClusterFuture ...
[13:23:10.752] - result already collected: FutureResult
[13:23:10.752] result() for ClusterFuture ... done
[13:23:10.752] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:10.752] Future #4
[13:23:10.752] result() for ClusterFuture ...
[13:23:10.752] - result already collected: FutureResult
[13:23:10.752] result() for ClusterFuture ... done
[13:23:10.752] result() for ClusterFuture ...
[13:23:10.752] - result already collected: FutureResult
[13:23:10.752] result() for ClusterFuture ... done
[13:23:10.753] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:10.753] - nx: 6
[13:23:10.753] - relay: TRUE
[13:23:10.753] - stdout: TRUE
[13:23:10.753] - signal: TRUE
[13:23:10.753] - resignal: FALSE
[13:23:10.753] - force: TRUE
[13:23:10.753] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:10.753] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.753]  - until=6
[13:23:10.753]  - relaying element #4
[13:23:10.754] result() for ClusterFuture ...
[13:23:10.754] - result already collected: FutureResult
[13:23:10.754] result() for ClusterFuture ... done
[13:23:10.754] result() for ClusterFuture ...
[13:23:10.754] - result already collected: FutureResult
[13:23:10.754] result() for ClusterFuture ... done
[13:23:10.754] result() for ClusterFuture ...
[13:23:10.754] - result already collected: FutureResult
[13:23:10.754] result() for ClusterFuture ... done
[13:23:10.754] result() for ClusterFuture ...
[13:23:10.754] - result already collected: FutureResult
[13:23:10.755] result() for ClusterFuture ... done
[13:23:10.755] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:10.755] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:10.755] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:10.755]  length: 0 (resolved future 4)
[13:23:10.755] Relaying remaining futures
[13:23:10.755] signalConditionsASAP(NULL, pos=0) ...
[13:23:10.755] - nx: 6
[13:23:10.755] - relay: TRUE
[13:23:10.755] - stdout: TRUE
[13:23:10.755] - signal: TRUE
[13:23:10.756] - resignal: FALSE
[13:23:10.756] - force: TRUE
[13:23:10.756] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:10.756] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:10.756] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:10.756] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:10.756] signalConditionsASAP(NULL, pos=0) ... done
[13:23:10.756] resolve() on list environment ... DONE
[13:23:10.756] result() for ClusterFuture ...
[13:23:10.757] - result already collected: FutureResult
[13:23:10.757] result() for ClusterFuture ... done
[13:23:10.757] result() for ClusterFuture ...
[13:23:10.757] - result already collected: FutureResult
[13:23:10.757] result() for ClusterFuture ... done
[13:23:10.757] result() for ClusterFuture ...
[13:23:10.757] - result already collected: FutureResult
[13:23:10.757] result() for ClusterFuture ... done
[13:23:10.757] result() for ClusterFuture ...
[13:23:10.757] - result already collected: FutureResult
[13:23:10.757] result() for ClusterFuture ... done
[13:23:10.758] result() for ClusterFuture ...
[13:23:10.758] - result already collected: FutureResult
[13:23:10.758] result() for ClusterFuture ... done
[13:23:10.758] result() for ClusterFuture ...
[13:23:10.758] - result already collected: FutureResult
[13:23:10.758] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d4c961e8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[13:23:10.760] getGlobalsAndPackages() ...
[13:23:10.760] Searching for globals...
[13:23:10.761] 
[13:23:10.761] Searching for globals ... DONE
[13:23:10.761] - globals: [0] <none>
[13:23:10.761] getGlobalsAndPackages() ... DONE
[13:23:10.761] run() for ‘Future’ ...
[13:23:10.761] - state: ‘created’
[13:23:10.761] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.776] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.777]   - Field: ‘node’
[13:23:10.777]   - Field: ‘label’
[13:23:10.777]   - Field: ‘local’
[13:23:10.777]   - Field: ‘owner’
[13:23:10.777]   - Field: ‘envir’
[13:23:10.777]   - Field: ‘workers’
[13:23:10.777]   - Field: ‘packages’
[13:23:10.777]   - Field: ‘gc’
[13:23:10.777]   - Field: ‘conditions’
[13:23:10.778]   - Field: ‘persistent’
[13:23:10.778]   - Field: ‘expr’
[13:23:10.778]   - Field: ‘uuid’
[13:23:10.778]   - Field: ‘seed’
[13:23:10.778]   - Field: ‘version’
[13:23:10.778]   - Field: ‘result’
[13:23:10.778]   - Field: ‘asynchronous’
[13:23:10.778]   - Field: ‘calls’
[13:23:10.778]   - Field: ‘globals’
[13:23:10.778]   - Field: ‘stdout’
[13:23:10.779]   - Field: ‘earlySignal’
[13:23:10.779]   - Field: ‘lazy’
[13:23:10.779]   - Field: ‘state’
[13:23:10.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.779] - Launch lazy future ...
[13:23:10.779] Packages needed by the future expression (n = 0): <none>
[13:23:10.779] Packages needed by future strategies (n = 0): <none>
[13:23:10.780] {
[13:23:10.780]     {
[13:23:10.780]         {
[13:23:10.780]             ...future.startTime <- base::Sys.time()
[13:23:10.780]             {
[13:23:10.780]                 {
[13:23:10.780]                   {
[13:23:10.780]                     {
[13:23:10.780]                       base::local({
[13:23:10.780]                         has_future <- base::requireNamespace("future", 
[13:23:10.780]                           quietly = TRUE)
[13:23:10.780]                         if (has_future) {
[13:23:10.780]                           ns <- base::getNamespace("future")
[13:23:10.780]                           version <- ns[[".package"]][["version"]]
[13:23:10.780]                           if (is.null(version)) 
[13:23:10.780]                             version <- utils::packageVersion("future")
[13:23:10.780]                         }
[13:23:10.780]                         else {
[13:23:10.780]                           version <- NULL
[13:23:10.780]                         }
[13:23:10.780]                         if (!has_future || version < "1.8.0") {
[13:23:10.780]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.780]                             "", base::R.version$version.string), 
[13:23:10.780]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.780]                               "release", "version")], collapse = " "), 
[13:23:10.780]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.780]                             info)
[13:23:10.780]                           info <- base::paste(info, collapse = "; ")
[13:23:10.780]                           if (!has_future) {
[13:23:10.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.780]                               info)
[13:23:10.780]                           }
[13:23:10.780]                           else {
[13:23:10.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.780]                               info, version)
[13:23:10.780]                           }
[13:23:10.780]                           base::stop(msg)
[13:23:10.780]                         }
[13:23:10.780]                       })
[13:23:10.780]                     }
[13:23:10.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.780]                     base::options(mc.cores = 1L)
[13:23:10.780]                   }
[13:23:10.780]                   options(future.plan = NULL)
[13:23:10.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.780]                 }
[13:23:10.780]                 ...future.workdir <- getwd()
[13:23:10.780]             }
[13:23:10.780]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.780]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.780]         }
[13:23:10.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.780]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.780]             base::names(...future.oldOptions))
[13:23:10.780]     }
[13:23:10.780]     if (FALSE) {
[13:23:10.780]     }
[13:23:10.780]     else {
[13:23:10.780]         if (TRUE) {
[13:23:10.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.780]                 open = "w")
[13:23:10.780]         }
[13:23:10.780]         else {
[13:23:10.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.780]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.780]         }
[13:23:10.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.780]             base::sink(type = "output", split = FALSE)
[13:23:10.780]             base::close(...future.stdout)
[13:23:10.780]         }, add = TRUE)
[13:23:10.780]     }
[13:23:10.780]     ...future.frame <- base::sys.nframe()
[13:23:10.780]     ...future.conditions <- base::list()
[13:23:10.780]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.780]     if (FALSE) {
[13:23:10.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.780]     }
[13:23:10.780]     ...future.result <- base::tryCatch({
[13:23:10.780]         base::withCallingHandlers({
[13:23:10.780]             ...future.value <- base::withVisible(base::local({
[13:23:10.780]                 ...future.makeSendCondition <- base::local({
[13:23:10.780]                   sendCondition <- NULL
[13:23:10.780]                   function(frame = 1L) {
[13:23:10.780]                     if (is.function(sendCondition)) 
[13:23:10.780]                       return(sendCondition)
[13:23:10.780]                     ns <- getNamespace("parallel")
[13:23:10.780]                     if (exists("sendData", mode = "function", 
[13:23:10.780]                       envir = ns)) {
[13:23:10.780]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.780]                         envir = ns)
[13:23:10.780]                       envir <- sys.frame(frame)
[13:23:10.780]                       master <- NULL
[13:23:10.780]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.780]                         !identical(envir, emptyenv())) {
[13:23:10.780]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.780]                           inherits = FALSE)) {
[13:23:10.780]                           master <- get("master", mode = "list", 
[13:23:10.780]                             envir = envir, inherits = FALSE)
[13:23:10.780]                           if (inherits(master, c("SOCKnode", 
[13:23:10.780]                             "SOCK0node"))) {
[13:23:10.780]                             sendCondition <<- function(cond) {
[13:23:10.780]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.780]                                 success = TRUE)
[13:23:10.780]                               parallel_sendData(master, data)
[13:23:10.780]                             }
[13:23:10.780]                             return(sendCondition)
[13:23:10.780]                           }
[13:23:10.780]                         }
[13:23:10.780]                         frame <- frame + 1L
[13:23:10.780]                         envir <- sys.frame(frame)
[13:23:10.780]                       }
[13:23:10.780]                     }
[13:23:10.780]                     sendCondition <<- function(cond) NULL
[13:23:10.780]                   }
[13:23:10.780]                 })
[13:23:10.780]                 withCallingHandlers({
[13:23:10.780]                   2
[13:23:10.780]                 }, immediateCondition = function(cond) {
[13:23:10.780]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.780]                   sendCondition(cond)
[13:23:10.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.780]                   {
[13:23:10.780]                     inherits <- base::inherits
[13:23:10.780]                     invokeRestart <- base::invokeRestart
[13:23:10.780]                     is.null <- base::is.null
[13:23:10.780]                     muffled <- FALSE
[13:23:10.780]                     if (inherits(cond, "message")) {
[13:23:10.780]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.780]                       if (muffled) 
[13:23:10.780]                         invokeRestart("muffleMessage")
[13:23:10.780]                     }
[13:23:10.780]                     else if (inherits(cond, "warning")) {
[13:23:10.780]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.780]                       if (muffled) 
[13:23:10.780]                         invokeRestart("muffleWarning")
[13:23:10.780]                     }
[13:23:10.780]                     else if (inherits(cond, "condition")) {
[13:23:10.780]                       if (!is.null(pattern)) {
[13:23:10.780]                         computeRestarts <- base::computeRestarts
[13:23:10.780]                         grepl <- base::grepl
[13:23:10.780]                         restarts <- computeRestarts(cond)
[13:23:10.780]                         for (restart in restarts) {
[13:23:10.780]                           name <- restart$name
[13:23:10.780]                           if (is.null(name)) 
[13:23:10.780]                             next
[13:23:10.780]                           if (!grepl(pattern, name)) 
[13:23:10.780]                             next
[13:23:10.780]                           invokeRestart(restart)
[13:23:10.780]                           muffled <- TRUE
[13:23:10.780]                           break
[13:23:10.780]                         }
[13:23:10.780]                       }
[13:23:10.780]                     }
[13:23:10.780]                     invisible(muffled)
[13:23:10.780]                   }
[13:23:10.780]                   muffleCondition(cond)
[13:23:10.780]                 })
[13:23:10.780]             }))
[13:23:10.780]             future::FutureResult(value = ...future.value$value, 
[13:23:10.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.780]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.780]                     ...future.globalenv.names))
[13:23:10.780]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.780]         }, condition = base::local({
[13:23:10.780]             c <- base::c
[13:23:10.780]             inherits <- base::inherits
[13:23:10.780]             invokeRestart <- base::invokeRestart
[13:23:10.780]             length <- base::length
[13:23:10.780]             list <- base::list
[13:23:10.780]             seq.int <- base::seq.int
[13:23:10.780]             signalCondition <- base::signalCondition
[13:23:10.780]             sys.calls <- base::sys.calls
[13:23:10.780]             `[[` <- base::`[[`
[13:23:10.780]             `+` <- base::`+`
[13:23:10.780]             `<<-` <- base::`<<-`
[13:23:10.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.780]                   3L)]
[13:23:10.780]             }
[13:23:10.780]             function(cond) {
[13:23:10.780]                 is_error <- inherits(cond, "error")
[13:23:10.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.780]                   NULL)
[13:23:10.780]                 if (is_error) {
[13:23:10.780]                   sessionInformation <- function() {
[13:23:10.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.780]                       search = base::search(), system = base::Sys.info())
[13:23:10.780]                   }
[13:23:10.780]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.780]                     cond$call), session = sessionInformation(), 
[13:23:10.780]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.780]                   signalCondition(cond)
[13:23:10.780]                 }
[13:23:10.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.780]                 "immediateCondition"))) {
[13:23:10.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.780]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.780]                   if (TRUE && !signal) {
[13:23:10.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.780]                     {
[13:23:10.780]                       inherits <- base::inherits
[13:23:10.780]                       invokeRestart <- base::invokeRestart
[13:23:10.780]                       is.null <- base::is.null
[13:23:10.780]                       muffled <- FALSE
[13:23:10.780]                       if (inherits(cond, "message")) {
[13:23:10.780]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.780]                         if (muffled) 
[13:23:10.780]                           invokeRestart("muffleMessage")
[13:23:10.780]                       }
[13:23:10.780]                       else if (inherits(cond, "warning")) {
[13:23:10.780]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.780]                         if (muffled) 
[13:23:10.780]                           invokeRestart("muffleWarning")
[13:23:10.780]                       }
[13:23:10.780]                       else if (inherits(cond, "condition")) {
[13:23:10.780]                         if (!is.null(pattern)) {
[13:23:10.780]                           computeRestarts <- base::computeRestarts
[13:23:10.780]                           grepl <- base::grepl
[13:23:10.780]                           restarts <- computeRestarts(cond)
[13:23:10.780]                           for (restart in restarts) {
[13:23:10.780]                             name <- restart$name
[13:23:10.780]                             if (is.null(name)) 
[13:23:10.780]                               next
[13:23:10.780]                             if (!grepl(pattern, name)) 
[13:23:10.780]                               next
[13:23:10.780]                             invokeRestart(restart)
[13:23:10.780]                             muffled <- TRUE
[13:23:10.780]                             break
[13:23:10.780]                           }
[13:23:10.780]                         }
[13:23:10.780]                       }
[13:23:10.780]                       invisible(muffled)
[13:23:10.780]                     }
[13:23:10.780]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.780]                   }
[13:23:10.780]                 }
[13:23:10.780]                 else {
[13:23:10.780]                   if (TRUE) {
[13:23:10.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.780]                     {
[13:23:10.780]                       inherits <- base::inherits
[13:23:10.780]                       invokeRestart <- base::invokeRestart
[13:23:10.780]                       is.null <- base::is.null
[13:23:10.780]                       muffled <- FALSE
[13:23:10.780]                       if (inherits(cond, "message")) {
[13:23:10.780]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.780]                         if (muffled) 
[13:23:10.780]                           invokeRestart("muffleMessage")
[13:23:10.780]                       }
[13:23:10.780]                       else if (inherits(cond, "warning")) {
[13:23:10.780]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.780]                         if (muffled) 
[13:23:10.780]                           invokeRestart("muffleWarning")
[13:23:10.780]                       }
[13:23:10.780]                       else if (inherits(cond, "condition")) {
[13:23:10.780]                         if (!is.null(pattern)) {
[13:23:10.780]                           computeRestarts <- base::computeRestarts
[13:23:10.780]                           grepl <- base::grepl
[13:23:10.780]                           restarts <- computeRestarts(cond)
[13:23:10.780]                           for (restart in restarts) {
[13:23:10.780]                             name <- restart$name
[13:23:10.780]                             if (is.null(name)) 
[13:23:10.780]                               next
[13:23:10.780]                             if (!grepl(pattern, name)) 
[13:23:10.780]                               next
[13:23:10.780]                             invokeRestart(restart)
[13:23:10.780]                             muffled <- TRUE
[13:23:10.780]                             break
[13:23:10.780]                           }
[13:23:10.780]                         }
[13:23:10.780]                       }
[13:23:10.780]                       invisible(muffled)
[13:23:10.780]                     }
[13:23:10.780]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.780]                   }
[13:23:10.780]                 }
[13:23:10.780]             }
[13:23:10.780]         }))
[13:23:10.780]     }, error = function(ex) {
[13:23:10.780]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.780]                 ...future.rng), started = ...future.startTime, 
[13:23:10.780]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.780]             version = "1.8"), class = "FutureResult")
[13:23:10.780]     }, finally = {
[13:23:10.780]         if (!identical(...future.workdir, getwd())) 
[13:23:10.780]             setwd(...future.workdir)
[13:23:10.780]         {
[13:23:10.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.780]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.780]             }
[13:23:10.780]             base::options(...future.oldOptions)
[13:23:10.780]             if (.Platform$OS.type == "windows") {
[13:23:10.780]                 old_names <- names(...future.oldEnvVars)
[13:23:10.780]                 envs <- base::Sys.getenv()
[13:23:10.780]                 names <- names(envs)
[13:23:10.780]                 common <- intersect(names, old_names)
[13:23:10.780]                 added <- setdiff(names, old_names)
[13:23:10.780]                 removed <- setdiff(old_names, names)
[13:23:10.780]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.780]                   envs[common]]
[13:23:10.780]                 NAMES <- toupper(changed)
[13:23:10.780]                 args <- list()
[13:23:10.780]                 for (kk in seq_along(NAMES)) {
[13:23:10.780]                   name <- changed[[kk]]
[13:23:10.780]                   NAME <- NAMES[[kk]]
[13:23:10.780]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.780]                     next
[13:23:10.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.780]                 }
[13:23:10.780]                 NAMES <- toupper(added)
[13:23:10.780]                 for (kk in seq_along(NAMES)) {
[13:23:10.780]                   name <- added[[kk]]
[13:23:10.780]                   NAME <- NAMES[[kk]]
[13:23:10.780]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.780]                     next
[13:23:10.780]                   args[[name]] <- ""
[13:23:10.780]                 }
[13:23:10.780]                 NAMES <- toupper(removed)
[13:23:10.780]                 for (kk in seq_along(NAMES)) {
[13:23:10.780]                   name <- removed[[kk]]
[13:23:10.780]                   NAME <- NAMES[[kk]]
[13:23:10.780]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.780]                     next
[13:23:10.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.780]                 }
[13:23:10.780]                 if (length(args) > 0) 
[13:23:10.780]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.780]             }
[13:23:10.780]             else {
[13:23:10.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.780]             }
[13:23:10.780]             {
[13:23:10.780]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.780]                   0L) {
[13:23:10.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.780]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.780]                   base::options(opts)
[13:23:10.780]                 }
[13:23:10.780]                 {
[13:23:10.780]                   {
[13:23:10.780]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.780]                     NULL
[13:23:10.780]                   }
[13:23:10.780]                   options(future.plan = NULL)
[13:23:10.780]                   if (is.na(NA_character_)) 
[13:23:10.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.780]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.780]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.780]                     envir = parent.frame()) 
[13:23:10.780]                   {
[13:23:10.780]                     if (is.function(workers)) 
[13:23:10.780]                       workers <- workers()
[13:23:10.780]                     workers <- structure(as.integer(workers), 
[13:23:10.780]                       class = class(workers))
[13:23:10.780]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.780]                       workers >= 1)
[13:23:10.780]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.780]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.780]                     }
[13:23:10.780]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.780]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.780]                       envir = envir)
[13:23:10.780]                     if (!future$lazy) 
[13:23:10.780]                       future <- run(future)
[13:23:10.780]                     invisible(future)
[13:23:10.780]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.780]                 }
[13:23:10.780]             }
[13:23:10.780]         }
[13:23:10.780]     })
[13:23:10.780]     if (TRUE) {
[13:23:10.780]         base::sink(type = "output", split = FALSE)
[13:23:10.780]         if (TRUE) {
[13:23:10.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.780]         }
[13:23:10.780]         else {
[13:23:10.780]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.780]         }
[13:23:10.780]         base::close(...future.stdout)
[13:23:10.780]         ...future.stdout <- NULL
[13:23:10.780]     }
[13:23:10.780]     ...future.result$conditions <- ...future.conditions
[13:23:10.780]     ...future.result$finished <- base::Sys.time()
[13:23:10.780]     ...future.result
[13:23:10.780] }
[13:23:10.783] MultisessionFuture started
[13:23:10.783] - Launch lazy future ... done
[13:23:10.784] run() for ‘MultisessionFuture’ ... done
[13:23:10.784] getGlobalsAndPackages() ...
[13:23:10.784] Searching for globals...
[13:23:10.784] 
[13:23:10.784] Searching for globals ... DONE
[13:23:10.784] - globals: [0] <none>
[13:23:10.785] getGlobalsAndPackages() ... DONE
[13:23:10.785] run() for ‘Future’ ...
[13:23:10.785] - state: ‘created’
[13:23:10.785] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.800] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.801]   - Field: ‘node’
[13:23:10.801]   - Field: ‘label’
[13:23:10.801]   - Field: ‘local’
[13:23:10.801]   - Field: ‘owner’
[13:23:10.801]   - Field: ‘envir’
[13:23:10.801]   - Field: ‘workers’
[13:23:10.801]   - Field: ‘packages’
[13:23:10.801]   - Field: ‘gc’
[13:23:10.802]   - Field: ‘conditions’
[13:23:10.802]   - Field: ‘persistent’
[13:23:10.802]   - Field: ‘expr’
[13:23:10.802]   - Field: ‘uuid’
[13:23:10.802]   - Field: ‘seed’
[13:23:10.802]   - Field: ‘version’
[13:23:10.802]   - Field: ‘result’
[13:23:10.802]   - Field: ‘asynchronous’
[13:23:10.802]   - Field: ‘calls’
[13:23:10.802]   - Field: ‘globals’
[13:23:10.803]   - Field: ‘stdout’
[13:23:10.803]   - Field: ‘earlySignal’
[13:23:10.803]   - Field: ‘lazy’
[13:23:10.803]   - Field: ‘state’
[13:23:10.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.803] - Launch lazy future ...
[13:23:10.803] Packages needed by the future expression (n = 0): <none>
[13:23:10.803] Packages needed by future strategies (n = 0): <none>
[13:23:10.804] {
[13:23:10.804]     {
[13:23:10.804]         {
[13:23:10.804]             ...future.startTime <- base::Sys.time()
[13:23:10.804]             {
[13:23:10.804]                 {
[13:23:10.804]                   {
[13:23:10.804]                     {
[13:23:10.804]                       base::local({
[13:23:10.804]                         has_future <- base::requireNamespace("future", 
[13:23:10.804]                           quietly = TRUE)
[13:23:10.804]                         if (has_future) {
[13:23:10.804]                           ns <- base::getNamespace("future")
[13:23:10.804]                           version <- ns[[".package"]][["version"]]
[13:23:10.804]                           if (is.null(version)) 
[13:23:10.804]                             version <- utils::packageVersion("future")
[13:23:10.804]                         }
[13:23:10.804]                         else {
[13:23:10.804]                           version <- NULL
[13:23:10.804]                         }
[13:23:10.804]                         if (!has_future || version < "1.8.0") {
[13:23:10.804]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.804]                             "", base::R.version$version.string), 
[13:23:10.804]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.804]                               "release", "version")], collapse = " "), 
[13:23:10.804]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.804]                             info)
[13:23:10.804]                           info <- base::paste(info, collapse = "; ")
[13:23:10.804]                           if (!has_future) {
[13:23:10.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.804]                               info)
[13:23:10.804]                           }
[13:23:10.804]                           else {
[13:23:10.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.804]                               info, version)
[13:23:10.804]                           }
[13:23:10.804]                           base::stop(msg)
[13:23:10.804]                         }
[13:23:10.804]                       })
[13:23:10.804]                     }
[13:23:10.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.804]                     base::options(mc.cores = 1L)
[13:23:10.804]                   }
[13:23:10.804]                   options(future.plan = NULL)
[13:23:10.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.804]                 }
[13:23:10.804]                 ...future.workdir <- getwd()
[13:23:10.804]             }
[13:23:10.804]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.804]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.804]         }
[13:23:10.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.804]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.804]             base::names(...future.oldOptions))
[13:23:10.804]     }
[13:23:10.804]     if (FALSE) {
[13:23:10.804]     }
[13:23:10.804]     else {
[13:23:10.804]         if (TRUE) {
[13:23:10.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.804]                 open = "w")
[13:23:10.804]         }
[13:23:10.804]         else {
[13:23:10.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.804]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.804]         }
[13:23:10.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.804]             base::sink(type = "output", split = FALSE)
[13:23:10.804]             base::close(...future.stdout)
[13:23:10.804]         }, add = TRUE)
[13:23:10.804]     }
[13:23:10.804]     ...future.frame <- base::sys.nframe()
[13:23:10.804]     ...future.conditions <- base::list()
[13:23:10.804]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.804]     if (FALSE) {
[13:23:10.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.804]     }
[13:23:10.804]     ...future.result <- base::tryCatch({
[13:23:10.804]         base::withCallingHandlers({
[13:23:10.804]             ...future.value <- base::withVisible(base::local({
[13:23:10.804]                 ...future.makeSendCondition <- base::local({
[13:23:10.804]                   sendCondition <- NULL
[13:23:10.804]                   function(frame = 1L) {
[13:23:10.804]                     if (is.function(sendCondition)) 
[13:23:10.804]                       return(sendCondition)
[13:23:10.804]                     ns <- getNamespace("parallel")
[13:23:10.804]                     if (exists("sendData", mode = "function", 
[13:23:10.804]                       envir = ns)) {
[13:23:10.804]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.804]                         envir = ns)
[13:23:10.804]                       envir <- sys.frame(frame)
[13:23:10.804]                       master <- NULL
[13:23:10.804]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.804]                         !identical(envir, emptyenv())) {
[13:23:10.804]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.804]                           inherits = FALSE)) {
[13:23:10.804]                           master <- get("master", mode = "list", 
[13:23:10.804]                             envir = envir, inherits = FALSE)
[13:23:10.804]                           if (inherits(master, c("SOCKnode", 
[13:23:10.804]                             "SOCK0node"))) {
[13:23:10.804]                             sendCondition <<- function(cond) {
[13:23:10.804]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.804]                                 success = TRUE)
[13:23:10.804]                               parallel_sendData(master, data)
[13:23:10.804]                             }
[13:23:10.804]                             return(sendCondition)
[13:23:10.804]                           }
[13:23:10.804]                         }
[13:23:10.804]                         frame <- frame + 1L
[13:23:10.804]                         envir <- sys.frame(frame)
[13:23:10.804]                       }
[13:23:10.804]                     }
[13:23:10.804]                     sendCondition <<- function(cond) NULL
[13:23:10.804]                   }
[13:23:10.804]                 })
[13:23:10.804]                 withCallingHandlers({
[13:23:10.804]                   NULL
[13:23:10.804]                 }, immediateCondition = function(cond) {
[13:23:10.804]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.804]                   sendCondition(cond)
[13:23:10.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.804]                   {
[13:23:10.804]                     inherits <- base::inherits
[13:23:10.804]                     invokeRestart <- base::invokeRestart
[13:23:10.804]                     is.null <- base::is.null
[13:23:10.804]                     muffled <- FALSE
[13:23:10.804]                     if (inherits(cond, "message")) {
[13:23:10.804]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.804]                       if (muffled) 
[13:23:10.804]                         invokeRestart("muffleMessage")
[13:23:10.804]                     }
[13:23:10.804]                     else if (inherits(cond, "warning")) {
[13:23:10.804]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.804]                       if (muffled) 
[13:23:10.804]                         invokeRestart("muffleWarning")
[13:23:10.804]                     }
[13:23:10.804]                     else if (inherits(cond, "condition")) {
[13:23:10.804]                       if (!is.null(pattern)) {
[13:23:10.804]                         computeRestarts <- base::computeRestarts
[13:23:10.804]                         grepl <- base::grepl
[13:23:10.804]                         restarts <- computeRestarts(cond)
[13:23:10.804]                         for (restart in restarts) {
[13:23:10.804]                           name <- restart$name
[13:23:10.804]                           if (is.null(name)) 
[13:23:10.804]                             next
[13:23:10.804]                           if (!grepl(pattern, name)) 
[13:23:10.804]                             next
[13:23:10.804]                           invokeRestart(restart)
[13:23:10.804]                           muffled <- TRUE
[13:23:10.804]                           break
[13:23:10.804]                         }
[13:23:10.804]                       }
[13:23:10.804]                     }
[13:23:10.804]                     invisible(muffled)
[13:23:10.804]                   }
[13:23:10.804]                   muffleCondition(cond)
[13:23:10.804]                 })
[13:23:10.804]             }))
[13:23:10.804]             future::FutureResult(value = ...future.value$value, 
[13:23:10.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.804]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.804]                     ...future.globalenv.names))
[13:23:10.804]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.804]         }, condition = base::local({
[13:23:10.804]             c <- base::c
[13:23:10.804]             inherits <- base::inherits
[13:23:10.804]             invokeRestart <- base::invokeRestart
[13:23:10.804]             length <- base::length
[13:23:10.804]             list <- base::list
[13:23:10.804]             seq.int <- base::seq.int
[13:23:10.804]             signalCondition <- base::signalCondition
[13:23:10.804]             sys.calls <- base::sys.calls
[13:23:10.804]             `[[` <- base::`[[`
[13:23:10.804]             `+` <- base::`+`
[13:23:10.804]             `<<-` <- base::`<<-`
[13:23:10.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.804]                   3L)]
[13:23:10.804]             }
[13:23:10.804]             function(cond) {
[13:23:10.804]                 is_error <- inherits(cond, "error")
[13:23:10.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.804]                   NULL)
[13:23:10.804]                 if (is_error) {
[13:23:10.804]                   sessionInformation <- function() {
[13:23:10.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.804]                       search = base::search(), system = base::Sys.info())
[13:23:10.804]                   }
[13:23:10.804]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.804]                     cond$call), session = sessionInformation(), 
[13:23:10.804]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.804]                   signalCondition(cond)
[13:23:10.804]                 }
[13:23:10.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.804]                 "immediateCondition"))) {
[13:23:10.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.804]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.804]                   if (TRUE && !signal) {
[13:23:10.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.804]                     {
[13:23:10.804]                       inherits <- base::inherits
[13:23:10.804]                       invokeRestart <- base::invokeRestart
[13:23:10.804]                       is.null <- base::is.null
[13:23:10.804]                       muffled <- FALSE
[13:23:10.804]                       if (inherits(cond, "message")) {
[13:23:10.804]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.804]                         if (muffled) 
[13:23:10.804]                           invokeRestart("muffleMessage")
[13:23:10.804]                       }
[13:23:10.804]                       else if (inherits(cond, "warning")) {
[13:23:10.804]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.804]                         if (muffled) 
[13:23:10.804]                           invokeRestart("muffleWarning")
[13:23:10.804]                       }
[13:23:10.804]                       else if (inherits(cond, "condition")) {
[13:23:10.804]                         if (!is.null(pattern)) {
[13:23:10.804]                           computeRestarts <- base::computeRestarts
[13:23:10.804]                           grepl <- base::grepl
[13:23:10.804]                           restarts <- computeRestarts(cond)
[13:23:10.804]                           for (restart in restarts) {
[13:23:10.804]                             name <- restart$name
[13:23:10.804]                             if (is.null(name)) 
[13:23:10.804]                               next
[13:23:10.804]                             if (!grepl(pattern, name)) 
[13:23:10.804]                               next
[13:23:10.804]                             invokeRestart(restart)
[13:23:10.804]                             muffled <- TRUE
[13:23:10.804]                             break
[13:23:10.804]                           }
[13:23:10.804]                         }
[13:23:10.804]                       }
[13:23:10.804]                       invisible(muffled)
[13:23:10.804]                     }
[13:23:10.804]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.804]                   }
[13:23:10.804]                 }
[13:23:10.804]                 else {
[13:23:10.804]                   if (TRUE) {
[13:23:10.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.804]                     {
[13:23:10.804]                       inherits <- base::inherits
[13:23:10.804]                       invokeRestart <- base::invokeRestart
[13:23:10.804]                       is.null <- base::is.null
[13:23:10.804]                       muffled <- FALSE
[13:23:10.804]                       if (inherits(cond, "message")) {
[13:23:10.804]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.804]                         if (muffled) 
[13:23:10.804]                           invokeRestart("muffleMessage")
[13:23:10.804]                       }
[13:23:10.804]                       else if (inherits(cond, "warning")) {
[13:23:10.804]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.804]                         if (muffled) 
[13:23:10.804]                           invokeRestart("muffleWarning")
[13:23:10.804]                       }
[13:23:10.804]                       else if (inherits(cond, "condition")) {
[13:23:10.804]                         if (!is.null(pattern)) {
[13:23:10.804]                           computeRestarts <- base::computeRestarts
[13:23:10.804]                           grepl <- base::grepl
[13:23:10.804]                           restarts <- computeRestarts(cond)
[13:23:10.804]                           for (restart in restarts) {
[13:23:10.804]                             name <- restart$name
[13:23:10.804]                             if (is.null(name)) 
[13:23:10.804]                               next
[13:23:10.804]                             if (!grepl(pattern, name)) 
[13:23:10.804]                               next
[13:23:10.804]                             invokeRestart(restart)
[13:23:10.804]                             muffled <- TRUE
[13:23:10.804]                             break
[13:23:10.804]                           }
[13:23:10.804]                         }
[13:23:10.804]                       }
[13:23:10.804]                       invisible(muffled)
[13:23:10.804]                     }
[13:23:10.804]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.804]                   }
[13:23:10.804]                 }
[13:23:10.804]             }
[13:23:10.804]         }))
[13:23:10.804]     }, error = function(ex) {
[13:23:10.804]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.804]                 ...future.rng), started = ...future.startTime, 
[13:23:10.804]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.804]             version = "1.8"), class = "FutureResult")
[13:23:10.804]     }, finally = {
[13:23:10.804]         if (!identical(...future.workdir, getwd())) 
[13:23:10.804]             setwd(...future.workdir)
[13:23:10.804]         {
[13:23:10.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.804]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.804]             }
[13:23:10.804]             base::options(...future.oldOptions)
[13:23:10.804]             if (.Platform$OS.type == "windows") {
[13:23:10.804]                 old_names <- names(...future.oldEnvVars)
[13:23:10.804]                 envs <- base::Sys.getenv()
[13:23:10.804]                 names <- names(envs)
[13:23:10.804]                 common <- intersect(names, old_names)
[13:23:10.804]                 added <- setdiff(names, old_names)
[13:23:10.804]                 removed <- setdiff(old_names, names)
[13:23:10.804]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.804]                   envs[common]]
[13:23:10.804]                 NAMES <- toupper(changed)
[13:23:10.804]                 args <- list()
[13:23:10.804]                 for (kk in seq_along(NAMES)) {
[13:23:10.804]                   name <- changed[[kk]]
[13:23:10.804]                   NAME <- NAMES[[kk]]
[13:23:10.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.804]                     next
[13:23:10.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.804]                 }
[13:23:10.804]                 NAMES <- toupper(added)
[13:23:10.804]                 for (kk in seq_along(NAMES)) {
[13:23:10.804]                   name <- added[[kk]]
[13:23:10.804]                   NAME <- NAMES[[kk]]
[13:23:10.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.804]                     next
[13:23:10.804]                   args[[name]] <- ""
[13:23:10.804]                 }
[13:23:10.804]                 NAMES <- toupper(removed)
[13:23:10.804]                 for (kk in seq_along(NAMES)) {
[13:23:10.804]                   name <- removed[[kk]]
[13:23:10.804]                   NAME <- NAMES[[kk]]
[13:23:10.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.804]                     next
[13:23:10.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.804]                 }
[13:23:10.804]                 if (length(args) > 0) 
[13:23:10.804]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.804]             }
[13:23:10.804]             else {
[13:23:10.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.804]             }
[13:23:10.804]             {
[13:23:10.804]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.804]                   0L) {
[13:23:10.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.804]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.804]                   base::options(opts)
[13:23:10.804]                 }
[13:23:10.804]                 {
[13:23:10.804]                   {
[13:23:10.804]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.804]                     NULL
[13:23:10.804]                   }
[13:23:10.804]                   options(future.plan = NULL)
[13:23:10.804]                   if (is.na(NA_character_)) 
[13:23:10.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.804]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.804]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.804]                     envir = parent.frame()) 
[13:23:10.804]                   {
[13:23:10.804]                     if (is.function(workers)) 
[13:23:10.804]                       workers <- workers()
[13:23:10.804]                     workers <- structure(as.integer(workers), 
[13:23:10.804]                       class = class(workers))
[13:23:10.804]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.804]                       workers >= 1)
[13:23:10.804]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.804]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.804]                     }
[13:23:10.804]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.804]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.804]                       envir = envir)
[13:23:10.804]                     if (!future$lazy) 
[13:23:10.804]                       future <- run(future)
[13:23:10.804]                     invisible(future)
[13:23:10.804]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.804]                 }
[13:23:10.804]             }
[13:23:10.804]         }
[13:23:10.804]     })
[13:23:10.804]     if (TRUE) {
[13:23:10.804]         base::sink(type = "output", split = FALSE)
[13:23:10.804]         if (TRUE) {
[13:23:10.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.804]         }
[13:23:10.804]         else {
[13:23:10.804]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.804]         }
[13:23:10.804]         base::close(...future.stdout)
[13:23:10.804]         ...future.stdout <- NULL
[13:23:10.804]     }
[13:23:10.804]     ...future.result$conditions <- ...future.conditions
[13:23:10.804]     ...future.result$finished <- base::Sys.time()
[13:23:10.804]     ...future.result
[13:23:10.804] }
[13:23:10.807] MultisessionFuture started
[13:23:10.808] - Launch lazy future ... done
[13:23:10.808] run() for ‘MultisessionFuture’ ... done
[13:23:10.808] getGlobalsAndPackages() ...
[13:23:10.808] Searching for globals...
[13:23:10.809] - globals found: [1] ‘{’
[13:23:10.809] Searching for globals ... DONE
[13:23:10.809] Resolving globals: FALSE
[13:23:10.809] 
[13:23:10.810] 
[13:23:10.810] getGlobalsAndPackages() ... DONE
[13:23:10.810] run() for ‘Future’ ...
[13:23:10.810] - state: ‘created’
[13:23:10.810] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.830]   - Field: ‘node’
[13:23:10.830]   - Field: ‘label’
[13:23:10.830]   - Field: ‘local’
[13:23:10.830]   - Field: ‘owner’
[13:23:10.830]   - Field: ‘envir’
[13:23:10.830]   - Field: ‘workers’
[13:23:10.831]   - Field: ‘packages’
[13:23:10.831]   - Field: ‘gc’
[13:23:10.831]   - Field: ‘conditions’
[13:23:10.831]   - Field: ‘persistent’
[13:23:10.831]   - Field: ‘expr’
[13:23:10.831]   - Field: ‘uuid’
[13:23:10.831]   - Field: ‘seed’
[13:23:10.831]   - Field: ‘version’
[13:23:10.831]   - Field: ‘result’
[13:23:10.832]   - Field: ‘asynchronous’
[13:23:10.832]   - Field: ‘calls’
[13:23:10.832]   - Field: ‘globals’
[13:23:10.832]   - Field: ‘stdout’
[13:23:10.832]   - Field: ‘earlySignal’
[13:23:10.832]   - Field: ‘lazy’
[13:23:10.832]   - Field: ‘state’
[13:23:10.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.832] - Launch lazy future ...
[13:23:10.833] Packages needed by the future expression (n = 0): <none>
[13:23:10.833] Packages needed by future strategies (n = 0): <none>
[13:23:10.833] {
[13:23:10.833]     {
[13:23:10.833]         {
[13:23:10.833]             ...future.startTime <- base::Sys.time()
[13:23:10.833]             {
[13:23:10.833]                 {
[13:23:10.833]                   {
[13:23:10.833]                     {
[13:23:10.833]                       base::local({
[13:23:10.833]                         has_future <- base::requireNamespace("future", 
[13:23:10.833]                           quietly = TRUE)
[13:23:10.833]                         if (has_future) {
[13:23:10.833]                           ns <- base::getNamespace("future")
[13:23:10.833]                           version <- ns[[".package"]][["version"]]
[13:23:10.833]                           if (is.null(version)) 
[13:23:10.833]                             version <- utils::packageVersion("future")
[13:23:10.833]                         }
[13:23:10.833]                         else {
[13:23:10.833]                           version <- NULL
[13:23:10.833]                         }
[13:23:10.833]                         if (!has_future || version < "1.8.0") {
[13:23:10.833]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.833]                             "", base::R.version$version.string), 
[13:23:10.833]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.833]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.833]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.833]                               "release", "version")], collapse = " "), 
[13:23:10.833]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.833]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.833]                             info)
[13:23:10.833]                           info <- base::paste(info, collapse = "; ")
[13:23:10.833]                           if (!has_future) {
[13:23:10.833]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.833]                               info)
[13:23:10.833]                           }
[13:23:10.833]                           else {
[13:23:10.833]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.833]                               info, version)
[13:23:10.833]                           }
[13:23:10.833]                           base::stop(msg)
[13:23:10.833]                         }
[13:23:10.833]                       })
[13:23:10.833]                     }
[13:23:10.833]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.833]                     base::options(mc.cores = 1L)
[13:23:10.833]                   }
[13:23:10.833]                   options(future.plan = NULL)
[13:23:10.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.833]                 }
[13:23:10.833]                 ...future.workdir <- getwd()
[13:23:10.833]             }
[13:23:10.833]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.833]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.833]         }
[13:23:10.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.833]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.833]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.833]             base::names(...future.oldOptions))
[13:23:10.833]     }
[13:23:10.833]     if (FALSE) {
[13:23:10.833]     }
[13:23:10.833]     else {
[13:23:10.833]         if (TRUE) {
[13:23:10.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.833]                 open = "w")
[13:23:10.833]         }
[13:23:10.833]         else {
[13:23:10.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.833]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.833]         }
[13:23:10.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.833]             base::sink(type = "output", split = FALSE)
[13:23:10.833]             base::close(...future.stdout)
[13:23:10.833]         }, add = TRUE)
[13:23:10.833]     }
[13:23:10.833]     ...future.frame <- base::sys.nframe()
[13:23:10.833]     ...future.conditions <- base::list()
[13:23:10.833]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.833]     if (FALSE) {
[13:23:10.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.833]     }
[13:23:10.833]     ...future.result <- base::tryCatch({
[13:23:10.833]         base::withCallingHandlers({
[13:23:10.833]             ...future.value <- base::withVisible(base::local({
[13:23:10.833]                 ...future.makeSendCondition <- base::local({
[13:23:10.833]                   sendCondition <- NULL
[13:23:10.833]                   function(frame = 1L) {
[13:23:10.833]                     if (is.function(sendCondition)) 
[13:23:10.833]                       return(sendCondition)
[13:23:10.833]                     ns <- getNamespace("parallel")
[13:23:10.833]                     if (exists("sendData", mode = "function", 
[13:23:10.833]                       envir = ns)) {
[13:23:10.833]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.833]                         envir = ns)
[13:23:10.833]                       envir <- sys.frame(frame)
[13:23:10.833]                       master <- NULL
[13:23:10.833]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.833]                         !identical(envir, emptyenv())) {
[13:23:10.833]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.833]                           inherits = FALSE)) {
[13:23:10.833]                           master <- get("master", mode = "list", 
[13:23:10.833]                             envir = envir, inherits = FALSE)
[13:23:10.833]                           if (inherits(master, c("SOCKnode", 
[13:23:10.833]                             "SOCK0node"))) {
[13:23:10.833]                             sendCondition <<- function(cond) {
[13:23:10.833]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.833]                                 success = TRUE)
[13:23:10.833]                               parallel_sendData(master, data)
[13:23:10.833]                             }
[13:23:10.833]                             return(sendCondition)
[13:23:10.833]                           }
[13:23:10.833]                         }
[13:23:10.833]                         frame <- frame + 1L
[13:23:10.833]                         envir <- sys.frame(frame)
[13:23:10.833]                       }
[13:23:10.833]                     }
[13:23:10.833]                     sendCondition <<- function(cond) NULL
[13:23:10.833]                   }
[13:23:10.833]                 })
[13:23:10.833]                 withCallingHandlers({
[13:23:10.833]                   {
[13:23:10.833]                     4
[13:23:10.833]                   }
[13:23:10.833]                 }, immediateCondition = function(cond) {
[13:23:10.833]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.833]                   sendCondition(cond)
[13:23:10.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.833]                   {
[13:23:10.833]                     inherits <- base::inherits
[13:23:10.833]                     invokeRestart <- base::invokeRestart
[13:23:10.833]                     is.null <- base::is.null
[13:23:10.833]                     muffled <- FALSE
[13:23:10.833]                     if (inherits(cond, "message")) {
[13:23:10.833]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.833]                       if (muffled) 
[13:23:10.833]                         invokeRestart("muffleMessage")
[13:23:10.833]                     }
[13:23:10.833]                     else if (inherits(cond, "warning")) {
[13:23:10.833]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.833]                       if (muffled) 
[13:23:10.833]                         invokeRestart("muffleWarning")
[13:23:10.833]                     }
[13:23:10.833]                     else if (inherits(cond, "condition")) {
[13:23:10.833]                       if (!is.null(pattern)) {
[13:23:10.833]                         computeRestarts <- base::computeRestarts
[13:23:10.833]                         grepl <- base::grepl
[13:23:10.833]                         restarts <- computeRestarts(cond)
[13:23:10.833]                         for (restart in restarts) {
[13:23:10.833]                           name <- restart$name
[13:23:10.833]                           if (is.null(name)) 
[13:23:10.833]                             next
[13:23:10.833]                           if (!grepl(pattern, name)) 
[13:23:10.833]                             next
[13:23:10.833]                           invokeRestart(restart)
[13:23:10.833]                           muffled <- TRUE
[13:23:10.833]                           break
[13:23:10.833]                         }
[13:23:10.833]                       }
[13:23:10.833]                     }
[13:23:10.833]                     invisible(muffled)
[13:23:10.833]                   }
[13:23:10.833]                   muffleCondition(cond)
[13:23:10.833]                 })
[13:23:10.833]             }))
[13:23:10.833]             future::FutureResult(value = ...future.value$value, 
[13:23:10.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.833]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.833]                     ...future.globalenv.names))
[13:23:10.833]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.833]         }, condition = base::local({
[13:23:10.833]             c <- base::c
[13:23:10.833]             inherits <- base::inherits
[13:23:10.833]             invokeRestart <- base::invokeRestart
[13:23:10.833]             length <- base::length
[13:23:10.833]             list <- base::list
[13:23:10.833]             seq.int <- base::seq.int
[13:23:10.833]             signalCondition <- base::signalCondition
[13:23:10.833]             sys.calls <- base::sys.calls
[13:23:10.833]             `[[` <- base::`[[`
[13:23:10.833]             `+` <- base::`+`
[13:23:10.833]             `<<-` <- base::`<<-`
[13:23:10.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.833]                   3L)]
[13:23:10.833]             }
[13:23:10.833]             function(cond) {
[13:23:10.833]                 is_error <- inherits(cond, "error")
[13:23:10.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.833]                   NULL)
[13:23:10.833]                 if (is_error) {
[13:23:10.833]                   sessionInformation <- function() {
[13:23:10.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.833]                       search = base::search(), system = base::Sys.info())
[13:23:10.833]                   }
[13:23:10.833]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.833]                     cond$call), session = sessionInformation(), 
[13:23:10.833]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.833]                   signalCondition(cond)
[13:23:10.833]                 }
[13:23:10.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.833]                 "immediateCondition"))) {
[13:23:10.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.833]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.833]                   if (TRUE && !signal) {
[13:23:10.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.833]                     {
[13:23:10.833]                       inherits <- base::inherits
[13:23:10.833]                       invokeRestart <- base::invokeRestart
[13:23:10.833]                       is.null <- base::is.null
[13:23:10.833]                       muffled <- FALSE
[13:23:10.833]                       if (inherits(cond, "message")) {
[13:23:10.833]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.833]                         if (muffled) 
[13:23:10.833]                           invokeRestart("muffleMessage")
[13:23:10.833]                       }
[13:23:10.833]                       else if (inherits(cond, "warning")) {
[13:23:10.833]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.833]                         if (muffled) 
[13:23:10.833]                           invokeRestart("muffleWarning")
[13:23:10.833]                       }
[13:23:10.833]                       else if (inherits(cond, "condition")) {
[13:23:10.833]                         if (!is.null(pattern)) {
[13:23:10.833]                           computeRestarts <- base::computeRestarts
[13:23:10.833]                           grepl <- base::grepl
[13:23:10.833]                           restarts <- computeRestarts(cond)
[13:23:10.833]                           for (restart in restarts) {
[13:23:10.833]                             name <- restart$name
[13:23:10.833]                             if (is.null(name)) 
[13:23:10.833]                               next
[13:23:10.833]                             if (!grepl(pattern, name)) 
[13:23:10.833]                               next
[13:23:10.833]                             invokeRestart(restart)
[13:23:10.833]                             muffled <- TRUE
[13:23:10.833]                             break
[13:23:10.833]                           }
[13:23:10.833]                         }
[13:23:10.833]                       }
[13:23:10.833]                       invisible(muffled)
[13:23:10.833]                     }
[13:23:10.833]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.833]                   }
[13:23:10.833]                 }
[13:23:10.833]                 else {
[13:23:10.833]                   if (TRUE) {
[13:23:10.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.833]                     {
[13:23:10.833]                       inherits <- base::inherits
[13:23:10.833]                       invokeRestart <- base::invokeRestart
[13:23:10.833]                       is.null <- base::is.null
[13:23:10.833]                       muffled <- FALSE
[13:23:10.833]                       if (inherits(cond, "message")) {
[13:23:10.833]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.833]                         if (muffled) 
[13:23:10.833]                           invokeRestart("muffleMessage")
[13:23:10.833]                       }
[13:23:10.833]                       else if (inherits(cond, "warning")) {
[13:23:10.833]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.833]                         if (muffled) 
[13:23:10.833]                           invokeRestart("muffleWarning")
[13:23:10.833]                       }
[13:23:10.833]                       else if (inherits(cond, "condition")) {
[13:23:10.833]                         if (!is.null(pattern)) {
[13:23:10.833]                           computeRestarts <- base::computeRestarts
[13:23:10.833]                           grepl <- base::grepl
[13:23:10.833]                           restarts <- computeRestarts(cond)
[13:23:10.833]                           for (restart in restarts) {
[13:23:10.833]                             name <- restart$name
[13:23:10.833]                             if (is.null(name)) 
[13:23:10.833]                               next
[13:23:10.833]                             if (!grepl(pattern, name)) 
[13:23:10.833]                               next
[13:23:10.833]                             invokeRestart(restart)
[13:23:10.833]                             muffled <- TRUE
[13:23:10.833]                             break
[13:23:10.833]                           }
[13:23:10.833]                         }
[13:23:10.833]                       }
[13:23:10.833]                       invisible(muffled)
[13:23:10.833]                     }
[13:23:10.833]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.833]                   }
[13:23:10.833]                 }
[13:23:10.833]             }
[13:23:10.833]         }))
[13:23:10.833]     }, error = function(ex) {
[13:23:10.833]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.833]                 ...future.rng), started = ...future.startTime, 
[13:23:10.833]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.833]             version = "1.8"), class = "FutureResult")
[13:23:10.833]     }, finally = {
[13:23:10.833]         if (!identical(...future.workdir, getwd())) 
[13:23:10.833]             setwd(...future.workdir)
[13:23:10.833]         {
[13:23:10.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.833]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.833]             }
[13:23:10.833]             base::options(...future.oldOptions)
[13:23:10.833]             if (.Platform$OS.type == "windows") {
[13:23:10.833]                 old_names <- names(...future.oldEnvVars)
[13:23:10.833]                 envs <- base::Sys.getenv()
[13:23:10.833]                 names <- names(envs)
[13:23:10.833]                 common <- intersect(names, old_names)
[13:23:10.833]                 added <- setdiff(names, old_names)
[13:23:10.833]                 removed <- setdiff(old_names, names)
[13:23:10.833]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.833]                   envs[common]]
[13:23:10.833]                 NAMES <- toupper(changed)
[13:23:10.833]                 args <- list()
[13:23:10.833]                 for (kk in seq_along(NAMES)) {
[13:23:10.833]                   name <- changed[[kk]]
[13:23:10.833]                   NAME <- NAMES[[kk]]
[13:23:10.833]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.833]                     next
[13:23:10.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.833]                 }
[13:23:10.833]                 NAMES <- toupper(added)
[13:23:10.833]                 for (kk in seq_along(NAMES)) {
[13:23:10.833]                   name <- added[[kk]]
[13:23:10.833]                   NAME <- NAMES[[kk]]
[13:23:10.833]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.833]                     next
[13:23:10.833]                   args[[name]] <- ""
[13:23:10.833]                 }
[13:23:10.833]                 NAMES <- toupper(removed)
[13:23:10.833]                 for (kk in seq_along(NAMES)) {
[13:23:10.833]                   name <- removed[[kk]]
[13:23:10.833]                   NAME <- NAMES[[kk]]
[13:23:10.833]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.833]                     next
[13:23:10.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.833]                 }
[13:23:10.833]                 if (length(args) > 0) 
[13:23:10.833]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.833]             }
[13:23:10.833]             else {
[13:23:10.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.833]             }
[13:23:10.833]             {
[13:23:10.833]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.833]                   0L) {
[13:23:10.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.833]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.833]                   base::options(opts)
[13:23:10.833]                 }
[13:23:10.833]                 {
[13:23:10.833]                   {
[13:23:10.833]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.833]                     NULL
[13:23:10.833]                   }
[13:23:10.833]                   options(future.plan = NULL)
[13:23:10.833]                   if (is.na(NA_character_)) 
[13:23:10.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.833]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.833]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.833]                     envir = parent.frame()) 
[13:23:10.833]                   {
[13:23:10.833]                     if (is.function(workers)) 
[13:23:10.833]                       workers <- workers()
[13:23:10.833]                     workers <- structure(as.integer(workers), 
[13:23:10.833]                       class = class(workers))
[13:23:10.833]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.833]                       workers >= 1)
[13:23:10.833]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.833]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.833]                     }
[13:23:10.833]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.833]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.833]                       envir = envir)
[13:23:10.833]                     if (!future$lazy) 
[13:23:10.833]                       future <- run(future)
[13:23:10.833]                     invisible(future)
[13:23:10.833]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.833]                 }
[13:23:10.833]             }
[13:23:10.833]         }
[13:23:10.833]     })
[13:23:10.833]     if (TRUE) {
[13:23:10.833]         base::sink(type = "output", split = FALSE)
[13:23:10.833]         if (TRUE) {
[13:23:10.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.833]         }
[13:23:10.833]         else {
[13:23:10.833]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.833]         }
[13:23:10.833]         base::close(...future.stdout)
[13:23:10.833]         ...future.stdout <- NULL
[13:23:10.833]     }
[13:23:10.833]     ...future.result$conditions <- ...future.conditions
[13:23:10.833]     ...future.result$finished <- base::Sys.time()
[13:23:10.833]     ...future.result
[13:23:10.833] }
[13:23:10.836] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:10.847] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.847] - Validating connection of MultisessionFuture
[13:23:10.847] - received message: FutureResult
[13:23:10.847] - Received FutureResult
[13:23:10.848] - Erased future from FutureRegistry
[13:23:10.848] result() for ClusterFuture ...
[13:23:10.848] - result already collected: FutureResult
[13:23:10.848] result() for ClusterFuture ... done
[13:23:10.848] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:10.848] result() for ClusterFuture ...
[13:23:10.848] - result already collected: FutureResult
[13:23:10.848] result() for ClusterFuture ... done
[13:23:10.849] result() for ClusterFuture ...
[13:23:10.849] - result already collected: FutureResult
[13:23:10.849] result() for ClusterFuture ... done
[13:23:10.850] MultisessionFuture started
[13:23:10.850] - Launch lazy future ... done
[13:23:10.850] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d6d3b4a0> 
Classes 'listenv', 'environment' <environment: 0x5596d58079d8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[13:23:10.856] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.856] - Validating connection of MultisessionFuture
[13:23:10.856] - received message: FutureResult
[13:23:10.856] - Received FutureResult
[13:23:10.856] - Erased future from FutureRegistry
[13:23:10.856] result() for ClusterFuture ...
[13:23:10.857] - result already collected: FutureResult
[13:23:10.857] result() for ClusterFuture ... done
[13:23:10.857] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:10.870] resolve() on list environment ...
[13:23:10.870]  recursive: 0
[13:23:10.871]  length: 6
[13:23:10.871]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:10.871] signalConditionsASAP(numeric, pos=1) ...
[13:23:10.872] - nx: 6
[13:23:10.872] - relay: TRUE
[13:23:10.872] - stdout: TRUE
[13:23:10.872] - signal: TRUE
[13:23:10.872] - resignal: FALSE
[13:23:10.872] - force: TRUE
[13:23:10.872] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.872] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.872]  - until=2
[13:23:10.872]  - relaying element #2
[13:23:10.872] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.873] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.873] signalConditionsASAP(NULL, pos=1) ... done
[13:23:10.873]  length: 5 (resolved future 1)
[13:23:10.873] Future #2
[13:23:10.873] result() for ClusterFuture ...
[13:23:10.873] - result already collected: FutureResult
[13:23:10.873] result() for ClusterFuture ... done
[13:23:10.873] result() for ClusterFuture ...
[13:23:10.873] - result already collected: FutureResult
[13:23:10.874] result() for ClusterFuture ... done
[13:23:10.874] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:10.874] - nx: 6
[13:23:10.874] - relay: TRUE
[13:23:10.874] - stdout: TRUE
[13:23:10.874] - signal: TRUE
[13:23:10.874] - resignal: FALSE
[13:23:10.874] - force: TRUE
[13:23:10.874] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.874] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:10.874]  - until=2
[13:23:10.875]  - relaying element #2
[13:23:10.875] result() for ClusterFuture ...
[13:23:10.875] - result already collected: FutureResult
[13:23:10.875] result() for ClusterFuture ... done
[13:23:10.875] result() for ClusterFuture ...
[13:23:10.875] - result already collected: FutureResult
[13:23:10.875] result() for ClusterFuture ... done
[13:23:10.875] result() for ClusterFuture ...
[13:23:10.875] - result already collected: FutureResult
[13:23:10.875] result() for ClusterFuture ... done
[13:23:10.875] result() for ClusterFuture ...
[13:23:10.876] - result already collected: FutureResult
[13:23:10.876] result() for ClusterFuture ... done
[13:23:10.876] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.876] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.876] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:10.876]  length: 4 (resolved future 2)
[13:23:10.876] Future #3
[13:23:10.876] result() for ClusterFuture ...
[13:23:10.876] - result already collected: FutureResult
[13:23:10.877] result() for ClusterFuture ... done
[13:23:10.877] result() for ClusterFuture ...
[13:23:10.877] - result already collected: FutureResult
[13:23:10.877] result() for ClusterFuture ... done
[13:23:10.877] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:10.877] - nx: 6
[13:23:10.877] - relay: TRUE
[13:23:10.877] - stdout: TRUE
[13:23:10.877] - signal: TRUE
[13:23:10.877] - resignal: FALSE
[13:23:10.877] - force: TRUE
[13:23:10.878] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.878] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:10.878]  - until=3
[13:23:10.878]  - relaying element #3
[13:23:10.878] result() for ClusterFuture ...
[13:23:10.878] - result already collected: FutureResult
[13:23:10.878] result() for ClusterFuture ... done
[13:23:10.878] result() for ClusterFuture ...
[13:23:10.878] - result already collected: FutureResult
[13:23:10.878] result() for ClusterFuture ... done
[13:23:10.878] result() for ClusterFuture ...
[13:23:10.879] - result already collected: FutureResult
[13:23:10.879] result() for ClusterFuture ... done
[13:23:10.879] result() for ClusterFuture ...
[13:23:10.879] - result already collected: FutureResult
[13:23:10.879] result() for ClusterFuture ... done
[13:23:10.879] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.879] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.879] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:10.879]  length: 3 (resolved future 3)
[13:23:10.890] signalConditionsASAP(NULL, pos=5) ...
[13:23:10.890] - nx: 6
[13:23:10.890] - relay: TRUE
[13:23:10.891] - stdout: TRUE
[13:23:10.891] - signal: TRUE
[13:23:10.891] - resignal: FALSE
[13:23:10.891] - force: TRUE
[13:23:10.891] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.891] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.891]  - until=6
[13:23:10.891]  - relaying element #4
[13:23:10.891]  - relaying element #6
[13:23:10.892] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:10.892] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.892] signalConditionsASAP(NULL, pos=5) ... done
[13:23:10.892]  length: 2 (resolved future 5)
[13:23:10.892] signalConditionsASAP(numeric, pos=6) ...
[13:23:10.892] - nx: 6
[13:23:10.892] - relay: TRUE
[13:23:10.892] - stdout: TRUE
[13:23:10.892] - signal: TRUE
[13:23:10.893] - resignal: FALSE
[13:23:10.893] - force: TRUE
[13:23:10.893] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:10.893] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.893]  - until=6
[13:23:10.893]  - relaying element #4
[13:23:10.893] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:10.893] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.893] signalConditionsASAP(NULL, pos=6) ... done
[13:23:10.893]  length: 1 (resolved future 6)
[13:23:10.904] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.905] - Validating connection of MultisessionFuture
[13:23:10.905] - received message: FutureResult
[13:23:10.905] - Received FutureResult
[13:23:10.905] - Erased future from FutureRegistry
[13:23:10.905] result() for ClusterFuture ...
[13:23:10.905] - result already collected: FutureResult
[13:23:10.905] result() for ClusterFuture ... done
[13:23:10.905] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:10.905] Future #4
[13:23:10.906] result() for ClusterFuture ...
[13:23:10.906] - result already collected: FutureResult
[13:23:10.906] result() for ClusterFuture ... done
[13:23:10.906] result() for ClusterFuture ...
[13:23:10.906] - result already collected: FutureResult
[13:23:10.906] result() for ClusterFuture ... done
[13:23:10.906] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:10.906] - nx: 6
[13:23:10.906] - relay: TRUE
[13:23:10.906] - stdout: TRUE
[13:23:10.906] - signal: TRUE
[13:23:10.907] - resignal: FALSE
[13:23:10.907] - force: TRUE
[13:23:10.907] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:10.907] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:10.907]  - until=6
[13:23:10.907]  - relaying element #4
[13:23:10.907] result() for ClusterFuture ...
[13:23:10.907] - result already collected: FutureResult
[13:23:10.907] result() for ClusterFuture ... done
[13:23:10.907] result() for ClusterFuture ...
[13:23:10.907] - result already collected: FutureResult
[13:23:10.908] result() for ClusterFuture ... done
[13:23:10.908] result() for ClusterFuture ...
[13:23:10.908] - result already collected: FutureResult
[13:23:10.908] result() for ClusterFuture ... done
[13:23:10.908] result() for ClusterFuture ...
[13:23:10.908] - result already collected: FutureResult
[13:23:10.908] result() for ClusterFuture ... done
[13:23:10.908] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:10.908] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:10.908] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:10.909]  length: 0 (resolved future 4)
[13:23:10.909] Relaying remaining futures
[13:23:10.909] signalConditionsASAP(NULL, pos=0) ...
[13:23:10.909] - nx: 6
[13:23:10.909] - relay: TRUE
[13:23:10.909] - stdout: TRUE
[13:23:10.909] - signal: TRUE
[13:23:10.909] - resignal: FALSE
[13:23:10.909] - force: TRUE
[13:23:10.909] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:10.909] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:10.910] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:10.910] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:10.910] signalConditionsASAP(NULL, pos=0) ... done
[13:23:10.910] resolve() on list environment ... DONE
[13:23:10.910] result() for ClusterFuture ...
[13:23:10.910] - result already collected: FutureResult
[13:23:10.910] result() for ClusterFuture ... done
[13:23:10.910] result() for ClusterFuture ...
[13:23:10.910] - result already collected: FutureResult
[13:23:10.910] result() for ClusterFuture ... done
[13:23:10.911] result() for ClusterFuture ...
[13:23:10.911] - result already collected: FutureResult
[13:23:10.911] result() for ClusterFuture ... done
[13:23:10.911] result() for ClusterFuture ...
[13:23:10.911] - result already collected: FutureResult
[13:23:10.911] result() for ClusterFuture ... done
[13:23:10.911] result() for ClusterFuture ...
[13:23:10.911] - result already collected: FutureResult
[13:23:10.911] result() for ClusterFuture ... done
[13:23:10.912] result() for ClusterFuture ...
[13:23:10.912] - result already collected: FutureResult
[13:23:10.912] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d52d4270> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[13:23:10.914] getGlobalsAndPackages() ...
[13:23:10.914] Searching for globals...
[13:23:10.914] 
[13:23:10.914] Searching for globals ... DONE
[13:23:10.914] - globals: [0] <none>
[13:23:10.914] getGlobalsAndPackages() ... DONE
[13:23:10.915] run() for ‘Future’ ...
[13:23:10.915] - state: ‘created’
[13:23:10.915] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.930] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.930]   - Field: ‘node’
[13:23:10.930]   - Field: ‘label’
[13:23:10.930]   - Field: ‘local’
[13:23:10.930]   - Field: ‘owner’
[13:23:10.930]   - Field: ‘envir’
[13:23:10.931]   - Field: ‘workers’
[13:23:10.931]   - Field: ‘packages’
[13:23:10.931]   - Field: ‘gc’
[13:23:10.931]   - Field: ‘conditions’
[13:23:10.931]   - Field: ‘persistent’
[13:23:10.931]   - Field: ‘expr’
[13:23:10.931]   - Field: ‘uuid’
[13:23:10.931]   - Field: ‘seed’
[13:23:10.931]   - Field: ‘version’
[13:23:10.931]   - Field: ‘result’
[13:23:10.931]   - Field: ‘asynchronous’
[13:23:10.932]   - Field: ‘calls’
[13:23:10.932]   - Field: ‘globals’
[13:23:10.932]   - Field: ‘stdout’
[13:23:10.932]   - Field: ‘earlySignal’
[13:23:10.932]   - Field: ‘lazy’
[13:23:10.932]   - Field: ‘state’
[13:23:10.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.932] - Launch lazy future ...
[13:23:10.933] Packages needed by the future expression (n = 0): <none>
[13:23:10.933] Packages needed by future strategies (n = 0): <none>
[13:23:10.933] {
[13:23:10.933]     {
[13:23:10.933]         {
[13:23:10.933]             ...future.startTime <- base::Sys.time()
[13:23:10.933]             {
[13:23:10.933]                 {
[13:23:10.933]                   {
[13:23:10.933]                     {
[13:23:10.933]                       base::local({
[13:23:10.933]                         has_future <- base::requireNamespace("future", 
[13:23:10.933]                           quietly = TRUE)
[13:23:10.933]                         if (has_future) {
[13:23:10.933]                           ns <- base::getNamespace("future")
[13:23:10.933]                           version <- ns[[".package"]][["version"]]
[13:23:10.933]                           if (is.null(version)) 
[13:23:10.933]                             version <- utils::packageVersion("future")
[13:23:10.933]                         }
[13:23:10.933]                         else {
[13:23:10.933]                           version <- NULL
[13:23:10.933]                         }
[13:23:10.933]                         if (!has_future || version < "1.8.0") {
[13:23:10.933]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.933]                             "", base::R.version$version.string), 
[13:23:10.933]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.933]                               "release", "version")], collapse = " "), 
[13:23:10.933]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.933]                             info)
[13:23:10.933]                           info <- base::paste(info, collapse = "; ")
[13:23:10.933]                           if (!has_future) {
[13:23:10.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.933]                               info)
[13:23:10.933]                           }
[13:23:10.933]                           else {
[13:23:10.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.933]                               info, version)
[13:23:10.933]                           }
[13:23:10.933]                           base::stop(msg)
[13:23:10.933]                         }
[13:23:10.933]                       })
[13:23:10.933]                     }
[13:23:10.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.933]                     base::options(mc.cores = 1L)
[13:23:10.933]                   }
[13:23:10.933]                   options(future.plan = NULL)
[13:23:10.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.933]                 }
[13:23:10.933]                 ...future.workdir <- getwd()
[13:23:10.933]             }
[13:23:10.933]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.933]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.933]         }
[13:23:10.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.933]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.933]             base::names(...future.oldOptions))
[13:23:10.933]     }
[13:23:10.933]     if (FALSE) {
[13:23:10.933]     }
[13:23:10.933]     else {
[13:23:10.933]         if (TRUE) {
[13:23:10.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.933]                 open = "w")
[13:23:10.933]         }
[13:23:10.933]         else {
[13:23:10.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.933]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.933]         }
[13:23:10.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.933]             base::sink(type = "output", split = FALSE)
[13:23:10.933]             base::close(...future.stdout)
[13:23:10.933]         }, add = TRUE)
[13:23:10.933]     }
[13:23:10.933]     ...future.frame <- base::sys.nframe()
[13:23:10.933]     ...future.conditions <- base::list()
[13:23:10.933]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.933]     if (FALSE) {
[13:23:10.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.933]     }
[13:23:10.933]     ...future.result <- base::tryCatch({
[13:23:10.933]         base::withCallingHandlers({
[13:23:10.933]             ...future.value <- base::withVisible(base::local({
[13:23:10.933]                 ...future.makeSendCondition <- base::local({
[13:23:10.933]                   sendCondition <- NULL
[13:23:10.933]                   function(frame = 1L) {
[13:23:10.933]                     if (is.function(sendCondition)) 
[13:23:10.933]                       return(sendCondition)
[13:23:10.933]                     ns <- getNamespace("parallel")
[13:23:10.933]                     if (exists("sendData", mode = "function", 
[13:23:10.933]                       envir = ns)) {
[13:23:10.933]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.933]                         envir = ns)
[13:23:10.933]                       envir <- sys.frame(frame)
[13:23:10.933]                       master <- NULL
[13:23:10.933]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.933]                         !identical(envir, emptyenv())) {
[13:23:10.933]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.933]                           inherits = FALSE)) {
[13:23:10.933]                           master <- get("master", mode = "list", 
[13:23:10.933]                             envir = envir, inherits = FALSE)
[13:23:10.933]                           if (inherits(master, c("SOCKnode", 
[13:23:10.933]                             "SOCK0node"))) {
[13:23:10.933]                             sendCondition <<- function(cond) {
[13:23:10.933]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.933]                                 success = TRUE)
[13:23:10.933]                               parallel_sendData(master, data)
[13:23:10.933]                             }
[13:23:10.933]                             return(sendCondition)
[13:23:10.933]                           }
[13:23:10.933]                         }
[13:23:10.933]                         frame <- frame + 1L
[13:23:10.933]                         envir <- sys.frame(frame)
[13:23:10.933]                       }
[13:23:10.933]                     }
[13:23:10.933]                     sendCondition <<- function(cond) NULL
[13:23:10.933]                   }
[13:23:10.933]                 })
[13:23:10.933]                 withCallingHandlers({
[13:23:10.933]                   2
[13:23:10.933]                 }, immediateCondition = function(cond) {
[13:23:10.933]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.933]                   sendCondition(cond)
[13:23:10.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.933]                   {
[13:23:10.933]                     inherits <- base::inherits
[13:23:10.933]                     invokeRestart <- base::invokeRestart
[13:23:10.933]                     is.null <- base::is.null
[13:23:10.933]                     muffled <- FALSE
[13:23:10.933]                     if (inherits(cond, "message")) {
[13:23:10.933]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.933]                       if (muffled) 
[13:23:10.933]                         invokeRestart("muffleMessage")
[13:23:10.933]                     }
[13:23:10.933]                     else if (inherits(cond, "warning")) {
[13:23:10.933]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.933]                       if (muffled) 
[13:23:10.933]                         invokeRestart("muffleWarning")
[13:23:10.933]                     }
[13:23:10.933]                     else if (inherits(cond, "condition")) {
[13:23:10.933]                       if (!is.null(pattern)) {
[13:23:10.933]                         computeRestarts <- base::computeRestarts
[13:23:10.933]                         grepl <- base::grepl
[13:23:10.933]                         restarts <- computeRestarts(cond)
[13:23:10.933]                         for (restart in restarts) {
[13:23:10.933]                           name <- restart$name
[13:23:10.933]                           if (is.null(name)) 
[13:23:10.933]                             next
[13:23:10.933]                           if (!grepl(pattern, name)) 
[13:23:10.933]                             next
[13:23:10.933]                           invokeRestart(restart)
[13:23:10.933]                           muffled <- TRUE
[13:23:10.933]                           break
[13:23:10.933]                         }
[13:23:10.933]                       }
[13:23:10.933]                     }
[13:23:10.933]                     invisible(muffled)
[13:23:10.933]                   }
[13:23:10.933]                   muffleCondition(cond)
[13:23:10.933]                 })
[13:23:10.933]             }))
[13:23:10.933]             future::FutureResult(value = ...future.value$value, 
[13:23:10.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.933]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.933]                     ...future.globalenv.names))
[13:23:10.933]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.933]         }, condition = base::local({
[13:23:10.933]             c <- base::c
[13:23:10.933]             inherits <- base::inherits
[13:23:10.933]             invokeRestart <- base::invokeRestart
[13:23:10.933]             length <- base::length
[13:23:10.933]             list <- base::list
[13:23:10.933]             seq.int <- base::seq.int
[13:23:10.933]             signalCondition <- base::signalCondition
[13:23:10.933]             sys.calls <- base::sys.calls
[13:23:10.933]             `[[` <- base::`[[`
[13:23:10.933]             `+` <- base::`+`
[13:23:10.933]             `<<-` <- base::`<<-`
[13:23:10.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.933]                   3L)]
[13:23:10.933]             }
[13:23:10.933]             function(cond) {
[13:23:10.933]                 is_error <- inherits(cond, "error")
[13:23:10.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.933]                   NULL)
[13:23:10.933]                 if (is_error) {
[13:23:10.933]                   sessionInformation <- function() {
[13:23:10.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.933]                       search = base::search(), system = base::Sys.info())
[13:23:10.933]                   }
[13:23:10.933]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.933]                     cond$call), session = sessionInformation(), 
[13:23:10.933]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.933]                   signalCondition(cond)
[13:23:10.933]                 }
[13:23:10.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.933]                 "immediateCondition"))) {
[13:23:10.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.933]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.933]                   if (TRUE && !signal) {
[13:23:10.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.933]                     {
[13:23:10.933]                       inherits <- base::inherits
[13:23:10.933]                       invokeRestart <- base::invokeRestart
[13:23:10.933]                       is.null <- base::is.null
[13:23:10.933]                       muffled <- FALSE
[13:23:10.933]                       if (inherits(cond, "message")) {
[13:23:10.933]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.933]                         if (muffled) 
[13:23:10.933]                           invokeRestart("muffleMessage")
[13:23:10.933]                       }
[13:23:10.933]                       else if (inherits(cond, "warning")) {
[13:23:10.933]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.933]                         if (muffled) 
[13:23:10.933]                           invokeRestart("muffleWarning")
[13:23:10.933]                       }
[13:23:10.933]                       else if (inherits(cond, "condition")) {
[13:23:10.933]                         if (!is.null(pattern)) {
[13:23:10.933]                           computeRestarts <- base::computeRestarts
[13:23:10.933]                           grepl <- base::grepl
[13:23:10.933]                           restarts <- computeRestarts(cond)
[13:23:10.933]                           for (restart in restarts) {
[13:23:10.933]                             name <- restart$name
[13:23:10.933]                             if (is.null(name)) 
[13:23:10.933]                               next
[13:23:10.933]                             if (!grepl(pattern, name)) 
[13:23:10.933]                               next
[13:23:10.933]                             invokeRestart(restart)
[13:23:10.933]                             muffled <- TRUE
[13:23:10.933]                             break
[13:23:10.933]                           }
[13:23:10.933]                         }
[13:23:10.933]                       }
[13:23:10.933]                       invisible(muffled)
[13:23:10.933]                     }
[13:23:10.933]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.933]                   }
[13:23:10.933]                 }
[13:23:10.933]                 else {
[13:23:10.933]                   if (TRUE) {
[13:23:10.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.933]                     {
[13:23:10.933]                       inherits <- base::inherits
[13:23:10.933]                       invokeRestart <- base::invokeRestart
[13:23:10.933]                       is.null <- base::is.null
[13:23:10.933]                       muffled <- FALSE
[13:23:10.933]                       if (inherits(cond, "message")) {
[13:23:10.933]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.933]                         if (muffled) 
[13:23:10.933]                           invokeRestart("muffleMessage")
[13:23:10.933]                       }
[13:23:10.933]                       else if (inherits(cond, "warning")) {
[13:23:10.933]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.933]                         if (muffled) 
[13:23:10.933]                           invokeRestart("muffleWarning")
[13:23:10.933]                       }
[13:23:10.933]                       else if (inherits(cond, "condition")) {
[13:23:10.933]                         if (!is.null(pattern)) {
[13:23:10.933]                           computeRestarts <- base::computeRestarts
[13:23:10.933]                           grepl <- base::grepl
[13:23:10.933]                           restarts <- computeRestarts(cond)
[13:23:10.933]                           for (restart in restarts) {
[13:23:10.933]                             name <- restart$name
[13:23:10.933]                             if (is.null(name)) 
[13:23:10.933]                               next
[13:23:10.933]                             if (!grepl(pattern, name)) 
[13:23:10.933]                               next
[13:23:10.933]                             invokeRestart(restart)
[13:23:10.933]                             muffled <- TRUE
[13:23:10.933]                             break
[13:23:10.933]                           }
[13:23:10.933]                         }
[13:23:10.933]                       }
[13:23:10.933]                       invisible(muffled)
[13:23:10.933]                     }
[13:23:10.933]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.933]                   }
[13:23:10.933]                 }
[13:23:10.933]             }
[13:23:10.933]         }))
[13:23:10.933]     }, error = function(ex) {
[13:23:10.933]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.933]                 ...future.rng), started = ...future.startTime, 
[13:23:10.933]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.933]             version = "1.8"), class = "FutureResult")
[13:23:10.933]     }, finally = {
[13:23:10.933]         if (!identical(...future.workdir, getwd())) 
[13:23:10.933]             setwd(...future.workdir)
[13:23:10.933]         {
[13:23:10.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.933]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.933]             }
[13:23:10.933]             base::options(...future.oldOptions)
[13:23:10.933]             if (.Platform$OS.type == "windows") {
[13:23:10.933]                 old_names <- names(...future.oldEnvVars)
[13:23:10.933]                 envs <- base::Sys.getenv()
[13:23:10.933]                 names <- names(envs)
[13:23:10.933]                 common <- intersect(names, old_names)
[13:23:10.933]                 added <- setdiff(names, old_names)
[13:23:10.933]                 removed <- setdiff(old_names, names)
[13:23:10.933]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.933]                   envs[common]]
[13:23:10.933]                 NAMES <- toupper(changed)
[13:23:10.933]                 args <- list()
[13:23:10.933]                 for (kk in seq_along(NAMES)) {
[13:23:10.933]                   name <- changed[[kk]]
[13:23:10.933]                   NAME <- NAMES[[kk]]
[13:23:10.933]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.933]                     next
[13:23:10.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.933]                 }
[13:23:10.933]                 NAMES <- toupper(added)
[13:23:10.933]                 for (kk in seq_along(NAMES)) {
[13:23:10.933]                   name <- added[[kk]]
[13:23:10.933]                   NAME <- NAMES[[kk]]
[13:23:10.933]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.933]                     next
[13:23:10.933]                   args[[name]] <- ""
[13:23:10.933]                 }
[13:23:10.933]                 NAMES <- toupper(removed)
[13:23:10.933]                 for (kk in seq_along(NAMES)) {
[13:23:10.933]                   name <- removed[[kk]]
[13:23:10.933]                   NAME <- NAMES[[kk]]
[13:23:10.933]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.933]                     next
[13:23:10.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.933]                 }
[13:23:10.933]                 if (length(args) > 0) 
[13:23:10.933]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.933]             }
[13:23:10.933]             else {
[13:23:10.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.933]             }
[13:23:10.933]             {
[13:23:10.933]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.933]                   0L) {
[13:23:10.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.933]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.933]                   base::options(opts)
[13:23:10.933]                 }
[13:23:10.933]                 {
[13:23:10.933]                   {
[13:23:10.933]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.933]                     NULL
[13:23:10.933]                   }
[13:23:10.933]                   options(future.plan = NULL)
[13:23:10.933]                   if (is.na(NA_character_)) 
[13:23:10.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.933]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.933]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.933]                     envir = parent.frame()) 
[13:23:10.933]                   {
[13:23:10.933]                     if (is.function(workers)) 
[13:23:10.933]                       workers <- workers()
[13:23:10.933]                     workers <- structure(as.integer(workers), 
[13:23:10.933]                       class = class(workers))
[13:23:10.933]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.933]                       workers >= 1)
[13:23:10.933]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.933]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.933]                     }
[13:23:10.933]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.933]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.933]                       envir = envir)
[13:23:10.933]                     if (!future$lazy) 
[13:23:10.933]                       future <- run(future)
[13:23:10.933]                     invisible(future)
[13:23:10.933]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.933]                 }
[13:23:10.933]             }
[13:23:10.933]         }
[13:23:10.933]     })
[13:23:10.933]     if (TRUE) {
[13:23:10.933]         base::sink(type = "output", split = FALSE)
[13:23:10.933]         if (TRUE) {
[13:23:10.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.933]         }
[13:23:10.933]         else {
[13:23:10.933]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.933]         }
[13:23:10.933]         base::close(...future.stdout)
[13:23:10.933]         ...future.stdout <- NULL
[13:23:10.933]     }
[13:23:10.933]     ...future.result$conditions <- ...future.conditions
[13:23:10.933]     ...future.result$finished <- base::Sys.time()
[13:23:10.933]     ...future.result
[13:23:10.933] }
[13:23:10.937] MultisessionFuture started
[13:23:10.937] - Launch lazy future ... done
[13:23:10.937] run() for ‘MultisessionFuture’ ... done
[13:23:10.937] getGlobalsAndPackages() ...
[13:23:10.937] Searching for globals...
[13:23:10.938] 
[13:23:10.938] Searching for globals ... DONE
[13:23:10.938] - globals: [0] <none>
[13:23:10.938] getGlobalsAndPackages() ... DONE
[13:23:10.938] run() for ‘Future’ ...
[13:23:10.938] - state: ‘created’
[13:23:10.938] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.953] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.954]   - Field: ‘node’
[13:23:10.954]   - Field: ‘label’
[13:23:10.954]   - Field: ‘local’
[13:23:10.954]   - Field: ‘owner’
[13:23:10.954]   - Field: ‘envir’
[13:23:10.954]   - Field: ‘workers’
[13:23:10.954]   - Field: ‘packages’
[13:23:10.954]   - Field: ‘gc’
[13:23:10.955]   - Field: ‘conditions’
[13:23:10.955]   - Field: ‘persistent’
[13:23:10.955]   - Field: ‘expr’
[13:23:10.955]   - Field: ‘uuid’
[13:23:10.955]   - Field: ‘seed’
[13:23:10.955]   - Field: ‘version’
[13:23:10.955]   - Field: ‘result’
[13:23:10.955]   - Field: ‘asynchronous’
[13:23:10.955]   - Field: ‘calls’
[13:23:10.955]   - Field: ‘globals’
[13:23:10.956]   - Field: ‘stdout’
[13:23:10.956]   - Field: ‘earlySignal’
[13:23:10.956]   - Field: ‘lazy’
[13:23:10.956]   - Field: ‘state’
[13:23:10.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.956] - Launch lazy future ...
[13:23:10.956] Packages needed by the future expression (n = 0): <none>
[13:23:10.957] Packages needed by future strategies (n = 0): <none>
[13:23:10.957] {
[13:23:10.957]     {
[13:23:10.957]         {
[13:23:10.957]             ...future.startTime <- base::Sys.time()
[13:23:10.957]             {
[13:23:10.957]                 {
[13:23:10.957]                   {
[13:23:10.957]                     {
[13:23:10.957]                       base::local({
[13:23:10.957]                         has_future <- base::requireNamespace("future", 
[13:23:10.957]                           quietly = TRUE)
[13:23:10.957]                         if (has_future) {
[13:23:10.957]                           ns <- base::getNamespace("future")
[13:23:10.957]                           version <- ns[[".package"]][["version"]]
[13:23:10.957]                           if (is.null(version)) 
[13:23:10.957]                             version <- utils::packageVersion("future")
[13:23:10.957]                         }
[13:23:10.957]                         else {
[13:23:10.957]                           version <- NULL
[13:23:10.957]                         }
[13:23:10.957]                         if (!has_future || version < "1.8.0") {
[13:23:10.957]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.957]                             "", base::R.version$version.string), 
[13:23:10.957]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.957]                               "release", "version")], collapse = " "), 
[13:23:10.957]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.957]                             info)
[13:23:10.957]                           info <- base::paste(info, collapse = "; ")
[13:23:10.957]                           if (!has_future) {
[13:23:10.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.957]                               info)
[13:23:10.957]                           }
[13:23:10.957]                           else {
[13:23:10.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.957]                               info, version)
[13:23:10.957]                           }
[13:23:10.957]                           base::stop(msg)
[13:23:10.957]                         }
[13:23:10.957]                       })
[13:23:10.957]                     }
[13:23:10.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.957]                     base::options(mc.cores = 1L)
[13:23:10.957]                   }
[13:23:10.957]                   options(future.plan = NULL)
[13:23:10.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.957]                 }
[13:23:10.957]                 ...future.workdir <- getwd()
[13:23:10.957]             }
[13:23:10.957]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.957]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.957]         }
[13:23:10.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.957]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.957]             base::names(...future.oldOptions))
[13:23:10.957]     }
[13:23:10.957]     if (FALSE) {
[13:23:10.957]     }
[13:23:10.957]     else {
[13:23:10.957]         if (TRUE) {
[13:23:10.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.957]                 open = "w")
[13:23:10.957]         }
[13:23:10.957]         else {
[13:23:10.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.957]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.957]         }
[13:23:10.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.957]             base::sink(type = "output", split = FALSE)
[13:23:10.957]             base::close(...future.stdout)
[13:23:10.957]         }, add = TRUE)
[13:23:10.957]     }
[13:23:10.957]     ...future.frame <- base::sys.nframe()
[13:23:10.957]     ...future.conditions <- base::list()
[13:23:10.957]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.957]     if (FALSE) {
[13:23:10.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.957]     }
[13:23:10.957]     ...future.result <- base::tryCatch({
[13:23:10.957]         base::withCallingHandlers({
[13:23:10.957]             ...future.value <- base::withVisible(base::local({
[13:23:10.957]                 ...future.makeSendCondition <- base::local({
[13:23:10.957]                   sendCondition <- NULL
[13:23:10.957]                   function(frame = 1L) {
[13:23:10.957]                     if (is.function(sendCondition)) 
[13:23:10.957]                       return(sendCondition)
[13:23:10.957]                     ns <- getNamespace("parallel")
[13:23:10.957]                     if (exists("sendData", mode = "function", 
[13:23:10.957]                       envir = ns)) {
[13:23:10.957]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.957]                         envir = ns)
[13:23:10.957]                       envir <- sys.frame(frame)
[13:23:10.957]                       master <- NULL
[13:23:10.957]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.957]                         !identical(envir, emptyenv())) {
[13:23:10.957]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.957]                           inherits = FALSE)) {
[13:23:10.957]                           master <- get("master", mode = "list", 
[13:23:10.957]                             envir = envir, inherits = FALSE)
[13:23:10.957]                           if (inherits(master, c("SOCKnode", 
[13:23:10.957]                             "SOCK0node"))) {
[13:23:10.957]                             sendCondition <<- function(cond) {
[13:23:10.957]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.957]                                 success = TRUE)
[13:23:10.957]                               parallel_sendData(master, data)
[13:23:10.957]                             }
[13:23:10.957]                             return(sendCondition)
[13:23:10.957]                           }
[13:23:10.957]                         }
[13:23:10.957]                         frame <- frame + 1L
[13:23:10.957]                         envir <- sys.frame(frame)
[13:23:10.957]                       }
[13:23:10.957]                     }
[13:23:10.957]                     sendCondition <<- function(cond) NULL
[13:23:10.957]                   }
[13:23:10.957]                 })
[13:23:10.957]                 withCallingHandlers({
[13:23:10.957]                   NULL
[13:23:10.957]                 }, immediateCondition = function(cond) {
[13:23:10.957]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.957]                   sendCondition(cond)
[13:23:10.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.957]                   {
[13:23:10.957]                     inherits <- base::inherits
[13:23:10.957]                     invokeRestart <- base::invokeRestart
[13:23:10.957]                     is.null <- base::is.null
[13:23:10.957]                     muffled <- FALSE
[13:23:10.957]                     if (inherits(cond, "message")) {
[13:23:10.957]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.957]                       if (muffled) 
[13:23:10.957]                         invokeRestart("muffleMessage")
[13:23:10.957]                     }
[13:23:10.957]                     else if (inherits(cond, "warning")) {
[13:23:10.957]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.957]                       if (muffled) 
[13:23:10.957]                         invokeRestart("muffleWarning")
[13:23:10.957]                     }
[13:23:10.957]                     else if (inherits(cond, "condition")) {
[13:23:10.957]                       if (!is.null(pattern)) {
[13:23:10.957]                         computeRestarts <- base::computeRestarts
[13:23:10.957]                         grepl <- base::grepl
[13:23:10.957]                         restarts <- computeRestarts(cond)
[13:23:10.957]                         for (restart in restarts) {
[13:23:10.957]                           name <- restart$name
[13:23:10.957]                           if (is.null(name)) 
[13:23:10.957]                             next
[13:23:10.957]                           if (!grepl(pattern, name)) 
[13:23:10.957]                             next
[13:23:10.957]                           invokeRestart(restart)
[13:23:10.957]                           muffled <- TRUE
[13:23:10.957]                           break
[13:23:10.957]                         }
[13:23:10.957]                       }
[13:23:10.957]                     }
[13:23:10.957]                     invisible(muffled)
[13:23:10.957]                   }
[13:23:10.957]                   muffleCondition(cond)
[13:23:10.957]                 })
[13:23:10.957]             }))
[13:23:10.957]             future::FutureResult(value = ...future.value$value, 
[13:23:10.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.957]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.957]                     ...future.globalenv.names))
[13:23:10.957]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.957]         }, condition = base::local({
[13:23:10.957]             c <- base::c
[13:23:10.957]             inherits <- base::inherits
[13:23:10.957]             invokeRestart <- base::invokeRestart
[13:23:10.957]             length <- base::length
[13:23:10.957]             list <- base::list
[13:23:10.957]             seq.int <- base::seq.int
[13:23:10.957]             signalCondition <- base::signalCondition
[13:23:10.957]             sys.calls <- base::sys.calls
[13:23:10.957]             `[[` <- base::`[[`
[13:23:10.957]             `+` <- base::`+`
[13:23:10.957]             `<<-` <- base::`<<-`
[13:23:10.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.957]                   3L)]
[13:23:10.957]             }
[13:23:10.957]             function(cond) {
[13:23:10.957]                 is_error <- inherits(cond, "error")
[13:23:10.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.957]                   NULL)
[13:23:10.957]                 if (is_error) {
[13:23:10.957]                   sessionInformation <- function() {
[13:23:10.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.957]                       search = base::search(), system = base::Sys.info())
[13:23:10.957]                   }
[13:23:10.957]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.957]                     cond$call), session = sessionInformation(), 
[13:23:10.957]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.957]                   signalCondition(cond)
[13:23:10.957]                 }
[13:23:10.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.957]                 "immediateCondition"))) {
[13:23:10.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.957]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.957]                   if (TRUE && !signal) {
[13:23:10.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.957]                     {
[13:23:10.957]                       inherits <- base::inherits
[13:23:10.957]                       invokeRestart <- base::invokeRestart
[13:23:10.957]                       is.null <- base::is.null
[13:23:10.957]                       muffled <- FALSE
[13:23:10.957]                       if (inherits(cond, "message")) {
[13:23:10.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.957]                         if (muffled) 
[13:23:10.957]                           invokeRestart("muffleMessage")
[13:23:10.957]                       }
[13:23:10.957]                       else if (inherits(cond, "warning")) {
[13:23:10.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.957]                         if (muffled) 
[13:23:10.957]                           invokeRestart("muffleWarning")
[13:23:10.957]                       }
[13:23:10.957]                       else if (inherits(cond, "condition")) {
[13:23:10.957]                         if (!is.null(pattern)) {
[13:23:10.957]                           computeRestarts <- base::computeRestarts
[13:23:10.957]                           grepl <- base::grepl
[13:23:10.957]                           restarts <- computeRestarts(cond)
[13:23:10.957]                           for (restart in restarts) {
[13:23:10.957]                             name <- restart$name
[13:23:10.957]                             if (is.null(name)) 
[13:23:10.957]                               next
[13:23:10.957]                             if (!grepl(pattern, name)) 
[13:23:10.957]                               next
[13:23:10.957]                             invokeRestart(restart)
[13:23:10.957]                             muffled <- TRUE
[13:23:10.957]                             break
[13:23:10.957]                           }
[13:23:10.957]                         }
[13:23:10.957]                       }
[13:23:10.957]                       invisible(muffled)
[13:23:10.957]                     }
[13:23:10.957]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.957]                   }
[13:23:10.957]                 }
[13:23:10.957]                 else {
[13:23:10.957]                   if (TRUE) {
[13:23:10.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.957]                     {
[13:23:10.957]                       inherits <- base::inherits
[13:23:10.957]                       invokeRestart <- base::invokeRestart
[13:23:10.957]                       is.null <- base::is.null
[13:23:10.957]                       muffled <- FALSE
[13:23:10.957]                       if (inherits(cond, "message")) {
[13:23:10.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.957]                         if (muffled) 
[13:23:10.957]                           invokeRestart("muffleMessage")
[13:23:10.957]                       }
[13:23:10.957]                       else if (inherits(cond, "warning")) {
[13:23:10.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.957]                         if (muffled) 
[13:23:10.957]                           invokeRestart("muffleWarning")
[13:23:10.957]                       }
[13:23:10.957]                       else if (inherits(cond, "condition")) {
[13:23:10.957]                         if (!is.null(pattern)) {
[13:23:10.957]                           computeRestarts <- base::computeRestarts
[13:23:10.957]                           grepl <- base::grepl
[13:23:10.957]                           restarts <- computeRestarts(cond)
[13:23:10.957]                           for (restart in restarts) {
[13:23:10.957]                             name <- restart$name
[13:23:10.957]                             if (is.null(name)) 
[13:23:10.957]                               next
[13:23:10.957]                             if (!grepl(pattern, name)) 
[13:23:10.957]                               next
[13:23:10.957]                             invokeRestart(restart)
[13:23:10.957]                             muffled <- TRUE
[13:23:10.957]                             break
[13:23:10.957]                           }
[13:23:10.957]                         }
[13:23:10.957]                       }
[13:23:10.957]                       invisible(muffled)
[13:23:10.957]                     }
[13:23:10.957]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.957]                   }
[13:23:10.957]                 }
[13:23:10.957]             }
[13:23:10.957]         }))
[13:23:10.957]     }, error = function(ex) {
[13:23:10.957]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.957]                 ...future.rng), started = ...future.startTime, 
[13:23:10.957]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.957]             version = "1.8"), class = "FutureResult")
[13:23:10.957]     }, finally = {
[13:23:10.957]         if (!identical(...future.workdir, getwd())) 
[13:23:10.957]             setwd(...future.workdir)
[13:23:10.957]         {
[13:23:10.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.957]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.957]             }
[13:23:10.957]             base::options(...future.oldOptions)
[13:23:10.957]             if (.Platform$OS.type == "windows") {
[13:23:10.957]                 old_names <- names(...future.oldEnvVars)
[13:23:10.957]                 envs <- base::Sys.getenv()
[13:23:10.957]                 names <- names(envs)
[13:23:10.957]                 common <- intersect(names, old_names)
[13:23:10.957]                 added <- setdiff(names, old_names)
[13:23:10.957]                 removed <- setdiff(old_names, names)
[13:23:10.957]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.957]                   envs[common]]
[13:23:10.957]                 NAMES <- toupper(changed)
[13:23:10.957]                 args <- list()
[13:23:10.957]                 for (kk in seq_along(NAMES)) {
[13:23:10.957]                   name <- changed[[kk]]
[13:23:10.957]                   NAME <- NAMES[[kk]]
[13:23:10.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.957]                     next
[13:23:10.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.957]                 }
[13:23:10.957]                 NAMES <- toupper(added)
[13:23:10.957]                 for (kk in seq_along(NAMES)) {
[13:23:10.957]                   name <- added[[kk]]
[13:23:10.957]                   NAME <- NAMES[[kk]]
[13:23:10.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.957]                     next
[13:23:10.957]                   args[[name]] <- ""
[13:23:10.957]                 }
[13:23:10.957]                 NAMES <- toupper(removed)
[13:23:10.957]                 for (kk in seq_along(NAMES)) {
[13:23:10.957]                   name <- removed[[kk]]
[13:23:10.957]                   NAME <- NAMES[[kk]]
[13:23:10.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.957]                     next
[13:23:10.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.957]                 }
[13:23:10.957]                 if (length(args) > 0) 
[13:23:10.957]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.957]             }
[13:23:10.957]             else {
[13:23:10.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.957]             }
[13:23:10.957]             {
[13:23:10.957]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.957]                   0L) {
[13:23:10.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.957]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.957]                   base::options(opts)
[13:23:10.957]                 }
[13:23:10.957]                 {
[13:23:10.957]                   {
[13:23:10.957]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.957]                     NULL
[13:23:10.957]                   }
[13:23:10.957]                   options(future.plan = NULL)
[13:23:10.957]                   if (is.na(NA_character_)) 
[13:23:10.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.957]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.957]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.957]                     envir = parent.frame()) 
[13:23:10.957]                   {
[13:23:10.957]                     if (is.function(workers)) 
[13:23:10.957]                       workers <- workers()
[13:23:10.957]                     workers <- structure(as.integer(workers), 
[13:23:10.957]                       class = class(workers))
[13:23:10.957]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.957]                       workers >= 1)
[13:23:10.957]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.957]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.957]                     }
[13:23:10.957]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.957]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.957]                       envir = envir)
[13:23:10.957]                     if (!future$lazy) 
[13:23:10.957]                       future <- run(future)
[13:23:10.957]                     invisible(future)
[13:23:10.957]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.957]                 }
[13:23:10.957]             }
[13:23:10.957]         }
[13:23:10.957]     })
[13:23:10.957]     if (TRUE) {
[13:23:10.957]         base::sink(type = "output", split = FALSE)
[13:23:10.957]         if (TRUE) {
[13:23:10.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.957]         }
[13:23:10.957]         else {
[13:23:10.957]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.957]         }
[13:23:10.957]         base::close(...future.stdout)
[13:23:10.957]         ...future.stdout <- NULL
[13:23:10.957]     }
[13:23:10.957]     ...future.result$conditions <- ...future.conditions
[13:23:10.957]     ...future.result$finished <- base::Sys.time()
[13:23:10.957]     ...future.result
[13:23:10.957] }
[13:23:10.961] MultisessionFuture started
[13:23:10.961] - Launch lazy future ... done
[13:23:10.961] run() for ‘MultisessionFuture’ ... done
[13:23:10.961] getGlobalsAndPackages() ...
[13:23:10.962] Searching for globals...
[13:23:10.962] - globals found: [1] ‘{’
[13:23:10.962] Searching for globals ... DONE
[13:23:10.962] Resolving globals: FALSE
[13:23:10.963] 
[13:23:10.963] 
[13:23:10.963] getGlobalsAndPackages() ... DONE
[13:23:10.963] run() for ‘Future’ ...
[13:23:10.963] - state: ‘created’
[13:23:10.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:10.978] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:10.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:10.978]   - Field: ‘node’
[13:23:10.979]   - Field: ‘label’
[13:23:10.979]   - Field: ‘local’
[13:23:10.979]   - Field: ‘owner’
[13:23:10.979]   - Field: ‘envir’
[13:23:10.979]   - Field: ‘workers’
[13:23:10.979]   - Field: ‘packages’
[13:23:10.979]   - Field: ‘gc’
[13:23:10.979]   - Field: ‘conditions’
[13:23:10.979]   - Field: ‘persistent’
[13:23:10.979]   - Field: ‘expr’
[13:23:10.979]   - Field: ‘uuid’
[13:23:10.980]   - Field: ‘seed’
[13:23:10.980]   - Field: ‘version’
[13:23:10.980]   - Field: ‘result’
[13:23:10.980]   - Field: ‘asynchronous’
[13:23:10.980]   - Field: ‘calls’
[13:23:10.980]   - Field: ‘globals’
[13:23:10.980]   - Field: ‘stdout’
[13:23:10.980]   - Field: ‘earlySignal’
[13:23:10.981]   - Field: ‘lazy’
[13:23:10.981]   - Field: ‘state’
[13:23:10.981] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:10.981] - Launch lazy future ...
[13:23:10.981] Packages needed by the future expression (n = 0): <none>
[13:23:10.981] Packages needed by future strategies (n = 0): <none>
[13:23:10.982] {
[13:23:10.982]     {
[13:23:10.982]         {
[13:23:10.982]             ...future.startTime <- base::Sys.time()
[13:23:10.982]             {
[13:23:10.982]                 {
[13:23:10.982]                   {
[13:23:10.982]                     {
[13:23:10.982]                       base::local({
[13:23:10.982]                         has_future <- base::requireNamespace("future", 
[13:23:10.982]                           quietly = TRUE)
[13:23:10.982]                         if (has_future) {
[13:23:10.982]                           ns <- base::getNamespace("future")
[13:23:10.982]                           version <- ns[[".package"]][["version"]]
[13:23:10.982]                           if (is.null(version)) 
[13:23:10.982]                             version <- utils::packageVersion("future")
[13:23:10.982]                         }
[13:23:10.982]                         else {
[13:23:10.982]                           version <- NULL
[13:23:10.982]                         }
[13:23:10.982]                         if (!has_future || version < "1.8.0") {
[13:23:10.982]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:10.982]                             "", base::R.version$version.string), 
[13:23:10.982]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:10.982]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:10.982]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:10.982]                               "release", "version")], collapse = " "), 
[13:23:10.982]                             hostname = base::Sys.info()[["nodename"]])
[13:23:10.982]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:10.982]                             info)
[13:23:10.982]                           info <- base::paste(info, collapse = "; ")
[13:23:10.982]                           if (!has_future) {
[13:23:10.982]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:10.982]                               info)
[13:23:10.982]                           }
[13:23:10.982]                           else {
[13:23:10.982]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:10.982]                               info, version)
[13:23:10.982]                           }
[13:23:10.982]                           base::stop(msg)
[13:23:10.982]                         }
[13:23:10.982]                       })
[13:23:10.982]                     }
[13:23:10.982]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:10.982]                     base::options(mc.cores = 1L)
[13:23:10.982]                   }
[13:23:10.982]                   options(future.plan = NULL)
[13:23:10.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:10.982]                 }
[13:23:10.982]                 ...future.workdir <- getwd()
[13:23:10.982]             }
[13:23:10.982]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:10.982]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:10.982]         }
[13:23:10.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:10.982]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:10.982]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:10.982]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:10.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:10.982]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:10.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:10.982]             base::names(...future.oldOptions))
[13:23:10.982]     }
[13:23:10.982]     if (FALSE) {
[13:23:10.982]     }
[13:23:10.982]     else {
[13:23:10.982]         if (TRUE) {
[13:23:10.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:10.982]                 open = "w")
[13:23:10.982]         }
[13:23:10.982]         else {
[13:23:10.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:10.982]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:10.982]         }
[13:23:10.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:10.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:10.982]             base::sink(type = "output", split = FALSE)
[13:23:10.982]             base::close(...future.stdout)
[13:23:10.982]         }, add = TRUE)
[13:23:10.982]     }
[13:23:10.982]     ...future.frame <- base::sys.nframe()
[13:23:10.982]     ...future.conditions <- base::list()
[13:23:10.982]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:10.982]     if (FALSE) {
[13:23:10.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:10.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:10.982]     }
[13:23:10.982]     ...future.result <- base::tryCatch({
[13:23:10.982]         base::withCallingHandlers({
[13:23:10.982]             ...future.value <- base::withVisible(base::local({
[13:23:10.982]                 ...future.makeSendCondition <- base::local({
[13:23:10.982]                   sendCondition <- NULL
[13:23:10.982]                   function(frame = 1L) {
[13:23:10.982]                     if (is.function(sendCondition)) 
[13:23:10.982]                       return(sendCondition)
[13:23:10.982]                     ns <- getNamespace("parallel")
[13:23:10.982]                     if (exists("sendData", mode = "function", 
[13:23:10.982]                       envir = ns)) {
[13:23:10.982]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:10.982]                         envir = ns)
[13:23:10.982]                       envir <- sys.frame(frame)
[13:23:10.982]                       master <- NULL
[13:23:10.982]                       while (!identical(envir, .GlobalEnv) && 
[13:23:10.982]                         !identical(envir, emptyenv())) {
[13:23:10.982]                         if (exists("master", mode = "list", envir = envir, 
[13:23:10.982]                           inherits = FALSE)) {
[13:23:10.982]                           master <- get("master", mode = "list", 
[13:23:10.982]                             envir = envir, inherits = FALSE)
[13:23:10.982]                           if (inherits(master, c("SOCKnode", 
[13:23:10.982]                             "SOCK0node"))) {
[13:23:10.982]                             sendCondition <<- function(cond) {
[13:23:10.982]                               data <- list(type = "VALUE", value = cond, 
[13:23:10.982]                                 success = TRUE)
[13:23:10.982]                               parallel_sendData(master, data)
[13:23:10.982]                             }
[13:23:10.982]                             return(sendCondition)
[13:23:10.982]                           }
[13:23:10.982]                         }
[13:23:10.982]                         frame <- frame + 1L
[13:23:10.982]                         envir <- sys.frame(frame)
[13:23:10.982]                       }
[13:23:10.982]                     }
[13:23:10.982]                     sendCondition <<- function(cond) NULL
[13:23:10.982]                   }
[13:23:10.982]                 })
[13:23:10.982]                 withCallingHandlers({
[13:23:10.982]                   {
[13:23:10.982]                     4
[13:23:10.982]                   }
[13:23:10.982]                 }, immediateCondition = function(cond) {
[13:23:10.982]                   sendCondition <- ...future.makeSendCondition()
[13:23:10.982]                   sendCondition(cond)
[13:23:10.982]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.982]                   {
[13:23:10.982]                     inherits <- base::inherits
[13:23:10.982]                     invokeRestart <- base::invokeRestart
[13:23:10.982]                     is.null <- base::is.null
[13:23:10.982]                     muffled <- FALSE
[13:23:10.982]                     if (inherits(cond, "message")) {
[13:23:10.982]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:10.982]                       if (muffled) 
[13:23:10.982]                         invokeRestart("muffleMessage")
[13:23:10.982]                     }
[13:23:10.982]                     else if (inherits(cond, "warning")) {
[13:23:10.982]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:10.982]                       if (muffled) 
[13:23:10.982]                         invokeRestart("muffleWarning")
[13:23:10.982]                     }
[13:23:10.982]                     else if (inherits(cond, "condition")) {
[13:23:10.982]                       if (!is.null(pattern)) {
[13:23:10.982]                         computeRestarts <- base::computeRestarts
[13:23:10.982]                         grepl <- base::grepl
[13:23:10.982]                         restarts <- computeRestarts(cond)
[13:23:10.982]                         for (restart in restarts) {
[13:23:10.982]                           name <- restart$name
[13:23:10.982]                           if (is.null(name)) 
[13:23:10.982]                             next
[13:23:10.982]                           if (!grepl(pattern, name)) 
[13:23:10.982]                             next
[13:23:10.982]                           invokeRestart(restart)
[13:23:10.982]                           muffled <- TRUE
[13:23:10.982]                           break
[13:23:10.982]                         }
[13:23:10.982]                       }
[13:23:10.982]                     }
[13:23:10.982]                     invisible(muffled)
[13:23:10.982]                   }
[13:23:10.982]                   muffleCondition(cond)
[13:23:10.982]                 })
[13:23:10.982]             }))
[13:23:10.982]             future::FutureResult(value = ...future.value$value, 
[13:23:10.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.982]                   ...future.rng), globalenv = if (FALSE) 
[13:23:10.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:10.982]                     ...future.globalenv.names))
[13:23:10.982]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:10.982]         }, condition = base::local({
[13:23:10.982]             c <- base::c
[13:23:10.982]             inherits <- base::inherits
[13:23:10.982]             invokeRestart <- base::invokeRestart
[13:23:10.982]             length <- base::length
[13:23:10.982]             list <- base::list
[13:23:10.982]             seq.int <- base::seq.int
[13:23:10.982]             signalCondition <- base::signalCondition
[13:23:10.982]             sys.calls <- base::sys.calls
[13:23:10.982]             `[[` <- base::`[[`
[13:23:10.982]             `+` <- base::`+`
[13:23:10.982]             `<<-` <- base::`<<-`
[13:23:10.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:10.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:10.982]                   3L)]
[13:23:10.982]             }
[13:23:10.982]             function(cond) {
[13:23:10.982]                 is_error <- inherits(cond, "error")
[13:23:10.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:10.982]                   NULL)
[13:23:10.982]                 if (is_error) {
[13:23:10.982]                   sessionInformation <- function() {
[13:23:10.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:10.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:10.982]                       search = base::search(), system = base::Sys.info())
[13:23:10.982]                   }
[13:23:10.982]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:10.982]                     cond$call), session = sessionInformation(), 
[13:23:10.982]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:10.982]                   signalCondition(cond)
[13:23:10.982]                 }
[13:23:10.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:10.982]                 "immediateCondition"))) {
[13:23:10.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:10.982]                   ...future.conditions[[length(...future.conditions) + 
[13:23:10.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:10.982]                   if (TRUE && !signal) {
[13:23:10.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.982]                     {
[13:23:10.982]                       inherits <- base::inherits
[13:23:10.982]                       invokeRestart <- base::invokeRestart
[13:23:10.982]                       is.null <- base::is.null
[13:23:10.982]                       muffled <- FALSE
[13:23:10.982]                       if (inherits(cond, "message")) {
[13:23:10.982]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.982]                         if (muffled) 
[13:23:10.982]                           invokeRestart("muffleMessage")
[13:23:10.982]                       }
[13:23:10.982]                       else if (inherits(cond, "warning")) {
[13:23:10.982]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.982]                         if (muffled) 
[13:23:10.982]                           invokeRestart("muffleWarning")
[13:23:10.982]                       }
[13:23:10.982]                       else if (inherits(cond, "condition")) {
[13:23:10.982]                         if (!is.null(pattern)) {
[13:23:10.982]                           computeRestarts <- base::computeRestarts
[13:23:10.982]                           grepl <- base::grepl
[13:23:10.982]                           restarts <- computeRestarts(cond)
[13:23:10.982]                           for (restart in restarts) {
[13:23:10.982]                             name <- restart$name
[13:23:10.982]                             if (is.null(name)) 
[13:23:10.982]                               next
[13:23:10.982]                             if (!grepl(pattern, name)) 
[13:23:10.982]                               next
[13:23:10.982]                             invokeRestart(restart)
[13:23:10.982]                             muffled <- TRUE
[13:23:10.982]                             break
[13:23:10.982]                           }
[13:23:10.982]                         }
[13:23:10.982]                       }
[13:23:10.982]                       invisible(muffled)
[13:23:10.982]                     }
[13:23:10.982]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.982]                   }
[13:23:10.982]                 }
[13:23:10.982]                 else {
[13:23:10.982]                   if (TRUE) {
[13:23:10.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:10.982]                     {
[13:23:10.982]                       inherits <- base::inherits
[13:23:10.982]                       invokeRestart <- base::invokeRestart
[13:23:10.982]                       is.null <- base::is.null
[13:23:10.982]                       muffled <- FALSE
[13:23:10.982]                       if (inherits(cond, "message")) {
[13:23:10.982]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:10.982]                         if (muffled) 
[13:23:10.982]                           invokeRestart("muffleMessage")
[13:23:10.982]                       }
[13:23:10.982]                       else if (inherits(cond, "warning")) {
[13:23:10.982]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:10.982]                         if (muffled) 
[13:23:10.982]                           invokeRestart("muffleWarning")
[13:23:10.982]                       }
[13:23:10.982]                       else if (inherits(cond, "condition")) {
[13:23:10.982]                         if (!is.null(pattern)) {
[13:23:10.982]                           computeRestarts <- base::computeRestarts
[13:23:10.982]                           grepl <- base::grepl
[13:23:10.982]                           restarts <- computeRestarts(cond)
[13:23:10.982]                           for (restart in restarts) {
[13:23:10.982]                             name <- restart$name
[13:23:10.982]                             if (is.null(name)) 
[13:23:10.982]                               next
[13:23:10.982]                             if (!grepl(pattern, name)) 
[13:23:10.982]                               next
[13:23:10.982]                             invokeRestart(restart)
[13:23:10.982]                             muffled <- TRUE
[13:23:10.982]                             break
[13:23:10.982]                           }
[13:23:10.982]                         }
[13:23:10.982]                       }
[13:23:10.982]                       invisible(muffled)
[13:23:10.982]                     }
[13:23:10.982]                     muffleCondition(cond, pattern = "^muffle")
[13:23:10.982]                   }
[13:23:10.982]                 }
[13:23:10.982]             }
[13:23:10.982]         }))
[13:23:10.982]     }, error = function(ex) {
[13:23:10.982]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:10.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:10.982]                 ...future.rng), started = ...future.startTime, 
[13:23:10.982]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:10.982]             version = "1.8"), class = "FutureResult")
[13:23:10.982]     }, finally = {
[13:23:10.982]         if (!identical(...future.workdir, getwd())) 
[13:23:10.982]             setwd(...future.workdir)
[13:23:10.982]         {
[13:23:10.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:10.982]                 ...future.oldOptions$nwarnings <- NULL
[13:23:10.982]             }
[13:23:10.982]             base::options(...future.oldOptions)
[13:23:10.982]             if (.Platform$OS.type == "windows") {
[13:23:10.982]                 old_names <- names(...future.oldEnvVars)
[13:23:10.982]                 envs <- base::Sys.getenv()
[13:23:10.982]                 names <- names(envs)
[13:23:10.982]                 common <- intersect(names, old_names)
[13:23:10.982]                 added <- setdiff(names, old_names)
[13:23:10.982]                 removed <- setdiff(old_names, names)
[13:23:10.982]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:10.982]                   envs[common]]
[13:23:10.982]                 NAMES <- toupper(changed)
[13:23:10.982]                 args <- list()
[13:23:10.982]                 for (kk in seq_along(NAMES)) {
[13:23:10.982]                   name <- changed[[kk]]
[13:23:10.982]                   NAME <- NAMES[[kk]]
[13:23:10.982]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.982]                     next
[13:23:10.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.982]                 }
[13:23:10.982]                 NAMES <- toupper(added)
[13:23:10.982]                 for (kk in seq_along(NAMES)) {
[13:23:10.982]                   name <- added[[kk]]
[13:23:10.982]                   NAME <- NAMES[[kk]]
[13:23:10.982]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.982]                     next
[13:23:10.982]                   args[[name]] <- ""
[13:23:10.982]                 }
[13:23:10.982]                 NAMES <- toupper(removed)
[13:23:10.982]                 for (kk in seq_along(NAMES)) {
[13:23:10.982]                   name <- removed[[kk]]
[13:23:10.982]                   NAME <- NAMES[[kk]]
[13:23:10.982]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:10.982]                     next
[13:23:10.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:10.982]                 }
[13:23:10.982]                 if (length(args) > 0) 
[13:23:10.982]                   base::do.call(base::Sys.setenv, args = args)
[13:23:10.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:10.982]             }
[13:23:10.982]             else {
[13:23:10.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:10.982]             }
[13:23:10.982]             {
[13:23:10.982]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:10.982]                   0L) {
[13:23:10.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:10.982]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:10.982]                   base::options(opts)
[13:23:10.982]                 }
[13:23:10.982]                 {
[13:23:10.982]                   {
[13:23:10.982]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:10.982]                     NULL
[13:23:10.982]                   }
[13:23:10.982]                   options(future.plan = NULL)
[13:23:10.982]                   if (is.na(NA_character_)) 
[13:23:10.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:10.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:10.982]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:10.982]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:10.982]                     envir = parent.frame()) 
[13:23:10.982]                   {
[13:23:10.982]                     if (is.function(workers)) 
[13:23:10.982]                       workers <- workers()
[13:23:10.982]                     workers <- structure(as.integer(workers), 
[13:23:10.982]                       class = class(workers))
[13:23:10.982]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:10.982]                       workers >= 1)
[13:23:10.982]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:10.982]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:10.982]                     }
[13:23:10.982]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:10.982]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:10.982]                       envir = envir)
[13:23:10.982]                     if (!future$lazy) 
[13:23:10.982]                       future <- run(future)
[13:23:10.982]                     invisible(future)
[13:23:10.982]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:10.982]                 }
[13:23:10.982]             }
[13:23:10.982]         }
[13:23:10.982]     })
[13:23:10.982]     if (TRUE) {
[13:23:10.982]         base::sink(type = "output", split = FALSE)
[13:23:10.982]         if (TRUE) {
[13:23:10.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:10.982]         }
[13:23:10.982]         else {
[13:23:10.982]             ...future.result["stdout"] <- base::list(NULL)
[13:23:10.982]         }
[13:23:10.982]         base::close(...future.stdout)
[13:23:10.982]         ...future.stdout <- NULL
[13:23:10.982]     }
[13:23:10.982]     ...future.result$conditions <- ...future.conditions
[13:23:10.982]     ...future.result$finished <- base::Sys.time()
[13:23:10.982]     ...future.result
[13:23:10.982] }
[13:23:10.984] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:10.999] receiveMessageFromWorker() for ClusterFuture ...
[13:23:10.999] - Validating connection of MultisessionFuture
[13:23:10.999] - received message: FutureResult
[13:23:10.999] - Received FutureResult
[13:23:10.999] - Erased future from FutureRegistry
[13:23:10.999] result() for ClusterFuture ...
[13:23:10.999] - result already collected: FutureResult
[13:23:11.000] result() for ClusterFuture ... done
[13:23:11.000] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:11.000] result() for ClusterFuture ...
[13:23:11.000] - result already collected: FutureResult
[13:23:11.000] result() for ClusterFuture ... done
[13:23:11.000] result() for ClusterFuture ...
[13:23:11.000] - result already collected: FutureResult
[13:23:11.000] result() for ClusterFuture ... done
[13:23:11.001] MultisessionFuture started
[13:23:11.002] - Launch lazy future ... done
[13:23:11.002] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d69b1d88> 
Classes 'listenv', 'environment' <environment: 0x5596d5ccdf48> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:23:11.009] receiveMessageFromWorker() for ClusterFuture ...
[13:23:11.009] - Validating connection of MultisessionFuture
[13:23:11.009] - received message: FutureResult
[13:23:11.009] - Received FutureResult
[13:23:11.010] - Erased future from FutureRegistry
[13:23:11.010] result() for ClusterFuture ...
[13:23:11.010] - result already collected: FutureResult
[13:23:11.010] result() for ClusterFuture ... done
[13:23:11.010] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:11.023] resolve() on list environment ...
[13:23:11.024]  recursive: 0
[13:23:11.025]  length: 6
[13:23:11.025]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:11.025] signalConditionsASAP(numeric, pos=1) ...
[13:23:11.025] - nx: 6
[13:23:11.025] - relay: TRUE
[13:23:11.025] - stdout: TRUE
[13:23:11.025] - signal: TRUE
[13:23:11.025] - resignal: FALSE
[13:23:11.025] - force: TRUE
[13:23:11.025] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.026] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.026]  - until=2
[13:23:11.026]  - relaying element #2
[13:23:11.026] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.026] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.026] signalConditionsASAP(NULL, pos=1) ... done
[13:23:11.026]  length: 5 (resolved future 1)
[13:23:11.026] Future #2
[13:23:11.026] result() for ClusterFuture ...
[13:23:11.026] - result already collected: FutureResult
[13:23:11.027] result() for ClusterFuture ... done
[13:23:11.027] result() for ClusterFuture ...
[13:23:11.027] - result already collected: FutureResult
[13:23:11.027] result() for ClusterFuture ... done
[13:23:11.027] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:11.027] - nx: 6
[13:23:11.027] - relay: TRUE
[13:23:11.027] - stdout: TRUE
[13:23:11.027] - signal: TRUE
[13:23:11.027] - resignal: FALSE
[13:23:11.027] - force: TRUE
[13:23:11.028] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.028] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.028]  - until=2
[13:23:11.028]  - relaying element #2
[13:23:11.028] result() for ClusterFuture ...
[13:23:11.028] - result already collected: FutureResult
[13:23:11.028] result() for ClusterFuture ... done
[13:23:11.028] result() for ClusterFuture ...
[13:23:11.028] - result already collected: FutureResult
[13:23:11.028] result() for ClusterFuture ... done
[13:23:11.029] result() for ClusterFuture ...
[13:23:11.029] - result already collected: FutureResult
[13:23:11.029] result() for ClusterFuture ... done
[13:23:11.029] result() for ClusterFuture ...
[13:23:11.029] - result already collected: FutureResult
[13:23:11.029] result() for ClusterFuture ... done
[13:23:11.029] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:11.029] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:11.029] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:11.029]  length: 4 (resolved future 2)
[13:23:11.029] Future #3
[13:23:11.030] result() for ClusterFuture ...
[13:23:11.030] - result already collected: FutureResult
[13:23:11.030] result() for ClusterFuture ... done
[13:23:11.030] result() for ClusterFuture ...
[13:23:11.030] - result already collected: FutureResult
[13:23:11.030] result() for ClusterFuture ... done
[13:23:11.030] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:11.030] - nx: 6
[13:23:11.030] - relay: TRUE
[13:23:11.030] - stdout: TRUE
[13:23:11.030] - signal: TRUE
[13:23:11.031] - resignal: FALSE
[13:23:11.031] - force: TRUE
[13:23:11.031] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:11.031] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:11.031]  - until=3
[13:23:11.031]  - relaying element #3
[13:23:11.031] result() for ClusterFuture ...
[13:23:11.031] - result already collected: FutureResult
[13:23:11.031] result() for ClusterFuture ... done
[13:23:11.031] result() for ClusterFuture ...
[13:23:11.031] - result already collected: FutureResult
[13:23:11.031] result() for ClusterFuture ... done
[13:23:11.032] result() for ClusterFuture ...
[13:23:11.032] - result already collected: FutureResult
[13:23:11.032] result() for ClusterFuture ... done
[13:23:11.032] result() for ClusterFuture ...
[13:23:11.032] - result already collected: FutureResult
[13:23:11.032] result() for ClusterFuture ... done
[13:23:11.032] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.032] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.032] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:11.032]  length: 3 (resolved future 3)
[13:23:11.043] signalConditionsASAP(NULL, pos=5) ...
[13:23:11.043] - nx: 6
[13:23:11.044] - relay: TRUE
[13:23:11.044] - stdout: TRUE
[13:23:11.044] - signal: TRUE
[13:23:11.044] - resignal: FALSE
[13:23:11.044] - force: TRUE
[13:23:11.044] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.044] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.045]  - until=6
[13:23:11.045]  - relaying element #4
[13:23:11.045]  - relaying element #6
[13:23:11.045] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:11.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.045] signalConditionsASAP(NULL, pos=5) ... done
[13:23:11.045]  length: 2 (resolved future 5)
[13:23:11.045] signalConditionsASAP(numeric, pos=6) ...
[13:23:11.045] - nx: 6
[13:23:11.045] - relay: TRUE
[13:23:11.046] - stdout: TRUE
[13:23:11.046] - signal: TRUE
[13:23:11.046] - resignal: FALSE
[13:23:11.046] - force: TRUE
[13:23:11.046] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:11.046] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.046]  - until=6
[13:23:11.046]  - relaying element #4
[13:23:11.046] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:11.046] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.047] signalConditionsASAP(NULL, pos=6) ... done
[13:23:11.047]  length: 1 (resolved future 6)
[13:23:11.058] receiveMessageFromWorker() for ClusterFuture ...
[13:23:11.058] - Validating connection of MultisessionFuture
[13:23:11.058] - received message: FutureResult
[13:23:11.058] - Received FutureResult
[13:23:11.058] - Erased future from FutureRegistry
[13:23:11.058] result() for ClusterFuture ...
[13:23:11.058] - result already collected: FutureResult
[13:23:11.059] result() for ClusterFuture ... done
[13:23:11.059] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:11.059] Future #4
[13:23:11.059] result() for ClusterFuture ...
[13:23:11.059] - result already collected: FutureResult
[13:23:11.059] result() for ClusterFuture ... done
[13:23:11.059] result() for ClusterFuture ...
[13:23:11.059] - result already collected: FutureResult
[13:23:11.059] result() for ClusterFuture ... done
[13:23:11.059] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:11.060] - nx: 6
[13:23:11.060] - relay: TRUE
[13:23:11.060] - stdout: TRUE
[13:23:11.060] - signal: TRUE
[13:23:11.060] - resignal: FALSE
[13:23:11.060] - force: TRUE
[13:23:11.060] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:11.060] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.060]  - until=6
[13:23:11.060]  - relaying element #4
[13:23:11.061] result() for ClusterFuture ...
[13:23:11.061] - result already collected: FutureResult
[13:23:11.061] result() for ClusterFuture ... done
[13:23:11.061] result() for ClusterFuture ...
[13:23:11.061] - result already collected: FutureResult
[13:23:11.061] result() for ClusterFuture ... done
[13:23:11.061] result() for ClusterFuture ...
[13:23:11.061] - result already collected: FutureResult
[13:23:11.061] result() for ClusterFuture ... done
[13:23:11.061] result() for ClusterFuture ...
[13:23:11.061] - result already collected: FutureResult
[13:23:11.062] result() for ClusterFuture ... done
[13:23:11.062] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:11.062] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:11.062] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:11.062]  length: 0 (resolved future 4)
[13:23:11.062] Relaying remaining futures
[13:23:11.062] signalConditionsASAP(NULL, pos=0) ...
[13:23:11.062] - nx: 6
[13:23:11.062] - relay: TRUE
[13:23:11.062] - stdout: TRUE
[13:23:11.062] - signal: TRUE
[13:23:11.063] - resignal: FALSE
[13:23:11.063] - force: TRUE
[13:23:11.063] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:11.063] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:11.063] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:11.063] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:11.063] signalConditionsASAP(NULL, pos=0) ... done
[13:23:11.063] resolve() on list environment ... DONE
[13:23:11.063] result() for ClusterFuture ...
[13:23:11.063] - result already collected: FutureResult
[13:23:11.064] result() for ClusterFuture ... done
[13:23:11.064] result() for ClusterFuture ...
[13:23:11.064] - result already collected: FutureResult
[13:23:11.064] result() for ClusterFuture ... done
[13:23:11.064] result() for ClusterFuture ...
[13:23:11.064] - result already collected: FutureResult
[13:23:11.064] result() for ClusterFuture ... done
[13:23:11.064] result() for ClusterFuture ...
[13:23:11.064] - result already collected: FutureResult
[13:23:11.065] result() for ClusterFuture ... done
[13:23:11.065] result() for ClusterFuture ...
[13:23:11.065] - result already collected: FutureResult
[13:23:11.065] result() for ClusterFuture ... done
[13:23:11.065] result() for ClusterFuture ...
[13:23:11.065] - result already collected: FutureResult
[13:23:11.065] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d5656080> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[13:23:11.067] getGlobalsAndPackages() ...
[13:23:11.068] Searching for globals...
[13:23:11.068] 
[13:23:11.068] Searching for globals ... DONE
[13:23:11.068] - globals: [0] <none>
[13:23:11.068] getGlobalsAndPackages() ... DONE
[13:23:11.069] run() for ‘Future’ ...
[13:23:11.069] - state: ‘created’
[13:23:11.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:11.084] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:11.084] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:11.084]   - Field: ‘node’
[13:23:11.084]   - Field: ‘label’
[13:23:11.084]   - Field: ‘local’
[13:23:11.084]   - Field: ‘owner’
[13:23:11.085]   - Field: ‘envir’
[13:23:11.085]   - Field: ‘workers’
[13:23:11.085]   - Field: ‘packages’
[13:23:11.085]   - Field: ‘gc’
[13:23:11.085]   - Field: ‘conditions’
[13:23:11.085]   - Field: ‘persistent’
[13:23:11.085]   - Field: ‘expr’
[13:23:11.085]   - Field: ‘uuid’
[13:23:11.085]   - Field: ‘seed’
[13:23:11.085]   - Field: ‘version’
[13:23:11.085]   - Field: ‘result’
[13:23:11.086]   - Field: ‘asynchronous’
[13:23:11.086]   - Field: ‘calls’
[13:23:11.086]   - Field: ‘globals’
[13:23:11.086]   - Field: ‘stdout’
[13:23:11.086]   - Field: ‘earlySignal’
[13:23:11.086]   - Field: ‘lazy’
[13:23:11.086]   - Field: ‘state’
[13:23:11.086] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:11.086] - Launch lazy future ...
[13:23:11.087] Packages needed by the future expression (n = 0): <none>
[13:23:11.087] Packages needed by future strategies (n = 0): <none>
[13:23:11.087] {
[13:23:11.087]     {
[13:23:11.087]         {
[13:23:11.087]             ...future.startTime <- base::Sys.time()
[13:23:11.087]             {
[13:23:11.087]                 {
[13:23:11.087]                   {
[13:23:11.087]                     {
[13:23:11.087]                       base::local({
[13:23:11.087]                         has_future <- base::requireNamespace("future", 
[13:23:11.087]                           quietly = TRUE)
[13:23:11.087]                         if (has_future) {
[13:23:11.087]                           ns <- base::getNamespace("future")
[13:23:11.087]                           version <- ns[[".package"]][["version"]]
[13:23:11.087]                           if (is.null(version)) 
[13:23:11.087]                             version <- utils::packageVersion("future")
[13:23:11.087]                         }
[13:23:11.087]                         else {
[13:23:11.087]                           version <- NULL
[13:23:11.087]                         }
[13:23:11.087]                         if (!has_future || version < "1.8.0") {
[13:23:11.087]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:11.087]                             "", base::R.version$version.string), 
[13:23:11.087]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:11.087]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:11.087]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:11.087]                               "release", "version")], collapse = " "), 
[13:23:11.087]                             hostname = base::Sys.info()[["nodename"]])
[13:23:11.087]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:11.087]                             info)
[13:23:11.087]                           info <- base::paste(info, collapse = "; ")
[13:23:11.087]                           if (!has_future) {
[13:23:11.087]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:11.087]                               info)
[13:23:11.087]                           }
[13:23:11.087]                           else {
[13:23:11.087]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:11.087]                               info, version)
[13:23:11.087]                           }
[13:23:11.087]                           base::stop(msg)
[13:23:11.087]                         }
[13:23:11.087]                       })
[13:23:11.087]                     }
[13:23:11.087]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:11.087]                     base::options(mc.cores = 1L)
[13:23:11.087]                   }
[13:23:11.087]                   options(future.plan = NULL)
[13:23:11.087]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:11.087]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:11.087]                 }
[13:23:11.087]                 ...future.workdir <- getwd()
[13:23:11.087]             }
[13:23:11.087]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:11.087]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:11.087]         }
[13:23:11.087]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:11.087]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:11.087]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:11.087]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:11.087]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:11.087]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:11.087]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:11.087]             base::names(...future.oldOptions))
[13:23:11.087]     }
[13:23:11.087]     if (FALSE) {
[13:23:11.087]     }
[13:23:11.087]     else {
[13:23:11.087]         if (TRUE) {
[13:23:11.087]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:11.087]                 open = "w")
[13:23:11.087]         }
[13:23:11.087]         else {
[13:23:11.087]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:11.087]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:11.087]         }
[13:23:11.087]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:11.087]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:11.087]             base::sink(type = "output", split = FALSE)
[13:23:11.087]             base::close(...future.stdout)
[13:23:11.087]         }, add = TRUE)
[13:23:11.087]     }
[13:23:11.087]     ...future.frame <- base::sys.nframe()
[13:23:11.087]     ...future.conditions <- base::list()
[13:23:11.087]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:11.087]     if (FALSE) {
[13:23:11.087]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:11.087]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:11.087]     }
[13:23:11.087]     ...future.result <- base::tryCatch({
[13:23:11.087]         base::withCallingHandlers({
[13:23:11.087]             ...future.value <- base::withVisible(base::local({
[13:23:11.087]                 ...future.makeSendCondition <- base::local({
[13:23:11.087]                   sendCondition <- NULL
[13:23:11.087]                   function(frame = 1L) {
[13:23:11.087]                     if (is.function(sendCondition)) 
[13:23:11.087]                       return(sendCondition)
[13:23:11.087]                     ns <- getNamespace("parallel")
[13:23:11.087]                     if (exists("sendData", mode = "function", 
[13:23:11.087]                       envir = ns)) {
[13:23:11.087]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:11.087]                         envir = ns)
[13:23:11.087]                       envir <- sys.frame(frame)
[13:23:11.087]                       master <- NULL
[13:23:11.087]                       while (!identical(envir, .GlobalEnv) && 
[13:23:11.087]                         !identical(envir, emptyenv())) {
[13:23:11.087]                         if (exists("master", mode = "list", envir = envir, 
[13:23:11.087]                           inherits = FALSE)) {
[13:23:11.087]                           master <- get("master", mode = "list", 
[13:23:11.087]                             envir = envir, inherits = FALSE)
[13:23:11.087]                           if (inherits(master, c("SOCKnode", 
[13:23:11.087]                             "SOCK0node"))) {
[13:23:11.087]                             sendCondition <<- function(cond) {
[13:23:11.087]                               data <- list(type = "VALUE", value = cond, 
[13:23:11.087]                                 success = TRUE)
[13:23:11.087]                               parallel_sendData(master, data)
[13:23:11.087]                             }
[13:23:11.087]                             return(sendCondition)
[13:23:11.087]                           }
[13:23:11.087]                         }
[13:23:11.087]                         frame <- frame + 1L
[13:23:11.087]                         envir <- sys.frame(frame)
[13:23:11.087]                       }
[13:23:11.087]                     }
[13:23:11.087]                     sendCondition <<- function(cond) NULL
[13:23:11.087]                   }
[13:23:11.087]                 })
[13:23:11.087]                 withCallingHandlers({
[13:23:11.087]                   2
[13:23:11.087]                 }, immediateCondition = function(cond) {
[13:23:11.087]                   sendCondition <- ...future.makeSendCondition()
[13:23:11.087]                   sendCondition(cond)
[13:23:11.087]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:11.087]                   {
[13:23:11.087]                     inherits <- base::inherits
[13:23:11.087]                     invokeRestart <- base::invokeRestart
[13:23:11.087]                     is.null <- base::is.null
[13:23:11.087]                     muffled <- FALSE
[13:23:11.087]                     if (inherits(cond, "message")) {
[13:23:11.087]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:11.087]                       if (muffled) 
[13:23:11.087]                         invokeRestart("muffleMessage")
[13:23:11.087]                     }
[13:23:11.087]                     else if (inherits(cond, "warning")) {
[13:23:11.087]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:11.087]                       if (muffled) 
[13:23:11.087]                         invokeRestart("muffleWarning")
[13:23:11.087]                     }
[13:23:11.087]                     else if (inherits(cond, "condition")) {
[13:23:11.087]                       if (!is.null(pattern)) {
[13:23:11.087]                         computeRestarts <- base::computeRestarts
[13:23:11.087]                         grepl <- base::grepl
[13:23:11.087]                         restarts <- computeRestarts(cond)
[13:23:11.087]                         for (restart in restarts) {
[13:23:11.087]                           name <- restart$name
[13:23:11.087]                           if (is.null(name)) 
[13:23:11.087]                             next
[13:23:11.087]                           if (!grepl(pattern, name)) 
[13:23:11.087]                             next
[13:23:11.087]                           invokeRestart(restart)
[13:23:11.087]                           muffled <- TRUE
[13:23:11.087]                           break
[13:23:11.087]                         }
[13:23:11.087]                       }
[13:23:11.087]                     }
[13:23:11.087]                     invisible(muffled)
[13:23:11.087]                   }
[13:23:11.087]                   muffleCondition(cond)
[13:23:11.087]                 })
[13:23:11.087]             }))
[13:23:11.087]             future::FutureResult(value = ...future.value$value, 
[13:23:11.087]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:11.087]                   ...future.rng), globalenv = if (FALSE) 
[13:23:11.087]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:11.087]                     ...future.globalenv.names))
[13:23:11.087]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:11.087]         }, condition = base::local({
[13:23:11.087]             c <- base::c
[13:23:11.087]             inherits <- base::inherits
[13:23:11.087]             invokeRestart <- base::invokeRestart
[13:23:11.087]             length <- base::length
[13:23:11.087]             list <- base::list
[13:23:11.087]             seq.int <- base::seq.int
[13:23:11.087]             signalCondition <- base::signalCondition
[13:23:11.087]             sys.calls <- base::sys.calls
[13:23:11.087]             `[[` <- base::`[[`
[13:23:11.087]             `+` <- base::`+`
[13:23:11.087]             `<<-` <- base::`<<-`
[13:23:11.087]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:11.087]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:11.087]                   3L)]
[13:23:11.087]             }
[13:23:11.087]             function(cond) {
[13:23:11.087]                 is_error <- inherits(cond, "error")
[13:23:11.087]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:11.087]                   NULL)
[13:23:11.087]                 if (is_error) {
[13:23:11.087]                   sessionInformation <- function() {
[13:23:11.087]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:11.087]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:11.087]                       search = base::search(), system = base::Sys.info())
[13:23:11.087]                   }
[13:23:11.087]                   ...future.conditions[[length(...future.conditions) + 
[13:23:11.087]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:11.087]                     cond$call), session = sessionInformation(), 
[13:23:11.087]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:11.087]                   signalCondition(cond)
[13:23:11.087]                 }
[13:23:11.087]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:11.087]                 "immediateCondition"))) {
[13:23:11.087]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:11.087]                   ...future.conditions[[length(...future.conditions) + 
[13:23:11.087]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:11.087]                   if (TRUE && !signal) {
[13:23:11.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:11.087]                     {
[13:23:11.087]                       inherits <- base::inherits
[13:23:11.087]                       invokeRestart <- base::invokeRestart
[13:23:11.087]                       is.null <- base::is.null
[13:23:11.087]                       muffled <- FALSE
[13:23:11.087]                       if (inherits(cond, "message")) {
[13:23:11.087]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:11.087]                         if (muffled) 
[13:23:11.087]                           invokeRestart("muffleMessage")
[13:23:11.087]                       }
[13:23:11.087]                       else if (inherits(cond, "warning")) {
[13:23:11.087]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:11.087]                         if (muffled) 
[13:23:11.087]                           invokeRestart("muffleWarning")
[13:23:11.087]                       }
[13:23:11.087]                       else if (inherits(cond, "condition")) {
[13:23:11.087]                         if (!is.null(pattern)) {
[13:23:11.087]                           computeRestarts <- base::computeRestarts
[13:23:11.087]                           grepl <- base::grepl
[13:23:11.087]                           restarts <- computeRestarts(cond)
[13:23:11.087]                           for (restart in restarts) {
[13:23:11.087]                             name <- restart$name
[13:23:11.087]                             if (is.null(name)) 
[13:23:11.087]                               next
[13:23:11.087]                             if (!grepl(pattern, name)) 
[13:23:11.087]                               next
[13:23:11.087]                             invokeRestart(restart)
[13:23:11.087]                             muffled <- TRUE
[13:23:11.087]                             break
[13:23:11.087]                           }
[13:23:11.087]                         }
[13:23:11.087]                       }
[13:23:11.087]                       invisible(muffled)
[13:23:11.087]                     }
[13:23:11.087]                     muffleCondition(cond, pattern = "^muffle")
[13:23:11.087]                   }
[13:23:11.087]                 }
[13:23:11.087]                 else {
[13:23:11.087]                   if (TRUE) {
[13:23:11.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:11.087]                     {
[13:23:11.087]                       inherits <- base::inherits
[13:23:11.087]                       invokeRestart <- base::invokeRestart
[13:23:11.087]                       is.null <- base::is.null
[13:23:11.087]                       muffled <- FALSE
[13:23:11.087]                       if (inherits(cond, "message")) {
[13:23:11.087]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:11.087]                         if (muffled) 
[13:23:11.087]                           invokeRestart("muffleMessage")
[13:23:11.087]                       }
[13:23:11.087]                       else if (inherits(cond, "warning")) {
[13:23:11.087]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:11.087]                         if (muffled) 
[13:23:11.087]                           invokeRestart("muffleWarning")
[13:23:11.087]                       }
[13:23:11.087]                       else if (inherits(cond, "condition")) {
[13:23:11.087]                         if (!is.null(pattern)) {
[13:23:11.087]                           computeRestarts <- base::computeRestarts
[13:23:11.087]                           grepl <- base::grepl
[13:23:11.087]                           restarts <- computeRestarts(cond)
[13:23:11.087]                           for (restart in restarts) {
[13:23:11.087]                             name <- restart$name
[13:23:11.087]                             if (is.null(name)) 
[13:23:11.087]                               next
[13:23:11.087]                             if (!grepl(pattern, name)) 
[13:23:11.087]                               next
[13:23:11.087]                             invokeRestart(restart)
[13:23:11.087]                             muffled <- TRUE
[13:23:11.087]                             break
[13:23:11.087]                           }
[13:23:11.087]                         }
[13:23:11.087]                       }
[13:23:11.087]                       invisible(muffled)
[13:23:11.087]                     }
[13:23:11.087]                     muffleCondition(cond, pattern = "^muffle")
[13:23:11.087]                   }
[13:23:11.087]                 }
[13:23:11.087]             }
[13:23:11.087]         }))
[13:23:11.087]     }, error = function(ex) {
[13:23:11.087]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:11.087]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:11.087]                 ...future.rng), started = ...future.startTime, 
[13:23:11.087]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:11.087]             version = "1.8"), class = "FutureResult")
[13:23:11.087]     }, finally = {
[13:23:11.087]         if (!identical(...future.workdir, getwd())) 
[13:23:11.087]             setwd(...future.workdir)
[13:23:11.087]         {
[13:23:11.087]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:11.087]                 ...future.oldOptions$nwarnings <- NULL
[13:23:11.087]             }
[13:23:11.087]             base::options(...future.oldOptions)
[13:23:11.087]             if (.Platform$OS.type == "windows") {
[13:23:11.087]                 old_names <- names(...future.oldEnvVars)
[13:23:11.087]                 envs <- base::Sys.getenv()
[13:23:11.087]                 names <- names(envs)
[13:23:11.087]                 common <- intersect(names, old_names)
[13:23:11.087]                 added <- setdiff(names, old_names)
[13:23:11.087]                 removed <- setdiff(old_names, names)
[13:23:11.087]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:11.087]                   envs[common]]
[13:23:11.087]                 NAMES <- toupper(changed)
[13:23:11.087]                 args <- list()
[13:23:11.087]                 for (kk in seq_along(NAMES)) {
[13:23:11.087]                   name <- changed[[kk]]
[13:23:11.087]                   NAME <- NAMES[[kk]]
[13:23:11.087]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:11.087]                     next
[13:23:11.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:11.087]                 }
[13:23:11.087]                 NAMES <- toupper(added)
[13:23:11.087]                 for (kk in seq_along(NAMES)) {
[13:23:11.087]                   name <- added[[kk]]
[13:23:11.087]                   NAME <- NAMES[[kk]]
[13:23:11.087]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:11.087]                     next
[13:23:11.087]                   args[[name]] <- ""
[13:23:11.087]                 }
[13:23:11.087]                 NAMES <- toupper(removed)
[13:23:11.087]                 for (kk in seq_along(NAMES)) {
[13:23:11.087]                   name <- removed[[kk]]
[13:23:11.087]                   NAME <- NAMES[[kk]]
[13:23:11.087]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:11.087]                     next
[13:23:11.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:11.087]                 }
[13:23:11.087]                 if (length(args) > 0) 
[13:23:11.087]                   base::do.call(base::Sys.setenv, args = args)
[13:23:11.087]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:11.087]             }
[13:23:11.087]             else {
[13:23:11.087]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:11.087]             }
[13:23:11.087]             {
[13:23:11.087]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:11.087]                   0L) {
[13:23:11.087]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:11.087]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:11.087]                   base::options(opts)
[13:23:11.087]                 }
[13:23:11.087]                 {
[13:23:11.087]                   {
[13:23:11.087]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:11.087]                     NULL
[13:23:11.087]                   }
[13:23:11.087]                   options(future.plan = NULL)
[13:23:11.087]                   if (is.na(NA_character_)) 
[13:23:11.087]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:11.087]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:11.087]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:11.087]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:11.087]                     envir = parent.frame()) 
[13:23:11.087]                   {
[13:23:11.087]                     if (is.function(workers)) 
[13:23:11.087]                       workers <- workers()
[13:23:11.087]                     workers <- structure(as.integer(workers), 
[13:23:11.087]                       class = class(workers))
[13:23:11.087]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:11.087]                       workers >= 1)
[13:23:11.087]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:11.087]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:11.087]                     }
[13:23:11.087]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:11.087]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:11.087]                       envir = envir)
[13:23:11.087]                     if (!future$lazy) 
[13:23:11.087]                       future <- run(future)
[13:23:11.087]                     invisible(future)
[13:23:11.087]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:11.087]                 }
[13:23:11.087]             }
[13:23:11.087]         }
[13:23:11.087]     })
[13:23:11.087]     if (TRUE) {
[13:23:11.087]         base::sink(type = "output", split = FALSE)
[13:23:11.087]         if (TRUE) {
[13:23:11.087]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:11.087]         }
[13:23:11.087]         else {
[13:23:11.087]             ...future.result["stdout"] <- base::list(NULL)
[13:23:11.087]         }
[13:23:11.087]         base::close(...future.stdout)
[13:23:11.087]         ...future.stdout <- NULL
[13:23:11.087]     }
[13:23:11.087]     ...future.result$conditions <- ...future.conditions
[13:23:11.087]     ...future.result$finished <- base::Sys.time()
[13:23:11.087]     ...future.result
[13:23:11.087] }
[13:23:11.091] MultisessionFuture started
[13:23:11.091] - Launch lazy future ... done
[13:23:11.092] run() for ‘MultisessionFuture’ ... done
[13:23:11.092] getGlobalsAndPackages() ...
[13:23:11.092] Searching for globals...
[13:23:11.092] 
[13:23:11.092] Searching for globals ... DONE
[13:23:11.092] - globals: [0] <none>
[13:23:11.093] getGlobalsAndPackages() ... DONE
[13:23:11.093] run() for ‘Future’ ...
[13:23:11.093] - state: ‘created’
[13:23:11.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:11.108] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:11.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:11.108]   - Field: ‘node’
[13:23:11.109]   - Field: ‘label’
[13:23:11.109]   - Field: ‘local’
[13:23:11.109]   - Field: ‘owner’
[13:23:11.109]   - Field: ‘envir’
[13:23:11.109]   - Field: ‘workers’
[13:23:11.109]   - Field: ‘packages’
[13:23:11.109]   - Field: ‘gc’
[13:23:11.109]   - Field: ‘conditions’
[13:23:11.109]   - Field: ‘persistent’
[13:23:11.109]   - Field: ‘expr’
[13:23:11.110]   - Field: ‘uuid’
[13:23:11.110]   - Field: ‘seed’
[13:23:11.110]   - Field: ‘version’
[13:23:11.110]   - Field: ‘result’
[13:23:11.110]   - Field: ‘asynchronous’
[13:23:11.110]   - Field: ‘calls’
[13:23:11.110]   - Field: ‘globals’
[13:23:11.110]   - Field: ‘stdout’
[13:23:11.110]   - Field: ‘earlySignal’
[13:23:11.110]   - Field: ‘lazy’
[13:23:11.111]   - Field: ‘state’
[13:23:11.111] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:11.111] - Launch lazy future ...
[13:23:11.111] Packages needed by the future expression (n = 0): <none>
[13:23:11.111] Packages needed by future strategies (n = 0): <none>
[13:23:11.112] {
[13:23:11.112]     {
[13:23:11.112]         {
[13:23:11.112]             ...future.startTime <- base::Sys.time()
[13:23:11.112]             {
[13:23:11.112]                 {
[13:23:11.112]                   {
[13:23:11.112]                     {
[13:23:11.112]                       base::local({
[13:23:11.112]                         has_future <- base::requireNamespace("future", 
[13:23:11.112]                           quietly = TRUE)
[13:23:11.112]                         if (has_future) {
[13:23:11.112]                           ns <- base::getNamespace("future")
[13:23:11.112]                           version <- ns[[".package"]][["version"]]
[13:23:11.112]                           if (is.null(version)) 
[13:23:11.112]                             version <- utils::packageVersion("future")
[13:23:11.112]                         }
[13:23:11.112]                         else {
[13:23:11.112]                           version <- NULL
[13:23:11.112]                         }
[13:23:11.112]                         if (!has_future || version < "1.8.0") {
[13:23:11.112]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:11.112]                             "", base::R.version$version.string), 
[13:23:11.112]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:11.112]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:11.112]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:11.112]                               "release", "version")], collapse = " "), 
[13:23:11.112]                             hostname = base::Sys.info()[["nodename"]])
[13:23:11.112]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:11.112]                             info)
[13:23:11.112]                           info <- base::paste(info, collapse = "; ")
[13:23:11.112]                           if (!has_future) {
[13:23:11.112]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:11.112]                               info)
[13:23:11.112]                           }
[13:23:11.112]                           else {
[13:23:11.112]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:11.112]                               info, version)
[13:23:11.112]                           }
[13:23:11.112]                           base::stop(msg)
[13:23:11.112]                         }
[13:23:11.112]                       })
[13:23:11.112]                     }
[13:23:11.112]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:11.112]                     base::options(mc.cores = 1L)
[13:23:11.112]                   }
[13:23:11.112]                   options(future.plan = NULL)
[13:23:11.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:11.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:11.112]                 }
[13:23:11.112]                 ...future.workdir <- getwd()
[13:23:11.112]             }
[13:23:11.112]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:11.112]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:11.112]         }
[13:23:11.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:11.112]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:11.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:11.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:11.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:11.112]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:11.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:11.112]             base::names(...future.oldOptions))
[13:23:11.112]     }
[13:23:11.112]     if (FALSE) {
[13:23:11.112]     }
[13:23:11.112]     else {
[13:23:11.112]         if (TRUE) {
[13:23:11.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:11.112]                 open = "w")
[13:23:11.112]         }
[13:23:11.112]         else {
[13:23:11.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:11.112]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:11.112]         }
[13:23:11.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:11.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:11.112]             base::sink(type = "output", split = FALSE)
[13:23:11.112]             base::close(...future.stdout)
[13:23:11.112]         }, add = TRUE)
[13:23:11.112]     }
[13:23:11.112]     ...future.frame <- base::sys.nframe()
[13:23:11.112]     ...future.conditions <- base::list()
[13:23:11.112]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:11.112]     if (FALSE) {
[13:23:11.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:11.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:11.112]     }
[13:23:11.112]     ...future.result <- base::tryCatch({
[13:23:11.112]         base::withCallingHandlers({
[13:23:11.112]             ...future.value <- base::withVisible(base::local({
[13:23:11.112]                 ...future.makeSendCondition <- base::local({
[13:23:11.112]                   sendCondition <- NULL
[13:23:11.112]                   function(frame = 1L) {
[13:23:11.112]                     if (is.function(sendCondition)) 
[13:23:11.112]                       return(sendCondition)
[13:23:11.112]                     ns <- getNamespace("parallel")
[13:23:11.112]                     if (exists("sendData", mode = "function", 
[13:23:11.112]                       envir = ns)) {
[13:23:11.112]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:11.112]                         envir = ns)
[13:23:11.112]                       envir <- sys.frame(frame)
[13:23:11.112]                       master <- NULL
[13:23:11.112]                       while (!identical(envir, .GlobalEnv) && 
[13:23:11.112]                         !identical(envir, emptyenv())) {
[13:23:11.112]                         if (exists("master", mode = "list", envir = envir, 
[13:23:11.112]                           inherits = FALSE)) {
[13:23:11.112]                           master <- get("master", mode = "list", 
[13:23:11.112]                             envir = envir, inherits = FALSE)
[13:23:11.112]                           if (inherits(master, c("SOCKnode", 
[13:23:11.112]                             "SOCK0node"))) {
[13:23:11.112]                             sendCondition <<- function(cond) {
[13:23:11.112]                               data <- list(type = "VALUE", value = cond, 
[13:23:11.112]                                 success = TRUE)
[13:23:11.112]                               parallel_sendData(master, data)
[13:23:11.112]                             }
[13:23:11.112]                             return(sendCondition)
[13:23:11.112]                           }
[13:23:11.112]                         }
[13:23:11.112]                         frame <- frame + 1L
[13:23:11.112]                         envir <- sys.frame(frame)
[13:23:11.112]                       }
[13:23:11.112]                     }
[13:23:11.112]                     sendCondition <<- function(cond) NULL
[13:23:11.112]                   }
[13:23:11.112]                 })
[13:23:11.112]                 withCallingHandlers({
[13:23:11.112]                   NULL
[13:23:11.112]                 }, immediateCondition = function(cond) {
[13:23:11.112]                   sendCondition <- ...future.makeSendCondition()
[13:23:11.112]                   sendCondition(cond)
[13:23:11.112]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:11.112]                   {
[13:23:11.112]                     inherits <- base::inherits
[13:23:11.112]                     invokeRestart <- base::invokeRestart
[13:23:11.112]                     is.null <- base::is.null
[13:23:11.112]                     muffled <- FALSE
[13:23:11.112]                     if (inherits(cond, "message")) {
[13:23:11.112]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:11.112]                       if (muffled) 
[13:23:11.112]                         invokeRestart("muffleMessage")
[13:23:11.112]                     }
[13:23:11.112]                     else if (inherits(cond, "warning")) {
[13:23:11.112]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:11.112]                       if (muffled) 
[13:23:11.112]                         invokeRestart("muffleWarning")
[13:23:11.112]                     }
[13:23:11.112]                     else if (inherits(cond, "condition")) {
[13:23:11.112]                       if (!is.null(pattern)) {
[13:23:11.112]                         computeRestarts <- base::computeRestarts
[13:23:11.112]                         grepl <- base::grepl
[13:23:11.112]                         restarts <- computeRestarts(cond)
[13:23:11.112]                         for (restart in restarts) {
[13:23:11.112]                           name <- restart$name
[13:23:11.112]                           if (is.null(name)) 
[13:23:11.112]                             next
[13:23:11.112]                           if (!grepl(pattern, name)) 
[13:23:11.112]                             next
[13:23:11.112]                           invokeRestart(restart)
[13:23:11.112]                           muffled <- TRUE
[13:23:11.112]                           break
[13:23:11.112]                         }
[13:23:11.112]                       }
[13:23:11.112]                     }
[13:23:11.112]                     invisible(muffled)
[13:23:11.112]                   }
[13:23:11.112]                   muffleCondition(cond)
[13:23:11.112]                 })
[13:23:11.112]             }))
[13:23:11.112]             future::FutureResult(value = ...future.value$value, 
[13:23:11.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:11.112]                   ...future.rng), globalenv = if (FALSE) 
[13:23:11.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:11.112]                     ...future.globalenv.names))
[13:23:11.112]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:11.112]         }, condition = base::local({
[13:23:11.112]             c <- base::c
[13:23:11.112]             inherits <- base::inherits
[13:23:11.112]             invokeRestart <- base::invokeRestart
[13:23:11.112]             length <- base::length
[13:23:11.112]             list <- base::list
[13:23:11.112]             seq.int <- base::seq.int
[13:23:11.112]             signalCondition <- base::signalCondition
[13:23:11.112]             sys.calls <- base::sys.calls
[13:23:11.112]             `[[` <- base::`[[`
[13:23:11.112]             `+` <- base::`+`
[13:23:11.112]             `<<-` <- base::`<<-`
[13:23:11.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:11.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:11.112]                   3L)]
[13:23:11.112]             }
[13:23:11.112]             function(cond) {
[13:23:11.112]                 is_error <- inherits(cond, "error")
[13:23:11.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:11.112]                   NULL)
[13:23:11.112]                 if (is_error) {
[13:23:11.112]                   sessionInformation <- function() {
[13:23:11.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:11.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:11.112]                       search = base::search(), system = base::Sys.info())
[13:23:11.112]                   }
[13:23:11.112]                   ...future.conditions[[length(...future.conditions) + 
[13:23:11.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:11.112]                     cond$call), session = sessionInformation(), 
[13:23:11.112]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:11.112]                   signalCondition(cond)
[13:23:11.112]                 }
[13:23:11.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:11.112]                 "immediateCondition"))) {
[13:23:11.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:11.112]                   ...future.conditions[[length(...future.conditions) + 
[13:23:11.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:11.112]                   if (TRUE && !signal) {
[13:23:11.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:11.112]                     {
[13:23:11.112]                       inherits <- base::inherits
[13:23:11.112]                       invokeRestart <- base::invokeRestart
[13:23:11.112]                       is.null <- base::is.null
[13:23:11.112]                       muffled <- FALSE
[13:23:11.112]                       if (inherits(cond, "message")) {
[13:23:11.112]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:11.112]                         if (muffled) 
[13:23:11.112]                           invokeRestart("muffleMessage")
[13:23:11.112]                       }
[13:23:11.112]                       else if (inherits(cond, "warning")) {
[13:23:11.112]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:11.112]                         if (muffled) 
[13:23:11.112]                           invokeRestart("muffleWarning")
[13:23:11.112]                       }
[13:23:11.112]                       else if (inherits(cond, "condition")) {
[13:23:11.112]                         if (!is.null(pattern)) {
[13:23:11.112]                           computeRestarts <- base::computeRestarts
[13:23:11.112]                           grepl <- base::grepl
[13:23:11.112]                           restarts <- computeRestarts(cond)
[13:23:11.112]                           for (restart in restarts) {
[13:23:11.112]                             name <- restart$name
[13:23:11.112]                             if (is.null(name)) 
[13:23:11.112]                               next
[13:23:11.112]                             if (!grepl(pattern, name)) 
[13:23:11.112]                               next
[13:23:11.112]                             invokeRestart(restart)
[13:23:11.112]                             muffled <- TRUE
[13:23:11.112]                             break
[13:23:11.112]                           }
[13:23:11.112]                         }
[13:23:11.112]                       }
[13:23:11.112]                       invisible(muffled)
[13:23:11.112]                     }
[13:23:11.112]                     muffleCondition(cond, pattern = "^muffle")
[13:23:11.112]                   }
[13:23:11.112]                 }
[13:23:11.112]                 else {
[13:23:11.112]                   if (TRUE) {
[13:23:11.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:11.112]                     {
[13:23:11.112]                       inherits <- base::inherits
[13:23:11.112]                       invokeRestart <- base::invokeRestart
[13:23:11.112]                       is.null <- base::is.null
[13:23:11.112]                       muffled <- FALSE
[13:23:11.112]                       if (inherits(cond, "message")) {
[13:23:11.112]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:11.112]                         if (muffled) 
[13:23:11.112]                           invokeRestart("muffleMessage")
[13:23:11.112]                       }
[13:23:11.112]                       else if (inherits(cond, "warning")) {
[13:23:11.112]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:11.112]                         if (muffled) 
[13:23:11.112]                           invokeRestart("muffleWarning")
[13:23:11.112]                       }
[13:23:11.112]                       else if (inherits(cond, "condition")) {
[13:23:11.112]                         if (!is.null(pattern)) {
[13:23:11.112]                           computeRestarts <- base::computeRestarts
[13:23:11.112]                           grepl <- base::grepl
[13:23:11.112]                           restarts <- computeRestarts(cond)
[13:23:11.112]                           for (restart in restarts) {
[13:23:11.112]                             name <- restart$name
[13:23:11.112]                             if (is.null(name)) 
[13:23:11.112]                               next
[13:23:11.112]                             if (!grepl(pattern, name)) 
[13:23:11.112]                               next
[13:23:11.112]                             invokeRestart(restart)
[13:23:11.112]                             muffled <- TRUE
[13:23:11.112]                             break
[13:23:11.112]                           }
[13:23:11.112]                         }
[13:23:11.112]                       }
[13:23:11.112]                       invisible(muffled)
[13:23:11.112]                     }
[13:23:11.112]                     muffleCondition(cond, pattern = "^muffle")
[13:23:11.112]                   }
[13:23:11.112]                 }
[13:23:11.112]             }
[13:23:11.112]         }))
[13:23:11.112]     }, error = function(ex) {
[13:23:11.112]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:11.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:11.112]                 ...future.rng), started = ...future.startTime, 
[13:23:11.112]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:11.112]             version = "1.8"), class = "FutureResult")
[13:23:11.112]     }, finally = {
[13:23:11.112]         if (!identical(...future.workdir, getwd())) 
[13:23:11.112]             setwd(...future.workdir)
[13:23:11.112]         {
[13:23:11.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:11.112]                 ...future.oldOptions$nwarnings <- NULL
[13:23:11.112]             }
[13:23:11.112]             base::options(...future.oldOptions)
[13:23:11.112]             if (.Platform$OS.type == "windows") {
[13:23:11.112]                 old_names <- names(...future.oldEnvVars)
[13:23:11.112]                 envs <- base::Sys.getenv()
[13:23:11.112]                 names <- names(envs)
[13:23:11.112]                 common <- intersect(names, old_names)
[13:23:11.112]                 added <- setdiff(names, old_names)
[13:23:11.112]                 removed <- setdiff(old_names, names)
[13:23:11.112]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:11.112]                   envs[common]]
[13:23:11.112]                 NAMES <- toupper(changed)
[13:23:11.112]                 args <- list()
[13:23:11.112]                 for (kk in seq_along(NAMES)) {
[13:23:11.112]                   name <- changed[[kk]]
[13:23:11.112]                   NAME <- NAMES[[kk]]
[13:23:11.112]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:11.112]                     next
[13:23:11.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:11.112]                 }
[13:23:11.112]                 NAMES <- toupper(added)
[13:23:11.112]                 for (kk in seq_along(NAMES)) {
[13:23:11.112]                   name <- added[[kk]]
[13:23:11.112]                   NAME <- NAMES[[kk]]
[13:23:11.112]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:11.112]                     next
[13:23:11.112]                   args[[name]] <- ""
[13:23:11.112]                 }
[13:23:11.112]                 NAMES <- toupper(removed)
[13:23:11.112]                 for (kk in seq_along(NAMES)) {
[13:23:11.112]                   name <- removed[[kk]]
[13:23:11.112]                   NAME <- NAMES[[kk]]
[13:23:11.112]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:11.112]                     next
[13:23:11.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:11.112]                 }
[13:23:11.112]                 if (length(args) > 0) 
[13:23:11.112]                   base::do.call(base::Sys.setenv, args = args)
[13:23:11.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:11.112]             }
[13:23:11.112]             else {
[13:23:11.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:11.112]             }
[13:23:11.112]             {
[13:23:11.112]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:11.112]                   0L) {
[13:23:11.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:11.112]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:11.112]                   base::options(opts)
[13:23:11.112]                 }
[13:23:11.112]                 {
[13:23:11.112]                   {
[13:23:11.112]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:11.112]                     NULL
[13:23:11.112]                   }
[13:23:11.112]                   options(future.plan = NULL)
[13:23:11.112]                   if (is.na(NA_character_)) 
[13:23:11.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:11.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:11.112]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:11.112]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:11.112]                     envir = parent.frame()) 
[13:23:11.112]                   {
[13:23:11.112]                     if (is.function(workers)) 
[13:23:11.112]                       workers <- workers()
[13:23:11.112]                     workers <- structure(as.integer(workers), 
[13:23:11.112]                       class = class(workers))
[13:23:11.112]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:11.112]                       workers >= 1)
[13:23:11.112]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:11.112]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:11.112]                     }
[13:23:11.112]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:11.112]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:11.112]                       envir = envir)
[13:23:11.112]                     if (!future$lazy) 
[13:23:11.112]                       future <- run(future)
[13:23:11.112]                     invisible(future)
[13:23:11.112]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:11.112]                 }
[13:23:11.112]             }
[13:23:11.112]         }
[13:23:11.112]     })
[13:23:11.112]     if (TRUE) {
[13:23:11.112]         base::sink(type = "output", split = FALSE)
[13:23:11.112]         if (TRUE) {
[13:23:11.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:11.112]         }
[13:23:11.112]         else {
[13:23:11.112]             ...future.result["stdout"] <- base::list(NULL)
[13:23:11.112]         }
[13:23:11.112]         base::close(...future.stdout)
[13:23:11.112]         ...future.stdout <- NULL
[13:23:11.112]     }
[13:23:11.112]     ...future.result$conditions <- ...future.conditions
[13:23:11.112]     ...future.result$finished <- base::Sys.time()
[13:23:11.112]     ...future.result
[13:23:11.112] }
[13:23:11.115] MultisessionFuture started
[13:23:11.115] - Launch lazy future ... done
[13:23:11.115] run() for ‘MultisessionFuture’ ... done
[13:23:11.116] getGlobalsAndPackages() ...
[13:23:11.116] Searching for globals...
[13:23:11.117] - globals found: [1] ‘{’
[13:23:11.117] Searching for globals ... DONE
[13:23:11.117] Resolving globals: FALSE
[13:23:11.117] 
[13:23:11.117] 
[13:23:11.118] getGlobalsAndPackages() ... DONE
[13:23:11.118] run() for ‘Future’ ...
[13:23:11.118] - state: ‘created’
[13:23:11.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:11.133] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:11.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:11.134]   - Field: ‘node’
[13:23:11.134]   - Field: ‘label’
[13:23:11.134]   - Field: ‘local’
[13:23:11.134]   - Field: ‘owner’
[13:23:11.134]   - Field: ‘envir’
[13:23:11.134]   - Field: ‘workers’
[13:23:11.135]   - Field: ‘packages’
[13:23:11.135]   - Field: ‘gc’
[13:23:11.135]   - Field: ‘conditions’
[13:23:11.135]   - Field: ‘persistent’
[13:23:11.135]   - Field: ‘expr’
[13:23:11.135]   - Field: ‘uuid’
[13:23:11.135]   - Field: ‘seed’
[13:23:11.135]   - Field: ‘version’
[13:23:11.136]   - Field: ‘result’
[13:23:11.136]   - Field: ‘asynchronous’
[13:23:11.136]   - Field: ‘calls’
[13:23:11.136]   - Field: ‘globals’
[13:23:11.136]   - Field: ‘stdout’
[13:23:11.136]   - Field: ‘earlySignal’
[13:23:11.136]   - Field: ‘lazy’
[13:23:11.137]   - Field: ‘state’
[13:23:11.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:11.137] - Launch lazy future ...
[13:23:11.137] Packages needed by the future expression (n = 0): <none>
[13:23:11.138] Packages needed by future strategies (n = 0): <none>
[13:23:11.138] {
[13:23:11.138]     {
[13:23:11.138]         {
[13:23:11.138]             ...future.startTime <- base::Sys.time()
[13:23:11.138]             {
[13:23:11.138]                 {
[13:23:11.138]                   {
[13:23:11.138]                     {
[13:23:11.138]                       base::local({
[13:23:11.138]                         has_future <- base::requireNamespace("future", 
[13:23:11.138]                           quietly = TRUE)
[13:23:11.138]                         if (has_future) {
[13:23:11.138]                           ns <- base::getNamespace("future")
[13:23:11.138]                           version <- ns[[".package"]][["version"]]
[13:23:11.138]                           if (is.null(version)) 
[13:23:11.138]                             version <- utils::packageVersion("future")
[13:23:11.138]                         }
[13:23:11.138]                         else {
[13:23:11.138]                           version <- NULL
[13:23:11.138]                         }
[13:23:11.138]                         if (!has_future || version < "1.8.0") {
[13:23:11.138]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:11.138]                             "", base::R.version$version.string), 
[13:23:11.138]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:11.138]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:11.138]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:11.138]                               "release", "version")], collapse = " "), 
[13:23:11.138]                             hostname = base::Sys.info()[["nodename"]])
[13:23:11.138]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:11.138]                             info)
[13:23:11.138]                           info <- base::paste(info, collapse = "; ")
[13:23:11.138]                           if (!has_future) {
[13:23:11.138]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:11.138]                               info)
[13:23:11.138]                           }
[13:23:11.138]                           else {
[13:23:11.138]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:11.138]                               info, version)
[13:23:11.138]                           }
[13:23:11.138]                           base::stop(msg)
[13:23:11.138]                         }
[13:23:11.138]                       })
[13:23:11.138]                     }
[13:23:11.138]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:11.138]                     base::options(mc.cores = 1L)
[13:23:11.138]                   }
[13:23:11.138]                   options(future.plan = NULL)
[13:23:11.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:11.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:11.138]                 }
[13:23:11.138]                 ...future.workdir <- getwd()
[13:23:11.138]             }
[13:23:11.138]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:11.138]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:11.138]         }
[13:23:11.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:11.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:11.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:11.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:11.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:11.138]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:11.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:11.138]             base::names(...future.oldOptions))
[13:23:11.138]     }
[13:23:11.138]     if (FALSE) {
[13:23:11.138]     }
[13:23:11.138]     else {
[13:23:11.138]         if (TRUE) {
[13:23:11.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:11.138]                 open = "w")
[13:23:11.138]         }
[13:23:11.138]         else {
[13:23:11.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:11.138]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:11.138]         }
[13:23:11.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:11.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:11.138]             base::sink(type = "output", split = FALSE)
[13:23:11.138]             base::close(...future.stdout)
[13:23:11.138]         }, add = TRUE)
[13:23:11.138]     }
[13:23:11.138]     ...future.frame <- base::sys.nframe()
[13:23:11.138]     ...future.conditions <- base::list()
[13:23:11.138]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:11.138]     if (FALSE) {
[13:23:11.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:11.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:11.138]     }
[13:23:11.138]     ...future.result <- base::tryCatch({
[13:23:11.138]         base::withCallingHandlers({
[13:23:11.138]             ...future.value <- base::withVisible(base::local({
[13:23:11.138]                 ...future.makeSendCondition <- base::local({
[13:23:11.138]                   sendCondition <- NULL
[13:23:11.138]                   function(frame = 1L) {
[13:23:11.138]                     if (is.function(sendCondition)) 
[13:23:11.138]                       return(sendCondition)
[13:23:11.138]                     ns <- getNamespace("parallel")
[13:23:11.138]                     if (exists("sendData", mode = "function", 
[13:23:11.138]                       envir = ns)) {
[13:23:11.138]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:11.138]                         envir = ns)
[13:23:11.138]                       envir <- sys.frame(frame)
[13:23:11.138]                       master <- NULL
[13:23:11.138]                       while (!identical(envir, .GlobalEnv) && 
[13:23:11.138]                         !identical(envir, emptyenv())) {
[13:23:11.138]                         if (exists("master", mode = "list", envir = envir, 
[13:23:11.138]                           inherits = FALSE)) {
[13:23:11.138]                           master <- get("master", mode = "list", 
[13:23:11.138]                             envir = envir, inherits = FALSE)
[13:23:11.138]                           if (inherits(master, c("SOCKnode", 
[13:23:11.138]                             "SOCK0node"))) {
[13:23:11.138]                             sendCondition <<- function(cond) {
[13:23:11.138]                               data <- list(type = "VALUE", value = cond, 
[13:23:11.138]                                 success = TRUE)
[13:23:11.138]                               parallel_sendData(master, data)
[13:23:11.138]                             }
[13:23:11.138]                             return(sendCondition)
[13:23:11.138]                           }
[13:23:11.138]                         }
[13:23:11.138]                         frame <- frame + 1L
[13:23:11.138]                         envir <- sys.frame(frame)
[13:23:11.138]                       }
[13:23:11.138]                     }
[13:23:11.138]                     sendCondition <<- function(cond) NULL
[13:23:11.138]                   }
[13:23:11.138]                 })
[13:23:11.138]                 withCallingHandlers({
[13:23:11.138]                   {
[13:23:11.138]                     4
[13:23:11.138]                   }
[13:23:11.138]                 }, immediateCondition = function(cond) {
[13:23:11.138]                   sendCondition <- ...future.makeSendCondition()
[13:23:11.138]                   sendCondition(cond)
[13:23:11.138]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:11.138]                   {
[13:23:11.138]                     inherits <- base::inherits
[13:23:11.138]                     invokeRestart <- base::invokeRestart
[13:23:11.138]                     is.null <- base::is.null
[13:23:11.138]                     muffled <- FALSE
[13:23:11.138]                     if (inherits(cond, "message")) {
[13:23:11.138]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:11.138]                       if (muffled) 
[13:23:11.138]                         invokeRestart("muffleMessage")
[13:23:11.138]                     }
[13:23:11.138]                     else if (inherits(cond, "warning")) {
[13:23:11.138]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:11.138]                       if (muffled) 
[13:23:11.138]                         invokeRestart("muffleWarning")
[13:23:11.138]                     }
[13:23:11.138]                     else if (inherits(cond, "condition")) {
[13:23:11.138]                       if (!is.null(pattern)) {
[13:23:11.138]                         computeRestarts <- base::computeRestarts
[13:23:11.138]                         grepl <- base::grepl
[13:23:11.138]                         restarts <- computeRestarts(cond)
[13:23:11.138]                         for (restart in restarts) {
[13:23:11.138]                           name <- restart$name
[13:23:11.138]                           if (is.null(name)) 
[13:23:11.138]                             next
[13:23:11.138]                           if (!grepl(pattern, name)) 
[13:23:11.138]                             next
[13:23:11.138]                           invokeRestart(restart)
[13:23:11.138]                           muffled <- TRUE
[13:23:11.138]                           break
[13:23:11.138]                         }
[13:23:11.138]                       }
[13:23:11.138]                     }
[13:23:11.138]                     invisible(muffled)
[13:23:11.138]                   }
[13:23:11.138]                   muffleCondition(cond)
[13:23:11.138]                 })
[13:23:11.138]             }))
[13:23:11.138]             future::FutureResult(value = ...future.value$value, 
[13:23:11.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:11.138]                   ...future.rng), globalenv = if (FALSE) 
[13:23:11.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:11.138]                     ...future.globalenv.names))
[13:23:11.138]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:11.138]         }, condition = base::local({
[13:23:11.138]             c <- base::c
[13:23:11.138]             inherits <- base::inherits
[13:23:11.138]             invokeRestart <- base::invokeRestart
[13:23:11.138]             length <- base::length
[13:23:11.138]             list <- base::list
[13:23:11.138]             seq.int <- base::seq.int
[13:23:11.138]             signalCondition <- base::signalCondition
[13:23:11.138]             sys.calls <- base::sys.calls
[13:23:11.138]             `[[` <- base::`[[`
[13:23:11.138]             `+` <- base::`+`
[13:23:11.138]             `<<-` <- base::`<<-`
[13:23:11.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:11.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:11.138]                   3L)]
[13:23:11.138]             }
[13:23:11.138]             function(cond) {
[13:23:11.138]                 is_error <- inherits(cond, "error")
[13:23:11.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:11.138]                   NULL)
[13:23:11.138]                 if (is_error) {
[13:23:11.138]                   sessionInformation <- function() {
[13:23:11.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:11.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:11.138]                       search = base::search(), system = base::Sys.info())
[13:23:11.138]                   }
[13:23:11.138]                   ...future.conditions[[length(...future.conditions) + 
[13:23:11.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:11.138]                     cond$call), session = sessionInformation(), 
[13:23:11.138]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:11.138]                   signalCondition(cond)
[13:23:11.138]                 }
[13:23:11.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:11.138]                 "immediateCondition"))) {
[13:23:11.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:11.138]                   ...future.conditions[[length(...future.conditions) + 
[13:23:11.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:11.138]                   if (TRUE && !signal) {
[13:23:11.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:11.138]                     {
[13:23:11.138]                       inherits <- base::inherits
[13:23:11.138]                       invokeRestart <- base::invokeRestart
[13:23:11.138]                       is.null <- base::is.null
[13:23:11.138]                       muffled <- FALSE
[13:23:11.138]                       if (inherits(cond, "message")) {
[13:23:11.138]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:11.138]                         if (muffled) 
[13:23:11.138]                           invokeRestart("muffleMessage")
[13:23:11.138]                       }
[13:23:11.138]                       else if (inherits(cond, "warning")) {
[13:23:11.138]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:11.138]                         if (muffled) 
[13:23:11.138]                           invokeRestart("muffleWarning")
[13:23:11.138]                       }
[13:23:11.138]                       else if (inherits(cond, "condition")) {
[13:23:11.138]                         if (!is.null(pattern)) {
[13:23:11.138]                           computeRestarts <- base::computeRestarts
[13:23:11.138]                           grepl <- base::grepl
[13:23:11.138]                           restarts <- computeRestarts(cond)
[13:23:11.138]                           for (restart in restarts) {
[13:23:11.138]                             name <- restart$name
[13:23:11.138]                             if (is.null(name)) 
[13:23:11.138]                               next
[13:23:11.138]                             if (!grepl(pattern, name)) 
[13:23:11.138]                               next
[13:23:11.138]                             invokeRestart(restart)
[13:23:11.138]                             muffled <- TRUE
[13:23:11.138]                             break
[13:23:11.138]                           }
[13:23:11.138]                         }
[13:23:11.138]                       }
[13:23:11.138]                       invisible(muffled)
[13:23:11.138]                     }
[13:23:11.138]                     muffleCondition(cond, pattern = "^muffle")
[13:23:11.138]                   }
[13:23:11.138]                 }
[13:23:11.138]                 else {
[13:23:11.138]                   if (TRUE) {
[13:23:11.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:11.138]                     {
[13:23:11.138]                       inherits <- base::inherits
[13:23:11.138]                       invokeRestart <- base::invokeRestart
[13:23:11.138]                       is.null <- base::is.null
[13:23:11.138]                       muffled <- FALSE
[13:23:11.138]                       if (inherits(cond, "message")) {
[13:23:11.138]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:11.138]                         if (muffled) 
[13:23:11.138]                           invokeRestart("muffleMessage")
[13:23:11.138]                       }
[13:23:11.138]                       else if (inherits(cond, "warning")) {
[13:23:11.138]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:11.138]                         if (muffled) 
[13:23:11.138]                           invokeRestart("muffleWarning")
[13:23:11.138]                       }
[13:23:11.138]                       else if (inherits(cond, "condition")) {
[13:23:11.138]                         if (!is.null(pattern)) {
[13:23:11.138]                           computeRestarts <- base::computeRestarts
[13:23:11.138]                           grepl <- base::grepl
[13:23:11.138]                           restarts <- computeRestarts(cond)
[13:23:11.138]                           for (restart in restarts) {
[13:23:11.138]                             name <- restart$name
[13:23:11.138]                             if (is.null(name)) 
[13:23:11.138]                               next
[13:23:11.138]                             if (!grepl(pattern, name)) 
[13:23:11.138]                               next
[13:23:11.138]                             invokeRestart(restart)
[13:23:11.138]                             muffled <- TRUE
[13:23:11.138]                             break
[13:23:11.138]                           }
[13:23:11.138]                         }
[13:23:11.138]                       }
[13:23:11.138]                       invisible(muffled)
[13:23:11.138]                     }
[13:23:11.138]                     muffleCondition(cond, pattern = "^muffle")
[13:23:11.138]                   }
[13:23:11.138]                 }
[13:23:11.138]             }
[13:23:11.138]         }))
[13:23:11.138]     }, error = function(ex) {
[13:23:11.138]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:11.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:11.138]                 ...future.rng), started = ...future.startTime, 
[13:23:11.138]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:11.138]             version = "1.8"), class = "FutureResult")
[13:23:11.138]     }, finally = {
[13:23:11.138]         if (!identical(...future.workdir, getwd())) 
[13:23:11.138]             setwd(...future.workdir)
[13:23:11.138]         {
[13:23:11.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:11.138]                 ...future.oldOptions$nwarnings <- NULL
[13:23:11.138]             }
[13:23:11.138]             base::options(...future.oldOptions)
[13:23:11.138]             if (.Platform$OS.type == "windows") {
[13:23:11.138]                 old_names <- names(...future.oldEnvVars)
[13:23:11.138]                 envs <- base::Sys.getenv()
[13:23:11.138]                 names <- names(envs)
[13:23:11.138]                 common <- intersect(names, old_names)
[13:23:11.138]                 added <- setdiff(names, old_names)
[13:23:11.138]                 removed <- setdiff(old_names, names)
[13:23:11.138]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:11.138]                   envs[common]]
[13:23:11.138]                 NAMES <- toupper(changed)
[13:23:11.138]                 args <- list()
[13:23:11.138]                 for (kk in seq_along(NAMES)) {
[13:23:11.138]                   name <- changed[[kk]]
[13:23:11.138]                   NAME <- NAMES[[kk]]
[13:23:11.138]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:11.138]                     next
[13:23:11.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:11.138]                 }
[13:23:11.138]                 NAMES <- toupper(added)
[13:23:11.138]                 for (kk in seq_along(NAMES)) {
[13:23:11.138]                   name <- added[[kk]]
[13:23:11.138]                   NAME <- NAMES[[kk]]
[13:23:11.138]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:11.138]                     next
[13:23:11.138]                   args[[name]] <- ""
[13:23:11.138]                 }
[13:23:11.138]                 NAMES <- toupper(removed)
[13:23:11.138]                 for (kk in seq_along(NAMES)) {
[13:23:11.138]                   name <- removed[[kk]]
[13:23:11.138]                   NAME <- NAMES[[kk]]
[13:23:11.138]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:11.138]                     next
[13:23:11.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:11.138]                 }
[13:23:11.138]                 if (length(args) > 0) 
[13:23:11.138]                   base::do.call(base::Sys.setenv, args = args)
[13:23:11.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:11.138]             }
[13:23:11.138]             else {
[13:23:11.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:11.138]             }
[13:23:11.138]             {
[13:23:11.138]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:11.138]                   0L) {
[13:23:11.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:11.138]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:11.138]                   base::options(opts)
[13:23:11.138]                 }
[13:23:11.138]                 {
[13:23:11.138]                   {
[13:23:11.138]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:11.138]                     NULL
[13:23:11.138]                   }
[13:23:11.138]                   options(future.plan = NULL)
[13:23:11.138]                   if (is.na(NA_character_)) 
[13:23:11.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:11.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:11.138]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:11.138]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:11.138]                     envir = parent.frame()) 
[13:23:11.138]                   {
[13:23:11.138]                     if (is.function(workers)) 
[13:23:11.138]                       workers <- workers()
[13:23:11.138]                     workers <- structure(as.integer(workers), 
[13:23:11.138]                       class = class(workers))
[13:23:11.138]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:11.138]                       workers >= 1)
[13:23:11.138]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:11.138]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:11.138]                     }
[13:23:11.138]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:11.138]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:11.138]                       envir = envir)
[13:23:11.138]                     if (!future$lazy) 
[13:23:11.138]                       future <- run(future)
[13:23:11.138]                     invisible(future)
[13:23:11.138]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:11.138]                 }
[13:23:11.138]             }
[13:23:11.138]         }
[13:23:11.138]     })
[13:23:11.138]     if (TRUE) {
[13:23:11.138]         base::sink(type = "output", split = FALSE)
[13:23:11.138]         if (TRUE) {
[13:23:11.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:11.138]         }
[13:23:11.138]         else {
[13:23:11.138]             ...future.result["stdout"] <- base::list(NULL)
[13:23:11.138]         }
[13:23:11.138]         base::close(...future.stdout)
[13:23:11.138]         ...future.stdout <- NULL
[13:23:11.138]     }
[13:23:11.138]     ...future.result$conditions <- ...future.conditions
[13:23:11.138]     ...future.result$finished <- base::Sys.time()
[13:23:11.138]     ...future.result
[13:23:11.138] }
[13:23:11.141] Poll #1 (0): usedNodes() = 2, workers = 2
[13:23:11.152] receiveMessageFromWorker() for ClusterFuture ...
[13:23:11.152] - Validating connection of MultisessionFuture
[13:23:11.152] - received message: FutureResult
[13:23:11.152] - Received FutureResult
[13:23:11.153] - Erased future from FutureRegistry
[13:23:11.153] result() for ClusterFuture ...
[13:23:11.153] - result already collected: FutureResult
[13:23:11.153] result() for ClusterFuture ... done
[13:23:11.153] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:11.153] result() for ClusterFuture ...
[13:23:11.153] - result already collected: FutureResult
[13:23:11.153] result() for ClusterFuture ... done
[13:23:11.153] result() for ClusterFuture ...
[13:23:11.153] - result already collected: FutureResult
[13:23:11.154] result() for ClusterFuture ... done
[13:23:11.155] MultisessionFuture started
[13:23:11.155] - Launch lazy future ... done
[13:23:11.155] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x5596d6741b38> 
Classes 'listenv', 'environment' <environment: 0x5596d7596240> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[13:23:11.166] receiveMessageFromWorker() for ClusterFuture ...
[13:23:11.166] - Validating connection of MultisessionFuture
[13:23:11.166] - received message: FutureResult
[13:23:11.166] - Received FutureResult
[13:23:11.166] - Erased future from FutureRegistry
[13:23:11.167] result() for ClusterFuture ...
[13:23:11.167] - result already collected: FutureResult
[13:23:11.167] result() for ClusterFuture ... done
[13:23:11.167] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[13:23:11.181] resolve() on list environment ...
[13:23:11.181]  recursive: 0
[13:23:11.182]  length: 6
[13:23:11.182]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[13:23:11.182] signalConditionsASAP(numeric, pos=1) ...
[13:23:11.182] - nx: 6
[13:23:11.182] - relay: TRUE
[13:23:11.182] - stdout: TRUE
[13:23:11.182] - signal: TRUE
[13:23:11.182] - resignal: FALSE
[13:23:11.183] - force: TRUE
[13:23:11.183] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.183] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.183]  - until=2
[13:23:11.183]  - relaying element #2
[13:23:11.183] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.183] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.183] signalConditionsASAP(NULL, pos=1) ... done
[13:23:11.183]  length: 5 (resolved future 1)
[13:23:11.183] Future #2
[13:23:11.184] result() for ClusterFuture ...
[13:23:11.184] - result already collected: FutureResult
[13:23:11.184] result() for ClusterFuture ... done
[13:23:11.184] result() for ClusterFuture ...
[13:23:11.184] - result already collected: FutureResult
[13:23:11.184] result() for ClusterFuture ... done
[13:23:11.184] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:23:11.184] - nx: 6
[13:23:11.184] - relay: TRUE
[13:23:11.184] - stdout: TRUE
[13:23:11.185] - signal: TRUE
[13:23:11.185] - resignal: FALSE
[13:23:11.185] - force: TRUE
[13:23:11.185] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.185] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[13:23:11.185]  - until=2
[13:23:11.185]  - relaying element #2
[13:23:11.185] result() for ClusterFuture ...
[13:23:11.185] - result already collected: FutureResult
[13:23:11.185] result() for ClusterFuture ... done
[13:23:11.185] result() for ClusterFuture ...
[13:23:11.185] - result already collected: FutureResult
[13:23:11.186] result() for ClusterFuture ... done
[13:23:11.186] result() for ClusterFuture ...
[13:23:11.186] - result already collected: FutureResult
[13:23:11.186] result() for ClusterFuture ... done
[13:23:11.186] result() for ClusterFuture ...
[13:23:11.186] - result already collected: FutureResult
[13:23:11.186] result() for ClusterFuture ... done
[13:23:11.186] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:11.186] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:11.186] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:23:11.187]  length: 4 (resolved future 2)
[13:23:11.187] Future #3
[13:23:11.187] result() for ClusterFuture ...
[13:23:11.187] - result already collected: FutureResult
[13:23:11.187] result() for ClusterFuture ... done
[13:23:11.187] result() for ClusterFuture ...
[13:23:11.187] - result already collected: FutureResult
[13:23:11.187] result() for ClusterFuture ... done
[13:23:11.187] signalConditionsASAP(MultisessionFuture, pos=3) ...
[13:23:11.187] - nx: 6
[13:23:11.187] - relay: TRUE
[13:23:11.187] - stdout: TRUE
[13:23:11.188] - signal: TRUE
[13:23:11.188] - resignal: FALSE
[13:23:11.188] - force: TRUE
[13:23:11.188] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:11.188] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[13:23:11.188]  - until=3
[13:23:11.188]  - relaying element #3
[13:23:11.188] result() for ClusterFuture ...
[13:23:11.188] - result already collected: FutureResult
[13:23:11.188] result() for ClusterFuture ... done
[13:23:11.189] result() for ClusterFuture ...
[13:23:11.189] - result already collected: FutureResult
[13:23:11.189] result() for ClusterFuture ... done
[13:23:11.189] result() for ClusterFuture ...
[13:23:11.189] - result already collected: FutureResult
[13:23:11.189] result() for ClusterFuture ... done
[13:23:11.189] result() for ClusterFuture ...
[13:23:11.189] - result already collected: FutureResult
[13:23:11.189] result() for ClusterFuture ... done
[13:23:11.189] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.189] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.190] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[13:23:11.190]  length: 3 (resolved future 3)
[13:23:11.200] signalConditionsASAP(NULL, pos=5) ...
[13:23:11.201] - nx: 6
[13:23:11.201] - relay: TRUE
[13:23:11.201] - stdout: TRUE
[13:23:11.201] - signal: TRUE
[13:23:11.201] - resignal: FALSE
[13:23:11.201] - force: TRUE
[13:23:11.202] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.202] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.202]  - until=6
[13:23:11.202]  - relaying element #4
[13:23:11.202]  - relaying element #6
[13:23:11.202] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:11.202] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.202] signalConditionsASAP(NULL, pos=5) ... done
[13:23:11.202]  length: 2 (resolved future 5)
[13:23:11.203] signalConditionsASAP(numeric, pos=6) ...
[13:23:11.203] - nx: 6
[13:23:11.203] - relay: TRUE
[13:23:11.203] - stdout: TRUE
[13:23:11.203] - signal: TRUE
[13:23:11.203] - resignal: FALSE
[13:23:11.203] - force: TRUE
[13:23:11.203] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[13:23:11.203] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.203]  - until=6
[13:23:11.203]  - relaying element #4
[13:23:11.203] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:11.204] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.204] signalConditionsASAP(NULL, pos=6) ... done
[13:23:11.204]  length: 1 (resolved future 6)
[13:23:11.215] receiveMessageFromWorker() for ClusterFuture ...
[13:23:11.215] - Validating connection of MultisessionFuture
[13:23:11.215] - received message: FutureResult
[13:23:11.215] - Received FutureResult
[13:23:11.215] - Erased future from FutureRegistry
[13:23:11.215] result() for ClusterFuture ...
[13:23:11.216] - result already collected: FutureResult
[13:23:11.216] result() for ClusterFuture ... done
[13:23:11.216] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:11.216] Future #4
[13:23:11.216] result() for ClusterFuture ...
[13:23:11.216] - result already collected: FutureResult
[13:23:11.216] result() for ClusterFuture ... done
[13:23:11.216] result() for ClusterFuture ...
[13:23:11.216] - result already collected: FutureResult
[13:23:11.217] result() for ClusterFuture ... done
[13:23:11.217] signalConditionsASAP(MultisessionFuture, pos=4) ...
[13:23:11.217] - nx: 6
[13:23:11.217] - relay: TRUE
[13:23:11.217] - stdout: TRUE
[13:23:11.217] - signal: TRUE
[13:23:11.217] - resignal: FALSE
[13:23:11.217] - force: TRUE
[13:23:11.217] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[13:23:11.217] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[13:23:11.217]  - until=6
[13:23:11.218]  - relaying element #4
[13:23:11.218] result() for ClusterFuture ...
[13:23:11.218] - result already collected: FutureResult
[13:23:11.218] result() for ClusterFuture ... done
[13:23:11.218] result() for ClusterFuture ...
[13:23:11.218] - result already collected: FutureResult
[13:23:11.218] result() for ClusterFuture ... done
[13:23:11.218] result() for ClusterFuture ...
[13:23:11.218] - result already collected: FutureResult
[13:23:11.218] result() for ClusterFuture ... done
[13:23:11.219] result() for ClusterFuture ...
[13:23:11.219] - result already collected: FutureResult
[13:23:11.219] result() for ClusterFuture ... done
[13:23:11.219] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:11.219] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:11.219] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[13:23:11.219]  length: 0 (resolved future 4)
[13:23:11.219] Relaying remaining futures
[13:23:11.219] signalConditionsASAP(NULL, pos=0) ...
[13:23:11.219] - nx: 6
[13:23:11.219] - relay: TRUE
[13:23:11.220] - stdout: TRUE
[13:23:11.220] - signal: TRUE
[13:23:11.220] - resignal: FALSE
[13:23:11.220] - force: TRUE
[13:23:11.220] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:11.220] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[13:23:11.220] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[13:23:11.220] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[13:23:11.220] signalConditionsASAP(NULL, pos=0) ... done
[13:23:11.220] resolve() on list environment ... DONE
[13:23:11.221] result() for ClusterFuture ...
[13:23:11.221] - result already collected: FutureResult
[13:23:11.221] result() for ClusterFuture ... done
[13:23:11.221] result() for ClusterFuture ...
[13:23:11.221] - result already collected: FutureResult
[13:23:11.221] result() for ClusterFuture ... done
[13:23:11.221] result() for ClusterFuture ...
[13:23:11.221] - result already collected: FutureResult
[13:23:11.221] result() for ClusterFuture ... done
[13:23:11.221] result() for ClusterFuture ...
[13:23:11.222] - result already collected: FutureResult
[13:23:11.222] result() for ClusterFuture ... done
[13:23:11.222] result() for ClusterFuture ...
[13:23:11.222] - result already collected: FutureResult
[13:23:11.222] result() for ClusterFuture ... done
[13:23:11.222] result() for ClusterFuture ...
[13:23:11.222] - result already collected: FutureResult
[13:23:11.222] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x5596d59a1c90> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[13:23:11.225] plan(): Setting new future strategy stack:
[13:23:11.225] List of future strategies:
[13:23:11.225] 1. FutureStrategy:
[13:23:11.225]    - args: function (..., envir = parent.frame())
[13:23:11.225]    - tweaked: FALSE
[13:23:11.225]    - call: future::plan(oplan)
[13:23:11.226] plan(): nbrOfWorkers() = 1
> 
